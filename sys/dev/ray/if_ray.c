begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_ray.c,v 1.12 2000/02/07 09:36:27 augustss Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2000 Christian E. Hopps  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Card configuration  * ==================  *  * This card is unusual in that it uses both common and attribute  * memory whilst working. It should use common memory and an IO port.  *  * The bus resource allocations need to work around the brain deadness  * of pccardd (where it reads the CIS for common memory, sets it all  * up and then throws it all away assuming the card is an ed  * driver...). Note that this could be dangerous (because it doesn't  * interact with pccardd) if you use other memory mapped cards in the  * same pccard slot as currently old mappings are not cleaned up very well  * by the bus_release_resource methods or pccardd.  * XXX Are these workarounds necessary with NEWCARD?  *  * Ad-hoc and infra-structure modes  * ================================  *   * The driver supports ad-hoc mode for V4 firmware and infrastructure  * mode for V5 firmware. V5 firmware in ad-hoc mode is untested and should  * work.  *  * The Linux driver also seems to have the capability to act as an AP.  * I wonder what facilities the "AP" can provide within a driver? We can  * probably use the BRIDGE code to form an ESS but I don't think  * power saving etc. is easy.  *  *  * Packet framing/encapsulation/translation  * ========================================  *   * Currently we support the Webgear encapsulation:  *	802.11	header<net/if_ieee80211.h>struct ieee80211_frame  *	802.3	header<net/ethernet.h>struct ether_header  *	IP/ARP	payload  *  * and RFC1042 encapsulation of IP datagrams (translation):  *	802.11	header<net/if_ieee80211.h>struct ieee80211_frame  *	802.2	LLC header  *	802.2	SNAP header  *	802.3	Ethertype  *	IP/ARP	payload  *  * Framing should be selected via if_media stuff or link types but  * is currently hardcoded to:  *	V4	encapsulation  *	V5	translation  *  *  * Authentication  * ==============  *  * 802.11 provides two authentication mechanisms. The first is a very  * simple host based mechanism (like xhost) called Open System and the  * second is a more complex challenge/response called Shared Key built  * ontop of WEP.  *  * This driver only supports Open System and does not implement any  * host based control lists. In otherwords authentication is always  * granted to hosts wanting to authenticate with this station. This is  * the only sensible behaviour as the Open System mechanism uses MAC  * addresses to identify hosts. Send me patches if you need it!  */
end_comment

begin_comment
comment|/*  * ***check all XXX_INFRA code - reassoc not done well at all!  * ***watchdog to catch screwed up removals?  * ***error handling of RAY_COM_RUNQ  * ***error handling of ECF command completions  * ***can't seem to create a n/w that Win95 wants to see.  * ***remove panic in ray_com_ecf by re-quing or timeout  * ***use new ioctl stuff - probably need to change RAY_COM_FCHKRUNNING things?  * 	consider user doing:  *		ifconfig ray0 192.168.200.38 -bssid "freed"  *		ifconfig ray0 192.168.200.38 -bssid "fred"  * 	here the second one would be missed in this code  * check that v5 needs timeouts on ecf commands  * write up driver structure in comments above  * UPDATE_PARAMS seems to return via an interrupt - maybe the timeout  *	is needed for wrong values?  * proper setting of mib_hop_seq_len with country code for v4 firmware  *	best done with raycontrol?  * countrycode setting is broken I think  *	userupdate should trap and do via startjoin etc.  * fragmentation when rx level drops?  * v5 might not need download  *	defaults are as documented apart from hop_seq_length  *	settings are sane for ad-hoc not infra  *  * driver state  *	most state is implied by the sequence of commands in the runq  *	but in fact any of the rx and tx path that uses variables  *	in the sc_c are potentially going to get screwed?  *  * infra mode stuff  * 	proper handling of the basic rate set - see the manual  *	all ray_sj, ray_assoc sequencues need a "nicer" solution as we  *		remember association and authentication  *	need to consider WEP  *	acting as ap - should be able to get working from the manual  *	need to finish RAY_ECMD_REJOIN_DONE  *	finish authenitcation code, it doesn't handle errors/timeouts/  *	REJOIN etc.  *  * ray_nw_param  *	promisc in here too? - done  *	should be able to update the parameters before we download to the  *		device. This means we must attach a desired struct to the  *		runq entry and maybe have another big case statement to  *		move these desired into current when not running.  *		init must then use the current settings (pre-loaded  *		in attach now!) and pass to download. But we can't access  *		current nw params outside of the runq - ahhh  * 	differeniate between parameters set in attach and init  * 	sc_station_addr in here too (for changing mac address)  * 	move desired into the command structure?  *	take downloaded MIB from a complete nw_param?  *	longer term need to attach a desired nw params to the runq entry  *  *  * RAY_COM_RUNQ errors  *  * if sleeping in ccs_alloc with eintr/erestart/enxio/enodev  *	erestart	try again from the top  *			XXX do not malloc more comqs  *			XXX ccs allocation hard  *	eintr		clean up and return  *	enxio		clean up and return - done in macro  *  * if sleeping in runq_arr itself with eintr/erestart/enxio/enodev  *	erestart	try again from the top  *			XXX do not malloc more comqs  *			XXX ccs allocation hard  *			XXX reinsert comqs at head of list  *	eintr		clean up and return  *	enxio		clean up and return - done in macro  */
end_comment

begin_define
define|#
directive|define
name|XXX
value|0
end_define

begin_define
define|#
directive|define
name|XXX_ACTING_AP
value|0
end_define

begin_define
define|#
directive|define
name|XXX_INFRA
value|0
end_define

begin_define
define|#
directive|define
name|RAY_DEBUG
value|(				\
comment|/* RAY_DBG_AUTH		| */
value|\
comment|/* RAY_DBG_SUBR		| */
value|\
comment|/* RAY_DBG_BOOTPARAM	| */
value|\
comment|/* RAY_DBG_STARTJOIN	| */
value|\
comment|/* RAY_DBG_CCS		| */
value|\
comment|/* RAY_DBG_IOCTL	| */
value|\
comment|/* RAY_DBG_MBUF		| */
value|\
comment|/* RAY_DBG_RX		| */
value|\
comment|/* RAY_DBG_CM		| */
value|\
comment|/* RAY_DBG_COM		| */
value|\
comment|/* RAY_DBG_STOP		| */
value|\
comment|/* RAY_DBG_CTL		| */
value|\
comment|/* RAY_DBG_MGT		| */
value|\
comment|/* RAY_DBG_TX		| */
value|\
comment|/* RAY_DBG_DCOM		| */
value|\ 			0				\ 			)
end_define

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_define
define|#
directive|define
name|RAY_CM_RID
value|0
end_define

begin_comment
comment|/* pccardd abuses windows 0 and 1 */
end_comment

begin_define
define|#
directive|define
name|RAY_AM_RID
value|3
end_define

begin_comment
comment|/* pccardd abuses windows 0 and 1 */
end_comment

begin_define
define|#
directive|define
name|RAY_COM_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for CCS commands */
end_comment

begin_define
define|#
directive|define
name|RAY_TX_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for rescheduling TX */
end_comment

begin_define
define|#
directive|define
name|RAY_ECF_SPIN_DELAY
value|1000
end_define

begin_comment
comment|/* Wait 1ms before checking ECF ready */
end_comment

begin_define
define|#
directive|define
name|RAY_ECF_SPIN_TRIES
value|10
end_define

begin_comment
comment|/* Wait this many times for ECF ready */
end_comment

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|0x0000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_rayreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_raymib.h>
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_raydbg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_rayvar.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_RAYCOM
argument_list|,
literal|"raycom"
argument_list|,
literal|"Raylink command queue entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prototyping  */
end_comment

begin_function_decl
specifier|static
name|int
name|ray_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_ccs_alloc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_ccs_fill
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_ccs_free
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_ccs_tx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|size_t
modifier|*
name|bufpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_ecf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_ecf_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_ecf_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ray_comq_entry
modifier|*
name|ray_com_init
parameter_list|(
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|,
name|ray_comqfn_t
name|function
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ray_comq_entry
modifier|*
name|ray_com_malloc
parameter_list|(
name|ray_comqfn_t
name|function
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_runq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_com_runq_add
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[]
parameter_list|,
name|int
name|ncom
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_runq_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_init_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_assoc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_assoc_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_auth
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_init_auth_send
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|,
name|int
name|sequence
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_auth_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_download
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_download_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_download_v4
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_download_v5
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_sj
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_sj_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_intr_ccs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|cmd
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_intr_rcs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|cmd
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_intr_updt_errcntrs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_mcast_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_mcast_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_promisc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_repparams
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_repparams_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_repparams_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_repstats_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_stats_req
modifier|*
name|sr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_res_alloc_am
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_res_alloc_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_res_alloc_irq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_res_release
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|rcs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_ctl
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_data
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int8_t
name|siglev
parameter_list|,
name|u_int8_t
name|antenna
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_mgt
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_mgt_auth
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_mgt_beacon
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_mgt_info
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|union
name|ieee80211_information
modifier|*
name|elements
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_update_cache
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|src
parameter_list|,
name|u_int8_t
name|siglev
parameter_list|,
name|u_int8_t
name|antenna
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_stop
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_stop_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_tx
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_tx_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_tx_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_tx_send
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|int
name|pktlen
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|ray_tx_wrhdr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|bufp
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int8_t
name|fc1
parameter_list|,
name|u_int8_t
modifier|*
name|addr1
parameter_list|,
name|u_int8_t
modifier|*
name|addr2
parameter_list|,
name|u_int8_t
modifier|*
name|addr3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_upparams
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_upparams_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_upparams_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|ray_tx_best_antenna
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
end_if

begin_function_decl
specifier|static
name|void
name|ray_com_ecf_check
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_COM */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_MBUF
end_if

begin_function_decl
specifier|static
name|void
name|ray_dump_mbuf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_MBUF */
end_comment

begin_comment
comment|/*  * PC Card (PCMCIA) driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ray_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ray_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ray_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ray_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ray_driver
init|=
block|{
literal|"ray"
block|,
name|ray_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ray_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ray_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ray
argument_list|,
name|pccard
argument_list|,
name|ray_driver
argument_list|,
name|ray_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   * Probe for the card by checking its startup results.  *  * Fixup any bugs/quirks for different firmware.  */
end_comment

begin_function
specifier|static
name|int
name|ray_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
init|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Read startup results from the card. 	 */
name|error
operator|=
name|ray_res_alloc_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ray_res_alloc_am
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Check the card is okay and work out what version we are using. 	 */
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"card failed self test 0x%b"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
name|RAY_ECFS_PRINTFB
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unsupported firmware version 0x%0x"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_BOOTPARAM
argument_list|,
literal|"found a card"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_gone
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Fixup tib size to be correct - on build 4 it is garbage 	 */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_tibsize
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_tibsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_tib
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the card into the kernel  */
end_comment

begin_function
specifier|static
name|int
name|ray_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
init|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_gone
operator|)
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Grab the resources I need 	 */
name|error
operator|=
name|ray_res_alloc_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ray_res_alloc_am
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ray_res_alloc_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Reset any pending interrupts 	 */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Set the parameters that will survive stop/init and 	 * reset a few things on the card. 	 * 	 * Do not update these in ray_init_download's parameter setup 	 * 	 */
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_d
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_c
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear statistics counters */
name|sc
operator|->
name|sc_rxoverflow
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxcksum
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxhcksum
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxnoise
operator|=
literal|0
expr_stmt|;
comment|/* Clear signal and antenna cache */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_siglevs
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_siglevs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set all ccs to be free */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|)
argument_list|)
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_CCS_LAST
condition|;
name|ccs
operator|+=
name|RAY_CCS_SIZE
operator|,
name|i
operator|++
control|)
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the network interface structure 	 */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator||
name|IFF_NEEDSGIANT
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000
expr_stmt|;
comment|/* Is this baud or bps ;-) */
name|ifp
operator|->
name|if_start
operator|=
name|ray_tx
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ray_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ray_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ray_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the timers and driver 	 */
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|tx_timerh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
comment|/* 	 * Print out some useful information 	 */
if|if
condition|(
name|bootverbose
operator|||
operator|(
name|RAY_DEBUG
operator|&
name|RAY_DBG_BOOTPARAM
operator|)
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"start up results"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|printf
argument_list|(
literal|".  Firmware version 4\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|".  Firmware version 5\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Status 0x%b\n"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
name|RAY_ECFS_PRINTFB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Ether address %6D\n"
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|printf
argument_list|(
literal|".  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_rates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|".  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Supported rates %8D\n"
argument_list|,
name|ep
operator|->
name|e_rates
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".  Japan call sign %12D\n"
argument_list|,
name|ep
operator|->
name|e_japan_callsign
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|".  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_prg_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_cis_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Firmware version %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Firmware revision %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_resv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  ASIC version %0x\n"
argument_list|,
name|ep
operator|->
name|e_asic_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  TIB size %0x\n"
argument_list|,
name|ep
operator|->
name|e_tibsize
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach the card  *  * This is usually called when the card is ejected, but  * can be caused by a modunload of a controller driver.  * The idea is to reset the driver's view of the device  * and ensure that any driver entry points such as  * read and write do not hang.  */
end_comment

begin_function
specifier|static
name|int
name|ray_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STOP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_gone
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Mark as not running and detach the interface. 	 * 	 * N.B. if_detach can trigger ioctls so we do it first and 	 * then clean the runq. 	 */
name|sc
operator|->
name|sc_gone
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_c
operator|.
name|np_havenet
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the runq and wake up anyone sleeping for us. 	 */
name|untimeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_tx_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|tx_timerh
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|com
argument_list|,
argument|&sc->sc_comq
argument_list|,
argument|c_chain
argument_list|)
block|{
name|com
operator|->
name|c_flags
operator||=
name|RAY_COM_FDETACHED
expr_stmt|;
name|com
operator|->
name|c_retval
operator|=
literal|0
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STOP
argument_list|,
literal|"looking at com %p %b"
argument_list|,
name|com
argument_list|,
name|com
operator|->
name|c_flags
argument_list|,
name|RAY_COM_FLAGS_PRINTFB
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FWOK
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STOP
argument_list|,
literal|"waking com %p"
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|com
operator|->
name|c_wakeup
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Release resources 	 */
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STOP
argument_list|,
literal|"unloading complete"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Network ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ray_param_req
name|pr
decl_stmt|;
name|struct
name|ray_stats_req
name|sr
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|error2
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_IOCTL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_gone
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|error2
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SIFFLAGS 0x%0x"
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
comment|/* 		 * If the interface is marked up we call ray_init_user. 		 * This will deal with mcast and promisc flags as well as 		 * initialising the hardware if it needs it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|error
operator|=
name|ray_init_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ray_stop_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"ADDMULTI/DELMULTI"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_mcast_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSRAYPARAM
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SRAYPARAM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ray_upparams_user
argument_list|(
name|sc
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|pr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYPARAM
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYPARAM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ray_repparams_user
argument_list|(
name|sc
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|pr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYSTATS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYSTATS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_repstats_user
argument_list|(
name|sc
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|sr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYSIGLEV
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYSIGLEV"
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|sc_siglevs
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_siglevs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFFLAGS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMETRIC
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMETRIC"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMTU"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFPHYS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFPYHS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SIFMEDIA"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMEDIA"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"OTHER (pass to ether)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ethernet layer entry to ray_init - discard errors  */
end_comment

begin_function
specifier|static
name|void
name|ray_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ray_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|ray_init_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User land entry to network initialisation and changes in interface flags.  *   * We do a very little work here, just creating runq entries to  * processes the actions needed to cope with interface flags. We do it  * this way in case there are runq entries outstanding from earlier  * ioctls that modify the interface flags.  *  * Returns values are either 0 for success, a varity of resource allocation  * failures or errors in the command sent to the card.  *  * Note, IFF_DRV_RUNNING is eventually set by init_sj_done or init_assoc_done  */
end_comment

begin_function
specifier|static
name|int
name|ray_init_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|6
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ncom
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Create the following runq entries to bring the card up. 	 * 	 *		init_download	- download the network to the card 	 *		init_mcast	- reset multicast list 	 *		init_sj		- find or start a BSS 	 *		init_auth	- authenticate with an ESSID if needed 	 *		init_assoc	- associate with an ESSID if needed 	 * 	 * They are only actually executed if the card is not running. 	 * We may enter this routine from a simple change of IP 	 * address and do not need to get the card to do these things. 	 * However, we cannot perform the check here as there may be 	 * commands in the runq that change the IFF_DRV_RUNNING state of 	 * the interface. 	 */
name|ncom
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_download
argument_list|,
name|RAY_COM_FCHKRUNNING
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_mcast
argument_list|,
name|RAY_COM_FCHKRUNNING
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_sj
argument_list|,
name|RAY_COM_FCHKRUNNING
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_auth
argument_list|,
name|RAY_COM_FCHKRUNNING
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_assoc
argument_list|,
name|RAY_COM_FCHKRUNNING
argument_list|)
expr_stmt|;
comment|/* 	 * Create runq entries to process flags 	 * 	 *		promisc		- set/reset PROMISC and ALLMULTI flags 	 * 	 * They are only actually executed if the card is running 	 */
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_promisc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAY_COM_RUNQ
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"rayinit"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX no real error processing from anything yet! */
name|RAY_COM_FREE
argument_list|(
name|com
argument_list|,
name|ncom
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry for resetting driver and downloading start up structures to card  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_download
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* If the card already running we might not need to download */
name|RAY_COM_CHKRUNNING
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Reset instance variables 	 * 	 * The first set are network parameters that are read back when 	 * the card starts or joins the network. 	 * 	 * The second set are network parameters that are downloaded to 	 * the card. 	 * 	 * The third set are driver parameters. 	 * 	 * All of the variables in these sets can be updated by the 	 * card or ioctls. 	 * 	 */
name|sc
operator|->
name|sc_d
operator|.
name|np_upd_param
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_bss_id
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_inited
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
operator|=
name|RAY_MIB_BASIC_RATE_SET_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|=
name|RAY_MIB_NET_TYPE_V4
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|RAY_MIB_SSID_V4
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
operator|=
name|RAY_MIB_AP_STATUS_V4
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_framing
operator|=
name|RAY_FRAMING_ENCAPSULATION
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|=
name|RAY_MIB_NET_TYPE_V5
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|RAY_MIB_SSID_V5
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
operator|=
name|RAY_MIB_AP_STATUS_V5
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_framing
operator|=
name|RAY_FRAMING_TRANSLATION
expr_stmt|;
block|}
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
operator|=
name|RAY_MIB_PRIVACY_CAN_JOIN_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_promisc
operator|=
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
comment|/* XXX this is a hack whilst I transition the code. The instance  * XXX variables above should be set somewhere else. This is needed for  * XXX start_join */
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|sc_d
argument_list|,
operator|&
name|com
operator|->
name|c_desired
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Download the right firmware defaults 	 */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|ray_init_download_v4
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
else|else
name|ray_init_download_v5
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
comment|/* 	 * Kick the card 	 */
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_DOWNLOAD_PARAMS
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PUT2
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do { (p)[0] = ((v>> 8)& 0xff); (p)[1] = (v& 0xff); } while(0)
end_define

begin_comment
comment|/*  * Firmware version 4 defaults - see if_raymib.h for details  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_download_v4
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ray_mib_4
name|ray_mib_4_default
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
define|#
directive|define
name|MIB4
parameter_list|(
name|m
parameter_list|)
value|ray_mib_4_default.m
name|MIB4
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_net_type
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_ap_status
expr_stmt|;
name|bcopy
argument_list|(
name|com
operator|->
name|c_desired
operator|.
name|np_ssid
argument_list|,
name|MIB4
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_V4
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB4
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V4
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_promisc
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_max
argument_list|)
operator|=
name|RAY_MIB_CW_MAX_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_min
argument_list|)
operator|=
name|RAY_MIB_CW_MIN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
undef|#
directive|undef
name|MIB4
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_4_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_4_default
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Firmware version 5 defaults - see if_raymib.h for details  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_download_v5
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ray_mib_5
name|ray_mib_5_default
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
define|#
directive|define
name|MIB5
parameter_list|(
name|m
parameter_list|)
value|ray_mib_5_default.m
name|MIB5
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_net_type
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_ap_status
expr_stmt|;
name|bcopy
argument_list|(
name|com
operator|->
name|c_desired
operator|.
name|np_ssid
argument_list|,
name|MIB5
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_V5
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB5
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_promisc
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_max
argument_list|)
argument_list|,
name|RAY_MIB_CW_MAX_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_min
argument_list|)
argument_list|,
name|RAY_MIB_CW_MIN_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_allow_probe_resp
argument_list|)
operator|=
name|RAY_MIB_ALLOW_PROBE_RESP_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_must_start
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_priv_start
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_can_join
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_priv_join
expr_stmt|;
name|MIB5
argument_list|(
name|mib_basic_rate_set
index|[
literal|0
index|]
argument_list|)
operator|=
name|com
operator|->
name|c_desired
operator|.
name|np_def_txrate
expr_stmt|;
undef|#
directive|undef
name|MIB5
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_5_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_5_default
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|PUT2
end_undef

begin_comment
comment|/*  * Download completion routine  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_download_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_CCSERR
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|if_oerrors
argument_list|)
expr_stmt|;
comment|/* XXX error counter */
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to empty the multicast filter list  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If the card already running we might not need to reset the list */
name|RAY_COM_CHKRUNNING
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Kick the card 	 */
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_UPDATE_MCAST
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update_mcast
argument_list|,
name|c_nmcast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to starting or joining a network  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_sj
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ray_net_params
name|np
decl_stmt|;
name|int
name|update
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If the card already running we might not need to start the n/w */
name|RAY_COM_CHKRUNNING
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the right start or join command and determine 	 * whether we should tell the card about a change in operating 	 * parameters. 	 */
name|sc
operator|->
name|sc_c
operator|.
name|np_havenet
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_START_NET
argument_list|)
expr_stmt|;
else|else
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_JOIN_NET
argument_list|)
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_join
operator|!=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_start
operator|!=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
condition|)
name|update
operator|++
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STARTJOIN
argument_list|,
literal|"%s updating nw params"
argument_list|,
name|update
condition|?
literal|"is"
else|:
literal|"not"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|.
name|p_net_type
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|np
operator|.
name|p_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|np
operator|.
name|p_privacy_must_start
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
name|np
operator|.
name|p_privacy_can_join
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Kick the card 	 */
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete start command or intermediate step in assoc command  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_sj_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_CCSERR
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|if_oerrors
argument_list|)
expr_stmt|;
comment|/* XXX error counter */
comment|/* 	 * Read back network parameters that the ECF sets 	 */
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
operator|&
name|sc
operator|->
name|sc_c
operator|.
name|p_1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_cmd_net
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust values for buggy firmware */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_inited
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_inited
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
expr_stmt|;
comment|/* 	 * Update our local state if we updated the network parameters 	 * when the START_NET or JOIN_NET was issued. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_upd_param
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STARTJOIN
argument_list|,
literal|"updated parameters"
argument_list|)
expr_stmt|;
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|sc
operator|->
name|sc_c
operator|.
name|p_2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_net_params
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Hurrah! The network is now active. 	 * 	 * Clearing IFF_DRV_OACTIVE will ensure that the system will send us 	 * packets. Just before we return from the interrupt context 	 * we check to see if packets have been queued. 	 */
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
operator|==
name|RAY_CMD_START_NET
condition|)
block|{
name|sc
operator|->
name|sc_c
operator|.
name|np_havenet
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_c
operator|.
name|np_framing
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_framing
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to authenticate with an access point or another station  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_auth
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
operator||
name|RAY_DBG_AUTH
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* If card already running we might not need to authenticate */
name|RAY_COM_CHKRUNNING
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Don't do anything if we are not in a managed network 	 * 	 * XXX V4 adhoc does not need this, V5 adhoc unknown 	 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|RAY_MIB_NET_TYPE_INFRA
condition|)
block|{
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * XXX_AUTH need to think of run queue when doing auths from request i.e. would  * XXX_AUTH need to have auth at top of runq?  * XXX_AUTH ditto for sending any auth response packets...what about timeouts?  */
comment|/* 	 * Kick the card 	 */
comment|/* XXX_AUTH check exit status and retry or fail as we can't associate without this */
name|ray_init_auth_send
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|IEEE80211_AUTH_OPEN_REQUEST
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Build and send an authentication packet  *  * If an error occurs, returns 1 else returns 0.  */
end_comment

begin_function
specifier|static
name|int
name|ray_init_auth_send
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|,
name|int
name|sequence
parameter_list|)
block|{
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|pktlen
init|=
literal|0
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
operator||
name|RAY_DBG_AUTH
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get a control block */
if|if
condition|(
name|ray_ccs_tx
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
operator|&
name|bufp
argument_list|)
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"could not obtain a ccs"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Fill the header in */
name|bufp
operator|=
name|ray_tx_wrhdr
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_AUTH
argument_list|,
name|IEEE80211_FC1_DIR_NODS
argument_list|,
name|dst
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|)
expr_stmt|;
comment|/* Add algorithm number */
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|bufp
operator|+
name|pktlen
operator|++
argument_list|,
name|IEEE80211_AUTH_ALG_OPEN
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|bufp
operator|+
name|pktlen
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add sequence number */
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|bufp
operator|+
name|pktlen
operator|++
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|bufp
operator|+
name|pktlen
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add status code */
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|bufp
operator|+
name|pktlen
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|bufp
operator|+
name|pktlen
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
return|return
operator|(
name|ray_tx_send
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|pktlen
argument_list|,
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Complete authentication runq  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_auth_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
operator||
name|RAY_DBG_AUTH
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IEEE80211_STATUS_SUCCESS
condition|)
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"authentication failed with status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/*  * XXX_AUTH retry? if not just recall ray_init_auth_send and dont clear runq?  * XXX_AUTH association requires that authenitcation is successful  * XXX_AUTH before we associate, and the runq is the only way to halt the  * XXX_AUTH progress of associate.  * XXX_AUTH In this case I might not need the RAY_AUTH_NEEDED state  */
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to starting an association with an access point  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_assoc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* If the card already running we might not need to associate */
name|RAY_COM_CHKRUNNING
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Don't do anything if we are not in a managed network 	 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|RAY_MIB_NET_TYPE_INFRA
condition|)
block|{
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Kick the card 	 */
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_START_ASSOC
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete association  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_assoc_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_CCSERR
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|if_oerrors
argument_list|)
expr_stmt|;
comment|/* XXX error counter */
comment|/* 	 * Hurrah! The network is now active. 	 * 	 * Clearing IFF_DRV_OACTIVE will ensure that the system will send us 	 * packets. Just before we return from the interrupt context 	 * we check to see if packets have been queued. 	 */
name|sc
operator|->
name|sc_c
operator|.
name|np_havenet
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_c
operator|.
name|np_framing
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_framing
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Network stop.  *  * Inhibit card - if we can't prevent reception then do not worry;  * stopping a NIC only guarantees no TX.  *  * The change to the interface flags is done via the runq so that any  * existing commands can execute normally.  */
end_comment

begin_function
specifier|static
name|int
name|ray_stop_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ncom
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STOP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule the real stop routine 	 */
name|ncom
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_stop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAY_COM_RUNQ
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"raystop"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX no real error processing from anything yet! */
name|RAY_COM_FREE
argument_list|(
name|com
argument_list|,
name|ncom
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry for stopping the interface activity  */
end_comment

begin_function
specifier|static
name|void
name|ray_stop
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STOP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Mark as not running and drain output queue 	 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_gone
operator|)
condition|)
return|return;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"watchdog timeout"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit packet handling  */
end_comment

begin_comment
comment|/*  * Send a packet.  *  * We make two assumptions here:  *  1) That the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) That the IFF_DRV_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  *  * A simple one packet at a time TX routine is used - we don't bother  * chaining TX buffers. Performance is sufficient to max out the  * wireless link on a P75.  *  * AST J30 Windows 95A (100MHz Pentium) to  *   Libretto 50CT FreeBSD-3.1 (75MHz Pentium)		167.37kB/s  *   Nonname box FreeBSD-3.4 (233MHz AMD K6)		161.82kB/s  *  * Libretto 50CT FreeBSD-3.1 (75MHz Pentium) to  *   AST J30 Windows 95A (100MHz Pentium) 		167.37kB/s  *   Nonname box FreeBSD-3.4 (233MHz AMD K6)		161.38kB/s  *  * Given that 160kB/s is saturating the 2Mb/s wireless link we  * are about there.  *  * In short I'm happy that the added complexity of chaining TX  * packets together isn't worth it for my machines.  */
end_comment

begin_function
specifier|static
name|void
name|ray_tx
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|pktlen
decl_stmt|,
name|len
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Some simple checks first - some are overkill 	 */
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_gone
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"cannot transmit - not running"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_c
operator|.
name|np_havenet
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"cannot transmit - no network"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Can't assume that the ECF is busy because of this driver */
if|if
condition|(
operator|(
name|sc
operator|->
name|tx_timerh
operator|.
name|callout
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|callout_active
argument_list|(
name|sc
operator|->
name|tx_timerh
operator|.
name|callout
argument_list|)
operator|)
condition|)
block|{
name|sc
operator|->
name|tx_timerh
operator|=
name|timeout
argument_list|(
name|ray_tx_timo
argument_list|,
name|sc
argument_list|,
name|RAY_TX_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|untimeout
argument_list|(
name|ray_tx_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|tx_timerh
argument_list|)
expr_stmt|;
comment|/* 	 * We find a ccs before we process the mbuf so that we are sure it 	 * is worthwhile processing the packet. All errors in the mbuf 	 * processing are either errors in the mbuf or gross configuration 	 * errors and the packet wouldn't get through anyway. 	 */
if|if
condition|(
name|ray_ccs_tx
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
operator|&
name|bufp
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the mbuf and process it - we have to remember to free the 	 * ccs if there are any errors. 	 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return;
block|}
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pktlen
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"mbuf too long %d"
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
name|m0
operator|=
name|m_pullup
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"could not pullup ether"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Write the 802.11 header according to network type etc. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
name|bufp
operator|=
name|ray_tx_wrhdr
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
argument_list|,
name|IEEE80211_FC1_DIR_NODS
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|==
name|RAY_MIB_AP_STATUS_TERMINAL
condition|)
name|bufp
operator|=
name|ray_tx_wrhdr
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
argument_list|,
name|IEEE80211_FC1_DIR_TODS
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
else|else
name|bufp
operator|=
name|ray_tx_wrhdr
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
argument_list|,
name|IEEE80211_FC1_DIR_FROMDS
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|)
expr_stmt|;
comment|/* 	 * Framing 	 * 	 * Add to the mbuf. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_framing
condition|)
block|{
case|case
name|RAY_FRAMING_ENCAPSULATION
case|:
comment|/* Nice and easy - nothing! (just add an 802.11 header) */
break|break;
case|case
name|RAY_FRAMING_TRANSLATION
case|:
comment|/* 		 * Drop the first address in the ethernet header and 		 * write an LLC and SNAP header over the second. 		 */
name|m_adj
argument_list|(
name|m0
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"could not get space for 802.2 header"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|llc
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unknown framing type %d"
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_framing
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"could not frame packet"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_TX
argument_list|,
name|m0
argument_list|,
literal|"framed packet"
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the mbuf to the buffer in common memory 	 * 	 * We drop and don't bother wrapping as Ethernet packets are 1518 	 * bytes, we checked the mbuf earlier, and our TX buffers are 2048 	 * bytes. We don't have 530 bytes of headers etc. so something 	 * must be fubar. 	 */
name|pktlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bufp
operator|+
name|len
operator|)
operator|<
name|RAY_TX_END
condition|)
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"tx buffer overflow"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 * Send it off 	 */
if|if
condition|(
name|ray_tx_send
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|pktlen
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start timeout routine.  *  * Used when card was busy but we needed to send a packet.  */
end_comment

begin_function
specifier|static
name|void
name|ray_tx_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ray_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ray_tx
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write an 802.11 header into the Tx buffer space and return the  * adjusted buffer pointer.  */
end_comment

begin_function
specifier|static
name|size_t
name|ray_tx_wrhdr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|bufp
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int8_t
name|fc1
parameter_list|,
name|u_int8_t
modifier|*
name|addr1
parameter_list|,
name|u_int8_t
modifier|*
name|addr2
parameter_list|,
name|u_int8_t
modifier|*
name|addr3
parameter_list|)
block|{
name|struct
name|ieee80211_frame
name|header
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|)
expr_stmt|;
name|header
operator|.
name|i_fc
index|[
literal|0
index|]
operator|=
operator|(
name|IEEE80211_FC0_VERSION_0
operator||
name|type
operator|)
expr_stmt|;
name|header
operator|.
name|i_fc
index|[
literal|1
index|]
operator|=
name|fc1
expr_stmt|;
name|bcopy
argument_list|(
name|addr1
argument_list|,
name|header
operator|.
name|i_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addr2
argument_list|,
name|header
operator|.
name|i_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addr3
argument_list|,
name|header
operator|.
name|i_addr3
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bufp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in a few loose ends and kick the card to send the packet  *  * Returns 0 on success, 1 on failure  */
end_comment

begin_function
specifier|static
name|int
name|ray_tx_send
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|int
name|pktlen
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
name|RAY_ECF_SPIN_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
name|RAY_ECF_SPIN_TRIES
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"ECF busy, dropping packet"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"spun %d times"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_len
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_antenna
argument_list|,
name|ray_tx_best_antenna
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine best antenna to use from rx level and antenna cache  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ray_tx_best_antenna
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|ray_siglev
modifier|*
name|sl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int8_t
name|antenna
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* try to find host */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sl
operator|->
name|rsl_host
argument_list|,
name|dst
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* not found, return default setting */
return|return
operator|(
literal|0
operator|)
return|;
name|found
label|:
comment|/* This is a simple thresholding scheme that takes the mean 	 * of the best antenna history. This is okay but as it is a 	 * filter, it adds a bit of lag in situations where the 	 * best antenna swaps from one side to the other slowly. Don't know 	 * how likely this is given the horrible fading though. 	 */
name|antenna
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NANTENNA
condition|;
name|i
operator|++
control|)
block|{
name|antenna
operator|+=
name|sl
operator|->
name|rsl_antennas
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|antenna
operator|>
operator|(
name|RAY_NANTENNA
operator|>>
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit now complete so clear ccs and network flags.  */
end_comment

begin_function
specifier|static
name|void
name|ray_tx_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_CCSERR
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|if_oerrors
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receiver packet handling  */
end_comment

begin_comment
comment|/*  * Receive a packet from the card  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|rcs
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|header
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|size_t
name|pktlen
decl_stmt|,
name|fraglen
decl_stmt|,
name|readlen
decl_stmt|,
name|tmplen
decl_stmt|;
name|size_t
name|bufp
decl_stmt|,
name|ebufp
decl_stmt|;
name|u_int8_t
name|siglev
decl_stmt|,
name|antenna
decl_stmt|;
name|u_int
name|first
decl_stmt|,
name|ni
decl_stmt|,
name|i
decl_stmt|;
name|u_int8_t
modifier|*
name|mp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"using rcs 0x%x"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|readlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get first part of packet and the length. Do some sanity checks 	 * and get a mbuf. 	 */
name|first
operator|=
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_pktlen
argument_list|)
expr_stmt|;
name|siglev
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_siglev
argument_list|)
expr_stmt|;
name|antenna
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_antenna
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pktlen
operator|>
name|MCLBYTES
operator|)
operator|||
operator|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|)
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"packet too big or too small"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"MGETHDR failed"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"MCLGET failed"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pktlen
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
name|mp
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Walk the fragment chain to build the complete packet. 	 * 	 * The use of two index variables removes a race with the 	 * hardware. If one index were used the clearing of the CCS would 	 * happen before reading the next pointer and the hardware can get in. 	 * Not my idea but verbatim from the NetBSD driver. 	 */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_bufp
argument_list|)
expr_stmt|;
name|fraglen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fraglen
operator|+
name|readlen
operator|>
name|pktlen
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"bad length current 0x%zx pktlen 0x%zx"
argument_list|,
name|fraglen
operator|+
name|readlen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|RAY_RCS_FIRST
operator|)
operator|||
operator|(
name|i
operator|>
name|RAY_RCS_LAST
operator|)
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"bad rcs index 0x%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|ebufp
operator|=
name|bufp
operator|+
name|fraglen
expr_stmt|;
if|if
condition|(
name|ebufp
operator|<=
name|RAY_RX_END
condition|)
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|mp
argument_list|,
name|fraglen
argument_list|)
expr_stmt|;
else|else
block|{
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|mp
argument_list|,
operator|(
name|tmplen
operator|=
name|RAY_RX_END
operator|-
name|bufp
operator|)
argument_list|)
expr_stmt|;
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_RX_BASE
argument_list|,
name|mp
operator|+
name|tmplen
argument_list|,
name|ebufp
operator|-
name|RAY_RX_END
argument_list|)
expr_stmt|;
block|}
name|mp
operator|+=
name|fraglen
expr_stmt|;
name|readlen
operator|+=
name|fraglen
expr_stmt|;
block|}
name|skip_read
label|:
comment|/* 	 * Walk the chain again to free the rcss. 	 */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Check the 802.11 packet type and hand off to 	 * appropriate functions. 	 */
name|header
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"header not version 0 fc0 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|ray_rx_data
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
name|siglev
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|ray_rx_mgt
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|ray_rx_ctl
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unknown packet fc0 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Deal with DATA packet types  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_data
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int8_t
name|siglev
parameter_list|,
name|u_int8_t
name|antenna
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|u_int8_t
modifier|*
name|sa
init|=
name|NULL
decl_stmt|,
modifier|*
name|da
init|=
name|NULL
decl_stmt|,
modifier|*
name|ra
init|=
name|NULL
decl_stmt|,
modifier|*
name|ta
init|=
name|NULL
decl_stmt|;
name|int
name|trim
init|=
literal|0
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_RX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Check the the data packet subtype, some packets have 	 * nothing in them so we will drop them here. 	 */
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_DATA
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CF_ACK
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CF_POLL
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CF_ACPL
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"DATA packet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_NODATA
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CFACK
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CFPOLL
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CF_ACK_CF_ACK
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"NULL packet"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"reserved DATA packet subtype 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Parse the To DS and From DS fields to determine the length 	 * of the 802.11 header for use later on. 	 * 	 * Additionally, furtle out the right destination and 	 * source MAC addresses for the packet. Packets may come via 	 * APs so the MAC addresses of the immediate node may be 	 * different from the node that actually sent us the packet. 	 * 	 *	da	destination address of final recipient 	 *	sa	source address of orginator 	 *	ra	receiver address of immediate recipient 	 *	ta	transmitter address of immediate orginator 	 * 	 * Address matching is performed on da or sa with the AP or 	 * BSSID in ra and ta. 	 */
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
name|m0
argument_list|,
literal|"(1) packet before framing"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_DIR_NODS
case|:
name|da
operator|=
name|ra
operator|=
name|header
operator|->
name|i_addr1
expr_stmt|;
name|sa
operator|=
name|ta
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
name|trim
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"from %6D to %6D"
argument_list|,
name|sa
argument_list|,
literal|":"
argument_list|,
name|da
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_FROMDS
case|:
name|da
operator|=
name|ra
operator|=
name|header
operator|->
name|i_addr1
expr_stmt|;
name|ta
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
name|sa
operator|=
name|header
operator|->
name|i_addr3
expr_stmt|;
name|trim
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"ap %6D from %6D to %6D"
argument_list|,
name|ta
argument_list|,
literal|":"
argument_list|,
name|sa
argument_list|,
literal|":"
argument_list|,
name|da
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_TODS
case|:
name|ra
operator|=
name|header
operator|->
name|i_addr1
expr_stmt|;
name|sa
operator|=
name|ta
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
name|da
operator|=
name|header
operator|->
name|i_addr3
expr_stmt|;
name|trim
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"from %6D to %6D ap %6D"
argument_list|,
name|sa
argument_list|,
literal|":"
argument_list|,
name|da
argument_list|,
literal|":"
argument_list|,
name|ra
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_DSTODS
case|:
name|ra
operator|=
name|header
operator|->
name|i_addr1
expr_stmt|;
name|ta
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
name|da
operator|=
name|header
operator|->
name|i_addr3
expr_stmt|;
name|sa
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|header
operator|+
literal|1
expr_stmt|;
name|trim
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|+
name|ETHER_ADDR_LEN
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"from %6D to %6D ap %6D to %6D"
argument_list|,
name|sa
argument_list|,
literal|":"
argument_list|,
name|da
argument_list|,
literal|":"
argument_list|,
name|ta
argument_list|,
literal|":"
argument_list|,
name|ra
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Framing 	 * 	 * Each case must leave an Ethernet header and adjust trim. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_framing
condition|)
block|{
case|case
name|RAY_FRAMING_ENCAPSULATION
case|:
comment|/* A NOP as the Ethernet header is in the packet */
break|break;
case|case
name|RAY_FRAMING_TRANSLATION
case|:
comment|/* Check that we have an LLC and SNAP sequence */
name|llc
operator|=
operator|(
expr|struct
name|llc
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|header
operator|+
name|trim
operator|)
expr_stmt|;
if|if
condition|(
name|llc
operator|->
name|llc_dsap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc
operator|->
name|llc_ssap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc
operator|->
name|llc_control
operator|==
name|LLC_UI
operator|&&
name|llc
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|llc
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|llc
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
comment|/* 			 * This is not magic. RFC1042 header is 8 			 * bytes, with the last two bytes being the 			 * ether type. So all we need is another 			 * ETHER_ADDR_LEN bytes to write the 			 * destination into. 			 */
name|trim
operator|-=
name|ETHER_ADDR_LEN
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|header
operator|+
name|trim
operator|)
expr_stmt|;
comment|/* 			 * Copy carefully to avoid mashing the MAC 			 * addresses. The address layout in the .11 header 			 * does make sense, honest, but it is a pain. 			 *  			 * NODS  	da sa		no risk               			 * FROMDS	da ta sa	sa then da            			 * DSTODS	ra ta da sa	sa then da            			 * TODS		ra sa da	da then sa            			 */
if|if
condition|(
name|sa
operator|>
name|da
condition|)
block|{
comment|/* Copy sa first */
name|bcopy
argument_list|(
name|sa
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|da
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy da first */
name|bcopy
argument_list|(
name|da
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Assume RAY_FRAMING_ENCAPSULATION */
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"got encapsulated packet but in translation mode"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unknown framing type %d"
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_framing
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
name|m0
argument_list|,
literal|"(2) packet after framing"
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, do a bit of house keeping before sending the packet 	 * up the stack. 	 */
name|m_adj
argument_list|(
name|m0
argument_list|,
name|trim
argument_list|)
expr_stmt|;
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
name|m0
argument_list|,
literal|"(3) packet after trimming"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|ray_rx_update_cache
argument_list|(
name|sc
argument_list|,
name|header
operator|->
name|i_addr2
argument_list|,
name|siglev
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deal with MGT packet types  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_mgt
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_MGT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
operator|)
operator|!=
name|IEEE80211_FC1_DIR_NODS
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"MGT TODS/FROMDS wrong fc1 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check the the mgt packet subtype, some packets should be 	 * dropped depending on the mode the station is in. See pg 	 * 52(60) of docs 	 * 	 * P - proccess, J - Junk, E - ECF deals with, I - Illegal  	 * ECF Proccesses   	 *  AHDOC procces or junk    	 *   INFRA STA process or junk     	 *    INFRA AP process or jumk 	 *   	 * +PPP	IEEE80211_FC0_SUBTYPE_BEACON  	 * +EEE	IEEE80211_FC0_SUBTYPE_PROBE_REQ  	 * +EEE	IEEE80211_FC0_SUBTYPE_PROBE_RESP  	 *  PPP	IEEE80211_FC0_SUBTYPE_AUTH  	 *  PPP	IEEE80211_FC0_SUBTYPE_DEAUTH  	 *  JJP	IEEE80211_FC0_SUBTYPE_ASSOC_REQ  	 *  JPJ	IEEE80211_FC0_SUBTYPE_ASSOC_RESP  	 *  JPP	IEEE80211_FC0_SUBTYPE_DISASSOC  	 *  JJP	IEEE80211_FC0_SUBTYPE_REASSOC_REQ  	 *  JPJ	IEEE80211_FC0_SUBTYPE_REASSOC_RESP  	 * +EEE	IEEE80211_FC0_SUBTYPE_ATIM 	 */
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
name|m0
argument_list|,
literal|"MGT packet"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_BEACON
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"BEACON MGT packet"
argument_list|)
expr_stmt|;
name|ray_rx_mgt_beacon
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_AUTH
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"AUTH MGT packet"
argument_list|)
expr_stmt|;
name|ray_rx_mgt_auth
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DEAUTH
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"DEAUTH MGT packet"
argument_list|)
expr_stmt|;
comment|/* XXX ray_rx_mgt_deauth(sc, m0); */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"(RE)ASSOC_REQ MGT packet"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_INFRA
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|==
name|RAY_MIB_AP_STATUS_AP
operator|)
condition|)
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"can't be an AP yet"
argument_list|)
expr_stmt|;
comment|/* XXX_ACTING_AP */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_RESP
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"(RE)ASSOC_RESP MGT packet"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_INFRA
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|==
name|RAY_MIB_AP_STATUS_TERMINAL
operator|)
condition|)
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"can't be in INFRA yet"
argument_list|)
expr_stmt|;
comment|/* XXX_INFRA */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DISASSOC
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"DISASSOC MGT packet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_INFRA
condition|)
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"can't be in INFRA yet"
argument_list|)
expr_stmt|;
comment|/* XXX_INFRA */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_ATIM
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unexpected MGT packet subtype 0x%0x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"reserved MGT packet subtype 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deal with BEACON management packet types  * XXX furtle anything interesting out  * XXX Note that there are rules governing what beacons to read  * XXX see 8802 S7.2.3, S11.1.2.3  * XXX is this actually useful?  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_mgt_beacon
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|ieee80211_mgt_beacon_t
name|beacon
init|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|header
operator|+
literal|1
operator|)
decl_stmt|;
name|union
name|ieee80211_information
name|elements
decl_stmt|;
name|u_int64_t
modifier|*
name|timestamp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_MGT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|timestamp
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
name|beacon
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"timestamp\t0x%x"
argument_list|,
operator|*
name|timestamp
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"interval\t\t0x%x"
argument_list|,
name|IEEE80211_BEACON_INTERVAL
argument_list|(
name|beacon
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"capability\t0x%x"
argument_list|,
name|IEEE80211_BEACON_CAPABILITY
argument_list|(
name|beacon
argument_list|)
argument_list|)
expr_stmt|;
name|ray_rx_mgt_info
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
operator|&
name|elements
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_rx_mgt_info
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|union
name|ieee80211_information
modifier|*
name|elements
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|ieee80211_mgt_beacon_t
name|beacon
init|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|header
operator|+
literal|1
operator|)
decl_stmt|;
name|ieee80211_mgt_beacon_t
name|bp
decl_stmt|,
name|be
decl_stmt|;
name|int
name|len
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_MGT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bp
operator|=
name|beacon
operator|+
literal|12
expr_stmt|;
name|be
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_int8_t
operator|*
argument_list|)
operator|+
name|m0
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|be
condition|)
block|{
name|len
operator|=
operator|*
operator|(
name|bp
operator|+
literal|1
operator|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"id 0x%02x length %d"
argument_list|,
operator|*
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
name|IEEE80211_ELEMID_SSID
case|:
if|if
condition|(
name|len
operator|>
name|IEEE80211_NWID_LEN
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"bad SSD length: %d from %6D"
argument_list|,
name|len
argument_list|,
name|header
operator|->
name|i_addr2
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|elements
operator|->
name|ssid
argument_list|,
name|bp
operator|+
literal|2
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|elements
operator|->
name|ssid
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"beacon ssid %s"
argument_list|,
name|elements
operator|->
name|ssid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_RATES
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"rates"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_FHPARMS
case|:
name|elements
operator|->
name|fh
operator|.
name|dwell
operator|=
name|bp
index|[
literal|2
index|]
operator|+
operator|(
name|bp
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|elements
operator|->
name|fh
operator|.
name|set
operator|=
name|bp
index|[
literal|4
index|]
expr_stmt|;
name|elements
operator|->
name|fh
operator|.
name|pattern
operator|=
name|bp
index|[
literal|5
index|]
expr_stmt|;
name|elements
operator|->
name|fh
operator|.
name|index
operator|=
name|bp
index|[
literal|6
index|]
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"fhparams dwell\t0x%04x"
argument_list|,
name|elements
operator|->
name|fh
operator|.
name|dwell
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"fhparams set\t0x%02x"
argument_list|,
name|elements
operator|->
name|fh
operator|.
name|set
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"fhparams pattern\t0x%02x"
argument_list|,
name|elements
operator|->
name|fh
operator|.
name|pattern
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"fhparams index\t0x%02x"
argument_list|,
name|elements
operator|->
name|fh
operator|.
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_DSPARMS
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"got direct sequence params!"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_CFPARMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"cfparams"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_TIM
case|:
name|elements
operator|->
name|tim
operator|.
name|count
operator|=
name|bp
index|[
literal|2
index|]
expr_stmt|;
name|elements
operator|->
name|tim
operator|.
name|period
operator|=
name|bp
index|[
literal|3
index|]
expr_stmt|;
name|elements
operator|->
name|tim
operator|.
name|bitctl
operator|=
name|bp
index|[
literal|4
index|]
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"tim count\t0x%02x"
argument_list|,
name|elements
operator|->
name|tim
operator|.
name|count
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"tim period\t0x%02x"
argument_list|,
name|elements
operator|->
name|tim
operator|.
name|period
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"tim bitctl\t0x%02x"
argument_list|,
name|elements
operator|->
name|tim
operator|.
name|bitctl
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_MGT
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|<
name|len
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"tim pvt[%03d]\t0x%02x"
argument_list|,
name|i
operator|-
literal|5
argument_list|,
name|bp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (RAY_DEBUG& RAY_DBG_MGT) */
break|break;
case|case
name|IEEE80211_ELEMID_IBSSPARMS
case|:
name|elements
operator|->
name|ibss
operator|.
name|atim
operator|=
name|bp
index|[
literal|2
index|]
operator|+
operator|(
name|bp
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"ibssparams atim\t0x%02x"
argument_list|,
name|elements
operator|->
name|ibss
operator|.
name|atim
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_CHALLENGE
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"challenge"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"reserved MGT element id 0x%x"
argument_list|,
operator|*
name|bp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
break|break;
block|}
name|bp
operator|+=
name|bp
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Deal with AUTH management packet types  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_mgt_auth
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|ieee80211_mgt_auth_t
name|auth
init|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|header
operator|+
literal|1
operator|)
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_AUTH
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IEEE80211_AUTH_ALGORITHM
argument_list|(
name|auth
argument_list|)
condition|)
block|{
case|case
name|IEEE80211_AUTH_ALG_OPEN
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_AUTH
argument_list|,
literal|"open system authentication sequence number %d"
argument_list|,
name|IEEE80211_AUTH_TRANSACTION
argument_list|(
name|auth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_AUTH_TRANSACTION
argument_list|(
name|auth
argument_list|)
operator|==
name|IEEE80211_AUTH_OPEN_REQUEST
condition|)
block|{
comment|/* XXX_AUTH use ray_init_auth_send */
block|}
elseif|else
if|if
condition|(
name|IEEE80211_AUTH_TRANSACTION
argument_list|(
name|auth
argument_list|)
operator|==
name|IEEE80211_AUTH_OPEN_RESPONSE
condition|)
name|ray_init_auth_done
argument_list|(
name|sc
argument_list|,
name|IEEE80211_AUTH_STATUS
argument_list|(
name|auth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_AUTH_ALG_SHARED
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"shared key authentication sequence number %d"
argument_list|,
name|IEEE80211_AUTH_TRANSACTION
argument_list|(
name|auth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"reserved authentication subtype 0x%04hx"
argument_list|,
name|IEEE80211_AUTH_ALGORITHM
argument_list|(
name|auth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Deal with CTL packet types  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_ctl
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CTL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
operator|)
operator|!=
name|IEEE80211_FC1_DIR_NODS
condition|)
block|{
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"CTL TODS/FROMDS wrong fc1 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check the the ctl packet subtype, some packets should be 	 * dropped depending on the mode the station is in. The ECF 	 * should deal with everything but the power save poll to an 	 * AP. See pg 52(60) of docs. 	 */
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CTL
argument_list|,
name|m0
argument_list|,
literal|"CTL packet"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_PS_POLL
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CTL
argument_list|,
literal|"PS_POLL CTL packet"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_INFRA
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|==
name|RAY_MIB_AP_STATUS_AP
operator|)
condition|)
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"can't be an AP yet"
argument_list|)
expr_stmt|;
comment|/* XXX_ACTING_AP */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_RTS
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CTS
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_ACK
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CF_END
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CF_END_ACK
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unexpected CTL packet subtype 0x%0x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"reserved CTL packet subtype 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update rx level and antenna cache  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_update_cache
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|src
parameter_list|,
name|u_int8_t
name|siglev
parameter_list|,
name|u_int8_t
name|antenna
parameter_list|)
block|{
name|struct
name|timeval
name|mint
decl_stmt|;
name|struct
name|ray_siglev
modifier|*
name|sl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mini
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Try to find host */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sl
operator|->
name|rsl_host
argument_list|,
name|src
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* Not found, find oldest slot */
name|mini
operator|=
literal|0
expr_stmt|;
name|mint
operator|.
name|tv_sec
operator|=
name|LONG_MAX
expr_stmt|;
name|mint
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|sl
operator|->
name|rsl_time
argument_list|,
operator|&
name|mint
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|mini
operator|=
name|i
expr_stmt|;
name|mint
operator|=
name|sl
operator|->
name|rsl_time
expr_stmt|;
block|}
block|}
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|mini
index|]
expr_stmt|;
name|bzero
argument_list|(
name|sl
operator|->
name|rsl_siglevs
argument_list|,
name|RAY_NSIGLEV
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sl
operator|->
name|rsl_antennas
argument_list|,
name|RAY_NANTENNA
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|sl
operator|->
name|rsl_host
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|found
label|:
name|microtime
argument_list|(
operator|&
name|sl
operator|->
name|rsl_time
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sl
operator|->
name|rsl_siglevs
argument_list|,
operator|&
name|sl
operator|->
name|rsl_siglevs
index|[
literal|1
index|]
argument_list|,
name|RAY_NSIGLEV
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sl
operator|->
name|rsl_siglevs
index|[
literal|0
index|]
operator|=
name|siglev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|bcopy
argument_list|(
name|sl
operator|->
name|rsl_antennas
argument_list|,
operator|&
name|sl
operator|->
name|rsl_antennas
index|[
literal|1
index|]
argument_list|,
name|RAY_NANTENNA
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sl
operator|->
name|rsl_antennas
index|[
literal|0
index|]
operator|=
name|antenna
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Interrupt handling  */
end_comment

begin_comment
comment|/*  * Process an interrupt  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ray_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int8_t
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|int
name|ccsi
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_gone
operator|)
condition|)
return|return;
comment|/* 	 * Check that the interrupt was for us, if so get the rcs/ccs 	 * and vector on the command contained within it. 	 */
if|if
condition|(
name|RAY_HCS_INTR
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ccsi
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_RCSI
argument_list|)
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|ccsi
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccsi
operator|<=
name|RAY_CCS_LAST
condition|)
name|ray_intr_ccs
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|status
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ccsi
operator|<=
name|RAY_RCS_LAST
condition|)
name|ray_intr_rcs
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
else|else
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"bad ccs index 0x%x"
argument_list|,
name|ccsi
argument_list|)
expr_stmt|;
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Send any packets lying around and update error counters */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|ray_tx
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|sc
operator|->
name|sc_checkcounters
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|ray_intr_updt_errcntrs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the error counters.  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr_updt_errcntrs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|csc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The card implements the following protocol to keep the 	 * values from being changed while read: It checks the `own' 	 * bit and if zero writes the current internal counter value, 	 * it then sets the `own' bit to 1. If the `own' bit was 1 it 	 * incremenets its internal counter. The user thus reads the 	 * counter if the `own' bit is one and then sets the own bit 	 * to 0. 	 */
name|csc
operator|=
name|RAY_STATUS_BASE
expr_stmt|;
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxo_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxoverflow
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrx_overflow
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxo_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxc_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxcksum
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrx_overflow
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxc_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rxhc_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxhcksum
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rx_hcksum
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rxhc_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxnoise
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rx_noise
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process CCS command completion  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr_ccs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|cmd
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_CMD_DOWNLOAD_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START_PARAMS"
argument_list|)
expr_stmt|;
name|ray_init_download_done
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"UPDATE_PARAMS"
argument_list|)
expr_stmt|;
name|ray_upparams_done
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_REPORT_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"REPORT_PARAMS"
argument_list|)
expr_stmt|;
name|ray_repparams_done
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_MCAST
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"UPDATE_MCAST"
argument_list|)
expr_stmt|;
name|ray_mcast_done
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_NET
case|:
case|case
name|RAY_CMD_JOIN_NET
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START|JOIN_NET"
argument_list|)
expr_stmt|;
name|ray_init_sj_done
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TX_REQ
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"TX_REQ"
argument_list|)
expr_stmt|;
name|ray_tx_done
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_ASSOC
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START_ASSOC"
argument_list|)
expr_stmt|;
name|ray_init_assoc_done
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_APM
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unexpected UPDATE_APM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TEST_MEM
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unexpected TEST_MEM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_SHUTDOWN
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unexpected SHUTDOWN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_DUMP_MEM
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unexpected DUMP_MEM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_TIMER
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unexpected START_TIMER"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unknown command 0x%x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process ECF command request  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr_rcs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|cmd
parameter_list|,
name|size_t
name|rcs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_ECMD_RX_DONE
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"RX_DONE"
argument_list|)
expr_stmt|;
name|ray_rx
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_REJOIN_DONE
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"REJOIN_DONE"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_c
operator|.
name|np_havenet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_ROAM_START
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"ROAM_START"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_c
operator|.
name|np_havenet
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_JAPAN_CALL_SIGNAL
case|:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unexpected JAPAN_CALL_SIGNAL"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"unknown command 0x%x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User land entry to multicast list changes  */
end_comment

begin_function
specifier|static
name|int
name|ray_mcast_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ncom
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Do all checking in the runq to preserve ordering. 	 * 	 * We run promisc to pick up changes to the ALL_MULTI 	 * interface flag. 	 */
name|ncom
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_mcast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_promisc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAY_COM_RUNQ
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"raymcast"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX no real error processing from anything yet! */
name|RAY_COM_FREE
argument_list|(
name|com
argument_list|,
name|ncom
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to setting the multicast filter list  *  * MUST always be followed by a call to ray_promisc to pick up changes  * to promisc flag  */
end_comment

begin_function
specifier|static
name|void
name|ray_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|size_t
name|bufp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If card is not running we don't need to update this. 	 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"not running"
argument_list|)
expr_stmt|;
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The multicast list is only 16 items long so use promiscuous 	 * mode and don't bother updating the multicast list. 	 */
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|16
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
comment|/* 	 * Kick the card 	 */
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_UPDATE_MCAST
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update_mcast
argument_list|,
name|c_nmcast
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|RAY_HOST_TO_ECF_BASE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|ETHER_ADDR_LEN
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the multicast filter list update  */
end_comment

begin_function
specifier|static
name|void
name|ray_mcast_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_CCSERR
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|if_oerrors
argument_list|)
expr_stmt|;
comment|/* XXX error counter */
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to set/reset promiscuous mode  */
end_comment

begin_function
specifier|static
name|void
name|ray_promisc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If card not running or we already have the right flags 	 * we don't need to update this 	 */
name|sc
operator|->
name|sc_d
operator|.
name|np_promisc
operator|=
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_c
operator|.
name|np_promisc
operator|==
name|sc
operator|->
name|sc_d
operator|.
name|np_promisc
operator|)
condition|)
block|{
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Kick the card 	 */
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_UPDATE_PARAMS
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_paramid
argument_list|,
name|RAY_MIB_PROMISC
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
name|sc
operator|->
name|sc_d
operator|.
name|np_promisc
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User land entry to parameter reporting  *  * As we by pass the runq to report current parameters this function  * only provides a snap shot of the driver's state.  */
end_comment

begin_function
specifier|static
name|int
name|ray_repparams_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ncom
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Test for illegal values or immediate responses 	 */
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|)
operator|&&
operator|!
operator|(
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
literal|0
index|]
operator|&
name|RAY_V4
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
operator|)
operator|&&
operator|!
operator|(
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
literal|0
index|]
operator|&
name|RAY_V5
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_LASTUSER
condition|)
block|{
switch|switch
condition|(
name|pr
operator|->
name|r_paramid
condition|)
block|{
case|case
name|RAY_MIB_VERSION
case|:
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
operator|*
name|pr
operator|->
name|r_data
operator|=
name|RAY_V4
expr_stmt|;
else|else
operator|*
name|pr
operator|->
name|r_data
operator|=
name|RAY_V5
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_BSSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_INITED
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_inited
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_DEF_TXRATE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_ENCRYPT
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_NET_TYPE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_SSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_PRIV_START
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_start
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_PRIV_JOIN
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_join
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_BSSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_bss_id
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_INITED
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_inited
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_DEF_TXRATE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_ENCRYPT
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_NET_TYPE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_SSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_PRIV_START
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_PRIV_JOIN
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_AP_STATUS
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_PROMISC
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_promisc
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_AP_STATUS
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_PROMISC
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_promisc
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_FRAMING
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_framing
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_FRAMING
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_framing
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
name|pr
operator|->
name|r_failcause
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|pr
operator|->
name|r_len
operator|=
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
name|RAY_MIB_INFO_SIZ4
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
name|pr
operator|->
name|r_len
operator|=
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
name|RAY_MIB_INFO_SIZ5
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pr
operator|->
name|r_failcause
operator|=
literal|0
expr_stmt|;
name|ncom
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_repparams
argument_list|,
name|RAY_COM_FWOK
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|-
literal|1
index|]
operator|->
name|c_pr
operator|=
name|pr
expr_stmt|;
name|RAY_COM_RUNQ
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"rayrparm"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX no real error processing from anything yet! */
if|if
condition|(
operator|!
name|com
index|[
literal|0
index|]
operator|->
name|c_retval
operator|&&
name|pr
operator|->
name|r_failcause
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|RAY_COM_FREE
argument_list|(
name|com
argument_list|,
name|ncom
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to read the required parameter  *  * The card and driver are happy for parameters to be read  * whenever the card is plugged in  */
end_comment

begin_function
specifier|static
name|void
name|ray_repparams
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Kick the card 	 */
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_REPORT_PARAMS
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_paramid
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_paramid
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the parameter reporting  */
end_comment

begin_function
specifier|static
name|void
name|ray_repparams_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_CCSERR
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|if_oerrors
argument_list|)
expr_stmt|;
comment|/* XXX error counter */
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_pr
operator|->
name|r_failcause
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_failcause
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_pr
operator|->
name|r_len
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_data
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User land entry (and exit) to the error counters  */
end_comment

begin_function
specifier|static
name|int
name|ray_repstats_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_stats_req
modifier|*
name|sr
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sr
operator|->
name|rxoverflow
operator|=
name|sc
operator|->
name|sc_rxoverflow
expr_stmt|;
name|sr
operator|->
name|rxcksum
operator|=
name|sc
operator|->
name|sc_rxcksum
expr_stmt|;
name|sr
operator|->
name|rxhcksum
operator|=
name|sc
operator|->
name|sc_rxhcksum
expr_stmt|;
name|sr
operator|->
name|rxnoise
operator|=
name|sc
operator|->
name|sc_rxnoise
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * User land entry to parameter update changes  *  * As a parameter change can cause the network parameters to be  * invalid we have to re-start/join.  */
end_comment

begin_function
specifier|static
name|int
name|ray_upparams_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|4
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ncom
decl_stmt|,
name|todo
decl_stmt|;
define|#
directive|define
name|RAY_UPP_SJ
value|0x1
define|#
directive|define
name|RAY_UPP_PARAMS
value|0x2
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the parameter is available based on firmware version 	 */
name|pr
operator|->
name|r_failcause
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_LASTUSER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|)
operator|&&
operator|!
operator|(
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
literal|0
index|]
operator|&
name|RAY_V4
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
operator|)
operator|&&
operator|!
operator|(
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
literal|0
index|]
operator|&
name|RAY_V5
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Handle certain parameters specially 	 */
name|todo
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|pr
operator|->
name|r_paramid
condition|)
block|{
case|case
name|RAY_MIB_NET_TYPE
case|:
comment|/* Updated via START_NET JOIN_NET  */
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
case|case
name|RAY_MIB_SSID
case|:
comment|/* Updated via START_NET JOIN_NET  */
name|bcopy
argument_list|(
name|pr
operator|->
name|r_data
argument_list|,
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
case|case
name|RAY_MIB_PRIVACY_MUST_START
case|:
comment|/* Updated via START_NET */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
case|case
name|RAY_MIB_PRIVACY_CAN_JOIN
case|:
comment|/* Updated via START_NET JOIN_NET  */
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
case|case
name|RAY_MIB_BASIC_RATE_SET
case|:
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_PARAMS
expr_stmt|;
break|break;
case|case
name|RAY_MIB_AP_STATUS
case|:
comment|/* Unsupported */
case|case
name|RAY_MIB_MAC_ADDR
case|:
comment|/* XXX Need interface up but could be done */
case|case
name|RAY_MIB_PROMISC
case|:
comment|/* BPF */
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
name|todo
operator||=
name|RAY_UPP_PARAMS
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
block|}
comment|/* 	 * Generate the runq entries as needed 	 */
name|ncom
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|todo
operator|&
name|RAY_UPP_PARAMS
condition|)
block|{
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_upparams
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|-
literal|1
index|]
operator|->
name|c_pr
operator|=
name|pr
expr_stmt|;
block|}
if|if
condition|(
name|todo
operator|&
name|RAY_UPP_SJ
condition|)
block|{
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_sj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_auth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_assoc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|RAY_COM_RUNQ
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"rayuparam"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX no real error processing from anything yet! */
if|if
condition|(
operator|!
name|com
index|[
literal|0
index|]
operator|->
name|c_retval
operator|&&
name|pr
operator|->
name|r_failcause
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|RAY_COM_FREE
argument_list|(
name|com
argument_list|,
name|ncom
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to update a parameter  *  * The card and driver are basically happy for parameters to be updated  * whenever the card is plugged in. However, there may be a couple of  * network hangs whilst the update is performed. Reading parameters back  * straight away may give the wrong answer and some parameters cannot be  * read at all. Local copies should be kept.  */
end_comment

begin_function
specifier|static
name|void
name|ray_upparams
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_UPDATE_PARAMS
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_paramid
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_paramid
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_data
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the parameter update, note that promisc finishes up here too  */
end_comment

begin_function
specifier|static
name|void
name|ray_upparams_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|status
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_CCSERR
argument_list|(
name|sc
argument_list|,
name|status
argument_list|,
name|if_oerrors
argument_list|)
expr_stmt|;
comment|/* XXX error counter */
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_paramid
argument_list|)
condition|)
block|{
case|case
name|RAY_MIB_PROMISC
case|:
name|sc
operator|->
name|sc_c
operator|.
name|np_promisc
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"promisc value %d"
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_promisc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|com
operator|->
name|c_pr
operator|->
name|r_failcause
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_failcause
argument_list|)
expr_stmt|;
break|break;
block|}
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Command queuing and execution  */
end_comment

begin_comment
comment|/*  * Set up a comq entry struct  */
end_comment

begin_function
specifier|static
name|struct
name|ray_comq_entry
modifier|*
name|ray_com_init
parameter_list|(
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|,
name|ray_comqfn_t
name|function
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
name|com
operator|->
name|c_function
operator|=
name|function
expr_stmt|;
name|com
operator|->
name|c_flags
operator|=
name|flags
expr_stmt|;
name|com
operator|->
name|c_retval
operator|=
literal|0
expr_stmt|;
name|com
operator|->
name|c_ccs
operator|=
literal|0
expr_stmt|;
name|com
operator|->
name|c_wakeup
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|c_pr
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|c_mesg
operator|=
name|mesg
expr_stmt|;
return|return
operator|(
name|com
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Malloc and set up a comq entry struct  */
end_comment

begin_function
specifier|static
name|struct
name|ray_comq_entry
modifier|*
name|ray_com_malloc
parameter_list|(
name|ray_comqfn_t
name|function
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|MALLOC
argument_list|(
name|com
argument_list|,
expr|struct
name|ray_comq_entry
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_comq_entry
argument_list|)
argument_list|,
name|M_RAYCOM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
return|return
operator|(
name|ray_com_init
argument_list|(
name|com
argument_list|,
name|function
argument_list|,
name|flags
argument_list|,
name|mesg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an array of commands to the runq, get some ccs's for them and  * then run, waiting on the last command.  *  * We add the commands to the queue first to preserve ioctl ordering.  *  * On recoverable errors, this routine removes the entries from the  * runq. A caller can requeue the commands (and still preserve its own  * processes ioctl ordering) but doesn't have to. When the card is  * detached we get out quickly to prevent panics and don't bother  * about the runq.  */
end_comment

begin_function
specifier|static
name|int
name|ray_com_runq_add
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[]
parameter_list|,
name|int
name|ncom
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Add the commands to the runq but don't let it run until 	 * the ccs's are allocated successfully 	 */
name|com
index|[
literal|0
index|]
operator|->
name|c_flags
operator||=
name|RAY_COM_FWAIT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
block|{
name|com
index|[
name|i
index|]
operator|->
name|c_wakeup
operator|=
name|com
index|[
name|ncom
operator|-
literal|1
index|]
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"adding %p"
argument_list|,
name|com
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_DCOM
argument_list|,
name|com
index|[
name|i
index|]
argument_list|,
literal|"adding"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
index|[
name|i
index|]
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
block|}
name|com
index|[
name|ncom
operator|-
literal|1
index|]
operator|->
name|c_flags
operator||=
name|RAY_COM_FWOK
expr_stmt|;
comment|/* 	 * Allocate ccs's for each command. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|ray_ccs_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|com
index|[
name|i
index|]
operator|->
name|c_ccs
argument_list|,
name|wmesg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Allow the queue to run and sleep if needed. 	 * 	 * Iff the FDETACHED flag is set in the com entry we waited on 	 * the driver is in a zombie state! The softc structure has been 	 * freed by the generic bus detach methods - eek. We tread very 	 * carefully! 	 */
name|com
index|[
literal|0
index|]
operator|->
name|c_flags
operator|&=
operator|~
name|RAY_COM_FWAIT
expr_stmt|;
name|ray_com_runq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"sleeping"
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|com
index|[
name|ncom
operator|-
literal|1
index|]
argument_list|,
name|PCATCH
operator||
name|PRIBIO
argument_list|,
name|wmesg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
index|[
name|ncom
operator|-
literal|1
index|]
operator|->
name|c_flags
operator|&
name|RAY_COM_FDETACHED
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"awakened, tsleep returned 0x%x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|cleanup
label|:
comment|/* 	 * Only clean the queue on real errors - we don't care about it 	 * when we detach as the queue entries are freed by the callers. 	 */
if|if
condition|(
name|error
operator|&&
operator|(
name|error
operator|!=
name|ENXIO
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|com
index|[
name|i
index|]
operator|->
name|c_flags
operator|&
name|RAY_COM_FCOMPLETED
operator|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"removing %p"
argument_list|,
name|com
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_DCOM
argument_list|,
name|com
index|[
name|i
index|]
argument_list|,
literal|"removing"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
index|[
name|i
index|]
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
name|ray_ccs_free
argument_list|(
name|sc
argument_list|,
name|com
index|[
name|i
index|]
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
name|com
index|[
name|i
index|]
operator|->
name|c_ccs
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the command at the head of the queue (if not already running)  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|com
operator|==
name|NULL
operator|)
operator|||
operator|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FRUNNING
operator|)
operator|||
operator|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FWAIT
operator|)
operator|||
operator|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FDETACHED
operator|)
condition|)
return|return;
name|com
operator|->
name|c_flags
operator||=
name|RAY_COM_FRUNNING
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"running %p"
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_DCOM
argument_list|,
name|com
argument_list|,
literal|"running"
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_function
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove run command, free ccs and wakeup caller.  *  * Minimal checks are done here as we ensure that the com and command  * handler were matched up earlier. Must be called at splnet or higher  * so that entries on the command queue are correctly removed.  *  * Remove the com from the comq, and wakeup the caller if it requested  * to be woken. This is used for ensuring a sequence of commands  * completes. Finally, re-run the queue.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
comment|/* XXX shall we check this as below */
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"removing %p"
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_DCOM
argument_list|,
name|com
argument_list|,
literal|"removing"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_flags
operator|&=
operator|~
name|RAY_COM_FRUNNING
expr_stmt|;
name|com
operator|->
name|c_flags
operator||=
name|RAY_COM_FCOMPLETED
expr_stmt|;
name|com
operator|->
name|c_retval
operator|=
literal|0
expr_stmt|;
name|ray_ccs_free
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_ccs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FWOK
condition|)
name|wakeup
argument_list|(
name|com
operator|->
name|c_wakeup
argument_list|)
expr_stmt|;
name|ray_com_runq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX what about error on completion then? deal with when i fix 	 * XXX the status checking 	 * 	 * XXX all the runq_done calls from IFF_DRV_RUNNING checks in runq 	 * XXX routines should return EIO but shouldn't abort the runq 	 */
block|}
end_function

begin_comment
comment|/*  * Send a command to the ECF.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
name|RAY_ECF_SPIN_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
name|RAY_ECF_SPIN_TRIES
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"spun too long"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"spun %d times"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"sending %p"
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_DCOM
argument_list|,
name|com
argument_list|,
literal|"sending"
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAY_COM_NEEDS_TIMO
argument_list|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
argument_list|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"adding timeout"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Deal with commands that require a timeout to test completion.  *  * This routine is coded to only expect one outstanding request for the  * timed out requests at a time, but thats all that can be outstanding  * per hardware limitations and all that we issue anyway.  *  * We don't do any fancy testing of the command currently issued as we  * know it must be a timeout based one...unless I've got this wrong!  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ray_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|u_int8_t
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|RAY_CCS_STATUS_COMPLETE
case|:
case|case
name|RAY_CCS_STATUS_FREE
case|:
comment|/* Buggy firmware */
name|ray_intr_ccs
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|status
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CCS_STATUS_BUSY
case|:
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Replicates NetBSD */
if|if
condition|(
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
index|]
operator|==
literal|1
condition|)
block|{
comment|/* give a chance for the interrupt to occur */
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
index|]
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
name|ray_intr_ccs
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|status
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when interrupt handler for the command has done all it  * needs to. Will be called at splnet.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
end_if

begin_comment
comment|/*  * Process completed ECF commands that probably came from the command queue  *  * This routine is called after vectoring the completed ECF command  * to the appropriate _done routine. It helps check everything is okay.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_check
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|"%s"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"no command queue"
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|c_ccs
operator|!=
name|ccs
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"ccs's don't match"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_COM */
end_comment

begin_comment
comment|/*  * CCS allocators  */
end_comment

begin_comment
comment|/*  * Obtain a ccs for a commmand  *  * Returns 0 and in `ccsp' the bus offset of the free ccs. Will block  * awaiting free ccs if needed - if the sleep is interrupted  * EINTR/ERESTART is returned, if the card is ejected we return ENXIO.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ccs_alloc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
name|RAY_CCS_CMD_FIRST
init|;
name|i
operator|<=
name|RAY_CCS_CMD_LAST
condition|;
name|i
operator|++
control|)
block|{
comment|/* we probe here to make the card go */
operator|(
name|void
operator|)
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|RAY_CCS_CMD_LAST
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"sleeping"
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|ray_ccs_alloc
argument_list|,
name|PCATCH
operator||
name|PRIBIO
argument_list|,
name|wmesg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_gone
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"awakened, tsleep returned 0x%x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
break|break;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"allocated 0x%02x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill the easy bits in of a pre-allocated CCS  */
end_comment

begin_function
specifier|static
name|void
name|ray_ccs_fill
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int
name|cmd
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccs
operator|==
literal|0
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"ccs not allocated"
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up a ccs allocated via ray_ccs_alloc  *  * Return the old status. This routine is only used for ccs allocated via  * ray_ccs_alloc (not tx, rx or ECF command requests).  */
end_comment

begin_function
specifier|static
name|void
name|ray_ccs_free
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
operator||
operator|(
name|RAY_DEBUG
operator|&
name|RAY_DBG_CCS
operator|)
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
condition|)
name|RAY_RECERR
argument_list|(
name|sc
argument_list|,
literal|"freeing free ccs 0x%02zx"
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_CCS */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_gone
condition|)
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"freed 0x%02zx"
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ray_ccs_alloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Obtain a ccs and tx buffer to transmit with and fill them in.  *  * Returns 0 and in `ccsp' the bus offset of the free ccs. Will not block  * and if none available and will returns EAGAIN.  *  * The caller must fill in the length later.  * The caller must clear the ccs on errors.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ccs_tx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|size_t
modifier|*
name|bufpp
parameter_list|)
block|{
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|i
operator|=
name|RAY_CCS_TX_FIRST
expr_stmt|;
do|do
block|{
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RAY_CCS_STATUS_FREE
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<=
name|RAY_CCS_TX_LAST
condition|)
do|;
if|if
condition|(
name|i
operator|>
name|RAY_CCS_TX_LAST
condition|)
block|{
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"allocated 0x%02x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve and fill the ccs - must do the length later. 	 * 	 * Even though build 4 and build 5 have different fields all these 	 * are common apart from tx_rate. Neither the NetBSD driver or Linux 	 * driver bother to overwrite this for build 4 cards. 	 * 	 * The start of the buffer must be aligned to a 256 byte boundary 	 * (least significant byte of address = 0x00). 	 */
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|RAY_TX_BASE
operator|+
name|i
operator|*
name|RAY_TX_BUF_SIZE
expr_stmt|;
name|bufp
operator|+=
name|sc
operator|->
name|sc_tibsize
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_cmd
argument_list|,
name|RAY_CMD_TX_REQ
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_bufp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_tx_rate
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_apm_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_phy_header
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
operator|*
name|bufpp
operator|=
name|bufp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines to obtain resources for the card  */
end_comment

begin_comment
comment|/*  * Allocate the attribute memory on the card  *  * The attribute memory space is abused by these devices as IO space. As such  * the OS card services don't have a chance of knowing that they need to keep  * the attribute space mapped. We have to do it manually.  */
end_comment

begin_function
specifier|static
name|int
name|ray_res_alloc_am
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|am_rid
operator|=
name|RAY_AM_RID
expr_stmt|;
name|sc
operator|->
name|am_res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|am_rid
argument_list|,
literal|0UL
argument_list|,
operator|~
literal|0UL
argument_list|,
literal|0x1000
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|am_res
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Cannot allocate attribute memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|CARD_SET_MEMORY_OFFSET
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"CARD_SET_MEMORY_OFFSET returned 0x%0x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
name|PCCARD_A_MEM_ATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"CARD_SET_RES_FLAGS returned 0x%0x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
name|PCCARD_A_MEM_8BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"CARD_SET_RES_FLAGS returned 0x%0x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|am_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|am_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|am_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|am_res
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
operator|(
name|RAY_DBG_CM
operator||
name|RAY_DBG_BOOTPARAM
operator|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|CARD_GET_MEMORY_OFFSET
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"allocated attribute memory:\n"
literal|".  start 0x%0lx count 0x%0lx flags 0x%0lx offset 0x%0x"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|)
argument_list|,
name|flags
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG& (RAY_DBG_CM | RAY_DBG_BOOTPARAM) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate the common memory on the card  *  * As this memory is described in the CIS, the OS card services should  * have set the map up okay, but the card uses 8 bit RAM. This is not  * described in the CIS.  */
end_comment

begin_function
specifier|static
name|int
name|ray_res_alloc_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_long
name|start
decl_stmt|,
name|count
decl_stmt|,
name|end
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CM
operator||
name|RAY_DBG_BOOTPARAM
argument_list|,
literal|"cm start 0x%0lx count 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|RAY_CM_RID
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|RAY_CM_RID
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cm_rid
operator|=
name|RAY_CM_RID
expr_stmt|;
name|start
operator|=
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
expr_stmt|;
name|count
operator|=
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|count
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|cm_res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|cm_rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|cm_res
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Cannot allocate common memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|CARD_SET_MEMORY_OFFSET
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"CARD_SET_MEMORY_OFFSET returned 0x%0x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
name|PCCARD_A_MEM_COM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"CARD_SET_RES_FLAGS returned 0x%0x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
name|PCCARD_A_MEM_8BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"CARD_SET_RES_FLAGS returned 0x%0x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|cm_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|cm_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cm_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|cm_res
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
operator|(
name|RAY_DBG_CM
operator||
name|RAY_DBG_BOOTPARAM
operator|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|CARD_GET_MEMORY_OFFSET
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"allocated common memory:\n"
literal|".  start 0x%0lx count 0x%0lx flags 0x%0lx offset 0x%0x"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
argument_list|,
name|flags
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG& (RAY_DBG_CM | RAY_DBG_BOOTPARAM) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get an irq and attach it to the bus  */
end_comment

begin_function
specifier|static
name|int
name|ray_res_alloc_irq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CM
operator||
name|RAY_DBG_BOOTPARAM
argument_list|,
literal|"irq start 0x%0lx count 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Cannot allocate irq"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|ray_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_handle
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Failed to setup irq"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CM
operator||
name|RAY_DBG_BOOTPARAM
argument_list|,
literal|"allocated irq:\n"
literal|".  start 0x%0lx count 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release all of the card's resources  */
end_comment

begin_function
specifier|static
name|void
name|ray_res_release
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|!=
literal|0
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|am_res
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
name|sc
operator|->
name|am_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|am_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|cm_res
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
name|sc
operator|->
name|cm_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cm_res
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * mbuf dump  */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_MBUF
end_if

begin_function
specifier|static
name|void
name|ray_dump_mbuf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|d
decl_stmt|,
modifier|*
name|ed
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
name|p
index|[
literal|17
index|]
decl_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"\nm0->data\t0x%p\nm_pkthdr.len\t%d\nm_len\t%d"
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
literal|17
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|ed
operator|=
name|d
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|ed
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  %s\n\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|%
literal|16
index|]
operator|=
operator|(
operator|(
operator|*
name|d
operator|>=
literal|0x20
operator|)
operator|&&
operator|(
operator|*
name|d
operator|<
literal|0x80
operator|)
operator|)
condition|?
operator|*
name|d
else|:
literal|'.'
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_MBUF */
end_comment

end_unit

