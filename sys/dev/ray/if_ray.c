begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id$  *  */
end_comment

begin_define
define|#
directive|define
name|XXX
value|0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_define
define|#
directive|define
name|HEXDUMP_8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|do {					\     u_int8_t *i;						\     int j;							\     for (i = p; i< (u_int8_t *)(p+l); i += 8) {		\ 	printf("  0x%08lx %02x", (unsigned long)i, *i);		\ 	for (j = 1; j< 8; j++)					\ 	    printf(" %02x", *(i+j));				\ 	printf("\n");						\     }								\ } while (0)
end_define

begin_define
define|#
directive|define
name|HEXDUMP_16
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|do {					\     u_int16_t *i;						\     int j;							\     for (i = p; i< (u_int16_t *)(p+l); i += 8) {		\ 	printf("  0x%08lx %02x", (unsigned long)i, *i);		\ 	for (j = 1; j< 8; j++)					\ 	    printf(" %02x", *(i+j));				\ 	printf("\n");						\     }								\ } while (0)
end_define

begin_include
include|#
directive|include
file|"ray.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NRAY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_rayreg.h>
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cis.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD */
end_comment

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM */
end_comment

begin_comment
comment|/*  * One of these structures per allocated device  */
end_comment

begin_struct
struct|struct
name|ray_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common */
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
comment|/* Ifnet common */
name|char
modifier|*
name|card_type
decl_stmt|;
comment|/* Card model name */
name|char
modifier|*
name|vendor
decl_stmt|;
comment|/* Card manufacturer */
name|int
name|unit
decl_stmt|;
comment|/* Unit number */
name|u_char
name|gone
decl_stmt|;
comment|/* 1 = Card bailed out */
name|int
name|slotnum
decl_stmt|;
comment|/* Slot number XXX only for attr read/write */
name|int
name|irq
decl_stmt|;
comment|/* Assigned IRQ */
name|caddr_t
name|maddr
decl_stmt|;
comment|/* Shared RAM Address */
name|int
name|msize
decl_stmt|;
comment|/* Shared RAM Size */
name|struct
name|ray_ecf_startup_v5
name|sc_ecf_startup
decl_stmt|;
comment|/* Startup info from card */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ray_softc
name|ray_softc
index|[
name|NRAY
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sc_version
value|sc_ecf_startup.e_fw_build_string
end_define

begin_comment
comment|/*  * PCMCIA driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_init
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_pccard_unload
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|ray
argument_list|,
name|ray_pccard_init
argument_list|,
name|ray_pccard_unload
argument_list|,
name|ray_pccard_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ISA driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|raydriver
init|=
block|{
name|ray_probe
block|,
name|ray_attach
block|,
literal|"ray"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Network driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ray_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_init
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_stop
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Misc. internal utilites  */
end_comment

begin_comment
comment|/*  * As described in if_xe.c...  *  * Horrid stuff for accessing CIS tuples  */
end_comment

begin_define
define|#
directive|define
name|CARD_MAJOR
value|50
end_define

begin_decl_stmt
specifier|static
name|int
name|ray_attr_write
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_char
name|byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attr_read
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_char
operator|*
name|buf
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PCCard initialise.  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_init
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|irq
decl_stmt|;
name|int
name|j
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: PCCard probe\n"
argument_list|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NRAY
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|slotnum
operator|=
name|dev_p
operator|->
name|slt
operator|->
name|slotnum
expr_stmt|;
comment|/* Get IRQ - encoded as a bitmask. */
name|irq
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_irq
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|irq
operator|&
literal|0x1
condition|)
break|break;
name|irq
operator|>>=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|irq
operator|=
name|j
expr_stmt|;
name|sc
operator|->
name|maddr
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|msize
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d:<Raylink/IEEE 802.11> maddr 0x%lx msize 0x%x irq %d on isa (PC-Card slot %d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sc
operator|->
name|maddr
argument_list|,
name|sc
operator|->
name|msize
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ray_attach
argument_list|(
operator|&
name|dev_p
operator|->
name|isahd
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCCard unload.  */
end_comment

begin_function
specifier|static
name|void
name|ray_pccard_unload
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: PCCard unload\n"
argument_list|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: already unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Cleardown interface      */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/*      * Mark card as gone      */
name|sc
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * PCCard interrupt.  */
end_comment

begin_comment
comment|/* XXX return 1 if we take interrupt, 0 otherwise */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_intr
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: PCCard intr\n"
argument_list|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before interrupt!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ISA probe routine.  */
end_comment

begin_function
specifier|static
name|int
name|ray_probe
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: ISA probe\n"
argument_list|,
name|dev_p
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ISA/PCCard attach.  */
end_comment

begin_function
specifier|static
name|int
name|ray_attach
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: ISA/PCCard attach\n"
argument_list|,
name|dev_p
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|id_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before attach!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Read startup results, check the card is okay and work out what      * version we are using.      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|maddr
operator|+
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
comment|/* XXX freebsd has a nice bit mask print thingy - use it here */
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%0x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unsupported firmware version 0x%0x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"ray%d: Start Up Results\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|10
name|HEXDUMP_8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_ECF_TO_HOST_BASE
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|printf
argument_list|(
literal|"  Firmware version 4\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  Firmware version 5\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Status 0x%x\n"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Ether address %6D\n"
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_rates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Supported rates %8D\n"
argument_list|,
name|ep
operator|->
name|e_rates
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  Japan call sign %12D\n"
argument_list|,
name|ep
operator|->
name|e_japan_callsign
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_prg_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_cis_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware version %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware revision %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_resv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ASIC version %0x\n"
argument_list|,
name|ep
operator|->
name|e_asic_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  TIB size %0x\n"
argument_list|,
name|ep
operator|->
name|e_tib_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Reset any pending interrupts      */
if|#
directive|if
literal|0
block|{u_int8_t p[16]; printf("Status pre interrupt clearing\n"); ray_attr_read(sc, RAY_CCR, p, sizeof(p)); HEXDUMP_8(p, sizeof(p)); HEXDUMP_16((u_int16_t *)p, sizeof(p) / 2);}
endif|#
directive|endif
name|ray_attr_write
argument_list|(
name|sc
argument_list|,
name|RAY_HCSIR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{u_int8_t p[16]; printf("Status post interrupt clearing\n"); ray_attr_read(sc, RAY_CCR, p, sizeof(p)); HEXDUMP_8(p, sizeof(p)); HEXDUMP_16((u_int16_t *)p, sizeof(p) / 2);}
endif|#
directive|endif
comment|/*      * Initialise the network interface structure      */
if|#
directive|if
name|XXX
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|=
endif|#
directive|endif
comment|/* XXX */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ray"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator|)
expr_stmt|;
comment|/* XXX - IFF_MULTICAST */
if|#
directive|if
name|XXX
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|scp
operator|->
name|mibdata
expr_stmt|;
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
name|scp
operator|->
name|mibdata
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
name|printf
argument_list|(
literal|"type 0x%x\n"
argument_list|,
name|ifp
operator|->
name|if_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addrlen 0x%x\n"
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"physical 0x%x\n"
argument_list|,
name|ifp
operator|->
name|if_physical
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hdrlen 0x%x\n"
argument_list|,
name|ifp
operator|->
name|if_hdrlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mtu 0x%lx\n"
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"metic 0x%lx\n"
argument_list|,
name|ifp
operator|->
name|if_metric
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"baudrate 0x%lx\n"
argument_list|,
name|ifp
operator|->
name|if_baudrate
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|if_mtu
modifier|...
name|if_rawoutput
name|ifp
operator|->
name|if_output
init|=
name|ether_output
decl_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ray_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ray_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ray_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ray_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|xe
name|ifmedia_init
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
literal|0
argument_list|,
name|xe_media_change
argument_list|,
name|xe_media_status
argument_list|)
decl_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|scp
operator|->
name|chand
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
if|#
directive|if
name|XXX
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Network start.  *  * Start output on interface.  We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|ray_start
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: Network start\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before start!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX mark output queue full so the kernel waits */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* XXX if_xe code is clean but if_ed does more checks at top */
return|return;
block|}
end_function

begin_comment
comment|/*  * Network ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: Network ioctl\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before ioctl!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 	     * If the interface is marked up and stopped, then start 	     * it. If it is marked down and running, then stop it. 	     */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* DROP THROUGH */
if|#
directive|if
name|XXX
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 	     * Multicast list has (maybe) changed; set the hardware filter 	     * accordingly. This also serves to deal with promiscuous mode 	     * if we have a BPF listener active. 	     */
name|ray_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: Network watchdog\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before watchdog!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ray%d: watchdog timeout\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX may need to have remedial action here    for example    	ray_reset 		ray_stop 		... 		ray_init */
return|return;
block|}
end_function

begin_comment
comment|/*  * Network initialisation.  */
end_comment

begin_function
specifier|static
name|void
name|ray_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: Network init\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before init!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* XXX stuff here please */
comment|/*      * Set running and clear output active, then attempt to start output      */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* XXX spl's needed higher up? */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Network stop.  */
end_comment

begin_function
specifier|static
name|void
name|ray_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"ray%d: Network stop\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before stop!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* XXX stuff here please to kill activity on the card and drain down transmissons */
comment|/*      * Mark as not running      */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Two routines to read from/write to the attribute memory.  *  * Taken from if_xe.c.  *  * Until there is a real way of accessing the attribute memory from a driver  * these have to stay.  *  */
end_comment

begin_function
specifier|static
name|int
name|ray_attr_write
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_char
name|byte
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|&
name|byte
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
return|return
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_write
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ray_attr_read
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
return|return
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_read
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRAY */
end_comment

end_unit

