begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: if_ray.c,v 1.8 2000/03/08 08:53:36 dmlb Exp $  *  */
end_comment

begin_comment
comment|/*	$NetBSD: if_ray.c,v 1.12 2000/02/07 09:36:27 augustss Exp $	*/
end_comment

begin_comment
comment|/*   * Copyright (c) 2000 Christian E. Hopps  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  * Card configuration  * ==================  *  * This card is unusual in that it uses both common and attribute  * memory whilst working. The -stable versions of FreeBSD have a real  * problem managing and setting up the correct memory maps. This  * driver should reset the memory maps correctly under PAO and non-PAO  * -stable systems. Work is in hand to fix these problems for -current.  *  * So, if you want to use this driver make sure that  *	options RAY_NEED_CM_FIXUP  *	options RAY_NEED_CM_REMAPPING  * are in your kernel configuration file.  *  * The first fixes the brain deadness of pccardd (where it reads the  * CIS for common memory, sets it all up and then throws it all away  * assuming the card is an ed driver...). Note that this could be  * dangerous (because it doesn't interact with pccardd) if you  * use other memory mapped cards at the same time.  *  * The second option ensures that common memory is remapped whenever  * we are going to access it (we can't just do it once, as something  * like pccardd may have read the attribute memory and pccard.c  * doesn't re-map the last active window - it remaps the last  * non-active window...).  *  *  * Ad-hoc and infra-structure modes  * ================================  *   * At present only the ad-hoc mode is being worked on.  *  * Apart from just writing the code for infrastructure mode I have a  * few concerns about both the Linux and NetBSD drivers in this area.  * They don't seem to differentiate between the MAC address of the AP  * and the BSS_ID of the network. I presume this is handled when  * joining a managed n/w and the network parameters are updated, but  * I'm not sure. How does this interact with ARP? For mobility we want  * to be able to move around without worrying about which AP we are  * actually talking to - we should always talk to the BSS_ID.  *  * The Linux driver also seems to have the capability to act as an AP.  * I wonder what facilities the "AP" can provide within a driver? We can  * probably use the BRIDGE code to form an ESS but I don't think  * power saving etc. is easy.  *  *  * Packet translation/encapsulation  * ================================  *   * Currently we only support the Webgear encapsulation  *	802.11	header<net/if_ieee80211.h>struct ieee80211_header  *	802.3	header<net/ethernet.h>struct ether_header  *	802.2	LLC header  *	802.2	SNAP header  *  * We should support whatever packet types the following drivers have  *   	if_wi.c		FreeBSD, RFC1042  *	if_ray.c	NetBSD	Webgear, RFC1042  *	rayctl.c	Linux Webgear, RFC1042  * also whatever we can divine from the NDC Access points and Kanda's boxes.  *  * Most drivers appear to have a RFC1042 translation. The incoming packet is  *	802.11	header<net/if_ieee80211.h>struct ieee80211_header  *	802.2	LLC header  *	802.2	SNAP header  *  * This is translated to  *	802.3	header<net/ethernet.h>struct ether_header  *	802.2	LLC header  *	802.2	SNAP header  *  * Linux seems to look at the SNAP org_code and do some translations  * for IPX and APPLEARP on that. This just may be how Linux does IPX  * and NETATALK. Need to see how FreeBSD does these.  *  * Translation should be selected via if_media stuff or link types.  */
end_comment

begin_comment
comment|/*  * TODO  *  * _stop - mostly done  *	would be nice to understand shutdown/or power save to prevent RX  * _reset - done  * 	just needs calling in the right places  *	converted panics to resets - when tx packets are the wrong length  *	may be needed in a couple of other places when I do more commands  * havenet - mostly done  *	i think i've got all the places to set it right, but not so sure  *	we reset it in all the right places  * _unload - done  *	recreated most of stop but as card is unplugged don't try and  *	access it to turn it off  * TX bpf - done  * RX bpf - done  *	I would much prefer to have the complete 802.11 packet dropped to  *	the bpf tap and then have a user land program parse the headers  *	as needed. This way, tcpdump -w can be used to grab the raw data. If  *	needed the 802.11 aware program can "translate" the .11 to ethernet  *	for tcpdump -r  * use std timeout code for download - done  *	was mainly moving a call and removing a load of stuff in  *	download_done as it duplicates check_ccs and ccs_done  * promisoius - done  * add the start_join_net - done  *	i needed it anyway  * remove startccs and startcmd - done  *	as those were used for the NetBSD start timeout  * multicast - done but UNTESTED  *	I don't have the ability/facilty to test this  * rxlevel - done  *	stats reported via raycontrol  * getparams ioctl - done  *	reported via raycontrol  * start_join_done needs a restart in download_done - done  *	now use netbsd style start up  * ioctls - done  *	use raycontrol  *	translation, BSS_ID, countrycode, changing mode  *  * shutdown  * ifp->if_hdr length  * _reset - check where needed  * apm  * faster TX routine  * more translations  * infrastructure mode - maybe need some of the old stuff for checking?  * differeniate between parameters set in attach and init  * spinning in ray_issue_cmd  * fix the XXX code in start_join_done  * make RAY_DEBUG a knob somehow - either sysctl or IFF_DEBUG  * ray_update_params_done needs work  * do an rx level and antenna cache, the antenna can be used to set c_antenna  *   for tx  * callout handles need rationalising. can probably remove timerh and  *   use ccs_timerh for download and sj_timerh  */
end_comment

begin_define
define|#
directive|define
name|XXX
value|0
end_define

begin_define
define|#
directive|define
name|XXX_NETBSDTX
value|0
end_define

begin_define
define|#
directive|define
name|XXX_PROM
value|0
end_define

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_comment
comment|/*  * RAY_DEBUG settings  *  *	2	Recoverable error's  *	6	Subroutine entry  *	11	Startup CM dump  *	16	State transitions for start/join  *	21	CCS info  *	31	IOCTL calls  *	51	MBUFs dumped/packet types reported  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAY_CCS_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for CCS commands */
end_comment

begin_define
define|#
directive|define
name|RAY_CHECK_SCHED_TIMEOUT
value|(hz)
end_define

begin_comment
comment|/* Time to wait until command retry, should be> RAY_CCS_TIMEOUT */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_STARTJOIN_TIMO
value|0
end_define

begin_comment
comment|/* Might be needed with build 4 */
end_comment

begin_define
define|#
directive|define
name|RAY_SJ_TIMEOUT
value|(90*hz)
end_define

begin_comment
comment|/* Timeout for failing STARTJOIN commands - only used with RAY_NEED_STARTJOIN_TIMO */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_CM_FIXUP
value|1
end_define

begin_comment
comment|/* Needed until pccardd hacks for ed drivers are removed (pccardd forces 16bit memory and 0x4000 size) THIS IS A DANGEROUS THING TO USE IF YOU USE OTHER MEMORY MAPPED PCCARDS */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_CM_REMAPPING
value|1
end_define

begin_comment
comment|/* Needed until pccard maps more than one memory area */
end_comment

begin_define
define|#
directive|define
name|RAY_RESET_TIMEOUT
value|(5*hz)
end_define

begin_comment
comment|/* Timeout for resetting the card */
end_comment

begin_define
define|#
directive|define
name|RAY_USE_CALLOUT_STOP
value|0
end_define

begin_comment
comment|/* Set for kernels with callout_stop function - 3.3 and above */
end_comment

begin_define
define|#
directive|define
name|RAY_SIMPLE_TX
value|1
end_define

begin_comment
comment|/* Simple TX routine */
end_comment

begin_define
define|#
directive|define
name|RAY_DECENT_TX
value|0
end_define

begin_comment
comment|/* Decent TX routine - tbd */
end_comment

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_comment
comment|/*  * Debugging odds and odds  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
end_if

begin_comment
comment|/* XXX This macro assumes that common memory is mapped into kernel space and  * XXX does not indirect through SRAM macros - it should  */
end_comment

begin_define
define|#
directive|define
name|RAY_DHEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|do { if (RAY_DEBUG> 10) {		\     u_int8_t *i;						\     for (i = p; i< (u_int8_t *)(p+l); i += 8)			\     	printf("  0x%08lx %8D\n",				\ 		(unsigned long)i, (unsigned char *)i, " ");	\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTFN
parameter_list|(
name|l
parameter_list|,
name|x
parameter_list|)
value|do { if (RAY_DEBUG> l) {		\     printf x ;							\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DNET_DUMP
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
value|do { if (RAY_DEBUG> 15) {			\     printf("ray%d: Current network parameters%s\n", (sc)->unit, (s));	\     printf("  bss_id %6D\n", (sc)->sc_c.np_bss_id, ":");		\     printf("  inited 0x%02x\n", (sc)->sc_c.np_inited);			\     printf("  def_txrate 0x%02x\n", (sc)->sc_c.np_def_txrate);		\     printf("  encrypt 0x%02x\n", (sc)->sc_c.np_encrypt);		\     printf("  net_type 0x%02x\n", (sc)->sc_c.np_net_type);		\     printf("  ssid \"%.32s\"\n", (sc)->sc_c.np_ssid);			\     printf("       %8D\n", (sc)->sc_c.np_ssid, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+8, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+16, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+24, " ");			\     printf("  priv_start 0x%02x\n", (sc)->sc_c.np_priv_start);		\     printf("  priv_join 0x%02x\n", (sc)->sc_c.np_priv_join);		\     printf("ray%d: Desired network parameters%s\n", (sc)->unit, (s));	\     printf("  bss_id %6D\n", (sc)->sc_d.np_bss_id, ":");		\     printf("  inited 0x%02x\n", (sc)->sc_d.np_inited);			\     printf("  def_txrate 0x%02x\n", (sc)->sc_d.np_def_txrate);		\     printf("  encrypt 0x%02x\n", (sc)->sc_d.np_encrypt);		\     printf("  net_type 0x%02x\n", (sc)->sc_d.np_net_type);		\     printf("  ssid \"%.32s\"\n", (sc)->sc_d.np_ssid);			\     printf("       %8D\n", (sc)->sc_c.np_ssid, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+8, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+16, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+24, " ");			\     printf("  priv_start 0x%02x\n", (sc)->sc_d.np_priv_start);		\     printf("  priv_join 0x%02x\n", (sc)->sc_d.np_priv_join);		\ } } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_DHEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTFN
parameter_list|(
name|l
parameter_list|,
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DNET_DUMP
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 0 */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|50
end_if

begin_define
define|#
directive|define
name|RAY_DMBUF_DUMP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
value|ray_dump_mbuf((sc), (m), (s))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_DMBUF_DUMP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 10 */
end_comment

begin_include
include|#
directive|include
file|"ray.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NRAY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_ieee80211.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_rayreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_raymib.h>
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cis.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD */
end_comment

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM */
end_comment

begin_comment
comment|/*  * Sysctl knobs  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_debug
init|=
name|RAY_DEBUG
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ray
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Raylink Driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ray
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ray_debug
argument_list|,
name|RAY_DEBUG
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Network parameters, used twice in sotfc to store what we want and what  * we have.  *  * XXX promisc in here too?  * XXX sc_station_addr in here too (for changing mac address)  */
end_comment

begin_struct
struct|struct
name|ray_nw_param
block|{
name|struct
name|ray_cmd_net
name|p_1
decl_stmt|;
name|u_int8_t
name|np_ap_status
decl_stmt|;
name|struct
name|ray_net_params
decl|\
name|p_2
decl_stmt|;
name|u_int8_t
name|np_countrycode
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|np_upd_param
value|p_1.c_upd_param
end_define

begin_define
define|#
directive|define
name|np_bss_id
value|p_1.c_bss_id
end_define

begin_define
define|#
directive|define
name|np_inited
value|p_1.c_inited
end_define

begin_define
define|#
directive|define
name|np_def_txrate
value|p_1.c_def_txrate
end_define

begin_define
define|#
directive|define
name|np_encrypt
value|p_1.c_encrypt
end_define

begin_define
define|#
directive|define
name|np_net_type
value|p_2.p_net_type
end_define

begin_define
define|#
directive|define
name|np_ssid
value|p_2.p_ssid
end_define

begin_define
define|#
directive|define
name|np_priv_start
value|p_2.p_privacy_must_start
end_define

begin_define
define|#
directive|define
name|np_priv_join
value|p_2.p_privacy_can_join
end_define

begin_comment
comment|/*  * One of these structures per allocated device  */
end_comment

begin_struct
struct|struct
name|ray_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common 		*/
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
comment|/* Ifnet common 		*/
name|struct
name|callout_handle
decl|\
name|ccs_timerh
decl_stmt|;
comment|/* Handle for ccs timeouts	*/
name|struct
name|callout_handle
decl|\
name|reset_timerh
decl_stmt|;
comment|/* Handle for reset timer	*/
name|struct
name|callout_handle
decl|\
name|start_timerh
decl_stmt|;
comment|/* Handle for start timer	*/
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|struct
name|callout_handle
decl|\
name|sj_timerh
decl_stmt|;
comment|/* Handle for start_join timer	*/
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|char
modifier|*
name|card_type
decl_stmt|;
comment|/* Card model name		*/
name|char
modifier|*
name|vendor
decl_stmt|;
comment|/* Card manufacturer		*/
name|int
name|unit
decl_stmt|;
comment|/* Unit number			*/
name|u_char
name|gone
decl_stmt|;
comment|/* 1 = Card bailed out		*/
name|caddr_t
name|maddr
decl_stmt|;
comment|/* Shared RAM Address		*/
name|int
name|flags
decl_stmt|;
comment|/* Start up flags		*/
name|int
name|translation
decl_stmt|;
comment|/* Packet translation types	*/
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
name|int
name|slotnum
decl_stmt|;
comment|/* Slot number			*/
name|struct
name|mem_desc
name|md
decl_stmt|;
comment|/* Map info for common memory	*/
endif|#
directive|endif
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
name|struct
name|ray_ecf_startup_v5
decl|\
name|sc_ecf_startup
decl_stmt|;
comment|/* Startup info from card	*/
name|struct
name|ray_nw_param
name|sc_c
decl_stmt|;
comment|/* current network params 	*/
name|struct
name|ray_nw_param
name|sc_d
decl_stmt|;
comment|/* desired network params	*/
name|int
name|sc_havenet
decl_stmt|;
comment|/* true if we have a network	*/
name|int
name|sc_promisc
decl_stmt|;
comment|/* current set value		*/
name|int
name|sc_running
decl_stmt|;
comment|/* things we are doing		*/
name|int
name|sc_scheduled
decl_stmt|;
comment|/* things we need to do		*/
name|int
name|sc_timoneed
decl_stmt|;
comment|/* set if timeout is sched	*/
name|int
name|sc_timocheck
decl_stmt|;
comment|/* set if timeout is sched	*/
name|u_int8_t
name|sc_ccsinuse
index|[
literal|64
index|]
decl_stmt|;
comment|/* ccss' in use -- not for tx	*/
name|int
name|sc_checkcounters
decl_stmt|;
name|u_int64_t
name|sc_rxoverflow
decl_stmt|;
comment|/* Number of rx overflows	*/
name|u_int64_t
name|sc_rxcksum
decl_stmt|;
comment|/* Number of checksum errors	*/
name|u_int64_t
name|sc_rxhcksum
decl_stmt|;
comment|/* Number of header checksum errors */
name|u_int8_t
name|sc_rxnoise
decl_stmt|;
comment|/* Average receiver level	*/
name|struct
name|ray_param_req
type|\
modifier|*
name|sc_repreq
decl_stmt|;
comment|/* used to return values	*/
name|struct
name|ray_param_req
type|\
modifier|*
name|sc_updreq
decl_stmt|;
comment|/* to the user			*/
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ray_softc
name|ray_softc
index|[
name|NRAY
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sc_station_addr
value|sc_ecf_startup.e_station_addr
end_define

begin_define
define|#
directive|define
name|sc_version
value|sc_ecf_startup.e_fw_build_string
end_define

begin_define
define|#
directive|define
name|sc_tibsize
value|sc_ecf_startup.e_tibsize
end_define

begin_comment
comment|/* Commands -- priority given to LSB */
end_comment

begin_define
define|#
directive|define
name|SCP_FIRST
value|0x0001
end_define

begin_define
define|#
directive|define
name|SCP_UPDATESUBCMD
value|0x0001
end_define

begin_define
define|#
directive|define
name|SCP_STARTASSOC
value|0x0002
end_define

begin_define
define|#
directive|define
name|SCP_REPORTPARAMS
value|0x0004
end_define

begin_define
define|#
directive|define
name|SCP_IFSTART
value|0x0008
end_define

begin_comment
comment|/* Update sub commands -- issues are serialized priority to LSB */
end_comment

begin_define
define|#
directive|define
name|SCP_UPD_FIRST
value|0x0100
end_define

begin_define
define|#
directive|define
name|SCP_UPD_STARTUP
value|0x0100
end_define

begin_define
define|#
directive|define
name|SCP_UPD_STARTJOIN
value|0x0200
end_define

begin_define
define|#
directive|define
name|SCP_UPD_PROMISC
value|0x0400
end_define

begin_define
define|#
directive|define
name|SCP_UPD_MCAST
value|0x0800
end_define

begin_define
define|#
directive|define
name|SCP_UPD_UPDATEPARAMS
value|0x1000
end_define

begin_define
define|#
directive|define
name|SCP_UPD_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|SCP_UPD_MASK
value|0xff00
end_define

begin_comment
comment|/* These command (a subset of the update set) require timeout checking */
end_comment

begin_define
define|#
directive|define
name|SCP_TIMOCHECK_CMD_MASK
define|\
value|(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \ 	SCP_UPD_PROMISC)
end_define

begin_comment
comment|/*  * Translation types  */
end_comment

begin_comment
comment|/* XXX maybe better as part of the if structure? */
end_comment

begin_define
define|#
directive|define
name|SC_TRANSLATE_WEBGEAR
value|0
end_define

begin_comment
comment|/*  * Prototyping  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_alloc_ccs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
operator|*
name|ccsp
operator|,
name|u_int
name|cmd
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_ccs_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_check_ccs
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_check_scheduled
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_cmd_cancel
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|int
name|cmdf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_cmd_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|int
name|cmdf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_cmd_is_running
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|int
name|cmdf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_cmd_is_scheduled
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|int
name|cmdf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_cmd_ran
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|int
name|cmdf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_cmd_schedule
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|int
name|cmdf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|50
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_dump_mbuf
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|mbuf
operator|*
name|m
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 50 */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_free_ccs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|XXX_NETBSDTX
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_free_ccs_chain
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|u_int
name|ni
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX_NETBSDTX */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_init
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_issue_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_init
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_pccard_unload
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rcs_intr
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_report_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_reset
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_reset_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rx
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|rcs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_set_pending
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|u_int
name|cmdf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_simple_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|u_int
name|cmd
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_assoc
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int8_t
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_sc
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ray_start_wrhdr
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ether_header
operator|*
name|eh
operator|,
name|size_t
name|bufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_join_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int8_t
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_join_net
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_start_join_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_STARTJOIN_TIMO */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ray_stop
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_update_error_counters
decl|\
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_update_mcast
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_update_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_update_params_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int
name|stat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_update_promisc
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_update_subcmd
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_user_update_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_param_req
operator|*
name|pr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_user_report_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_param_req
operator|*
name|pr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_user_report_stats
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_stats_req
operator|*
name|sr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PCMCIA driver definition  */
end_comment

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|ray
argument_list|,
name|ray_pccard_init
argument_list|,
name|ray_pccard_unload
argument_list|,
name|ray_pccard_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ISA driver definition  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|raydriver
init|=
block|{
name|ray_probe
block|,
name|ray_attach
block|,
literal|"ray"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Command function tables - based on bit index in SCP_xx  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ray_cmd_func_t
function_decl|)
parameter_list|(
name|struct
name|ray_softc
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|ray_cmd_func_t
name|ray_cmdtab
index|[]
init|=
block|{
name|ray_update_subcmd
block|,
comment|/* SCP_UPDATESUBCMD */
name|ray_start_assoc
block|,
comment|/* SCP_STARTASSOC */
name|ray_report_params
block|,
comment|/* SCP_REPORTPARAMS */
name|ray_start_sc
comment|/* SCP_IFSTART */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ncmdtab
init|=
sizeof|sizeof
argument_list|(
name|ray_cmdtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|ray_cmdtab
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ray_cmd_func_t
name|ray_subcmdtab
index|[]
init|=
block|{
name|ray_download_params
block|,
comment|/* SCP_UPD_STARTUP */
name|ray_start_join_net
block|,
comment|/* SCP_UPD_STARTJOIN */
name|ray_update_promisc
block|,
comment|/* SCP_UPD_PROMISC */
name|ray_update_mcast
block|,
comment|/* SCP_UPD_MCAST */
name|ray_update_params
comment|/* SCP_UPD_UPDATEPARAMS */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_nsubcmdtab
init|=
sizeof|sizeof
argument_list|(
name|ray_subcmdtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|ray_subcmdtab
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Indirections for reading/writing shared memory - from NetBSD/if_ray.c  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((size_t)(&((type *)0)->member))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* offsetof */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|(u_int8_t)*((sc)->maddr + (off))
end_define

begin_comment
comment|/* ((u_int8_t)bus_space_read_1((sc)->sc_memt, (sc)->sc_memh, (off))) */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|SRAM_READ_1(sc, (off) + offsetof(struct s, f))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|((((u_int16_t)SRAM_READ_1(sc, (off) + offsetof(struct s, f))<< 8) \     |(SRAM_READ_1(sc, (off) + 1 + offsetof(struct s, f)))))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_read_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_read_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((sc)->maddr + (off), (vp), (n))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|*((sc)->maddr + (off)) = (val)
end_define

begin_comment
comment|/* bus_space_write_1((sc)->sc_memt, (sc)->sc_memh, (off), (val)) */
end_comment

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
define|\
value|SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (v))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
value|do {	\     SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (((v)>> 8 )& 0xff)); \     SRAM_WRITE_1(sc, (off) + 1 + offsetof(struct s, f), ((v)& 0xff)); \ } while (0)
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_write_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_write_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((vp), (sc)->maddr + (off), (n))
end_define

begin_comment
comment|/*  * Macro's and constants  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_CCS_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_CCS_TIMEOUT
value|(hz / 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_CHECK_SCHED_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_CHECK_SCHED_TIMEOUT
value|(hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_RESET_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_RESET_TIMEOUT
value|(10 * hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_START_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_START_TIMEOUT
value|(hz / 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|RAY_SIMPLE_TX
end_if

begin_define
define|#
directive|define
name|RAY_IFQ_MAXLEN
value|(2)
end_define

begin_else
else|#
directive|else
else|if RAY_DECENT_TX
end_else

begin_define
define|#
directive|define
name|RAY_IFQ_MAXLEN
value|(RAY_CCS_TX_LAST+1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAY_CCS_FREE
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
define|\
value|SRAM_WRITE_FIELD_1((sc), (ccs), ray_cmd, c_status, RAY_CCS_STATUS_FREE)
end_define

begin_define
define|#
directive|define
name|RAY_ECF_READY
parameter_list|(
name|sc
parameter_list|)
value|(!(ray_read_reg(sc, RAY_ECFIR)& RAY_ECFIR_IRQ))
end_define

begin_define
define|#
directive|define
name|RAY_ECF_START_CMD
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_ECFIR, RAY_ECFIR_IRQ)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_CLEAR_INTR
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_HCSIR, 0)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_INTR
parameter_list|(
name|sc
parameter_list|)
value|(ray_read_reg(sc, RAY_HCSIR)& RAY_HCSIR_IRQ)
end_define

begin_comment
comment|/*  * As described in if_xe.c...  *  * Horrid stuff for accessing CIS tuples and remapping common memory...  */
end_comment

begin_define
define|#
directive|define
name|CARD_MAJOR
value|50
end_define

begin_decl_stmt
specifier|static
name|int
name|ray_attr_write
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
name|byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attr_read
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
operator|*
name|buf
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_read_reg
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_attr_getmap
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_attr_cm
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_cm(sc)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
end_comment

begin_comment
comment|/*  * PCCard initialise.  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_init
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|doRemap
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: PCCard probe\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NRAY
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
name|sc
operator|->
name|slotnum
operator|=
name|dev_p
operator|->
name|slt
operator|->
name|slotnum
expr_stmt|;
name|ray_attr_getmap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: Memory window flags 0x%02x, start %p, size 0x%x, card address 0x%lx\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|sc
operator|->
name|md
operator|.
name|flags
operator|,
name|sc
operator|->
name|md
operator|.
name|start
operator|,
name|sc
operator|->
name|md
operator|.
name|size
operator|,
name|sc
operator|->
name|md
operator|.
name|card
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
if|#
directive|if
name|RAY_NEED_CM_FIXUP
name|doRemap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|start
operator|==
literal|0x0
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: pccardd did not map CM - giving up\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|flags
operator|!=
name|MDF_ACTIVE
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM flags from 0x%x to 0x40\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|flags
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|flags
operator|=
name|MDF_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|size
operator|!=
literal|0xc000
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM size from 0x%x to 0xc000\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|size
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|size
operator|=
literal|0xc000
expr_stmt|;
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
operator|=
name|sc
operator|->
name|md
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|card
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM card address from 0x%lx to 0x0\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|card
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|card
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doRemap
condition|)
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_FIXUP */
name|sc
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|maddr
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_flags
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d:<Raylink/IEEE 802.11> maddr %p msize 0x%x irq %d flags 0x%x on isa (PC-Card slot %d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|maddr
argument_list|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
argument_list|,
name|ffs
argument_list|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|sc
operator|->
name|flags
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ray_attach
argument_list|(
operator|&
name|dev_p
operator|->
name|isahd
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCCard unload.  */
end_comment

begin_function
specifier|static
name|void
name|ray_pccard_unload
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: PCCard unload\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: already unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Clear out timers and sort out driver state      *      * We use callout_stop to unconditionally kill the ccs and general      * timers as they are used with multiple arguments.      */
if|#
directive|if
name|RAY_USE_CALLOUT_STOP
name|callout_stop
argument_list|(
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|ray_check_ccs
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_check_scheduled
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_USE_CALLOUT_STOP */
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|untimeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/*      * Mark as not running      */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/*      * Cleardown interface      */
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX should be if_detach for -current */
comment|/*      * Mark card as gone      */
name|sc
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * process an interrupt  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_intr
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
return|return
operator|(
name|ray_intr
argument_list|(
name|dev_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ISA probe routine.  */
end_comment

begin_function
specifier|static
name|int
name|ray_probe
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ISA probe\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ISA/PCCard attach.  */
end_comment

begin_function
specifier|static
name|int
name|ray_attach
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ISA/PCCard attach\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|id_unit
index|]
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before attach!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*      * Read startup results, check the card is okay and work out what      * version we are using.      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
literal|"\020"
comment|/* print in hex */
literal|"\001RESERVED0"
literal|"\002PROC_SELF_TEST"
literal|"\003PROG_MEM_CHECKSUM"
literal|"\004DATA_MEM_TEST"
literal|"\005RX_CALIBRATION"
literal|"\006FW_VERSION_COMPAT"
literal|"\007RERSERVED1"
literal|"\008TEST_COMPLETE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unsupported firmware version 0x%0x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
operator|||
name|RAY_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Start Up Results\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|printf
argument_list|(
literal|"  Firmware version 4\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  Firmware version 5\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Status 0x%x\n"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Ether address %6D\n"
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_rates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Supported rates %8D\n"
argument_list|,
name|ep
operator|->
name|e_rates
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  Japan call sign %12D\n"
argument_list|,
name|ep
operator|->
name|e_japan_callsign
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_prg_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_cis_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware version %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware revision %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_resv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ASIC version %0x\n"
argument_list|,
name|ep
operator|->
name|e_asic_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  TIB size %0x\n"
argument_list|,
name|ep
operator|->
name|e_tibsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Set the parameters that will survive stop/init      *      * Do not update these in ray_init's parameter setup      */
if|#
directive|if
name|XXX
name|see
name|the
name|ray_init
name|section
for|for stuff to move
endif|#
directive|endif
for|bzero
control|(
operator|&
name|sc
operator|->
name|sc_d
operator|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
control|)
empty_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_c
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Initialise the network interface structure      */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|e_station_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ray"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
if|#
directive|if
name|XXX
name|ifp
operator|->
name|if_hdr
operator|=
operator|...
expr_stmt|;
name|make
name|this
name|big
name|enough
name|to
name|hold
name|the
literal|.11
name|and
literal|.3
name|headers
endif|#
directive|endif
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000
expr_stmt|;
comment|/* Is this baud or bps ;-) */
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ray_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ray_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ray_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ray_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|RAY_IFQ_MAXLEN
expr_stmt|;
comment|/*      * If this logical interface has already been attached,      * don't attach it again or chaos will ensue.      */
name|sprintf
argument_list|(
name|ifname
argument_list|,
literal|"ray%d"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifunit
argument_list|(
name|ifname
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBFFILTER */
if|#
directive|if
name|XXX
name|this
name|looks
name|like
name|a
name|good
name|idea
name|at_shutdown
argument_list|(
name|ray_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* XXX */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Network initialisation.  *  * Start up flow is as follows.  * The kernel calls ray_init when the interface is assigned an address.  *   * ray_init does a bit of house keeping before calling ray_download_params.  *  * ray_download_params fills the startup parameter structure out and  * sends it to the card. The download command simply completes, so we  * use the timeout code in ray_check_ccs instead of spin locking. The  * passes flow to the standard ccs handler and we eventually end up in  * ray_download_done.  *  * ray_download_done tells the card to start an adhoc network or join  * a managed network. This should complete via the interrupt  * mechanism, but the NetBSD driver includes a timeout for some buggy  * stuff somewhere - I've left the hooks in but don't use them. The  * interrupt handler passes control to ray_start_join_done - the ccs  * is handled by the interrupt mechanism.  *  * Once ray_start_join_done has checked the ccs and uploaded/updated  * the network parameters we are ready to process packets. It is then  * safe to call ray_start which is done by the interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ray_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network init\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before init!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Reset instance variables      *      * The first set are network parameters that are read back when      * the card starts or joins the network.      *      * The second set are network parameters that are downloaded to      * the card.      *      * The third set are driver parameters.      *      * All of the variables in these sets can be updated by the card or ioctls.      */
if|#
directive|if
name|XXX
name|see
name|the
name|ray_attach
name|section
for|for stuff to move
endif|#
directive|endif
for|sc->sc_d.np_upd_param = 0
empty_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_bss_id
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_inited
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
operator|=
name|RAY_MIB_BASIC_RATE_SET_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|=
name|RAY_MIB_NET_TYPE_DEFAULT
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|RAY_MIB_SSID_DEFAULT
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
operator|=
name|RAY_MIB_PRIVACY_CAN_JOIN_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_promisc
operator|=
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|translation
operator|=
name|SC_TRANSLATE_WEBGEAR
expr_stmt|;
comment|/* Set all ccs to be free */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|)
argument_list|)
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_CCS_LAST
condition|;
name|ccs
operator|+=
name|RAY_CCS_SIZE
operator|,
name|i
operator|++
control|)
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|Not
name|sure
name|why
name|I
name|really
name|need
name|this
operator|-
name|maybe
name|best
name|to
name|deal
name|with
name|this
name|when
name|resets
name|are
name|requested
name|by
name|me
condition|?
endif|#
directive|endif
comment|/* XXX */
comment|/*      * Get startup results - the card may have been reset      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
literal|"\020"
comment|/* print in hex */
literal|"\001RESERVED0"
literal|"\002PROC_SELF_TEST"
literal|"\003PROG_MEM_CHECKSUM"
literal|"\004DATA_MEM_TEST"
literal|"\005RX_CALIBRATION"
literal|"\006FW_VERSION_COMPAT"
literal|"\007RERSERVED1"
literal|"\008TEST_COMPLETE"
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX This doesn't mark the interface as down */
block|}
comment|/*      * Fixup tib size to be correct - on build 4 it is garbage      */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_tibsize
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_tibsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_tib
argument_list|)
expr_stmt|;
comment|/*      * We are now up and running. Next we have to download network      * configuration into the card. We are busy until download is done.      */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
expr_stmt|;
name|ray_download_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Network stop.  *  * Assumes that a ray_init is used to restart the card.  *  */
end_comment

begin_function
specifier|static
name|void
name|ray_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network stop\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before stop!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/*      * Clear out timers and sort out driver state      */
if|#
directive|if
name|RAY_USE_CALLOUT_STOP
name|callout_stop
argument_list|(
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|ray_check_ccs
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_check_scheduled
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_USE_CALLOUT_STOP */
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|untimeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxoverflow
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxcksum
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxhcksum
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxnoise
operator|=
literal|0
expr_stmt|;
comment|/*      * Inhibit card - if we can't prevent reception then do not worry;      * stopping a NIC only guarantees no TX.      */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* XXX what does the SHUTDOWN command do? Or power saving in COR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*      * Mark as not running      */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Reset the card  *  * I'm using the soft reset command in the COR register. I'm not sure  * if the sequence is right but it does seem to do the right thing. A  * nano second after reset is written the flashing light goes out, and  * a few seconds after the default is written the main card light goes  * out. We wait a while and then re-init the card.  */
end_comment

begin_function
specifier|static
name|void
name|ray_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_reset\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: resetting card\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_attr_write
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|RAY_COR
argument_list|,
name|RAY_COR_RESET
argument_list|)
expr_stmt|;
name|ray_attr_write
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|RAY_COR
argument_list|,
name|RAY_COR_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reset_timerh
operator|=
name|timeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|RAY_RESET_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Finishing resetting and restarting the card  */
end_comment

begin_function
specifier|static
name|void
name|ray_reset_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_reset_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_reset_timo still busy, re-schedule\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reset_timerh
operator|=
name|timeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|RAY_RESET_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network watchdog\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before watchdog!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ray%d: watchdog timeout\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX may need to have remedial action here    for example    	ray_reset 	    ray_stop 	    ... 	    ray_init      do we only use on TX?     	if so then we should clear OACTIVE etc.  */
return|return;
block|}
end_function

begin_comment
comment|/*  * Network ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ray_param_req
name|pr
decl_stmt|;
name|struct
name|ray_stats_req
name|sr
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|error2
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network ioctl\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before ioctl!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error2
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl SIFADDR/GIFADDR/SIFMTU\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: for SIFFLAGS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * If the interface is marked up and stopped, then start 	     * it. If it is marked down and running, then stop it. 	     */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_update_promisc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* XXX DROP THROUGH or not? */
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for ADDMULTI/DELMULTI\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_update_mcast
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSRAYPARAM
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for SRAYPARAM\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ray_user_update_params
argument_list|(
name|sc
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|pr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYPARAM
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GRAYPARAM\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ray_user_report_params
argument_list|(
name|sc
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|pr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYSTATS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GRAYSTATS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_user_report_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|sr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFFLAGS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMETRIC
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFMETRIC\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMTU
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFMTU\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFPHYS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFPYHS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for SIFMEDIA\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFMEDIA\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Network start.  *  * Start sending a packet.  *  * We make two assumptions here:  *  1) That the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) That the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|ray_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|ray_start_sc
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_start_sc
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pktlen
decl_stmt|,
name|len
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_sc\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/*      * Some simple checks first      */
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before start!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|!
name|sc
operator|->
name|sc_havenet
condition|)
return|return;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_start busy, schedule a timeout\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|start_timerh
operator|=
name|timeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|RAY_START_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
comment|/*      * Simple one packet at a time TX routine - probably appaling performance      * and we certainly chew CPU. However bing to windows boxes shows      * a reliance on the far end too:      *      * 1500k default rate      *      * Libretto 50CT (75MHz Pentium) with FreeBSD-3.1 to      *   Nonname box Windows 95C (133MHz AMD 5x86) 		 996109bps      *   AST J30 Windows 95A (100MHz Pentium) 			1307791bps      *      * 2000k default rate      *      * Libretto 50CT (75MHz Pentium) with FreeBSD-3.1 to      *   Nonname box Windows 95C (133MHz AMD 5x86) 		1087049bps      *   AST J30 Windows 95A (100MHz Pentium) 			1307791bps      *      * Flow is      *		get a ccs      *		build the packet      *		set IFF_OACTIVE      *		interrupt the card to send the packet      *		exit      *      *		wait for interrupt telling us the packet has been sent      *		clear IFF_OACTIVE      *		get called by the interrupt routine if any packets left      */
comment|/*      * Find a free ccs; if none available wave good bye and exit.      *      * We find a ccs before we process the mbuf so that we are sure it      * is worthwhile processing the packet. All errors in the mbuf      * processing are either errors in the mbuf or gross configuration      * errors and the packet wouldn't get through anyway.      *      * Don't forget to clear the ccs on errors.      */
name|i
operator|=
name|RAY_CCS_TX_FIRST
expr_stmt|;
do|do
block|{
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RAY_CCS_STATUS_FREE
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<=
name|RAY_CCS_TX_LAST
condition|)
do|;
if|if
condition|(
name|i
operator|>
name|RAY_CCS_TX_LAST
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_start using ccs 0x%02x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Reserve and fill the ccs - must do the length later.      *      * Even though build 4 and build 5 have different fields all these      * are common apart from tx_rate. Neither the NetBSD driver or Linux      * driver bother to overwrite this for build 4 cards.      */
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|RAY_TX_BASE
operator|+
name|i
operator|*
name|RAY_TX_BUF_SIZE
expr_stmt|;
name|bufp
operator|+=
name|sc
operator|->
name|sc_tibsize
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_cmd
argument_list|,
name|RAY_CMD_TX_REQ
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_bufp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_tx_rate
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_apm_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_antenna
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|bufp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_phy_header
argument_list|)
expr_stmt|;
comment|/*      * Get the mbuf and process it - we have to remember to free the      * ccs if there are any errors      */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|pktlen
operator|=
literal|0
operator|,
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: mbuf too long %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX      * I would much prefer to have the complete 802.11 packet dropped to      * the bpf tap and then have a user land program parse the headers      * as needed. This way, tcpdump -w can be used to grab the raw data. If      * needed the 802.11 aware program can "translate" the .11 to ethernet      * for tcpdump -r.      */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBPFILTER */
comment|/*      * Translation - capability as described earlier      *      * Each case must write the 802.11 header using ray_start_wrhdr,      * passing a pointer to the ethernet header in and getting a new      * tc buffer pointer. Next remove/modify/addto the 802.3 and 802.2      * headers as needed.      *      * We've pulled up the mbuf for you.      *      */
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_start could not pullup ether\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|translation
condition|)
block|{
case|case
name|SC_TRANSLATE_WEBGEAR
case|:
name|bufp
operator|=
name|ray_start_wrhdr
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_start unknown translation type 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|translation
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m0
operator|=
name|m_free
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_start could not translate mbuf\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|pktlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
expr_stmt|;
comment|/*      * Copy the mbuf to the buffer in common memory      *      * We panic and don't bother wrapping as ethernet packets are 1518      * bytes, we checked the mbuf earlier, and our TX buffers are 2048      * bytes. We don't have 530 bytes of headers etc. so something      * must be fubar.      */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bufp
operator|+
name|len
operator|)
operator|<
name|RAY_TX_END
condition|)
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ray%d: ray_start tx buffer overflow\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
name|RAY_DMBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
literal|"ray_start"
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/*      * Fill in a few loose ends and kick the card to send the packet      */
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 	 * From NetBSD code: 	 * 	 * If this can really happen perhaps we need to save 	 * the chain and use it later.  I think this might 	 * be a confused state though because we check above 	 * and don't issue any commands between. 	 */
name|printf
argument_list|(
literal|"ray%d: ray_tx device busy\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_len
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|XXX_NETBSDTX
end_if

begin_decl_stmt
name|netbsd
name|driver
name|uses
name|a
name|loop
name|repeat
name|get
name|a
name|ccs
name|get
name|a
name|mbuf
name|translate
name|and
name|send
name|packet
name|to
name|shared
name|ram
name|until
argument_list|(
name|no
name|more
name|ccs
literal|'s) || (no more mbuf'
name|s
argument_list|)
name|send
name|ccs
name|chain
name|to
name|card
name|exit
name|Linux
name|driver
name|is
name|simple
name|single
name|shot
name|packet
argument_list|(
name|with
name|a
name|lot
name|of
name|spinlocks
operator|!
argument_list|)
name|general
name|the
name|tx
name|space
name|is
decl|0x7000
init|=
literal|28kB
decl_stmt|,
name|and
name|TX
name|buffer
name|size
name|is
decl|2048
name|so
name|there
name|can
name|be
decl|14
name|requests
name|at
decl|2kB
name|each
name|from
name|this
decl|2k
name|we
name|have
name|to
name|remove
name|the
name|TIB
decl|-
name|whatever
name|that
name|is
decl|- for
name|data
name|netbsd
range|:
name|we
name|need
name|to
name|call
name|_start
name|after
name|receiveing
name|a
name|packet
name|to
name|see
end_decl_stmt

begin_if
if|if any packets were queued whilst in the interrupt  	there is a potential race in obtaining ccss for the tx
operator|,
name|in
name|that
name|we
name|might
name|be
name|in
name|_start
name|synchronously
name|and
name|then
name|an
name|rx
name|interrupt
name|occurs
operator|.
name|the
name|rx
name|will
name|call
name|_start
name|and
name|steal
name|tx
name|ccs
name|from
name|underneath
name|the
name|interrupted
name|entry
operator|.
name|toptions
name|dont
name|call
name|_start
name|from
name|rx
name|interrupt
name|find
name|a
name|safe
name|way
name|of
name|locking
name|find
name|a
name|better
name|way
name|of
name|obtaining
name|ccs
name|using
name|next
name|free
name|avilable
condition|?
name|look
name|at
name|other
name|drivers
name|use
name|tsleep
operator|/
name|wakeup
name|some
name|form
name|of
name|ring
name|to
name|hold
name|ccs
name|free
name|lsit
name|rework
name|calling
endif|#
directive|endif
endif|XXX_NETBSDTX
comment|/*  * TX completion routine.  *  * Clear ccs and network flags.  */
specifier|static
name|void
name|ray_start_done
argument_list|(
argument|sc
argument_list|,
argument|ccs
argument_list|,
argument|status
argument_list|)
expr|struct
name|ray_softc
operator|*
name|sc
expr_stmt|;
end_if

begin_decl_stmt
name|size_t
name|ccs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8_t
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
modifier|*
name|status_string
index|[]
init|=
name|RAY_CCS_STATUS_STRINGS
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RAY_CCS_STATUS_COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_start tx completed but status is %s.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|status_string
index|[
name|status
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Start timeout routine.  *  * Used when card was busy but we needed to send a packet.  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Write an 802.11 header into the TX buffer and return the  * adjusted buffer pointer.  */
end_comment

begin_function
specifier|static
name|size_t
name|ray_start_wrhdr
parameter_list|(
name|sc
parameter_list|,
name|eh
parameter_list|,
name|bufp
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|size_t
name|bufp
decl_stmt|;
block|{
name|struct
name|ieee80211_header
name|header
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_wrhdr\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
name|header
operator|.
name|i_fc
index|[
literal|0
index|]
operator|=
operator|(
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
block|{
name|header
operator|.
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_STA_TO_STA
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|header
operator|.
name|i_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|header
operator|.
name|i_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|header
operator|.
name|i_addr3
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|==
name|RAY_MIB_AP_STATUS_TERMINAL
condition|)
block|{
name|header
operator|.
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_STA_TO_AP
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|header
operator|.
name|i_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|header
operator|.
name|i_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|header
operator|.
name|i_addr3
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"ray%d: ray_start can't be an AP yet\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bufp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * receive a packet from the card  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx
parameter_list|(
name|sc
parameter_list|,
name|rcs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|rcs
decl_stmt|;
block|{
name|struct
name|ieee80211_header
modifier|*
name|header
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|size_t
name|pktlen
decl_stmt|,
name|fraglen
decl_stmt|,
name|readlen
decl_stmt|,
name|tmplen
decl_stmt|;
name|size_t
name|bufp
decl_stmt|,
name|ebufp
decl_stmt|;
name|u_int8_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|u_int8_t
name|fc
decl_stmt|;
name|u_int
name|first
decl_stmt|,
name|ni
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_rx\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: rcs chain - using rcs 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|rcs
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|readlen
operator|=
literal|0
expr_stmt|;
comment|/*      * Get first part of packet and the length. Do some sanity checks      * and get a mbuf.      */
name|first
operator|=
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pktlen
operator|>
name|MCLBYTES
operator|)
operator|||
operator|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|)
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx packet is too big or too small\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx MGETHDR failed\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx MCLGET failed\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pktlen
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
name|dst
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
comment|/*      * Walk the fragment chain to build the complete packet.      *      * The use of two index variables removes a race with the      * hardware. If one index were used the clearing of the CCS would      * happen before reading the next pointer and the hardware can get in.      * Not my idea but verbatim from the NetBSD driver.      */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_bufp
argument_list|)
expr_stmt|;
name|fraglen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|50
argument_list|,
operator|(
literal|"ray%d: ray_rx frag index %d len %d bufp 0x%x ni %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|i
operator|,
name|fraglen
operator|,
operator|(
name|int
operator|)
name|bufp
operator|,
name|ni
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fraglen
operator|+
name|readlen
operator|>
name|pktlen
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx bad length current 0x%x pktlen 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|fraglen
operator|+
name|readlen
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|RAY_RCS_FIRST
operator|)
operator|||
operator|(
name|i
operator|>
name|RAY_RCS_LAST
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_rx bad rcs index 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|ebufp
operator|=
name|bufp
operator|+
name|fraglen
expr_stmt|;
if|if
condition|(
name|ebufp
operator|<=
name|RAY_RX_END
condition|)
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
name|fraglen
argument_list|)
expr_stmt|;
else|else
block|{
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
operator|(
name|tmplen
operator|=
name|RAY_RX_END
operator|-
name|bufp
operator|)
argument_list|)
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_RX_BASE
argument_list|,
name|dst
operator|+
name|tmplen
argument_list|,
name|ebufp
operator|-
name|RAY_RX_END
argument_list|)
expr_stmt|;
block|}
name|dst
operator|+=
name|fraglen
expr_stmt|;
name|readlen
operator|+=
name|fraglen
expr_stmt|;
block|}
name|skip_read
label|:
comment|/*      * Walk the chain again to free the rcss.      */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return;
name|RAY_DMBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
literal|"ray_rx"
argument_list|)
expr_stmt|;
comment|/*      * Check the 802.11 packet type and obtain the .11 src addresses.      *      * XXX CTL and MGT packets will have separate functions, DATA with here      *      * XXX This needs some work for INFRA mode      */
name|header
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_header
operator|*
argument_list|)
expr_stmt|;
name|fc
operator|=
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fc
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: header not version 0 fc 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|fc
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|fc
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a MGT packet - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a CTL packet - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|RAY_DPRINTFN
argument_list|(
literal|50
argument_list|,
operator|(
literal|"ray%d: ray_rx got a DATA packet\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a unknown packet fc0 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
name|fc
operator|=
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|fc
operator|&
name|IEEE80211_FC1_DS_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_STA_TO_STA
case|:
name|src
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|50
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from sta %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|src
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_STA_TO_AP
case|:
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from sta %6D to ap %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|header
operator|->
name|i_addr2
operator|,
literal|":"
operator|,
name|header
operator|->
name|i_addr3
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_AP_TO_STA
case|:
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from ap %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|header
operator|->
name|i_addr3
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_AP_TO_AP
case|:
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx saw packet between aps %6D %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|header
operator|->
name|i_addr1
operator|,
literal|":"
operator|,
name|header
operator|->
name|i_addr2
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx packet type unknown fc1 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Translation - capability as described earlier      *      * Each case must remove the 802.11 header and leave an 802.3      * header in the mbuf copy addresses as needed.      */
switch|switch
condition|(
name|sc
operator|->
name|translation
condition|)
block|{
case|case
name|SC_TRANSLATE_WEBGEAR
case|:
comment|/* Nice and easy - just trim the 802.11 header */
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx unknown translation type 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|translation
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Finally, do a bit of house keeping before sending the packet      * up the stack.      */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBPFILTER */
if|#
directive|if
name|XXX_PROM
name|if_wi
operator|.
name|c
operator|-
name|might
name|be
name|needed
if|if we hear our own broadcasts in promiscuous mode but will not be if we dont see them 	if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* XXX_PROM */
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * XXX NOT KNF FROM HERE UP  ******************************************************************************/
end_comment

begin_comment
comment|/*  * an update params command has completed lookup which command and  * the status  *  * XXX this isn't finished yet, we need to grok the command used  */
end_comment

begin_function
specifier|static
name|void
name|ray_update_params_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int
name|stat
parameter_list|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_update_params_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_update_params_done stat %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|stat
operator|)
argument_list|)
expr_stmt|;
comment|/* this will get more complex as we add commands */
if|if
condition|(
name|stat
operator|==
name|RAY_CCS_STATUS_FAIL
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: failed to update a promisc\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX should probably reset */
comment|/* rcmd = ray_reset; */
block|}
if|if
condition|(
name|sc
operator|->
name|sc_running
operator|&
name|SCP_UPD_PROMISC
condition|)
block|{
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_PROMISC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_promisc
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: new promisc value %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|sc
operator|->
name|sc_promisc
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_updreq
condition|)
block|{
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_UPDATEPARAMS
argument_list|)
expr_stmt|;
comment|/* get the update parameter */
name|sc
operator|->
name|sc_updreq
operator|->
name|r_failcause
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_failcause
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_updreq
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|ray_update_params
argument_list|)
expr_stmt|;
name|ray_start_join_net
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  check too see if we have any pending commands.  */
end_comment

begin_function
specifier|static
name|void
name|ray_check_scheduled
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|mask
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_check_scheduled\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_check_scheduled schd 0x%x running 0x%x ready %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|sc
operator|->
name|sc_scheduled
operator|,
name|sc
operator|->
name|sc_running
operator|,
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_timoneed
condition|)
block|{
name|untimeout
argument_list|(
name|ray_check_scheduled
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timoneed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if update subcmd is running -- clear it in scheduled */
if|if
condition|(
name|sc
operator|->
name|sc_running
operator|&
name|SCP_UPDATESUBCMD
condition|)
name|sc
operator|->
name|sc_scheduled
operator|&=
operator|~
name|SCP_UPDATESUBCMD
expr_stmt|;
name|mask
operator|=
name|SCP_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ray_ncmdtab
condition|;
name|mask
operator|<<=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_scheduled
operator|&
operator|~
name|SCP_UPD_MASK
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sc
operator|->
name|sc_scheduled
operator|&
name|mask
condition|)
call|(
modifier|*
name|ray_cmdtab
index|[
name|i
index|]
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_check_scheduled sched 0x%x running 0x%x ready %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|sc
operator|->
name|sc_scheduled
operator|,
name|sc
operator|->
name|sc_running
operator|,
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_scheduled
operator|&
operator|~
name|SCP_UPD_MASK
condition|)
name|ray_set_pending
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_scheduled
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * check for unreported returns  *  * this routine is coded to only expect one outstanding request for the  * timed out requests at a time, but thats all that can be outstanding  * per hardware limitations  */
end_comment

begin_function
specifier|static
name|void
name|ray_check_ccs
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|cmd
decl_stmt|,
name|stat
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_check_ccs\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ccs
operator|=
literal|0
expr_stmt|;
name|stat
operator|=
name|RAY_CCS_STATUS_FAIL
expr_stmt|;
name|sc
operator|->
name|sc_timocheck
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|RAY_CCS_CMD_FIRST
init|;
name|i
operator|<=
name|RAY_CCS_CMD_LAST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
condition|)
continue|continue;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_CMD_START_PARAMS
case|:
case|case
name|RAY_CMD_UPDATE_MCAST
case|:
case|case
name|RAY_CMD_UPDATE_PARAMS
case|:
name|stat
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: check ccs idx %d ccs 0x%x "
literal|"cmd 0x%x stat %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|i
operator|,
name|ccs
operator|,
name|cmd
operator|,
name|stat
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|breakout
goto|;
block|}
block|}
name|breakout
label|:
comment|/* see if we got one of the commands we are looking for */
if|if
condition|(
name|i
operator|>
name|RAY_CCS_CMD_LAST
condition|)
empty_stmt|;
comment|/* nothign */
elseif|else
if|if
condition|(
name|stat
operator|==
name|RAY_CCS_STATUS_FREE
condition|)
block|{
name|stat
operator|=
name|RAY_CCS_STATUS_COMPLETE
expr_stmt|;
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|!=
name|RAY_CCS_STATUS_BUSY
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
comment|/* give a chance for the interrupt to occur */
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_timocheck
condition|)
block|{
name|sc
operator|->
name|ccs_timerh
operator|=
name|timeout
argument_list|(
name|ray_check_ccs
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timocheck
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|ccs_timerh
operator|=
name|timeout
argument_list|(
name|ray_check_ccs
argument_list|,
name|sc
argument_list|,
name|RAY_CCS_TIMEOUT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timocheck
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read the counters, the card implements the following protocol  * to keep the values from being changed while read:  It checks  * the `own' bit and if zero writes the current internal counter  * value, it then sets the `own' bit to 1.  If the `own' bit was 1 it  * incremenets its internal counter.  The user thus reads the counter  * if the `own' bit is one and then sets the own bit to 0.  */
end_comment

begin_function
specifier|static
name|void
name|ray_update_error_counters
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|csc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_update_error_counters\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* try and update the error counters */
name|csc
operator|=
name|RAY_STATUS_BASE
expr_stmt|;
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxo_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxoverflow
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrx_overflow
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxo_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxc_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxcksum
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrx_overflow
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxc_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rxhc_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxhcksum
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rx_hcksum
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rxhc_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxnoise
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rx_noise
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process CCS command completion - called from ray_intr  */
end_comment

begin_function
specifier|static
name|void
name|ray_ccs_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|u_int
name|cmd
decl_stmt|,
name|stat
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|stat
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ccs idx %d ccs 0x%x cmd 0x%x status %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|,
name|ccs
operator|,
name|cmd
operator|,
name|stat
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_CMD_START_PARAMS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got START_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_download_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_PARAMS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_update_params_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_REPORT_PARAMS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got REPORT_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
comment|/* get the reported parameters */
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_repreq
condition|)
break|break;
name|sc
operator|->
name|sc_repreq
operator|->
name|r_failcause
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_failcause
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_repreq
operator|->
name|r_len
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|sc
operator|->
name|sc_repreq
operator|->
name|r_data
argument_list|,
name|sc
operator|->
name|sc_repreq
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_repreq
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|ray_report_params
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_MCAST
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_MCAST\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_MCAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|RAY_CCS_STATUS_FAIL
condition|)
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_NET
case|:
case|case
name|RAY_CMD_JOIN_NET
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got START|JOIN_NET\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_start_join_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TX_REQ
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got TX_REQ\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_start_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|stat
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|RAY_CMD_START_ASSOC
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got START_ASSOC\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_STARTASSOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|RAY_CCS_STATUS_FAIL
condition|)
name|ray_start_join_net
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX check */
else|else
block|{
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RAY_CMD_UPDATE_APM
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_APM\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TEST_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got TEST_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_SHUTDOWN
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got SHUTDOWN - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_DUMP_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got DUMP_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_TIMER
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got START_TIMER - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * see if needed things can be done now that a command 	 * has completed 	 */
name|ray_check_scheduled
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process ECF command request - called from ray_intr  */
end_comment

begin_function
specifier|static
name|void
name|ray_rcs_intr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|rcs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: rcs idx %d rcs 0x%x cmd 0x%x status %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
operator|,
name|rcs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_ECMD_RX_DONE
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got RX_DONE\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_rx
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_REJOIN_DONE
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got REJOIN_DONE\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_ROAM_START
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got ROAM_START\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_JAPAN_CALL_SIGNAL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr got JAPAN_CALL_SIGNAL - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process an interrupt  */
end_comment

begin_function
specifier|static
name|int
name|ray_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_intr\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before interrupt!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|++
name|sc
operator|->
name|sc_checkcounters
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|ray_update_error_counters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the interrupt was for us, if so get the rcs/ccs 	 * and vector on the command contained within it. 	 */
if|if
condition|(
operator|!
name|RAY_HCS_INTR
argument_list|(
name|sc
argument_list|)
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_RCSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|RAY_CCS_LAST
condition|)
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
name|RAY_RCS_LAST
condition|)
name|ray_rcs_intr
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ray%d: ray_intr bad ccs index %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ray%d: interrupt %s handled\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|count
condition|?
literal|"was"
else|:
literal|"not"
operator|)
argument_list|)
expr_stmt|;
comment|/* Send any packets lying around */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic CCS handling  */
end_comment

begin_if
if|#
directive|if
name|XXX_NETBSDTX
end_if

begin_comment
comment|/*  * free the chain of descriptors -- used for freeing allocated tx chains  */
end_comment

begin_function
specifier|static
name|void
name|ray_free_ccs_chain
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|ni
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_free_ccs_chain\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|!=
name|RAY_CCS_LINK_NULL
condition|)
block|{
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_link
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|XXX_NETBSDTX
end_endif

begin_comment
comment|/*  * free up a cmd and return the old status.  * this routine is only used for commands.  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ray_free_ccs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|u_int8_t
name|stat
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_free_ccs\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stat
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccs
operator|<=
name|RAY_CCS_ADDRESS
argument_list|(
name|RAY_CCS_LAST
argument_list|)
condition|)
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_free_ccs freed 0x%02x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Obtain a free ccs buffer.  *  * returns 1 and in `ccsp' the bus offset of the free ccs   * or 0 if none are free  *  * If `track' is not zero, handles tracking this command  * possibly indicating a callback is needed and setting a timeout  * also if ECF isn't ready we terminate earlier to avoid overhead.  *  * this routine is only used for commands  */
end_comment

begin_function
specifier|static
name|int
name|ray_alloc_ccs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|u_int
name|track
parameter_list|)
block|{
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_alloc_ccs\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* for tracked commands, if not ready just set pending */
if|if
condition|(
name|track
operator|&&
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|RAY_CCS_CMD_FIRST
init|;
name|i
operator|<=
name|RAY_CCS_CMD_LAST
condition|;
name|i
operator|++
control|)
block|{
comment|/* probe here to make the card go */
operator|(
name|void
operator|)
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|RAY_CCS_CMD_LAST
condition|)
block|{
if|if
condition|(
name|track
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this function sets the pending bit for the command given in 'need'  * and schedules a timeout if none is scheduled already.  Any command  * that uses the `host to ecf' region must be serialized.  */
end_comment

begin_function
specifier|static
name|void
name|ray_set_pending
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cmdf
parameter_list|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_set_pending\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_set_pending 0x%0x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmdf
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scheduled
operator||=
name|cmdf
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_timoneed
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_set_pending new timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ccs_timerh
operator|=
name|timeout
argument_list|(
name|ray_check_scheduled
argument_list|,
name|sc
argument_list|,
name|RAY_CHECK_SCHED_TIMEOUT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timoneed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * schedule the `cmdf' for completion later  */
end_comment

begin_function
specifier|static
name|void
name|ray_cmd_schedule
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmdf
parameter_list|)
block|{
name|int
name|track
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_cmd_schedule\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_cmd_schedule 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmdf
operator|)
argument_list|)
expr_stmt|;
name|track
operator|=
name|cmdf
expr_stmt|;
if|if
condition|(
operator|(
name|cmdf
operator|&
name|SCP_UPD_MASK
operator|)
operator|==
literal|0
condition|)
name|ray_set_pending
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_UPDATESUBCMD
argument_list|)
condition|)
block|{
comment|/* don't do timeout mechaniscm if subcmd already going */
name|sc
operator|->
name|sc_scheduled
operator||=
name|cmdf
expr_stmt|;
block|}
else|else
name|ray_set_pending
argument_list|(
name|sc
argument_list|,
name|cmdf
operator||
name|SCP_UPDATESUBCMD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * check to see if `cmdf' has been scheduled  */
end_comment

begin_function
specifier|static
name|int
name|ray_cmd_is_scheduled
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmdf
parameter_list|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_cmd_is_scheduled\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_cmd_is_scheduled 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmdf
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|sc
operator|->
name|sc_scheduled
operator|&
name|cmdf
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cancel a scheduled command (not a running one though!)  */
end_comment

begin_function
specifier|static
name|void
name|ray_cmd_cancel
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmdf
parameter_list|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_cmd_cancel\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_cmd_cancel 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmdf
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scheduled
operator|&=
operator|~
name|cmdf
expr_stmt|;
if|if
condition|(
operator|(
name|cmdf
operator|&
name|SCP_UPD_MASK
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_scheduled
operator|&
name|SCP_UPD_MASK
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_scheduled
operator|&=
operator|~
name|SCP_UPDATESUBCMD
expr_stmt|;
comment|/* if nothing else needed cancel the timer */
if|if
condition|(
name|sc
operator|->
name|sc_scheduled
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_timoneed
condition|)
block|{
name|untimeout
argument_list|(
name|ray_check_scheduled
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timoneed
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * called to indicate the 'cmdf' has been issued  */
end_comment

begin_function
specifier|static
name|void
name|ray_cmd_ran
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmdf
parameter_list|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_cmd_ran\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_cmd_ran 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmdf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdf
operator|&
name|SCP_UPD_MASK
condition|)
name|sc
operator|->
name|sc_running
operator||=
name|cmdf
operator||
name|SCP_UPDATESUBCMD
expr_stmt|;
else|else
name|sc
operator|->
name|sc_running
operator||=
name|cmdf
expr_stmt|;
if|if
condition|(
operator|(
name|cmdf
operator|&
name|SCP_TIMOCHECK_CMD_MASK
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_timocheck
condition|)
block|{
name|sc
operator|->
name|ccs_timerh
operator|=
name|timeout
argument_list|(
name|ray_check_ccs
argument_list|,
name|sc
argument_list|,
name|RAY_CCS_TIMEOUT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timocheck
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * check to see if `cmdf' has been issued  */
end_comment

begin_function
specifier|static
name|int
name|ray_cmd_is_running
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmdf
parameter_list|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_cmd_is_running\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_cmd_is_running 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmdf
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|sc
operator|->
name|sc_running
operator|&
name|cmdf
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * the given `cmdf' that was issued has completed  */
end_comment

begin_function
specifier|static
name|void
name|ray_cmd_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmdf
parameter_list|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_cmd_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_cmd_done 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmdf
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_running
operator|&=
operator|~
name|cmdf
expr_stmt|;
if|if
condition|(
name|cmdf
operator|&
name|SCP_UPD_MASK
condition|)
block|{
name|sc
operator|->
name|sc_running
operator|&=
operator|~
name|SCP_UPDATESUBCMD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_scheduled
operator|&
name|SCP_UPD_MASK
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_scheduled
operator|&
name|SCP_UPD_MASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_running
operator|&
name|SCP_TIMOCHECK_CMD_MASK
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_timocheck
condition|)
block|{
name|untimeout
argument_list|(
name|ray_check_ccs
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ccs_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timocheck
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * issue the command  * only used for commands not tx  */
end_comment

begin_function
specifier|static
name|int
name|ray_issue_cmd
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int
name|track
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_cmd_issue\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * XXX other drivers did this, but I think  	 * what we really want to do is just make sure we don't 	 * get here or that spinning is ok 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
if|if
condition|(
operator|++
name|i
operator|>
literal|50
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
if|if
condition|(
name|track
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"ray%d: ray_issue_cmd spinning"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_cmd_ran
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * send a simple command if we can  */
end_comment

begin_function
specifier|static
name|int
name|ray_simple_cmd
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|u_int
name|track
parameter_list|)
block|{
name|size_t
name|ccs
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_simple_cmd\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|cmd
argument_list|,
name|track
argument_list|)
operator|&&
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|track
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Functions based on CCS commands  */
end_comment

begin_comment
comment|/*  * run a update subcommand  */
end_comment

begin_function
specifier|static
name|void
name|ray_update_subcmd
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|submask
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_update_subcmd\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPDATESUBCMD
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|submask
operator|=
name|SCP_UPD_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ray_nsubcmdtab
condition|;
name|submask
operator|<<=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_scheduled
operator|&
name|SCP_UPD_MASK
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* when done the next command will be scheduled */
if|if
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_UPDATESUBCMD
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
comment|/* 		 * give priority to LSB -- e.g., if previous loop reschuled 		 * doing this command after calling the function won't catch 		 * if a later command sets an earlier bit 		 */
if|if
condition|(
name|sc
operator|->
name|sc_scheduled
operator|&
operator|(
operator|(
name|submask
operator|-
literal|1
operator|)
operator|&
name|SCP_UPD_MASK
operator|)
condition|)
break|break;
if|if
condition|(
name|sc
operator|->
name|sc_scheduled
operator|&
name|submask
condition|)
call|(
modifier|*
name|ray_subcmdtab
index|[
name|i
index|]
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * report a parameter  */
end_comment

begin_function
specifier|static
name|void
name|ray_report_params
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_report_params\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_repreq
condition|)
return|return;
comment|/* do the issue check before equality check */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|RAY_CMD_REPORT_PARAMS
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
condition|)
return|return;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_paramid
argument_list|,
name|sc
operator|->
name|sc_repreq
operator|->
name|r_paramid
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * start an association  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_assoc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_assoc\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_STARTASSOC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_STARTASSOC
argument_list|)
condition|)
return|return;
operator|(
name|void
operator|)
name|ray_simple_cmd
argument_list|(
name|sc
argument_list|,
name|RAY_CMD_START_ASSOC
argument_list|,
name|SCP_STARTASSOC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * XXX NOT KNF FROM HERE DOWN						      *  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Subcommand functions that use the SCP_UPDATESUBCMD command  * (and are serialized with respect to other update sub commands  */
end_comment

begin_comment
comment|/*  * Download start up structures to card.  *  * Part of ray_init, download, startjoin control flow.  */
end_comment

begin_function
specifier|static
name|void
name|ray_download_params
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ray_mib_4
name|ray_mib_4_default
decl_stmt|;
name|struct
name|ray_mib_5
name|ray_mib_5_default
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Downloading startup parameters\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
expr_stmt|;
define|#
directive|define
name|MIB4
parameter_list|(
name|m
parameter_list|)
value|ray_mib_4_default.##m
define|#
directive|define
name|MIB5
parameter_list|(
name|m
parameter_list|)
value|ray_mib_5_default.##m
define|#
directive|define
name|PUT2
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do { (p)[0] = ((v>> 8)& 0xff); (p)[1] = (v& 0xff); } while(0)
comment|/*       * Firmware version 4 defaults - see if_raymib.h for details       */
name|MIB4
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|MIB4
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB4
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V4
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_max
argument_list|)
operator|=
name|RAY_MIB_CW_MAX_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_min
argument_list|)
operator|=
name|RAY_MIB_CW_MIN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
comment|/*       * Firmware version 5 defaults - see if_raymib.h for details       */
name|MIB5
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|MIB5
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB5
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_max
argument_list|)
argument_list|,
name|RAY_MIB_CW_MAX_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_min
argument_list|)
argument_list|,
name|RAY_MIB_CW_MIN_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_allow_probe_resp
argument_list|)
operator|=
name|RAY_MIB_ALLOW_PROBE_RESP_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_must_start
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_can_join
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
name|MIB5
argument_list|(
name|mib_basic_rate_set
index|[
literal|0
index|]
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_download_params something is already happening\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_4_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_4_default
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_5_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_5_default
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ray_simple_cmd
argument_list|(
name|sc
argument_list|,
name|RAY_CMD_START_PARAMS
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ray%d: ray_download_params can't issue command\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ray%d: Download now awaiting completion\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Download completion routine.  *  * Part of ray_init, download, start_join control flow.  *  * As START_PARAMS is an update command ray_check_ccs has checked the  * ccs status and re-scheduled timeouts if needed.  */
end_comment

begin_function
specifier|static
name|void
name|ray_download_done
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_download_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
expr_stmt|;
comment|/*       * Fake the current network parameter settings so start_join_net      * will not bother updating them to the card (we would need to      * zero these anyway, so we might as well copy).      */
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|ray_start_join_net
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * start or join a network  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_join_net
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_net_params
name|np
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|update
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_join_net\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* XXX check we may not want to re-issue */
if|if
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_UPDATESUBCMD
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
name|cmd
operator|=
name|RAY_CMD_START_NET
expr_stmt|;
else|else
name|cmd
operator|=
name|RAY_CMD_JOIN_NET
expr_stmt|;
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|cmd
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_start_join_net can't get a CCS\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|.
name|p_net_type
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|np
operator|.
name|p_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|np
operator|.
name|p_privacy_must_start
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
name|np
operator|.
name|p_privacy_can_join
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ray%d: ray_start_join_net %s updating nw params\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|update
condition|?
literal|"is"
else|:
literal|"not"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_start_join_net can't issue cmd\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|sc
operator|->
name|sj_timerh
operator|=
name|timeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|RAY_SJ_TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
block|}
end_function

begin_if
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
end_if

begin_comment
comment|/*  * Back stop catcher for start_join command. The NetBSD driver  * suggests that they need it to catch a bug in the firmware or the  * parameters they use - they are not sure. I'll just panic as I seem  * to get interrupts back fine and I have version 4 firmware.  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_join_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_join_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ray%d: ray-start_join_timo occured\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_STARTJOIN_TIMO */
end_comment

begin_comment
comment|/*  * Complete start or join command.  *  * Part of ray_init, download, start_join control flow.  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_join_done
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|,
name|status
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int8_t
name|o_net_type
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_join_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|untimeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
expr_stmt|;
comment|/*      * XXX This switch and the following test are badly done. I      * XXX need to take remedial action in each case branch and      * XXX return from there. Then remove the test.      * XXX FAIL comment       * XXX    if we fired the start command we successfully set the card up      * XXX    so just restart ray_start_join sequence and dont reset the card      * XXX    may need to split download_done for this      * XXX FREE      * XXX    not sure      * XXX BUSY      * XXX    maybe timeout but why would we get an interrupt when      * XXX    the card is not finished?       */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|RAY_CCS_STATUS_FREE
case|:
case|case
name|RAY_CCS_STATUS_BUSY
case|:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done status is FREE/BUSY - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CCS_STATUS_COMPLETE
case|:
break|break;
case|case
name|RAY_CCS_STATUS_FAIL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done status is FAIL - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done unknown status 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|!=
name|RAY_CCS_STATUS_COMPLETE
condition|)
return|return;
comment|/*      * If the command completed correctly, get a few network parameters      * from the ccs and active the network.      */
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
operator|&
name|sc
operator|->
name|sc_c
operator|.
name|p_1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_cmd_net
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust values for buggy build 4 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
expr_stmt|;
comment|/* card is telling us to update the network parameters */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_upd_param
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: sj_done card updating parameters - why?\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|o_net_type
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
expr_stmt|;
comment|/* XXX this may be wrong? */
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|sc
operator|->
name|sc_c
operator|.
name|p_2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_net_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|o_net_type
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: sj_done card changing network type - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|restart
name|ray_start_join
name|sequence
name|may
name|need
name|to
name|split
name|download_done
for|for this
endif|#
directive|endif
block|}
block|}
name|RAY_DNET_DUMP
argument_list|(
name|sc
argument_list|,
literal|" after start/join network completed."
argument_list|)
expr_stmt|;
comment|/*      * Hurrah! The network is now active.      *      * Clearing IFF_OACTIVE will ensure that the system will queue packets.      * Just before we return from the interrupt context we check to      * see if packets have been queued.      */
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_MCAST
operator||
name|SCP_UPD_PROMISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
operator|==
name|RAY_CMD_JOIN_NET
condition|)
name|ray_start_assoc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * XXX NOT KNF FROM HERE UP  ******************************************************************************/
end_comment

begin_comment
comment|/*  * set the card in/out of promiscuous mode  */
end_comment

begin_function
specifier|static
name|void
name|ray_update_promisc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|promisc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_update_promisc\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_PROMISC
argument_list|)
expr_stmt|;
comment|/* do the issue check before equality check */
name|promisc
operator|=
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_UPDATESUBCMD
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_PROMISC
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|promisc
operator|==
name|sc
operator|->
name|sc_promisc
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|RAY_CMD_UPDATE_PARAMS
argument_list|,
name|SCP_UPD_PROMISC
argument_list|)
condition|)
return|return;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_paramid
argument_list|,
name|RAY_MIB_PROMISC
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
name|promisc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|SCP_UPD_PROMISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * update the parameter based on what the user passed in  */
end_comment

begin_function
specifier|static
name|void
name|ray_update_params
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_update_params\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_UPDATEPARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_updreq
condition|)
block|{
comment|/* XXX do we need to wakeup here? */
return|return;
block|}
comment|/* do the issue check before equality check */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_UPDATESUBCMD
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_UPDATEPARAMS
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|RAY_CMD_UPDATE_PARAMS
argument_list|,
name|SCP_UPD_UPDATEPARAMS
argument_list|)
condition|)
return|return;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_paramid
argument_list|,
name|sc
operator|->
name|sc_updreq
operator|->
name|r_paramid
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
name|sc
operator|->
name|sc_updreq
operator|->
name|r_data
argument_list|,
name|sc
operator|->
name|sc_updreq
operator|->
name|r_len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|SCP_UPD_UPDATEPARAMS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set the multicast filter list  */
end_comment

begin_function
specifier|static
name|void
name|ray_update_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_update_mcast\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_MCAST
argument_list|)
expr_stmt|;
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
operator|,
name|count
operator|=
literal|0
init|;
name|ifma
operator|!=
name|NULL
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
operator|,
name|count
operator|++
control|)
comment|/* track this stuff even when not running */
if|if
condition|(
name|count
operator|>
literal|16
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
name|ray_update_promisc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
name|ray_update_promisc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_UPDATESUBCMD
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_MCAST
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|RAY_CMD_UPDATE_MCAST
argument_list|,
name|SCP_UPD_MCAST
argument_list|)
condition|)
return|return;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update_mcast
argument_list|,
name|c_nmcast
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|RAY_HOST_TO_ECF_BASE
expr_stmt|;
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
operator|!=
name|NULL
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|ETHER_ADDR_LEN
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|SCP_UPD_MCAST
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User issued commands  */
end_comment

begin_comment
comment|/*  * issue a update params  *  * expected to be called in sleapable context -- intended for user stuff  */
end_comment

begin_function
specifier|static
name|int
name|ray_user_update_params
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_user_update_params\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|pr
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_EDEVSTOP
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_MAX
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Handle certain parameters specially 	 */
switch|switch
condition|(
name|pr
operator|->
name|r_paramid
condition|)
block|{
case|case
name|RAY_MIB_NET_TYPE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
operator|*
name|pr
operator|->
name|r_data
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_start_join_net
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAY_MIB_SSID
case|:
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
name|pr
operator|->
name|r_data
argument_list|,
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_start_join_net
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAY_MIB_BASIC_RATE_SET
case|:
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
break|break;
case|case
name|RAY_MIB_AP_STATUS
case|:
comment|/* Unsupported */
case|case
name|RAY_MIB_MAC_ADDR
case|:
comment|/* XXX Need interface up */
case|case
name|RAY_MIB_PROMISC
case|:
comment|/* BPF */
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_LASTUSER
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* wait to be able to issue the command */
name|rv
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_UPDATEPARAMS
argument_list|)
operator|||
name|ray_cmd_is_scheduled
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_UPDATEPARAMS
argument_list|)
condition|)
block|{
name|rv
operator|=
name|tsleep
argument_list|(
name|ray_update_params
argument_list|,
literal|0
operator||
name|PCATCH
argument_list|,
literal|"cmd in use"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|pr
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_EDEVSTOP
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|pr
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_WAITING
expr_stmt|;
name|sc
operator|->
name|sc_updreq
operator|=
name|pr
expr_stmt|;
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_UPDATEPARAMS
argument_list|)
expr_stmt|;
name|ray_check_scheduled
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|pr
operator|->
name|r_failcause
operator|==
name|RAY_FAILCAUSE_WAITING
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
name|ray_update_params
argument_list|,
literal|0
argument_list|,
literal|"waiting cmd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ray_update_params
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * issue a report params  *  * expected to be called in sleapable context -- intended for user stuff  */
end_comment

begin_function
specifier|static
name|int
name|ray_user_report_params
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|mib_sizes
index|[]
init|=
name|RAY_MIB_SIZES
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_user_report_params\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|pr
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_EDEVSTOP
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* test for illegal values or immediate responses */
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_LASTUSER
condition|)
block|{
switch|switch
condition|(
name|pr
operator|->
name|r_paramid
condition|)
block|{
case|case
name|RAY_MIB_VERSION
case|:
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
operator|*
name|pr
operator|->
name|r_data
operator|=
literal|4
expr_stmt|;
else|else
operator|*
name|pr
operator|->
name|r_data
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_BSSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_INITED
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_inited
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_DEF_TXRATE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_ENCRYPT
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_NET_TYPE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_SSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_PRIV_START
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_start
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_PRIV_JOIN
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_join
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_BSSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_bss_id
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_INITED
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_inited
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_DEF_TXRATE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_ENCRYPT
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_NET_TYPE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_SSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_PRIV_START
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_PRIV_JOIN
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
name|pr
operator|->
name|r_failcause
operator|=
literal|0
expr_stmt|;
name|pr
operator|->
name|r_len
operator|=
name|mib_sizes
index|[
name|pr
operator|->
name|r_paramid
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* wait to be able to issue the command */
name|rv
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ray_cmd_is_running
argument_list|(
name|sc
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
operator|||
name|ray_cmd_is_scheduled
argument_list|(
name|sc
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
condition|)
block|{
name|rv
operator|=
name|tsleep
argument_list|(
name|ray_report_params
argument_list|,
literal|0
operator||
name|PCATCH
argument_list|,
literal|"cmd in use"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|pr
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_EDEVSTOP
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|pr
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_WAITING
expr_stmt|;
name|sc
operator|->
name|sc_repreq
operator|=
name|pr
expr_stmt|;
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_REPORTPARAMS
argument_list|)
expr_stmt|;
name|ray_check_scheduled
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|pr
operator|->
name|r_failcause
operator|==
name|RAY_FAILCAUSE_WAITING
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
name|ray_report_params
argument_list|,
literal|0
argument_list|,
literal|"waiting cmd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ray_report_params
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return the error counters  */
end_comment

begin_function
specifier|static
name|int
name|ray_user_report_stats
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_stats_req
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_user_report_stats\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sr
operator|->
name|rxoverflow
operator|=
name|sc
operator|->
name|sc_rxoverflow
expr_stmt|;
name|sr
operator|->
name|rxcksum
operator|=
name|sc
operator|->
name|sc_rxcksum
expr_stmt|;
name|sr
operator|->
name|rxhcksum
operator|=
name|sc
operator|->
name|sc_rxhcksum
expr_stmt|;
name|sr
operator|->
name|rxnoise
operator|=
name|sc
operator|->
name|sc_rxnoise
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * XXX NOT KNF FROM HERE DOWN  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Routines to read from/write to the attribute memory.  *  * Taken from if_xe.c.  *  * Until there is a real way of accessing the attribute memory from a driver  * these have to stay.  *  * The hack to use the crdread/crdwrite device functions causes the attribute  * memory to be remapped into the controller and looses the mapping of  * the common memory.  *  * We cheat by using PIOCSMEM and assume that the common memory window  * is in window 0 of the card structure.  *  * Also  *	pccard/pcic.c/crdread does mark the unmapped window as inactive  *	pccard/pccard.c/map_mem toggles the mapping of a window on  *	successive calls  *  */
end_comment

begin_if
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
end_if

begin_function
specifier|static
name|void
name|ray_attr_getmap
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|int
name|result
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: attempting to get map for common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCGMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_attr_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|100
argument_list|,
operator|(
literal|"ray%d: attempting to remap common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCSMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
end_comment

begin_function
specifier|static
name|int
name|ray_attr_write
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|&
name|byte
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_write
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ray_attr_read
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_read
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ray_read_reg
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|off_t
name|reg
decl_stmt|;
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|50
end_if

begin_function
specifier|static
name|void
name|ray_dump_mbuf
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|u_int8_t
modifier|*
name|d
decl_stmt|,
modifier|*
name|ed
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
name|p
index|[
literal|17
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"ray%d: %s mbuf dump:"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
literal|17
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|ed
operator|=
name|d
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|ed
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  %s\n\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|%
literal|16
index|]
operator|=
operator|(
operator|(
operator|*
name|d
operator|>=
literal|0x20
operator|)
operator|&&
operator|(
operator|*
name|d
operator|<
literal|0x80
operator|)
operator|)
condition|?
operator|*
name|d
else|:
literal|'.'
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 50 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRAY */
end_comment

end_unit

