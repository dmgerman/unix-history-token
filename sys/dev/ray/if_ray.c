begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: if_ray.c,v 1.17 2000/04/04 06:43:30 dmlb Exp $  *  */
end_comment

begin_comment
comment|/*	$NetBSD: if_ray.c,v 1.12 2000/02/07 09:36:27 augustss Exp $	*/
end_comment

begin_comment
comment|/*   * Copyright (c) 2000 Christian E. Hopps  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  * Card configuration  * ==================  *  * This card is unusual in that it uses both common and attribute  * memory whilst working. The -stable versions of FreeBSD have a real  * problem managing and setting up the correct memory maps. This  * driver should reset the memory maps correctly under PAO and non-PAO  * -stable systems. Work is in hand to fix these problems for -current.  *  * So, if you want to use this driver make sure that  *	options RAY_NEED_CM_FIXUP  *	options RAY_NEED_CM_REMAPPING  * are in your kernel configuration file.  *  * The first fixes the brain deadness of pccardd (where it reads the  * CIS for common memory, sets it all up and then throws it all away  * assuming the card is an ed driver...). Note that this could be  * dangerous (because it doesn't interact with pccardd) if you  * use other memory mapped cards at the same time.  *  * The second option ensures that common memory is remapped whenever  * we are going to access it (we can't just do it once, as something  * like pccardd may have read the attribute memory and pccard.c  * doesn't re-map the last active window - it remaps the last  * non-active window...).  *  *  * Ad-hoc and infra-structure modes  * ================================  *   * At present only the ad-hoc mode is being worked on.  *  * Apart from just writing the code for infrastructure mode I have a  * few concerns about both the Linux and NetBSD drivers in this area.  * They don't seem to differentiate between the MAC address of the AP  * and the BSS_ID of the network. I presume this is handled when  * joining a managed n/w and the network parameters are updated, but  * I'm not sure. How does this interact with ARP? For mobility we want  * to be able to move around without worrying about which AP we are  * actually talking to - we should always talk to the BSS_ID.  *  * The Linux driver also seems to have the capability to act as an AP.  * I wonder what facilities the "AP" can provide within a driver? We can  * probably use the BRIDGE code to form an ESS but I don't think  * power saving etc. is easy.  *  *  * Packet translation/encapsulation  * ================================  *   * Currently we only support the Webgear encapsulation  *	802.11	header<net/if_ieee80211.h>struct ieee80211_header  *	802.3	header<net/ethernet.h>struct ether_header  *	802.2	LLC header  *	802.2	SNAP header  *  * We should support whatever packet types the following drivers have  *   	if_wi.c		FreeBSD, RFC1042  *	if_ray.c	NetBSD	Webgear, RFC1042  *	rayctl.c	Linux Webgear, RFC1042  * also whatever we can divine from the NDC Access points and Kanda's boxes.  *  * Most drivers appear to have a RFC1042 translation. The incoming packet is  *	802.11	header<net/if_ieee80211.h>struct ieee80211_header  *	802.2	LLC header  *	802.2	SNAP header  *  * This is translated to  *	802.3	header<net/ethernet.h>struct ether_header  *	802.2	LLC header  *	802.2	SNAP header  *  * Linux seems to look at the SNAP org_code and do some translations  * for IPX and APPLEARP on that. This just may be how Linux does IPX  * and NETATALK. Need to see how FreeBSD does these.  *  * Translation should be selected via if_media stuff or link types.  */
end_comment

begin_comment
comment|/*  * TODO  *  * _stop - mostly done  *	would be nice to understand shutdown/or power save to prevent RX  * _reset - done  * 	just needs calling in the right places  *	converted panics to resets - when tx packets are the wrong length  *	may be needed in a couple of other places when I do more commands  * havenet - mostly done  *	i think i've got all the places to set it right, but not so sure  *	we reset it in all the right places  * _unload - done  *	recreated most of stop but as card is unplugged don't try and  *	access it to turn it off  * TX bpf - done  * RX bpf - done  *	I would much prefer to have the complete 802.11 packet dropped to  *	the bpf tap and then have a user land program parse the headers  *	as needed. This way, tcpdump -w can be used to grab the raw data. If  *	needed the 802.11 aware program can "translate" the .11 to ethernet  *	for tcpdump -r  * use std timeout code for download - done  *	was mainly moving a call and removing a load of stuff in  *	download_done as it duplicates check_ccs and ccs_done  * promisoius - done  * add the start_join_net - done  *	i needed it anyway  * remove startccs and startcmd - done  *	as those were used for the NetBSD start timeout  * multicast - done but UNTESTED  *	I don't have the ability/facilty to test this  * rxlevel - done  *	stats reported via raycontrol  * getparams ioctl - done  *	reported via raycontrol  * start_join_done needs a restart in download_done - done  *	now use netbsd style start up  * ioctls - done  *	use raycontrol  *	translation, BSS_ID, countrycode, changing mode  * ifp->if_hdr length - done  * rx level and antenna cache - done  *	antenna not used yet  * antenna tx side - done  *	not tested!  * shutdown - done  *	the driver seems to do the right thing for plugging and unplugging  *	cards  * apm/resume - ignore  *	apm+pccard is borken for 3.x - no one knows how to do it anymore  * fix the XXX code in start_join_done - n/a  *	i've removed this as the error handling should be consistent for  *	all ECF commands and none of the other commands bother!  *  * ***unload needs to drain comq  * ***unload checks in more routines  * ***IFF_RUNNING checks are they really needed?  * ***PCATCH tsleeps and have something that will clean the runq  * havenet needs checking again  * error handling of ECF command completions  * proper setting of mib_hop_seq_len with country code for v4 firmware  * _reset - check where needed  * splimp or splnet?  * faster TX routine  * more translations  * infrastructure mode - maybe need some of the old stuff for checking?  * differeniate between parameters set in attach and init  * spinning in ray_cmd_issue  * make RAY_DEBUG a knob somehow - either sysctl or IFF_DEBUG  * ray_update_params_done needs work  * callout handles need rationalising. can probably remove sj_timerh  * replace sc_comtimo with callout_pending() - see /sys/kern/kern_timeout.c  *   unfortunately not in 3.2  * fragmentation when rx level drops?  * make RAY_DPRINTFN RAY_DPRINTF  * rationalise CM mapping if needed - might mean moving a couple of things  */
end_comment

begin_define
define|#
directive|define
name|XXX
value|0
end_define

begin_define
define|#
directive|define
name|XXX_NETBSDTX
value|0
end_define

begin_define
define|#
directive|define
name|XXX_CLEARCCS_IN_INIT
value|0
end_define

begin_define
define|#
directive|define
name|XXX_ASSOCWORKING_AGAIN
value|0
end_define

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_comment
comment|/*  * RAY_DEBUG settings  *  *	RECERR		Recoverable error's  *	SUBR		Subroutine entry  *	BOOTPARAM	Startup CM dump  *	STARTJOIN	State transitions for start/join  *	CCS		CCS info  *	IOCTL		IOCTL calls  *	NETPARAM	SSID when rejoining nets  *	MBUF		MBUFs dumped  *	RX		packet types reported  *	CM		common memory re-mapping  *	COM		new command sleep/wakeup  */
end_comment

begin_define
define|#
directive|define
name|RAY_DBG_RECERR
value|0x0001
end_define

begin_define
define|#
directive|define
name|RAY_DBG_SUBR
value|0x0002
end_define

begin_define
define|#
directive|define
name|RAY_DBG_BOOTPARAM
value|0x0004
end_define

begin_define
define|#
directive|define
name|RAY_DBG_STARTJOIN
value|0x0008
end_define

begin_define
define|#
directive|define
name|RAY_DBG_CCS
value|0x0010
end_define

begin_define
define|#
directive|define
name|RAY_DBG_IOCTL
value|0x0020
end_define

begin_define
define|#
directive|define
name|RAY_DBG_NETPARAM
value|0x0040
end_define

begin_define
define|#
directive|define
name|RAY_DBG_MBUF
value|0x0080
end_define

begin_define
define|#
directive|define
name|RAY_DBG_RX
value|0x0100
end_define

begin_define
define|#
directive|define
name|RAY_DBG_CM
value|0x0200
end_define

begin_define
define|#
directive|define
name|RAY_DBG_COM
value|0x0400
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|(				\  			   RAY_DBG_RECERR	|   	\  			   RAY_DBG_SUBR		|    	\ 			   RAY_DBG_BOOTPARAM	|	\ 			   RAY_DBG_STARTJOIN	|	\ 			   RAY_DBG_CCS		|   	\                            RAY_DBG_IOCTL	|   	\
comment|/* RAY_DBG_NETPARAM	| */
value|\
comment|/* RAY_DBG_MBUF		| */
value|\
comment|/* RAY_DBG_RX		| */
value|\
comment|/* RAY_DBG_CM		| */
value|\                            RAY_DBG_COM		|   	\ 			0				\ 			)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAY_CCS_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for CCS commands */
end_comment

begin_define
define|#
directive|define
name|RAY_CHECK_SCHED_TIMEOUT
value|(hz)
end_define

begin_comment
comment|/* Time to wait until command retry, should be> RAY_CCS_TIMEOUT */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_CM_FIXUP
value|1
end_define

begin_comment
comment|/* Needed until pccardd hacks for ed drivers are removed (pccardd forces 16bit memory and 0x4000 size) THIS IS A DANGEROUS THING TO USE IF YOU USE OTHER MEMORY MAPPED PCCARDS */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_CM_REMAPPING
value|1
end_define

begin_comment
comment|/* Needed until pccard maps more than one memory area */
end_comment

begin_define
define|#
directive|define
name|RAY_RESET_TIMEOUT
value|(5*hz)
end_define

begin_comment
comment|/* Timeout for resetting the card */
end_comment

begin_define
define|#
directive|define
name|RAY_USE_CALLOUT_STOP
value|0
end_define

begin_comment
comment|/* Set for kernels with callout_stop function - 3.3 and above */
end_comment

begin_define
define|#
directive|define
name|RAY_SIMPLE_TX
value|1
end_define

begin_comment
comment|/* Simple TX routine */
end_comment

begin_define
define|#
directive|define
name|RAY_DECENT_TX
value|0
end_define

begin_comment
comment|/* Decent TX routine - tbd */
end_comment

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_comment
comment|/*  * Debugging odds and odds  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|0x0000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
end_if

begin_comment
comment|/* XXX This macro assumes that common memory is mapped into kernel space and  * XXX does not indirect through SRAM macros - it should  */
end_comment

begin_define
define|#
directive|define
name|RAY_DHEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|,
name|mask
parameter_list|)
value|do { if (RAY_DEBUG& mask) {	\     u_int8_t *i;						\     for (i = p; i< (u_int8_t *)(p+l); i += 8)			\     	printf("  0x%08lx %8D\n",				\ 		(unsigned long)i, (unsigned char *)i, " ");	\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTFN
parameter_list|(
name|mask
parameter_list|,
name|x
parameter_list|)
value|do { if (RAY_DEBUG& mask) {	\     printf x ;							\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|mask
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {if (RAY_DEBUG& mask) {	\     printf("ray%d: %s(%d) " fmt "\n",					\     	sc->unit, __FUNCTION__ , __LINE__ , ##args);			\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DNET_DUMP
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
value|do { if (RAY_DEBUG& RAY_DBG_NETPARAM) {	\     printf("ray%d: Current network parameters%s\n", (sc)->unit, (s));	\     printf("  bss_id %6D\n", (sc)->sc_c.np_bss_id, ":");		\     printf("  inited 0x%02x\n", (sc)->sc_c.np_inited);			\     printf("  def_txrate 0x%02x\n", (sc)->sc_c.np_def_txrate);		\     printf("  encrypt 0x%02x\n", (sc)->sc_c.np_encrypt);		\     printf("  net_type 0x%02x\n", (sc)->sc_c.np_net_type);		\     printf("  ssid \"%.32s\"\n", (sc)->sc_c.np_ssid);			\     printf("       %8D\n", (sc)->sc_c.np_ssid, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+8, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+16, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+24, " ");			\     printf("  priv_start 0x%02x\n", (sc)->sc_c.np_priv_start);		\     printf("  priv_join 0x%02x\n", (sc)->sc_c.np_priv_join);		\     printf("ray%d: Desired network parameters%s\n", (sc)->unit, (s));	\     printf("  bss_id %6D\n", (sc)->sc_d.np_bss_id, ":");		\     printf("  inited 0x%02x\n", (sc)->sc_d.np_inited);			\     printf("  def_txrate 0x%02x\n", (sc)->sc_d.np_def_txrate);		\     printf("  encrypt 0x%02x\n", (sc)->sc_d.np_encrypt);		\     printf("  net_type 0x%02x\n", (sc)->sc_d.np_net_type);		\     printf("  ssid \"%.32s\"\n", (sc)->sc_d.np_ssid);			\     printf("       %8D\n", (sc)->sc_c.np_ssid, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+8, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+16, " ");			\     printf("       %8D\n", (sc)->sc_c.np_ssid+24, " ");			\     printf("  priv_start 0x%02x\n", (sc)->sc_d.np_priv_start);		\     printf("  priv_join 0x%02x\n", (sc)->sc_d.np_priv_join);		\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DCOM_DUMP
parameter_list|(
name|sc
parameter_list|,
name|com
parameter_list|,
name|s
parameter_list|)
value|do { if (RAY_DEBUG& RAY_DBG_COM) {	\     printf("ray%d: %s(%d) %s com entry 0x%p\n",				\         (sc)->unit, __FUNCTION__ , __LINE__ , (s) , (com));		\     printf("  c_mesg %s\n", (com)->c_mesg);				\     printf("  c_flags 0x%b\n", (com)->c_flags, RAY_COM_FLAGS_PRINTFB);	\     printf("  c_retval 0x%x\n", (com)->c_retval);			\     printf("  c_ccs 0x%0x index 0x%02x\n",				\         com->c_ccs, RAY_CCS_INDEX((com)->c_ccs));			\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DCOM_CHECK
parameter_list|(
name|sc
parameter_list|,
name|com
parameter_list|)
value|do { if (RAY_DEBUG& RAY_DBG_COM) {	\     ray_com_ecf_check((sc), (com), __FUNCTION__ );			\ } } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_DHEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|,
name|mask
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTFN
parameter_list|(
name|mask
parameter_list|,
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|mask
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DNET_DUMP
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DCOM_DUMP
parameter_list|(
name|sc
parameter_list|,
name|com
parameter_list|,
name|s
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DCOM_CHECK
parameter_list|(
name|sc
parameter_list|,
name|com
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 0 */
end_comment

begin_define
define|#
directive|define
name|RAY_PANIC
parameter_list|(
name|sc
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {			\     panic("ray%d: %s(%d) " fmt "\n",				\     	sc->unit, __FUNCTION__ , __LINE__ , ##args);		\ } while (0)
end_define

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_MBUF
end_if

begin_define
define|#
directive|define
name|RAY_DMBUF_DUMP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
value|ray_dump_mbuf((sc), (m), (s))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_DMBUF_DUMP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_MBUF */
end_comment

begin_include
include|#
directive|include
file|"ray.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NRAY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_ieee80211.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_rayreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_raymib.h>
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cis.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD */
end_comment

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM */
end_comment

begin_comment
comment|/*  * Sysctl knobs  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_debug
init|=
name|RAY_DEBUG
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ray
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Raylink Driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ray
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ray_debug
argument_list|,
name|RAY_DEBUG
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Network parameters, used twice in sotfc to store what we want and what  * we have.  *  * XXX promisc in here too?  * XXX sc_station_addr in here too (for changing mac address)  */
end_comment

begin_struct
struct|struct
name|ray_nw_param
block|{
name|struct
name|ray_cmd_net
name|p_1
decl_stmt|;
name|u_int8_t
name|np_ap_status
decl_stmt|;
name|struct
name|ray_net_params
decl|\
name|p_2
decl_stmt|;
name|u_int8_t
name|np_countrycode
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|np_upd_param
value|p_1.c_upd_param
end_define

begin_define
define|#
directive|define
name|np_bss_id
value|p_1.c_bss_id
end_define

begin_define
define|#
directive|define
name|np_inited
value|p_1.c_inited
end_define

begin_define
define|#
directive|define
name|np_def_txrate
value|p_1.c_def_txrate
end_define

begin_define
define|#
directive|define
name|np_encrypt
value|p_1.c_encrypt
end_define

begin_define
define|#
directive|define
name|np_net_type
value|p_2.p_net_type
end_define

begin_define
define|#
directive|define
name|np_ssid
value|p_2.p_ssid
end_define

begin_define
define|#
directive|define
name|np_priv_start
value|p_2.p_privacy_must_start
end_define

begin_define
define|#
directive|define
name|np_priv_join
value|p_2.p_privacy_can_join
end_define

begin_comment
comment|/*  * One of these structures per allocated device  */
end_comment

begin_struct
struct|struct
name|ray_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common 		*/
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
comment|/* Ifnet common 		*/
name|struct
name|callout_handle
name|reset_timerh
decl_stmt|;
comment|/* Handle for reset timer	*/
name|struct
name|callout_handle
name|start_timerh
decl_stmt|;
comment|/* Handle for start timer	*/
name|struct
name|callout_handle
name|com_timerh
decl_stmt|;
comment|/* Handle for command timer	*/
name|char
modifier|*
name|card_type
decl_stmt|;
comment|/* Card model name		*/
name|char
modifier|*
name|vendor
decl_stmt|;
comment|/* Card manufacturer		*/
name|int
name|unit
decl_stmt|;
comment|/* Unit number			*/
name|u_char
name|gone
decl_stmt|;
comment|/* 1 = Card bailed out		*/
name|caddr_t
name|maddr
decl_stmt|;
comment|/* Shared RAM Address		*/
name|int
name|flags
decl_stmt|;
comment|/* Start up flags		*/
name|int
name|translation
decl_stmt|;
comment|/* Packet translation types	*/
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
name|int
name|slotnum
decl_stmt|;
comment|/* Slot number			*/
name|struct
name|mem_desc
name|md
decl_stmt|;
comment|/* Map info for common memory	*/
endif|#
directive|endif
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
name|struct
name|ray_ecf_startup_v5
name|sc_ecf_startup
decl_stmt|;
comment|/* Startup info from card	*/
name|TAILQ_HEAD
argument_list|(
argument|ray_comq
argument_list|,
argument|ray_comq_entry
argument_list|)
name|sc_comq
expr_stmt|;
comment|/* Command queue		*/
name|struct
name|ray_nw_param
name|sc_c
decl_stmt|;
comment|/* current network params 	*/
name|struct
name|ray_nw_param
name|sc_d
decl_stmt|;
comment|/* desired network params	*/
name|int
name|sc_havenet
decl_stmt|;
comment|/* true if we have a network	*/
name|int
name|sc_promisc
decl_stmt|;
comment|/* current set value		*/
name|u_int8_t
name|sc_ccsinuse
index|[
literal|64
index|]
decl_stmt|;
comment|/* ccss' in use -- not for tx	*/
name|int
name|sc_checkcounters
decl_stmt|;
name|u_int64_t
name|sc_rxoverflow
decl_stmt|;
comment|/* Number of rx overflows	*/
name|u_int64_t
name|sc_rxcksum
decl_stmt|;
comment|/* Number of checksum errors	*/
name|u_int64_t
name|sc_rxhcksum
decl_stmt|;
comment|/* Number of header checksum errors */
name|u_int8_t
name|sc_rxnoise
decl_stmt|;
comment|/* Average receiver level	*/
name|struct
name|ray_siglev
name|sc_siglevs
index|[
name|RAY_NSIGLEVRECS
index|]
decl_stmt|;
comment|/* Antenna/levels	*/
name|struct
name|ray_param_req
type|\
modifier|*
name|sc_repreq
decl_stmt|;
comment|/* used to return values	*/
name|struct
name|ray_param_req
type|\
modifier|*
name|sc_updreq
decl_stmt|;
comment|/* to the user			*/
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ray_softc
name|ray_softc
index|[
name|NRAY
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sc_station_addr
value|sc_ecf_startup.e_station_addr
end_define

begin_define
define|#
directive|define
name|sc_version
value|sc_ecf_startup.e_fw_build_string
end_define

begin_define
define|#
directive|define
name|sc_tibsize
value|sc_ecf_startup.e_tibsize
end_define

begin_comment
comment|/*  * Command queue definitions  */
end_comment

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_RAYCOM
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_RAYCOM
argument_list|,
literal|"raycom"
argument_list|,
literal|"Raylink command queue entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ray_comq_entry
block|{
name|TAILQ_ENTRY
argument_list|(
argument|ray_comq_entry
argument_list|)
name|c_chain
expr_stmt|;
comment|/* Tail queue.		*/
name|void
argument_list|(
argument|*c_function
argument_list|)
comment|/* Function to call */
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_comq_entry
operator|*
name|com
operator|)
argument_list|)
expr_stmt|;
name|int
name|c_flags
decl_stmt|;
comment|/* Flags		*/
name|u_int8_t
name|c_retval
decl_stmt|;
comment|/* Return value		*/
name|void
modifier|*
name|c_wakeup
decl_stmt|;
comment|/* Sleeping on this	*/
name|size_t
name|c_ccs
decl_stmt|;
comment|/* Control structure	*/
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
name|char
modifier|*
name|c_mesg
decl_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RAY_COM_FWOK
value|0x0001
end_define

begin_comment
comment|/* Wakeup on completion	*/
end_comment

begin_define
define|#
directive|define
name|RAY_COM_FRUNNING
value|0x0002
end_define

begin_comment
comment|/* This one running	*/
end_comment

begin_define
define|#
directive|define
name|RAY_COM_FCOMPLETED
value|0x0004
end_define

begin_comment
comment|/* This one completed	*/
end_comment

begin_define
define|#
directive|define
name|RAY_COM_FLAGS_PRINTFB
define|\
value|"\020"			\ 	"\001WOK"		\ 	"\002RUNNING"		\ 	"\003COMPLETED"
end_define

begin_define
define|#
directive|define
name|RAY_COM_NEEDS_TIMO
parameter_list|(
name|cmd
parameter_list|)
define|\
value|(cmd == RAY_CMD_DOWNLOAD_PARAMS) ||	\ 	(cmd == RAY_CMD_UPDATE_PARAMS) ||	\ 	(cmd == RAY_CMD_UPDATE_MCAST)
end_define

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
end_if

begin_define
define|#
directive|define
name|RAY_COM_FUNCTION
parameter_list|(
name|comp
parameter_list|,
name|function
parameter_list|)
define|\
value|(comp)->c_function = (function);	\ 	(comp)->c_mesg = __STRING(function);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_COM_FUNCTION
parameter_list|(
name|comp
parameter_list|,
name|function
parameter_list|)
define|\
value|comp->c_function = function;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_COM */
end_comment

begin_comment
comment|/*  * Translation types  */
end_comment

begin_comment
comment|/* XXX maybe better as part of the if structure? */
end_comment

begin_define
define|#
directive|define
name|SC_TRANSLATE_WEBGEAR
value|0
end_define

begin_comment
comment|/*  * Prototyping  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ccs_alloc
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
operator|*
name|ccsp
operator|,
name|u_int
name|cmd
operator|,
name|int
name|timo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_ccs_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_ccs_free
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|XXX_NETBSDTX
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_ccs_free_chain
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|u_int
name|ni
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX_NETBSDTX */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ray_com_ecf
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_comq_entry
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_com_ecf_check
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|char
operator|*
name|mesg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_COM */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ray_com_ecf_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_com_ecf_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_com_runq
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_com_runq_add
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_comq_entry
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_com_runq_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_comq_entry
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_MBUF
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_dump_mbuf
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|mbuf
operator|*
name|m
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_MBUF */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ray_init
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_intr_updt_errcntrs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_init
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_pccard_unload
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rcs_intr
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_report_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_reset
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_reset_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rx
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|rcs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rx_update_cache
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|u_int8_t
operator|*
name|src
operator|,
name|u_int8_t
name|siglev
operator|,
name|u_int8_t
name|antenna
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_sj
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_comq_entry
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_sj_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|XXX_ASSOCWORKING_AGAIN
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_start_assoc
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_assoc_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int8_t
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|XXX_ASSOCWORKING_AGAIN
end_endif

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_start_best_antenna
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|u_int8_t
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int8_t
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ray_start_wrhdr
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ether_header
operator|*
name|eh
operator|,
name|size_t
name|bufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_stop
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_mcast
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_comq_entry
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_mcast_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_mcast_user
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_update_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_update_params_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int
name|stat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_promisc
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_comq_entry
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_promisc_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_promisc_user
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_user_update_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_param_req
operator|*
name|pr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_user_report_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_param_req
operator|*
name|pr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_user_report_stats
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ray_stats_req
operator|*
name|sr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PCMCIA driver definition  */
end_comment

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|ray
argument_list|,
name|ray_pccard_init
argument_list|,
name|ray_pccard_unload
argument_list|,
name|ray_pccard_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ISA driver definition  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|raydriver
init|=
block|{
name|ray_probe
block|,
name|ray_attach
block|,
literal|"ray"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Indirections for reading/writing shared memory - from NetBSD/if_ray.c  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((size_t)(&((type *)0)->member))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* offsetof */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|(u_int8_t)*((sc)->maddr + (off))
end_define

begin_comment
comment|/* ((u_int8_t)bus_space_read_1((sc)->sc_memt, (sc)->sc_memh, (off))) */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|SRAM_READ_1(sc, (off) + offsetof(struct s, f))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|((((u_int16_t)SRAM_READ_1(sc, (off) + offsetof(struct s, f))<< 8) \     |(SRAM_READ_1(sc, (off) + 1 + offsetof(struct s, f)))))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_read_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_read_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((sc)->maddr + (off), (vp), (n))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|*((sc)->maddr + (off)) = (val)
end_define

begin_comment
comment|/* bus_space_write_1((sc)->sc_memt, (sc)->sc_memh, (off), (val)) */
end_comment

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
define|\
value|SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (v))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
value|do {	\     SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (((v)>> 8 )& 0xff)); \     SRAM_WRITE_1(sc, (off) + 1 + offsetof(struct s, f), ((v)& 0xff)); \ } while (0)
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_write_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_write_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((vp), (sc)->maddr + (off), (n))
end_define

begin_comment
comment|/*  * Macro's and constants  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_CHECK_SCHED_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_CHECK_SCHED_TIMEOUT
value|(hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_COM_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_COM_TIMEOUT
value|(hz / 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_RESET_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_RESET_TIMEOUT
value|(10 * hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_START_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_START_TIMEOUT
value|(hz / 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAY_CCS_FREE
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
define|\
value|SRAM_WRITE_FIELD_1((sc), (ccs), ray_cmd, c_status, RAY_CCS_STATUS_FREE)
end_define

begin_define
define|#
directive|define
name|RAY_ECF_READY
parameter_list|(
name|sc
parameter_list|)
value|(!(ray_read_reg(sc, RAY_ECFIR)& RAY_ECFIR_IRQ))
end_define

begin_define
define|#
directive|define
name|RAY_ECF_START_CMD
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_ECFIR, RAY_ECFIR_IRQ)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_CLEAR_INTR
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_HCSIR, 0)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_INTR
parameter_list|(
name|sc
parameter_list|)
value|(ray_read_reg(sc, RAY_HCSIR)& RAY_HCSIR_IRQ)
end_define

begin_comment
comment|/*  * As described in if_xe.c...  *  * Horrid stuff for accessing CIS tuples and remapping common memory...  */
end_comment

begin_define
define|#
directive|define
name|CARD_MAJOR
value|50
end_define

begin_decl_stmt
specifier|static
name|int
name|ray_attr_write
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
name|byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attr_read
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
operator|*
name|buf
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_read_reg
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_attr_getmap
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_attr_cm
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_cm(sc)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
end_comment

begin_comment
comment|/*  * PCCard initialise.  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_init
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|doRemap
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: PCCard probe\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NRAY
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
name|sc
operator|->
name|slotnum
operator|=
name|dev_p
operator|->
name|slt
operator|->
name|slotnum
expr_stmt|;
name|ray_attr_getmap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RECERR
argument_list|,
operator|(
literal|"ray%d: Memory window flags 0x%02x, start %p, size 0x%x, card address 0x%lx\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|sc
operator|->
name|md
operator|.
name|flags
operator|,
name|sc
operator|->
name|md
operator|.
name|start
operator|,
name|sc
operator|->
name|md
operator|.
name|size
operator|,
name|sc
operator|->
name|md
operator|.
name|card
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
if|#
directive|if
name|RAY_NEED_CM_FIXUP
name|doRemap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|start
operator|==
literal|0x0
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: pccardd did not map CM - giving up\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|flags
operator|!=
name|MDF_ACTIVE
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM flags from 0x%x to 0x40\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|flags
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|flags
operator|=
name|MDF_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|size
operator|!=
literal|0xc000
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM size from 0x%x to 0xc000\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|size
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|size
operator|=
literal|0xc000
expr_stmt|;
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
operator|=
name|sc
operator|->
name|md
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|card
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM card address from 0x%lx to 0x0\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|card
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|card
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doRemap
condition|)
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_FIXUP */
name|sc
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|maddr
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_flags
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d:<Raylink/IEEE 802.11> maddr %p msize 0x%x irq %d flags 0x%x on isa (PC-Card slot %d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|maddr
argument_list|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
argument_list|,
name|ffs
argument_list|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|sc
operator|->
name|flags
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ray_attach
argument_list|(
operator|&
name|dev_p
operator|->
name|isahd
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCCard unload.  */
end_comment

begin_function
specifier|static
name|void
name|ray_pccard_unload
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_pccard_unload\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_pccard_unload unloaded!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Clear out timers and sort out driver state      *      * We use callout_stop to unconditionally kill the ccs and general      * timers as they are used with multiple arguments.      */
if|#
directive|if
name|RAY_USE_CALLOUT_STOP
name|callout_stop
argument_list|(
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_USE_CALLOUT_STOP */
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/*      * Mark as not running      */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/*      * Cleardown interface      */
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX should be if_detach for -current */
comment|/*      * Mark card as gone      */
name|sc
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: ray_pccard_unload unloading complete\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * process an interrupt  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_intr
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
return|return
operator|(
name|ray_intr
argument_list|(
name|dev_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ISA probe routine.  */
end_comment

begin_function
specifier|static
name|int
name|ray_probe
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ISA probe\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ISA/PCCard attach.  */
end_comment

begin_function
specifier|static
name|int
name|ray_attach
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ISA/PCCard attach\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|id_unit
index|]
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_attach unloaded!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*      * Read startup results, check the card is okay and work out what      * version we are using.      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
name|RAY_ECFS_PRINTFB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unsupported firmware version 0x%0x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
operator|||
operator|(
name|RAY_DEBUG
operator|&
name|RAY_DBG_BOOTPARAM
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Start Up Results\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|printf
argument_list|(
literal|"  Firmware version 4\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  Firmware version 5\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Status 0x%b\n"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
name|RAY_ECFS_PRINTFB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Ether address %6D\n"
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_rates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Supported rates %8D\n"
argument_list|,
name|ep
operator|->
name|e_rates
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  Japan call sign %12D\n"
argument_list|,
name|ep
operator|->
name|e_japan_callsign
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_prg_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_cis_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware version %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware revision %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_resv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ASIC version %0x\n"
argument_list|,
name|ep
operator|->
name|e_asic_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  TIB size %0x\n"
argument_list|,
name|ep
operator|->
name|e_tibsize
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|XXX_CLEARCCS_IN_INIT
operator|>
literal|0
else|#
directive|else
comment|/* Set all ccs to be free */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|)
argument_list|)
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_CCS_LAST
condition|;
name|ccs
operator|+=
name|RAY_CCS_SIZE
operator|,
name|i
operator|++
control|)
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_CLEARCCS_IN_INIT */
comment|/* Reset any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Set the parameters that will survive stop/init      *      * Do not update these in ray_init's parameter setup      */
if|#
directive|if
name|XXX
name|see
name|the
name|ray_init
name|section
for|for stuff to move
endif|#
directive|endif
for|bzero
control|(
operator|&
name|sc
operator|->
name|sc_d
operator|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
control|)
empty_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_c
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Initialise the network interface structure      */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|e_station_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ray"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000
expr_stmt|;
comment|/* Is this baud or bps ;-) */
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ray_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ray_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ray_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ray_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
comment|/*      * If this logical interface has already been attached,      * don't attach it again or chaos will ensue.      */
name|sprintf
argument_list|(
name|ifname
argument_list|,
literal|"ray%d"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifunit
argument_list|(
name|ifname
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBFFILTER */
if|#
directive|if
name|XXX
name|this
name|looks
name|like
name|a
name|good
name|idea
name|at_shutdown
argument_list|(
name|ray_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* XXX */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * User land entry to network initialisation.  *  *XXX change all this - it's wrong  *  * Start up flow is as follows.  * The kernel calls ray_init when the interface is assigned an address.  *   * ray_init does a bit of house keeping before calling ray_download.  *  * ray_download_params fills the startup parameter structure out and  * sends it to the card. The download command simply completes, so we  * use the timeout code in ray_check_ccs instead of spin locking. The  * passes flow to the standard ccs handler and we eventually end up in  * ray_download_done.  *  * ray_download_done tells the card to start an adhoc network or join  * a managed network. This should complete via the interrupt  * mechanism, but the NetBSD driver includes a timeout for some buggy  * stuff somewhere - I've left the hooks in but don't use them. The  * interrupt handler passes control to ray_sj_done - the ccs  * is handled by the interrupt mechanism.  *  * Once ray_sj_done has checked the ccs and uploaded/updated  * the network parameters we are ready to process packets. It is then  * safe to call ray_start which is done by the interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ray_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_init unloaded!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Reset instance variables      *      * The first set are network parameters that are read back when      * the card starts or joins the network.      *      * The second set are network parameters that are downloaded to      * the card.      *      * The third set are driver parameters.      *      * All of the variables in these sets can be updated by the card or ioctls.      */
if|#
directive|if
name|XXX
name|see
name|the
name|ray_attach
name|section
for|for stuff to move
endif|#
directive|endif
for|sc->sc_d.np_upd_param = 0
empty_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_bss_id
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_inited
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
operator|=
name|RAY_MIB_BASIC_RATE_SET_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|=
name|RAY_MIB_NET_TYPE_DEFAULT
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|RAY_MIB_SSID_DEFAULT
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
operator|=
name|RAY_MIB_PRIVACY_CAN_JOIN_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_promisc
operator|=
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|translation
operator|=
name|SC_TRANSLATE_WEBGEAR
expr_stmt|;
if|#
directive|if
name|XXX_CLEARCCS_IN_INIT
operator|>
literal|0
comment|/* Set all ccs to be free */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|)
argument_list|)
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_CCS_LAST
condition|;
name|ccs
operator|+=
name|RAY_CCS_SIZE
operator|,
name|i
operator|++
control|)
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_CLEARCCS_IN_INIT */
if|#
directive|if
name|XXX
name|Not
name|sure
name|why
name|I
name|really
name|need
name|this
operator|-
name|maybe
name|best
name|to
name|deal
name|with
name|this
name|when
name|resets
name|are
name|requested
name|by
name|me
condition|?
endif|#
directive|endif
comment|/* XXX */
comment|/*      * Get startup results - the card may have been reset      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
name|RAY_ECFS_PRINTFB
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX This doesn't mark the interface as down */
block|}
comment|/*      * Fixup tib size to be correct - on build 4 it is garbage      */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_tibsize
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_tibsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_tib
argument_list|)
expr_stmt|;
comment|/*      * We are now up and running. We are busy until network is joined.      */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
expr_stmt|;
comment|/*      * Create the following runq entries:      *      *		download	- download the network definition to the card      *		sj		- find or start a BSS      *		mcast		- download multicast list      *		promisc		- last in case mcast called it anyway      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|MALLOC
argument_list|(
name|com
index|[
name|i
index|]
argument_list|,
expr|struct
name|ray_comq_entry
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_comq_entry
argument_list|)
argument_list|,
name|M_RAYCOM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|RAY_COM_FUNCTION
argument_list|(
name|com
index|[
literal|0
index|]
argument_list|,
name|ray_download
argument_list|)
expr_stmt|;
name|RAY_COM_FUNCTION
argument_list|(
name|com
index|[
literal|1
index|]
argument_list|,
name|ray_sj
argument_list|)
expr_stmt|;
name|RAY_COM_FUNCTION
argument_list|(
name|com
index|[
literal|2
index|]
argument_list|,
name|ray_mcast
argument_list|)
expr_stmt|;
name|RAY_COM_FUNCTION
argument_list|(
name|com
index|[
literal|3
index|]
argument_list|,
name|ray_promisc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|com
index|[
name|i
index|]
operator|->
name|c_flags
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|i
index|]
operator|->
name|c_retval
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|i
index|]
operator|->
name|c_ccs
operator|=
name|NULL
expr_stmt|;
name|com
index|[
name|i
index|]
operator|->
name|c_wakeup
operator|=
name|com
index|[
literal|3
index|]
expr_stmt|;
if|#
directive|if
name|XXX
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX remove */
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* XXX remove */
name|com
index|[
literal|1
index|]
operator|->
name|c_flags
operator|=
name|RAY_COM_FWOK
expr_stmt|;
comment|/* XXX should be com[3] */
name|ray_com_runq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"sleeping"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
name|com
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
literal|"rayinit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"awakened"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|FREE
argument_list|(
name|com
index|[
name|i
index|]
argument_list|,
name|M_RAYCOM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Network stop.  *  * Assumes that a ray_init is used to restart the card.  *  */
end_comment

begin_function
specifier|static
name|void
name|ray_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|scheduled
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_stop\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_stop unloaded!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/*      * Clear out timers and sort out driver state      */
comment|/*XXX splimp with care needed */
name|printf
argument_list|(
literal|"ray%d: ray_stop hcs_intr %d rcsi 0x%0x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|RAY_HCS_INTR
argument_list|(
name|sc
argument_list|)
argument_list|,
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_RCSI
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: ray_stop ready %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_repreq
condition|)
block|{
name|sc
operator|->
name|sc_repreq
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_EDEVSTOP
expr_stmt|;
name|wakeup
argument_list|(
name|ray_report_params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_updreq
condition|)
block|{
name|sc
operator|->
name|sc_repreq
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_EDEVSTOP
expr_stmt|;
name|wakeup
argument_list|(
name|ray_update_params
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|RAY_USE_CALLOUT_STOP
name|callout_stop
argument_list|(
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_USE_CALLOUT_STOP */
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxoverflow
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxcksum
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxhcksum
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxnoise
operator|=
literal|0
expr_stmt|;
comment|/*      * Inhibit card - if we can't prevent reception then do not worry;      * stopping a NIC only guarantees no TX.      */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* XXX what does the SHUTDOWN command do? Or power saving in COR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*      * Mark as not running      */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Reset the card  *  * I'm using the soft reset command in the COR register. I'm not sure  * if the sequence is right but it does seem to do the right thing. A  * nano second after reset is written the flashing light goes out, and  * a few seconds after the default is written the main card light goes  * out. We wait a while and then re-init the card.  */
end_comment

begin_function
specifier|static
name|void
name|ray_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_reset\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: ray_reset skip reset card\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|printf
argument_list|(
literal|"ray%d: *** ray_reset skip stop card\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX ray_stop(sc); not always in a sleepable context? */
name|printf
argument_list|(
literal|"ray%d: resetting card\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_attr_write
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|RAY_COR
argument_list|,
name|RAY_COR_RESET
argument_list|)
expr_stmt|;
name|ray_attr_write
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|RAY_COR
argument_list|,
name|RAY_COR_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reset_timerh
operator|=
name|timeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|RAY_RESET_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Finishing resetting and restarting the card  */
end_comment

begin_function
specifier|static
name|void
name|ray_reset_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_reset_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RECERR
argument_list|,
operator|(
literal|"ray%d: ray_reset_timo still busy, re-schedule\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reset_timerh
operator|=
name|timeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|RAY_RESET_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_watchdog\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_watchdog unloaded!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ray%d: watchdog timeout\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX may need to have remedial action here    for example    	ray_reset 	    ray_stop 	    ... 	    ray_init      do we only use on TX?     	if so then we should clear OACTIVE etc.  */
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * XXX NOT KNF FROM HERE UP  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Network ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ray_param_req
name|pr
decl_stmt|;
name|struct
name|ray_stats_req
name|sr
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|error2
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_IOCTL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_ioctl unloaded!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error2
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SIFADDR/GIFADDR/SIFMTU"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SIFFLAGS"
argument_list|)
expr_stmt|;
comment|/* 		 * If the interface is marked up and stopped, then start 		 * it. If it is marked down and running, then stop it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|ray_promisc_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"ADDMULTI/DELMULTI"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_mcast_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSRAYPARAM
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SRAYPARAM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ray_user_update_params
argument_list|(
name|sc
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|pr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYPARAM
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYPARAM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ray_user_report_params
argument_list|(
name|sc
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|pr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYSTATS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYSTATS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_user_report_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|sr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYSIGLEV
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYSIGLEV"
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|sc_siglevs
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_siglevs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFFLAGS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMETRIC
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMETRIC"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMTU"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFPHYS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFPYHS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SIFMEDIA"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMEDIA"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit packet handling  */
end_comment

begin_comment
comment|/*  * Network start.  *  * Start sending a packet.  *  * We make two assumptions here:  *  1) That the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) That the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|ray_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pktlen
decl_stmt|,
name|len
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Some simple checks first 	 */
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_start unloaded!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|!
name|sc
operator|->
name|sc_havenet
condition|)
return|return;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"busy, schedule a timeout"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|start_timerh
operator|=
name|timeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|RAY_START_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
comment|/* 	 * Simple one packet at a time TX routine - probably appaling performance 	 * and we certainly chew CPU. However bing to windows boxes shows 	 * a reliance on the far end too: 	 * 	 * 1500k default rate 	 * 	 * Libretto 50CT (75MHz Pentium) with FreeBSD-3.1 to 	 *   Nonname box Windows 95C (133MHz AMD 5x86) 		 996109bps 	 *   AST J30 Windows 95A (100MHz Pentium) 		1307791bps 	 * 	 * 2000k default rate 	 * 	 * Libretto 50CT (75MHz Pentium) with FreeBSD-3.1 to 	 *   Nonname box Windows 95C (133MHz AMD 5x86) 		1087049bps 	 *   AST J30 Windows 95A (100MHz Pentium) 		1307791bps 	 * 	 * Flow is 	 *		get a ccs 	 *		build the packet 	 *		set IFF_OACTIVE 	 *		interrupt the card to send the packet 	 *		exit 	 * 	 *		wait for interrupt telling us the packet has been sent 	 *		clear IFF_OACTIVE 	 *		get called by the interrupt routine if any packets left 	 */
comment|/* 	 * Find a free ccs; if none available wave good bye and exit. 	 * 	 * We find a ccs before we process the mbuf so that we are sure it 	 * is worthwhile processing the packet. All errors in the mbuf 	 * processing are either errors in the mbuf or gross configuration 	 * errors and the packet wouldn't get through anyway. 	 * 	 * Don't forget to clear the ccs on errors. 	 */
name|i
operator|=
name|RAY_CCS_TX_FIRST
expr_stmt|;
do|do
block|{
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RAY_CCS_STATUS_FREE
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<=
name|RAY_CCS_TX_LAST
condition|)
do|;
if|if
condition|(
name|i
operator|>
name|RAY_CCS_TX_LAST
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"using ccs 0x%02x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve and fill the ccs - must do the length later. 	 * 	 * Even though build 4 and build 5 have different fields all these 	 * are common apart from tx_rate. Neither the NetBSD driver or Linux 	 * driver bother to overwrite this for build 4 cards. 	 * 	 * The start of the buffer must be aligned to a 256 byte boundary 	 * (least significant byte of address = 0x00). 	 */
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|RAY_TX_BASE
operator|+
name|i
operator|*
name|RAY_TX_BUF_SIZE
expr_stmt|;
name|bufp
operator|+=
name|sc
operator|->
name|sc_tibsize
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_cmd
argument_list|,
name|RAY_CMD_TX_REQ
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_bufp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_tx_rate
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_apm_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|bufp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_phy_header
argument_list|)
expr_stmt|;
comment|/* 	 * Get the mbuf and process it - we have to remember to free the 	 * ccs if there are any errors 	 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|pktlen
operator|=
literal|0
operator|,
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"mbuf too long %d"
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX 	 * I would much prefer to have the complete 802.11 packet dropped to 	 * the bpf tap and then have a user land program parse the headers 	 * as needed. This way, tcpdump -w can be used to grab the raw data. If 	 * needed the 802.11 aware program can "translate" the .11 to ethernet 	 * for tcpdump -r. 	 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBPFILTER */
comment|/* 	 * Translation - capability as described earlier 	 * 	 * Each case must write the 802.11 header using ray_start_wrhdr, 	 * passing a pointer to the ethernet header in and getting a new 	 * tc buffer pointer. Next remove/modify/addto the 802.3 and 802.2 	 * headers as needed. 	 * 	 * We've pulled up the mbuf for you. 	 * 	 */
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"could not pullup ether"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|sc
operator|->
name|translation
condition|)
block|{
case|case
name|SC_TRANSLATE_WEBGEAR
case|:
name|bufp
operator|=
name|ray_start_wrhdr
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_start unknown translation type 0x%x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|translation
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"could not translate mbuf"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|pktlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the mbuf to the buffer in common memory 	 * 	 * We panic and don't bother wrapping as ethernet packets are 1518 	 * bytes, we checked the mbuf earlier, and our TX buffers are 2048 	 * bytes. We don't have 530 bytes of headers etc. so something 	 * must be fubar. 	 */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bufp
operator|+
name|len
operator|)
operator|<
name|RAY_TX_END
condition|)
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"tx buffer overflow"
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
name|RAY_DMBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
literal|"ray_start"
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in a few loose ends and kick the card to send the packet 	 */
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * From NetBSD code: 		 * 		 * If this can really happen perhaps we need to save 		 * the chain and use it later.  I think this might 		 * be a confused state though because we check above 		 * and don't issue any commands between. 		 */
name|printf
argument_list|(
literal|"ray%d: ray_tx device busy\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_len
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_antenna
argument_list|,
name|ray_start_best_antenna
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|XXX_NETBSDTX
end_if

begin_decl_stmt
name|netbsd
name|driver
name|uses
name|a
name|loop
name|repeat
name|get
name|a
name|ccs
name|get
name|a
name|mbuf
name|translate
name|and
name|send
name|packet
name|to
name|shared
name|ram
name|until
argument_list|(
name|no
name|more
name|ccs
literal|'s) || (no more mbuf'
name|s
argument_list|)
name|send
name|ccs
name|chain
name|to
name|card
name|exit
name|Linux
name|driver
name|is
name|simple
name|single
name|shot
name|packet
argument_list|(
name|with
name|a
name|lot
name|of
name|spinlocks
operator|!
argument_list|)
name|general
name|the
name|tx
name|space
name|is
decl|0x7000
init|=
literal|28kB
decl_stmt|,
name|and
name|TX
name|buffer
name|size
name|is
decl|2048
name|so
name|there
name|can
name|be
decl|14
name|requests
name|at
decl|2kB
name|each
name|from
name|this
decl|2k
name|we
name|have
name|to
name|remove
name|the
name|TIB
decl|-
name|whatever
name|that
name|is
decl|- for
name|data
name|netbsd
range|:
name|we
name|need
name|to
name|call
name|_start
name|after
name|receiveing
name|a
name|packet
name|to
name|see
end_decl_stmt

begin_if
if|if any packets were queued whilst in the interrupt  	there is a potential race in obtaining ccss for the tx
operator|,
name|in
name|that
name|we
name|might
name|be
name|in
name|_start
name|synchronously
name|and
name|then
name|an
name|rx
name|interrupt
name|occurs
operator|.
name|the
name|rx
name|will
name|call
name|_start
name|and
name|steal
name|tx
name|ccs
name|from
name|underneath
name|the
name|interrupted
name|entry
operator|.
name|toptions
name|is
name|it
name|just
name|as
name|simple
name|as
name|splimp
argument_list|()
name|around
name|the
name|ccs
name|search
condition|?
name|dont
name|call
name|_start
name|from
name|rx
name|interrupt
name|find
name|a
name|safe
name|way
name|of
name|locking
name|find
name|a
name|better
name|way
name|of
name|obtaining
name|ccs
name|using
name|next
name|free
name|avilable
condition|?
name|look
name|at
name|other
name|drivers
name|use
name|tsleep
operator|/
name|wakeup
name|use
name|asleep
name|await
operator|*
operator|*
operator|*
operator|*
operator|*
name|some
name|form
name|of
name|ring
name|to
name|hold
name|ccs
name|free
name|lsit
name|rework
name|calling
endif|#
directive|endif
endif|XXX_NETBSDTX
comment|/*  * Start timeout routine.  *  * Used when card was busy but we needed to send a packet.  */
specifier|static
name|void
name|ray_start_timo
argument_list|(
argument|void *xsc
argument_list|)
block|{ 	struct
name|ray_softc
operator|*
name|sc
operator|=
name|xsc
block|; 	struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_if

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_start_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}
comment|/*  * Write an 802.11 header into the TX buffer and return the  * adjusted buffer pointer.  */
end_comment

begin_function
unit|static
name|size_t
name|ray_start_wrhdr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|,
name|size_t
name|bufp
parameter_list|)
block|{
name|struct
name|ieee80211_header
name|header
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_start_wrhdr\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
name|header
operator|.
name|i_fc
index|[
literal|0
index|]
operator|=
operator|(
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
block|{
name|header
operator|.
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_STA_TO_STA
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|header
operator|.
name|i_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|header
operator|.
name|i_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|header
operator|.
name|i_addr3
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|==
name|RAY_MIB_AP_STATUS_TERMINAL
condition|)
block|{
name|header
operator|.
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_STA_TO_AP
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|header
operator|.
name|i_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|header
operator|.
name|i_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|header
operator|.
name|i_addr3
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"ray%d: ray_start can't be an AP yet\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bufp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine best antenna to use from rx level and antenna cache  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ray_start_best_antenna
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|ray_siglev
modifier|*
name|sl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int8_t
name|antenna
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_start_best_antenna\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* try to find host */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sl
operator|->
name|rsl_host
argument_list|,
name|dst
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* not found, return default setting */
return|return
operator|(
literal|0
operator|)
return|;
name|found
label|:
comment|/* This is a simple thresholding scheme which takes the mean 	 * of the best antenna history. This is okay but as it is a 	 * filter, it adds a bit of lag in situations where the 	 * best antenna swaps from one side to the other slowly. Don't know 	 * how likely this is given the horrible fading though. 	 */
name|antenna
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NANTENNA
condition|;
name|i
operator|++
control|)
block|{
name|antenna
operator|+=
name|sl
operator|->
name|rsl_antennas
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|antenna
operator|>
operator|(
name|RAY_NANTENNA
operator|>>
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit now complete so clear ccs and network flags.  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int8_t
name|status
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
modifier|*
name|status_string
index|[]
init|=
name|RAY_CCS_STATUS_STRINGS
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_start_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RAY_CCS_STATUS_COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_start tx completed but status is %s.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|status_string
index|[
name|status
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receiver packet handling  */
end_comment

begin_comment
comment|/*  * Receive a packet from the card  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|rcs
parameter_list|)
block|{
name|struct
name|ieee80211_header
modifier|*
name|header
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|size_t
name|pktlen
decl_stmt|,
name|fraglen
decl_stmt|,
name|readlen
decl_stmt|,
name|tmplen
decl_stmt|;
name|size_t
name|bufp
decl_stmt|,
name|ebufp
decl_stmt|;
name|u_int8_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|u_int8_t
name|fc
decl_stmt|;
name|u_int8_t
name|siglev
decl_stmt|,
name|antenna
decl_stmt|;
name|u_int
name|first
decl_stmt|,
name|ni
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_rx\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_CCS
argument_list|,
operator|(
literal|"ray%d: rcs chain - using rcs 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|rcs
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|readlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get first part of packet and the length. Do some sanity checks 	 * and get a mbuf. 	 */
name|first
operator|=
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_pktlen
argument_list|)
expr_stmt|;
name|siglev
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_siglev
argument_list|)
expr_stmt|;
name|antenna
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_antenna
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pktlen
operator|>
name|MCLBYTES
operator|)
operator|||
operator|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|)
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RECERR
argument_list|,
operator|(
literal|"ray%d: ray_rx packet is too big or too small\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RECERR
argument_list|,
operator|(
literal|"ray%d: ray_rx MGETHDR failed\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RECERR
argument_list|,
operator|(
literal|"ray%d: ray_rx MCLGET failed\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pktlen
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
name|dst
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Walk the fragment chain to build the complete packet. 	 * 	 * The use of two index variables removes a race with the 	 * hardware. If one index were used the clearing of the CCS would 	 * happen before reading the next pointer and the hardware can get in. 	 * Not my idea but verbatim from the NetBSD driver. 	 */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_bufp
argument_list|)
expr_stmt|;
name|fraglen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RX
argument_list|,
operator|(
literal|"ray%d: ray_rx frag index %d len %d bufp 0x%x ni %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|i
operator|,
name|fraglen
operator|,
operator|(
name|int
operator|)
name|bufp
operator|,
name|ni
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fraglen
operator|+
name|readlen
operator|>
name|pktlen
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RECERR
argument_list|,
operator|(
literal|"ray%d: ray_rx bad length current 0x%x pktlen 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|fraglen
operator|+
name|readlen
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|RAY_RCS_FIRST
operator|)
operator|||
operator|(
name|i
operator|>
name|RAY_RCS_LAST
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_rx bad rcs index 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|ebufp
operator|=
name|bufp
operator|+
name|fraglen
expr_stmt|;
if|if
condition|(
name|ebufp
operator|<=
name|RAY_RX_END
condition|)
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
name|fraglen
argument_list|)
expr_stmt|;
else|else
block|{
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
operator|(
name|tmplen
operator|=
name|RAY_RX_END
operator|-
name|bufp
operator|)
argument_list|)
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_RX_BASE
argument_list|,
name|dst
operator|+
name|tmplen
argument_list|,
name|ebufp
operator|-
name|RAY_RX_END
argument_list|)
expr_stmt|;
block|}
name|dst
operator|+=
name|fraglen
expr_stmt|;
name|readlen
operator|+=
name|fraglen
expr_stmt|;
block|}
name|skip_read
label|:
comment|/* 	 * Walk the chain again to free the rcss. 	 */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return;
name|RAY_DMBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
literal|"ray_rx"
argument_list|)
expr_stmt|;
comment|/* 	 * Check the 802.11 packet type and obtain the .11 src addresses. 	 * 	 * XXX CTL and MGT packets will have separate functions, DATA with here 	 * 	 * XXX This needs some work for INFRA mode 	 */
name|header
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_header
operator|*
argument_list|)
expr_stmt|;
name|fc
operator|=
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fc
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RECERR
argument_list|,
operator|(
literal|"ray%d: header not version 0 fc 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|fc
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|fc
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a MGT packet - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a CTL packet - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_MBUF
argument_list|,
operator|(
literal|"ray%d: ray_rx got a DATA packet\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a unknown packet fc0 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
name|fc
operator|=
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
switch|switch
condition|(
name|fc
operator|&
name|IEEE80211_FC1_DS_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_STA_TO_STA
case|:
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RX
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from sta %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|src
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_STA_TO_AP
case|:
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RX
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from sta to ap %6D %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|src
operator|,
literal|":"
operator|,
name|header
operator|->
name|i_addr3
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_AP_TO_STA
case|:
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RX
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from ap %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|src
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_AP_TO_AP
case|:
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RX
argument_list|,
operator|(
literal|"ray%d: ray_rx packet between aps %6D %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|src
operator|,
literal|":"
operator|,
name|header
operator|->
name|i_addr2
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
default|default:
name|src
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: ray_rx packet type unknown fc1 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Translation - capability as described earlier 	 * 	 * Each case must remove the 802.11 header and leave an 802.3 	 * header in the mbuf copy addresses as needed. 	 */
switch|switch
condition|(
name|sc
operator|->
name|translation
condition|)
block|{
case|case
name|SC_TRANSLATE_WEBGEAR
case|:
comment|/* Nice and easy - just trim the 802.11 header */
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx unknown translation type 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|translation
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Finally, do a bit of house keeping before sending the packet 	 * up the stack. 	 */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|ray_rx_update_cache
argument_list|(
name|sc
argument_list|,
name|src
argument_list|,
name|siglev
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBPFILTER */
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Update rx level and antenna cache  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_update_cache
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|src
parameter_list|,
name|u_int8_t
name|siglev
parameter_list|,
name|u_int8_t
name|antenna
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mini
decl_stmt|;
name|struct
name|timeval
name|mint
decl_stmt|;
name|struct
name|ray_siglev
modifier|*
name|sl
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_rx_update_cache\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* try to find host */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sl
operator|->
name|rsl_host
argument_list|,
name|src
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* not found, find oldest slot */
name|mini
operator|=
literal|0
expr_stmt|;
name|mint
operator|.
name|tv_sec
operator|=
name|LONG_MAX
expr_stmt|;
name|mint
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|sl
operator|->
name|rsl_time
argument_list|,
operator|&
name|mint
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|mini
operator|=
name|i
expr_stmt|;
name|mint
operator|=
name|sl
operator|->
name|rsl_time
expr_stmt|;
block|}
block|}
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|mini
index|]
expr_stmt|;
name|bzero
argument_list|(
name|sl
operator|->
name|rsl_siglevs
argument_list|,
name|RAY_NSIGLEV
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sl
operator|->
name|rsl_antennas
argument_list|,
name|RAY_NANTENNA
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|sl
operator|->
name|rsl_host
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|found
label|:
name|microtime
argument_list|(
operator|&
name|sl
operator|->
name|rsl_time
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sl
operator|->
name|rsl_siglevs
argument_list|,
operator|&
name|sl
operator|->
name|rsl_siglevs
index|[
literal|1
index|]
argument_list|,
name|RAY_NSIGLEV
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sl
operator|->
name|rsl_siglevs
index|[
literal|0
index|]
operator|=
name|siglev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|bcopy
argument_list|(
name|sl
operator|->
name|rsl_antennas
argument_list|,
operator|&
name|sl
operator|->
name|rsl_antennas
index|[
literal|1
index|]
argument_list|,
name|RAY_NANTENNA
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sl
operator|->
name|rsl_antennas
index|[
literal|0
index|]
operator|=
name|antenna
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Interrupt handling  */
end_comment

begin_comment
comment|/*  * Process an interrupt  */
end_comment

begin_function
specifier|static
name|int
name|ray_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_intr\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_intr unloaded!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|++
name|sc
operator|->
name|sc_checkcounters
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|ray_intr_updt_errcntrs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the interrupt was for us, if so get the rcs/ccs 	 * and vector on the command contained within it. 	 */
if|if
condition|(
operator|!
name|RAY_HCS_INTR
argument_list|(
name|sc
argument_list|)
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_RCSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|RAY_CCS_LAST
condition|)
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
name|RAY_RCS_LAST
condition|)
name|ray_rcs_intr
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ray%d: ray_intr bad ccs index %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_RX
argument_list|,
operator|(
literal|"ray%d: interrupt %s handled\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|count
condition|?
literal|"was"
else|:
literal|"not"
operator|)
argument_list|)
expr_stmt|;
comment|/* Send any packets lying around */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the error counters.  *  * The card implements the following protocol to keep the values from  * being changed while read: It checks the `own' bit and if zero  * writes the current internal counter value, it then sets the `own'  * bit to 1. If the `own' bit was 1 it incremenets its internal  * counter. The user thus reads the counter if the `own' bit is one  * and then sets the own bit to 0.  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr_updt_errcntrs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|csc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_intr_updt_errcntrs\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* try and update the error counters */
name|csc
operator|=
name|RAY_STATUS_BASE
expr_stmt|;
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxo_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxoverflow
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrx_overflow
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxo_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxc_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxcksum
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrx_overflow
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxc_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rxhc_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxhcksum
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rx_hcksum
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rxhc_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxnoise
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rx_noise
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process CCS command completion  */
end_comment

begin_function
specifier|static
name|void
name|ray_ccs_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* XXX don't really need stat here? */
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"ccs index 0x%02x ccs addr 0x%02x cmd 0x%x status %d"
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|,
name|ccs
argument_list|,
name|cmd
argument_list|,
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_CMD_DOWNLOAD_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START_PARAMS"
argument_list|)
expr_stmt|;
name|ray_download_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"UPDATE_PARAMS"
argument_list|)
expr_stmt|;
name|ray_update_params_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_REPORT_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"REPORT_PARAMS"
argument_list|)
expr_stmt|;
comment|/* XXX proper function and don't forget to ecf_done */
comment|/* get the reported parameters */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_repreq
condition|)
break|break;
name|sc
operator|->
name|sc_repreq
operator|->
name|r_failcause
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_failcause
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_repreq
operator|->
name|r_len
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|sc
operator|->
name|sc_repreq
operator|->
name|r_data
argument_list|,
name|sc
operator|->
name|sc_repreq
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_repreq
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|ray_report_params
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_MCAST
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"UPDATE_MCAST"
argument_list|)
expr_stmt|;
name|ray_mcast_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_NET
case|:
case|case
name|RAY_CMD_JOIN_NET
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START|JOIN_NET"
argument_list|)
expr_stmt|;
name|ray_sj_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TX_REQ
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"TX_REQ"
argument_list|)
expr_stmt|;
name|ray_start_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|RAY_CMD_START_ASSOC
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START_ASSOC"
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_ASSOCWORKING_AGAIN
name|ray_start_assoc_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|XXX_ASSOCWORKING_AGAIN
break|break;
case|case
name|RAY_CMD_UPDATE_APM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got UPDATE_APM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TEST_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got TEST_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_SHUTDOWN
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got SHUTDOWN - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_DUMP_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got DUMP_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_TIMER
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got START_TIMER - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ray_ccs_free
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * See if needed things can be done now that a command has completed 	 */
name|ray_com_runq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process ECF command request  */
end_comment

begin_function
specifier|static
name|void
name|ray_rcs_intr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|rcs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_CCS
argument_list|,
operator|(
literal|"ray%d: rcs idx %d rcs 0x%x cmd 0x%x status %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
operator|,
name|rcs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_ECMD_RX_DONE
case|:
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_CCS
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got RX_DONE\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_rx
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_REJOIN_DONE
case|:
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_CCS
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got REJOIN_DONE\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_ROAM_START
case|:
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_CCS
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got ROAM_START\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_JAPAN_CALL_SIGNAL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr got JAPAN_CALL_SIGNAL - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CCS allocator for commands  */
end_comment

begin_comment
comment|/*  * Obtain a ccs and fill easy bits in  *  * Returns 1 and in `ccsp' the bus offset of the free ccs. Will block  * awaiting free ccs if needed, timo is passed to tsleep and will  * return 0 if the timeout expired.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ccs_alloc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
name|RAY_CCS_CMD_FIRST
init|;
name|i
operator|<=
name|RAY_CCS_CMD_LAST
condition|;
name|i
operator|++
control|)
block|{
comment|/* we probe here to make the card go */
operator|(
name|void
operator|)
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|RAY_CCS_CMD_LAST
condition|)
block|{
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"out of CCS's"
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"allocated 0x%02x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free up a ccs allocated via ray_ccs_alloc  *  * Return the old status. This routine is only used for ccs allocated via  * ray_ccs_alloc (not tx, rx or ECF command requests).  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ray_ccs_free
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|u_int8_t
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|ray_ccs_alloc
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"freed 0x%02x"
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command queuing and execution  *  * XXX  * Set up a command queue.  To submit a command, you do this:  *  *      s = splnet()  *      put_cmd_on_queue(sc, cmd)  *      start_command_on_queue(sc)  *      tsleep(com, 0, "raycmd", 0)  *      splx(s)  *      handle_completed_command(cmd)  *  * The start_command_on_queue() function looks like this:  *  *      if (device_ready_for_command(sc)&& queue_not_empty(sc))  *              running_cmd = pop_command_from_queue(sc)  *              submit_command(running_cmd)  *  *  * In your interrupt handler you do:  *  *      if (interrupt_is_completed_command(sc))  *              wakeup(running_cmd)  *              running_cmd = NULL;  *              start_command_on_queue(sc)  */
end_comment

begin_comment
comment|/*  * Add a command to the tail of the queue  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq_add
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_DCOM_DUMP
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
literal|"adding"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Run the command at the head of the queue (if not already running)  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
comment|/* XXX this can go later */
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"empty command queue"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FRUNNING
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"command already running"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|com
operator|==
name|NULL
operator|)
operator|||
operator|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FRUNNING
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
name|com
operator|->
name|c_flags
operator||=
name|RAY_COM_FRUNNING
expr_stmt|;
name|RAY_DCOM_DUMP
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
literal|"running"
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_function
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort the execution of a run queue entry and wakeup the  * user level caller.  *  * We do not remove the entry from the runq incase the caller want's to  * retry and to prevent any other commands being run. The user level caller  * must acknowledge the abort.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq_abort
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
if|if
condition|(
name|com
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"com and head of queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
name|RAY_DCOM_DUMP
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
literal|"aborting"
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_retval
operator|=
name|reason
expr_stmt|;
name|wakeup
argument_list|(
name|com
operator|->
name|c_wakeup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an aborted command and re-run the queue  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq_clrabort
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
if|if
condition|(
name|com
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"com and head of queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
name|RAY_DCOM_DUMP
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
literal|"removing"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
name|ray_com_runq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove run command and wakeup caller.  *  * Minimal checks are done here as we ensure that the com and  * command handler were matched up earlier.  *  * Remove the com from the comq, and wakeup the caller if it requested  * to be woken. This is used for ensuring a sequence of commands  * completes.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
comment|/* XXX shall we do this as below */
name|com
operator|->
name|c_flags
operator|&=
operator|~
name|RAY_COM_FRUNNING
expr_stmt|;
name|com
operator|->
name|c_flags
operator||=
name|RAY_COM_FCOMPLETED
expr_stmt|;
name|com
operator|->
name|c_retval
operator|=
literal|0
expr_stmt|;
name|RAY_DCOM_DUMP
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
literal|"removing"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FWOK
condition|)
name|wakeup
argument_list|(
name|com
operator|->
name|c_wakeup
argument_list|)
expr_stmt|;
comment|/* XXX what about error on completion then? deal with when i fix 	 * XXX the status checking */
block|}
end_function

begin_comment
comment|/*  * Send a command to the ECF.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
if|if
condition|(
name|com
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"com and head of queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
comment|/* 	 * XXX other drivers did this, but I think  	 * what we really want to do is just make sure we don't 	 * get here or that spinning is ok 	 * 	 * XXX actually we probably want to call a timeout on 	 * XXX ourself here... 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
if|if
condition|(
operator|++
name|i
operator|>
literal|50
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"spun too long"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"ray%d: ray_com_issue spinning"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|RAY_DCOM_DUMP
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAY_COM_NEEDS_TIMO
argument_list|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
argument_list|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"adding timeout"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Deal with commands that require a timeout to test completion.  *  * This routine is coded to only expect one outstanding request for the  * timed out requests at a time, but thats all that can be outstanding  * per hardware limitations and all that we issue anyway.  *  * We don't do any fancy testing of the command currently issued as we  * know it must be a timeout based one...unless I've got this wrong!  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
comment|/* XXX get rid of this at some point or make it KASSERT */
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"no command queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"ccs 0x%02x status %d"
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|RAY_CCS_STATUS_COMPLETE
case|:
case|case
name|RAY_CCS_STATUS_FREE
case|:
comment|/* Buggy firmware */
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CCS_STATUS_BUSY
case|:
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Replicates NetBSD */
if|if
condition|(
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
index|]
operator|==
literal|1
condition|)
block|{
comment|/* give a chance for the interrupt to occur */
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
index|]
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when interrupt handler for the command has done all it  * needs to.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
end_if

begin_comment
comment|/*  * Process completed ECF commands that probably came from the command queue  *  * This routine is called after vectoring the completed ECF command  * to the appropriate _done routine. It helps check everything is okay.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_check
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|"%s"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"no command queue"
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|c_ccs
operator|!=
name|ccs
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"ccs's don't match"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_COM */
end_comment

begin_comment
comment|/*  * Functions based on CCS commands  */
end_comment

begin_comment
comment|/*  * report a parameter  */
end_comment

begin_function
specifier|static
name|void
name|ray_report_params
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: ray_report_params\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_repreq
condition|)
return|return;
comment|/* do the issue check before equality check */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|ray_ccs_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|RAY_CMD_REPORT_PARAMS
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_paramid
argument_list|,
name|sc
operator|->
name|sc_repreq
operator|->
name|r_paramid
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|XXX_ASSOCWORKING_AGAIN
end_if

begin_comment
comment|/*XXX move this further down the code */
end_comment

begin_comment
comment|/*  * Start an association with an access point  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_assoc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|ray_cmd_simple
argument_list|(
name|sc
argument_list|,
name|RAY_CMD_START_ASSOC
argument_list|,
name|SCP_STARTASSOC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete association  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_assoc_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DCOM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/* 	 * Hurrah! The network is now active. 	 * 	 * Clearing IFF_OACTIVE will ensure that the system will queue 	 * packets. Just before we return from the interrupt context 	 * we check to see if packets have been queued. 	 */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|XXX_ASSOCWORKING_AGAIN
end_endif

begin_comment
comment|/*  * Download start up structures to card.  */
end_comment

begin_function
specifier|static
name|void
name|ray_download
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ray_mib_4
name|ray_mib_4_default
decl_stmt|;
name|struct
name|ray_mib_5
name|ray_mib_5_default
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
define|#
directive|define
name|MIB4
parameter_list|(
name|m
parameter_list|)
value|ray_mib_4_default.##m
define|#
directive|define
name|MIB5
parameter_list|(
name|m
parameter_list|)
value|ray_mib_5_default.##m
define|#
directive|define
name|PUT2
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do { (p)[0] = ((v>> 8)& 0xff); (p)[1] = (v& 0xff); } while(0)
comment|/* 	  * Firmware version 4 defaults - see if_raymib.h for details 	  */
name|MIB4
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|MIB4
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB4
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V4
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_max
argument_list|)
operator|=
name|RAY_MIB_CW_MAX_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_min
argument_list|)
operator|=
name|RAY_MIB_CW_MIN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
comment|/* 	  * Firmware version 5 defaults - see if_raymib.h for details 	  */
name|MIB5
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|MIB5
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB5
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_max
argument_list|)
argument_list|,
name|RAY_MIB_CW_MAX_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_min
argument_list|)
argument_list|,
name|RAY_MIB_CW_MIN_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_allow_probe_resp
argument_list|)
operator|=
name|RAY_MIB_ALLOW_PROBE_RESP_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_must_start
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_can_join
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
name|MIB5
argument_list|(
name|mib_basic_rate_set
index|[
literal|0
index|]
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_4_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_4_default
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_5_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_5_default
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ray_ccs_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_DOWNLOAD_PARAMS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Download completion routine.  */
end_comment

begin_function
specifier|static
name|void
name|ray_download_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_DCOM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/*  	 * Fake the current network parameter settings so start_join_net 	 * will not bother updating them to the card (we would need to 	 * zero these anyway, so we might as well copy). 	 */
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start or join a network  */
end_comment

begin_function
specifier|static
name|void
name|ray_sj
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ray_net_params
name|np
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|update
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX do I need this anymore? how can IFF_RUNNING be cleared 	 * XXX before this routine exits - check in ray_ioctl and the 	 * network code itself. 	 */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"IFF_RUNNING == 0"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
operator|(
name|void
operator|)
name|ray_ccs_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_START_NET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|ray_ccs_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_JOIN_NET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
condition|)
name|update
operator|++
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STARTJOIN
argument_list|,
literal|"%s updating nw params"
argument_list|,
name|update
condition|?
literal|"is"
else|:
literal|"not"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|.
name|p_net_type
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|np
operator|.
name|p_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|np
operator|.
name|p_privacy_must_start
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
name|np
operator|.
name|p_privacy_can_join
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete start command or intermediate step in join command  */
end_comment

begin_function
specifier|static
name|void
name|ray_sj_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int8_t
name|o_net_type
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_DCOM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Read back any network parameters the ECF changed 	 */
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
operator|&
name|sc
operator|->
name|sc_c
operator|.
name|p_1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_cmd_net
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust values for buggy build 4 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
expr_stmt|;
comment|/* card is telling us to update the network parameters */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_upd_param
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STARTJOIN
argument_list|,
literal|"card updating parameters"
argument_list|)
expr_stmt|;
name|o_net_type
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
expr_stmt|;
comment|/* XXX this may be wrong? */
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|sc
operator|->
name|sc_c
operator|.
name|p_2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_net_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|o_net_type
condition|)
block|{
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"card changing network type"
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|restart
name|ray_start_join
name|sequence
name|may
name|need
name|to
name|split
name|download_done
for|for this
endif|#
directive|endif
block|}
block|}
name|RAY_DNET_DUMP
argument_list|(
name|sc
argument_list|,
literal|" after start/join network completed."
argument_list|)
expr_stmt|;
comment|/* 	 * Hurrah! The network is now active. 	 * 	 * Clearing IFF_OACTIVE will ensure that the system will queue 	 * packets. Just before we return from the interrupt context 	 * we check to see if packets have been queued. 	 */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|#
directive|if
name|XXX_ASSOCWORKING_AGAIN
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
operator|==
name|RAY_CMD_JOIN_NET
condition|)
name|ray_start_assoc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
else|#
directive|else
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
endif|XXX_ASSOCWORKING_AGAIN
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * User land entry to promiscuous mode changes  */
end_comment

begin_if
unit|static int ray_promisc_user(struct ray_softc *sc) { 	struct ifnet *ifp; 	struct ray_comq_entry *com; 	int error;  	RAY_DPRINTF(sc, RAY_DBG_SUBR, "");  	if ((ifp->if_flags& IFF_RUNNING) == 0) 		return (0); 	if (sc->promisc != !!(ifp->if_flags& (IFF_PROMISC|IFF_ALLMULTI))) 		return (0);  	MALLOC(com, struct ray_comq_entry *, sizeof(struct ray_comq_entry), 	    M_RAYCOM, M_WAITOK); 	com->c_function = ray_promisc; 	com->c_flags = RAY_COM_FWOK; 	com->c_retval = 0; 	com->c_ccs = NULL; 	com->c_wakeup = com;
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
end_if

begin_endif
unit|com->c_mesg = "ray_promisc";
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 0 */
end_comment

begin_comment
unit|ray_com_runq_add(sc, com);  	ray_com_runq(sc); 	RAY_DPRINTF(sc, RAY_DBG_COM, "sleeping"); 	(void)tsleep(com[3], 0, "raypromisc", 0); 	RAY_DPRINTF(sc, RAY_DBG_COM, "awakened");  	error = com->c_retval; 	FREE(com, M_RAYCOM); 	return (error); }
comment|/*  * Set/reset promiscuous mode  */
end_comment

begin_comment
unit|static void ray_promisc(struct ray_softc *sc, struct ray_comq_entry *com) { 	struct ifnet *ifp;  	RAY_DPRINTF(sc, RAY_DBG_SUBR, ""); 	RAY_MAP_CM(sc);  	ifp =&sc->arpcom.ac_if;  	(void)ray_ccs_alloc(sc,&com->c_ccs, RAY_CMD_UPDATE_PARAMS, 0); 	SRAM_WRITE_FIELD_1(sc,&com->c_ccs, 	    ray_cmd_update, c_paramid, RAY_MIB_PROMISC); 	SRAM_WRITE_FIELD_1(sc,&com->c_ccs, ray_cmd_update, c_nparam, 1); 	SRAM_WRITE_1(sc, RAY_HOST_TO_ECF_BASE,  	    !!(ifp->if_flags& (IFF_PROMISC|IFF_ALLMULTI)));  	ray_com_ecf(sc, com); }
comment|/*  * Complete the promiscuous mode update  */
end_comment

begin_comment
unit|static void ray_promisc_done(struct ray_softc *sc, size_t ccs) { 	RAY_DPRINTF(sc, RAY_DBG_SUBR, ""); 	RAY_DCOM_CHECK(sc, ccs);  	ray_com_ecf_done(sc); }
comment|/*  * update the parameter based on what the user passed in  */
end_comment

begin_comment
unit|static void ray_update_params(struct ray_softc *sc) { 	struct ifnet *ifp; 	size_t ccs;  	RAY_DPRINTFN(RAY_DBG_SUBR, ("ray%d: ray_update_params\n", sc->unit)); 	RAY_MAP_CM(sc);  	ifp =&sc->arpcom.ac_if;  	ray_cmd_cancel(sc, SCP_UPD_UPDATEPARAMS); 	if (!sc->sc_updreq) {
comment|/* XXX do we need to wakeup here? */
end_comment

begin_comment
unit|return; 	}
comment|/* do the issue check before equality check */
end_comment

begin_comment
unit|if ((ifp->if_flags& IFF_RUNNING) == 0) 		return; 	else if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) { 		ray_cmd_schedule(sc, SCP_UPD_UPDATEPARAMS); 		return; 	} else if (!ray_ccs_alloc(sc,&ccs, RAY_CMD_UPDATE_PARAMS, 0)) 		return;  	SRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid, 	    sc->sc_updreq->r_paramid); 	SRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1); 	ray_write_region(sc, RAY_HOST_TO_ECF_BASE, sc->sc_updreq->r_data, 	    sc->sc_updreq->r_len);  	(void)ray_cmd_issue(sc, ccs, SCP_UPD_UPDATEPARAMS); }
comment|/*  * an update params command has completed lookup which command and  * the status  *  * XXX this isn't finished yet, we need to grok the command used  */
end_comment

begin_comment
unit|static void ray_update_params_done(struct ray_softc *sc, size_t ccs, u_int stat) { 	RAY_DPRINTFN(RAY_DBG_SUBR, 	    ("ray%d: ray_update_params_done\n", sc->unit)); 	RAY_MAP_CM(sc);
comment|/* this will get more complex as we add commands */
end_comment

begin_comment
unit|if (stat == RAY_CCS_STATUS_FAIL) { 		printf("ray%d: failed to update a promisc\n", sc->unit);
comment|/* XXX should probably reset */
end_comment

begin_comment
comment|/* rcmd = ray_reset; */
end_comment

begin_comment
unit|}  	if (sc->sc_running& SCP_UPD_PROMISC) { 		ray_cmd_done(sc, SCP_UPD_PROMISC); 		sc->sc_promisc = SRAM_READ_1(sc, RAY_HOST_TO_ECF_BASE); 		RAY_DPRINTFN(RAY_DBG_IOCTL, 		    ("ray%d: new promisc value %d\n", sc->unit, 		    sc->sc_promisc)); 	} else if (sc->sc_updreq) { 		ray_cmd_done(sc, SCP_UPD_UPDATEPARAMS);
comment|/* get the update parameter */
end_comment

begin_comment
unit|sc->sc_updreq->r_failcause = 		    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_update, c_failcause); 		sc->sc_updreq = 0; 		wakeup(ray_update_params); 		ray_sj_net(sc); 	} }
comment|/*  * User land entry to multicast list changes  */
end_comment

begin_comment
unit|static int ray_mcast_user(struct ray_softc *sc) { 	struct ifnet *ifp; 	struct ray_comq_entry *com[2]; 	int error, count;  	RAY_DPRINTF(sc, RAY_DBG_SUBR, ""); 	 	ifp =&sc->arpcom.ac_if;
comment|/* 	 * The multicast list is only 16 items long so use promiscuous 	 * mode if needed. 	 * 	 * We track this stuff even when not running. 	 */
end_comment

begin_comment
unit|for (ifma = ifp->if_multiaddrs.lh_first, count = 0; ifma != NULL; 	    ifma = ifma->ifma_link.le_next, count++) 	if (count> 16) 		ifp->if_flags |= IFF_ALLMULTI; 	else if (ifp->if_flags& IFF_ALLMULTI) 		ifp->if_flags&= ~IFF_ALLMULTI;  	if ((ifp->if_flags& IFF_RUNNING) == 0) { 		return (0); 	}
comment|/* 	 * If we need to change the promiscuous mode then do so. 	 */
end_comment

begin_if
unit|if (sc->promisc != !!(ifp->if_flags& (IFF_PROMISC|IFF_ALLMULTI))) { 		MALLOC(com[0], struct ray_comq_entry *, 		    sizeof(struct ray_comq_entry), M_RAYCOM, M_WAITOK); 		com[0]->c_function = ray_promisc; 		com[0]->c_flags = RAY_COM_FWOK;  		com[0]->c_retval = 0; 		com[0]->c_ccs = NULL; 		com[0]->c_wakeup = com[1];
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
end_if

begin_endif
unit|com[0]->c_mesg = "ray_promisc";
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 0 */
end_comment

begin_comment
unit|ray_com_runq_add(sc, com[0]); 	} else 	    com[0] = NULL;
comment|/* 	 * If we need to set the mcast list then do so. 	 */
end_comment

begin_if
unit|if (!(ifp->if_flags& IFF_ALLMULTI)) 		MALLOC(com[1], struct ray_comq_entry *, 		    sizeof(struct ray_comq_entry), M_RAYCOM, M_WAITOK); 		com[1]->c_function = ray_mcast; 		com[0]->c_flags&= ~RAY_COM_FWOK;  		com[1]->c_flags = RAY_COM_FWOK;  		com[1]->c_retval = 0; 		com[1]->c_ccs = NULL; 		com[1]->c_wakeup = com[1];
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
end_if

begin_endif
unit|com[1]->c_mesg = "ray_mcast";
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 0 */
end_comment

begin_comment
unit|ray_com_runq_add(sc, com[1]); 	} else 	    com[1] = NULL;  	ray_com_runq(sc); 	RAY_DPRINTF(sc, RAY_DBG_COM, "sleeping"); 	(void)tsleep(com[1], 0, "raymcast", 0); 	RAY_DPRINTF(sc, RAY_DBG_COM, "awakened");  	error = com->c_retval; 	if (com[0] != NULL) 	    FREE(com[0], M_RAYCOM); 	if (com[1] != NULL) 	    FREE(com[1], M_RAYCOM); 	return (error); }
comment|/*  * Set the multicast filter list  */
end_comment

begin_comment
unit|static void ray_mcast(struct ray_softc *sc, struct ray_comq_entry *com) { 	struct ifnet *ifp; 	struct ifmultiaddr *ifma; 	size_t bufp;  	RAY_DPRINTF(sc, RAY_DBG_SUBR, ""); 	RAY_MAP_CM(sc);  	ifp =&sc->arpcom.ac_if;  	(void)ray_ccs_alloc(sc,&com->c_ccs, RAY_CMD_UPDATE_MCAST, 0); 	SRAM_WRITE_FIELD_1(sc,&com->c_ccs, 	    ray_cmd_update_mcast, c_nmcast, count); 	bufp = RAY_HOST_TO_ECF_BASE; 	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL; 	    ifma = ifma->ifma_link.le_next) { 		ray_write_region( 		    sc, 		    bufp, 		    LLADDR((struct sockaddr_dl *)ifma->ifma_addr), 		    ETHER_ADDR_LEN 		); 		bufp += ETHER_ADDR_LEN; 	}  	ray_com_ecf(sc, com); }
comment|/*  * Complete the multicast filter list update  */
end_comment

begin_comment
unit|static void ray_mcast_done(struct ray_softc *sc, size_t ccs) { 	RAY_DPRINTF(sc, RAY_DBG_SUBR, ""); 	RAY_DCOM_CHECK(sc, ccs);  	ray_com_ecf_done(sc); }
comment|/*  * issue a update params  *  * expected to be called in sleepable context -- intended for user stuff  */
end_comment

begin_comment
unit|static int ray_user_update_params(struct ray_softc *sc, struct ray_param_req *pr) { 	struct ifnet *ifp; 	int rv;  	RAY_DPRINTFN(RAY_DBG_SUBR, 	    ("ray%d: ray_user_update_params\n", sc->unit)); 	RAY_MAP_CM(sc);  	ifp =&sc->arpcom.ac_if;  	if ((ifp->if_flags& IFF_RUNNING) == 0) { 		pr->r_failcause = RAY_FAILCAUSE_EDEVSTOP; 		return (EIO); 	}  	if (pr->r_paramid> RAY_MIB_MAX) { 		return (EINVAL); 	}
comment|/* 	 * Handle certain parameters specially 	 */
end_comment

begin_comment
unit|switch (pr->r_paramid) { 	case RAY_MIB_NET_TYPE: 		if (sc->sc_c.np_net_type == *pr->r_data) 			return (0); 		sc->sc_d.np_net_type = *pr->r_data; 		if (ifp->if_flags& IFF_RUNNING) 			ray_sj_net(sc); 		return (0);  	case RAY_MIB_SSID: 		if (bcmp(sc->sc_c.np_ssid, pr->r_data, IEEE80211_NWID_LEN) == 0) 			return (0); 		bcopy(pr->r_data, sc->sc_d.np_ssid, IEEE80211_NWID_LEN); 		if (ifp->if_flags& IFF_RUNNING) 			ray_sj_net(sc); 		return (0);  	case RAY_MIB_BASIC_RATE_SET: 		sc->sc_d.np_def_txrate = *pr->r_data; 		break;  	case RAY_MIB_AP_STATUS:
comment|/* Unsupported */
end_comment

begin_comment
unit|case RAY_MIB_MAC_ADDR:
comment|/* XXX Need interface up */
end_comment

begin_comment
unit|case RAY_MIB_PROMISC:
comment|/* BPF */
end_comment

begin_comment
unit|return (EINVAL); 		break;  	default: 		break; 	}  	if (pr->r_paramid> RAY_MIB_LASTUSER) { 		return (EINVAL); 	}
comment|/* wait to be able to issue the command */
end_comment

begin_comment
unit|rv = 0; 	while (ray_cmd_is_running(sc, SCP_UPD_UPDATEPARAMS) || 	    ray_cmd_is_scheduled(sc, SCP_UPD_UPDATEPARAMS)) { 		rv = tsleep(ray_update_params, 0|PCATCH, "cmd in use", 0); 		if (rv) 			return (rv); 		if ((ifp->if_flags& IFF_RUNNING) == 0) { 			pr->r_failcause = RAY_FAILCAUSE_EDEVSTOP; 			return (EIO); 		} 	}  	pr->r_failcause = RAY_FAILCAUSE_WAITING; 	sc->sc_updreq = pr; 	ray_cmd_schedule(sc, SCP_UPD_UPDATEPARAMS); 	ray_cmd_check_scheduled(sc);  	while (pr->r_failcause == RAY_FAILCAUSE_WAITING) 		(void)tsleep(ray_update_params, 0, "waiting cmd", 0); 	wakeup(ray_update_params);  	return (0); }
comment|/*  * issue a report params  *  * expected to be called in sleapable context -- intended for user stuff  */
end_comment

begin_comment
unit|static int ray_user_report_params(struct ray_softc *sc, struct ray_param_req *pr) { 	struct ifnet *ifp; 	int mib_sizes[] = RAY_MIB_SIZES; 	int rv;  	RAY_DPRINTFN(RAY_DBG_SUBR, 	    ("ray%d: ray_user_report_params\n", sc->unit)); 	RAY_MAP_CM(sc);  	ifp =&sc->arpcom.ac_if;  	if ((ifp->if_flags& IFF_RUNNING) == 0) { 		pr->r_failcause = RAY_FAILCAUSE_EDEVSTOP; 		return (EIO); 	}
comment|/* test for illegal values or immediate responses */
end_comment

begin_comment
unit|if (pr->r_paramid> RAY_MIB_LASTUSER) { 	    	switch (pr->r_paramid) {  		case  RAY_MIB_VERSION: 			if (sc->sc_version == RAY_ECFS_BUILD_4) 			    *pr->r_data = 4; 			else 			    *pr->r_data = 5; 			break;  		case  RAY_MIB_CUR_BSSID: 		    	bcopy(sc->sc_c.np_bss_id, pr->r_data, ETHER_ADDR_LEN); 			break; 		case  RAY_MIB_CUR_INITED: 		    	*pr->r_data = sc->sc_c.np_inited; 			break; 		case  RAY_MIB_CUR_DEF_TXRATE: 		    	*pr->r_data = sc->sc_c.np_def_txrate; 			break; 		case  RAY_MIB_CUR_ENCRYPT: 		    	*pr->r_data = sc->sc_c.np_encrypt; 			break; 		case  RAY_MIB_CUR_NET_TYPE: 		    	*pr->r_data = sc->sc_c.np_net_type; 			break; 		case  RAY_MIB_CUR_SSID: 		    	bcopy(sc->sc_c.np_ssid, pr->r_data, IEEE80211_NWID_LEN); 			break; 		case  RAY_MIB_CUR_PRIV_START: 		    	*pr->r_data = sc->sc_c.np_priv_start; 			break; 		case  RAY_MIB_CUR_PRIV_JOIN: 		    	*pr->r_data = sc->sc_c.np_priv_join; 			break;  		case  RAY_MIB_DES_BSSID: 		    	bcopy(sc->sc_d.np_bss_id, pr->r_data, ETHER_ADDR_LEN); 			break; 		case  RAY_MIB_DES_INITED: 		    	*pr->r_data = sc->sc_d.np_inited; 			break; 		case  RAY_MIB_DES_DEF_TXRATE: 		    	*pr->r_data = sc->sc_d.np_def_txrate; 			break; 		case  RAY_MIB_DES_ENCRYPT: 		    	*pr->r_data = sc->sc_d.np_encrypt; 			break; 		case  RAY_MIB_DES_NET_TYPE: 		    	*pr->r_data = sc->sc_d.np_net_type; 			break; 		case  RAY_MIB_DES_SSID: 		    	bcopy(sc->sc_d.np_ssid, pr->r_data, IEEE80211_NWID_LEN); 			break; 		case  RAY_MIB_DES_PRIV_START: 		    	*pr->r_data = sc->sc_d.np_priv_start; 			break; 		case  RAY_MIB_DES_PRIV_JOIN: 		    	*pr->r_data = sc->sc_d.np_priv_join; 			break;  		default: 		    	return (EINVAL); 			break; 		} 		pr->r_failcause = 0; 		pr->r_len = mib_sizes[pr->r_paramid]; 		return (0); 	}
comment|/* wait to be able to issue the command */
end_comment

begin_else
unit|rv = 0; 	while (ray_cmd_is_running(sc, SCP_REPORTPARAMS) 	    || ray_cmd_is_scheduled(sc, SCP_REPORTPARAMS)) { 		rv = tsleep(ray_report_params, 0|PCATCH, "cmd in use", 0); 		if (rv) 			return (rv); 		if ((ifp->if_flags& IFF_RUNNING) == 0) { 			pr->r_failcause = RAY_FAILCAUSE_EDEVSTOP; 			return (EIO); 		} 	}  	pr->r_failcause = RAY_FAILCAUSE_WAITING; 	sc->sc_repreq = pr; 	ray_cmd_schedule(sc, SCP_REPORTPARAMS); 	ray_cmd_check_scheduled(sc);  	while (pr->r_failcause == RAY_FAILCAUSE_WAITING) 		(void)tsleep(ray_report_params, 0, "waiting cmd", 0); 	wakeup(ray_report_params);  	return (0); }
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|ray_update_params
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|ray_update_params_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int
name|stat
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|int
name|ray_mcast_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|ray_mcast_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|int
name|ray_promisc_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_promisc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|ray_promisc_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|int
name|ray_user_update_params
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ray_user_report_params
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the error counters  */
end_comment

begin_function
specifier|static
name|int
name|ray_user_report_stats
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_stats_req
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sr
operator|->
name|rxoverflow
operator|=
name|sc
operator|->
name|sc_rxoverflow
expr_stmt|;
name|sr
operator|->
name|rxcksum
operator|=
name|sc
operator|->
name|sc_rxcksum
expr_stmt|;
name|sr
operator|->
name|rxhcksum
operator|=
name|sc
operator|->
name|sc_rxhcksum
expr_stmt|;
name|sr
operator|->
name|rxnoise
operator|=
name|sc
operator|->
name|sc_rxnoise
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * XXX NOT KNF FROM HERE DOWN  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Routines to read from/write to the attribute memory.  *  * Taken from if_xe.c.  *  * Until there is a real way of accessing the attribute memory from a driver  * these have to stay.  *  * The hack to use the crdread/crdwrite device functions causes the attribute  * memory to be remapped into the controller and looses the mapping of  * the common memory.  *  * We cheat by using PIOCSMEM and assume that the common memory window  * is in window 0 of the card structure.  *  * Also  *	pccard/pcic.c/crdread does mark the unmapped window as inactive  *	pccard/pccard.c/map_mem toggles the mapping of a window on  *	successive calls  *  */
end_comment

begin_if
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
end_if

begin_function
specifier|static
name|void
name|ray_attr_getmap
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|int
name|result
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_SUBR
argument_list|,
operator|(
literal|"ray%d: attempting to get map for common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCGMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_attr_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
name|RAY_DBG_CM
argument_list|,
operator|(
literal|"ray%d: attempting to remap common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCSMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
end_comment

begin_function
specifier|static
name|int
name|ray_attr_write
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|&
name|byte
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_write
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ray_attr_read
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_read
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ray_read_reg
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|off_t
name|reg
decl_stmt|;
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_MBUF
end_if

begin_function
specifier|static
name|void
name|ray_dump_mbuf
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|u_int8_t
modifier|*
name|d
decl_stmt|,
modifier|*
name|ed
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
name|p
index|[
literal|17
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"ray%d: %s mbuf dump:"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
literal|17
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|ed
operator|=
name|d
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|ed
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  %s\n\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|%
literal|16
index|]
operator|=
operator|(
operator|(
operator|*
name|d
operator|>=
literal|0x20
operator|)
operator|&&
operator|(
operator|*
name|d
operator|<
literal|0x80
operator|)
operator|)
condition|?
operator|*
name|d
else|:
literal|'.'
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_MBUF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRAY */
end_comment

end_unit

