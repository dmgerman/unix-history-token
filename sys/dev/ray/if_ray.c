begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: if_ray.c,v 1.4 2000/02/27 19:52:29 dmlb Exp $  *  */
end_comment

begin_define
define|#
directive|define
name|XXX
value|0
end_define

begin_define
define|#
directive|define
name|XXX_TRACKING
value|0
end_define

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_define
define|#
directive|define
name|RAY_DEBUG
value|100
end_define

begin_comment
comment|/* Big numbers get more verbose */
end_comment

begin_define
define|#
directive|define
name|RAY_CCS_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for CCS commands - only used for downloading startup parameters */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_STARTJOIN_TIMO
value|0
end_define

begin_comment
comment|/* Might be needed with build 4 */
end_comment

begin_define
define|#
directive|define
name|RAY_SJ_TIMEOUT
value|(90*hz)
end_define

begin_comment
comment|/* Timeout for failing STARTJOIN commands - only used with RAY_NEED_STARTJOIN_TIMO */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_CM_REMAPPING
value|1
end_define

begin_comment
comment|/* Needed until pccard maps more than one memory area */
end_comment

begin_define
define|#
directive|define
name|RAY_DUMP_CM_ON_GIFMEDIA
value|1
end_define

begin_comment
comment|/* Dump some common memory when the SIOCGIFMEDIA ioctl is issued - a nasty hack for debugging and will be placed by an ioctl and control program */
end_comment

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_comment
comment|/*  * Debugging odds and odds  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|RAY_DHEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|do { if (RAY_DEBUG> 10) {		\     u_int8_t *i;						\     for (i = p; i< (u_int8_t *)(p+l); i += 8)			\     	printf("  0x%08lx %8D\n",				\ 		(unsigned long)i, (unsigned char *)i, " ");	\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTF
parameter_list|(
name|x
parameter_list|)
value|do { if (RAY_DEBUG) {			\     printf x ;							\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DNET_DUMP
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
value|do { if (RAY_DEBUG) {			\     printf("ray%d: Network parameters%s\n", (sc)->unit, (s));		\     printf("  bss_id %6D\n", (sc)->sc_bss_id, ":");			\     printf("  inited 0x%02x\n", (sc)->sc_inited);			\     printf("  def_txrate 0x%02x\n", (sc)->sc_def_txrate);		\     printf("  encrypt 0x%02x\n", (sc)->sc_encrypt);			\     printf("  net_type 0x%02x\n", (sc)->sc_net_type);			\     printf("  ssid \"%.32s\"\n", (sc)->sc_ssid);			\     printf("  priv_start 0x%02x\n", (sc)->sc_priv_start);		\     printf("  priv_join 0x%02x\n", (sc)->sc_priv_join);			\ } } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_HEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DNET_DUMP
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 0 */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|10
end_if

begin_define
define|#
directive|define
name|RAY_DMBUF_DUMP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
value|ray_dump_mbuf((sc), (m), (s))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_DMBUF_DUMP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 10 */
end_comment

begin_include
include|#
directive|include
file|"ray.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NRAY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_ieee80211.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_rayreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_raymib.h>
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cis.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD */
end_comment

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM */
end_comment

begin_comment
comment|/*  * One of these structures per allocated device  */
end_comment

begin_struct
struct|struct
name|ray_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common 		*/
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
comment|/* Ifnet common 		*/
name|struct
name|callout_handle
decl|\
name|timerh
decl_stmt|;
comment|/* Handle for timer		*/
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|struct
name|callout_handle
decl|\
name|sj_timerh
decl_stmt|;
comment|/* Handle for start_join timer	*/
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|char
modifier|*
name|card_type
decl_stmt|;
comment|/* Card model name		*/
name|char
modifier|*
name|vendor
decl_stmt|;
comment|/* Card manufacturer		*/
name|int
name|unit
decl_stmt|;
comment|/* Unit number			*/
name|u_char
name|gone
decl_stmt|;
comment|/* 1 = Card bailed out		*/
name|int
name|irq
decl_stmt|;
comment|/* Assigned IRQ			*/
name|caddr_t
name|maddr
decl_stmt|;
comment|/* Shared RAM Address		*/
name|int
name|msize
decl_stmt|;
comment|/* Shared RAM Size		*/
name|int
name|translation
decl_stmt|;
comment|/* Packet translation types	*/
comment|/* XXX these can go when attribute reading is fixed */
name|int
name|slotnum
decl_stmt|;
comment|/* Slot number			*/
name|struct
name|mem_desc
name|md
decl_stmt|;
comment|/* Map info for common memory	*/
name|struct
name|ray_ecf_startup_v5
decl|\
name|sc_ecf_startup
decl_stmt|;
comment|/* Startup info from card	*/
name|u_int8_t
name|sc_ccsinuse
index|[
literal|64
index|]
decl_stmt|;
comment|/* ccss' in use -- not for tx	*/
name|size_t
name|sc_ccs
decl_stmt|;
comment|/* ccs used by non-scheduled,	*/
comment|/* non-overlapping procedures	*/
name|struct
name|ray_cmd_net
name|sc_cnet_1
decl_stmt|;
comment|/* current network params from	*/
name|struct
name|ray_net_params
name|sc_cnet_2
decl_stmt|;
comment|/* starting/joining a network	*/
if|#
directive|if
literal|0
block|u_int8_t		sc_cnwid[IEEE80211_NWID_LEN];
comment|/* Last nwid */
block|u_int8_t		sc_dnwid[IEEE80211_NWID_LEN];
comment|/* Desired nwid */
block|u_int8_t		sc_omode;
comment|/* Old operating mode SC_MODE_xx */
block|u_int8_t		sc_mode;
comment|/* Current operating mode SC_MODE_xx */
block|u_int8_t		sc_countrycode;
comment|/* Current country code */
block|u_int8_t		sc_dcountrycode;
comment|/* Desired country code */
endif|#
directive|endif
name|int
name|sc_havenet
decl_stmt|;
comment|/* true if we have aquired a network */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ray_softc
name|ray_softc
index|[
name|NRAY
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sc_station_addr
value|sc_ecf_startup.e_station_addr
end_define

begin_define
define|#
directive|define
name|sc_version
value|sc_ecf_startup.e_fw_build_string
end_define

begin_define
define|#
directive|define
name|sc_tibsize
value|sc_ecf_startup.e_tibsize
end_define

begin_define
define|#
directive|define
name|sc_upd_param
value|sc_cnet_1.c_upd_param
end_define

begin_define
define|#
directive|define
name|sc_bss_id
value|sc_cnet_1.c_bss_id
end_define

begin_define
define|#
directive|define
name|sc_inited
value|sc_cnet_1.c_inited
end_define

begin_define
define|#
directive|define
name|sc_def_txrate
value|sc_cnet_1.c_def_txrate
end_define

begin_define
define|#
directive|define
name|sc_encrypt
value|sc_cnet_1.c_encrypt
end_define

begin_define
define|#
directive|define
name|sc_net_type
value|sc_cnet_2.p_net_type
end_define

begin_define
define|#
directive|define
name|sc_ssid
value|sc_cnet_2.p_ssid
end_define

begin_define
define|#
directive|define
name|sc_priv_start
value|sc_cnet_2.p_privacy_must_start
end_define

begin_define
define|#
directive|define
name|sc_priv_join
value|sc_cnet_2.p_privacy_can_join
end_define

begin_comment
comment|/*XXX add to debug macro too */
end_comment

begin_comment
comment|/* Commands -- priority given to LSB */
end_comment

begin_define
define|#
directive|define
name|SCP_FIRST
value|0x0001
end_define

begin_define
define|#
directive|define
name|SCP_UPDATESUBCMD
value|0x0001
end_define

begin_define
define|#
directive|define
name|SCP_STARTASSOC
value|0x0002
end_define

begin_define
define|#
directive|define
name|SCP_REPORTPARAMS
value|0x0004
end_define

begin_define
define|#
directive|define
name|SCP_IFSTART
value|0x0008
end_define

begin_comment
comment|/* Update sub commands -- issues are serialized priority to LSB */
end_comment

begin_define
define|#
directive|define
name|SCP_UPD_FIRST
value|0x0100
end_define

begin_define
define|#
directive|define
name|SCP_UPD_STARTUP
value|0x0100
end_define

begin_define
define|#
directive|define
name|SCP_UPD_STARTJOIN
value|0x0200
end_define

begin_define
define|#
directive|define
name|SCP_UPD_PROMISC
value|0x0400
end_define

begin_define
define|#
directive|define
name|SCP_UPD_MCAST
value|0x0800
end_define

begin_define
define|#
directive|define
name|SCP_UPD_UPDATEPARAMS
value|0x1000
end_define

begin_define
define|#
directive|define
name|SCP_UPD_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|SCP_UPD_MASK
value|0xff00
end_define

begin_comment
comment|/* These command (a subset of the update set) require timeout checking */
end_comment

begin_define
define|#
directive|define
name|SCP_TIMOCHECK_CMD_MASK
define|\
value|(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \ 	SCP_UPD_PROMISC)
end_define

begin_comment
comment|/* Translation types */
end_comment

begin_comment
comment|/* XXX maybe better as part of the if structure? */
end_comment

begin_define
define|#
directive|define
name|SC_TRANSLATE_WEBGEAR
value|0
end_define

begin_comment
comment|/*  * PCMCIA driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_init
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_pccard_unload
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|ray
argument_list|,
name|ray_pccard_init
argument_list|,
name|ray_pccard_unload
argument_list|,
name|ray_pccard_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ISA driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|raydriver
init|=
block|{
name|ray_probe
block|,
name|ray_attach
block|,
literal|"ray"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Network driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ray_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_init
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_stop
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal utilites  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_alloc_ccs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
operator|*
name|ccsp
operator|,
name|u_int
name|cmd
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_ccs_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_free_ccs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_issue_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rcs_intr
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rx
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|rcs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_join_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int8_t
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_start_join_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_STARTJOIN_TIMO */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|10
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_dump_mbuf
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|mbuf
operator|*
name|m
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 10 */
end_comment

begin_comment
comment|/*  * Indirections for reading/writing shared memory - from NetBSD/if_ray.c  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((size_t)(&((type *)0)->member))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* offsetof */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|(u_int8_t)*((sc)->maddr + (off))
end_define

begin_comment
comment|/* ((u_int8_t)bus_space_read_1((sc)->sc_memt, (sc)->sc_memh, (off))) */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|SRAM_READ_1(sc, (off) + offsetof(struct s, f))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|((((u_int16_t)SRAM_READ_1(sc, (off) + offsetof(struct s, f))<< 8) \     |(SRAM_READ_1(sc, (off) + 1 + offsetof(struct s, f)))))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_read_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_read_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((sc)->maddr + (off), (vp), (n))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|*((sc)->maddr + (off)) = (val)
end_define

begin_comment
comment|/* bus_space_write_1((sc)->sc_memt, (sc)->sc_memh, (off), (val)) */
end_comment

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
define|\
value|SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (v))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
value|do {	\     SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (((v)>> 8 )& 0xff)); \     SRAM_WRITE_1(sc, (off) + 1 + offsetof(struct s, f), ((v)& 0xff)); \ } while (0)
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_write_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_write_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((vp), (sc)->maddr + (off), (n))
end_define

begin_comment
comment|/*  * Macro's  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_CCS_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_CCS_TIMEOUT
value|(hz / 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAY_ECF_READY
parameter_list|(
name|sc
parameter_list|)
value|(!(ray_read_reg(sc, RAY_ECFIR)& RAY_ECFIR_IRQ))
end_define

begin_define
define|#
directive|define
name|RAY_ECF_START_CMD
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_ECFIR, RAY_ECFIR_IRQ)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_CLEAR_INTR
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_HCSIR, 0)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_INTR
parameter_list|(
name|sc
parameter_list|)
value|(ray_read_reg(sc, RAY_HCSIR)& RAY_HCSIR_IRQ)
end_define

begin_comment
comment|/*  * XXX  * As described in if_xe.c...  *  * Horrid stuff for accessing CIS tuples and remapping common memory...  * XXX  */
end_comment

begin_define
define|#
directive|define
name|CARD_MAJOR
value|50
end_define

begin_decl_stmt
specifier|static
name|int
name|ray_attr_write
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
name|byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attr_read
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
operator|*
name|buf
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_read_reg
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_attr_getmap
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_attr_cm
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_cm(sc)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_CM_REMAPPING */
end_comment

begin_comment
comment|/*  * PCCard initialise.  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_init
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|irq
decl_stmt|;
name|int
name|j
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: PCCard probe\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NRAY
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|slotnum
operator|=
name|dev_p
operator|->
name|slt
operator|->
name|slotnum
expr_stmt|;
comment|/* Get IRQ - encoded as a bitmask. */
name|irq
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_irq
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|irq
operator|&
literal|0x1
condition|)
break|break;
name|irq
operator|>>=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|irq
operator|=
name|j
expr_stmt|;
name|sc
operator|->
name|maddr
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|msize
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d:<Raylink/IEEE 802.11> maddr 0x%lx msize 0x%x irq %d on isa (PC-Card slot %d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sc
operator|->
name|maddr
argument_list|,
name|sc
operator|->
name|msize
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_getmap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
if|if
condition|(
name|ray_attach
argument_list|(
operator|&
name|dev_p
operator|->
name|isahd
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCCard unload.  */
end_comment

begin_function
specifier|static
name|void
name|ray_pccard_unload
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: PCCard unload\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: already unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Cleardown interface */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX probably should be if_detach but I don't know if it works in 3.1 */
comment|/* Mark card as gone */
name|sc
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * PCCard interrupt.  */
end_comment

begin_comment
comment|/* XXX return 1 if we take interrupt, 0 otherwise */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_intr
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ccsi
decl_stmt|,
name|handled
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: PCCard intr\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before interrupt!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Check that the interrupt was for us, if so get the rcs/ccs and vector      * on the command contained within it.      */
if|if
condition|(
operator|!
name|RAY_HCS_INTR
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|handled
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|handled
operator|=
literal|1
expr_stmt|;
name|ccsi
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_RCSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccsi
operator|<=
name|RAY_CCS_LAST
condition|)
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|ccsi
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ccsi
operator|<=
name|RAY_RCS_LAST
condition|)
name|ray_rcs_intr
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|ccsi
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ray%d: ray_intr bad ccs index %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ccsi
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|ccs_done
name|and
name|rcs_intr
return|return
name|function
name|pointers
operator|-
name|why
name|dont
name|they
name|just
do|do
name|it
name|themselves
condition|?
name|its
name|not
name|as
if|if each command only 	requires a single function call - things like start_join_net 	call a couple on the way... 	if
condition|(
name|rcmd
condition|)
call|(
modifier|*
name|rcmd
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|}
if|if
condition|(
name|handled
condition|)
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: interrupt %s handled\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|handled
condition|?
literal|"was"
else|:
literal|"not"
operator|)
argument_list|)
expr_stmt|;
comment|/* Send any packets lying around */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|handled
operator|)
return|;
block|}
comment|/*  * ISA probe routine.  */
specifier|static
name|int
name|ray_probe
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ISA probe\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * ISA/PCCard attach.  */
specifier|static
name|int
name|ray_attach
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ISA/PCCard attach\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|id_unit
index|]
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before attach!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Read startup results, check the card is okay and work out what      * version we are using.      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
literal|"\020"
comment|/* print in hex */
literal|"\001RESERVED0"
literal|"\002PROC_SELF_TEST"
literal|"\003PROG_MEM_CHECKSUM"
literal|"\004DATA_MEM_TEST"
literal|"\005RX_CALIBRATION"
literal|"\006FW_VERSION_COMPAT"
literal|"\007RERSERVED1"
literal|"\008TEST_COMPLETE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unsupported firmware version 0x%0x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
operator|||
name|RAY_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Start Up Results\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAY_DEBUG
operator|>
literal|10
condition|)
name|RAY_DHEX8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_ECF_TO_HOST_BASE
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|printf
argument_list|(
literal|"  Firmware version 4\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  Firmware version 5\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Status 0x%x\n"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Ether address %6D\n"
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_rates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Supported rates %8D\n"
argument_list|,
name|ep
operator|->
name|e_rates
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  Japan call sign %12D\n"
argument_list|,
name|ep
operator|->
name|e_japan_callsign
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_prg_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_cis_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware version %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware revision %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_resv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ASIC version %0x\n"
argument_list|,
name|ep
operator|->
name|e_asic_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  TIB size %0x\n"
argument_list|,
name|ep
operator|->
name|e_tibsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Set the parameters that will survive stop/init      *      * Do not update these in ray_init's parameter setup      */
if|#
directive|if
name|XXX
name|see
name|the
name|ray_init
name|section
for|for stuff to move here
endif|#
directive|endif
comment|/*      * Initialise the network interface structure      */
for|bcopy
control|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|e_station_addr
operator|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|,
name|ETHER_ADDR_LEN
control|)
empty_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ray"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator|)
expr_stmt|;
comment|/* XXX - IFF_MULTICAST */
if|#
directive|if
name|XXX
name|ifp
operator|->
name|if_hdr
operator|=
operator|...
expr_stmt|;
name|make
name|this
name|big
name|enough
name|to
name|hold
name|the
literal|.11
name|and
literal|.3
name|headers
endif|#
directive|endif
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000
expr_stmt|;
comment|/* XXX Is this baud or bps ;-) */
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ray_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ray_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ray_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ray_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|RAY_CCS_TX_LAST
expr_stmt|;
comment|/*      * If this logical interface has already been attached,      * don't attach it again or chaos will ensue.      */
name|sprintf
argument_list|(
name|ifname
argument_list|,
literal|"ray%d"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifunit
argument_list|(
name|ifname
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|timerh
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBFFILTER */
if|#
directive|if
name|XXX
name|this
name|looks
name|like
name|a
name|good
name|idea
name|at_shutdown
argument_list|(
name|ray_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* XXX */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Network start.  *  *XXX from if_xe  * Start output on interface.  We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  *XXX from if_xe so maybe we can ignore? see start_join_net_done  */
specifier|static
name|void
name|ray_start
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network start\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX mark output queue full so the kernel waits */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
comment|/* XXX mark output queue full so the kernel waits */
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before start!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|!
name|sc
operator|->
name|sc_havenet
condition|)
return|return;
comment|/* We only deal with one packet at a time */
comment|/* XXX is this actually true? I don't think so there are 16 ccs */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
if|#
directive|if
name|XXX
name|netbsd
name|driver
name|uses
name|a
name|loop
name|repeat
name|get
name|a
name|ccs
name|get
name|a
name|mbuf
name|translate
name|and
name|send
name|packet
name|to
name|shared
name|ram
name|until
argument_list|(
name|no
name|more
name|ccs
literal|'s) || (no more mbuf'
name|s
argument_list|)
name|send
name|ccs
name|chain
name|to
name|card
name|exit
name|Linux
name|driver
name|is
name|simple
name|single
name|shot
name|packet
argument_list|(
name|with
name|a
name|lot
name|of
name|spinlocks
operator|!
argument_list|)
name|general
name|why
decl|14
name|CCS
name|reserved
decl|for
name|TX
name|in
name|Linux
decl|+
name|NetBSD
decl|?
name|Is
name|it
name|simply
name|that
name|there
name|are
name|that
name|many
name|ethernet
decl|+80211header
name|packets
name|in
name|the
name|TX
name|memory
name|space
decl|?
name|probably
name|the
name|tx
name|space
name|is
decl|0x7000
init|=
literal|28kB
decl_stmt|,
name|and
name|TX
name|buffer
name|size
name|is
decl|2048
decl|?
name|so
name|there
name|can
name|be
decl|14
name|requests
name|at
decl|2kB
name|each
name|from
name|this
decl|2k
name|we
name|have
name|to
name|remove
name|the
name|TIB
decl|-
name|whatever
name|that
name|is
decl|- for
name|data
name|netbsd
range|:
name|we
name|need
name|to
name|call
name|_start
name|after
name|receiveing
name|a
name|packet
name|to
name|see
if|if any packets were queued whilst in the interrupt  	there is a potential race in obtaining ccs's for the tx, in that 	we might be in _start synchronously and then an rx interrupt 	occurs. the rx will call _start and steal tx ccs from underneath 	the interrupted entry.  	toptions 		don't call _start from rx interrupt  		find a safe way of locking  		find a better way of obtaining ccs using next free avilable?  		look at other drivers  		use tsleep/wakeup  		some form of ring to hold ccs  		free lsit
endif|#
directive|endif
if|IF_DEQUEUE
condition|(
operator|&
name|ifp
operator|->
name|if_snd
operator|,
name|m
condition|)
empty_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
return|return;
block|}
comment|/*  * Network ioctl request.  */
specifier|static
name|int
name|ray_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network ioctl\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before ioctl!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl SIFADDR/GIFADDR/SIFMTU\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: for SIFFLAGS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * If the interface is marked up and stopped, then start 	     * it. If it is marked down and running, then stop it. 	     */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* DROP THROUGH */
if|#
directive|if
name|XXX
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for ADDMULTI/DELMULTI\n, sc->unit"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * Multicast list has (maybe) changed; set the hardware filter 	     * accordingly. This also serves to deal with promiscuous mode 	     * if we have a BPF listener active. 	     */
name|ray_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFFLAGS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMETRIC
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFMETRIC\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFMTU\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFPHYS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFPYHS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for SIFMEDIA\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFMEDIA\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DUMP_CM_ON_GIFMEDIA
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: RAY_SCB\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_DHEX8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_SCB_BASE
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: RAY_STATUS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_DNET_DUMP
argument_list|(
name|sc
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DUMP_CM_ON_GIFMEDIA */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network watchdog\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before watchdog!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ray%d: watchdog timeout\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX may need to have remedial action here    for example    	ray_reset - may be useful elsewhere 		ray_stop 		... 		ray_init */
return|return;
block|}
comment|/*  * Network initialisation.  */
specifier|static
name|void
name|ray_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network init\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before init!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Reset instance variables      *      * The first set are network parameters that are fully initialised      * when the card starts or joins the network.      *      * The second set are network parameters that are downloaded to      * the card.      *      * All of the variables in these sets can be updated by the card or ioctls.      */
name|sc
operator|->
name|sc_upd_param
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_bss_id
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_bss_id
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inited
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_def_txrate
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_encrypt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|translation
operator|=
name|SC_TRANSLATE_WEBGEAR
expr_stmt|;
if|#
directive|if
name|XXX
name|these
name|might
name|be
name|better
name|in
name|_attach
name|so
name|updated
name|values
name|are
name|kept
name|over
name|up
operator|/
name|down
name|events
name|we
name|probably
name|also
name|need
name|a
name|few
name|more
name|countrycode
endif|#
directive|endif
name|sc
operator|->
name|sc_net_type
operator|=
name|RAY_MIB_NET_TYPE_DEFAULT
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_ssid
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ssid
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_ssid
argument_list|,
name|RAY_MIB_SSID_DEFAULT
argument_list|,
name|RAY_MAXSSIDLEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_priv_start
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_priv_join
operator|=
name|RAY_MIB_PRIVACY_CAN_JOIN_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|XXX
name|NetBSD
name|sc
operator|->
name|sc_scheduled
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|sc_running
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|=
name|RAY_CCS_NTX
expr_stmt|;
name|sc
operator|->
name|sc_checkcounters
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set all ccs to be free */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccs
operator|=
name|RAY_CCS_LAST
operator|+
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_CCS_LAST
condition|;
name|ccs
operator|+=
name|RAY_CCS_SIZE
operator|,
name|i
operator|++
control|)
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Get startup results - the card may have been reset      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
literal|"\020"
comment|/* print in hex */
literal|"\001RESERVED0"
literal|"\002PROC_SELF_TEST"
literal|"\003PROG_MEM_CHECKSUM"
literal|"\004DATA_MEM_TEST"
literal|"\005RX_CALIBRATION"
literal|"\006FW_VERSION_COMPAT"
literal|"\007RERSERVED1"
literal|"\008TEST_COMPLETE"
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
return|return;
comment|/* XXX This doesn't mark the interface as down */
endif|#
directive|endif
comment|/* XXX */
block|}
comment|/*      * Fixup tib size to be correct - on build 4 it is garbage      */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_tibsize
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_tibsize
operator|=
literal|32
expr_stmt|;
comment|/*      * We are now up and running. Next we have to download network      * configuration into the card. We are busy until download is done.      */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
expr_stmt|;
if|#
directive|if
name|XXX
comment|/* set this now so it gets set in the download */
name|sc
operator|->
name|sc_promisc
operator|=
operator|!
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
name|ray_download_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|need
name|to
name|understand
name|how
name|the
name|doenload
name|finishes
name|first
name|Start
name|up
name|flow
name|is
name|as
name|follows
operator|.
name|The
name|kernel
name|calls
name|ray_init
name|when
name|the
name|interface
name|is
name|assigned
name|an
name|address
operator|.
name|ray_init
name|does
name|a
name|bit
name|of
name|house
name|keeping
name|before
name|calling
name|ray_download_params
operator|.
name|ray_download_params
name|fills
name|the
name|startup
name|parameter
name|structure
name|out
name|and
name|sends
name|it
name|to
name|the
name|card
operator|.
name|The
name|download
name|command
name|simply
name|completes
name|so
name|we
name|use
name|schedule
name|a
name|timeout
name|function
name|call
name|to
name|ray_download_timo
operator|.
name|We
name|pass
name|the
name|ccs
name|in
name|use
name|via
name|sc
operator|->
name|sc_css
operator|.
name|ray_download_timo
name|checks
name|the
name|ccs
for|for command completion/errors. 	Then it tells the card to start an adhoc or join a managed 	network. This should complete via the interrupt mechanism
operator|,
name|but
name|the
name|NetBSD
name|driver
name|includes
name|a
name|timeout
for|for some buggy stuff somewhere. 	I've left the hooks in but don't use them. The interrupt handler 	passes control to ray_start_join_done - the ccs is handled by 	the interrupt mechanism.  	Once ray_start_join_done has checked the ccs and 	uploaded/updated the network parameters we are ready to 	process packets. It can then call ray_start.
endif|#
directive|endif
comment|/* XXX */
for|return
empty_stmt|;
block|}
comment|/*  * Network stop.  */
specifier|static
name|void
name|ray_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network stop\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before stop!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* XXX stuff here please to kill activity on the card and drain down transmissons */
comment|/* Mark as not running */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return;
block|}
comment|/*  * Process CCS command completion - called from ray_intr  */
specifier|static
name|void
name|ray_ccs_done
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
block|{
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Processing ccs %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ccs idx %d ccs 0x%x cmd 0x%x stat %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|,
name|ccs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX should we panic on unrecognised commands or just ignore them?      * maybe I'll macroize the printf's */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_CMD_START_PARAMS
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got START_PARAMS - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_REPORT_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got REPORT_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_MCAST
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_MCAST\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_APM
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_APM\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_NET
case|:
case|case
name|RAY_CMD_JOIN_NET
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got START|JOIN_NET\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_start_join_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_ASSOC
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got START_ASSOC\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TX_REQ
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got TX_REQ\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
case|case
name|RAY_CMD_TEST_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got TEST_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_SHUTDOWN
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got SHUTDOWN - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_DUMP_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got DUMP_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_TIMER
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got START_TIMER - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Process ECF command request - called from ray_intr  */
specifier|static
name|void
name|ray_rcs_intr
parameter_list|(
name|sc
parameter_list|,
name|rcs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|rcs
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Processing rcs %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: rcs idx %d rcs 0x%x cmd 0x%x stat %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
operator|,
name|rcs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX should we panic on unrecognised commands or just ignore them?      * maybe I'll macroize the printf's */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_ECMD_RX_DONE
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr got RX_DONE\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_rx
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_REJOIN_DONE
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rcs_intr got UPDATE_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_ROAM_START
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rcs_intr got ROAM_START\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_JAPAN_CALL_SIGNAL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr got JAPAN_CALL_SIGNAL - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Receive a packet  */
specifier|static
name|void
name|ray_rx
parameter_list|(
name|sc
parameter_list|,
name|rcs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|rcs
decl_stmt|;
block|{
name|struct
name|ieee80211_header
modifier|*
name|header
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|pktlen
decl_stmt|,
name|fraglen
decl_stmt|,
name|readlen
decl_stmt|,
name|tmplen
decl_stmt|;
name|size_t
name|bufp
decl_stmt|,
name|ebufp
decl_stmt|;
name|u_int8_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|u_int8_t
name|fc
decl_stmt|;
name|u_int
name|first
decl_stmt|,
name|ni
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: rcs chain - using rcs 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|rcs
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|readlen
operator|=
literal|0
expr_stmt|;
comment|/*      * Get first part of packet and the length. Do some sanity checks      * and get a mbuf.      */
name|first
operator|=
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pktlen
operator|>
name|MCLBYTES
operator|)
operator|||
operator|(
name|pktlen
operator|<
literal|1
comment|/*XXX should be header size*/
operator|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx packet is too big or too small\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx MGETHDR failed\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx MCLGET failed\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pktlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
name|dst
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
comment|/*      * Walk the fragment chain to build the complete packet.      *      * The use of two index variables removes a race with the      * hardware. If one index were used the clearing of the CCS would      * happen before reading the next pointer and the hardware can get in.      * Not my idea but verbatim from the NetBSD driver.      */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_bufp
argument_list|)
expr_stmt|;
name|fraglen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx frag index %d len %d bufp 0x%x ni %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|i
operator|,
name|fraglen
operator|,
operator|(
name|int
operator|)
name|bufp
operator|,
name|ni
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fraglen
operator|+
name|readlen
operator|>
name|pktlen
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx bad length current 0x%x pktlen 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|fraglen
operator|+
name|readlen
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|RAY_RCS_FIRST
operator|)
operator|||
operator|(
name|i
operator|>
name|RAY_RCS_LAST
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_rx bad rcs index 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|ebufp
operator|=
name|bufp
operator|+
name|fraglen
expr_stmt|;
if|if
condition|(
name|ebufp
operator|<=
name|RAY_RX_END
condition|)
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
name|fraglen
argument_list|)
expr_stmt|;
else|else
block|{
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
operator|(
name|tmplen
operator|=
name|RAY_RX_END
operator|-
name|bufp
operator|)
argument_list|)
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_RX_BASE
argument_list|,
name|dst
operator|+
name|tmplen
argument_list|,
name|ebufp
operator|-
name|RAY_RX_END
argument_list|)
expr_stmt|;
block|}
name|dst
operator|+=
name|fraglen
expr_stmt|;
name|readlen
operator|+=
name|fraglen
expr_stmt|;
block|}
name|skip_read
label|:
comment|/*      * Walk the chain again to free the rcss.      */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx cleaning rcs fragments "
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"%d "
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
block|}
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx got packet pktlen %d actual %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|pktlen
operator|,
name|readlen
operator|)
argument_list|)
expr_stmt|;
name|RAY_DMBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
literal|"ray_rx"
argument_list|)
expr_stmt|;
comment|/*      * Check the 802.11 packet type and obtain the .11 src address.      *      * XXX CTL and MGT packets will have separate functions,      *     DATA dealt with here      */
name|header
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_header
operator|*
argument_list|)
expr_stmt|;
name|fc
operator|=
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fc
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: header not version 0 fc 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|fc
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|fc
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a .11 MGT packet - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a .11 CTL packet - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx got a .11 DATA packet\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a unknown .11 packet fc0 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|fc
operator|=
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|fc
operator|&
name|IEEE80211_FC1_RCVFROM_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_RCVFROM_TERMINAL
case|:
name|src
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx got packet from station %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|src
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_RCVFROM_AP
case|:
name|src
operator|=
name|header
operator|->
name|i_addr3
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx got packet from ap %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|src
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_RCVFROM_AP2AP
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rx saw packet between aps %6D %6D %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|header
operator|->
name|i_addr1
operator|,
literal|":"
operator|,
name|header
operator|->
name|i_addr2
operator|,
literal|":"
operator|,
name|header
operator|->
name|i_addr3
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx packet type unknown fc1 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * XXX      *       * Currently only support the Webgear encapsulation      *		802.11	header<net/if_ieee80211.h>struct ieee80211_header      *		802.3	header<net/ethernet.h>struct ether_header      * 		802.2	LLC header      *		802.2	SNAP header      *      * We should support whatever packet types the following drivers have      *   	if_wi.c		FreeBSD, RFC1042      *		if_ray.c	NetBSD	Webgear, RFC1042      *		rayctl.c	Linux Webgear, RFC1042      * also whatever we can divine from the NDC Access points and      * Kanda's boxes.      *      * Most appear to have a RFC1042 translation. The incoming packet is      *		802.11	header<net/if_ieee80211.h>struct ieee80211_header      * 		802.2	LLC header      *		802.2	SNAP header      *      * This is translated to      *		802.3	header<net/ethernet.h>struct ether_header      * 		802.2	LLC header      *		802.2	SNAP header      *      * Linux seems to look at the SNAP org_code and do some translations      * for IPX and APPLEARP on that. This just may be how Linux does IPX      * and NETATALK. Need to see how FreeBSD does these.      *      * Translation should be selected via if_media stuff or link types.      */
switch|switch
condition|(
name|sc
operator|->
name|translation
condition|)
block|{
case|case
name|SC_TRANSLATE_WEBGEAR
case|:
comment|/* XXX error checking ? how? */
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
operator|(
name|header
operator|+
literal|1
operator|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx unknown translation type 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|translation
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* Handle BPF listeners. */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBPFILTER */
if|#
directive|if
name|XXX
name|if_wi
operator|.
name|c
operator|-
name|might
name|be
name|needed
if|if we hear our own broadcasts in promiscuous mode 	if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* XXX */
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Download start up structures to card.  *  * Part of ray_init, download, startjoin control flow.  */
specifier|static
name|void
name|ray_download_params
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ray_mib_4
name|ray_mib_4_default
decl_stmt|;
name|struct
name|ray_mib_5
name|ray_mib_5_default
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Downloading startup parameters\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DNET_DUMP
argument_list|(
name|sc
argument_list|,
literal|" before we download them."
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|netbsd
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* XXX */
define|#
directive|define
name|MIB4
parameter_list|(
name|m
parameter_list|)
value|ray_mib_4_default.##m
define|#
directive|define
name|MIB5
parameter_list|(
name|m
parameter_list|)
value|ray_mib_5_default.##m
define|#
directive|define
name|PUT2
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do { (p)[0] = ((v>> 8)& 0xff); (p)[1] = (v& 0xff); } while(0)
comment|/*       * Firmware version 4 defaults - see if_raymib.h for details       */
name|MIB4
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_net_type
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|strncpy
argument_list|(
name|MIB4
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ssid
argument_list|,
name|RAY_MAXSSIDLEN
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB4
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V4
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_max
argument_list|)
operator|=
name|RAY_MIB_CW_MAX_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_min
argument_list|)
operator|=
name|RAY_MIB_CW_MIN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
comment|/*       * Firmware version 5 defaults - see if_raymib.h for details       */
name|MIB5
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_net_type
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|strncpy
argument_list|(
name|MIB5
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ssid
argument_list|,
name|RAY_MAXSSIDLEN
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB5
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_max
argument_list|)
argument_list|,
name|RAY_MIB_CW_MAX_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_min
argument_list|)
argument_list|,
name|RAY_MIB_CW_MIN_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_allow_probe_resp
argument_list|)
operator|=
name|RAY_MIB_ALLOW_PROBE_RESP_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_must_start
argument_list|)
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_can_join
argument_list|)
operator|=
name|sc
operator|->
name|sc_priv_start
expr_stmt|;
name|MIB5
argument_list|(
name|mib_basic_rate_set
index|[
literal|0
index|]
argument_list|)
operator|=
name|sc
operator|->
name|sc_priv_join
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_params something is already happening\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_4_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_4_default
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_5_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_5_default
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX  * NetBSD  * hand expanding ray_simple_cmd  * we dont do any of the clever timeout stuff yet (i.e. ray_cmd_ran) just  * simple check  *  * 	if (!ray_simple_cmd(sc, RAY_CMD_START_PARAMS, SCP_UPD_STARTUP))  * 	    panic("ray_download_params issue");  *  * 	ray_simple_cmd ==  * 	    ray_alloc_ccs(sc,&ccs, cmd, track)&&  * 	    ray_issue_cmd(sc, ccs, track));  *  */
comment|/*      * Get a free command ccs and issue the command - there is nothing      * to fill in for a START_PARAMS command. The start parameters      * command just gets serviced, so we use a timeout to complete the      * sequence.      */
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ccs
argument_list|,
name|RAY_CMD_START_PARAMS
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_params can't get a CCS\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_params can't issue command\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timerh
operator|=
name|timeout
argument_list|(
name|ray_download_timo
argument_list|,
name|sc
argument_list|,
name|RAY_CCS_TIMEOUT
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Download now awaiting timeout\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Download timeout routine.  *  * Part of ray_init, download, start_join control flow.  */
specifier|static
name|void
name|ray_download_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|,
name|cmd
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_download_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: check rayidx %d ccs 0x%x cmd 0x%x stat %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|sc
operator|->
name|sc_ccs
argument_list|)
operator|,
name|sc
operator|->
name|sc_ccs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|!=
name|RAY_CMD_START_PARAMS
operator|)
operator|||
operator|(
name|status
operator|!=
name|RAY_CCS_STATUS_FREE
operator|)
condition|)
name|printf
argument_list|(
literal|"ray%d: Download ccs odd cmd = 0x%02x, status = 0x%02x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/*XXX so what do we do? reset or retry? */
comment|/*XXX this gets triggered when we try and re-reset the ipaddress  	 *    ray_init gets called */
comment|/*      * If the card is still busy, re-schedule ourself      */
if|if
condition|(
name|status
operator|==
name|RAY_CCS_STATUS_BUSY
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_download_timo - still busy, see you soon\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timerh
operator|=
name|timeout
argument_list|(
name|ray_download_timo
argument_list|,
name|sc
argument_list|,
name|RAY_CCS_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the ccs */
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccs
operator|=
name|RAY_CCS_LAST
operator|+
literal|1
expr_stmt|;
if|#
directive|if
name|XXX
name|NetBSD
name|clear
name|IFF_OACTIVE
name|at
name|this
name|point
endif|#
directive|endif
comment|/*      * Grab a ccs and don't bother updating the network parameters.      * Issue the start/join command and we get interrupted back.      */
if|if
condition|(
name|sc
operator|->
name|sc_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
name|cmd
operator|=
name|RAY_CMD_START_NET
expr_stmt|;
else|else
name|cmd
operator|=
name|RAY_CMD_JOIN_NET
expr_stmt|;
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|cmd
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_timo can't get a CCS to start/join net\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_timo can't issue start/join\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|sc
operator|->
name|sj_timerh
operator|=
name|timeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|RAY_CCS_TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Start-join awaiting interrupt/timeout\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Complete start or join command.  *  * Part of ray_init, download, start_join control flow.  */
specifier|static
name|void
name|ray_start_join_done
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|,
name|status
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
block|{
name|u_int8_t
name|o_net_type
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_start_join_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|untimeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
if|#
directive|if
name|XXX_TRACKING
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_TRACKING */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|RAY_CCS_STATUS_FREE
case|:
case|case
name|RAY_CCS_STATUS_BUSY
case|:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done status is FREE/BUSY - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CCS_STATUS_COMPLETE
case|:
break|break;
case|case
name|RAY_CCS_STATUS_FAIL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done status is FAIL - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|XXX
name|restart
name|ray_start_join
name|sequence
name|may
name|need
name|to
name|split
name|download_done
for|for this
endif|#
directive|endif
for|break
empty_stmt|;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done unknown status 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|!=
name|RAY_CCS_STATUS_COMPLETE
condition|)
return|return;
comment|/*      * If the command completed correctly, get a few network parameters      * from the ccs and active the network.      */
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
operator|&
name|sc
operator|->
name|sc_cnet_1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_cmd_net
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust values for buggy build 4 */
if|if
condition|(
name|sc
operator|->
name|sc_def_txrate
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_def_txrate
operator|=
name|RAY_MIB_BASIC_RATE_SET_1500K
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_encrypt
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_encrypt
operator|=
literal|0
expr_stmt|;
comment|/* card is telling us to update the network parameters */
if|if
condition|(
name|sc
operator|->
name|sc_upd_param
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: sj_done card updating parameters - why?\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|o_net_type
operator|=
name|sc
operator|->
name|sc_net_type
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|sc
operator|->
name|sc_cnet_2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_net_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_net_type
operator|!=
name|o_net_type
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: sj_done card changing network type - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|restart
name|ray_start_join
name|sequence
condition|?
name|may
name|need
name|to
name|split
name|download_timo
for|for this panic?
endif|#
directive|endif
block|}
block|}
name|RAY_DNET_DUMP
argument_list|(
name|sc
argument_list|,
literal|" after start/join network completed."
argument_list|)
expr_stmt|;
comment|/*      * Hurrah! The network is now active      */
if|#
directive|if
name|XXX_MCASTPROM
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_MCAST
operator||
name|SCP_UPD_PROMISC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_MCASTPROM */
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
operator|==
name|RAY_CMD_JOIN_NET
condition|)
if|#
directive|if
name|XXX
name|ray_start_assoc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|#
directive|else
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"wanted to join a NET!\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
else|else
block|{
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
comment|/* XXX need to check havenet setting/clearing */
if|#
directive|if
name|XXX
name|ray_start
name|needs
name|OACTIVE
name|clear
name|and
name|more
name|than
name|splimp
name|NetBSD
name|has
name|already
name|cleared
name|OACTIVE
name|need
name|to
name|know
name|interrupt
name|level
name|we
name|enter
name|ray_pccard_intr
name|at
name|ray_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* XXX */
block|}
return|return;
block|}
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
comment|/*  * Back stop catcher for start_join command. The NetBSD driver  * suggests that they need it to catch a bug in the firmware or the  * parameters they use - they are not sure. I'll just panic as I seem  * to get interrupts back fine and I have version 4 firmware.  */
specifier|static
name|void
name|ray_start_join_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_start_join_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ray%d: ray-start_join_timo occured\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
comment|/*  * Obtain a free ccs buffer.  *  * Returns 1 and in `ccsp' the bus offset of the free ccs   * or 0 if none are free  *  * If `track' is not zero, handles tracking this command  * possibly indicating a callback is needed and setting a timeout  * also if ECF isn't ready we terminate earlier to avoid overhead.  *  * This routine is only used for commands  */
specifier|static
name|int
name|ray_alloc_ccs
parameter_list|(
name|sc
parameter_list|,
name|ccsp
parameter_list|,
name|cmd
parameter_list|,
name|track
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
modifier|*
name|ccsp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|track
decl_stmt|;
block|{
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_alloc_ccs for cmd %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
comment|/* for tracked commands, if not ready just set pending */
if|if
condition|(
name|track
operator|&&
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* XXX */
for|for
control|(
name|i
operator|=
name|RAY_CCS_CMD_FIRST
init|;
name|i
operator|<=
name|RAY_CCS_CMD_LAST
condition|;
name|i
operator|++
control|)
block|{
comment|/* probe here to make the card go */
operator|(
name|void
operator|)
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|RAY_CCS_CMD_LAST
condition|)
block|{
if|#
directive|if
name|XXX
if|if
condition|(
name|track
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * Free up a ccs/cmd and return the old status.  * This routine is only used for commands.  */
specifier|static
name|u_int8_t
name|ray_free_ccs
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
block|{
name|u_int8_t
name|stat
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: free_ccs 0x%02x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stat
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccs
operator|<=
name|RAY_CCS_ADDRESS
argument_list|(
name|RAY_CCS_LAST
argument_list|)
condition|)
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
comment|/*  * Issue a command by writing the mailbox and tickling the card.  * Only used for commands not transmitted packets.  */
specifier|static
name|int
name|ray_issue_cmd
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|,
name|track
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|track
decl_stmt|;
block|{
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_cmd_issue, track = 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|track
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * XXX other drivers did this, but I think       * what we really want to do is just make sure we don't      * get here or that spinning is ok      */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
if|if
condition|(
operator|++
name|i
operator|>
literal|50
condition|)
block|{
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_TRACKING
if|if
condition|(
name|track
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_TRACKING */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_TRACKING
name|ray_cmd_ran
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_TRACKING */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|10
specifier|static
name|void
name|ray_dump_mbuf
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|u_int8_t
modifier|*
name|d
decl_stmt|,
modifier|*
name|ed
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
name|p
index|[
literal|17
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"ray%d: %s mbuf dump:"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
literal|17
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|ed
operator|=
name|d
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|ed
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  %s\n\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|%
literal|16
index|]
operator|=
operator|(
operator|(
operator|*
name|d
operator|>=
literal|0x20
operator|)
operator|&&
operator|(
operator|*
name|d
operator|<
literal|0x80
operator|)
operator|)
condition|?
operator|*
name|d
else|:
literal|'.'
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG> 10 */
comment|/*  * Routines to read from/write to the attribute memory.  *  * Taken from if_xe.c.  *  * Until there is a real way of accessing the attribute memory from a driver  * these have to stay.  *  * The hack to use the crdread/crdwrite device functions causes the attribute  * memory to be remapped into the controller and looses the mapping of  * the common memory.  *  * We cheat by using PIOCSMEM and assume that the common memory window  * is in window 0 of the card structure.  *  * Also  *	pccard/pcic.c/crdread does mark the unmapped window as inactive  *	pccard/pccard.c/map_mem toggles the mapping of a window on  *	successive calls  *  */
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
specifier|static
name|void
name|ray_attr_getmap
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: attempting to get map for common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"  ioctl returns 0x%0x\n"
operator|,
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCGMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"  flags 0x%02x, start 0x%p, size 0x%08x, card address 0x%lx\n"
operator|,
name|sc
operator|->
name|md
operator|.
name|flags
operator|,
name|sc
operator|->
name|md
operator|.
name|start
operator|,
name|sc
operator|->
name|md
operator|.
name|size
operator|,
name|sc
operator|->
name|md
operator|.
name|card
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ray_attr_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: attempting to remap common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCSMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
specifier|static
name|int
name|ray_attr_write
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|&
name|byte
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_write
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
return|return
operator|(
name|err
operator|)
return|;
block|}
specifier|static
name|int
name|ray_attr_read
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_read
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
return|return
operator|(
name|err
operator|)
return|;
block|}
specifier|static
name|u_int8_t
name|ray_read_reg
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|off_t
name|reg
decl_stmt|;
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|)
return|;
block|}
if|#
directive|if
name|XXX
comment|/*  * Could be replaced by the following macro  * RAY_ECF_READY(sc)	(!(REG_READ(sc, RAY_ECFIR)& RAY_ECFIR_IRQ))  * where reg_read is a suitable macro to read a byte in the attribute memory.  */
specifier|static
name|int
name|ray_ecf_ready
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|RAY_ECFIR
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|byte
operator|&
name|RAY_ECFIR_IRQ
operator|)
operator|)
return|;
block|}
comment|/*  * Could be replaced by the following macro  * RAY_HCS_INTR(sc)	(REG_READ(sc, RAY_HCSIR)& RAY_HCSIR_IRQ)  * where reg_read is a suitable macro to read a byte in the attribute memory.  */
specifier|static
name|int
name|ray_hcs_intr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|RAY_HCSIR
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|&
name|RAY_HCSIR_IRQ
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRAY */
end_comment

end_unit

