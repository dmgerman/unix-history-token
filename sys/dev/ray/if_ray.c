begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id$  *  */
end_comment

begin_define
define|#
directive|define
name|XXX
value|0
end_define

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_STARTJOIN_TIMEO
end_define

begin_comment
comment|/* Might be needed with build 4 */
end_comment

begin_define
define|#
directive|define
name|RAY_DEBUG
value|100
end_define

begin_comment
comment|/* Big numbers get more verbose */
end_comment

begin_define
define|#
directive|define
name|RAY_CCS_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for CCS commands - only used for downloading startup parameters */
end_comment

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_comment
comment|/*  * Debugging odds and odds  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|RAY_DHEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|do { if (RAY_DEBUG> 10) {		\     u_int8_t *i;						\     for (i = p; i< (u_int8_t *)(p+l); i += 8)			\     	printf("  0x%08lx %8D\n",				\ 		(unsigned long)i, (unsigned char *)i, " ");	\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTF
parameter_list|(
name|x
parameter_list|)
value|do { if (RAY_DEBUG) {			\     printf x ;							\     } } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_HEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_HEX16
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_include
include|#
directive|include
file|"ray.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NRAY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_ieee80211.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_rayreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_raymib.h>
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cis.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD */
end_comment

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM */
end_comment

begin_comment
comment|/*  * One of these structures per allocated device  */
end_comment

begin_struct
struct|struct
name|ray_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common */
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
comment|/* Ifnet common */
name|struct
name|callout_handle
decl|\
name|timerh
decl_stmt|;
comment|/* Handle for timer */
ifdef|#
directive|ifdef
name|RAY_NEED_STARTJOIN_TIMEO
name|struct
name|callout_handle
decl|\
name|sj_timerh
decl_stmt|;
comment|/* Handle for start_join timer */
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMEO */
name|char
modifier|*
name|card_type
decl_stmt|;
comment|/* Card model name */
name|char
modifier|*
name|vendor
decl_stmt|;
comment|/* Card manufacturer */
name|int
name|unit
decl_stmt|;
comment|/* Unit number */
name|u_char
name|gone
decl_stmt|;
comment|/* 1 = Card bailed out */
name|int
name|irq
decl_stmt|;
comment|/* Assigned IRQ */
name|caddr_t
name|maddr
decl_stmt|;
comment|/* Shared RAM Address */
name|int
name|msize
decl_stmt|;
comment|/* Shared RAM Size */
comment|/* XXX these can go when attribute reading is fixed */
name|int
name|slotnum
decl_stmt|;
comment|/* Slot number */
name|struct
name|mem_desc
name|md
decl_stmt|;
comment|/* Map info for common memory */
name|struct
name|ray_ecf_startup_v5
decl|\
name|sc_ecf_startup
decl_stmt|;
comment|/* Startup info from card */
name|u_int8_t
name|sc_ccsinuse
index|[
literal|64
index|]
decl_stmt|;
comment|/* ccs in use -- not for tx */
name|size_t
name|sc_ccs
decl_stmt|;
comment|/* ccs used by non-scheduled,     					 * non-overlapping procedures */
name|u_int8_t
name|sc_bssid
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
comment|/* Current net values */
name|u_int8_t
name|sc_cnwid
index|[
name|IEEE80211_NWID_LEN
index|]
decl_stmt|;
comment|/* Last nwid */
name|u_int8_t
name|sc_dnwid
index|[
name|IEEE80211_NWID_LEN
index|]
decl_stmt|;
comment|/* Desired nwid */
name|u_int8_t
name|sc_omode
decl_stmt|;
comment|/* Old operating mode SC_MODE_xx */
name|u_int8_t
name|sc_mode
decl_stmt|;
comment|/* Current operating mode SC_MODE_xx */
name|u_int8_t
name|sc_countrycode
decl_stmt|;
comment|/* Current country code */
name|u_int8_t
name|sc_dcountrycode
decl_stmt|;
comment|/* Desired country code */
name|int
name|sc_havenet
decl_stmt|;
comment|/* true if we have aquired a network */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ray_softc
name|ray_softc
index|[
name|NRAY
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sc_station_addr
value|sc_ecf_startup.e_station_addr
end_define

begin_define
define|#
directive|define
name|sc_version
value|sc_ecf_startup.e_fw_build_string
end_define

begin_define
define|#
directive|define
name|sc_tibsize
value|sc_ecf_startup.e_tibsize
end_define

begin_comment
comment|/* Modes of operation */
end_comment

begin_comment
comment|/*XXX must these be tied with defaults on the station type? or do they  * decribe the network mode and not the station type? */
end_comment

begin_define
define|#
directive|define
name|SC_MODE_ADHOC
value|0
end_define

begin_comment
comment|/* ad-hoc mode */
end_comment

begin_define
define|#
directive|define
name|SC_MODE_INFRA
value|1
end_define

begin_comment
comment|/* infrastructure mode */
end_comment

begin_comment
comment|/* Commands -- priority given to LSB */
end_comment

begin_define
define|#
directive|define
name|SCP_FIRST
value|0x0001
end_define

begin_define
define|#
directive|define
name|SCP_UPDATESUBCMD
value|0x0001
end_define

begin_define
define|#
directive|define
name|SCP_STARTASSOC
value|0x0002
end_define

begin_define
define|#
directive|define
name|SCP_REPORTPARAMS
value|0x0004
end_define

begin_define
define|#
directive|define
name|SCP_IFSTART
value|0x0008
end_define

begin_comment
comment|/* Update sub commands -- issues are serialized priority to LSB */
end_comment

begin_define
define|#
directive|define
name|SCP_UPD_FIRST
value|0x0100
end_define

begin_define
define|#
directive|define
name|SCP_UPD_STARTUP
value|0x0100
end_define

begin_define
define|#
directive|define
name|SCP_UPD_STARTJOIN
value|0x0200
end_define

begin_define
define|#
directive|define
name|SCP_UPD_PROMISC
value|0x0400
end_define

begin_define
define|#
directive|define
name|SCP_UPD_MCAST
value|0x0800
end_define

begin_define
define|#
directive|define
name|SCP_UPD_UPDATEPARAMS
value|0x1000
end_define

begin_define
define|#
directive|define
name|SCP_UPD_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|SCP_UPD_MASK
value|0xff00
end_define

begin_comment
comment|/* These command (a subset of the update set) require timeout checking */
end_comment

begin_define
define|#
directive|define
name|SCP_TIMOCHECK_CMD_MASK
define|\
value|(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \ 	SCP_UPD_PROMISC)
end_define

begin_comment
comment|/*  * PCMCIA driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_init
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_pccard_unload
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|ray
argument_list|,
name|ray_pccard_init
argument_list|,
name|ray_pccard_unload
argument_list|,
name|ray_pccard_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ISA driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|raydriver
init|=
block|{
name|ray_probe
block|,
name|ray_attach
block|,
literal|"ray"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Network driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ray_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_init
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_stop
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal utilites  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_alloc_ccs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
operator|*
name|ccsp
operator|,
name|u_int
name|cmd
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_ccs_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_free_ccs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_issue_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rcs_intr
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_join_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Indirections for reading/writing shared memory - from NetBSD/if_ray.c  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((size_t)(&((type *)0)->member))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* offsetof */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|(u_int8_t)*((sc)->maddr + (off))
end_define

begin_comment
comment|/* ((u_int8_t)bus_space_read_1((sc)->sc_memt, (sc)->sc_memh, (off))) */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|SRAM_READ_1(sc, (off) + offsetof(struct s, f))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|((((u_int16_t)SRAM_READ_1(sc, (off) + offsetof(struct s, f))<< 8) \     |(SRAM_READ_1(sc, (off) + 1 + offsetof(struct s, f)))))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_read_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_read_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((sc)->maddr + (off), (vp), (n))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|*((sc)->maddr + (off)) = (val)
end_define

begin_comment
comment|/* bus_space_write_1((sc)->sc_memt, (sc)->sc_memh, (off), (val)) */
end_comment

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
define|\
value|SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (v))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
value|do {	\     SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (((v)>> 8 )& 0xff)); \     SRAM_WRITE_1(sc, (off) + 1 + offsetof(struct s, f), ((v)& 0xff)); \ } while (0)
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_write_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_write_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((vp), (sc)->maddr + (off), (n))
end_define

begin_comment
comment|/*  * Macro's  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_CCS_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_CCS_TIMEOUT
value|(hz / 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAY_ECF_READY
parameter_list|(
name|sc
parameter_list|)
value|ray_ecf_ready((sc))
end_define

begin_define
define|#
directive|define
name|RAY_ECF_START_CMD
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_ECFIR, RAY_ECFIR_IRQ)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_CLEAR_INTR
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_HCSIR, 0)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_INTR
parameter_list|(
name|sc
parameter_list|)
value|ray_hcs_intr((sc))
end_define

begin_comment
comment|/*  * XXX  * As described in if_xe.c...  *  * Horrid stuff for accessing CIS tuples and remapping common memory...  * XXX  */
end_comment

begin_define
define|#
directive|define
name|CARD_MAJOR
value|50
end_define

begin_decl_stmt
specifier|static
name|void
name|ray_attr_getmap
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_attr_cm
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attr_write
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
name|byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attr_read
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
operator|*
name|buf
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ecf_ready
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_cm(sc)
end_define

begin_comment
comment|/*  * PCCard initialise.  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_init
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|irq
decl_stmt|;
name|int
name|j
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: PCCard probe\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NRAY
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|slotnum
operator|=
name|dev_p
operator|->
name|slt
operator|->
name|slotnum
expr_stmt|;
comment|/* Get IRQ - encoded as a bitmask. */
name|irq
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_irq
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|irq
operator|&
literal|0x1
condition|)
break|break;
name|irq
operator|>>=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|irq
operator|=
name|j
expr_stmt|;
name|sc
operator|->
name|maddr
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|msize
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d:<Raylink/IEEE 802.11> maddr 0x%lx msize 0x%x irq %d on isa (PC-Card slot %d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sc
operator|->
name|maddr
argument_list|,
name|sc
operator|->
name|msize
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
expr_stmt|;
name|ray_attr_getmap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX remove when attribute/common mapping fixed */
if|if
condition|(
name|ray_attach
argument_list|(
operator|&
name|dev_p
operator|->
name|isahd
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCCard unload.  */
end_comment

begin_function
specifier|static
name|void
name|ray_pccard_unload
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: PCCard unload\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: already unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Cleardown interface */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX probably should be if_detach but I don't know if it works in 3.1 */
comment|/* Mark card as gone */
name|sc
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * PCCard interrupt.  */
end_comment

begin_comment
comment|/* XXX return 1 if we take interrupt, 0 otherwise */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_intr
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ccsi
decl_stmt|,
name|handled
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: PCCard intr\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before interrupt!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Check that the interrupt was for us, if so get the rcs/ccs and vector      * on the command contained within it.      */
if|if
condition|(
operator|!
name|RAY_HCS_INTR
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|handled
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|handled
operator|=
literal|1
expr_stmt|;
name|ccsi
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_RCSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccsi
operator|<=
name|RAY_CCS_LAST
condition|)
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|ccsi
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ccsi
operator|<=
name|RAY_RCS_LAST
condition|)
name|ray_rcs_intr
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|ccsi
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ray%d: ray_intr bad ccs index %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ccsi
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|ccs_done
name|and
name|rcs_intr
return|return
name|function
name|pointers
operator|-
name|why
name|dont
name|they
name|just
do|do
name|it
name|themselves
condition|?
name|its
name|not
name|as
if|if each command only 	requires a single function call - things like start_join_net 	call a couple on the way... 	if
condition|(
name|rcmd
condition|)
call|(
modifier|*
name|rcmd
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|}
if|if
condition|(
name|handled
condition|)
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: interrupt %s handled\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|handled
condition|?
literal|"was"
else|:
literal|"not"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|handled
operator|)
return|;
block|}
comment|/*  * ISA probe routine.  */
specifier|static
name|int
name|ray_probe
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ISA probe\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * ISA/PCCard attach.  */
specifier|static
name|int
name|ray_attach
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ISA/PCCard attach\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|id_unit
index|]
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before attach!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Read startup results, check the card is okay and work out what      * version we are using.      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
literal|"\020"
comment|/* print in hex */
literal|"\001RESERVED0"
literal|"\002PROC_SELF_TEST"
literal|"\003PROG_MEM_CHECKSUM"
literal|"\004DATA_MEM_TEST"
literal|"\005RX_CALIBRATION"
literal|"\006FW_VERSION_COMPAT"
literal|"\007RERSERVED1"
literal|"\008TEST_COMPLETE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unsupported firmware version 0x%0x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
operator|||
name|RAY_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Start Up Results\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAY_DEBUG
operator|>
literal|10
condition|)
name|RAY_DHEX8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_ECF_TO_HOST_BASE
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|printf
argument_list|(
literal|"  Firmware version 4\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  Firmware version 5\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Status 0x%x\n"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Ether address %6D\n"
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_rates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Supported rates %8D\n"
argument_list|,
name|ep
operator|->
name|e_rates
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  Japan call sign %12D\n"
argument_list|,
name|ep
operator|->
name|e_japan_callsign
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_prg_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_cis_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware version %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware revision %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_resv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ASIC version %0x\n"
argument_list|,
name|ep
operator|->
name|e_asic_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  TIB size %0x\n"
argument_list|,
name|ep
operator|->
name|e_tibsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Set the parameters that will survive stop/init      */
if|#
directive|if
name|XXX
name|NetBSD
name|bzero
argument_list|(
name|sc
operator|->
name|sc_cnwid
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cnwid
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_dnwid
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_dnwid
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_dnwid
argument_list|,
name|RAY_DEF_NWID
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_dnwid
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_cnwid
argument_list|,
name|RAY_DEF_NWID
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_dnwid
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_omode
operator|=
name|sc
operator|->
name|sc_mode
operator|=
name|RAY_MODE_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_countrycode
operator|=
name|sc
operator|->
name|sc_dcountrycode
operator|=
name|RAY_PID_COUNTRY_CODE_DEFAULT
expr_stmt|;
endif|#
directive|endif
comment|/*      * Initialise the network interface structure      */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|e_station_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ray"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator|)
expr_stmt|;
comment|/* XXX - IFF_MULTICAST */
if|#
directive|if
name|XXX
name|ifp
operator|->
name|if_hdr
operator|=
operator|...
expr_stmt|;
name|make
name|this
name|big
name|enough
name|to
name|hold
name|the
literal|.11
name|and
literal|.3
name|headers
endif|#
directive|endif
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000
expr_stmt|;
comment|/* XXX Is this baud or bps ;-) */
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ray_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ray_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ray_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ray_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
comment|/*      * If this logical interface has already been attached,      * don't attach it again or chaos will ensue.      */
name|sprintf
argument_list|(
name|ifname
argument_list|,
literal|"ray%d"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifunit
argument_list|(
name|ifname
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|timerh
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RAY_NEED_STARTJOIN_TIMEO
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMEO */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBFFILTER */
if|#
directive|if
name|XXX
name|this
name|looks
name|like
name|a
name|good
name|idea
name|at_shutdown
argument_list|(
name|ray_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* XXX */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Network start.  *  * Start output on interface.  We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
specifier|static
name|void
name|ray_start
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network start\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before start!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX mark output queue full so the kernel waits */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* XXX if_xe code is clean but if_ed does more checks at top */
return|return;
block|}
comment|/*  * Network ioctl request.  */
specifier|static
name|int
name|ray_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network ioctl\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before ioctl!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl SIFADDR/GIFADDR/SIFMTU\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: for SIFFLAGS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * If the interface is marked up and stopped, then start 	     * it. If it is marked down and running, then stop it. 	     */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* DROP THROUGH */
if|#
directive|if
name|XXX
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for ADDMULTI/DELMULTI\n, sc->unit"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * Multicast list has (maybe) changed; set the hardware filter 	     * accordingly. This also serves to deal with promiscuous mode 	     * if we have a BPF listener active. 	     */
name|ray_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFFLAGS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMETRIC
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFMETRIC\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFMTU\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFPHYS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFPYHS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for SIFMEDIA\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ioctl called for GIFMEDIA\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* XXX This is here to avoid spl's */
if|if
condition|(
name|command
operator|==
name|SIOCGIFMEDIA
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: RAY_SCB\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_DHEX8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_SCB_BASE
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: RAY_STATUS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_DHEX8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_STATUS_BASE
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: RAY_ECF_TO_HOST\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_DHEX8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_ECF_TO_HOST_BASE
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: RAY_HOST_TO_ECF\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_DHEX8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_HOST_TO_ECF_BASE
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network watchdog\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before watchdog!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ray%d: watchdog timeout\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX may need to have remedial action here    for example    	ray_reset - may be useful elsewhere 		ray_stop 		... 		ray_init */
return|return;
block|}
comment|/*  * Network initialisation.  */
specifier|static
name|void
name|ray_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network init\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before init!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|XXX
name|NetBSD
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/*      * Reset instance variables      */
if|#
directive|if
name|XXX
name|NetBSD
name|sc
operator|->
name|sc_havenet
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_bssid
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_deftxrate
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_encrypt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_promisc
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_scheduled
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_running
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|=
name|RAY_CCS_NTX
expr_stmt|;
name|sc
operator|->
name|sc_checkcounters
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set all ccs to be free */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccs
operator|=
name|RAY_CCS_LAST
operator|+
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_CCS_LAST
condition|;
name|ccs
operator|+=
name|RAY_CCS_SIZE
operator|,
name|i
operator|++
control|)
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Get startup results - the card may have been reset      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
literal|"\020"
comment|/* print in hex */
literal|"\001RESERVED0"
literal|"\002PROC_SELF_TEST"
literal|"\003PROG_MEM_CHECKSUM"
literal|"\004DATA_MEM_TEST"
literal|"\005RX_CALIBRATION"
literal|"\006FW_VERSION_COMPAT"
literal|"\007RERSERVED1"
literal|"\008TEST_COMPLETE"
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
return|return;
comment|/* XXX This doesn't mark the interface as down */
endif|#
directive|endif
comment|/* XXX */
block|}
comment|/*      * Fixup tib size to be correct - on build 4 it is garbage      */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_tibsize
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_tibsize
operator|=
literal|32
expr_stmt|;
comment|/*      * We are now up and running. Next we have to download network      * configuration into the card. We are busy until download is done.      */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
expr_stmt|;
if|#
directive|if
name|XXX
comment|/* set this now so it gets set in the download */
name|sc
operator|->
name|sc_promisc
operator|=
operator|!
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
name|ray_download_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|need
name|to
name|understand
name|how
name|the
name|doenload
name|finishes
name|first
name|Start
name|up
name|flow
name|is
name|as
name|follows
operator|.
name|The
name|kernel
name|calls
name|ray_init
name|when
name|the
name|interface
name|is
name|assigned
name|an
name|address
operator|.
name|ray_init
name|does
name|a
name|bit
name|of
name|house
name|keeping
name|before
name|calling
name|ray_download_params
operator|.
name|ray_download_params
name|fills
name|the
name|startup
name|parameter
name|structure
name|out
name|and
name|sends
name|it
name|to
name|the
name|card
operator|.
name|The
name|download
name|command
name|simply
name|completes
name|so
name|we
name|use
name|schedule
name|a
name|timeout
name|function
name|call
name|to
name|ray_download_timo
operator|.
name|We
name|pass
name|the
name|ccs
name|in
name|use
name|via
name|sc
operator|->
name|sc_css
operator|.
name|ray_download_timo
name|checks
name|the
name|ccs
for|for command completion/errors. 	Then it tells the card to start an adhoc or join a managed 	network. This should complete via the interrupt mechanism
operator|,
name|but
name|the
name|NetBSD
name|driver
name|includes
name|a
name|timeout
for|for some buggy stuff somewhere. 	I've left the hooks in but don't use them. The interrupt handler 	passes control to ray_start_join_done
control|(
name|again
name|the
name|ccs
name|is
name|in
name|sc
operator|->
name|sc_css
name|XXX
name|need
name|to
name|see
if|if this is actually needed
control|)
operator|.
name|XXX
comment|/*      * Set running and clear output active, then attempt to start output      */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* XXX spl's needed higher up? but this is called by ioctl only?*/
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/*  * Network stop.  */
specifier|static
name|void
name|ray_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Network stop\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before stop!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* XXX stuff here please to kill activity on the card and drain down transmissons */
comment|/* Mark as not running */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return;
block|}
comment|/*  * Process CCS command completion - called from ray_intr  */
specifier|static
name|void
name|ray_ccs_done
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Processing ccs %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ccs idx %d ccs 0x%x cmd 0x%x stat %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|,
name|ccs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX should we panic on unrecognised commands or just ignore them?      * maybe I'll macroize the printf's */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_CMD_START_PARAMS
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got START_PARAMS - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_REPORT_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got REPORT_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_MCAST
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_MCAST\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_APM
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_APM\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_NET
case|:
case|case
name|RAY_CMD_JOIN_NET
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got START|JOIN_NET\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RAY_NEED_STARTJOIN_TIMEO
name|untimeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMEO */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_ASSOC
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got START_ASSOC\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TX_REQ
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_ccs_done got TX_REQ\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TEST_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got TEST_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_SHUTDOWN
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got SHUTDOWN - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_DUMP_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got DUMP_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_TIMER
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got START_TIMER - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Process ECF command request - called from ray_intr  */
specifier|static
name|void
name|ray_rcs_intr
parameter_list|(
name|sc
parameter_list|,
name|rcs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|rcs
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Processing rcs %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: rcs idx %d rcs 0x%x cmd 0x%x stat %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
operator|,
name|rcs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX should we panic on unrecognised commands or just ignore them?      * maybe I'll macroize the printf's */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_ECMD_RX_DONE
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr got RX_DONE\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_REJOIN_DONE
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rcs_intr got UPDATE_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_ROAM_START
case|:
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_rcs_intr got ROAM_START\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_JAPAN_CALL_SIGNAL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr got JAPAN_CALL_SIGNAL - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Download start up structures to card.  *  * Part of ray_init, download, startjoin control flow.  */
specifier|static
name|void
name|ray_download_params
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ray_mib_4
name|ray_mib_4_default
decl_stmt|;
name|struct
name|ray_mib_5
name|ray_mib_5_default
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Downloading startup parameters\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|netbsd
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* XXX */
define|#
directive|define
name|MIB4
parameter_list|(
name|m
parameter_list|)
value|ray_mib_4_default.##m
define|#
directive|define
name|MIB5
parameter_list|(
name|m
parameter_list|)
value|ray_mib_5_default.##m
define|#
directive|define
name|PUT2
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do { (p)[0] = ((v>> 8)& 0xff); (p)[1] = (v& 0xff); } while(0)
comment|/*       * Firmware version 4 defaults - see if_raymib.h for details       */
name|MIB4
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|RAY_MIB_NET_TYPE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|strncpy
argument_list|(
name|MIB4
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|RAY_MIB_SSID_DEFAULT
argument_list|,
name|RAY_MAXSSIDLEN
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB4
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V4
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_max
argument_list|)
operator|=
name|RAY_MIB_CW_MAX_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_min
argument_list|)
operator|=
name|RAY_MIB_CW_MIN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
comment|/*       * Firmware version 5 defaults - see if_raymib.h for details       */
name|MIB5
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|RAY_MIB_NET_TYPE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|strncpy
argument_list|(
name|MIB5
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|RAY_MIB_SSID_DEFAULT
argument_list|,
name|RAY_MAXSSIDLEN
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB5
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_max
argument_list|)
argument_list|,
name|RAY_MIB_CW_MAX_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_min
argument_list|)
argument_list|,
name|RAY_MIB_CW_MIN_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_allow_probe_resp
argument_list|)
operator|=
name|RAY_MIB_ALLOW_PROBE_RESP_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_must_start
argument_list|)
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_can_join
argument_list|)
operator|=
name|RAY_MIB_PRIVACY_CAN_JOIN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_basic_rate_set
index|[
literal|0
index|]
argument_list|)
operator|=
name|RAY_MIB_BASIC_RATE_SET_DEFAULT
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_params something is already happening\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_4_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_4_default
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_5_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_5_default
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  * NetBSD  * hand expanding ray_simple_cmd  * we dont do any of the clever timeout stuff yet (i.e. ray_cmd_ran) just  * simple check  *  * 	if (!ray_simple_cmd(sc, RAY_CMD_START_PARAMS, SCP_UPD_STARTUP))  * 	    panic("ray_download_params issue");  *  * 	ray_simple_cmd ==  * 	    ray_alloc_ccs(sc,&ccs, cmd, track)&&  * 	    ray_issue_cmd(sc, ccs, track));  *  */
comment|/*      * Get a free command ccs and issue the command - there is nothing      * to fill in for a START_PARAMS command. The start parameters      * command just gets serviced, so we use a timeout to complete the      * sequence.      */
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ccs
argument_list|,
name|RAY_CMD_START_PARAMS
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_params can't get a CCS\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_params can't issue command\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timerh
operator|=
name|timeout
argument_list|(
name|ray_download_timo
argument_list|,
name|sc
argument_list|,
name|RAY_CCS_TIMEOUT
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Download now awaiting timeout\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Download timeout routine.  *  * Part of ray_init, download, start_join control flow.  */
specifier|static
name|void
name|ray_download_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|,
name|cmd
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_download_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: check rayidx %d ccs 0x%x cmd 0x%x stat %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|sc
operator|->
name|sc_ccs
argument_list|)
operator|,
name|sc
operator|->
name|sc_ccs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|!=
name|RAY_CMD_START_PARAMS
operator|)
operator|||
operator|(
name|status
operator|!=
name|RAY_CCS_STATUS_FREE
operator|)
condition|)
name|printf
argument_list|(
literal|"ray%d: Download ccs odd cmd = 0x%02x, status = 0x%02x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/*XXX so what do we do? reset or retry? */
comment|/*      * If the card is still busy, re-schedule ourself      */
if|if
condition|(
name|status
operator|==
name|RAY_CCS_STATUS_BUSY
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_download_timo - still busy, see you soon\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timerh
operator|=
name|timeout
argument_list|(
name|ray_download_timo
argument_list|,
name|sc
argument_list|,
name|RAY_CCS_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the ccs */
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccs
operator|=
name|RAY_CCS_LAST
operator|+
literal|1
expr_stmt|;
comment|/*      * Grab a ccs and don't bother updating the network parameters.      * Issue the start/join command and we get interrupted back.      */
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|SC_MODE_ADHOC
condition|)
name|cmd
operator|=
name|RAY_CMD_START_NET
expr_stmt|;
else|else
name|cmd
operator|=
name|RAY_CMD_JOIN_NET
expr_stmt|;
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ccs
argument_list|,
name|cmd
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_timo can't get a CCS to start/join net\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ray%d: ray_download_timo can't issue start/join\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RAY_NEED_STARTJOIN_TIMEO
name|sc
operator|->
name|sj_timerh
operator|=
name|timeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|RAY_CCS_TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMEO */
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: Start-join awaiting interrupt/timeout\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|RAY_NEED_STARTJOIN_TIMEO
comment|/*  * Back stop catcher for start_join command. The NetBSD driver  * suggests that they need it to catch a bug in the firmware or the  * parameters they use - they are not sure. I'll just panic as I seem  * to get interrupts back fine and I have version 4 firmware.  */
specifier|static
name|void
name|ray_start_join_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_start_join_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ray%d: ray-start_join_timo occured\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMEO */
comment|/*  * Obtain a free ccs buffer.  *  * Returns 1 and in `ccsp' the bus offset of the free ccs   * or 0 if none are free  *  * If `track' is not zero, handles tracking this command  * possibly indicating a callback is needed and setting a timeout  * also if ECF isn't ready we terminate earlier to avoid overhead.  *  * This routine is only used for commands  */
specifier|static
name|int
name|ray_alloc_ccs
parameter_list|(
name|sc
parameter_list|,
name|ccsp
parameter_list|,
name|cmd
parameter_list|,
name|track
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
modifier|*
name|ccsp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|track
decl_stmt|;
block|{
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_alloc_ccs for cmd %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
comment|/* for tracked commands, if not ready just set pending */
if|if
condition|(
name|track
operator|&&
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* XXX */
for|for
control|(
name|i
operator|=
name|RAY_CCS_CMD_FIRST
init|;
name|i
operator|<=
name|RAY_CCS_CMD_LAST
condition|;
name|i
operator|++
control|)
block|{
comment|/* probe here to make the card go */
operator|(
name|void
operator|)
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|RAY_CCS_CMD_LAST
condition|)
block|{
if|#
directive|if
name|XXX
if|if
condition|(
name|track
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * Free up a ccs/cmd and return the old status.  * This routine is only used for commands.  */
specifier|static
name|u_int8_t
name|ray_free_ccs
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
block|{
name|u_int8_t
name|stat
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: free_ccs 0x%02x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stat
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccs
operator|<=
name|RAY_CCS_ADDRESS
argument_list|(
name|RAY_CCS_LAST
argument_list|)
condition|)
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
comment|/*  * Issue a command by writing the mailbox and tickling the card.  * Only used for commands not transmitted packets.  */
specifier|static
name|int
name|ray_issue_cmd
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|,
name|track
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|track
decl_stmt|;
block|{
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: ray_cmd_issue, track = 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|track
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * XXX other drivers did this, but I think       * what we really want to do is just make sure we don't      * get here or that spinning is ok      */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
if|if
condition|(
operator|++
name|i
operator|>
literal|50
condition|)
block|{
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
if|if
condition|(
name|track
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|ray_cmd_ran
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * Two routines to read from/write to the attribute memory.  *  * Taken from if_xe.c.  *  * Until there is a real way of accessing the attribute memory from a driver  * these have to stay.  *  * The hack to use the crdread/crdwrite device functions causes the attribute  * memory to be remapped into the controller and looses the mapping of  * the common memory.  *  * We cheat by using PIOCSMEM and assume that the common memory window  * is in window 0 of the card structure.  *  * Also  *	pccard/pcic.c/crdread does mark the unmapped window as inactive  *	pccard/pccard.c/map_mem toggles the mapping of a window on  *	successive calls  *  */
specifier|static
name|void
name|ray_attr_getmap
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: attempting to get map for common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"  ioctl returns 0x%0x\n"
operator|,
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCGMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"  flags 0x%02x, start 0x%p, size 0x%08x, card address 0x%lx\n"
operator|,
name|sc
operator|->
name|md
operator|.
name|flags
operator|,
name|sc
operator|->
name|md
operator|.
name|start
operator|,
name|sc
operator|->
name|md
operator|.
name|size
operator|,
name|sc
operator|->
name|md
operator|.
name|card
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ray_attr_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
operator|(
literal|"ray%d: attempting to remap common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCSMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|int
name|ray_attr_write
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|&
name|byte
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_write
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
specifier|static
name|int
name|ray_attr_read
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_read
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
specifier|static
name|u_int8_t
name|ray_read_reg
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
decl|struct
name|ray_softc
modifier|*
name|sc
name|off_t
name|off
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|)
return|;
block|}
if|#
directive|if
name|XXX
comment|/*  * Could be replaced by the following macro  * RAY_ECF_READY(sc)	(!(REG_READ(sc, RAY_ECFIR)& RAY_ECFIR_IRQ))  * where reg_read is a suitable macro to read a byte in the attribute memory.  */
specifier|static
name|int
name|ray_ecf_ready
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|RAY_ECFIR
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|byte
operator|&
name|RAY_ECFIR_IRQ
operator|)
operator|)
return|;
block|}
comment|/*  * Could be replaced by the following macro  * RAY_HCS_INTR(sc)	(REG_READ(sc, RAY_HCSIR)& RAY_HCSIR_IRQ)  * where reg_read is a suitable macro to read a byte in the attribute memory.  */
specifier|static
name|int
name|ray_hcs_intr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|RAY_HCSIR
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|&
name|RAY_HCSIR_IRQ
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRAY */
end_comment

end_unit

