begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: if_ray.c,v 1.29 2000/05/11 18:55:38 dmlb Exp $  *  */
end_comment

begin_comment
comment|/*	$NetBSD: if_ray.c,v 1.12 2000/02/07 09:36:27 augustss Exp $	*/
end_comment

begin_comment
comment|/*   * Copyright (c) 2000 Christian E. Hopps  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  * Card configuration  * ==================  *  * This card is unusual in that it uses both common and attribute  * memory whilst working. The -stable versions of FreeBSD have a real  * problem managing and setting up the correct memory maps. This  * driver should reset the memory maps correctly under PAO and non-PAO  * -stable systems. Work is in hand to fix these problems for -current.  *  * The first fixes the brain deadness of pccardd (where it reads the  * CIS for common memory, sets it all up and then throws it all away  * assuming the card is an ed driver...). Note that this could be  * dangerous (because it doesn't interact with pccardd) if you  * use other memory mapped cards at the same time.  *  * The second option ensures that common memory is remapped whenever  * we are going to access it (we can't just do it once, as something  * like pccardd may have read the attribute memory and pccard.c  * doesn't re-map the last active window - it remaps the last  * non-active window...).  *  *  * Ad-hoc and infra-structure modes  * ================================  *   * At present only the ad-hoc mode is being worked on.  *  * Apart from just writing the code for infrastructure mode I have a  * few concerns about both the Linux and NetBSD drivers in this area.  * They don't seem to differentiate between the MAC address of the AP  * and the BSS_ID of the network. I presume this is handled when  * joining a managed n/w and the network parameters are updated, but  * I'm not sure. How does this interact with ARP? For mobility we want  * to be able to move around without worrying about which AP we are  * actually talking to - we should always talk to the BSS_ID.  *  * The Linux driver also seems to have the capability to act as an AP.  * I wonder what facilities the "AP" can provide within a driver? We can  * probably use the BRIDGE code to form an ESS but I don't think  * power saving etc. is easy.  *  *  * Packet framing/encapsulation  * ================================  *   * Currently we only support the Webgear encapsulation  *	802.11	header<net/if_ieee80211.h>struct ieee80211_header  *	802.3	header<net/ethernet.h>struct ether_header  *	802.2	LLC header  *	802.2	SNAP header  *  * We should support whatever packet types the following drivers have  *   	if_wi.c		FreeBSD, RFC1042  *	if_ray.c	NetBSD	Webgear, RFC1042  *	rayctl.c	Linux Webgear, RFC1042  * also whatever we can divine from the NDC Access points and Kanda's boxes.  *  * Most drivers appear to have a RFC1042 framing. The incoming packet is  *	802.11	header<net/if_ieee80211.h>struct ieee80211_header  *	802.2	LLC header  *	802.2	SNAP header  *  * This is translated to  *	802.3	header<net/ethernet.h>struct ether_header  *	802.2	LLC header  *	802.2	SNAP header  *  * Linux seems to look at the SNAP org_code and do some framings  * for IPX and APPLEARP on that. This just may be how Linux does IPX  * and NETATALK. Need to see how FreeBSD does these.  *  * Translation should be selected via if_media stuff or link types.  *  *  * Authentication  * ==============  *  * 802.11 provides two authentication mechanisms. The first is a very  * simple host based mechanism (like xhost) called Open System and the  * second is a more complex challenge/response called Shared Key built  * ontop of WEP.  *  * This driver only supports Open System and does not implement any  * host based control lists. In otherwords authentication is always  * granted to hosts wanting to authenticate with this station. This is  * the only sensible behaviour as the Open System mechanism uses MAC  * addresses to identify hosts. Send me patches if you need it!  */
end_comment

begin_comment
comment|/*  * TODO  *  * _stop - mostly done  *	would be nice to understand shutdown/or power save to prevent RX  * _reset - done  * 	just needs calling in the right places  *	converted panics to resets - when tx packets are the wrong length  *	may be needed in a couple of other places when I do more commands  * havenet - mostly done  *	i think i've got all the places to set it right, but not so sure  *	we reset it in all the right places  * _unload - done  *	recreated most of stop but as card is unplugged don't try and  *	access it to turn it off  * TX bpf - done  * RX bpf - done  *	I would much prefer to have the complete 802.11 packet dropped to  *	the bpf tap and then have a user land program parse the headers  *	as needed. This way, tcpdump -w can be used to grab the raw data. If  *	needed the 802.11 aware program can "translate" the .11 to ethernet  *	for tcpdump -r  * use std timeout code for download - done  *	was mainly moving a call and removing a load of stuff in  *	download_done as it duplicates check_ccs and ccs_done  * promisoius - done  * add the start_join_net - done  *	i needed it anyway  * remove startccs and startcmd - done  *	as those were used for the NetBSD start timeout  * multicast - done but UNTESTED  *	I don't have the ability/facilty to test this  * rxlevel - done  *	stats reported via raycontrol  * getparams ioctl - done  *	reported via raycontrol  * start_join_done needs a restart in download_done - done  *	now use netbsd style start up  * ioctls - done  *	use raycontrol  *	translation, BSS_ID, countrycode, changing mode  * ifp->if_hdr length - done  * rx level and antenna cache - done  *	antenna not used yet  * antenna tx side - done  *	not tested!  * shutdown - done  *	the driver seems to do the right thing for plugging and unplugging  *	cards  * apm/resume - ignore  *	apm+pccard is borken for 3.x - no one knows how to do it anymore  * fix the XXX code in start_join_done - n/a  *	i've removed this as the error handling should be consistent for  *	all ECF commands and none of the other commands bother!  * ray_update_params_done needs work - done  *	as part of scheduler/promisc re-write  * raycontrol to be firmware version aware - done  *	also report and update parameters IOCTLs are version aware  * make RAY_DPRINTFN RAY_DPRINTF - done  * make all printfs RAY_PRINTF - done  * faster TX routine - done  *	see comments but OACTIVE is gone  * __P to die - done  *	the rest is ansi anyway  * macroize the attribute read/write and 3.x driver - done  *	like the SRAM macros?  * rename "translation" to framing for consitency with Webgear - done  * severe breakage with CCS allocation - done  *	ccs are now allocated in a sleepable context with error recovery  * resource allocation should be be in attach and not probe - done  * resources allocated in probe hould be released before probe exits - done  * softc and ifp in variable definition block - done  * callout handles need rationalising. can probably remove sj_timerh - done  * why can't download use sc_promisc? - done  *	still use the specific update in _init to ensure that the state is  *	right until promisc is moved into current/desired parameters  *  * ***detach needs to drain comq  * ***stop/detach checks in more routines  * ***reset in ray_init_user?  * ***IFF_RUNNING checks are they really needed?  *	this whole area is circumspect as RUNNING is reflection of the  *	driver state and is subject to waits etc.  *	- need to return EIO from runq routines that check  *	- now understood and I have to get the runq routines to  *	  check as required  *		init sequence is done  *		stop sequence is done  *		other not done  * ***PCATCH tsleeps and have something that will clean the runq  * ***priorities for each tsleep   * ***watchdog to catch screwed up removals?  * ***check and rationalise CM mappings  * use /sys/net/if_ieee80211.h and update it  * macro for gone and check is at head of all externally called routines  * probably function/macro to test unload at top of commands  * for ALLMULTI must go into PROMISC and filter unicast packets  * mcast code resurrection  * UPDATE_PARAMS seems to return via an interrupt - maybe the timeout  *	is needed for wrong values?  *	remember it must be serialised as it uses the HCF-ECF area  * check all RECERRs and make sure that some are RAY_PRINTF not RAY_DPRINTF  * havenet needs checking again  * error handling of ECF command completions  * proper setting of mib_hop_seq_len with country code for v4 firmware  * _reset - check where needed  * splimp or splnet?  * tidy #includes - we cant need all of these  * differeniate between parameters set in attach and init  * more translations  * spinning in ray_com_ecf  * make RAY_DEBUG a knob somehow - either sysctl or IFF_DEBUG  * fragmentation when rx level drops?  *  * infra mode stuff  * 	proper handling of the basic rate set - see the manual  *	all ray_sj, ray_assoc sequencues need a "nicer" solution as we  *		remember association and authentication  *	need to consider WEP  * acting as ap - should be able to get working from the manual  *  * ray_nw_param  *	promisc in here too? will need work in download_done and init  * 	sc_station_addr in here too (for changing mac address)  * 	move desired into the command structure?  *	take downloaded MIB from a complete nw_param?  */
end_comment

begin_define
define|#
directive|define
name|XXX
value|0
end_define

begin_define
define|#
directive|define
name|XXX_ASSOC
value|0
end_define

begin_define
define|#
directive|define
name|XXX_ACTING_AP
value|0
end_define

begin_define
define|#
directive|define
name|XXX_INFRA
value|0
end_define

begin_define
define|#
directive|define
name|XXX_MCAST
value|0
end_define

begin_define
define|#
directive|define
name|XXX_RESET
value|0
end_define

begin_define
define|#
directive|define
name|XXX_IFQ_PEEK
value|0
end_define

begin_define
define|#
directive|define
name|XXX_IOCTLLOCK
value|0
end_define

begin_define
define|#
directive|define
name|RAY_DEBUG
value|(				\  			   RAY_DBG_RECERR	|    	\
comment|/* RAY_DBG_SUBR		| */
value|\
comment|/* RAY_DBG_BOOTPARAM	| */
value|\ 			   RAY_DBG_STARTJOIN	|   	\
comment|/* RAY_DBG_CCS		| */
value|\                            RAY_DBG_IOCTL	|   	\
comment|/* RAY_DBG_MBUF		| */
value|\
comment|/* RAY_DBG_RX		| */
value|\
comment|/* RAY_DBG_CM		| */
value|\                            RAY_DBG_COM		|    	\                            RAY_DBG_STOP		|   	\
comment|/* RAY_DBG_CTL		| */
value|\
comment|/* RAY_DBG_MGT		| */
value|\
comment|/* RAY_DBG_TX		| */
value|\ 			0				\ 			)
end_define

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_CM_REMAPPING
value|1
end_define

begin_comment
comment|/* Needed until pccard maps more than one memory area */
end_comment

begin_define
define|#
directive|define
name|RAY_COM_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for CCS commands */
end_comment

begin_define
define|#
directive|define
name|RAY_RESET_TIMEOUT
value|(5*hz)
end_define

begin_comment
comment|/* Timeout for resetting the card */
end_comment

begin_define
define|#
directive|define
name|RAY_TX_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for rescheduling TX */
end_comment

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|0x0000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_include
include|#
directive|include
file|"ray.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_if
if|#
directive|if
name|NRAY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_ieee80211.h>
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_rayreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_raymib.h>
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_raydbg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ray/if_rayvar.h>
end_include

begin_comment
comment|/*  * Prototyping  */
end_comment

begin_function_decl
specifier|static
name|int
name|ray_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_ccs_alloc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_ccs_fill
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_ccs_free
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_ccs_tx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|size_t
modifier|*
name|bufpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_ecf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_ecf_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_ecf_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ray_comq_entry
modifier|*
name|ray_com_init
parameter_list|(
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|,
name|ray_comqfn_t
name|function
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ray_comq_entry
modifier|*
name|ray_com_malloc
parameter_list|(
name|ray_comqfn_t
name|function
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_runq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_com_runq_add
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[]
parameter_list|,
name|int
name|ncom
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_com_runq_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_init_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_assoc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_assoc_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_download
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_download_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_download_v4
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_download_v5
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_sj
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_init_sj_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_intr_ccs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|cmd
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_intr_rcs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|cmd
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_intr_updt_errcntrs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_ioctl_lock
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_ioctl_unlock
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_mcast_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_mcast_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_promisc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_promisc_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_repparams
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_repparams_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_repparams_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_repstats_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_stats_req
modifier|*
name|sr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_reset
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_reset_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_res_alloc_am
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_res_alloc_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_res_alloc_irq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_res_release
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|rcs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_ctl
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_mgt
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_mgt_auth
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_rx_update_cache
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|src
parameter_list|,
name|u_int8_t
name|siglev
parameter_list|,
name|u_int8_t
name|antenna
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_stop
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_stop_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_tx
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_tx_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_tx_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_tx_send
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int8_t
name|pktlen
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|ray_tx_wrhdr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|bufp
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int8_t
name|fc1
parameter_list|,
name|u_int8_t
modifier|*
name|addr1
parameter_list|,
name|u_int8_t
modifier|*
name|addr2
parameter_list|,
name|u_int8_t
modifier|*
name|addr3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_upparams
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_upparams_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ray_upparams_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|ray_tx_best_antenna
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
end_if

begin_function_decl
specifier|static
name|void
name|ray_com_ecf_check
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_COM */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_MBUF
end_if

begin_function_decl
specifier|static
name|void
name|ray_dump_mbuf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_MBUF */
end_comment

begin_if
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
end_if

begin_function_decl
specifier|static
name|void
name|ray_attr_mapam
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_attr_mapcm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|ray_attr_read_1
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ray_attr_write_1
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_CM_REMAPPING */
end_comment

begin_comment
comment|/*  * PC-Card (PCMCIA) driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ray_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ray_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ray_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ray_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ray_driver
init|=
block|{
literal|"ray"
block|,
name|ray_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ray_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ray_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ray
argument_list|,
name|pccard
argument_list|,
name|ray_driver
argument_list|,
name|ray_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   * Probe for the card by checking its startup results.  *  * Fixup any bugs/quirks for different firmware.  */
end_comment

begin_function
specifier|static
name|int
name|ray_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
init|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Read startup results from the card. 	 * Then return resouces to the pool. 	 */
name|error
operator|=
name|ray_res_alloc_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Check the card is okay and work out what version we are using. 	 */
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"card failed self test 0x%b"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
name|RAY_ECFS_PRINTFB
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unsupported firmware version 0x%0x"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_BOOTPARAM
argument_list|,
literal|"found a card"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Fixup tib size to be correct - on build 4 it is garbage 	 */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_tibsize
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_tibsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_tib
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the card into the kernel  */
end_comment

begin_function
specifier|static
name|int
name|ray_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
init|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Grab the resources I need 	 */
if|#
directive|if
operator|(
name|RAY_DBG_CM
operator|||
name|RAY_DBG_BOOTPARAM
operator|)
block|{
name|u_long
name|flags
init|=
literal|0xffff
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"ioport start 0x%0lx count 0x%0lx flags 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"memory start 0x%0lx count 0x%0lx flags 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"irq start 0x%0lx count 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (RAY_DBG_CM || RAY_DBG_BOOTPARAM) */
name|error
operator|=
name|ray_res_alloc_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ray_res_alloc_am
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ray_res_alloc_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Reset any pending interrupts 	 */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Set the parameters that will survive stop/init and 	 * reset a few things on the card. 	 * 	 * Do not update these in ray_init_download's parameter setup 	 */
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|see
name|the
name|ray_init_download
name|section
for|for stuff to move
endif|#
directive|endif
for|bzero
control|(
operator|&
name|sc
operator|->
name|sc_d
operator|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
control|)
empty_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_c
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_nw_param
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set all ccs to be free */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|)
argument_list|)
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_CCS_LAST
condition|;
name|ccs
operator|+=
name|RAY_CCS_SIZE
operator|,
name|i
operator|++
control|)
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the network interface structure 	 */
if|if
condition|(
operator|!
name|ifp
operator|->
name|if_name
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|e_station_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ray"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|XXX_MCAST
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_MCAST */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000
expr_stmt|;
comment|/* Is this baud or bps ;-) */
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ray_tx
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ray_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ray_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialise the timers and driver 	 */
if|#
directive|if
name|XXX_IOCTLLOCK
name|sc
operator|->
name|sc_ioctl_lock
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioctl_cnt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_IOCTLLOCK */
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|tx_timerh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|at_shutdown
argument_list|(
name|ray_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
comment|/* 	 * Print out some useful information 	 */
if|if
condition|(
name|bootverbose
operator|||
operator|(
name|RAY_DEBUG
operator|&
name|RAY_DBG_BOOTPARAM
operator|)
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"start up results"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|printf
argument_list|(
literal|".  Firmware version 4\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|".  Firmware version 5\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Status 0x%b\n"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
name|RAY_ECFS_PRINTFB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Ether address %6D\n"
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|printf
argument_list|(
literal|".  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_rates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|".  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Supported rates %8D\n"
argument_list|,
name|ep
operator|->
name|e_rates
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".  Japan call sign %12D\n"
argument_list|,
name|ep
operator|->
name|e_japan_callsign
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|".  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_prg_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_cis_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Firmware version %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  Firmware revision %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_resv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  ASIC version %0x\n"
argument_list|,
name|ep
operator|->
name|e_asic_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".  TIB size %0x\n"
argument_list|,
name|ep
operator|->
name|e_tibsize
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach the card  *  * This is usually called when the card is ejected, but  * can be caused by a modunload of a controller driver.  * The idea is to reset the driver's view of the device  * and ensure that any driver entry points such as  * read and write do not hang.  */
end_comment

begin_function
specifier|static
name|int
name|ray_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STOP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Clear out timers and sort out driver state 	 */
name|untimeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|reset_timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_tx_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|tx_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Mark as not running 	 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
comment|/* 	 * Cleardown interface 	 */
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Mark card as gone and release resources 	 */
name|sc
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
name|ray_res_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unloading complete"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Network ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ray_param_req
name|pr
decl_stmt|;
name|struct
name|ray_stats_req
name|sr
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|error2
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_IOCTL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|#
directive|if
name|XXX_IOCTLLOCK
name|error
operator|=
name|ray_ioctl_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cannotlock
goto|;
endif|#
directive|endif
comment|/* XXX_IOCTLLOCK */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFADDR/SIFMTU"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SIFADDR"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* FALLTHROUGH */
case|case
name|SIOCSIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SIFFLAGS"
argument_list|)
expr_stmt|;
comment|/* 		 * If the interface is marked up and stopped, then start 		 * it. If it is marked down and running, then stop it. 		 * 	   	 * Restarting the interface deals with promisc/allmulti, 		 * so only check them if we are already running. 		 *  		 */
comment|/* XXX  need some mechanism to allow me to differentiate init and promisc? 	we could just not bail in promisc? */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|error
operator|=
name|ray_init_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ray_stop_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"ADDMULTI/DELMULTI"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_mcast_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSRAYPARAM
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SRAYPARAM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ray_upparams_user
argument_list|(
name|sc
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|pr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYPARAM
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYPARAM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ray_repparams_user
argument_list|(
name|sc
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|pr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYSTATS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYSTATS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_repstats_user
argument_list|(
name|sc
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|sr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|error2
condition|?
name|error2
else|:
name|error
expr_stmt|;
break|break;
case|case
name|SIOCGRAYSIGLEV
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GRAYSIGLEV"
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|sc_siglevs
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_siglevs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFFLAGS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMETRIC
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMETRIC"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMTU
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMTU"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFPHYS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFPYHS"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"SIFMEDIA"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"GIFMEDIA"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|#
directive|if
name|XXX_IOCTLLOCK
name|ray_ioctl_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cannotlock
label|:
endif|#
directive|endif
comment|/* XXX_IOCTLLOCK */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|XXX_IOCTLLOCK
end_if

begin_comment
comment|/*  * Lock routines for serialising ioctls  */
end_comment

begin_function
specifier|static
name|int
name|ray_ioctl_lock
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_IOCTL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* XXX Just in case for KAME ipv6 - see awi.c */
if|if
condition|(
name|curproc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ioctl_lock
condition|)
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
name|sc
operator|->
name|sc_ioctl_lock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|sc
operator|->
name|sc_busy
condition|)
block|{
name|sc
operator|->
name|sc_ioctl_cnt
operator|++
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|ray_ioctl_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"raylock"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ioctl_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ioctl_lock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_ioctl_unlock
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_IOCTL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ioctl_lock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|ray_ioctl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX_IOCTLLOCK */
end_comment

begin_comment
comment|/*  * User land entry to network initialisation. Called by ray_ioctl  *   * We do a very small bit of house keeping before calling ray_init_download  * to do all the real work. We do it this way in case there are runq  * entries outstanding from earlier ioctls that modify the interface  * flags.  *  * ray_init_download fills the startup parameter structure out and  * sends it to the card.  *  * ray_init_sj tells the card to try and find an existing network or  * start a new one.  *  * ray_init_sj_done checks a few parameters and we are ready to process packets  *  * the promiscuous and multi-cast modes are then set  *  * Returns values are either 0 for success, a varity of resource allocation  * failures or errors in the command sent to the card.  */
end_comment

begin_function
specifier|static
name|int
name|ray_init_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ncom
decl_stmt|,
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Create the following runq entries: 	 * 	 *		download	- download the network to the card 	 *		sj		- find or start a BSS 	 *		assoc		- associate with a ESSID if needed 	 *		promisc		- force promiscuous mode update 	 *		mcast		- force multicast list 	 */
name|ncom
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_download
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_sj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_ASSOC
if|if
condition|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_INFRA
condition|)
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_assoc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_ASSOC */
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_promisc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_MCAST
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_mcast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_MCAST */
name|error
operator|=
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"rayinit"
argument_list|)
expr_stmt|;
comment|/* XXX no real error processing from anything yet! */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|com
index|[
name|i
index|]
operator|->
name|c_flags
operator|&
name|RAY_COM_FCOMPLETED
condition|)
block|{ 		}
else|else
block|{
name|ray_ccs_free
argument_list|(
name|sc
argument_list|,
name|com
index|[
name|i
index|]
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
index|[
name|i
index|]
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|com
index|[
name|i
index|]
argument_list|,
name|M_RAYCOM
argument_list|)
expr_stmt|;
block|}
comment|/* runq_arr may fail:      if sleeping in ccs_alloc with eintr/erestart/enxio/enodev 		erestart	try again from the top 				XXX do not malloc more comqs 				XXX ccs allocation hard     		eintr		clean up and return 		enxio		clean up and return      if sleeping in runq_arr itself with eintr/erestart/enxio/enodev 		erestart	try again from the top 				XXX do not malloc more comqs 				XXX ccs allocation hard 				XXX reinsert comqs at head of list     		eintr		clean up and return 		enxio		clean up and return  only difficult one is init sequence that should be aborted in download         as commands complete before next one starts then                 init                 init is safe          longer term need to attach a desired nw params to the runq entry  */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry for resetting driver and downloading start up structures to card  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_download
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If card already running we don't need to download. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Reset instance variables 	 * 	 * The first set are network parameters that are read back when 	 * the card starts or joins the network. 	 * 	 * The second set are network parameters that are downloaded to 	 * the card. 	 * 	 * The third set are driver parameters. 	 * 	 * All of the variables in these sets can be updated by the 	 * card or ioctls. 	 */
if|#
directive|if
name|XXX
name|see
name|the
name|ray_attach
name|section
for|for stuff to move
endif|#
directive|endif
for|sc->sc_d.np_upd_param = 0
empty_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_bss_id
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_inited
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
operator|=
name|RAY_MIB_BASIC_RATE_SET_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|=
name|RAY_MIB_NET_TYPE_DEFAULT
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|RAY_MIB_SSID_DEFAULT
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
operator|=
name|RAY_MIB_PRIVACY_CAN_JOIN_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_promisc
operator|=
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|framing
operator|=
name|SC_FRAMING_WEBGEAR
expr_stmt|;
name|sc
operator|->
name|sc_rxoverflow
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxcksum
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxhcksum
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxnoise
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Download the right firmware defaults 	 */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|ray_init_download_v4
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|ray_init_download_v5
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Kick the card 	 */
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_DOWNLOAD_PARAMS
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PUT2
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do { (p)[0] = ((v>> 8)& 0xff); (p)[1] = (v& 0xff); } while(0)
end_define

begin_comment
comment|/*  * Firmware version 4 defaults - see if_raymib.h for details  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_download_v4
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_mib_4
name|ray_mib_4_default
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
define|#
directive|define
name|MIB4
parameter_list|(
name|m
parameter_list|)
value|ray_mib_4_default.##m
name|MIB4
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|MIB4
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB4
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V4
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|sc
operator|->
name|sc_promisc
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_max
argument_list|)
operator|=
name|RAY_MIB_CW_MAX_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_min
argument_list|)
operator|=
name|RAY_MIB_CW_MIN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
undef|#
directive|undef
name|MIB4
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_4_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_4_default
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Firmware version 5 defaults - see if_raymib.h for details  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_download_v5
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_mib_5
name|ray_mib_5_default
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
define|#
directive|define
name|MIB5
parameter_list|(
name|m
parameter_list|)
value|ray_mib_5_default.##m
name|MIB5
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_ap_status
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|MIB5
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB5
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|sc
operator|->
name|sc_promisc
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_max
argument_list|)
argument_list|,
name|RAY_MIB_CW_MAX_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_min
argument_list|)
argument_list|,
name|RAY_MIB_CW_MIN_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_allow_probe_resp
argument_list|)
operator|=
name|RAY_MIB_ALLOW_PROBE_RESP_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_must_start
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_can_join
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
name|MIB5
argument_list|(
name|mib_basic_rate_set
index|[
literal|0
index|]
argument_list|)
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
undef|#
directive|undef
name|MIB5
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_5_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_5_default
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|PUT2
end_undef

begin_comment
comment|/*  * Download completion routine  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_download_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/*  	 * Fake the current network parameter settings so start_join_net 	 * will not bother updating them to the card (we would need to 	 * zero these anyway, so we might as well copy). 	 */
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to starting or joining a network  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_sj
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ray_net_params
name|np
decl_stmt|;
name|int
name|update
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If card already running we don't need to start the n/w. 	 * 	 * XXX When we cope with errors and re-call this routine we 	 * XXX need better checking 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_START_NET
argument_list|)
expr_stmt|;
else|else
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_JOIN_NET
argument_list|)
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_join
operator|!=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
condition|)
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_start
operator|!=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
condition|)
name|update
operator|++
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STARTJOIN
argument_list|,
literal|"%s updating nw params"
argument_list|,
name|update
condition|?
literal|"is"
else|:
literal|"not"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|.
name|p_net_type
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|np
operator|.
name|p_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|np
operator|.
name|p_privacy_must_start
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
name|np
operator|.
name|p_privacy_can_join
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Kick the card 	 */
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete start command or intermediate step in assoc command  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_sj_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/* 	 * Read back network parameters that the ECF sets 	 */
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
operator|&
name|sc
operator|->
name|sc_c
operator|.
name|p_1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_cmd_net
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust values for buggy build 4 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
expr_stmt|;
comment|/* 	 * Update our local state if we updated the network parameters 	 * when the START_NET or JOIN_NET was issued. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_upd_param
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_STARTJOIN
argument_list|,
literal|"updated parameters"
argument_list|)
expr_stmt|;
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|sc
operator|->
name|sc_c
operator|.
name|p_2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_net_params
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Hurrah! The network is now active. 	 * 	 * Clearing IFF_OACTIVE will ensure that the system will send us 	 * packets. Just before we return from the interrupt context 	 * we check to see if packets have been queued. 	 */
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
operator|==
name|RAY_CMD_START_NET
condition|)
block|{
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to starting an association with an access point  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_assoc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If card already running we don't need to associate. 	 * 	 * XXX When we cope with errors and re-call this routine we 	 * XXX need better checking 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Kick the card 	 */
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_START_ASSOC
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete association  */
end_comment

begin_function
specifier|static
name|void
name|ray_init_assoc_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STARTJOIN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Hurrah! The network is now active. 	 * 	 * Clearing IFF_OACTIVE will ensure that the system will send us 	 * packets. Just before we return from the interrupt context 	 * we check to see if packets have been queued. 	 */
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Network stop.  *  * Inhibit card - if we can't prevent reception then do not worry;  * stopping a NIC only guarantees no TX.  *  * The change to the interface flags is done via the runq so that any  * existing commands can execute normally.  */
end_comment

begin_function
specifier|static
name|int
name|ray_stop_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STOP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Schedule the real stop routine 	 */
name|com
index|[
literal|0
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_stop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
literal|1
argument_list|,
literal|"raystop"
argument_list|)
expr_stmt|;
comment|/* XXX no real error processing from anything yet! */
if|if
condition|(
name|error
condition|)
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"got error from ray_stop 0x%x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|com
index|[
literal|0
index|]
argument_list|,
name|M_RAYCOM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry for stopping the interface activity  */
end_comment

begin_function
specifier|static
name|void
name|ray_stop
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_STOP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Mark as not running 	 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* XXX Drain output queue (don't bother for detach) */
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the card  *  * I'm using the soft reset command in the COR register. I'm not sure  * if the sequence is right but it does seem to do the right thing. A  * nano second after reset is written the flashing light goes out, and  * a few seconds after the default is written the main card light goes  * out. We wait a while and then re-init the card.  */
end_comment

begin_function
specifier|static
name|void
name|ray_reset
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
name|XXX_RESET
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
endif|#
directive|endif
comment|/* XXX_RESET */
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_RESET
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"resetting ECF"
argument_list|)
expr_stmt|;
name|ATTR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_COR
argument_list|,
name|RAY_COR_RESET
argument_list|)
expr_stmt|;
name|ATTR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_COR
argument_list|,
name|RAY_COR_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reset_timerh
operator|=
name|timeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|RAY_RESET_TIMEOUT
argument_list|)
expr_stmt|;
else|#
directive|else
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"skip reset card"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_RESET */
block|}
end_function

begin_comment
comment|/*  * Finishing resetting and restarting the card  */
end_comment

begin_function
specifier|static
name|void
name|ray_reset_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ray_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"ECF busy, re-scheduling self"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reset_timerh
operator|=
name|timeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|RAY_RESET_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"XXX need to restart ECF but not in sleepable context"
argument_list|)
expr_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"XXX the user routines must restart as required"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"watchdog timeout"
argument_list|)
expr_stmt|;
comment|/* XXX may need to have remedial action here    for example    	ray_reset 	    ray_stop 	    ... 	    ray_init      do we only use on TX?     	if so then we should clear OACTIVE etc.  */
block|}
end_function

begin_comment
comment|/*  * Transmit packet handling  */
end_comment

begin_comment
comment|/*  * Send a packet.  *  * We make two assumptions here:  *  1) That the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) That the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  *  * A simple one packet at a time TX routine is used - we don't bother  * chaining TX buffers. Performance is sufficient to max out the  * wireless link on a P75. Earlier versions of this used to set  * OACTIVE to add an extra layer of locking. It isn't really needed.  *  * Removing the OACTIVE gives much better performance. Here we  * have this driver on a Libretto, the old driver (OACTIVE)  * on a K6-233 and the Windows driver on a P100. FTPing 2048k  * of zeros.  *  * Nonname box old+FreeBSD-3.4 (K6-233MHz) to  *   Libretto 50CT new+FreeBSD-3.1 (75MHz Pentium)	110.77kB/s  *   AST J30 Windows 95A (100MHz Pentium) 		109.40kB/s  *  * AST J30 Windows 95A (100MHz Pentium) to  *   Libretto 50CT new+FreeBSD-3.1 (75MHz Pentium)	167.37kB/s  *   Nonname box FreeBSD-3.4 (233MHz AMD K6)		161.82kB/s  *  * Libretto 50CT new+FreeBSD-3.1 (75MHz Pentium) to  *   AST J30 Windows 95A (100MHz Pentium) 		167.37kB/s  *   Nonname box FreeBSD-3.4 (233MHz AMD K6)		161.38kB/s  *  * Given that 160kB/s is saturating the 2Mb/s wireless link we  * are about there.  *  * There is a little test in the code to see how many packets  * could be chained together. For the FTP test this rarely showed  * any and when it did, only two packets were on the queue.  *  * So, in short I'm happy that the added complexity of chaining TX  * packets together isn't worth it for my machines.  *  * Flow is  *		get a ccs  *		build the packet  *		interrupt the card to send the packet  *		return  *  *		wait for interrupt telling us the packet has been sent  *		get called by the interrupt routine if any packets left  */
end_comment

begin_function
specifier|static
name|void
name|ray_tx
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|pktlen
decl_stmt|,
name|len
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Some simple checks first - some are overkill 	 */
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"not running"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_havenet
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"no network"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Can't assume that the ECF is busy because of this driver */
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"ECF busy, re-scheduling self"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_timerh
operator|=
name|timeout
argument_list|(
name|ray_tx_timo
argument_list|,
name|sc
argument_list|,
name|RAY_TX_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|untimeout
argument_list|(
name|ray_tx_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|tx_timerh
argument_list|)
expr_stmt|;
comment|/* 	 * We find a ccs before we process the mbuf so that we are sure it 	 * is worthwhile processing the packet. All errors in the mbuf 	 * processing are either errors in the mbuf or gross configuration 	 * errors and the packet wouldn't get through anyway. 	 */
if|if
condition|(
name|ray_ccs_tx
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
operator|&
name|bufp
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the mbuf and process it - we have to remember to free the 	 * ccs if there are any errors 	 */
if|#
directive|if
name|XXX_IFQ_PEEK
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
operator|>
literal|1
condition|)
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"ifq_len %d"
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_IFQ_PEEK */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|pktlen
operator|=
literal|0
operator|,
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"mbuf too long %d"
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX 	 * I would much prefer to have the complete 802.11 packet dropped to 	 * the bpf tap and then have a user land program parse the headers 	 * as needed. This way, tcpdump -w can be used to grab the raw data. If 	 * needed the 802.11 aware program can "translate" the .11 to ethernet 	 * for tcpdump -r. 	 * 	 * XXX see /sys/dev/awi/awi.c:AWI_BPF_NORM stuff 	 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * Write the header according to network type etc. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
name|bufp
operator|=
name|ray_tx_wrhdr
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
argument_list|,
name|IEEE80211_FC1_STA_TO_STA
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|==
name|RAY_MIB_AP_STATUS_TERMINAL
condition|)
name|bufp
operator|=
name|ray_tx_wrhdr
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
argument_list|,
name|IEEE80211_FC1_STA_TO_AP
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
else|else
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"can't be an AP yet"
argument_list|)
expr_stmt|;
comment|/* XXX_ACTING_AP */
comment|/* 	 * Translation - capability as described earlier 	 * 	 * Remove/modify/addto the 802.3 and 802.2 headers as needed. 	 * 	 * We've pulled up the mbuf for you. 	 * 	 */
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"could not pullup ether"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|sc
operator|->
name|framing
condition|)
block|{
case|case
name|SC_FRAMING_WEBGEAR
case|:
comment|/* Nice and easy - nothing! (just add an 802.11 header) */
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unknown framing type %d"
argument_list|,
name|sc
operator|->
name|framing
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"could not translate mbuf"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Copy the mbuf to the buffer in common memory 	 * 	 * We panic and don't bother wrapping as ethernet packets are 1518 	 * bytes, we checked the mbuf earlier, and our TX buffers are 2048 	 * bytes. We don't have 530 bytes of headers etc. so something 	 * must be fubar. 	 */
name|pktlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bufp
operator|+
name|len
operator|)
operator|<
name|RAY_TX_END
condition|)
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"tx buffer overflow"
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_TX
argument_list|,
name|m0
argument_list|,
literal|"ray_tx"
argument_list|)
expr_stmt|;
comment|/* 	 * Send it off 	 */
if|if
condition|(
name|ray_tx_send
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|pktlen
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start timeout routine.  *  * Used when card was busy but we needed to send a packet.  */
end_comment

begin_function
specifier|static
name|void
name|ray_tx_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ray_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ray_tx
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write an 802.11 header into the Tx buffer space and return the  * adjusted buffer pointer.  */
end_comment

begin_function
specifier|static
name|size_t
name|ray_tx_wrhdr
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|bufp
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int8_t
name|fc1
parameter_list|,
name|u_int8_t
modifier|*
name|addr1
parameter_list|,
name|u_int8_t
modifier|*
name|addr2
parameter_list|,
name|u_int8_t
modifier|*
name|addr3
parameter_list|)
block|{
name|struct
name|ieee80211_header
name|header
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
name|header
operator|.
name|i_fc
index|[
literal|0
index|]
operator|=
operator|(
name|IEEE80211_FC0_VERSION_0
operator||
name|type
operator|)
expr_stmt|;
name|header
operator|.
name|i_fc
index|[
literal|1
index|]
operator|=
name|fc1
expr_stmt|;
name|bcopy
argument_list|(
name|addr1
argument_list|,
name|header
operator|.
name|i_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addr2
argument_list|,
name|header
operator|.
name|i_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addr3
argument_list|,
name|header
operator|.
name|i_addr3
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bufp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in a few loose ends and kick the card to send the packet  *  * Returns 0 on success, 1 on failure  */
end_comment

begin_function
specifier|static
name|int
name|ray_tx_send
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int8_t
name|pktlen
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * XXX From NetBSD code: 		 * 		 * XXX If this can really happen perhaps we need to save 		 * XXX the chain and use it later.  I think this might 		 * XXX be a confused state though because we check above 		 * XXX and don't issue any commands between. 		 */
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"ECF busy, dropping packet"
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_len
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_antenna
argument_list|,
name|ray_tx_best_antenna
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine best antenna to use from rx level and antenna cache  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ray_tx_best_antenna
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|ray_siglev
modifier|*
name|sl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int8_t
name|antenna
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* try to find host */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sl
operator|->
name|rsl_host
argument_list|,
name|dst
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* not found, return default setting */
return|return
operator|(
literal|0
operator|)
return|;
name|found
label|:
comment|/* This is a simple thresholding scheme which takes the mean 	 * of the best antenna history. This is okay but as it is a 	 * filter, it adds a bit of lag in situations where the 	 * best antenna swaps from one side to the other slowly. Don't know 	 * how likely this is given the horrible fading though. 	 */
name|antenna
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NANTENNA
condition|;
name|i
operator|++
control|)
block|{
name|antenna
operator|+=
name|sl
operator|->
name|rsl_antennas
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|antenna
operator|>
operator|(
name|RAY_NANTENNA
operator|>>
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit now complete so clear ccs and network flags.  */
end_comment

begin_function
specifier|static
name|void
name|ray_tx_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|char
modifier|*
name|ss
index|[]
init|=
name|RAY_CCS_STATUS_STRINGS
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_TX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RAY_CCS_STATUS_COMPLETE
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"tx completed but status is %s"
argument_list|,
name|ss
index|[
name|status
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receiver packet handling  */
end_comment

begin_comment
comment|/*  * Receive a packet from the card  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|rcs
parameter_list|)
block|{
name|struct
name|ieee80211_header
modifier|*
name|header
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|size_t
name|pktlen
decl_stmt|,
name|fraglen
decl_stmt|,
name|readlen
decl_stmt|,
name|tmplen
decl_stmt|;
name|size_t
name|bufp
decl_stmt|,
name|ebufp
decl_stmt|;
name|u_int8_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|u_int8_t
name|siglev
decl_stmt|,
name|antenna
decl_stmt|;
name|u_int
name|first
decl_stmt|,
name|ni
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"using rcs 0x%x"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|readlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get first part of packet and the length. Do some sanity checks 	 * and get a mbuf. 	 */
name|first
operator|=
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_pktlen
argument_list|)
expr_stmt|;
name|siglev
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_siglev
argument_list|)
expr_stmt|;
name|antenna
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_antenna
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pktlen
operator|>
name|MCLBYTES
operator|)
operator|||
operator|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"packet too big or too small"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"MGETHDR failed"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"MCLGET failed"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pktlen
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
name|dst
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Walk the fragment chain to build the complete packet. 	 * 	 * The use of two index variables removes a race with the 	 * hardware. If one index were used the clearing of the CCS would 	 * happen before reading the next pointer and the hardware can get in. 	 * Not my idea but verbatim from the NetBSD driver. 	 */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_bufp
argument_list|)
expr_stmt|;
name|fraglen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"frag index %d len %d bufp 0x%x ni %d"
argument_list|,
name|i
argument_list|,
name|fraglen
argument_list|,
operator|(
name|int
operator|)
name|bufp
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|fraglen
operator|+
name|readlen
operator|>
name|pktlen
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"bad length current 0x%x pktlen 0x%x"
argument_list|,
name|fraglen
operator|+
name|readlen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|RAY_RCS_FIRST
operator|)
operator|||
operator|(
name|i
operator|>
name|RAY_RCS_LAST
operator|)
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"bad rcs index 0x%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|ebufp
operator|=
name|bufp
operator|+
name|fraglen
expr_stmt|;
if|if
condition|(
name|ebufp
operator|<=
name|RAY_RX_END
condition|)
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
name|fraglen
argument_list|)
expr_stmt|;
else|else
block|{
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
operator|(
name|tmplen
operator|=
name|RAY_RX_END
operator|-
name|bufp
operator|)
argument_list|)
expr_stmt|;
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_RX_BASE
argument_list|,
name|dst
operator|+
name|tmplen
argument_list|,
name|ebufp
operator|-
name|RAY_RX_END
argument_list|)
expr_stmt|;
block|}
name|dst
operator|+=
name|fraglen
expr_stmt|;
name|readlen
operator|+=
name|fraglen
expr_stmt|;
block|}
name|skip_read
label|:
comment|/* 	 * Walk the chain again to free the rcss. 	 */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Check the 802.11 packet type 	 * 	 * DATA packets are dealt with below, CTL and MGT packets 	 * are handled in their own functions. 	 */
name|header
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"header not version 0 fc0 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|ray_rx_mgt
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
break|break;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|ray_rx_ctl
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unknown packet fc0 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check the the data packet subtype, some packets have 	 * nothing in them so we will drop them here. 	 */
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_DATA_DATA
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_DATA_DATA_CFACK
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_DATA_DATA_CFPOLL
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_DATA_DATA_CFACPL
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"DATA packet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DATA_NULL
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_DATA_CFACK
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_DATA_CFPOLL
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_DATA_CFACK_CFACK
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"NULL packet"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"reserved DATA packet subtype 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Obtain the .11 src addresses. 	 * 	 * XXX This needs some work for INFRA mode 	 * XXX Do I need this at all? MGT and CTL is far easier. 	 */
name|src
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DS_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_STA_TO_STA
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"packet from sta %6D"
argument_list|,
name|src
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_STA_TO_AP
case|:
comment|/* XXX XXX_ACTING_AP */
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"packet from sta to ap %6D %6D"
argument_list|,
name|src
argument_list|,
literal|":"
argument_list|,
name|header
operator|->
name|i_addr3
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_AP_TO_STA
case|:
comment|/* XXX_INFRA */
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"packet from ap %6D"
argument_list|,
name|src
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_AP_TO_AP
case|:
comment|/* XXX XXX_ACTING_AP */
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"packet between aps %6D %6D"
argument_list|,
name|src
argument_list|,
literal|":"
argument_list|,
name|header
operator|->
name|i_addr2
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unknown packet fc1 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Translation - capability as described earlier 	 * 	 * Each case must remove the 802.11 header and leave an 802.3 	 * header in the mbuf copy addresses as needed. 	 */
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
name|m0
argument_list|,
literal|"DATA packet before framing"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|framing
condition|)
block|{
case|case
name|SC_FRAMING_WEBGEAR
case|:
comment|/* Nice and easy - just trim the 802.11 header */
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unknown framing type %d"
argument_list|,
name|sc
operator|->
name|framing
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Finally, do a bit of house keeping before sending the packet 	 * up the stack. 	 */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|ray_rx_update_cache
argument_list|(
name|sc
argument_list|,
name|src
argument_list|,
name|siglev
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Deal with MGT packet types  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_mgt
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ieee80211_header
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_header
operator|*
argument_list|)
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_MGT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DS_MASK
operator|)
operator|!=
name|IEEE80211_FC1_STA_TO_STA
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"MGT TODS/FROMDS wrong fc1 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DS_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check the the mgt packet subtype, some packets should be 	 * dropped depending on the mode the station is in. 	 * 	 * XXX investigations of v5 firmware See pg 52(60) of docs 	 * 	 * P - proccess, J - Junk, E - ECF deals with, I - Illegal  	 * ECF Proccesses   	 *  AHDOC procces or junk    	 *   INFRA STA process or junk     	 *    INFRA AP process or jumk 	 *   	 * +PPP	IEEE80211_FC0_SUBTYPE_MGT_BEACON  	 * +EEE	IEEE80211_FC0_SUBTYPE_MGT_PROBE_REQ  	 * +EEE	IEEE80211_FC0_SUBTYPE_MGT_PROBE_RESP  	 *  PPP	IEEE80211_FC0_SUBTYPE_MGT_AUTH  	 *  PPP	IEEE80211_FC0_SUBTYPE_MGT_DEAUTH  	 *  JJP	IEEE80211_FC0_SUBTYPE_MGT_ASSOC_REQ  	 *  JPJ	IEEE80211_FC0_SUBTYPE_MGT_ASSOC_RESP  	 *  JPP	IEEE80211_FC0_SUBTYPE_MGT_DISASSOC  	 *  JJP	IEEE80211_FC0_SUBTYPE_MGT_REASSOC_REQ  	 *  JPJ	IEEE80211_FC0_SUBTYPE_MGT_REASSOC_RESP  	 * +EEE	IEEE80211_FC0_SUBTYPE_MGT_ATIM 	 */
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
name|m0
argument_list|,
literal|"MGT packet"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_BEACON
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"BEACON MGT packet"
argument_list|)
expr_stmt|;
comment|/* XXX furtle anything interesting out */
comment|/* Note that there are rules governing what beacons to 		   read, see 8802 S7.2.3, S11.1.2.3 */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_AUTH
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"AUTH MGT packet"
argument_list|)
expr_stmt|;
name|ray_rx_mgt_auth
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_DEAUTH
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"DEAUTH MGT packet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_ASSOC_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_REASSOC_REQ
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"(RE)ASSOC_REQ MGT packet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|!=
name|RAY_MIB_AP_STATUS_AP
condition|)
return|return;
else|else
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"can't be an AP yet"
argument_list|)
expr_stmt|;
comment|/* XXX_ACTING_AP */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_ASSOC_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_REASSOC_RESP
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"(RE)ASSOC_RESP MGT packet"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|==
name|RAY_MIB_AP_STATUS_AP
operator|)
condition|)
return|return;
else|else
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"can't be in INFRA yet"
argument_list|)
expr_stmt|;
comment|/* XXX_INFRA */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_DISASSOC
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"DISASSOC MGT packet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
return|return;
else|else
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"can't be in INFRA yet"
argument_list|)
expr_stmt|;
comment|/* XXX_INFRA */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_PROBE_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_PROBE_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_MGT_ATIM
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unexpected MGT packet subtype 0x%0x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"reserved MGT packet subtype 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Deal with AUTH management packet types  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_mgt_auth
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211_header
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_header
operator|*
argument_list|)
decl_stmt|;
name|ieee80211_mgt_auth_t
name|auth
init|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|header
operator|+
literal|1
operator|)
decl_stmt|;
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_MGT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IEEE80211_AUTH_ALGORITHM
argument_list|(
name|auth
argument_list|)
condition|)
block|{
case|case
name|IEEE80211_AUTH_OPENSYSTEM
case|:
if|if
condition|(
name|IEEE80211_AUTH_TRANSACTION
argument_list|(
name|auth
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* XXX see sys/dev/awi/awk.c:awi_{recv|send}_auth */
comment|/* 			 * Send authentication response if possible. If 			 * we are out of CCSs we don't to anything, the 			 * other end will try again. 			 */
if|if
condition|(
name|ray_ccs_tx
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
operator|&
name|bufp
argument_list|)
condition|)
block|{
return|return;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"bufp %x"
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|ray_tx_wrhdr
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_MGT_AUTH
argument_list|,
name|IEEE80211_FC1_STA_TO_STA
argument_list|,
name|header
operator|->
name|i_addr2
argument_list|,
name|header
operator|->
name|i_addr1
argument_list|,
name|header
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
for|for
control|(
name|pktlen
operator|=
literal|0
init|;
name|pktlen
operator|<
literal|6
condition|;
name|pktlen
operator|++
control|)
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|bufp
operator|+
name|pktlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|bufp
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
literal|"dump start %x"
argument_list|,
name|bufp
operator|-
name|pktlen
operator|+
literal|6
argument_list|)
expr_stmt|;
name|RAY_DHEX8
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_MGT
argument_list|,
name|bufp
operator|-
name|pktlen
operator|+
literal|6
argument_list|,
name|pktlen
argument_list|,
literal|"AUTH MGT response to Open System request"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ray_tx_send
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|pktlen
argument_list|,
name|header
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_AUTH_TRANSACTION
argument_list|(
name|auth
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|IEEE80211_AUTH_STATUS
argument_list|(
name|auth
argument_list|)
operator|!=
name|IEEE80211_STATUS_SUCCESS
condition|)
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"authentication failed with status %d"
argument_list|,
name|IEEE80211_AUTH_STATUS
argument_list|(
name|auth
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX probably need a lot more than this */
block|}
break|break;
case|case
name|IEEE80211_AUTH_SHAREDKEYS
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"shared key authentication requested"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unknown authentication subtype 0x%04hx"
argument_list|,
name|IEEE80211_AUTH_ALGORITHM
argument_list|(
name|auth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Deal with CTL packet types  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_ctl
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ieee80211_header
modifier|*
name|header
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_header
operator|*
argument_list|)
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CTL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DS_MASK
operator|)
operator|!=
name|IEEE80211_FC1_STA_TO_STA
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RECERR
argument_list|,
literal|"CTL TODS/FROMDS wrong fc1 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DS_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check the the ctl packet subtype, some packets should be 	 * dropped depending on the mode the station is in. The ECF 	 * should deal with everything but the power save poll to an 	 * AP 	 * 	 * XXX investigations of v5 firmware See pg 52(60) of docs 	 * 	 */
name|RAY_MBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CTL
argument_list|,
name|m0
argument_list|,
literal|"CTL packet"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_CTL_PS_POLL
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CTL
argument_list|,
literal|"PS_POLL CTL packet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ap_status
operator|!=
name|RAY_MIB_AP_STATUS_AP
condition|)
return|return;
else|else
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"can't be an AP yet"
argument_list|)
expr_stmt|;
comment|/* XXX_ACTING_AP */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_CTL_RTS
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CTL_CTS
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CTL_ACK
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CTL_CFEND
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_CTL_CFEND_CFACK
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unexpected CTL packet subtype 0x%0x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"reserved CTL packet subtype 0x%x"
argument_list|,
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Update rx level and antenna cache  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx_update_cache
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|src
parameter_list|,
name|u_int8_t
name|siglev
parameter_list|,
name|u_int8_t
name|antenna
parameter_list|)
block|{
name|struct
name|timeval
name|mint
decl_stmt|;
name|struct
name|ray_siglev
modifier|*
name|sl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mini
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Try to find host */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sl
operator|->
name|rsl_host
argument_list|,
name|src
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* Not found, find oldest slot */
name|mini
operator|=
literal|0
expr_stmt|;
name|mint
operator|.
name|tv_sec
operator|=
name|LONG_MAX
expr_stmt|;
name|mint
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_NSIGLEVRECS
condition|;
name|i
operator|++
control|)
block|{
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|sl
operator|->
name|rsl_time
argument_list|,
operator|&
name|mint
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|mini
operator|=
name|i
expr_stmt|;
name|mint
operator|=
name|sl
operator|->
name|rsl_time
expr_stmt|;
block|}
block|}
name|sl
operator|=
operator|&
name|sc
operator|->
name|sc_siglevs
index|[
name|mini
index|]
expr_stmt|;
name|bzero
argument_list|(
name|sl
operator|->
name|rsl_siglevs
argument_list|,
name|RAY_NSIGLEV
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sl
operator|->
name|rsl_antennas
argument_list|,
name|RAY_NANTENNA
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|sl
operator|->
name|rsl_host
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|found
label|:
name|microtime
argument_list|(
operator|&
name|sl
operator|->
name|rsl_time
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sl
operator|->
name|rsl_siglevs
argument_list|,
operator|&
name|sl
operator|->
name|rsl_siglevs
index|[
literal|1
index|]
argument_list|,
name|RAY_NSIGLEV
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sl
operator|->
name|rsl_siglevs
index|[
literal|0
index|]
operator|=
name|siglev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|bcopy
argument_list|(
name|sl
operator|->
name|rsl_antennas
argument_list|,
operator|&
name|sl
operator|->
name|rsl_antennas
index|[
literal|1
index|]
argument_list|,
name|RAY_NANTENNA
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sl
operator|->
name|rsl_antennas
index|[
literal|0
index|]
operator|=
name|antenna
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Interrupt handling  */
end_comment

begin_comment
comment|/*  * Process an interrupt  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ray_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int8_t
name|cmd
decl_stmt|;
name|int
name|ccsi
decl_stmt|,
name|count
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
comment|/* 	 * Check that the interrupt was for us, if so get the rcs/ccs 	 * and vector on the command contained within it. 	 */
if|if
condition|(
operator|!
name|RAY_HCS_INTR
argument_list|(
name|sc
argument_list|)
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|ccsi
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_RCSI
argument_list|)
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|ccsi
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccsi
operator|<=
name|RAY_CCS_LAST
condition|)
name|ray_intr_ccs
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ccsi
operator|<=
name|RAY_RCS_LAST
condition|)
name|ray_intr_rcs
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
else|else
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"bad ccs index 0x%x"
argument_list|,
name|ccsi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"interrupt %s handled"
argument_list|,
name|count
condition|?
literal|"was"
else|:
literal|"not"
argument_list|)
expr_stmt|;
comment|/* Send any packets lying around and update error counters */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|ray_tx
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|sc
operator|->
name|sc_checkcounters
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|ray_intr_updt_errcntrs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the error counters.  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr_updt_errcntrs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|csc
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The card implements the following protocol to keep the 	 * values from being changed while read: It checks the `own' 	 * bit and if zero writes the current internal counter value, 	 * it then sets the `own' bit to 1. If the `own' bit was 1 it 	 * incremenets its internal counter. The user thus reads the 	 * counter if the `own' bit is one and then sets the own bit 	 * to 0. 	 */
name|csc
operator|=
name|RAY_STATUS_BASE
expr_stmt|;
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxo_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxoverflow
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrx_overflow
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxo_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxc_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxcksum
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrx_overflow
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_mrxc_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rxhc_own
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_rxhcksum
operator|+=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rx_hcksum
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rxhc_own
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxnoise
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|csc
argument_list|,
name|ray_csc
argument_list|,
name|csc_rx_noise
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process CCS command completion  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr_ccs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|cmd
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX replace this with a jump table? */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_CMD_DOWNLOAD_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START_PARAMS"
argument_list|)
expr_stmt|;
name|ray_init_download_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"UPDATE_PARAMS"
argument_list|)
expr_stmt|;
name|ray_upparams_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_REPORT_PARAMS
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"REPORT_PARAMS"
argument_list|)
expr_stmt|;
name|ray_repparams_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_MCAST
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"UPDATE_MCAST"
argument_list|)
expr_stmt|;
name|ray_mcast_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_NET
case|:
case|case
name|RAY_CMD_JOIN_NET
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START|JOIN_NET"
argument_list|)
expr_stmt|;
name|ray_init_sj_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TX_REQ
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"TX_REQ"
argument_list|)
expr_stmt|;
name|ray_tx_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_ASSOC
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"START_ASSOC"
argument_list|)
expr_stmt|;
name|ray_init_assoc_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_APM
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unexpected UPDATE_APM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TEST_MEM
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unexpected TEST_MEM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_SHUTDOWN
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unexpected SHUTDOWN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_DUMP_MEM
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unexpected DUMP_MEM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_TIMER
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unexpected START_TIMER"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unknown command 0x%x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process ECF command request  */
end_comment

begin_function
specifier|static
name|void
name|ray_intr_rcs
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|cmd
parameter_list|,
name|size_t
name|rcs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX replace this with a jump table? */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_ECMD_RX_DONE
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"RX_DONE"
argument_list|)
expr_stmt|;
name|ray_rx
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_REJOIN_DONE
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"REJOIN_DONE"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
comment|/* XXX Should not be here but in function */
break|break;
case|case
name|RAY_ECMD_ROAM_START
case|:
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_RX
argument_list|,
literal|"ROAM_START"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/* XXX Should not be here but in function */
break|break;
case|case
name|RAY_ECMD_JAPAN_CALL_SIGNAL
case|:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unexpected JAPAN_CALL_SIGNAL"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"unknown command 0x%x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|XXX_MCAST
end_if

begin_comment
comment|/*  * XXX First cut at this code - have not tried compiling it yet. V. confusing  * XXX interactions between allmulti, promisc and mcast. Going to leave it  * XXX for now.  * XXX Don't like the code bloat to set promisc up - we use it here, ray_init,  * XXX ray_promisc_user and ray_upparams_user...  * XXX need to use the runq_array  */
end_comment

begin_comment
comment|/*  * User land entry to multicast list changes  */
end_comment

begin_function
specifier|static
name|int
name|ray_mcast_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * The multicast list is only 16 items long so use promiscuous 	 * mode if needed. 	 * 	 * We track this stuff even when not running. 	 */
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
operator|,
name|count
operator|=
literal|0
init|;
name|ifma
operator|!=
name|NULL
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
operator|,
name|count
operator|++
control|)
if|if
condition|(
name|count
operator|>
literal|16
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ncom
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we need to change the promiscuous mode then do so. 	 */
if|if
condition|(
name|sc
operator|->
name|promisc
operator|!=
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
condition|)
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_promisc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If we need to set the mcast list then do so. 	 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
condition|)
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_mcast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"raymcast"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EINTR
operator|)
operator|||
operator|(
name|error
operator|==
name|ERESTART
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX no real error processing from anything yet! */
name|error
operator|=
name|com
operator|->
name|c_retval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
name|FREE
argument_list|(
name|com
index|[
name|i
index|]
argument_list|,
name|M_RAYCOM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to setting the multicast filter list  */
end_comment

begin_function
specifier|static
name|void
name|ray_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|size_t
name|bufp
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_UPDATE_MCAST
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
argument|sc
argument_list|,
argument|com->c_ccs 	    ray_cmd_update_mcast
argument_list|,
argument|c_nmcast
argument_list|,
argument|count
argument_list|)
empty_stmt|;
name|bufp
operator|=
name|RAY_HOST_TO_ECF_BASE
expr_stmt|;
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
operator|!=
name|NULL
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|ETHER_ADDR_LEN
expr_stmt|;
block|}
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the multicast filter list update  */
end_comment

begin_function
specifier|static
name|void
name|ray_mcast_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|ray_mcast_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_mcast
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|ray_mcast_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX_MCAST */
end_comment

begin_comment
comment|/*  * User land entry to promiscuous mode change  */
end_comment

begin_function
specifier|static
name|int
name|ray_promisc_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ncom
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ncom
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_promisc
argument_list|,
name|RAY_COM_FWOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"raypromisc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EINTR
operator|)
operator|||
operator|(
name|error
operator|==
name|ERESTART
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX no real error processing from anything yet! */
name|error
operator|=
name|com
index|[
literal|0
index|]
operator|->
name|c_retval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
name|FREE
argument_list|(
name|com
index|[
name|i
index|]
argument_list|,
name|M_RAYCOM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to set/reset promiscuous mode  */
end_comment

begin_function
specifier|static
name|void
name|ray_promisc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_UPDATE_PARAMS
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_paramid
argument_list|,
name|RAY_MIB_PROMISC
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User land entry to parameter reporting  */
end_comment

begin_function
specifier|static
name|int
name|ray_repparams_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ncom
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|pr
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_EDEVSTOP
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Test for illegal values or immediate responses 	 */
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|)
operator|&&
operator|!
operator|(
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
literal|0
index|]
operator|&
name|RAY_V4
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
operator|)
operator|&&
operator|!
operator|(
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
literal|0
index|]
operator|&
name|RAY_V5
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_LASTUSER
condition|)
block|{
switch|switch
condition|(
name|pr
operator|->
name|r_paramid
condition|)
block|{
case|case
name|RAY_MIB_VERSION
case|:
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
operator|*
name|pr
operator|->
name|r_data
operator|=
name|RAY_V4
expr_stmt|;
else|else
operator|*
name|pr
operator|->
name|r_data
operator|=
name|RAY_V5
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_BSSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_bss_id
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_INITED
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_inited
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_DEF_TXRATE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_ENCRYPT
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_encrypt
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_NET_TYPE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_SSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_PRIV_START
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_start
expr_stmt|;
break|break;
case|case
name|RAY_MIB_CUR_PRIV_JOIN
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_join
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_BSSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_bss_id
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_INITED
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_inited
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_DEF_TXRATE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_ENCRYPT
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_encrypt
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_NET_TYPE
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_SSID
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_PRIV_START
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
expr_stmt|;
break|break;
case|case
name|RAY_MIB_DES_PRIV_JOIN
case|:
operator|*
name|pr
operator|->
name|r_data
operator|=
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
name|pr
operator|->
name|r_failcause
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|pr
operator|->
name|r_len
operator|=
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
name|RAY_MIB_INFO_SIZ4
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
name|pr
operator|->
name|r_len
operator|=
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
name|RAY_MIB_INFO_SIZ5
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pr
operator|->
name|r_failcause
operator|=
literal|0
expr_stmt|;
name|ncom
operator|=
literal|0
expr_stmt|;
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_repparams
argument_list|,
name|RAY_COM_FWOK
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|-
literal|1
index|]
operator|->
name|c_pr
operator|=
name|pr
expr_stmt|;
name|error
operator|=
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"rayrepparams"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EINTR
operator|)
operator|||
operator|(
name|error
operator|==
name|ERESTART
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX no real error processing from anything yet! */
name|error
operator|=
name|com
index|[
literal|0
index|]
operator|->
name|c_retval
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|pr
operator|->
name|r_failcause
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
name|FREE
argument_list|(
name|com
index|[
name|i
index|]
argument_list|,
name|M_RAYCOM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to read the required parameter  */
end_comment

begin_function
specifier|static
name|void
name|ray_repparams
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_REPORT_PARAMS
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_paramid
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_paramid
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the parameter reporting  */
end_comment

begin_function
specifier|static
name|void
name|ray_repparams_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_pr
operator|->
name|r_failcause
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_failcause
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_pr
operator|->
name|r_len
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_report
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|SRAM_READ_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_data
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User land entry (and exit) to the error counters  */
end_comment

begin_function
specifier|static
name|int
name|ray_repstats_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_stats_req
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sr
operator|->
name|rxoverflow
operator|=
name|sc
operator|->
name|sc_rxoverflow
expr_stmt|;
name|sr
operator|->
name|rxcksum
operator|=
name|sc
operator|->
name|sc_rxcksum
expr_stmt|;
name|sr
operator|->
name|rxhcksum
operator|=
name|sc
operator|->
name|sc_rxhcksum
expr_stmt|;
name|sr
operator|->
name|rxnoise
operator|=
name|sc
operator|->
name|sc_rxnoise
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * User land entry to parameter update changes  *  * As a parameter change can cause the network parameters to be  * invalid we have to re-sttart/join.  */
end_comment

begin_function
specifier|static
name|int
name|ray_upparams_user
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_param_req
modifier|*
name|pr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|todo
decl_stmt|,
name|error
decl_stmt|,
name|ncom
decl_stmt|;
define|#
directive|define
name|RAY_UPP_SJ
value|0x1
define|#
directive|define
name|RAY_UPP_PARAMS
value|0x2
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|pr
operator|->
name|r_failcause
operator|=
name|RAY_FAILCAUSE_EDEVSTOP
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* XXX Use this for other IFF_RUNNING checks */
block|}
comment|/* 	 * Handle certain parameters specially 	 */
name|todo
operator|=
literal|0
expr_stmt|;
name|pr
operator|->
name|r_failcause
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|r_paramid
operator|>
name|RAY_MIB_LASTUSER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|)
operator|&&
operator|!
operator|(
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
literal|0
index|]
operator|&
name|RAY_V4
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
operator|)
operator|&&
operator|!
operator|(
name|mib_info
index|[
name|pr
operator|->
name|r_paramid
index|]
index|[
literal|0
index|]
operator|&
name|RAY_V5
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|pr
operator|->
name|r_paramid
condition|)
block|{
case|case
name|RAY_MIB_NET_TYPE
case|:
comment|/* Updated via START_NET JOIN_NET  */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|==
operator|*
name|pr
operator|->
name|r_data
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
case|case
name|RAY_MIB_SSID
case|:
comment|/* Updated via START_NET JOIN_NET  */
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|sc_c
operator|.
name|np_ssid
argument_list|,
name|pr
operator|->
name|r_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
name|pr
operator|->
name|r_data
argument_list|,
name|sc
operator|->
name|sc_d
operator|.
name|np_ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
case|case
name|RAY_MIB_PRIVACY_MUST_START
case|:
comment|/* Updated via START_NET */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_net_type
operator|!=
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_start
operator|==
operator|*
name|pr
operator|->
name|r_data
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_start
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
case|case
name|RAY_MIB_PRIVACY_CAN_JOIN
case|:
comment|/* Updated via START_NET JOIN_NET  */
if|if
condition|(
name|sc
operator|->
name|sc_c
operator|.
name|np_priv_join
operator|==
operator|*
name|pr
operator|->
name|r_data
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_d
operator|.
name|np_priv_join
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
case|case
name|RAY_MIB_BASIC_RATE_SET
case|:
name|sc
operator|->
name|sc_d
operator|.
name|np_def_txrate
operator|=
operator|*
name|pr
operator|->
name|r_data
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_PARAMS
expr_stmt|;
break|break;
case|case
name|RAY_MIB_AP_STATUS
case|:
comment|/* Unsupported */
case|case
name|RAY_MIB_MAC_ADDR
case|:
comment|/* XXX Need interface up */
case|case
name|RAY_MIB_PROMISC
case|:
comment|/* BPF */
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
name|todo
operator||=
name|RAY_UPP_PARAMS
expr_stmt|;
name|todo
operator||=
name|RAY_UPP_SJ
expr_stmt|;
break|break;
block|}
name|ncom
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|todo
operator|&
name|RAY_UPP_PARAMS
condition|)
block|{
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_upparams
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|com
index|[
name|ncom
operator|-
literal|1
index|]
operator|->
name|c_pr
operator|=
name|pr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|todo
operator|&
name|RAY_UPP_SJ
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_sj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_ASSOC
if|if
condition|(
name|sc
operator|->
name|sc_d
operator|.
name|np_net_type
operator|==
name|RAY_MIB_NET_TYPE_INFRA
condition|)
name|com
index|[
name|ncom
operator|++
index|]
operator|=
name|RAY_COM_MALLOC
argument_list|(
name|ray_init_assoc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_ASSOC */
block|}
name|error
operator|=
name|ray_com_runq_add
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|ncom
argument_list|,
literal|"rayupparams"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EINTR
operator|)
operator|||
operator|(
name|error
operator|==
name|ERESTART
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX no real error processing from anything yet! */
name|error
operator|=
name|com
index|[
literal|0
index|]
operator|->
name|c_retval
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|pr
operator|->
name|r_failcause
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
name|FREE
argument_list|(
name|com
index|[
name|i
index|]
argument_list|,
name|M_RAYCOM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runq entry to update a parameter  */
end_comment

begin_function
specifier|static
name|void
name|ray_upparams
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_ccs_fill
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|RAY_CMD_UPDATE_PARAMS
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_paramid
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_paramid
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_nparam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SRAM_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_data
argument_list|,
name|com
operator|->
name|c_pr
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|ray_com_ecf
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the parameter update  */
end_comment

begin_function
specifier|static
name|void
name|ray_upparams_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_COM_CHECK
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_paramid
argument_list|)
condition|)
block|{
case|case
name|RAY_MIB_PROMISC
case|:
name|sc
operator|->
name|sc_promisc
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_IOCTL
argument_list|,
literal|"promisc value %d"
argument_list|,
name|sc
operator|->
name|sc_promisc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|com
operator|->
name|c_pr
operator|->
name|r_failcause
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_update
argument_list|,
name|c_failcause
argument_list|)
expr_stmt|;
break|break;
block|}
name|ray_com_ecf_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Command queuing and execution  */
end_comment

begin_comment
comment|/*  * Set up a comq entry struct  */
end_comment

begin_function
specifier|static
name|struct
name|ray_comq_entry
modifier|*
name|ray_com_init
parameter_list|(
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|,
name|ray_comqfn_t
name|function
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
name|com
operator|->
name|c_function
operator|=
name|function
expr_stmt|;
name|com
operator|->
name|c_flags
operator|=
name|flags
expr_stmt|;
name|com
operator|->
name|c_retval
operator|=
literal|0
expr_stmt|;
name|com
operator|->
name|c_ccs
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|c_wakeup
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|c_pr
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|c_mesg
operator|=
name|mesg
expr_stmt|;
return|return
operator|(
name|com
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Malloc and set up a comq entry struct  */
end_comment

begin_function
specifier|static
name|struct
name|ray_comq_entry
modifier|*
name|ray_com_malloc
parameter_list|(
name|ray_comqfn_t
name|function
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|MALLOC
argument_list|(
name|com
argument_list|,
expr|struct
name|ray_comq_entry
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_comq_entry
argument_list|)
argument_list|,
name|M_RAYCOM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
return|return
operator|(
name|ray_com_init
argument_list|(
name|com
argument_list|,
name|function
argument_list|,
name|flags
argument_list|,
name|mesg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an array of commands to the runq, get some ccs's for them and  * then run, waiting on the last command.  *  * We add the commands to the queue first to preserve ioctl ordering.  *  * On any error, this routine simply returns. This ensures that commands  * remain serialised, even though recovery is difficult - but as the  * only failure mechanisms are a signal or detach/stop most callers  * won't bother restarting.  */
end_comment

begin_function
specifier|static
name|int
name|ray_com_runq_add
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
index|[]
parameter_list|,
name|int
name|ncom
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Add the commands to the runq but don't let it run until 	 * the ccs's are allocated successfully 	 */
name|com
index|[
literal|0
index|]
operator|->
name|c_flags
operator||=
name|RAY_COM_FWAIT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
block|{
name|com
index|[
name|i
index|]
operator|->
name|c_wakeup
operator|=
name|com
index|[
name|ncom
operator|-
literal|1
index|]
expr_stmt|;
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
name|com
index|[
name|i
index|]
argument_list|,
literal|"adding"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
index|[
name|i
index|]
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
block|}
name|com
index|[
name|ncom
operator|-
literal|1
index|]
operator|->
name|c_flags
operator|=
name|RAY_COM_FWOK
expr_stmt|;
comment|/* 	 * Allocate ccs's for each command. If we fail, we bail 	 * for the caller to sort everything out. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncom
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|ray_ccs_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|com
index|[
name|i
index|]
operator|->
name|c_ccs
argument_list|,
name|wmesg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Allow the queue to run and if needed sleep 	 */
name|com
index|[
literal|0
index|]
operator|->
name|c_flags
operator|&=
operator|~
name|RAY_COM_FWAIT
expr_stmt|;
name|ray_com_runq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"sleeping"
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|com
index|[
name|ncom
operator|-
literal|1
index|]
argument_list|,
name|PCATCH
argument_list|,
name|wmesg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"awakened, tsleep returned 0x%x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the command at the head of the queue (if not already running)  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
comment|/* XXX this can go later */
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"empty command queue"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FRUNNING
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"command already running"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FWAIT
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"command not ready"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|com
operator|==
name|NULL
operator|)
operator|||
operator|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FRUNNING
operator|)
operator|||
operator|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FWAIT
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
name|com
operator|->
name|c_flags
operator||=
name|RAY_COM_FRUNNING
expr_stmt|;
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
name|com
argument_list|,
literal|"running"
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_function
argument_list|(
name|sc
argument_list|,
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort the execution of a run queue entry and wakeup the  * user level caller.  *  * We do not remove the entry from the runq incase the caller want's to  * retry and to prevent any other commands being run. The user level caller  * must acknowledge the abort.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq_abort
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
if|if
condition|(
name|com
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"com and head of queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
name|com
argument_list|,
literal|"aborting"
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_retval
operator|=
name|reason
expr_stmt|;
name|wakeup
argument_list|(
name|com
operator|->
name|c_wakeup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an aborted command and re-run the queue  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq_clrabort
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
if|if
condition|(
name|com
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"com and head of queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
name|com
argument_list|,
literal|"removing"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
name|ray_com_runq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove run command, free ccs and wakeup caller.  *  * Minimal checks are done here as we ensure that the com and command  * handler were matched up earlier. Must be called at splnet or higher  * so that entries on the command queue are correctly removed.  *  * Remove the com from the comq, and wakeup the caller if it requested  * to be woken. This is used for ensuring a sequence of commands  * completes. Finally, re-run the queue.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_runq_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
comment|/* XXX shall we check this as below */
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
name|com
argument_list|,
literal|"removing"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|,
name|com
argument_list|,
name|c_chain
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_flags
operator|&=
operator|~
name|RAY_COM_FRUNNING
expr_stmt|;
name|com
operator|->
name|c_flags
operator||=
name|RAY_COM_FCOMPLETED
expr_stmt|;
name|com
operator|->
name|c_retval
operator|=
literal|0
expr_stmt|;
name|ray_ccs_free
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
name|com
operator|->
name|c_ccs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|c_flags
operator|&
name|RAY_COM_FWOK
condition|)
name|wakeup
argument_list|(
name|com
operator|->
name|c_wakeup
argument_list|)
expr_stmt|;
name|ray_com_runq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX what about error on completion then? deal with when i fix 	 * XXX the status checking 	 * 	 * XXX all the runq_done calls from IFF_RUNNING checks in runq 	 * XXX routines should return EIO but shouldn't abort the runq 	 */
block|}
end_function

begin_comment
comment|/*  * Send a command to the ECF.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ray_comq_entry
modifier|*
name|com
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
if|if
condition|(
name|com
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"com and head of queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
comment|/* 	 * XXX other drivers did this, but I think  	 * XXX what we really want to do is just make sure we don't 	 * XXX get here or that spinning is ok 	 * 	 * XXX actually we probably want to call a timeout on 	 * XXX ourself here... 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
if|if
condition|(
operator|++
name|i
operator|>
literal|50
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"spun too long"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"spinning"
argument_list|)
expr_stmt|;
name|RAY_DCOM
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
name|com
argument_list|,
literal|"sending"
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAY_COM_NEEDS_TIMO
argument_list|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
argument_list|)
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_COM
argument_list|,
literal|"adding timeout"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Deal with commands that require a timeout to test completion.  *  * This routine is coded to only expect one outstanding request for the  * timed out requests at a time, but thats all that can be outstanding  * per hardware limitations and all that we issue anyway.  *  * We don't do any fancy testing of the command currently issued as we  * know it must be a timeout based one...unless I've got this wrong!  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_timo
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ray_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|u_int8_t
name|cmd
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
comment|/* XXX get rid of this at some point or make it KASSERT */
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"no command queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_COM */
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
condition|)
block|{
case|case
name|RAY_CCS_STATUS_COMPLETE
case|:
case|case
name|RAY_CCS_STATUS_FREE
case|:
comment|/* Buggy firmware */
name|ray_intr_ccs
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CCS_STATUS_BUSY
case|:
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Replicates NetBSD */
if|if
condition|(
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
index|]
operator|==
literal|1
condition|)
block|{
comment|/* give a chance for the interrupt to occur */
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|com
operator|->
name|c_ccs
argument_list|)
index|]
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|com_timerh
operator|=
name|timeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|RAY_COM_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
name|ray_intr_ccs
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|com
operator|->
name|c_ccs
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when interrupt handler for the command has done all it  * needs to. Will be called at splnet.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_done
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_com_ecf_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|com_timerh
argument_list|)
expr_stmt|;
name|ray_com_runq_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_COM
end_if

begin_comment
comment|/*  * Process completed ECF commands that probably came from the command queue  *  * This routine is called after vectoring the completed ECF command  * to the appropriate _done routine. It helps check everything is okay.  */
end_comment

begin_function
specifier|static
name|void
name|ray_com_ecf_check
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
name|struct
name|ray_comq_entry
modifier|*
name|com
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_COM
argument_list|,
literal|"%s"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|com
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_comq
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"no command queue"
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|c_ccs
operator|!=
name|ccs
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"ccs's don't match"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_COM */
end_comment

begin_comment
comment|/*  * CCS allocators  */
end_comment

begin_comment
comment|/*  * Obtain a ccs for a commmand  *  * Returns 0 and in `ccsp' the bus offset of the free ccs. Will block  * awaiting free ccs if needed - if the sleep is interrupted EINTR/ERESTART  * is returned.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ccs_alloc
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
name|RAY_CCS_CMD_FIRST
init|;
name|i
operator|<=
name|RAY_CCS_CMD_LAST
condition|;
name|i
operator|++
control|)
block|{
comment|/* we probe here to make the card go */
operator|(
name|void
operator|)
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|RAY_CCS_CMD_LAST
condition|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"sleeping"
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|ray_ccs_alloc
argument_list|,
name|PCATCH
argument_list|,
name|wmesg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"awakened, tsleep returned 0x%x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
break|break;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"allocated 0x%02x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill the easy bits in of a pre-allocated CCS  */
end_comment

begin_function
specifier|static
name|void
name|ray_ccs_fill
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|,
name|u_int
name|cmd
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccs
operator|==
name|NULL
condition|)
name|RAY_PANIC
argument_list|(
name|sc
argument_list|,
literal|"ccs not allocated"
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up a ccs allocated via ray_ccs_alloc  *  * Return the old status. This routine is only used for ccs allocated via  * ray_ccs_alloc (not tx, rx or ECF command requests).  */
end_comment

begin_function
specifier|static
name|void
name|ray_ccs_free
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
name|ccs
parameter_list|)
block|{
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
operator||
operator|(
name|RAY_DEBUG
operator|&
name|RAY_DBG_CCS
operator|)
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
condition|)
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"freeing free ccs 0x%02x"
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_CCS */
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"freed 0x%02x"
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ray_ccs_alloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Obtain a ccs and tx buffer to transmit with and fill them in.  *  * Returns 0 and in `ccsp' the bus offset of the free ccs. Will not block  * and if none available and will returns EAGAIN.  *  * The caller must fill in the length later.  * The caller must clear the ccs on errors.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ccs_tx
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|size_t
modifier|*
name|ccsp
parameter_list|,
name|size_t
modifier|*
name|bufpp
parameter_list|)
block|{
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CCS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|i
operator|=
name|RAY_CCS_TX_FIRST
expr_stmt|;
do|do
block|{
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RAY_CCS_STATUS_FREE
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<=
name|RAY_CCS_TX_LAST
condition|)
do|;
if|if
condition|(
name|i
operator|>
name|RAY_CCS_TX_LAST
condition|)
block|{
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CCS
argument_list|,
literal|"allocated 0x%02x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve and fill the ccs - must do the length later. 	 * 	 * Even though build 4 and build 5 have different fields all these 	 * are common apart from tx_rate. Neither the NetBSD driver or Linux 	 * driver bother to overwrite this for build 4 cards. 	 * 	 * The start of the buffer must be aligned to a 256 byte boundary 	 * (least significant byte of address = 0x00). 	 */
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|RAY_TX_BASE
operator|+
name|i
operator|*
name|RAY_TX_BUF_SIZE
expr_stmt|;
name|bufp
operator|+=
name|sc
operator|->
name|sc_tibsize
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_cmd
argument_list|,
name|RAY_CMD_TX_REQ
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_bufp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_tx_rate
argument_list|,
name|sc
operator|->
name|sc_c
operator|.
name|np_def_txrate
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_apm_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|bufp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_phy_header
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
operator|*
name|bufpp
operator|=
name|bufp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines to obtain resources for the card  */
end_comment

begin_comment
comment|/*  * Allocate the attribute memory on the card  */
end_comment

begin_function
specifier|static
name|int
name|ray_res_alloc_am
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
operator||
name|RAY_DBG_CM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|am_rid
operator|=
literal|1
expr_stmt|;
comment|/* pccard uses 0 */
name|sc
operator|->
name|am_res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|am_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|0x1000
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|am_res
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Cannot allocate attribute memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Ensure attribute memory settings */
name|error
operator|=
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX card_set_res_flags */
if|if
condition|(
name|error
condition|)
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"CARD_SET_RES_FLAGS returned 0x%0x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|am_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|am_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|am_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|am_res
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
operator|(
name|RAY_DBG_CM
operator||
name|RAY_DBG_BOOTPARAM
operator|)
block|{
name|u_long
name|flags
init|=
literal|0xffff
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX card_get_res_flags */
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"allocated attribute memory:\n"
literal|".  start 0x%0lx count 0x%0lx flags 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG& (RAY_DBG_CM | RAY_DBG_BOOTPARAM) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate the common memory on the card  *  * XXX the pccard manager should get this right eventually and allocate it  * XXX for us - that why I'm using rid == 0  * XXX I might end up just setting these using set_start etc.  */
end_comment

begin_function
specifier|static
name|int
name|ray_res_alloc_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cm_rid
operator|=
literal|0
expr_stmt|;
comment|/* pccard uses 0 */
name|sc
operator|->
name|cm_res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|cm_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|0xc000
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|cm_res
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Cannot allocate common memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Ensure 8bit access */
name|error
operator|=
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* XXX card_set_res_flags */
if|if
condition|(
name|error
condition|)
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"CARD_SET_RES_FLAGS returned 0x%0x"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cm_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|cm_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cm_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|cm_res
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
operator|(
name|RAY_DBG_CM
operator||
name|RAY_DBG_BOOTPARAM
operator|)
block|{
name|u_long
name|flags
init|=
literal|0xffff
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX card_get_res_flags */
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"allocated common memory:\n"
literal|".  start 0x%0lx count 0x%0lx flags 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG& (RAY_DBG_CM | RAY_DBG_BOOTPARAM) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get an irq and attach it to the bus  */
end_comment

begin_function
specifier|static
name|int
name|ray_res_alloc_irq
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_SUBR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Cannot allocate irq"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|ray_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_handle
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Failed to setup irq"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|RAY_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RAY_DBG_CM
operator||
name|RAY_DBG_BOOTPARAM
argument_list|,
literal|"allocated irq:\n"
literal|".  start 0x%0lx count 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release all of the card's resources  */
end_comment

begin_function
specifier|static
name|void
name|ray_res_release
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|!=
literal|0
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|am_res
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
name|sc
operator|->
name|am_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|am_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|cm_res
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
name|sc
operator|->
name|cm_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cm_res
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Hacks for working around the PCCard layer problems.  *  * For NEWBUS kludge and OLDCARD.  *  * We just call the pccard layer to change and restore the mapping each  * time we use the attribute memory.  *  * XXX These could become marcos around bus_activate_resource, but  * XXX the functions do made hacking them around safer.  *  */
end_comment

begin_if
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
end_if

begin_function
specifier|static
name|void
name|ray_attr_mapam
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_activate_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
name|sc
operator|->
name|am_res
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_CM
block|{
name|u_long
name|flags
init|=
literal|0xffff
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX card_get_res_flags */
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"attribute memory\n"
literal|".  start 0x%0lx count 0x%0lx flags 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|am_rid
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_CM */
block|}
end_function

begin_function
specifier|static
name|void
name|ray_attr_mapcm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_activate_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
name|sc
operator|->
name|cm_res
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_CM
block|{
name|u_long
name|flags
init|=
literal|0xffff
decl_stmt|;
name|CARD_GET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX card_get_res_flags */
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"common memory\n"
literal|".  start 0x%0lx count 0x%0lx flags 0x%0lx"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|cm_rid
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RAY_DEBUG& RAY_DBG_CM */
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ray_attr_read_1
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_mapam
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|(
name|u_int8_t
operator|)
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|am_bst
argument_list|,
name|sc
operator|->
name|am_bsh
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ray_attr_mapcm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_attr_write_1
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
block|{
name|ray_attr_mapam
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|am_bst
argument_list|,
name|sc
operator|->
name|am_bsh
argument_list|,
name|offset
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|ray_attr_mapcm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_CM_REMAPPING */
end_comment

begin_comment
comment|/*  * mbuf dump  */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|&
name|RAY_DBG_MBUF
end_if

begin_function
specifier|static
name|void
name|ray_dump_mbuf
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|d
decl_stmt|,
modifier|*
name|ed
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
name|p
index|[
literal|17
index|]
decl_stmt|;
name|RAY_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
literal|17
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|ed
operator|=
name|d
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|ed
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  %s\n\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|%
literal|16
index|]
operator|=
operator|(
operator|(
operator|*
name|d
operator|>=
literal|0x20
operator|)
operator|&&
operator|(
operator|*
name|d
operator|<
literal|0x80
operator|)
operator|)
condition|?
operator|*
name|d
else|:
literal|'.'
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG& RAY_DBG_MBUF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRAY */
end_comment

end_unit

