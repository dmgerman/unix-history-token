begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2000  * Dr. Duncan McLennan Barclay, dmlb@ragnet.demon.co.uk.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DUNCAN BARCLAY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DUNCAN BARCLAY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: if_ray.c,v 1.7 2000/03/05 22:24:30 dmlb Exp $  *  */
end_comment

begin_comment
comment|/*  *  * Card configuration  * ==================  *  * This card is unusual in that it uses both common and attribute  * memory whilst working. The -stable versions of FreeBSD have a real  * problem managing and setting up the correct memory maps. This  * driver should reset the memory maps correctly under PAO and non-PAO  * -stable systems. Work is in hand to fix these problems for -current.  *  * So, if you want to use this driver make sure that  *	options RAY_NEED_CM_FIXUP  *	options RAY_NEED_CM_REMAPPING  * are in your kernel configuration file.  *  * The first fixes the brain deadness of pccardd (where it reads the  * CIS for common memory, sets it all up and then throws it all away  * assuming the card is an ed driver...). Note that this could be  * dangerous (because it doesn't interact with pccardd) if you  * use other memory mapped cards at the same time.  *  * The second option ensures that common memory is remapped whenever  * we are going to access it (we can't just do it once, as something  * like pccardd may have read the attribute memory and pccard.c  * doesn't re-map the last active window - it remaps the last  * non-active window...).  *  *  * Ad-hoc and infra-structure modes  * ================================  *   * At present only the ad-hoc mode is being worked on.  *  * Apart from just writing the code for infrastructure mode I have a  * few concerns about both the Linux and NetBSD drivers in this area.  * They don't seem to differentiate between the MAC address of the AP  * and the BSS_ID of the network. I presume this is handled when  * joining a managed n/w and the network parameters are updated, but  * I'm not sure. How does this interact with ARP? For mobility we want  * to be able to move around without worrying about which AP we are  * actually talking to - we should always talk to the BSS_ID.  *  * The Linux driver also seems to have the capability to act as an AP.  * I wonder what facilities the "AP" can provide within a driver? We can  * probably use the BRIDGE code to form an ESS but I don't think  * power saving etc. is easy.  *  *  * Packet translation/encapsulation  * ================================  *   * Currently we only support the Webgear encapsulation  *	802.11	header<net/if_ieee80211.h>struct ieee80211_header  *	802.3	header<net/ethernet.h>struct ether_header  *	802.2	LLC header  *	802.2	SNAP header  *  * We should support whatever packet types the following drivers have  *   	if_wi.c		FreeBSD, RFC1042  *	if_ray.c	NetBSD	Webgear, RFC1042  *	rayctl.c	Linux Webgear, RFC1042  * also whatever we can divine from the NDC Access points and Kanda's boxes.  *  * Most drivers appear to have a RFC1042 translation. The incoming packet is  *	802.11	header<net/if_ieee80211.h>struct ieee80211_header  *	802.2	LLC header  *	802.2	SNAP header  *  * This is translated to  *	802.3	header<net/ethernet.h>struct ether_header  *	802.2	LLC header  *	802.2	SNAP header  *  * Linux seems to look at the SNAP org_code and do some translations  * for IPX and APPLEARP on that. This just may be how Linux does IPX  * and NETATALK. Need to see how FreeBSD does these.  *  * Translation should be selected via if_media stuff or link types.  */
end_comment

begin_comment
comment|/*  * TODO  *  * _stop - mostly done  *	would be nice to understand shutdown/power save to prevent RX  * _reset - done  * 	just needs calling in the right places  *	converted most panic to resets  *	may be needed in a couple of other places when I do more commands  * havenet - mostly done  *	i think i've got all the places to set it right, but not so sure  *	we reset it in all the right places  * _unload - done  *	recreated most of stop but as card is unplugged don't try and  *	access it  *  * TX bpf  * RX bpf  * shutdown  * promisoius  * multicast  * ifp->if_hdr length  *  * apm  *  * more commands  * ioctls - translation, BSS_ID, countrycode  * faster TX routine  * more translations  * infrastructure mode  * differeniate between parameters set in attach and init  * start_join_done needs a restart in download_done  * spinning in ray_issue_cmd  *  * command tracking - really needed? if not remove SCP_ stuff  * 	will simplify ray_issue_cmd away  */
end_comment

begin_define
define|#
directive|define
name|XXX
value|0
end_define

begin_define
define|#
directive|define
name|XXX_TRACKING
value|0
end_define

begin_define
define|#
directive|define
name|XXX_INFRA
value|0
end_define

begin_define
define|#
directive|define
name|XXX_MCASTPROM
value|0
end_define

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_comment
comment|/*  * RAY_DEBUG settings  *  *	2	Recoverable error's  *	6	Subroutine entry  *	11	Startup CM dump  *	15	State transitions for start/join  *	21	CCS info  *	31	IOCTL calls  *	51	MBUFs dumped/packet types reported  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAY_DOWNLOAD_TIMEOUT
value|(hz/2)
end_define

begin_comment
comment|/* Timeout for CCS commands - only used for downloading startup parameters */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_STARTJOIN_TIMO
value|0
end_define

begin_comment
comment|/* Might be needed with build 4 */
end_comment

begin_define
define|#
directive|define
name|RAY_SJ_TIMEOUT
value|(90*hz)
end_define

begin_comment
comment|/* Timeout for failing STARTJOIN commands - only used with RAY_NEED_STARTJOIN_TIMO */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_CM_FIXUP
value|1
end_define

begin_comment
comment|/* Needed until pccardd hacks for ed drivers are removed (pccardd forces 16bit memory and 0x4000 size) THIS IS A DANGEROUS THING TO USE IF YOU USE OTHER MEMORY MAPPED PCCARDS */
end_comment

begin_define
define|#
directive|define
name|RAY_NEED_CM_REMAPPING
value|1
end_define

begin_comment
comment|/* Needed until pccard maps more than one memory area */
end_comment

begin_define
define|#
directive|define
name|RAY_DUMP_CM_ON_GIFMEDIA
value|1
end_define

begin_comment
comment|/* Dump some common memory when the SIOCGIFMEDIA ioctl is issued - a nasty hack for debugging and will be placed by an ioctl and control program */
end_comment

begin_define
define|#
directive|define
name|RAY_RESET_TIMEOUT
value|(5*hz)
end_define

begin_comment
comment|/* Timeout for resetting the card */
end_comment

begin_define
define|#
directive|define
name|RAY_SIMPLE_TX
value|1
end_define

begin_comment
comment|/* Simple TX routine */
end_comment

begin_define
define|#
directive|define
name|RAY_DECENT_TX
value|0
end_define

begin_comment
comment|/* Decent TX routine - tbd */
end_comment

begin_comment
comment|/*  * XXX build options - move to LINT  */
end_comment

begin_comment
comment|/*  * Debugging odds and odds  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RAY_DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|0
end_if

begin_comment
comment|/* XXX This macro assumes that common memory is mapped into kernel space and  * XXX does not indirect through SRAM macros - it should  */
end_comment

begin_define
define|#
directive|define
name|RAY_DHEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|do { if (RAY_DEBUG> 10) {		\     u_int8_t *i;						\     for (i = p; i< (u_int8_t *)(p+l); i += 8)			\     	printf("  0x%08lx %8D\n",				\ 		(unsigned long)i, (unsigned char *)i, " ");	\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTFN
parameter_list|(
name|l
parameter_list|,
name|x
parameter_list|)
value|do { if (RAY_DEBUG> l) {		\     printf x ;							\ } } while (0)
end_define

begin_define
define|#
directive|define
name|RAY_DNET_DUMP
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
value|do { if (RAY_DEBUG) {			\     printf("ray%d: Network parameters%s\n", (sc)->unit, (s));		\     printf("  bss_id %6D\n", (sc)->sc_bss_id, ":");			\     printf("  inited 0x%02x\n", (sc)->sc_inited);			\     printf("  def_txrate 0x%02x\n", (sc)->sc_def_txrate);		\     printf("  encrypt 0x%02x\n", (sc)->sc_encrypt);			\     printf("  net_type 0x%02x\n", (sc)->sc_net_type);			\     printf("  ssid \"%.32s\"\n", (sc)->sc_ssid);			\     printf("  priv_start 0x%02x\n", (sc)->sc_priv_start);		\     printf("  priv_join 0x%02x\n", (sc)->sc_priv_join);			\ } } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_DHEX8
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DPRINTFN
parameter_list|(
name|l
parameter_list|,
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RAY_DNET_DUMP
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 0 */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|50
end_if

begin_define
define|#
directive|define
name|RAY_DMBUF_DUMP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
value|ray_dump_mbuf((sc), (m), (s))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_DMBUF_DUMP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 10 */
end_comment

begin_include
include|#
directive|include
file|"ray.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NRAY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_rayreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_raymib.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_ieee80211.h>
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cis.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD */
end_comment

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM */
end_comment

begin_comment
comment|/*  * One of these structures per allocated device  */
end_comment

begin_struct
struct|struct
name|ray_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common 		*/
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
comment|/* Ifnet common 		*/
name|struct
name|callout_handle
decl|\
name|timerh
decl_stmt|;
comment|/* Handle for timer		*/
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|struct
name|callout_handle
decl|\
name|sj_timerh
decl_stmt|;
comment|/* Handle for start_join timer	*/
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|struct
name|callout_handle
decl|\
name|start_timerh
decl_stmt|;
comment|/* Handle for start timer	*/
name|char
modifier|*
name|card_type
decl_stmt|;
comment|/* Card model name		*/
name|char
modifier|*
name|vendor
decl_stmt|;
comment|/* Card manufacturer		*/
name|int
name|unit
decl_stmt|;
comment|/* Unit number			*/
name|u_char
name|gone
decl_stmt|;
comment|/* 1 = Card bailed out		*/
name|caddr_t
name|maddr
decl_stmt|;
comment|/* Shared RAM Address		*/
name|int
name|flags
decl_stmt|;
comment|/* Start up flags		*/
name|int
name|translation
decl_stmt|;
comment|/* Packet translation types	*/
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
name|int
name|slotnum
decl_stmt|;
comment|/* Slot number			*/
name|struct
name|mem_desc
name|md
decl_stmt|;
comment|/* Map info for common memory	*/
endif|#
directive|endif
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
name|struct
name|ray_ecf_startup_v5
decl|\
name|sc_ecf_startup
decl_stmt|;
comment|/* Startup info from card	*/
name|u_int8_t
name|sc_ccsinuse
index|[
literal|64
index|]
decl_stmt|;
comment|/* ccss' in use -- not for tx	*/
name|size_t
name|sc_ccs
decl_stmt|;
comment|/* ccs used by non-scheduled,	*/
comment|/* non-overlapping procedures	*/
name|struct
name|ray_cmd_net
name|sc_cnet_1
decl_stmt|;
comment|/* current network params from	*/
name|struct
name|ray_net_params
name|sc_cnet_2
decl_stmt|;
comment|/* starting/joining a network	*/
if|#
directive|if
literal|0
block|u_int8_t		sc_cnwid[IEEE80211_NWID_LEN];
comment|/* Last nwid */
block|u_int8_t		sc_dnwid[IEEE80211_NWID_LEN];
comment|/* Desired nwid */
block|u_int8_t		sc_omode;
comment|/* Old operating mode SC_MODE_xx */
block|u_int8_t		sc_mode;
comment|/* Current operating mode SC_MODE_xx */
block|u_int8_t		sc_countrycode;
comment|/* Current country code */
block|u_int8_t		sc_dcountrycode;
comment|/* Desired country code */
endif|#
directive|endif
name|int
name|sc_havenet
decl_stmt|;
comment|/* true if we have aquired a network */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ray_softc
name|ray_softc
index|[
name|NRAY
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sc_station_addr
value|sc_ecf_startup.e_station_addr
end_define

begin_define
define|#
directive|define
name|sc_version
value|sc_ecf_startup.e_fw_build_string
end_define

begin_define
define|#
directive|define
name|sc_tibsize
value|sc_ecf_startup.e_tibsize
end_define

begin_define
define|#
directive|define
name|sc_upd_param
value|sc_cnet_1.c_upd_param
end_define

begin_define
define|#
directive|define
name|sc_bss_id
value|sc_cnet_1.c_bss_id
end_define

begin_define
define|#
directive|define
name|sc_inited
value|sc_cnet_1.c_inited
end_define

begin_define
define|#
directive|define
name|sc_def_txrate
value|sc_cnet_1.c_def_txrate
end_define

begin_define
define|#
directive|define
name|sc_encrypt
value|sc_cnet_1.c_encrypt
end_define

begin_define
define|#
directive|define
name|sc_net_type
value|sc_cnet_2.p_net_type
end_define

begin_define
define|#
directive|define
name|sc_ssid
value|sc_cnet_2.p_ssid
end_define

begin_define
define|#
directive|define
name|sc_priv_start
value|sc_cnet_2.p_privacy_must_start
end_define

begin_define
define|#
directive|define
name|sc_priv_join
value|sc_cnet_2.p_privacy_can_join
end_define

begin_comment
comment|/* Remember to add to the debug macro and ioctl*/
end_comment

begin_comment
comment|/* XXX might not need these */
end_comment

begin_comment
comment|/* Commands -- priority given to LSB */
end_comment

begin_define
define|#
directive|define
name|SCP_FIRST
value|0x0001
end_define

begin_define
define|#
directive|define
name|SCP_UPDATESUBCMD
value|0x0001
end_define

begin_define
define|#
directive|define
name|SCP_STARTASSOC
value|0x0002
end_define

begin_define
define|#
directive|define
name|SCP_REPORTPARAMS
value|0x0004
end_define

begin_define
define|#
directive|define
name|SCP_IFSTART
value|0x0008
end_define

begin_comment
comment|/* Update sub commands -- issues are serialized priority to LSB */
end_comment

begin_define
define|#
directive|define
name|SCP_UPD_FIRST
value|0x0100
end_define

begin_define
define|#
directive|define
name|SCP_UPD_STARTUP
value|0x0100
end_define

begin_define
define|#
directive|define
name|SCP_UPD_STARTJOIN
value|0x0200
end_define

begin_define
define|#
directive|define
name|SCP_UPD_PROMISC
value|0x0400
end_define

begin_define
define|#
directive|define
name|SCP_UPD_MCAST
value|0x0800
end_define

begin_define
define|#
directive|define
name|SCP_UPD_UPDATEPARAMS
value|0x1000
end_define

begin_define
define|#
directive|define
name|SCP_UPD_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|SCP_UPD_MASK
value|0xff00
end_define

begin_comment
comment|/* These command (a subset of the update set) require timeout checking */
end_comment

begin_define
define|#
directive|define
name|SCP_TIMOCHECK_CMD_MASK
define|\
value|(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \ 	SCP_UPD_PROMISC)
end_define

begin_comment
comment|/*XXX might not need these */
end_comment

begin_comment
comment|/*  * Translation types  */
end_comment

begin_comment
comment|/* XXX maybe better as part of the if structure? */
end_comment

begin_define
define|#
directive|define
name|SC_TRANSLATE_WEBGEAR
value|0
end_define

begin_comment
comment|/*  * PCMCIA driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_init
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_pccard_unload
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_pccard_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
name|dev_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|ray
argument_list|,
name|ray_pccard_init
argument_list|,
name|ray_pccard_unload
argument_list|,
name|ray_pccard_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ISA driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|raydriver
init|=
block|{
name|ray_probe
block|,
name|ray_attach
block|,
literal|"ray"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Network driver definition  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ray_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_init
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_stop
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal utilites  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ray_alloc_ccs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
operator|*
name|ccsp
operator|,
name|u_int
name|cmd
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_ccs_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_params
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_download_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_free_ccs
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_issue_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int
name|track
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_reset
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_reset_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rcs_intr
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_rx
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|rcs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int8_t
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ray_start_wrhdr
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|ether_header
operator|*
name|eh
operator|,
name|size_t
name|bufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_start_join_done
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|size_t
name|ccs
operator|,
name|u_int8_t
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_start_join_timo
name|__P
argument_list|(
operator|(
name|void
operator|*
name|xsc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_STARTJOIN_TIMO */
end_comment

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|50
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_dump_mbuf
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
expr|struct
name|mbuf
operator|*
name|m
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 50 */
end_comment

begin_comment
comment|/*  * Indirections for reading/writing shared memory - from NetBSD/if_ray.c  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((size_t)(&((type *)0)->member))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* offsetof */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|(u_int8_t)*((sc)->maddr + (off))
end_define

begin_comment
comment|/* ((u_int8_t)bus_space_read_1((sc)->sc_memt, (sc)->sc_memh, (off))) */
end_comment

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|SRAM_READ_1(sc, (off) + offsetof(struct s, f))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|((((u_int16_t)SRAM_READ_1(sc, (off) + offsetof(struct s, f))<< 8) \     |(SRAM_READ_1(sc, (off) + 1 + offsetof(struct s, f)))))
end_define

begin_define
define|#
directive|define
name|SRAM_READ_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_read_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_read_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((sc)->maddr + (off), (vp), (n))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|*((sc)->maddr + (off)) = (val)
end_define

begin_comment
comment|/* bus_space_write_1((sc)->sc_memt, (sc)->sc_memh, (off), (val)) */
end_comment

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
define|\
value|SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (v))
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|)
value|do {	\     SRAM_WRITE_1(sc, (off) + offsetof(struct s, f), (((v)>> 8 )& 0xff)); \     SRAM_WRITE_1(sc, (off) + 1 + offsetof(struct s, f), ((v)& 0xff)); \ } while (0)
end_define

begin_define
define|#
directive|define
name|SRAM_WRITE_FIELD_N
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|ray_write_region(sc, (off) + offsetof(struct s, f), (p), (n))
end_define

begin_define
define|#
directive|define
name|ray_write_region
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|vp
parameter_list|,
name|n
parameter_list|)
define|\
value|bcopy((vp), (sc)->maddr + (off), (n))
end_define

begin_comment
comment|/*  * Macro's and constants  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_DOWNLOAD_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_DOWNLOAD_TIMEOUT
value|(hz / 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_START_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_START_TIMEOUT
value|(hz / 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAY_RESET_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|RAY_RESET_TIMEOUT
value|(10 * hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|RAY_SIMPLE_TX
end_if

begin_define
define|#
directive|define
name|RAY_IFQ_MAXLEN
value|(2)
end_define

begin_else
else|#
directive|else
else|if RAY_DECENT_TX
end_else

begin_define
define|#
directive|define
name|RAY_IFQ_MAXLEN
value|(RAY_CCS_TX_LAST+1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAY_CCS_FREE
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
define|\
value|SRAM_WRITE_FIELD_1((sc), (ccs), ray_cmd, c_status, RAY_CCS_STATUS_FREE)
end_define

begin_define
define|#
directive|define
name|RAY_ECF_READY
parameter_list|(
name|sc
parameter_list|)
value|(!(ray_read_reg(sc, RAY_ECFIR)& RAY_ECFIR_IRQ))
end_define

begin_define
define|#
directive|define
name|RAY_ECF_START_CMD
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_ECFIR, RAY_ECFIR_IRQ)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_CLEAR_INTR
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_write((sc), RAY_HCSIR, 0)
end_define

begin_define
define|#
directive|define
name|RAY_HCS_INTR
parameter_list|(
name|sc
parameter_list|)
value|(ray_read_reg(sc, RAY_HCSIR)& RAY_HCSIR_IRQ)
end_define

begin_comment
comment|/*  * XXX  * As described in if_xe.c...  *  * Horrid stuff for accessing CIS tuples and remapping common memory...  * XXX  */
end_comment

begin_define
define|#
directive|define
name|CARD_MAJOR
value|50
end_define

begin_decl_stmt
specifier|static
name|int
name|ray_attr_write
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
name|byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ray_attr_read
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|offset
operator|,
name|u_int8_t
operator|*
name|buf
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ray_read_reg
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|,
name|off_t
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
end_if

begin_decl_stmt
specifier|static
name|void
name|ray_attr_getmap
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ray_attr_cm
name|__P
argument_list|(
operator|(
expr|struct
name|ray_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
value|ray_attr_cm(sc)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAY_MAP_CM
parameter_list|(
name|sc
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
end_comment

begin_comment
comment|/*  * PCCard initialise.  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_init
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|doRemap
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: PCCard probe\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NRAY
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
name|sc
operator|->
name|slotnum
operator|=
name|dev_p
operator|->
name|slt
operator|->
name|slotnum
expr_stmt|;
name|ray_attr_getmap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: Memory window flags 0x%02x, start %p, size 0x%x, card address 0x%lx\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|sc
operator|->
name|md
operator|.
name|flags
operator|,
name|sc
operator|->
name|md
operator|.
name|start
operator|,
name|sc
operator|->
name|md
operator|.
name|size
operator|,
name|sc
operator|->
name|md
operator|.
name|card
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
if|#
directive|if
name|RAY_NEED_CM_FIXUP
name|doRemap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|start
operator|==
literal|0x0
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: pccardd did not map CM - giving up\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|flags
operator|!=
name|MDF_ACTIVE
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM flags from 0x%x to 0x40\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|flags
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|flags
operator|=
name|MDF_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|size
operator|!=
literal|0xc000
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM size from 0x%x to 0xc000\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|size
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|size
operator|=
literal|0xc000
expr_stmt|;
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
operator|=
name|sc
operator|->
name|md
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|md
operator|.
name|card
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Fixing up CM card address from 0x%lx to 0x0\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|md
operator|.
name|card
argument_list|)
expr_stmt|;
name|doRemap
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|card
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doRemap
condition|)
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_FIXUP */
name|sc
operator|->
name|gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|maddr
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
name|dev_p
operator|->
name|isahd
operator|.
name|id_flags
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d:<Raylink/IEEE 802.11> maddr %p msize 0x%x irq %d flags 0x%x on isa (PC-Card slot %d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|maddr
argument_list|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_msize
argument_list|,
name|ffs
argument_list|(
name|dev_p
operator|->
name|isahd
operator|.
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|sc
operator|->
name|flags
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ray_attach
argument_list|(
operator|&
name|dev_p
operator|->
name|isahd
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCCard unload.  */
end_comment

begin_function
specifier|static
name|void
name|ray_pccard_unload
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: PCCard unload\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: already unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Clear out timers and sort out driver state      */
name|untimeout
argument_list|(
name|ray_download_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|timerh
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|untimeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/*      * Mark as not running      */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/*      * Cleardown interface      */
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX should be if_detach for -current */
comment|/*      * Mark card as gone      */
name|sc
operator|->
name|gone
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: unloaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * PCCard interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|ray_pccard_intr
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|ccsi
decl_stmt|,
name|handled
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: PCCard intr\n"
operator|,
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before interrupt!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Check that the interrupt was for us, if so get the rcs/ccs and vector      * on the command contained within it.      */
if|if
condition|(
operator|!
name|RAY_HCS_INTR
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|handled
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|handled
operator|=
literal|1
expr_stmt|;
name|ccsi
operator|=
name|SRAM_READ_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_RCSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccsi
operator|<=
name|RAY_CCS_LAST
condition|)
name|ray_ccs_done
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|ccsi
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ccsi
operator|<=
name|RAY_RCS_LAST
condition|)
name|ray_rcs_intr
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|ccsi
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ray%d: ray_intr bad ccs index %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ccsi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handled
condition|)
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ray%d: interrupt %s handled\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|handled
condition|?
literal|"was"
else|:
literal|"not"
operator|)
argument_list|)
expr_stmt|;
comment|/* Send any packets lying around */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|handled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ISA probe routine.  */
end_comment

begin_function
specifier|static
name|int
name|ray_probe
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ISA probe\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ISA/PCCard attach.  */
end_comment

begin_function
specifier|static
name|int
name|ray_attach
parameter_list|(
name|dev_p
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ISA/PCCard attach\n"
operator|,
name|dev_p
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ray_softc
index|[
name|dev_p
operator|->
name|id_unit
index|]
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before attach!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*      * Read startup results, check the card is okay and work out what      * version we are using.      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
literal|"\020"
comment|/* print in hex */
literal|"\001RESERVED0"
literal|"\002PROC_SELF_TEST"
literal|"\003PROG_MEM_CHECKSUM"
literal|"\004DATA_MEM_TEST"
literal|"\005RX_CALIBRATION"
literal|"\006FW_VERSION_COMPAT"
literal|"\007RERSERVED1"
literal|"\008TEST_COMPLETE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_version
operator|!=
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unsupported firmware version 0x%0x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
operator|||
name|RAY_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Start Up Results\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|printf
argument_list|(
literal|"  Firmware version 4\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  Firmware version 5\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Status 0x%x\n"
argument_list|,
name|ep
operator|->
name|e_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Ether address %6D\n"
argument_list|,
name|ep
operator|->
name|e_station_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_rates
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_resv0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Supported rates %8D\n"
argument_list|,
name|ep
operator|->
name|e_rates
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  Japan call sign %12D\n"
argument_list|,
name|ep
operator|->
name|e_japan_callsign
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_5
condition|)
block|{
name|printf
argument_list|(
literal|"  Program checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_prg_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CIS checksum %0x\n"
argument_list|,
name|ep
operator|->
name|e_cis_cksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware version %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build_string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Firmware revision %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (reserved word) %0x\n"
argument_list|,
name|ep
operator|->
name|e_fw_resv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ASIC version %0x\n"
argument_list|,
name|ep
operator|->
name|e_asic_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  TIB size %0x\n"
argument_list|,
name|ep
operator|->
name|e_tibsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Set the parameters that will survive stop/init      *      * Do not update these in ray_init's parameter setup      */
if|#
directive|if
name|XXX
name|see
name|the
name|ray_init
name|section
for|for stuff to move
endif|#
directive|endif
comment|/*      * Initialise the network interface structure      */
for|bcopy
control|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|e_station_addr
operator|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|,
name|ETHER_ADDR_LEN
control|)
empty_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ray"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator|)
expr_stmt|;
comment|/* XXX - IFF_MULTICAST */
if|#
directive|if
name|XXX
name|ifp
operator|->
name|if_hdr
operator|=
operator|...
expr_stmt|;
name|make
name|this
name|big
name|enough
name|to
name|hold
name|the
literal|.11
name|and
literal|.3
name|headers
endif|#
directive|endif
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000
expr_stmt|;
comment|/* Is this baud or bps ;-) */
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ray_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ray_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ray_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ray_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|RAY_IFQ_MAXLEN
expr_stmt|;
comment|/*      * If this logical interface has already been attached,      * don't attach it again or chaos will ensue.      */
name|sprintf
argument_list|(
name|ifname
argument_list|,
literal|"ray%d"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifunit
argument_list|(
name|ifname
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|timerh
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBFFILTER */
if|#
directive|if
name|XXX
name|this
name|looks
name|like
name|a
name|good
name|idea
name|at_shutdown
argument_list|(
name|ray_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* XXX */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Network start.  *  * Start sending a packet.  *  * We make two assumptions here:  *  1) That the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) That the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|ray_start
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|size_t
name|ccs
decl_stmt|,
name|bufp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pktlen
decl_stmt|,
name|len
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network start\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Some simple checks first      */
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before start!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|!
name|sc
operator|->
name|sc_havenet
condition|)
return|return;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_start busy, schedule a timeout\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|start_timerh
operator|=
name|timeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|RAY_START_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
comment|/*      * Simple one packet at a time TX routine - probably appaling performance      * and we certainly chew CPU. However bing to windows boxes shows      * a reliance on the far end too:      *      * Libretto 50CT (75MHz Pentium) with FreeBSD-3.1 to      *   Nonname box Windows 95C (133MHz AMD 5x86) 		 996109bps      *   AST J30 Windows 95A (100MHz Pentium) 			1307791bps      *      * Flow is      *		get a ccs      *		build the packet      *		set IFF_OACTIVE      *		interrupt the card to send the packet      *		exit      *      *		wait for interrupt telling us the packet has been sent      *		clear IFF_OACTIVE      *		get called by the interrupt routine if any packets left      */
comment|/*      * Find a free ccs; if none available wave good bye and exit.      *      * We find a ccs before we process the mbuf so that we are sure it      * is worthwhile processing the packet. All errors in the mbuf      * processing are either errors in the mbuf or gross configuration      * errors and the packet wouldn't get through anyway.      *      * Don't forget to clear the ccs on errors.      */
name|i
operator|=
name|RAY_CCS_TX_FIRST
expr_stmt|;
do|do
block|{
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RAY_CCS_STATUS_FREE
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<=
name|RAY_CCS_TX_LAST
condition|)
do|;
if|if
condition|(
name|i
operator|>
name|RAY_CCS_TX_LAST
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_start using ccs 0x%02x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Reserve and fill the ccs - must do the length later.      *      * Even though build 4 and build 5 have different fields all these      * are common apart from tx_rate. This will be overwritten later if      * needed.      */
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|RAY_TX_BASE
operator|+
name|i
operator|*
name|RAY_TX_BUF_SIZE
expr_stmt|;
name|bufp
operator|+=
name|sc
operator|->
name|sc_tibsize
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_cmd
argument_list|,
name|RAY_CMD_TX_REQ
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_bufp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_tx_rate
argument_list|,
name|sc
operator|->
name|sc_def_txrate
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_apm_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_antenna
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_phy_header
argument_list|)
expr_stmt|;
comment|/*      * Get the mbuf and process it - we have to remember to free the      * ccs if there are any errors      */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|pktlen
operator|=
literal|0
operator|,
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: mbuf too long %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Translation - capability as described earlier      *      * Each case must write the 802.11 header using ray_start_wrhdr,      * passing a pointer to the ethernet header in and getting a new      * tc buffer pointer. Next remove/modify/addto the 802.3 and 802.2      * headers as needed.      *      * We've pulled up the mbuf for you.      */
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_start could not pullup ether\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|translation
condition|)
block|{
case|case
name|SC_TRANSLATE_WEBGEAR
case|:
name|bufp
operator|=
name|ray_start_wrhdr
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_start unknown translation type 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|translation
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m0
operator|=
name|m_free
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_start could not translate mbuf\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|pktlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
expr_stmt|;
comment|/*      * Copy the mbuf to the buffer in common memory      *      * We panic and don't bother wrapping as ethernet packets are 1518      * bytes, we checked the mbuf earlier, and our TX buffers are 2048      * bytes. We don't have 530 bytes of headers etc. so something      * must be fubar.      */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|pktlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bufp
operator|+
name|len
operator|)
operator|<
name|RAY_TX_END
condition|)
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ray%d: ray_start tx buffer overflow\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
name|RAY_DMBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
literal|"ray_start"
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/*      * Fill in a few loose ends and kick the card to send the packet      */
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 	 * From NetBSD code: 	 * 	 * If this can really happen perhaps we need to save 	 * the chain and use it later.  I think this might 	 * be a confused state though because we check above 	 * and don't issue any commands between. 	 */
name|printf
argument_list|(
literal|"ray%d: ray_tx device busy\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
name|SRAM_WRITE_FIELD_2
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_tx
argument_list|,
name|c_len
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* XXX but the translation code dicks around with the mbuf structure sigh */
comment|/* XXX and I've freed the mbuf already */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* XXX */
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|XXX
end_if

begin_decl_stmt
name|netbsd
name|driver
name|uses
name|a
name|loop
name|repeat
name|get
name|a
name|ccs
name|get
name|a
name|mbuf
name|translate
name|and
name|send
name|packet
name|to
name|shared
name|ram
name|until
argument_list|(
name|no
name|more
name|ccs
literal|'s) || (no more mbuf'
name|s
argument_list|)
name|send
name|ccs
name|chain
name|to
name|card
name|exit
name|Linux
name|driver
name|is
name|simple
name|single
name|shot
name|packet
argument_list|(
name|with
name|a
name|lot
name|of
name|spinlocks
operator|!
argument_list|)
name|general
name|the
name|tx
name|space
name|is
decl|0x7000
init|=
literal|28kB
decl_stmt|,
name|and
name|TX
name|buffer
name|size
name|is
decl|2048
name|so
name|there
name|can
name|be
decl|14
name|requests
name|at
decl|2kB
name|each
name|from
name|this
decl|2k
name|we
name|have
name|to
name|remove
name|the
name|TIB
decl|-
name|whatever
name|that
name|is
decl|- for
name|data
name|netbsd
range|:
name|we
name|need
name|to
name|call
name|_start
name|after
name|receiveing
name|a
name|packet
name|to
name|see
end_decl_stmt

begin_if
if|if any packets were queued whilst in the interrupt  	there is a potential race in obtaining ccss for the tx
operator|,
name|in
name|that
name|we
name|might
name|be
name|in
name|_start
name|synchronously
name|and
name|then
name|an
name|rx
name|interrupt
name|occurs
operator|.
name|the
name|rx
name|will
name|call
name|_start
name|and
name|steal
name|tx
name|ccs
name|from
name|underneath
name|the
name|interrupted
name|entry
operator|.
name|toptions
name|dont
name|call
name|_start
name|from
name|rx
name|interrupt
name|find
name|a
name|safe
name|way
name|of
name|locking
name|find
name|a
name|better
name|way
name|of
name|obtaining
name|ccs
name|using
name|next
name|free
name|avilable
condition|?
name|look
name|at
name|other
name|drivers
name|use
name|tsleep
operator|/
name|wakeup
name|some
name|form
name|of
name|ring
name|to
name|hold
name|ccs
name|free
name|lsit
name|rework
name|calling
endif|#
directive|endif
comment|/*  * TX completion routine.  *  * Clear ccs and network flags.  */
specifier|static
name|void
name|ray_start_done
argument_list|(
argument|sc
argument_list|,
argument|ccs
argument_list|,
argument|status
argument_list|)
expr|struct
name|ray_softc
operator|*
name|sc
expr_stmt|;
end_if

begin_decl_stmt
name|size_t
name|ccs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8_t
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
modifier|*
name|status_string
index|[]
init|=
name|RAY_CCS_STATUS_STRINGS
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RAY_CCS_STATUS_COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_start tx completed but status is %s.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|status_string
index|[
name|status
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Start timeout routine.  *  * Used when card was busy but we needed to send a packet.  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ray_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Write an 802.11 header into the TX buffer and return the  * adjusted buffer pointer.  */
end_comment

begin_function
specifier|static
name|size_t
name|ray_start_wrhdr
parameter_list|(
name|sc
parameter_list|,
name|eh
parameter_list|,
name|bufp
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|size_t
name|bufp
decl_stmt|;
block|{
name|struct
name|ieee80211_header
name|header
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_wrhdr\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
name|header
operator|.
name|i_fc
index|[
literal|0
index|]
operator|=
operator|(
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
block|{
name|header
operator|.
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_STA_TO_STA
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|header
operator|.
name|i_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|header
operator|.
name|i_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_bss_id
argument_list|,
name|header
operator|.
name|i_addr3
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|XXX_INFRA
if|if
condition|(
name|sc
operator|->
name|sc_ap_status
operator|==
name|RAY_MIB_AP_STATUS_TERMINAL
condition|)
block|{
name|header
operator|.
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_STA_TO_AP
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_bss_id
argument_list|,
name|header
operator|.
name|i_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|header
operator|.
name|i_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|header
operator|.
name|i_addr3
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"ray%d: ray_start can't be an AP yet\n"
argument_list|,
name|sc
operator|-
operator|.
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_INFRA */
block|}
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bufp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Network ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|ray_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network ioctl\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before ioctl!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl SIFADDR/GIFADDR/SIFMTU\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: for SIFFLAGS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * If the interface is marked up and stopped, then start 	     * it. If it is marked down and running, then stop it. 	     */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* DROP THROUGH */
if|#
directive|if
name|XXX
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for ADDMULTI/DELMULTI\n, sc->unit"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * Multicast list has (maybe) changed; set the hardware filter 	     * accordingly. This also serves to deal with promiscuous mode 	     * if we have a BPF listener active. 	     */
name|ray_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFFLAGS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFFLAGS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMETRIC
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFMETRIC\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMTU
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFMTU\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFPHYS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFPYHS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for SIFMEDIA\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|RAY_DPRINTFN
argument_list|(
literal|30
argument_list|,
operator|(
literal|"ray%d: ioctl called for GIFMEDIA\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_DUMP_CM_ON_GIFMEDIA
name|RAY_DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ray%d: RAY_SCB\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_DHEX8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|maddr
operator|+
name|RAY_SCB_BASE
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"ray%d: RAY_STATUS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_DNET_DUMP
argument_list|(
name|sc
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_DUMP_CM_ON_GIFMEDIA */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_watchdog
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network watchdog\n"
operator|,
name|ifp
operator|->
name|if_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before watchdog!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ray%d: watchdog timeout\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX may need to have remedial action here    for example    	ray_reset 	    ray_stop 	    ... 	    ray_init      do we only use on TX?     	if so then we should clear OACTIVE etc.  */
return|return;
block|}
end_function

begin_comment
comment|/*  * Network initialisation.  *  * Start up flow is as follows.  * The kernel calls ray_init when the interface is assigned an address.  *   * ray_init does a bit of house keeping before calling ray_download_params.  *  * ray_download_params fills the startup parameter structure out and  * sends it to the card. The download command simply completes so we  * use schedule a timeout function call to ray_download_timo instead  * of spin locking. We pass the ccs in use via sc->sc_css.  *  * ray_download_timo checks the ccs for command completion and/or  * errors. Then it tells the card to start an adhoc network or join a  * managed network. This should complete via the interrupt mechanism,  * but the NetBSD driver includes a timeout for some buggy stuff  * somewhere - I've left the hooks in but don't use them. The interrupt  * handler passes control to ray_start_join_done - the ccs is handled  * by the interrupt mechanism.  *  * Once ray_start_join_done has checked the ccs and uploaded/updated  * the network parameters we are ready to process packets. It is then  * safe to call ray_start which is done by the interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ray_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ray_ecf_startup_v5
modifier|*
name|ep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network init\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before init!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Reset instance variables      *      * The first set are network parameters that are fully initialised      * when the card starts or joins the network.      *      * The second set are network parameters that are downloaded to      * the card.      *      * The third set are driver parameters.      *      * All of the variables in these sets can be updated by the card or ioctls.      */
if|#
directive|if
name|XXX
name|see
name|the
name|ray_attach
name|section
for|for stuff to move
endif|#
directive|endif
for|sc->sc_upd_param = 0
empty_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_bss_id
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_bss_id
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inited
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_def_txrate
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_encrypt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_net_type
operator|=
name|RAY_MIB_NET_TYPE_DEFAULT
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ssid
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ssid
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|sc_ssid
argument_list|,
name|RAY_MIB_SSID_DEFAULT
argument_list|,
name|RAY_MAXSSIDLEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_priv_start
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|sc
operator|->
name|sc_priv_join
operator|=
name|RAY_MIB_PRIVACY_CAN_JOIN_DEFAULT
expr_stmt|;
if|#
directive|if
name|XXX_MCASTPROM
name|sc
operator|->
name|sc_promisc
operator|=
operator|!
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_MCASTPROM */
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|translation
operator|=
name|SC_TRANSLATE_WEBGEAR
expr_stmt|;
comment|/* Set all ccs to be free */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ccsinuse
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccs
operator|=
name|RAY_CCS_LAST
operator|+
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAY_CCS_LAST
condition|;
name|ccs
operator|+=
name|RAY_CCS_SIZE
operator|,
name|i
operator|++
control|)
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|Not
name|sure
name|why
name|I
name|really
name|need
name|this
operator|-
name|maybe
name|best
name|to
name|deal
name|with
name|this
name|when
name|resets
name|are
name|requested
name|by
name|me
condition|?
endif|#
directive|endif
comment|/* XXX */
comment|/*      * Get startup results - the card may have been reset      */
name|ep
operator|=
operator|&
name|sc
operator|->
name|sc_ecf_startup
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_ECF_TO_HOST_BASE
argument_list|,
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecf_startup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_status
operator|!=
name|RAY_ECFS_CARD_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: card failed self test: status 0x%b\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|ep
operator|->
name|e_status
argument_list|,
literal|"\020"
comment|/* print in hex */
literal|"\001RESERVED0"
literal|"\002PROC_SELF_TEST"
literal|"\003PROG_MEM_CHECKSUM"
literal|"\004DATA_MEM_TEST"
literal|"\005RX_CALIBRATION"
literal|"\006FW_VERSION_COMPAT"
literal|"\007RERSERVED1"
literal|"\008TEST_COMPLETE"
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX This doesn't mark the interface as down */
block|}
comment|/*      * Fixup tib size to be correct - on build 4 it is garbage      */
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
operator|&&
name|sc
operator|->
name|sc_tibsize
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_tibsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ray_tx_tib
argument_list|)
expr_stmt|;
comment|/*      * We are now up and running. Next we have to download network      * configuration into the card. We are busy until download is done.      */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
expr_stmt|;
name|ray_download_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Network stop.  *  * Assumes that a ray_init is used to restart the card.  *  */
end_comment

begin_function
specifier|static
name|void
name|ray_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Network stop\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: unloaded before stop!\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/*      * Clear out timers and sort out driver state      */
name|untimeout
argument_list|(
name|ray_download_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|timerh
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|timerh
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|untimeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|untimeout
argument_list|(
name|ray_start_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|start_timerh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/*      * Inhibit card - if we can't prevent reception then do not worry;      * stopping a NIC only guarantees no TX.      */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* XXX what does the SHUTDOWN command do? Or power saving in COR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*      * Mark as not running      */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Reset the card  *  * I'm using the soft reset command in the COR register. I'm not sure  * if the sequence is right but it does seem to do the right thing. A  * nano second after reset is written the flashing light goes out, and  * a few seconds after the default is written the main card light goes  * out. We wait a while and then re-init the card.  */
end_comment

begin_function
specifier|static
name|void
name|ray_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_reset\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ray_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ray%d: resetting card\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_attr_write
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|RAY_COR
argument_list|,
name|RAY_COR_RESET
argument_list|)
expr_stmt|;
name|ray_attr_write
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|RAY_COR
argument_list|,
name|RAY_COR_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timerh
operator|=
name|timeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|RAY_RESET_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Finishing resetting and restarting the card  */
end_comment

begin_function
specifier|static
name|void
name|ray_reset_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_reset_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_reset_timo still busy, re-schedule\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timerh
operator|=
name|timeout
argument_list|(
name|ray_reset_timo
argument_list|,
name|sc
argument_list|,
name|RAY_RESET_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|RAY_HCS_CLEAR_INTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process CCS command completion - called from ray_intr  */
end_comment

begin_function
specifier|static
name|void
name|ray_ccs_done
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
block|{
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ccs idx %d ccs 0x%x cmd 0x%x status %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|,
name|ccs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_CMD_START_PARAMS
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got START_PARAMS - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_PARAMS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_REPORT_PARAMS
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got REPORT_PARAMS\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_MCAST
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_MCAST\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_UPDATE_APM
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got UPDATE_APM\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_NET
case|:
case|case
name|RAY_CMD_JOIN_NET
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got START|JOIN_NET\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_start_join_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_ASSOC
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got START_ASSOC\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_CMD_TX_REQ
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_ccs_done got TX_REQ\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_start_done
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
case|case
name|RAY_CMD_TEST_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got TEST_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_SHUTDOWN
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got SHUTDOWN - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_DUMP_MEM
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got DUMP_MEM - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CMD_START_TIMER
case|:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done got START_TIMER - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_ccs_done unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process ECF command request - called from ray_intr  */
end_comment

begin_function
specifier|static
name|void
name|ray_rcs_intr
parameter_list|(
name|sc
parameter_list|,
name|rcs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|rcs
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|status
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: rcs idx %d rcs 0x%x cmd 0x%x status %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
operator|,
name|rcs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAY_ECMD_RX_DONE
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got RX_DONE\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ray_rx
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_REJOIN_DONE
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got REJOIN_DONE\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_ROAM_START
case|:
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_rcs_intr got ROAM_START\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
comment|/* Should not be here but in function */
name|XXX
expr_stmt|;
break|break;
case|case
name|RAY_ECMD_JAPAN_CALL_SIGNAL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr got JAPAN_CALL_SIGNAL - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rcs_intr unknown command 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Receive a packet  */
end_comment

begin_function
specifier|static
name|void
name|ray_rx
parameter_list|(
name|sc
parameter_list|,
name|rcs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|rcs
decl_stmt|;
block|{
name|struct
name|ieee80211_header
modifier|*
name|header
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|size_t
name|pktlen
decl_stmt|,
name|fraglen
decl_stmt|,
name|readlen
decl_stmt|,
name|tmplen
decl_stmt|;
name|size_t
name|bufp
decl_stmt|,
name|ebufp
decl_stmt|;
name|u_int8_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|u_int8_t
name|fc
decl_stmt|;
name|u_int
name|first
decl_stmt|,
name|ni
decl_stmt|,
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_rx\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: rcs chain - using rcs 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|rcs
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|readlen
operator|=
literal|0
expr_stmt|;
comment|/*      * Get first part of packet and the length. Do some sanity checks      * and get a mbuf.      */
name|first
operator|=
name|RAY_CCS_INDEX
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pktlen
operator|>
name|MCLBYTES
operator|)
operator|||
operator|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
operator|)
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx packet is too big or too small\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx MGETHDR failed\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
name|pktlen
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx MCLGET failed\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pktlen
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
name|dst
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
comment|/*      * Walk the fragment chain to build the complete packet.      *      * The use of two index variables removes a race with the      * hardware. If one index were used the clearing of the CCS would      * happen before reading the next pointer and the hardware can get in.      * Not my idea but verbatim from the NetBSD driver.      */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_bufp
argument_list|)
expr_stmt|;
name|fraglen
operator|=
name|SRAM_READ_FIELD_2
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|50
argument_list|,
operator|(
literal|"ray%d: ray_rx frag index %d len %d bufp 0x%x ni %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|i
operator|,
name|fraglen
operator|,
operator|(
name|int
operator|)
name|bufp
operator|,
name|ni
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fraglen
operator|+
name|readlen
operator|>
name|pktlen
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx bad length current 0x%x pktlen 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|fraglen
operator|+
name|readlen
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|RAY_RCS_FIRST
operator|)
operator|||
operator|(
name|i
operator|>
name|RAY_RCS_LAST
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_rx bad rcs index 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|skip_read
goto|;
block|}
name|ebufp
operator|=
name|bufp
operator|+
name|fraglen
expr_stmt|;
if|if
condition|(
name|ebufp
operator|<=
name|RAY_RX_END
condition|)
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
name|fraglen
argument_list|)
expr_stmt|;
else|else
block|{
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|bufp
argument_list|,
name|dst
argument_list|,
operator|(
name|tmplen
operator|=
name|RAY_RX_END
operator|-
name|bufp
operator|)
argument_list|)
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_RX_BASE
argument_list|,
name|dst
operator|+
name|tmplen
argument_list|,
name|ebufp
operator|-
name|RAY_RX_END
argument_list|)
expr_stmt|;
block|}
name|dst
operator|+=
name|fraglen
expr_stmt|;
name|readlen
operator|+=
name|fraglen
expr_stmt|;
block|}
name|skip_read
label|:
comment|/*      * Walk the chain again to free the rcss.      */
name|i
operator|=
name|ni
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ni
operator|)
operator|&&
operator|(
name|i
operator|!=
name|RAY_CCS_LINK_NULL
operator|)
condition|)
block|{
name|rcs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ni
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd_rx
argument_list|,
name|c_nextfrag
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|rcs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_FREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return;
name|RAY_DMBUF_DUMP
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
literal|"ray_rx"
argument_list|)
expr_stmt|;
comment|/*      * Check the 802.11 packet type and obtain the .11 src addresses.      *      * XXX CTL and MGT packets will have separate functions, DATA with here      *      * XXX This needs some work for INFRA mode      */
name|header
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_header
operator|*
argument_list|)
expr_stmt|;
name|fc
operator|=
name|header
operator|->
name|i_fc
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fc
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: header not version 0 fc 0x%x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|fc
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|fc
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a MGT packet - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a CTL packet - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|RAY_DPRINTFN
argument_list|(
literal|50
argument_list|,
operator|(
literal|"ray%d: ray_rx got a DATA packet\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx got a unknown packet fc0 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
name|fc
operator|=
name|header
operator|->
name|i_fc
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|fc
operator|&
name|IEEE80211_FC1_DS_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_STA_TO_STA
case|:
name|src
operator|=
name|header
operator|->
name|i_addr2
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|50
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from sta %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|src
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_STA_TO_AP
case|:
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from sta %6D to ap %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|header
operator|->
name|i_addr2
operator|,
literal|":"
operator|,
name|header
operator|->
name|i_addr3
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_AP_TO_STA
case|:
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx packet from ap %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|header
operator|->
name|i_addr3
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_AP_TO_AP
case|:
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_rx saw packet between aps %6D %6D\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|header
operator|->
name|i_addr1
operator|,
literal|":"
operator|,
name|header
operator|->
name|i_addr2
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx packet type unknown fc1 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|fc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Translation - capability as described earlier      *      * Each case must remove the 802.11 header and leave an 802.3      * header in the mbuf copy addresses as needed.      */
switch|switch
condition|(
name|sc
operator|->
name|translation
condition|)
block|{
case|case
name|SC_TRANSLATE_WEBGEAR
case|:
comment|/* Nice and easy - just trim the 802.11 header */
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_header
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_rx unknown translation type 0x%x - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|translation
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Finally, do a bit of house keeping before sending the packet      * up the stack.      */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBPFILTER */
if|#
directive|if
name|XXX
name|if_wi
operator|.
name|c
operator|-
name|might
name|be
name|needed
if|if we hear our own broadcasts in promiscuous mode but will not be if we dont see them 	if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* XXX */
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Download start up structures to card.  *  * Part of ray_init, download, startjoin control flow.  */
end_comment

begin_function
specifier|static
name|void
name|ray_download_params
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ray_mib_4
name|ray_mib_4_default
decl_stmt|;
name|struct
name|ray_mib_5
name|ray_mib_5_default
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: Downloading startup parameters\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_TRACKING
name|ray_cmd_cancel
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_TRACKING */
define|#
directive|define
name|MIB4
parameter_list|(
name|m
parameter_list|)
value|ray_mib_4_default.##m
define|#
directive|define
name|MIB5
parameter_list|(
name|m
parameter_list|)
value|ray_mib_5_default.##m
define|#
directive|define
name|PUT2
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do { (p)[0] = ((v>> 8)& 0xff); (p)[1] = (v& 0xff); } while(0)
comment|/*       * Firmware version 4 defaults - see if_raymib.h for details       */
name|MIB4
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_net_type
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|strncpy
argument_list|(
name|MIB4
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ssid
argument_list|,
name|RAY_MAXSSIDLEN
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB4
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V4
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V4
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V4
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB4
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB4
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_max
argument_list|)
operator|=
name|RAY_MIB_CW_MAX_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_cw_min
argument_list|)
operator|=
name|RAY_MIB_CW_MIN_V4
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB4
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
comment|/*       * Firmware version 5 defaults - see if_raymib.h for details       */
name|MIB5
argument_list|(
name|mib_net_type
argument_list|)
operator|=
name|sc
operator|->
name|sc_net_type
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ap_status
argument_list|)
operator|=
name|RAY_MIB_AP_STATUS_DEFAULT
expr_stmt|;
name|strncpy
argument_list|(
name|MIB5
argument_list|(
name|mib_ssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ssid
argument_list|,
name|RAY_MAXSSIDLEN
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_scan_mode
argument_list|)
operator|=
name|RAY_MIB_SCAN_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_apm_mode
argument_list|)
operator|=
name|RAY_MIB_APM_MODE_DEFAULT
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_station_addr
argument_list|,
name|MIB5
argument_list|(
name|mib_mac_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_frag_thresh
argument_list|)
argument_list|,
name|RAY_MIB_FRAG_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_dwell_time
argument_list|)
argument_list|,
name|RAY_MIB_DWELL_TIME_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_beacon_period
argument_list|)
argument_list|,
name|RAY_MIB_BEACON_PERIOD_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_dtim_interval
argument_list|)
operator|=
name|RAY_MIB_DTIM_INTERVAL_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_max_retry
argument_list|)
operator|=
name|RAY_MIB_MAX_RETRY_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_ack_timo
argument_list|)
operator|=
name|RAY_MIB_ACK_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sifs
argument_list|)
operator|=
name|RAY_MIB_SIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_difs
argument_list|)
operator|=
name|RAY_MIB_DIFS_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_pifs
argument_list|)
operator|=
name|RAY_MIB_PIFS_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_rts_thresh
argument_list|)
argument_list|,
name|RAY_MIB_RTS_THRESH_DEFAULT
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_DWELL_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_scan_max_dwell
argument_list|)
argument_list|,
name|RAY_MIB_SCAN_MAX_DWELL_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_assoc_timo
argument_list|)
operator|=
name|RAY_MIB_ASSOC_TIMO_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_ADHOC_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_super_scan_cycle
argument_list|)
operator|=
name|RAY_MIB_INFRA_SUPER_SCAN_CYCLE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_promisc
argument_list|)
operator|=
name|RAY_MIB_PROMISC_DEFAULT
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_uniq_word
argument_list|)
argument_list|,
name|RAY_MIB_UNIQ_WORD_DEFAULT
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_slot_time
argument_list|)
operator|=
name|RAY_MIB_SLOT_TIME_V5
expr_stmt|;
name|MIB5
argument_list|(
name|mib_roam_low_snr_thresh
argument_list|)
operator|=
name|RAY_MIB_ROAM_LOW_SNR_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_low_snr_count
argument_list|)
operator|=
name|RAY_MIB_LOW_SNR_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_infra_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_INFRA_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_adhoc_missed_beacon_count
argument_list|)
operator|=
name|RAY_MIB_ADHOC_MISSED_BEACON_COUNT_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_country_code
argument_list|)
operator|=
name|RAY_MIB_COUNTRY_CODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_hop_seq_len
argument_list|)
operator|=
name|RAY_MIB_HOP_SEQ_LEN_V5
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_max
argument_list|)
argument_list|,
name|RAY_MIB_CW_MAX_V5
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|MIB5
argument_list|(
name|mib_cw_min
argument_list|)
argument_list|,
name|RAY_MIB_CW_MIN_V5
argument_list|)
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_filter_gain
argument_list|)
operator|=
name|RAY_MIB_NOISE_FILTER_GAIN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_noise_limit_offset
argument_list|)
operator|=
name|RAY_MIB_NOISE_LIMIT_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_rssi_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_RSSI_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_busy_thresh_offset
argument_list|)
operator|=
name|RAY_MIB_BUSY_THRESH_OFFSET_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_sync_thresh
argument_list|)
operator|=
name|RAY_MIB_SYNC_THRESH_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_mode
argument_list|)
operator|=
name|RAY_MIB_TEST_MODE_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_min_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MIN_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_test_max_chan
argument_list|)
operator|=
name|RAY_MIB_TEST_MAX_CHAN_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_allow_probe_resp
argument_list|)
operator|=
name|RAY_MIB_ALLOW_PROBE_RESP_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_must_start
argument_list|)
operator|=
name|RAY_MIB_PRIVACY_MUST_START_DEFAULT
expr_stmt|;
name|MIB5
argument_list|(
name|mib_privacy_can_join
argument_list|)
operator|=
name|sc
operator|->
name|sc_priv_start
expr_stmt|;
name|MIB5
argument_list|(
name|mib_basic_rate_set
index|[
literal|0
index|]
argument_list|)
operator|=
name|sc
operator|->
name|sc_priv_join
expr_stmt|;
if|if
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_download_params something is already happening\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_version
operator|==
name|RAY_ECFS_BUILD_4
condition|)
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_4_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_4_default
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ray_write_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|ray_mib_5_default
argument_list|,
sizeof|sizeof
argument_list|(
name|ray_mib_5_default
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Get a free command ccs and issue the command - there is nothing      * to fill in for a START_PARAMS command. The start parameters      * command just gets serviced, so we use a timeout to complete the      * sequence.      */
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ccs
argument_list|,
name|RAY_CMD_START_PARAMS
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_download_params can't get a CCS\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|SCP_UPD_STARTUP
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_download_params can't issue command\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|timerh
operator|=
name|timeout
argument_list|(
name|ray_download_timo
argument_list|,
name|sc
argument_list|,
name|RAY_DOWNLOAD_TIMEOUT
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ray%d: Download now awaiting timeout\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Download timeout routine.  *  * Part of ray_init, download, start_join control flow.  */
end_comment

begin_function
specifier|static
name|void
name|ray_download_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|,
name|cmd
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_download_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: check rayidx %d ccs 0x%x cmd 0x%x status %d\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|sc
operator|->
name|sc_ccs
argument_list|)
operator|,
name|sc
operator|->
name|sc_ccs
operator|,
name|cmd
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|!=
name|RAY_CMD_START_PARAMS
operator|)
operator|||
operator|(
operator|(
name|status
operator|!=
name|RAY_CCS_STATUS_FREE
operator|)
operator|&&
operator|(
name|status
operator|!=
name|RAY_CCS_STATUS_BUSY
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: Download ccs odd cmd = 0x%02x, status = 0x%02x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|cmd
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ray_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the card is still busy, re-schedule ourself      */
if|if
condition|(
name|status
operator|==
name|RAY_CCS_STATUS_BUSY
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: ray_download_timo still busy, re-schedule\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timerh
operator|=
name|timeout
argument_list|(
name|ray_download_timo
argument_list|,
name|sc
argument_list|,
name|RAY_DOWNLOAD_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Clear the ccs */
operator|(
name|void
operator|)
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ccs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ccs
operator|=
name|RAY_CCS_LAST
operator|+
literal|1
expr_stmt|;
comment|/*      * Grab a ccs and don't bother updating the network parameters.      * Issue the start/join command and we get interrupted back.      */
if|if
condition|(
name|sc
operator|->
name|sc_net_type
operator|==
name|RAY_MIB_NET_TYPE_ADHOC
condition|)
name|cmd
operator|=
name|RAY_CMD_START_NET
expr_stmt|;
else|else
name|cmd
operator|=
name|RAY_CMD_JOIN_NET
expr_stmt|;
if|if
condition|(
operator|!
name|ray_alloc_ccs
argument_list|(
name|sc
argument_list|,
operator|&
name|ccs
argument_list|,
name|cmd
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_download_timo can't get a CCS to start/join net\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd_net
argument_list|,
name|c_upd_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ray_issue_cmd
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: ray_download_timo can't issue start/join\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ray_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|sc
operator|->
name|sj_timerh
operator|=
name|timeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|RAY_SJ_TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
name|RAY_DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"ray%d: Start-join awaiting interrupt/timeout\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Complete start or join command.  *  * Part of ray_init, download, start_join control flow.  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_join_done
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|,
name|status
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int8_t
name|o_net_type
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_join_done\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
name|untimeout
argument_list|(
name|ray_start_join_timo
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sj_timerh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_STARTJOIN_TIMO */
if|#
directive|if
name|XXX_TRACKING
name|ray_cmd_done
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_STARTJOIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_TRACKING */
comment|/*      * XXX This switch and the following test are badly done. I      * XXX need to take remedial action in each case branch and      * XXX return from there. Then remove the test.      * XXX FAIL comment       * XXX    if we fired the start command we successfully set the card up      * XXX    so just restart ray_start_join sequence and dont reset the card      * XXX    may need to split download_done for this      * XXX FREE      * XXX    not sure      * XXX BUSY      * XXX    maybe timeout but why would we get an interrupt when      * XXX    the card is not finished?       */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|RAY_CCS_STATUS_FREE
case|:
case|case
name|RAY_CCS_STATUS_BUSY
case|:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done status is FREE/BUSY - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAY_CCS_STATUS_COMPLETE
case|:
break|break;
case|case
name|RAY_CCS_STATUS_FAIL
case|:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done status is FAIL - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_havenet
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ray%d: ray_start_join_done unknown status 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|!=
name|RAY_CCS_STATUS_COMPLETE
condition|)
return|return;
comment|/*      * If the command completed correctly, get a few network parameters      * from the ccs and active the network.      */
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
operator|&
name|sc
operator|->
name|sc_cnet_1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_cmd_net
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust values for buggy build 4 */
if|if
condition|(
name|sc
operator|->
name|sc_def_txrate
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_def_txrate
operator|=
name|RAY_MIB_BASIC_RATE_SET_1500K
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_encrypt
operator|==
literal|0x55
condition|)
name|sc
operator|->
name|sc_encrypt
operator|=
literal|0
expr_stmt|;
comment|/* card is telling us to update the network parameters */
if|if
condition|(
name|sc
operator|->
name|sc_upd_param
condition|)
block|{
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ray%d: sj_done card updating parameters - why?\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|o_net_type
operator|=
name|sc
operator|->
name|sc_net_type
expr_stmt|;
name|ray_read_region
argument_list|(
name|sc
argument_list|,
name|RAY_HOST_TO_ECF_BASE
argument_list|,
operator|&
name|sc
operator|->
name|sc_cnet_2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ray_net_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_net_type
operator|!=
name|o_net_type
condition|)
block|{
name|printf
argument_list|(
literal|"ray%d: sj_done card changing network type - why?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX
name|restart
name|ray_start_join
name|sequence
name|may
name|need
name|to
name|split
name|download_timo
for|for this
endif|#
directive|endif
block|}
block|}
name|RAY_DNET_DUMP
argument_list|(
name|sc
argument_list|,
literal|" after start/join network completed."
argument_list|)
expr_stmt|;
comment|/*      * Hurrah! The network is now active.      *      * Clearing IFF_OACTIVE will ensure that the system will queue packets.      * Just before we return from the interrupt context we check to      * see if packets have been queued.      */
if|#
directive|if
name|XXX_MCASTPROM
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|SCP_UPD_MCAST
operator||
name|SCP_UPD_PROMISC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_MCASTPROM */
if|if
condition|(
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|)
operator|==
name|RAY_CMD_JOIN_NET
condition|)
if|#
directive|if
name|XXX_INFRA
name|ray_start_assoc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|#
directive|else
name|RAY_DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"wanted to join a NET!\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_INFRA */
else|else
block|{
name|sc
operator|->
name|sc_havenet
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|RAY_NEED_STARTJOIN_TIMO
end_if

begin_comment
comment|/*  * Back stop catcher for start_join command. The NetBSD driver  * suggests that they need it to catch a bug in the firmware or the  * parameters they use - they are not sure. I'll just panic as I seem  * to get interrupts back fine and I have version 4 firmware.  */
end_comment

begin_function
specifier|static
name|void
name|ray_start_join_timo
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ray_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_start_join_timo\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ray%d: ray-start_join_timo occured\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_NEED_STARTJOIN_TIMO */
end_comment

begin_comment
comment|/*  * Obtain a free ccs buffer.  *  * Returns 1 and in `ccsp' the bus offset of the free ccs   * or 0 if none are free  *  * If `track' is not zero, handles tracking this command  * possibly indicating a callback is needed and setting a timeout  * also if ECF isn't ready we terminate earlier to avoid overhead.  *  * This routine is only used for commands  */
end_comment

begin_function
specifier|static
name|int
name|ray_alloc_ccs
parameter_list|(
name|sc
parameter_list|,
name|ccsp
parameter_list|,
name|cmd
parameter_list|,
name|track
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
modifier|*
name|ccsp
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|track
decl_stmt|;
block|{
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_alloc_ccs\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_TRACKING
comment|/* for tracked commands, if not ready just set pending */
if|if
condition|(
name|track
operator|&&
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* XXX_TRACKING */
for|for
control|(
name|i
operator|=
name|RAY_CCS_CMD_FIRST
init|;
name|i
operator|<=
name|RAY_CCS_CMD_LAST
condition|;
name|i
operator|++
control|)
block|{
comment|/* probe here to make the card go */
operator|(
name|void
operator|)
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|RAY_CCS_CMD_LAST
condition|)
block|{
if|#
directive|if
name|XXX_TRACKING
if|if
condition|(
name|track
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_TRACKING */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ccsinuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|ccs
operator|=
name|RAY_CCS_ADDRESS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|,
name|RAY_CCS_STATUS_BUSY
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|SRAM_WRITE_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_link
argument_list|,
name|RAY_CCS_LINK_NULL
argument_list|)
expr_stmt|;
operator|*
name|ccsp
operator|=
name|ccs
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free up a ccs/cmd and return the old status.  * This routine is only used for commands.  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ray_free_ccs
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
block|{
name|u_int8_t
name|status
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_free_ccs\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|SRAM_READ_FIELD_1
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|,
name|ray_cmd
argument_list|,
name|c_status
argument_list|)
expr_stmt|;
name|RAY_CCS_FREE
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccs
operator|<=
name|RAY_CCS_ADDRESS
argument_list|(
name|RAY_CCS_LAST
argument_list|)
condition|)
name|sc
operator|->
name|sc_ccsinuse
index|[
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|20
argument_list|,
operator|(
literal|"ray%d: ray_free_ccs freed 0x%02x\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Issue a command by writing the mailbox and tickling the card.  * Only used for commands not transmitted packets.  */
end_comment

begin_function
specifier|static
name|int
name|ray_issue_cmd
parameter_list|(
name|sc
parameter_list|,
name|ccs
parameter_list|,
name|track
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|size_t
name|ccs
decl_stmt|;
name|u_int
name|track
decl_stmt|;
block|{
name|u_int
name|i
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: ray_cmd_issue\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|RAY_MAP_CM
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * XXX other drivers did this, but I think       * what we really want to do is just make sure we don't      * get here or that spinning is ok      */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|RAY_ECF_READY
argument_list|(
name|sc
argument_list|)
condition|)
if|if
condition|(
operator|++
name|i
operator|>
literal|50
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ray_free_ccs
argument_list|(
name|sc
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_TRACKING
if|if
condition|(
name|track
condition|)
name|ray_cmd_schedule
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_TRACKING */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"ray%d: ray_issue_cmd spinning"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|SRAM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RAY_SCB_CCSI
argument_list|,
name|RAY_CCS_INDEX
argument_list|(
name|ccs
argument_list|)
argument_list|)
expr_stmt|;
name|RAY_ECF_START_CMD
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXX_TRACKING
name|ray_cmd_ran
argument_list|(
name|sc
argument_list|,
name|track
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX_TRACKING */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|RAY_DEBUG
operator|>
literal|50
end_if

begin_function
specifier|static
name|void
name|ray_dump_mbuf
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|u_int8_t
modifier|*
name|d
decl_stmt|,
modifier|*
name|ed
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
name|p
index|[
literal|17
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"ray%d: %s mbuf dump:"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
literal|17
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|ed
operator|=
name|d
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|ed
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  %s\n\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|%
literal|16
index|]
operator|=
operator|(
operator|(
operator|*
name|d
operator|>=
literal|0x20
operator|)
operator|&&
operator|(
operator|*
name|d
operator|<
literal|0x80
operator|)
operator|)
condition|?
operator|*
name|d
else|:
literal|'.'
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAY_DEBUG> 50 */
end_comment

begin_comment
comment|/*  * Routines to read from/write to the attribute memory.  *  * Taken from if_xe.c.  *  * Until there is a real way of accessing the attribute memory from a driver  * these have to stay.  *  * The hack to use the crdread/crdwrite device functions causes the attribute  * memory to be remapped into the controller and looses the mapping of  * the common memory.  *  * We cheat by using PIOCSMEM and assume that the common memory window  * is in window 0 of the card structure.  *  * Also  *	pccard/pcic.c/crdread does mark the unmapped window as inactive  *	pccard/pccard.c/map_mem toggles the mapping of a window on  *	successive calls  *  */
end_comment

begin_if
if|#
directive|if
operator|(
name|RAY_NEED_CM_REMAPPING
operator||
name|RAY_NEED_CM_FIXUP
operator|)
end_if

begin_function
specifier|static
name|void
name|ray_attr_getmap
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|int
name|result
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"ray%d: attempting to get map for common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|md
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCGMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ray_attr_cm
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ucred
name|uc
decl_stmt|;
name|struct
name|pcred
name|pc
decl_stmt|;
name|struct
name|proc
name|p
decl_stmt|;
name|RAY_DPRINTFN
argument_list|(
literal|100
argument_list|,
operator|(
literal|"ray%d: attempting to remap common memory\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_cred
operator|=
operator|&
name|pc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|=
operator|&
name|uc
expr_stmt|;
name|p
operator|.
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_ioctl
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
name|PIOCSMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|md
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RAY_NEED_CM_REMAPPING | RAY_NEED_CM_FIXUP) */
end_comment

begin_function
specifier|static
name|int
name|ray_attr_write
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
name|byte
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|&
name|byte
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_write
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ray_attr_read
parameter_list|(
name|struct
name|ray_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uios
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uios
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uios
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uios
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|uios
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uios
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uios
operator|.
name|uio_procp
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cdevsw
index|[
name|CARD_MAJOR
index|]
operator|->
name|d_read
argument_list|(
name|makedev
argument_list|(
name|CARD_MAJOR
argument_list|,
name|sc
operator|->
name|slotnum
argument_list|)
argument_list|,
operator|&
name|uios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|RAY_NEED_CM_REMAPPING
name|ray_attr_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RAY_NEED_CM_REMAPPING */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ray_read_reg
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
name|struct
name|ray_softc
modifier|*
name|sc
decl_stmt|;
name|off_t
name|reg
decl_stmt|;
block|{
name|u_int8_t
name|byte
decl_stmt|;
name|ray_attr_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRAY */
end_comment

end_unit

