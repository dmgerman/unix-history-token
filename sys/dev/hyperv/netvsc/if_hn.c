begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Citrix Inc.  * Copyright (c) 2009-2012,2016 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2004-2006 Kip Macy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_hn.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf_ring.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/rndis.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/vmbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/vmbus_xact.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/netvsc/ndis.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/netvsc/if_hnreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/netvsc/if_hnvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/netvsc/hn_nvs.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/netvsc/hn_rndis.h>
end_include

begin_include
include|#
directive|include
file|"vmbus_if.h"
end_include

begin_define
define|#
directive|define
name|HN_IFSTART_SUPPORT
end_define

begin_define
define|#
directive|define
name|HN_RING_CNT_DEF_MAX
value|8
end_define

begin_define
define|#
directive|define
name|HN_VFMAP_SIZE_DEF
value|8
end_define

begin_comment
comment|/* YYY should get it from the underlying channel */
end_comment

begin_define
define|#
directive|define
name|HN_TX_DESC_CNT
value|512
end_define

begin_define
define|#
directive|define
name|HN_RNDIS_PKT_LEN
define|\
value|(sizeof(struct rndis_packet_msg) +			\ 	 HN_RNDIS_PKTINFO_SIZE(HN_NDIS_HASH_VALUE_SIZE) +	\ 	 HN_RNDIS_PKTINFO_SIZE(NDIS_VLAN_INFO_SIZE) +		\ 	 HN_RNDIS_PKTINFO_SIZE(NDIS_LSO2_INFO_SIZE) +		\ 	 HN_RNDIS_PKTINFO_SIZE(NDIS_TXCSUM_INFO_SIZE))
end_define

begin_define
define|#
directive|define
name|HN_RNDIS_PKT_BOUNDARY
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|HN_RNDIS_PKT_ALIGN
value|CACHE_LINE_SIZE
end_define

begin_define
define|#
directive|define
name|HN_TX_DATA_BOUNDARY
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|HN_TX_DATA_MAXSIZE
value|IP_MAXPACKET
end_define

begin_define
define|#
directive|define
name|HN_TX_DATA_SEGSIZE
value|PAGE_SIZE
end_define

begin_comment
comment|/* -1 for RNDIS packet message */
end_comment

begin_define
define|#
directive|define
name|HN_TX_DATA_SEGCNT_MAX
value|(HN_GPACNT_MAX - 1)
end_define

begin_define
define|#
directive|define
name|HN_DIRECT_TX_SIZE_DEF
value|128
end_define

begin_define
define|#
directive|define
name|HN_EARLY_TXEOF_THRESH
value|8
end_define

begin_define
define|#
directive|define
name|HN_PKTBUF_LEN_DEF
value|(16 * 1024)
end_define

begin_define
define|#
directive|define
name|HN_LROENT_CNT_DEF
value|128
end_define

begin_define
define|#
directive|define
name|HN_LRO_LENLIM_MULTIRX_DEF
value|(12 * ETHERMTU)
end_define

begin_define
define|#
directive|define
name|HN_LRO_LENLIM_DEF
value|(25 * ETHERMTU)
end_define

begin_comment
comment|/* YYY 2*MTU is a bit rough, but should be good enough. */
end_comment

begin_define
define|#
directive|define
name|HN_LRO_LENLIM_MIN
parameter_list|(
name|ifp
parameter_list|)
value|(2 * (ifp)->if_mtu)
end_define

begin_define
define|#
directive|define
name|HN_LRO_ACKCNT_DEF
value|1
end_define

begin_define
define|#
directive|define
name|HN_LOCK_INIT
parameter_list|(
name|sc
parameter_list|)
define|\
value|sx_init(&(sc)->hn_lock, device_get_nameunit((sc)->hn_dev))
end_define

begin_define
define|#
directive|define
name|HN_LOCK_DESTROY
parameter_list|(
name|sc
parameter_list|)
value|sx_destroy(&(sc)->hn_lock)
end_define

begin_define
define|#
directive|define
name|HN_LOCK_ASSERT
parameter_list|(
name|sc
parameter_list|)
value|sx_assert(&(sc)->hn_lock, SA_XLOCKED)
end_define

begin_define
define|#
directive|define
name|HN_LOCK
parameter_list|(
name|sc
parameter_list|)
define|\
value|do {							\ 	while (sx_try_xlock(&(sc)->hn_lock) == 0)	\ 		DELAY(1000);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|HN_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|sx_xunlock(&(sc)->hn_lock)
end_define

begin_define
define|#
directive|define
name|HN_CSUM_IP_MASK
value|(CSUM_IP | CSUM_IP_TCP | CSUM_IP_UDP)
end_define

begin_define
define|#
directive|define
name|HN_CSUM_IP6_MASK
value|(CSUM_IP6_TCP | CSUM_IP6_UDP)
end_define

begin_define
define|#
directive|define
name|HN_CSUM_IP_HWASSIST
parameter_list|(
name|sc
parameter_list|)
define|\
value|((sc)->hn_tx_ring[0].hn_csum_assist& HN_CSUM_IP_MASK)
end_define

begin_define
define|#
directive|define
name|HN_CSUM_IP6_HWASSIST
parameter_list|(
name|sc
parameter_list|)
define|\
value|((sc)->hn_tx_ring[0].hn_csum_assist& HN_CSUM_IP6_MASK)
end_define

begin_define
define|#
directive|define
name|HN_PKTSIZE_MIN
parameter_list|(
name|align
parameter_list|)
define|\
value|roundup2(ETHER_MIN_LEN + ETHER_VLAN_ENCAP_LEN - ETHER_CRC_LEN + \ 	    HN_RNDIS_PKT_LEN, (align))
end_define

begin_define
define|#
directive|define
name|HN_PKTSIZE
parameter_list|(
name|m
parameter_list|,
name|align
parameter_list|)
define|\
value|roundup2((m)->m_pkthdr.len + HN_RNDIS_PKT_LEN, (align))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_define
define|#
directive|define
name|HN_RING_IDX2CPU
parameter_list|(
name|sc
parameter_list|,
name|idx
parameter_list|)
value|rss_getcpu((idx) % rss_getnumbuckets())
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HN_RING_IDX2CPU
parameter_list|(
name|sc
parameter_list|,
name|idx
parameter_list|)
value|(((sc)->hn_cpu + (idx)) % mp_ncpus)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|hn_txdesc
block|{
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|SLIST_ENTRY
argument_list|(
argument|hn_txdesc
argument_list|)
name|link
expr_stmt|;
endif|#
directive|endif
name|STAILQ_ENTRY
argument_list|(
argument|hn_txdesc
argument_list|)
name|agg_link
expr_stmt|;
comment|/* Aggregated txdescs, in sending order. */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|hn_txdesc
argument_list|)
name|agg_list
expr_stmt|;
comment|/* The oldest packet, if transmission aggregation happens. */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|refs
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
comment|/* HN_TXD_FLAG_ */
name|struct
name|hn_nvs_sendctx
name|send_ctx
decl_stmt|;
name|uint32_t
name|chim_index
decl_stmt|;
name|int
name|chim_size
decl_stmt|;
name|bus_dmamap_t
name|data_dmap
decl_stmt|;
name|bus_addr_t
name|rndis_pkt_paddr
decl_stmt|;
name|struct
name|rndis_packet_msg
modifier|*
name|rndis_pkt
decl_stmt|;
name|bus_dmamap_t
name|rndis_pkt_dmap
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HN_TXD_FLAG_ONLIST
value|0x0001
end_define

begin_define
define|#
directive|define
name|HN_TXD_FLAG_DMAMAP
value|0x0002
end_define

begin_define
define|#
directive|define
name|HN_TXD_FLAG_ONAGG
value|0x0004
end_define

begin_struct
struct|struct
name|hn_rxinfo
block|{
name|uint32_t
name|vlan_info
decl_stmt|;
name|uint32_t
name|csum_info
decl_stmt|;
name|uint32_t
name|hash_info
decl_stmt|;
name|uint32_t
name|hash_value
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hn_update_vf
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|vf
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HN_RXINFO_VLAN
value|0x0001
end_define

begin_define
define|#
directive|define
name|HN_RXINFO_CSUM
value|0x0002
end_define

begin_define
define|#
directive|define
name|HN_RXINFO_HASHINF
value|0x0004
end_define

begin_define
define|#
directive|define
name|HN_RXINFO_HASHVAL
value|0x0008
end_define

begin_define
define|#
directive|define
name|HN_RXINFO_ALL
define|\
value|(HN_RXINFO_VLAN |		\ 	 HN_RXINFO_CSUM |		\ 	 HN_RXINFO_HASHINF |		\ 	 HN_RXINFO_HASHVAL)
end_define

begin_define
define|#
directive|define
name|HN_NDIS_VLAN_INFO_INVALID
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|HN_NDIS_RXCSUM_INFO_INVALID
value|0
end_define

begin_define
define|#
directive|define
name|HN_NDIS_HASH_INFO_INVALID
value|0
end_define

begin_function_decl
specifier|static
name|int
name|hn_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_chan_callback
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
end_ifdef

begin_function_decl
specifier|static
name|void
name|hn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|hn_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_xmit_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifnet_event
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifaddr_event
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifnet_attevent
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifnet_detevent
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_rndis_rxinfo
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|hn_rxinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_rndis_rx_data
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_rndis_rx_status
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_rndis_init_fixat
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_nvs_handle_notify
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|vmbus_chanpkt_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_nvs_handle_comp
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
specifier|const
name|struct
name|vmbus_chanpkt_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_nvs_handle_rxbuf
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
specifier|const
name|struct
name|vmbus_chanpkt_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_nvs_ack_rxbuf
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100099
end_if

begin_function_decl
specifier|static
name|int
name|hn_lro_lenlim_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_lro_ackcnt_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|hn_trust_hcsum_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_chim_size_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1100095
end_if

begin_function_decl
specifier|static
name|int
name|hn_rx_stat_int_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|hn_rx_stat_u64_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|hn_rx_stat_ulong_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_tx_stat_ulong_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_tx_conf_int_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_ndis_version_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_caps_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_hwassist_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_rxfilter_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|RSS
end_ifndef

begin_function_decl
specifier|static
name|int
name|hn_rss_key_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_rss_ind_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|hn_rss_hash_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_txagg_size_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_txagg_pkts_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_txagg_pktmax_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_txagg_align_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_polling_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_vf_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_rxvf_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_vflist_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_vfmap_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_stop
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_init_locked
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_chan_attach
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_chan_detach
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_attach_subchans
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_detach_allchans
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_chan_rollup
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_set_ring_inuse
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_synth_attach
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_synth_detach
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_synth_alloc_subchans
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|hn_synth_attachable
parameter_list|(
specifier|const
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_suspend
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_suspend_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_suspend_mgmt
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_resume
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_resume_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_resume_mgmt
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_suspend_mgmt_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_chan_drain
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_disable_rx
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_drain_rxtx
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_polling
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_chan_polling
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_update_link_status
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_change_network
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_link_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_netchg_init_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_netchg_status_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_link_status
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_create_rx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_destroy_rx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_check_iplen
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_set_rxfilter
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_rxfilter_config
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|RSS
end_ifndef

begin_function_decl
specifier|static
name|int
name|hn_rss_reconfig
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|hn_rss_ind_fixup
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_rxpkt
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|hn_rxinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_tx_ring_create
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_tx_ring_destroy
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_create_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_fixup_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_destroy_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_txdesc_dmamap_destroy
parameter_list|(
name|struct
name|hn_txdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_txdesc_gc
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_encap
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_txpkt
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_set_chim_size
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_set_tso_maxsize
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|hn_tx_ring_pending
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_tx_ring_qflush
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_resume_tx
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_set_txagg
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|hn_try_txagg
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_get_txswq_depth
parameter_list|(
specifier|const
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_txpkt_done
parameter_list|(
name|struct
name|hn_nvs_sendctx
modifier|*
parameter_list|,
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_txpkt_sglist
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_txpkt_chim
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_xmit
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_xmit_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_xmit_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_xmit_txeof_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
end_ifdef

begin_function_decl
specifier|static
name|int
name|hn_start_locked
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start_txeof_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|hn
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|"Hyper-V network interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Trust tcp segements verification on host side. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_trust_hosttcp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|trust_hosttcp
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_trust_hosttcp
argument_list|,
literal|0
argument_list|,
literal|"Trust tcp segement verification on host side, "
literal|"when csum info is missing (global setting)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Trust udp datagrams verification on host side. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_trust_hostudp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|trust_hostudp
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_trust_hostudp
argument_list|,
literal|0
argument_list|,
literal|"Trust udp datagram verification on host side, "
literal|"when csum info is missing (global setting)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Trust ip packets verification on host side. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_trust_hostip
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|trust_hostip
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_trust_hostip
argument_list|,
literal|0
argument_list|,
literal|"Trust ip packet verification on host side, "
literal|"when csum info is missing (global setting)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Limit TSO burst size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_tso_maxlen
init|=
name|IP_MAXPACKET
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tso_maxlen
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tso_maxlen
argument_list|,
literal|0
argument_list|,
literal|"TSO burst limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Limit chimney send size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_tx_chimney_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_chimney_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tx_chimney_size
argument_list|,
literal|0
argument_list|,
literal|"Chimney send packet size limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Limit the size of packet for direct transmission */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_direct_tx_size
init|=
name|HN_DIRECT_TX_SIZE_DEF
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|direct_tx_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_direct_tx_size
argument_list|,
literal|0
argument_list|,
literal|"Size of the packet for direct transmission"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* # of LRO entries per RX ring */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
end_if

begin_decl_stmt
specifier|static
name|int
name|hn_lro_entry_count
init|=
name|HN_LROENT_CNT_DEF
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|lro_entry_count
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_lro_entry_count
argument_list|,
literal|0
argument_list|,
literal|"LRO entry count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|hn_tx_taskq_cnt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_taskq_cnt
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tx_taskq_cnt
argument_list|,
literal|0
argument_list|,
literal|"# of TX taskqueues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HN_TX_TASKQ_M_INDEP
value|0
end_define

begin_define
define|#
directive|define
name|HN_TX_TASKQ_M_GLOBAL
value|1
end_define

begin_define
define|#
directive|define
name|HN_TX_TASKQ_M_EVTTQ
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|hn_tx_taskq_mode
init|=
name|HN_TX_TASKQ_M_INDEP
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_taskq_mode
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tx_taskq_mode
argument_list|,
literal|0
argument_list|,
literal|"TX taskqueue modes: "
literal|"0 - independent, 1 - share global tx taskqs, 2 - share event taskqs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|hn_use_txdesc_bufring
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|hn_use_txdesc_bufring
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|use_txdesc_bufring
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|hn_use_txdesc_bufring
argument_list|,
literal|0
argument_list|,
literal|"Use buf_ring for TX descriptors"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
end_ifdef

begin_comment
comment|/* Use ifnet.if_start instead of ifnet.if_transmit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_use_if_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|use_if_start
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_use_if_start
argument_list|,
literal|0
argument_list|,
literal|"Use if_start TX method"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* # of channels to use */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_chan_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|chan_cnt
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_chan_cnt
argument_list|,
literal|0
argument_list|,
literal|"# of channels to use; each channel has one RX ring and one TX ring"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* # of transmit rings to use */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_tx_ring_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_ring_cnt
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tx_ring_cnt
argument_list|,
literal|0
argument_list|,
literal|"# of TX rings to use"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Software TX ring deptch */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_tx_swq_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_swq_depth
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tx_swq_depth
argument_list|,
literal|0
argument_list|,
literal|"Depth of IFQ or BUFRING"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Enable sorted LRO, and the depth of the per-channel mbuf queue */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
end_if

begin_decl_stmt
specifier|static
name|u_int
name|hn_lro_mbufq_depth
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|lro_mbufq_depth
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_lro_mbufq_depth
argument_list|,
literal|0
argument_list|,
literal|"Depth of LRO mbuf queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Packet transmission aggregation size limit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_tx_agg_size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_agg_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tx_agg_size
argument_list|,
literal|0
argument_list|,
literal|"Packet transmission aggregation size limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Packet transmission aggregation count limit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_tx_agg_pkts
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_agg_pkts
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tx_agg_pkts
argument_list|,
literal|0
argument_list|,
literal|"Packet transmission aggregation packet limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* VF list */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|vflist
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRING
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hn_vflist_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"VF list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* VF mapping */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|vfmap
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRING
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hn_vfmap_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"VF mapping"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|hn_cpu_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next CPU for channel */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|taskqueue
modifier|*
modifier|*
name|hn_tx_taskque
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shared TX taskqueues */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rmlock
name|hn_vfmap_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hn_vfmap_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ifnet
modifier|*
modifier|*
name|hn_vfmap
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|RSS
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|hn_rss_key_default
index|[
name|NDIS_HASH_KEYSIZE_TOEPLITZ
index|]
init|=
block|{
literal|0x6d
block|,
literal|0x5a
block|,
literal|0x56
block|,
literal|0xda
block|,
literal|0x25
block|,
literal|0x5b
block|,
literal|0x0e
block|,
literal|0xc2
block|,
literal|0x41
block|,
literal|0x67
block|,
literal|0x25
block|,
literal|0x3d
block|,
literal|0x43
block|,
literal|0xa3
block|,
literal|0x8f
block|,
literal|0xb0
block|,
literal|0xd0
block|,
literal|0xca
block|,
literal|0x2b
block|,
literal|0xcb
block|,
literal|0xae
block|,
literal|0x7b
block|,
literal|0x30
block|,
literal|0xb4
block|,
literal|0x77
block|,
literal|0xcb
block|,
literal|0x2d
block|,
literal|0xa3
block|,
literal|0x80
block|,
literal|0x30
block|,
literal|0xf2
block|,
literal|0x0c
block|,
literal|0x6a
block|,
literal|0x42
block|,
literal|0xb7
block|,
literal|0x3b
block|,
literal|0xbe
block|,
literal|0xac
block|,
literal|0x01
block|,
literal|0xfa
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !RSS */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|hn_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hn_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hn_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hn_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|hn_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hn_driver
init|=
block|{
literal|"hn"
block|,
name|hn_methods
block|,
expr|sizeof
operator|(
expr|struct
name|hn_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hn_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hn
argument_list|,
name|vmbus
argument_list|,
name|hn_driver
argument_list|,
name|hn_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|hn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hn
argument_list|,
name|vmbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100099
end_if

begin_function
specifier|static
name|void
name|hn_set_lro_lenlim
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|lenlim
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
operator|.
name|hn_lro
operator|.
name|lro_length_lim
operator|=
name|lenlim
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|hn_txpkt_sglist
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|txd
operator|->
name|chim_index
operator|==
name|HN_NVS_CHIM_IDX_INVALID
operator|&&
name|txd
operator|->
name|chim_size
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid rndis sglist txd"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hn_nvs_send_rndis_sglist
argument_list|(
name|txr
operator|->
name|hn_chan
argument_list|,
name|HN_NVS_RNDIS_MTYPE_DATA
argument_list|,
operator|&
name|txd
operator|->
name|send_ctx
argument_list|,
name|txr
operator|->
name|hn_gpa
argument_list|,
name|txr
operator|->
name|hn_gpa_cnt
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_txpkt_chim
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|struct
name|hn_nvs_rndis
name|rndis
decl_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|chim_index
operator|!=
name|HN_NVS_CHIM_IDX_INVALID
operator|&&
name|txd
operator|->
name|chim_size
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid rndis chim txd"
operator|)
argument_list|)
expr_stmt|;
name|rndis
operator|.
name|nvs_type
operator|=
name|HN_NVS_TYPE_RNDIS
expr_stmt|;
name|rndis
operator|.
name|nvs_rndis_mtype
operator|=
name|HN_NVS_RNDIS_MTYPE_DATA
expr_stmt|;
name|rndis
operator|.
name|nvs_chim_idx
operator|=
name|txd
operator|->
name|chim_index
expr_stmt|;
name|rndis
operator|.
name|nvs_chim_sz
operator|=
name|txd
operator|->
name|chim_size
expr_stmt|;
return|return
operator|(
name|hn_nvs_send
argument_list|(
name|txr
operator|->
name|hn_chan
argument_list|,
name|VMBUS_CHANPKT_FLAG_RC
argument_list|,
operator|&
name|rndis
argument_list|,
sizeof|sizeof
argument_list|(
name|rndis
argument_list|)
argument_list|,
operator|&
name|txd
operator|->
name|send_ctx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|hn_chim_alloc
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bmap_cnt
init|=
name|sc
operator|->
name|hn_chim_bmap_cnt
decl_stmt|;
name|u_long
modifier|*
name|bmap
init|=
name|sc
operator|->
name|hn_chim_bmap
decl_stmt|;
name|uint32_t
name|ret
init|=
name|HN_NVS_CHIM_IDX_INVALID
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bmap_cnt
condition|;
operator|++
name|i
control|)
block|{
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|ffsl
argument_list|(
operator|~
name|bmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
continue|continue;
operator|--
name|idx
expr_stmt|;
comment|/* ffsl is 1-based */
name|KASSERT
argument_list|(
name|i
operator|*
name|LONG_BIT
operator|+
name|idx
operator|<
name|sc
operator|->
name|hn_chim_cnt
argument_list|,
operator|(
literal|"invalid i %d and idx %d"
operator|,
name|i
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_testandset_long
argument_list|(
operator|&
name|bmap
index|[
name|i
index|]
argument_list|,
name|idx
argument_list|)
condition|)
continue|continue;
name|ret
operator|=
name|i
operator|*
name|LONG_BIT
operator|+
name|idx
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|hn_chim_free
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|chim_idx
parameter_list|)
block|{
name|u_long
name|mask
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|idx
operator|=
name|chim_idx
operator|/
name|LONG_BIT
expr_stmt|;
name|KASSERT
argument_list|(
name|idx
operator|<
name|sc
operator|->
name|hn_chim_bmap_cnt
argument_list|,
operator|(
literal|"invalid chimney index 0x%x"
operator|,
name|chim_idx
operator|)
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|1UL
operator|<<
operator|(
name|chim_idx
operator|%
name|LONG_BIT
operator|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|hn_chim_bmap
index|[
name|idx
index|]
operator|&
name|mask
argument_list|,
operator|(
literal|"index bitmap 0x%lx, chimney index %u, "
literal|"bitmap idx %d, bitmask 0x%lx"
operator|,
name|sc
operator|->
name|hn_chim_bmap
index|[
name|idx
index|]
operator|,
name|chim_idx
operator|,
name|idx
operator|,
name|mask
operator|)
argument_list|)
expr_stmt|;
name|atomic_clear_long
argument_list|(
operator|&
name|sc
operator|->
name|hn_chim_bmap
index|[
name|idx
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
end_if

begin_define
define|#
directive|define
name|PULLUP_HDR
parameter_list|(
name|m
parameter_list|,
name|len
parameter_list|)
define|\
value|do {							\ 	if (__predict_false((m)->m_len< (len))) {	\ 		(m) = m_pullup((m), (len));		\ 		if ((m) == NULL)			\ 			return (NULL);			\ 	}						\ } while (0)
end_define

begin_comment
comment|/*  * NOTE: If this function failed, the m_head would be freed.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|hn_tso_fixup
argument_list|(
argument|struct mbuf *m_head
argument_list|)
block|{ 	struct
name|ether_vlan_header
operator|*
name|evl
block|; 	struct
name|tcphdr
operator|*
name|th
block|;
name|int
name|ehlen
block|;
name|KASSERT
argument_list|(
name|M_WRITABLE
argument_list|(
name|m_head
argument_list|)
argument_list|,
operator|(
literal|"TSO mbuf not writable"
operator|)
argument_list|)
block|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|evl
argument_list|)
argument_list|)
block|;
name|evl
operator|=
name|mtod
argument_list|(
name|m_head
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
block|;
if|if
condition|(
name|evl
operator|->
name|evl_encap_proto
operator|==
name|ntohs
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
name|ehlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
else|else
name|ehlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_if
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_TSO
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtodo
argument_list|(
name|m_head
argument_list|,
name|ehlen
argument_list|)
expr_stmt|;
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|=
name|mtodo
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
name|iphlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtodo
argument_list|(
name|m_head
argument_list|,
name|ehlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|!=
name|IPPROTO_TCP
condition|)
block|{
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|=
name|mtodo
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
operator|(
name|m_head
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * NOTE: If this function failed, the m_head would be freed.  */
end_comment

begin_function
unit|static
name|__inline
name|struct
name|mbuf
modifier|*
name|hn_check_tcpsyn
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|,
name|int
modifier|*
name|tcpsyn
parameter_list|)
block|{
specifier|const
name|struct
name|ether_vlan_header
modifier|*
name|evl
decl_stmt|;
specifier|const
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|int
name|ehlen
decl_stmt|;
operator|*
name|tcpsyn
operator|=
literal|0
expr_stmt|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|evl
argument_list|)
argument_list|)
expr_stmt|;
name|evl
operator|=
name|mtod
argument_list|(
name|m_head
argument_list|,
specifier|const
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|evl
operator|->
name|evl_encap_proto
operator|==
name|ntohs
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
name|ehlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
else|else
name|ehlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_TCP
condition|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtodo
argument_list|(
name|m_head
argument_list|,
name|ehlen
argument_list|)
expr_stmt|;
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|=
name|mtodo
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
name|iphlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
operator|*
name|tcpsyn
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtodo
argument_list|(
name|m_head
argument_list|,
name|ehlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|m_head
operator|)
return|;
name|PULLUP_HDR
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|=
name|mtodo
argument_list|(
name|m_head
argument_list|,
name|ehlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
operator|*
name|tcpsyn
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|m_head
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|PULLUP_HDR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 || INET */
end_comment

begin_function
specifier|static
name|int
name|hn_set_rxfilter
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|filter
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rx_filter
operator|!=
name|filter
condition|)
block|{
name|error
operator|=
name|hn_rndis_set_rxfilter
argument_list|(
name|sc
argument_list|,
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|sc
operator|->
name|hn_rx_filter
operator|=
name|filter
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_rxfilter_config
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|uint32_t
name|filter
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|||
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_VF
operator|)
condition|)
block|{
name|filter
operator|=
name|NDIS_PACKET_TYPE_PROMISCUOUS
expr_stmt|;
block|}
else|else
block|{
name|filter
operator|=
name|NDIS_PACKET_TYPE_DIRECTED
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
name|filter
operator||=
name|NDIS_PACKET_TYPE_BROADCAST
expr_stmt|;
comment|/* TODO: support multicast list */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_multiaddrs
argument_list|)
condition|)
name|filter
operator||=
name|NDIS_PACKET_TYPE_ALL_MULTICAST
expr_stmt|;
block|}
return|return
operator|(
name|hn_set_rxfilter
argument_list|(
name|sc
argument_list|,
name|filter
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_set_txagg
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|size
decl_stmt|,
name|pkts
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Setup aggregation size. 	 */
if|if
condition|(
name|sc
operator|->
name|hn_agg_size
operator|<
literal|0
condition|)
name|size
operator|=
name|UINT32_MAX
expr_stmt|;
else|else
name|size
operator|=
name|sc
operator|->
name|hn_agg_size
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rndis_agg_size
operator|<
name|size
condition|)
name|size
operator|=
name|sc
operator|->
name|hn_rndis_agg_size
expr_stmt|;
comment|/* NOTE: We only aggregate packets using chimney sending buffers. */
if|if
condition|(
name|size
operator|>
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|hn_chim_szmax
condition|)
name|size
operator|=
name|sc
operator|->
name|hn_chim_szmax
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|2
operator|*
name|HN_PKTSIZE_MIN
argument_list|(
name|sc
operator|->
name|hn_rndis_agg_align
argument_list|)
condition|)
block|{
comment|/* Disable */
name|size
operator|=
literal|0
expr_stmt|;
name|pkts
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* NOTE: Type of the per TX ring setting is 'int'. */
if|if
condition|(
name|size
operator|>
name|INT_MAX
condition|)
name|size
operator|=
name|INT_MAX
expr_stmt|;
comment|/* 	 * Setup aggregation packet count. 	 */
if|if
condition|(
name|sc
operator|->
name|hn_agg_pkts
operator|<
literal|0
condition|)
name|pkts
operator|=
name|UINT32_MAX
expr_stmt|;
else|else
name|pkts
operator|=
name|sc
operator|->
name|hn_agg_pkts
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rndis_agg_pkts
operator|<
name|pkts
condition|)
name|pkts
operator|=
name|sc
operator|->
name|hn_rndis_agg_pkts
expr_stmt|;
if|if
condition|(
name|pkts
operator|<=
literal|1
condition|)
block|{
comment|/* Disable */
name|size
operator|=
literal|0
expr_stmt|;
name|pkts
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* NOTE: Type of the per TX ring setting is 'short'. */
if|if
condition|(
name|pkts
operator|>
name|SHRT_MAX
condition|)
name|pkts
operator|=
name|SHRT_MAX
expr_stmt|;
name|done
label|:
comment|/* NOTE: Type of the per TX ring setting is 'short'. */
if|if
condition|(
name|sc
operator|->
name|hn_rndis_agg_align
operator|>
name|SHRT_MAX
condition|)
block|{
comment|/* Disable */
name|size
operator|=
literal|0
expr_stmt|;
name|pkts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"TX agg size %u, pkts %u, align %u\n"
argument_list|,
name|size
argument_list|,
name|pkts
argument_list|,
name|sc
operator|->
name|hn_rndis_agg_align
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_agg_szmax
operator|=
name|size
expr_stmt|;
name|txr
operator|->
name|hn_agg_pktmax
operator|=
name|pkts
expr_stmt|;
name|txr
operator|->
name|hn_agg_align
operator|=
name|sc
operator|->
name|hn_rndis_agg_align
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hn_get_txswq_depth
parameter_list|(
specifier|const
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_txdesc_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"tx ring is not setup yet"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hn_tx_swq_depth
operator|<
name|txr
operator|->
name|hn_txdesc_cnt
condition|)
return|return
name|txr
operator|->
name|hn_txdesc_cnt
return|;
return|return
name|hn_tx_swq_depth
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|RSS
end_ifndef

begin_function
specifier|static
name|int
name|hn_rss_reconfig
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Disable RSS first. 	 * 	 * NOTE: 	 * Direct reconfiguration by setting the UNCHG flags does 	 * _not_ work properly. 	 */
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"disable RSS\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|hn_rndis_conf_rss
argument_list|(
name|sc
argument_list|,
name|NDIS_RSS_FLAG_DISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"RSS disable failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Reenable the RSS w/ the updated RSS key or indirect 	 * table. 	 */
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"reconfig RSS\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|hn_rndis_conf_rss
argument_list|(
name|sc
argument_list|,
name|NDIS_RSS_FLAG_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"RSS reconfig failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !RSS */
end_comment

begin_function
specifier|static
name|void
name|hn_rss_ind_fixup
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ndis_rssprm_toeplitz
modifier|*
name|rss
init|=
operator|&
name|sc
operator|->
name|hn_rss
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nchan
decl_stmt|;
name|nchan
operator|=
name|sc
operator|->
name|hn_rx_ring_inuse
expr_stmt|;
name|KASSERT
argument_list|(
name|nchan
operator|>
literal|1
argument_list|,
operator|(
literal|"invalid # of channels %d"
operator|,
name|nchan
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check indirect table to make sure that all channels in it 	 * can be used. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDIS_HASH_INDCNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rss
operator|->
name|rss_ind
index|[
name|i
index|]
operator|>=
name|nchan
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"RSS indirect table %d fixup: %u -> %d\n"
argument_list|,
name|i
argument_list|,
name|rss
operator|->
name|rss_ind
index|[
name|i
index|]
argument_list|,
name|nchan
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rss
operator|->
name|rss_ind
index|[
name|i
index|]
operator|=
name|nchan
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_link_flags
operator|&
name|HN_LINK_FLAG_LINKUP
operator|)
operator|==
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
operator||
name|IFM_FDX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_update_vf_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_update_vf
modifier|*
name|uv
init|=
name|arg
decl_stmt|;
name|uv
operator|->
name|rxr
operator|->
name|hn_rxvf_ifp
operator|=
name|uv
operator|->
name|vf
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_update_vf
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|struct
name|hn_update_vf
name|uv
decl_stmt|;
name|struct
name|task
name|task
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|task
argument_list|,
literal|0
argument_list|,
name|hn_update_vf_task
argument_list|,
operator|&
name|uv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_inuse
condition|)
block|{
name|uv
operator|.
name|rxr
operator|=
name|rxr
expr_stmt|;
name|uv
operator|.
name|vf
operator|=
name|vf
expr_stmt|;
name|vmbus_chan_run_task
argument_list|(
name|rxr
operator|->
name|hn_chan
argument_list|,
operator|&
name|task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxr
operator|->
name|hn_rxvf_ifp
operator|=
name|vf
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|hn_ismyvf
parameter_list|(
specifier|const
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
specifier|const
name|struct
name|ifnet
modifier|*
name|hn_ifp
decl_stmt|;
name|hn_ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|hn_ifp
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_alloctype
operator|!=
name|IFT_ETHER
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Ignore lagg/vlan interfaces */
if|if
condition|(
name|strcmp
argument_list|(
name|ifp
operator|->
name|if_dname
argument_list|,
literal|"lagg"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ifp
operator|->
name|if_dname
argument_list|,
literal|"vlan"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|IF_LLADDR
argument_list|(
name|hn_ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_set_vf
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|bool
name|vf
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|hn_ifp
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|hn_ismyvf
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hn_ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
comment|/* Now we're sure 'ifp' is a real VF device. */
if|if
condition|(
name|vf
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_VF
condition|)
goto|goto
name|out
goto|;
name|sc
operator|->
name|hn_flags
operator||=
name|HN_FLAG_VF
expr_stmt|;
name|hn_rxfilter_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_VF
operator|)
condition|)
goto|goto
name|out
goto|;
name|sc
operator|->
name|hn_flags
operator|&=
operator|~
name|HN_FLAG_VF
expr_stmt|;
if|if
condition|(
name|hn_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|hn_rxfilter_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|hn_set_rxfilter
argument_list|(
name|sc
argument_list|,
name|NDIS_PACKET_TYPE_NONE
argument_list|)
expr_stmt|;
block|}
name|hn_nvs_set_datapath
argument_list|(
name|sc
argument_list|,
name|vf
condition|?
name|HN_NVS_DATAPATH_VF
else|:
name|HN_NVS_DATAPATH_SYNTHETIC
argument_list|)
expr_stmt|;
name|hn_update_vf
argument_list|(
name|sc
argument_list|,
name|vf
condition|?
name|ifp
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf
condition|)
block|{
name|hn_suspend_mgmt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_link_flags
operator|&=
operator|~
operator|(
name|HN_LINK_FLAG_LINKUP
operator||
name|HN_LINK_FLAG_NETCHG
operator|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|hn_ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hn_resume_mgmt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|devctl_notify
argument_list|(
literal|"HYPERV_NIC_VF"
argument_list|,
name|if_name
argument_list|(
name|hn_ifp
argument_list|)
argument_list|,
name|vf
condition|?
literal|"VF_UP"
else|:
literal|"VF_DOWN"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|hn_ifp
argument_list|,
literal|"Data path is switched %s %s\n"
argument_list|,
name|vf
condition|?
literal|"to"
else|:
literal|"from"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_ifnet_event
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|!=
name|IFNET_EVENT_UP
operator|&&
name|event
operator|!=
name|IFNET_EVENT_DOWN
condition|)
return|return;
name|hn_set_vf
argument_list|(
name|arg
argument_list|,
name|ifp
argument_list|,
name|event
operator|==
name|IFNET_EVENT_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_ifaddr_event
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|hn_set_vf
argument_list|(
name|arg
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_ifnet_attevent
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|hn_ismyvf
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|sc
operator|->
name|hn_vf_ifp
operator|!=
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"%s was attached as VF\n"
argument_list|,
name|sc
operator|->
name|hn_vf_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rm_wlock
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_index
operator|>=
name|hn_vfmap_size
condition|)
block|{
name|struct
name|ifnet
modifier|*
modifier|*
name|newmap
decl_stmt|;
name|int
name|newsize
decl_stmt|;
name|newsize
operator|=
name|ifp
operator|->
name|if_index
operator|+
name|HN_VFMAP_SIZE_DEF
expr_stmt|;
name|newmap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
operator|*
name|newsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newmap
argument_list|,
name|hn_vfmap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
operator|*
name|hn_vfmap_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hn_vfmap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|hn_vfmap
operator|=
name|newmap
expr_stmt|;
name|hn_vfmap_size
operator|=
name|newsize
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|hn_vfmap
index|[
name|ifp
operator|->
name|if_index
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: ifindex %d was mapped to %s"
operator|,
name|ifp
operator|->
name|if_xname
operator|,
name|ifp
operator|->
name|if_index
operator|,
name|hn_vfmap
index|[
name|ifp
operator|->
name|if_index
index|]
operator|->
name|if_xname
operator|)
argument_list|)
expr_stmt|;
name|hn_vfmap
index|[
name|ifp
operator|->
name|if_index
index|]
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
name|rm_wunlock
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_vf_ifp
operator|=
name|ifp
expr_stmt|;
name|done
label|:
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_ifnet_detevent
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_vf_ifp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|hn_ismyvf
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|sc
operator|->
name|hn_vf_ifp
operator|=
name|NULL
expr_stmt|;
name|rm_wlock
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|->
name|if_index
operator|<
name|hn_vfmap_size
argument_list|,
operator|(
literal|"ifindex %d, vfmapsize %d"
operator|,
name|ifp
operator|->
name|if_index
operator|,
name|hn_vfmap_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hn_vfmap
index|[
name|ifp
operator|->
name|if_index
index|]
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|hn_vfmap
index|[
name|ifp
operator|->
name|if_index
index|]
operator|==
name|sc
operator|->
name|hn_ifp
argument_list|,
operator|(
literal|"%s: ifindex %d was mapped to %s"
operator|,
name|ifp
operator|->
name|if_xname
operator|,
name|ifp
operator|->
name|if_index
operator|,
name|hn_vfmap
index|[
name|ifp
operator|->
name|if_index
index|]
operator|->
name|if_xname
operator|)
argument_list|)
expr_stmt|;
name|hn_vfmap
index|[
name|ifp
operator|->
name|if_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|rm_wunlock
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|)
expr_stmt|;
name|done
label|:
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* {F8615163-DF3E-46c5-913F-F2D2F965ED0E} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|hyperv_guid
name|g_net_vsc_device_type
init|=
block|{
operator|.
name|hv_guid
operator|=
block|{
literal|0x63
block|,
literal|0x51
block|,
literal|0x61
block|,
literal|0xF8
block|,
literal|0x3E
block|,
literal|0xDF
block|,
literal|0xc5
block|,
literal|0x46
block|,
literal|0x91
block|,
literal|0x3F
block|,
literal|0xF2
block|,
literal|0xD2
block|,
literal|0xF9
block|,
literal|0x65
block|,
literal|0xED
block|,
literal|0x0E
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|hn_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|VMBUS_PROBE_GUID
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
operator|&
name|g_net_vsc_device_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Hyper-V Network Interface"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|uint8_t
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ring_cnt
decl_stmt|,
name|tx_ring_cnt
decl_stmt|;
name|sc
operator|->
name|hn_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|hn_prichan
operator|=
name|vmbus_get_channel
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|HN_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize these tunables once. 	 */
name|sc
operator|->
name|hn_agg_size
operator|=
name|hn_tx_agg_size
expr_stmt|;
name|sc
operator|->
name|hn_agg_pkts
operator|=
name|hn_tx_agg_pkts
expr_stmt|;
comment|/* 	 * Setup taskqueue for transmission. 	 */
if|if
condition|(
name|hn_tx_taskq_mode
operator|==
name|HN_TX_TASKQ_M_INDEP
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|hn_tx_taskqs
operator|=
name|malloc
argument_list|(
name|hn_tx_taskq_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|taskqueue
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hn_tx_taskq_cnt
condition|;
operator|++
name|i
control|)
block|{
name|sc
operator|->
name|hn_tx_taskqs
index|[
name|i
index|]
operator|=
name|taskqueue_create
argument_list|(
literal|"hn_tx"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|hn_tx_taskqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|hn_tx_taskqs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s tx%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hn_tx_taskq_mode
operator|==
name|HN_TX_TASKQ_M_GLOBAL
condition|)
block|{
name|sc
operator|->
name|hn_tx_taskqs
operator|=
name|hn_tx_taskque
expr_stmt|;
block|}
comment|/* 	 * Setup taskqueue for mangement tasks, e.g. link status. 	 */
name|sc
operator|->
name|hn_mgmt_taskq0
operator|=
name|taskqueue_create
argument_list|(
literal|"hn_mgmt"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|hn_mgmt_taskq0
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|hn_mgmt_taskq0
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s mgmt"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|hn_link_task
argument_list|,
literal|0
argument_list|,
name|hn_link_taskfunc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|hn_netchg_init
argument_list|,
literal|0
argument_list|,
name|hn_netchg_init_taskfunc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|sc
operator|->
name|hn_mgmt_taskq0
argument_list|,
operator|&
name|sc
operator|->
name|hn_netchg_status
argument_list|,
literal|0
argument_list|,
name|hn_netchg_status_taskfunc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate ifnet and setup its name earlier, so that if_printf 	 * can be used by functions, which will be called after 	 * ether_ifattach(). 	 */
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize ifmedia earlier so that it can be unconditionally 	 * destroyed, if error happened later on. 	 */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
literal|0
argument_list|,
name|hn_ifmedia_upd
argument_list|,
name|hn_ifmedia_sts
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out the # of RX rings (ring_cnt) and the # of TX rings 	 * to use (tx_ring_cnt). 	 * 	 * NOTE: 	 * The # of RX rings to use is same as the # of channels to use. 	 */
name|ring_cnt
operator|=
name|hn_chan_cnt
expr_stmt|;
if|if
condition|(
name|ring_cnt
operator|<=
literal|0
condition|)
block|{
comment|/* Default */
name|ring_cnt
operator|=
name|mp_ncpus
expr_stmt|;
if|if
condition|(
name|ring_cnt
operator|>
name|HN_RING_CNT_DEF_MAX
condition|)
name|ring_cnt
operator|=
name|HN_RING_CNT_DEF_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ring_cnt
operator|>
name|mp_ncpus
condition|)
block|{
name|ring_cnt
operator|=
name|mp_ncpus
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|ring_cnt
operator|>
name|rss_getnumbuckets
argument_list|()
condition|)
name|ring_cnt
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tx_ring_cnt
operator|=
name|hn_tx_ring_cnt
expr_stmt|;
if|if
condition|(
name|tx_ring_cnt
operator|<=
literal|0
operator|||
name|tx_ring_cnt
operator|>
name|ring_cnt
condition|)
name|tx_ring_cnt
operator|=
name|ring_cnt
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
if|if
condition|(
name|hn_use_if_start
condition|)
block|{
comment|/* ifnet.if_start only needs one TX ring. */
name|tx_ring_cnt
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Set the leader CPU for channels. 	 */
name|sc
operator|->
name|hn_cpu
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|hn_cpu_index
argument_list|,
name|ring_cnt
argument_list|)
operator|%
name|mp_ncpus
expr_stmt|;
comment|/* 	 * Create enough TX/RX rings, even if only limited number of 	 * channels can be allocated. 	 */
name|error
operator|=
name|hn_create_tx_data
argument_list|(
name|sc
argument_list|,
name|tx_ring_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|error
operator|=
name|hn_create_rx_data
argument_list|(
name|sc
argument_list|,
name|ring_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * Create transaction context for NVS and RNDIS transactions. 	 */
name|sc
operator|->
name|hn_xact
operator|=
name|vmbus_xact_ctx_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
name|HN_XACT_REQ_SIZE
argument_list|,
name|HN_XACT_RESP_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_xact
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Install orphan handler for the revocation of this device's 	 * primary channel. 	 * 	 * NOTE: 	 * The processing order is critical here: 	 * Install the orphan handler, _before_ testing whether this 	 * device's primary channel has been revoked or not. 	 */
name|vmbus_chan_set_orphan
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|,
name|sc
operator|->
name|hn_xact
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmbus_chan_is_revoked
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Attach the synthetic parts, i.e. NVS and RNDIS. 	 */
name|error
operator|=
name|hn_synth_attach
argument_list|(
name|sc
argument_list|,
name|ETHERMTU
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|error
operator|=
name|hn_rndis_get_eaddr
argument_list|(
name|sc
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100099
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring_inuse
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Reduce TCP segment aggregation limit for multiple 		 * RX rings to increase ACK timeliness. 		 */
name|hn_set_lro_lenlim
argument_list|(
name|sc
argument_list|,
name|HN_LRO_LENLIM_MULTIRX_DEF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Fixup TX stuffs after synthetic parts are attached. 	 */
name|hn_fixup_tx_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nvs_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_nvs_ver
argument_list|,
literal|0
argument_list|,
literal|"NVS version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ndis_version"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_ndis_version_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"NDIS version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"caps"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_caps_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hwassist"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_hwassist_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"hwassist"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxfilter"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_rxfilter_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"rxfilter"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rss_hash"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_rss_hash_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"RSS hash"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rss_ind_size"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_rss_ind_size
argument_list|,
literal|0
argument_list|,
literal|"RSS indirect entry count"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RSS
comment|/* 	 * Don't allow RSS key/indirect table changes, if RSS is defined. 	 */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rss_key"
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_rss_key_sysctl
argument_list|,
literal|"IU"
argument_list|,
literal|"RSS key"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rss_ind"
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_rss_ind_sysctl
argument_list|,
literal|"IU"
argument_list|,
literal|"RSS indirect table"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rndis_agg_size"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_rndis_agg_size
argument_list|,
literal|0
argument_list|,
literal|"RNDIS offered packet transmission aggregation size limit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rndis_agg_pkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_rndis_agg_pkts
argument_list|,
literal|0
argument_list|,
literal|"RNDIS offered packet transmission aggregation count limit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rndis_agg_align"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_rndis_agg_align
argument_list|,
literal|0
argument_list|,
literal|"RNDIS packet transmission aggregation alignment"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"agg_size"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_txagg_size_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Packet transmission aggregation size, 0 -- disable, -1 -- auto"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"agg_pkts"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_txagg_pkts_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Packet transmission aggregation packets, "
literal|"0 -- disable, -1 -- auto"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"polling"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_polling_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Polling frequency: [100,1000000], 0 disable polling"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vf"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_vf_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"Virtual Function's name"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxvf"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_rxvf_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"activated Virtual Function's name"
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the ifmedia, which has been initialized earlier. 	 */
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* XXX ifmedia_set really should do this for us */
name|sc
operator|->
name|hn_media
operator|.
name|ifm_media
operator|=
name|sc
operator|->
name|hn_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
comment|/* 	 * Setup the ifnet for this interface. 	 */
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|hn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|hn_init
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
if|if
condition|(
name|hn_use_if_start
condition|)
block|{
name|int
name|qdepth
init|=
name|hn_get_txswq_depth
argument_list|(
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|hn_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|qdepth
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|qdepth
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ifp
operator|->
name|if_transmit
operator|=
name|hn_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|hn_xmit_qflush
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_RXCSUM
operator||
name|IFCAP_LRO
expr_stmt|;
ifdef|#
directive|ifdef
name|foo
comment|/* We can't diff IPv6 packets from IPv4 packets on RX path. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_VLAN
condition|)
block|{
comment|/* XXX not sure about VLAN_MTU. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
block|}
name|ifp
operator|->
name|if_hwassist
operator|=
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_csum_assist
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_hwassist
operator|&
name|HN_CSUM_IP_MASK
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_hwassist
operator|&
name|HN_CSUM_IP6_MASK
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP_TSO
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP6_TSO
expr_stmt|;
block|}
comment|/* Enable all available capabilities by default. */
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Disable IPv6 TSO and TXCSUM by default, they still can 	 * be enabled through SIOCSIFCAP. 	 */
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|HN_CSUM_IP6_MASK
operator||
name|CSUM_IP6_TSO
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
operator|(
name|IFCAP_TSO6
operator||
name|IFCAP_TSO4
operator|)
condition|)
block|{
name|hn_set_tso_maxsize
argument_list|(
name|sc
argument_list|,
name|hn_tso_maxlen
argument_list|,
name|ETHERMTU
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|HN_TX_DATA_SEGCNT_MAX
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
name|PAGE_SIZE
expr_stmt|;
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
operator|(
name|IFCAP_TSO6
operator||
name|IFCAP_TSO4
operator|)
operator|)
operator|&&
name|bootverbose
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO segcnt %u segsz %u\n"
argument_list|,
name|ifp
operator|->
name|if_hw_tsomaxsegcount
argument_list|,
name|ifp
operator|->
name|if_hw_tsomaxsegsize
argument_list|)
expr_stmt|;
block|}
comment|/* Inform the upper layer about the long frame support. */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off link status check. 	 */
name|sc
operator|->
name|hn_mgmt_taskq
operator|=
name|sc
operator|->
name|hn_mgmt_taskq0
expr_stmt|;
name|hn_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_ifnet_evthand
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_event
argument_list|,
name|hn_ifnet_event
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_ifaddr_evthand
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifaddr_event
argument_list|,
name|hn_ifaddr_event
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_ifnet_atthand
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ether_ifattach_event
argument_list|,
name|hn_ifnet_attevent
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_ifnet_dethand
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|hn_ifnet_detevent
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
condition|)
name|hn_synth_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|,
modifier|*
name|vf_ifp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_ifaddr_evthand
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifaddr_event
argument_list|,
name|sc
operator|->
name|hn_ifaddr_evthand
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_ifnet_evthand
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_event
argument_list|,
name|sc
operator|->
name|hn_ifnet_evthand
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_ifnet_atthand
operator|!=
name|NULL
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ether_ifattach_event
argument_list|,
name|sc
operator|->
name|hn_ifnet_atthand
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|hn_ifnet_dethand
operator|!=
name|NULL
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|sc
operator|->
name|hn_ifnet_dethand
argument_list|)
expr_stmt|;
block|}
name|vf_ifp
operator|=
name|sc
operator|->
name|hn_vf_ifp
expr_stmt|;
name|__compiler_membar
argument_list|()
expr_stmt|;
if|if
condition|(
name|vf_ifp
operator|!=
name|NULL
condition|)
name|hn_ifnet_detevent
argument_list|(
name|sc
argument_list|,
name|vf_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_xact
operator|!=
name|NULL
operator|&&
name|vmbus_chan_is_revoked
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|)
condition|)
block|{
comment|/* 		 * In case that the vmbus missed the orphan handler 		 * installation. 		 */
name|vmbus_xact_ctx_orphan
argument_list|(
name|sc
operator|->
name|hn_xact
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|hn_stop
argument_list|(
name|sc
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* 			 * NOTE: 			 * hn_stop() only suspends data, so managment 			 * stuffs have to be suspended manually here. 			 */
name|hn_suspend_mgmt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_synth_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|)
expr_stmt|;
name|hn_destroy_rx_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_destroy_tx_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_tx_taskqs
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|hn_tx_taskqs
operator|!=
name|hn_tx_taskque
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hn_tx_taskq_cnt
condition|;
operator|++
name|i
control|)
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|hn_tx_taskqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|hn_tx_taskqs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|hn_mgmt_taskq0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_xact
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Uninstall the orphan handler _before_ the xact is 		 * destructed. 		 */
name|vmbus_chan_unset_orphan
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|)
expr_stmt|;
name|vmbus_xact_ctx_destroy
argument_list|(
name|sc
operator|->
name|hn_xact
argument_list|)
expr_stmt|;
block|}
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|HN_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_link_status
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|link_status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|hn_rndis_get_linkstatus
argument_list|(
name|sc
argument_list|,
operator|&
name|link_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* XXX what to do? */
return|return;
block|}
if|if
condition|(
name|link_status
operator|==
name|NDIS_MEDIA_STATE_CONNECTED
condition|)
name|sc
operator|->
name|hn_link_flags
operator||=
name|HN_LINK_FLAG_LINKUP
expr_stmt|;
else|else
name|sc
operator|->
name|hn_link_flags
operator|&=
operator|~
name|HN_LINK_FLAG_LINKUP
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
operator|(
name|sc
operator|->
name|hn_link_flags
operator|&
name|HN_LINK_FLAG_LINKUP
operator|)
condition|?
name|LINK_STATE_UP
else|:
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_link_taskfunc
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_link_flags
operator|&
name|HN_LINK_FLAG_NETCHG
condition|)
return|return;
name|hn_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_netchg_init_taskfunc
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
comment|/* Prevent any link status checks from running. */
name|sc
operator|->
name|hn_link_flags
operator||=
name|HN_LINK_FLAG_NETCHG
expr_stmt|;
comment|/* 	 * Fake up a [link down --> link up] state change; 5 seconds 	 * delay is used, which closely simulates miibus reaction 	 * upon link down event. 	 */
name|sc
operator|->
name|hn_link_flags
operator|&=
operator|~
name|HN_LINK_FLAG_LINKUP
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_timeout
argument_list|(
name|sc
operator|->
name|hn_mgmt_taskq0
argument_list|,
operator|&
name|sc
operator|->
name|hn_netchg_status
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_netchg_status_taskfunc
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
comment|/* Re-allow link status checks. */
name|sc
operator|->
name|hn_link_flags
operator|&=
operator|~
name|HN_LINK_FLAG_NETCHG
expr_stmt|;
name|hn_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_update_link_status
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|hn_mgmt_taskq
operator|!=
name|NULL
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|hn_mgmt_taskq
argument_list|,
operator|&
name|sc
operator|->
name|hn_link_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_change_network
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|hn_mgmt_taskq
operator|!=
name|NULL
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|hn_mgmt_taskq
argument_list|,
operator|&
name|sc
operator|->
name|hn_netchg_init
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hn_txdesc_dmamap_load
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m_head
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|chim_index
operator|==
name|HN_NVS_CHIM_IDX_INVALID
argument_list|,
operator|(
literal|"txd uses chim"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|m_new
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|HN_TX_DATA_SEGCNT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
else|else
operator|*
name|m_head
operator|=
name|m
operator|=
name|m_new
expr_stmt|;
name|txr
operator|->
name|hn_tx_collapsed
operator|++
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|txd
operator|->
name|flags
operator||=
name|HN_TXD_FLAG_DMAMAP
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hn_txdesc_put
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONLIST
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"put an onlist txd %#x"
operator|,
name|txd
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONAGG
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"put an onagg txd %#x"
operator|,
name|txd
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|refs
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid txd refs %d"
operator|,
name|txd
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|txd
operator|->
name|refs
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|txd
operator|->
name|agg_list
argument_list|)
condition|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|tmp_txd
decl_stmt|;
while|while
condition|(
operator|(
name|tmp_txd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txd
operator|->
name|agg_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|freed
decl_stmt|;
name|KASSERT
argument_list|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|tmp_txd
operator|->
name|agg_list
argument_list|)
argument_list|,
operator|(
literal|"resursive aggregation on aggregated txdesc"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tmp_txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONAGG
operator|)
argument_list|,
operator|(
literal|"not aggregated txdesc"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tmp_txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_DMAMAP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"aggregated txdesc uses dmamap"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tmp_txd
operator|->
name|chim_index
operator|==
name|HN_NVS_CHIM_IDX_INVALID
argument_list|,
operator|(
literal|"aggregated txdesc consumes "
literal|"chimney sending buffer"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tmp_txd
operator|->
name|chim_size
operator|==
literal|0
argument_list|,
operator|(
literal|"aggregated txdesc has non-zero "
literal|"chimney sending size"
operator|)
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txd
operator|->
name|agg_list
argument_list|,
name|agg_link
argument_list|)
expr_stmt|;
name|tmp_txd
operator|->
name|flags
operator|&=
operator|~
name|HN_TXD_FLAG_ONAGG
expr_stmt|;
name|freed
operator|=
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|tmp_txd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|freed
argument_list|,
operator|(
literal|"failed to free aggregated txdesc"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|txd
operator|->
name|chim_index
operator|!=
name|HN_NVS_CHIM_IDX_INVALID
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_DMAMAP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"chim txd uses dmamap"
operator|)
argument_list|)
expr_stmt|;
name|hn_chim_free
argument_list|(
name|txr
operator|->
name|hn_sc
argument_list|,
name|txd
operator|->
name|chim_index
argument_list|)
expr_stmt|;
name|txd
operator|->
name|chim_index
operator|=
name|HN_NVS_CHIM_IDX_INVALID
expr_stmt|;
name|txd
operator|->
name|chim_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_DMAMAP
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
name|txd
operator|->
name|flags
operator|&=
operator|~
name|HN_TXD_FLAG_DMAMAP
expr_stmt|;
block|}
if|if
condition|(
name|txd
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txd
operator|->
name|m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|txd
operator|->
name|flags
operator||=
name|HN_TXD_FLAG_ONLIST
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_lock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_txdesc_avail
operator|>=
literal|0
operator|&&
name|txr
operator|->
name|hn_txdesc_avail
operator|<
name|txr
operator|->
name|hn_txdesc_cnt
argument_list|,
operator|(
literal|"txdesc_put: invalid txd avail %d"
operator|,
name|txr
operator|->
name|hn_txdesc_avail
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdesc_avail
operator|++
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|,
name|txd
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HN_USE_TXDESC_BUFRING */
ifdef|#
directive|ifdef
name|HN_DEBUG
name|atomic_add_int
argument_list|(
operator|&
name|txr
operator|->
name|hn_txdesc_avail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf_ring_enqueue
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|,
name|txd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HN_USE_TXDESC_BUFRING */
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|hn_txdesc
operator|*
name|hn_txdesc_get
argument_list|(
argument|struct hn_tx_ring *txr
argument_list|)
block|{ 	struct
name|hn_txdesc
operator|*
name|txd
block|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_lock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
block|;
name|txd
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|)
block|;
if|if
condition|(
name|txd
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_txdesc_avail
operator|>
literal|0
argument_list|,
operator|(
literal|"txdesc_get: invalid txd avail %d"
operator|,
name|txr
operator|->
name|hn_txdesc_avail
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdesc_avail
operator|--
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|txd
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|txd
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HN_USE_TXDESC_BUFRING
ifdef|#
directive|ifdef
name|HN_DEBUG
name|atomic_subtract_int
argument_list|(
operator|&
name|txr
operator|->
name|hn_txdesc_avail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HN_USE_TXDESC_BUFRING */
name|KASSERT
argument_list|(
name|txd
operator|->
name|m
operator|==
name|NULL
operator|&&
name|txd
operator|->
name|refs
operator|==
literal|0
operator|&&
name|STAILQ_EMPTY
argument_list|(
operator|&
name|txd
operator|->
name|agg_list
argument_list|)
operator|&&
name|txd
operator|->
name|chim_index
operator|==
name|HN_NVS_CHIM_IDX_INVALID
operator|&&
name|txd
operator|->
name|chim_size
operator|==
literal|0
operator|&&
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONLIST
operator|)
operator|&&
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONAGG
operator|)
operator|==
literal|0
operator|&&
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_DMAMAP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid txd"
operator|)
argument_list|)
expr_stmt|;
name|txd
operator|->
name|flags
operator|&=
operator|~
name|HN_TXD_FLAG_ONLIST
expr_stmt|;
name|txd
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_return
return|return
name|txd
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|hn_txdesc_hold
parameter_list|(
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
comment|/* 0->1 transition will never work */
name|KASSERT
argument_list|(
name|txd
operator|->
name|refs
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid txd refs %d"
operator|,
name|txd
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|txd
operator|->
name|refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|hn_txdesc_agg
parameter_list|(
name|struct
name|hn_txdesc
modifier|*
name|agg_txd
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|agg_txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONAGG
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"recursive aggregation on aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONAGG
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"already aggregated"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|txd
operator|->
name|agg_list
argument_list|)
argument_list|,
operator|(
literal|"recursive aggregation on to-be-aggregated txdesc"
operator|)
argument_list|)
expr_stmt|;
name|txd
operator|->
name|flags
operator||=
name|HN_TXD_FLAG_ONAGG
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|agg_txd
operator|->
name|agg_list
argument_list|,
name|txd
argument_list|,
name|agg_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|hn_tx_ring_pending
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|bool
name|pending
init|=
name|false
decl_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_lock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_txdesc_avail
operator|!=
name|txr
operator|->
name|hn_txdesc_cnt
condition|)
name|pending
operator|=
name|true
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|buf_ring_full
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|)
condition|)
name|pending
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pending
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|hn_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|txr
operator|->
name|hn_has_txeof
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_txpkt_done
parameter_list|(
name|struct
name|hn_nvs_sendctx
modifier|*
name|sndc
parameter_list|,
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|void
modifier|*
name|data
name|__unused
parameter_list|,
name|int
name|dlen
name|__unused
parameter_list|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
init|=
name|sndc
operator|->
name|hn_cbarg
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|txr
operator|=
name|txd
operator|->
name|txr
expr_stmt|;
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_chan
operator|==
name|chan
argument_list|,
operator|(
literal|"channel mismatch, on chan%u, should be chan%u"
operator|,
name|vmbus_chan_id
argument_list|(
name|chan
argument_list|)
operator|,
name|vmbus_chan_id
argument_list|(
name|txr
operator|->
name|hn_chan
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_has_txeof
operator|=
literal|1
expr_stmt|;
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
operator|++
name|txr
operator|->
name|hn_txdone_cnt
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_txdone_cnt
operator|>=
name|HN_EARLY_TXEOF_THRESH
condition|)
block|{
name|txr
operator|->
name|hn_txdone_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_oactive
condition|)
name|hn_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_chan_rollup
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
name|rxr
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|tcp_lro_flush_all
argument_list|(
operator|&
name|rxr
operator|->
name|hn_lro
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * NOTE: 	 * 'txr' could be NULL, if multiple channels and 	 * ifnet.if_start method are enabled. 	 */
if|if
condition|(
name|txr
operator|==
name|NULL
operator|||
operator|!
name|txr
operator|->
name|hn_has_txeof
condition|)
return|return;
name|txr
operator|->
name|hn_txdone_cnt
operator|=
literal|0
expr_stmt|;
name|hn_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|hn_rndis_pktmsg_offset
parameter_list|(
name|uint32_t
name|ofs
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ofs
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|rndis_packet_msg
argument_list|)
argument_list|,
operator|(
literal|"invalid RNDIS packet msg offset %u"
operator|,
name|ofs
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ofs
operator|-
name|__offsetof
argument_list|(
expr|struct
name|rndis_packet_msg
argument_list|,
name|rm_dataoffset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
modifier|*
name|hn_rndis_pktinfo_append
parameter_list|(
name|struct
name|rndis_packet_msg
modifier|*
name|pkt
parameter_list|,
name|size_t
name|pktsize
parameter_list|,
name|size_t
name|pi_dlen
parameter_list|,
name|uint32_t
name|pi_type
parameter_list|)
block|{
specifier|const
name|size_t
name|pi_size
init|=
name|HN_RNDIS_PKTINFO_SIZE
argument_list|(
name|pi_dlen
argument_list|)
decl_stmt|;
name|struct
name|rndis_pktinfo
modifier|*
name|pi
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pi_size
operator|&
name|RNDIS_PACKET_MSG_OFFSET_ALIGNMASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"unaligned pktinfo size %zu, pktinfo dlen %zu"
operator|,
name|pi_size
operator|,
name|pi_dlen
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Per-packet-info does not move; it only grows. 	 * 	 * NOTE: 	 * rm_pktinfooffset in this phase counts from the beginning 	 * of rndis_packet_msg. 	 */
name|KASSERT
argument_list|(
name|pkt
operator|->
name|rm_pktinfooffset
operator|+
name|pkt
operator|->
name|rm_pktinfolen
operator|+
name|pi_size
operator|<=
name|pktsize
argument_list|,
operator|(
literal|"%u pktinfo overflows RNDIS packet msg"
operator|,
name|pi_type
operator|)
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
expr|struct
name|rndis_pktinfo
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|pkt
operator|+
name|pkt
operator|->
name|rm_pktinfooffset
operator|+
name|pkt
operator|->
name|rm_pktinfolen
operator|)
expr_stmt|;
name|pkt
operator|->
name|rm_pktinfolen
operator|+=
name|pi_size
expr_stmt|;
name|pi
operator|->
name|rm_size
operator|=
name|pi_size
expr_stmt|;
name|pi
operator|->
name|rm_type
operator|=
name|pi_type
expr_stmt|;
name|pi
operator|->
name|rm_pktinfooffset
operator|=
name|RNDIS_PKTINFO_OFFSET
expr_stmt|;
return|return
operator|(
name|pi
operator|->
name|rm_data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hn_flush_txagg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pkts
decl_stmt|;
name|txd
operator|=
name|txr
operator|->
name|hn_agg_txd
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no aggregate txdesc"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Since hn_txpkt() will reset this temporary stat, save 	 * it now, so that oerrors can be updated properly, if 	 * hn_txpkt() ever fails. 	 */
name|pkts
operator|=
name|txr
operator|->
name|hn_stat_pkts
expr_stmt|;
comment|/* 	 * Since txd's mbuf will _not_ be freed upon hn_txpkt() 	 * failure, save it for later freeing, if hn_txpkt() ever 	 * fails. 	 */
name|m
operator|=
name|txd
operator|->
name|m
expr_stmt|;
name|error
operator|=
name|hn_txpkt
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
comment|/* txd is freed, but m is not. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_flush_failed
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
name|pkts
argument_list|)
expr_stmt|;
block|}
comment|/* Reset all aggregation states. */
name|txr
operator|->
name|hn_agg_txd
operator|=
name|NULL
expr_stmt|;
name|txr
operator|->
name|hn_agg_szleft
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_agg_pktleft
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_agg_prevpkt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|hn_try_txagg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|,
name|int
name|pktsize
parameter_list|)
block|{
name|void
modifier|*
name|chim
decl_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|hn_agg_pktleft
operator|>=
literal|1
operator|&&
name|txr
operator|->
name|hn_agg_szleft
operator|>
name|pktsize
condition|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|agg_txd
init|=
name|txr
operator|->
name|hn_agg_txd
decl_stmt|;
name|struct
name|rndis_packet_msg
modifier|*
name|pkt
init|=
name|txr
operator|->
name|hn_agg_prevpkt
decl_stmt|;
name|int
name|olen
decl_stmt|;
comment|/* 			 * Update the previous RNDIS packet's total length, 			 * it can be increased due to the mandatory alignment 			 * padding for this RNDIS packet.  And update the 			 * aggregating txdesc's chimney sending buffer size 			 * accordingly. 			 * 			 * XXX 			 * Zero-out the padding, as required by the RNDIS spec. 			 */
name|olen
operator|=
name|pkt
operator|->
name|rm_len
expr_stmt|;
name|pkt
operator|->
name|rm_len
operator|=
name|roundup2
argument_list|(
name|olen
argument_list|,
name|txr
operator|->
name|hn_agg_align
argument_list|)
expr_stmt|;
name|agg_txd
operator|->
name|chim_size
operator|+=
name|pkt
operator|->
name|rm_len
operator|-
name|olen
expr_stmt|;
comment|/* Link this txdesc to the parent. */
name|hn_txdesc_agg
argument_list|(
name|agg_txd
argument_list|,
name|txd
argument_list|)
expr_stmt|;
name|chim
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|pkt
operator|+
name|pkt
operator|->
name|rm_len
expr_stmt|;
comment|/* Save the current packet for later fixup. */
name|txr
operator|->
name|hn_agg_prevpkt
operator|=
name|chim
expr_stmt|;
name|txr
operator|->
name|hn_agg_pktleft
operator|--
expr_stmt|;
name|txr
operator|->
name|hn_agg_szleft
operator|-=
name|pktsize
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_agg_szleft
operator|<=
name|HN_PKTSIZE_MIN
argument_list|(
name|txr
operator|->
name|hn_agg_align
argument_list|)
condition|)
block|{
comment|/* 				 * Probably can't aggregate more packets, 				 * flush this aggregating txdesc proactively. 				 */
name|txr
operator|->
name|hn_agg_pktleft
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Done! */
return|return
operator|(
name|chim
operator|)
return|;
block|}
name|hn_flush_txagg
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_agg_txd
operator|==
name|NULL
argument_list|,
operator|(
literal|"lingering aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_tx_chimney_tried
operator|++
expr_stmt|;
name|txd
operator|->
name|chim_index
operator|=
name|hn_chim_alloc
argument_list|(
name|txr
operator|->
name|hn_sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|chim_index
operator|==
name|HN_NVS_CHIM_IDX_INVALID
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|txr
operator|->
name|hn_tx_chimney
operator|++
expr_stmt|;
name|chim
operator|=
name|txr
operator|->
name|hn_sc
operator|->
name|hn_chim
operator|+
operator|(
name|txd
operator|->
name|chim_index
operator|*
name|txr
operator|->
name|hn_sc
operator|->
name|hn_chim_szmax
operator|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_agg_pktmax
operator|>
literal|1
operator|&&
name|txr
operator|->
name|hn_agg_szmax
operator|>
name|pktsize
operator|+
name|HN_PKTSIZE_MIN
argument_list|(
name|txr
operator|->
name|hn_agg_align
argument_list|)
condition|)
block|{
name|txr
operator|->
name|hn_agg_txd
operator|=
name|txd
expr_stmt|;
name|txr
operator|->
name|hn_agg_pktleft
operator|=
name|txr
operator|->
name|hn_agg_pktmax
operator|-
literal|1
expr_stmt|;
name|txr
operator|->
name|hn_agg_szleft
operator|=
name|txr
operator|->
name|hn_agg_szmax
operator|-
name|pktsize
expr_stmt|;
name|txr
operator|->
name|hn_agg_prevpkt
operator|=
name|chim
expr_stmt|;
block|}
return|return
operator|(
name|chim
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE:  * If this function fails, then both txd and m_head0 will be freed.  */
end_comment

begin_function
specifier|static
name|int
name|hn_encap
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head0
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
name|HN_TX_DATA_SEGCNT_MAX
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
init|=
operator|*
name|m_head0
decl_stmt|;
name|struct
name|rndis_packet_msg
modifier|*
name|pkt
decl_stmt|;
name|uint32_t
modifier|*
name|pi_data
decl_stmt|;
name|void
modifier|*
name|chim
init|=
name|NULL
decl_stmt|;
name|int
name|pkt_hlen
decl_stmt|,
name|pkt_size
decl_stmt|;
name|pkt
operator|=
name|txd
operator|->
name|rndis_pkt
expr_stmt|;
name|pkt_size
operator|=
name|HN_PKTSIZE
argument_list|(
name|m_head
argument_list|,
name|txr
operator|->
name|hn_agg_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt_size
operator|<
name|txr
operator|->
name|hn_chim_size
condition|)
block|{
name|chim
operator|=
name|hn_try_txagg
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
name|pkt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|chim
operator|!=
name|NULL
condition|)
name|pkt
operator|=
name|chim
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
condition|)
name|hn_flush_txagg
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
block|}
name|pkt
operator|->
name|rm_type
operator|=
name|REMOTE_NDIS_PACKET_MSG
expr_stmt|;
name|pkt
operator|->
name|rm_len
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pkt
operator|->
name|rm_dataoffset
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|rm_datalen
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pkt
operator|->
name|rm_oobdataoffset
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|rm_oobdatalen
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|rm_oobdataelements
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|rm_pktinfooffset
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|rm_pktinfolen
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|rm_vchandle
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|rm_reserved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_tx_flags
operator|&
name|HN_TX_FLAG_HASHVAL
condition|)
block|{
comment|/* 		 * Set the hash value for this packet, so that the host could 		 * dispatch the TX done event for this packet back to this TX 		 * ring's channel. 		 */
name|pi_data
operator|=
name|hn_rndis_pktinfo_append
argument_list|(
name|pkt
argument_list|,
name|HN_RNDIS_PKT_LEN
argument_list|,
name|HN_NDIS_HASH_VALUE_SIZE
argument_list|,
name|HN_NDIS_PKTINFO_TYPE_HASHVAL
argument_list|)
expr_stmt|;
operator|*
name|pi_data
operator|=
name|txr
operator|->
name|hn_tx_idx
expr_stmt|;
block|}
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|pi_data
operator|=
name|hn_rndis_pktinfo_append
argument_list|(
name|pkt
argument_list|,
name|HN_RNDIS_PKT_LEN
argument_list|,
name|NDIS_VLAN_INFO_SIZE
argument_list|,
name|NDIS_PKTINFO_TYPE_VLAN
argument_list|)
expr_stmt|;
operator|*
name|pi_data
operator|=
name|NDIS_VLAN_INFO_MAKE
argument_list|(
name|EVL_VLANOFTAG
argument_list|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|,
name|EVL_PRIOFTAG
argument_list|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|,
name|EVL_CFIOFTAG
argument_list|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
name|pi_data
operator|=
name|hn_rndis_pktinfo_append
argument_list|(
name|pkt
argument_list|,
name|HN_RNDIS_PKT_LEN
argument_list|,
name|NDIS_LSO2_INFO_SIZE
argument_list|,
name|NDIS_PKTINFO_TYPE_LSO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_TSO
condition|)
block|{
operator|*
name|pi_data
operator|=
name|NDIS_LSO2_INFO_MAKEIPV4
argument_list|(
literal|0
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
operator|*
name|pi_data
operator|=
name|NDIS_LSO2_INFO_MAKEIPV6
argument_list|(
literal|0
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* INET6 || INET */
block|}
elseif|else
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|txr
operator|->
name|hn_csum_assist
condition|)
block|{
name|pi_data
operator|=
name|hn_rndis_pktinfo_append
argument_list|(
name|pkt
argument_list|,
name|HN_RNDIS_PKT_LEN
argument_list|,
name|NDIS_TXCSUM_INFO_SIZE
argument_list|,
name|NDIS_PKTINFO_TYPE_CSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP6_TCP
operator||
name|CSUM_IP6_UDP
operator|)
condition|)
block|{
operator|*
name|pi_data
operator|=
name|NDIS_TXCSUM_INFO_IPV6
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pi_data
operator|=
name|NDIS_TXCSUM_INFO_IPV4
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
operator|*
name|pi_data
operator||=
name|NDIS_TXCSUM_INFO_IPCS
expr_stmt|;
block|}
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_TCP
operator||
name|CSUM_IP6_TCP
operator|)
condition|)
operator|*
name|pi_data
operator||=
name|NDIS_TXCSUM_INFO_TCPCS
expr_stmt|;
elseif|else
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_UDP
operator||
name|CSUM_IP6_UDP
operator|)
condition|)
operator|*
name|pi_data
operator||=
name|NDIS_TXCSUM_INFO_UDPCS
expr_stmt|;
block|}
name|pkt_hlen
operator|=
name|pkt
operator|->
name|rm_pktinfooffset
operator|+
name|pkt
operator|->
name|rm_pktinfolen
expr_stmt|;
comment|/* Fixup RNDIS packet message total length */
name|pkt
operator|->
name|rm_len
operator|+=
name|pkt_hlen
expr_stmt|;
comment|/* Convert RNDIS packet message offsets */
name|pkt
operator|->
name|rm_dataoffset
operator|=
name|hn_rndis_pktmsg_offset
argument_list|(
name|pkt_hlen
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|rm_pktinfooffset
operator|=
name|hn_rndis_pktmsg_offset
argument_list|(
name|pkt
operator|->
name|rm_pktinfooffset
argument_list|)
expr_stmt|;
comment|/* 	 * Fast path: Chimney sending. 	 */
if|if
condition|(
name|chim
operator|!=
name|NULL
condition|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|tgt_txd
init|=
name|txd
decl_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
condition|)
block|{
name|tgt_txd
operator|=
name|txr
operator|->
name|hn_agg_txd
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
operator|*
name|m_head0
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|KASSERT
argument_list|(
name|pkt
operator|==
name|chim
argument_list|,
operator|(
literal|"RNDIS pkt not in chimney sending buffer"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tgt_txd
operator|->
name|chim_index
operator|!=
name|HN_NVS_CHIM_IDX_INVALID
argument_list|,
operator|(
literal|"chimney sending buffer is not used"
operator|)
argument_list|)
expr_stmt|;
name|tgt_txd
operator|->
name|chim_size
operator|+=
name|pkt
operator|->
name|rm_len
expr_stmt|;
name|m_copydata
argument_list|(
name|m_head
argument_list|,
literal|0
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|chim
operator|)
operator|+
name|pkt_hlen
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_gpa_cnt
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_sendpkt
operator|=
name|hn_txpkt_chim
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_agg_txd
operator|==
name|NULL
argument_list|,
operator|(
literal|"aggregating sglist txdesc"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|chim_index
operator|==
name|HN_NVS_CHIM_IDX_INVALID
argument_list|,
operator|(
literal|"chimney buffer is used"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pkt
operator|==
name|txd
operator|->
name|rndis_pkt
argument_list|,
operator|(
literal|"RNDIS pkt not in txdesc"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hn_txdesc_dmamap_load
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|,
operator|&
name|m_head
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|int
name|freed
decl_stmt|;
comment|/* 		 * This mbuf is not linked w/ the txd yet, so free it now. 		 */
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head0
operator|=
name|NULL
expr_stmt|;
name|freed
operator|=
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|freed
operator|!=
literal|0
argument_list|,
operator|(
literal|"fail to free txd upon txdma error"
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdma_failed
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
operator|*
name|m_head0
operator|=
name|m_head
expr_stmt|;
comment|/* +1 RNDIS packet message */
name|txr
operator|->
name|hn_gpa_cnt
operator|=
name|nsegs
operator|+
literal|1
expr_stmt|;
comment|/* send packet with page buffer */
name|txr
operator|->
name|hn_gpa
index|[
literal|0
index|]
operator|.
name|gpa_page
operator|=
name|atop
argument_list|(
name|txd
operator|->
name|rndis_pkt_paddr
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_gpa
index|[
literal|0
index|]
operator|.
name|gpa_ofs
operator|=
name|txd
operator|->
name|rndis_pkt_paddr
operator|&
name|PAGE_MASK
expr_stmt|;
name|txr
operator|->
name|hn_gpa
index|[
literal|0
index|]
operator|.
name|gpa_len
operator|=
name|pkt_hlen
expr_stmt|;
comment|/* 	 * Fill the page buffers with mbuf info after the page 	 * buffer for RNDIS packet message. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|vmbus_gpa
modifier|*
name|gpa
init|=
operator|&
name|txr
operator|->
name|hn_gpa
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|gpa
operator|->
name|gpa_page
operator|=
name|atop
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|gpa
operator|->
name|gpa_ofs
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|&
name|PAGE_MASK
expr_stmt|;
name|gpa
operator|->
name|gpa_len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
name|txd
operator|->
name|chim_index
operator|=
name|HN_NVS_CHIM_IDX_INVALID
expr_stmt|;
name|txd
operator|->
name|chim_size
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_sendpkt
operator|=
name|hn_txpkt_sglist
expr_stmt|;
name|done
label|:
name|txd
operator|->
name|m
operator|=
name|m_head
expr_stmt|;
comment|/* Set the completion routine */
name|hn_nvs_sendctx_init
argument_list|(
operator|&
name|txd
operator|->
name|send_ctx
argument_list|,
name|hn_txpkt_done
argument_list|,
name|txd
argument_list|)
expr_stmt|;
comment|/* Update temporary stats for later use. */
name|txr
operator|->
name|hn_stat_pkts
operator|++
expr_stmt|;
name|txr
operator|->
name|hn_stat_size
operator|+=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|txr
operator|->
name|hn_stat_mcasts
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE:  * If this function fails, then txd will be freed, but the mbuf  * associated w/ the txd will _not_ be freed.  */
end_comment

begin_function
specifier|static
name|int
name|hn_txpkt
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|send_failed
init|=
literal|0
decl_stmt|,
name|has_bpf
decl_stmt|;
name|again
label|:
name|has_bpf
operator|=
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_bpf
condition|)
block|{
comment|/* 		 * Make sure that this txd and any aggregated txds are not 		 * freed before ETHER_BPF_MTAP. 		 */
name|hn_txdesc_hold
argument_list|(
name|txd
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|txr
operator|->
name|hn_sendpkt
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|has_bpf
condition|)
block|{
specifier|const
name|struct
name|hn_txdesc
modifier|*
name|tmp_txd
decl_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|txd
operator|->
name|m
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|tmp_txd
argument_list|,
argument|&txd->agg_list
argument_list|,
argument|agg_link
argument_list|)
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|tmp_txd
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
name|txr
operator|->
name|hn_stat_pkts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
if|if
condition|(
operator|!
name|hn_use_if_start
condition|)
endif|#
directive|endif
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|txr
operator|->
name|hn_stat_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_stat_mcasts
operator|!=
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
name|txr
operator|->
name|hn_stat_mcasts
argument_list|)
expr_stmt|;
block|}
block|}
name|txr
operator|->
name|hn_pkts
operator|+=
name|txr
operator|->
name|hn_stat_pkts
expr_stmt|;
name|txr
operator|->
name|hn_sends
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|has_bpf
condition|)
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|int
name|freed
decl_stmt|;
comment|/* 		 * This should "really rarely" happen. 		 * 		 * XXX Too many RX to be acked or too many sideband 		 * commands to run?  Ask netvsc_channel_rollup() 		 * to kick start later. 		 */
name|txr
operator|->
name|hn_has_txeof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|send_failed
condition|)
block|{
name|txr
operator|->
name|hn_send_failed
operator|++
expr_stmt|;
name|send_failed
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Try sending again after set hn_has_txeof; 			 * in case that we missed the last 			 * netvsc_channel_rollup(). 			 */
goto|goto
name|again
goto|;
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"send failed\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Caller will perform further processing on the 		 * associated mbuf, so don't free it in hn_txdesc_put(); 		 * only unload it from the DMA map in hn_txdesc_put(), 		 * if it was loaded. 		 */
name|txd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|freed
operator|=
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|freed
operator|!=
literal|0
argument_list|,
operator|(
literal|"fail to free txd upon send error"
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_send_failed
operator|++
expr_stmt|;
block|}
comment|/* Reset temporary stats, after this sending is done. */
name|txr
operator|->
name|hn_stat_size
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_stat_pkts
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_stat_mcasts
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append the specified data to the indicated mbuf chain,  * Extend the mbuf chain if the new data does not fit in  * existing space.  *  * This is a minor rewrite of m_append() from sys/kern/uipc_mbuf.c.  * There should be an equivalent in the kernel mbuf code,  * but there does not appear to be one yet.  *  * Differs from m_append() in that additional mbufs are  * allocated with cluster size MJUMPAGESIZE, and filled  * accordingly.  *  * Return 1 if able to complete the job; otherwise 0.  */
end_comment

begin_function
specifier|static
name|int
name|hv_m_append
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|len
parameter_list|,
name|c_caddr_t
name|cp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|remainder
decl_stmt|,
name|space
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|remainder
operator|=
name|len
expr_stmt|;
name|space
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Copy into available space. 		 */
if|if
condition|(
name|space
operator|>
name|remainder
condition|)
name|space
operator|=
name|remainder
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|space
expr_stmt|;
name|cp
operator|+=
name|space
expr_stmt|;
name|remainder
operator|-=
name|space
expr_stmt|;
block|}
while|while
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Allocate a new mbuf; could check space 		 * and allocate a cluster instead. 		 */
name|n
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
literal|0
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
break|break;
name|n
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MJUMPAGESIZE
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|remainder
operator|-=
name|n
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
operator|-
name|remainder
expr_stmt|;
return|return
operator|(
name|remainder
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_function
specifier|static
name|__inline
name|int
name|hn_lro_rx
parameter_list|(
name|struct
name|lro_ctrl
modifier|*
name|lc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
if|if
condition|(
name|hn_lro_mbufq_depth
condition|)
block|{
name|tcp_lro_queue_mbuf
argument_list|(
name|lc
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
name|tcp_lro_rx
argument_list|(
name|lc
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|hn_rxpkt
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
name|rxr
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|,
specifier|const
name|struct
name|hn_rxinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|int
name|size
decl_stmt|,
name|do_lro
init|=
literal|0
decl_stmt|,
name|do_csum
init|=
literal|1
decl_stmt|;
name|int
name|hash_type
decl_stmt|;
comment|/* If the VF is active, inject the packet through the VF */
name|ifp
operator|=
name|rxr
operator|->
name|hn_rxvf_ifp
condition|?
name|rxr
operator|->
name|hn_rxvf_ifp
else|:
name|rxr
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NOTE: 		 * See the NOTE of hn_rndis_init_fixat().  This 		 * function can be reached, immediately after the 		 * RNDIS is initialized but before the ifnet is 		 * setup on the hn_attach() path; drop the unexpected 		 * packets. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dlen
operator|<=
name|MHLEN
condition|)
block|{
name|m_new
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m_new
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m_new
operator|->
name|m_len
operator|=
name|dlen
expr_stmt|;
name|rxr
operator|->
name|hn_small_pkts
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Get an mbuf with a cluster.  For packets 2K or less, 		 * get a standard 2K cluster.  For anything larger, get a 		 * 4K cluster.  Any buffers larger than 4K can cause problems 		 * if looped around to the Hyper-V TX channel, so avoid them. 		 */
name|size
operator|=
name|MCLBYTES
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
name|MCLBYTES
condition|)
block|{
comment|/* 4096 */
name|size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
name|m_new
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hv_m_append
argument_list|(
name|m_new
argument_list|,
name|dlen
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|m_new
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|do_csum
operator|=
literal|0
expr_stmt|;
comment|/* receive side checksum offload */
if|if
condition|(
name|info
operator|->
name|csum_info
operator|!=
name|HN_NDIS_RXCSUM_INFO_INVALID
condition|)
block|{
comment|/* IP csum offload */
if|if
condition|(
operator|(
name|info
operator|->
name|csum_info
operator|&
name|NDIS_RXCSUM_INFO_IPCS_OK
operator|)
operator|&&
name|do_csum
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
name|rxr
operator|->
name|hn_csum_ip
operator|++
expr_stmt|;
block|}
comment|/* TCP/UDP csum offload */
if|if
condition|(
operator|(
name|info
operator|->
name|csum_info
operator|&
operator|(
name|NDIS_RXCSUM_INFO_UDPCS_OK
operator||
name|NDIS_RXCSUM_INFO_TCPCS_OK
operator|)
operator|)
operator|&&
name|do_csum
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|csum_info
operator|&
name|NDIS_RXCSUM_INFO_TCPCS_OK
condition|)
name|rxr
operator|->
name|hn_csum_tcp
operator|++
expr_stmt|;
else|else
name|rxr
operator|->
name|hn_csum_udp
operator|++
expr_stmt|;
block|}
comment|/* 		 * XXX 		 * As of this write (Oct 28th, 2016), host side will turn 		 * on only TCPCS_OK and IPCS_OK even for UDP datagrams, so 		 * the do_lro setting here is actually _not_ accurate.  We 		 * depend on the RSS hash type check to reset do_lro. 		 */
if|if
condition|(
operator|(
name|info
operator|->
name|csum_info
operator|&
operator|(
name|NDIS_RXCSUM_INFO_TCPCS_OK
operator||
name|NDIS_RXCSUM_INFO_IPCS_OK
operator|)
operator|)
operator|==
operator|(
name|NDIS_RXCSUM_INFO_TCPCS_OK
operator||
name|NDIS_RXCSUM_INFO_IPCS_OK
operator|)
condition|)
name|do_lro
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|uint16_t
name|etype
decl_stmt|;
name|int
name|hoff
decl_stmt|;
name|hoff
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|->
name|m_len
operator|<
name|hoff
condition|)
goto|goto
name|skip
goto|;
name|eh
operator|=
name|mtod
argument_list|(
name|m_new
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
specifier|const
name|struct
name|ether_vlan_header
modifier|*
name|evl
decl_stmt|;
name|hoff
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|evl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|->
name|m_len
operator|<
name|hoff
condition|)
goto|goto
name|skip
goto|;
name|evl
operator|=
name|mtod
argument_list|(
name|m_new
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|evl
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_IP
condition|)
block|{
name|int
name|pr
decl_stmt|;
name|pr
operator|=
name|hn_check_iplen
argument_list|(
name|m_new
argument_list|,
name|hoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|do_csum
operator|&&
operator|(
name|rxr
operator|->
name|hn_trust_hcsum
operator|&
name|HN_TRUST_HCSUM_TCP
operator|)
condition|)
block|{
name|rxr
operator|->
name|hn_csum_trusted
operator|++
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
name|do_lro
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pr
operator|==
name|IPPROTO_UDP
condition|)
block|{
if|if
condition|(
name|do_csum
operator|&&
operator|(
name|rxr
operator|->
name|hn_trust_hcsum
operator|&
name|HN_TRUST_HCSUM_UDP
operator|)
condition|)
block|{
name|rxr
operator|->
name|hn_csum_trusted
operator|++
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pr
operator|!=
name|IPPROTO_DONE
operator|&&
name|do_csum
operator|&&
operator|(
name|rxr
operator|->
name|hn_trust_hcsum
operator|&
name|HN_TRUST_HCSUM_IP
operator|)
condition|)
block|{
name|rxr
operator|->
name|hn_csum_trusted
operator|++
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
block|}
block|}
name|skip
label|:
if|if
condition|(
name|info
operator|->
name|vlan_info
operator|!=
name|HN_NDIS_VLAN_INFO_INVALID
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|EVL_MAKETAG
argument_list|(
name|NDIS_VLAN_INFO_ID
argument_list|(
name|info
operator|->
name|vlan_info
argument_list|)
argument_list|,
name|NDIS_VLAN_INFO_PRI
argument_list|(
name|info
operator|->
name|vlan_info
argument_list|)
argument_list|,
name|NDIS_VLAN_INFO_CFI
argument_list|(
name|info
operator|->
name|vlan_info
argument_list|)
argument_list|)
expr_stmt|;
name|m_new
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|hash_info
operator|!=
name|HN_NDIS_HASH_INFO_INVALID
condition|)
block|{
name|rxr
operator|->
name|hn_rss_pkts
operator|++
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|info
operator|->
name|hash_value
expr_stmt|;
name|hash_type
operator|=
name|M_HASHTYPE_OPAQUE_HASH
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|hash_info
operator|&
name|NDIS_HASH_FUNCTION_MASK
operator|)
operator|==
name|NDIS_HASH_FUNCTION_TOEPLITZ
condition|)
block|{
name|uint32_t
name|type
init|=
operator|(
name|info
operator|->
name|hash_info
operator|&
name|NDIS_HASH_TYPE_MASK
operator|)
decl_stmt|;
comment|/* 			 * NOTE: 			 * do_lro is resetted, if the hash types are not TCP 			 * related.  See the comment in the above csum_flags 			 * setup section. 			 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NDIS_HASH_IPV4
case|:
name|hash_type
operator|=
name|M_HASHTYPE_RSS_IPV4
expr_stmt|;
name|do_lro
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NDIS_HASH_TCP_IPV4
case|:
name|hash_type
operator|=
name|M_HASHTYPE_RSS_TCP_IPV4
expr_stmt|;
break|break;
case|case
name|NDIS_HASH_IPV6
case|:
name|hash_type
operator|=
name|M_HASHTYPE_RSS_IPV6
expr_stmt|;
name|do_lro
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NDIS_HASH_IPV6_EX
case|:
name|hash_type
operator|=
name|M_HASHTYPE_RSS_IPV6_EX
expr_stmt|;
name|do_lro
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NDIS_HASH_TCP_IPV6
case|:
name|hash_type
operator|=
name|M_HASHTYPE_RSS_TCP_IPV6
expr_stmt|;
break|break;
case|case
name|NDIS_HASH_TCP_IPV6_EX
case|:
name|hash_type
operator|=
name|M_HASHTYPE_RSS_TCP_IPV6_EX
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|rxr
operator|->
name|hn_rx_idx
expr_stmt|;
name|hash_type
operator|=
name|M_HASHTYPE_OPAQUE
expr_stmt|;
block|}
name|M_HASHTYPE_SET
argument_list|(
name|m_new
argument_list|,
name|hash_type
argument_list|)
expr_stmt|;
comment|/* 	 * Note:  Moved RX completion back to hv_nv_on_receive() so all 	 * messages (not just data messages) will trigger a response. 	 */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_pkts
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|&&
name|do_lro
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|hn_lro
decl_stmt|;
if|if
condition|(
name|lro
operator|->
name|lro_cnt
condition|)
block|{
name|rxr
operator|->
name|hn_lro_tried
operator|++
expr_stmt|;
if|if
condition|(
name|hn_lro_rx
argument_list|(
name|lro
argument_list|,
name|m_new
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* DONE! */
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* We're not holding the lock here, so don't release it */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|HN_MTU_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
operator|==
literal|0
condition|)
block|{
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_MTU
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't change MTU */
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|==
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Suspend this interface before the synthetic parts 		 * are ripped. 		 */
name|hn_suspend
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Detach the synthetics parts, i.e. NVS and RNDIS. 		 */
name|hn_synth_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Reattach the synthetic parts, i.e. NVS and RNDIS, 		 * with the new MTU setting. 		 */
name|error
operator|=
name|hn_synth_attach
argument_list|(
name|sc
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Commit the requested MTU, after the synthetic parts 		 * have been successfully attached. 		 */
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
comment|/* 		 * Make sure that various parameters based on MTU are 		 * still valid, after the MTU change. 		 */
if|if
condition|(
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_chim_size
operator|>
name|sc
operator|->
name|hn_chim_szmax
condition|)
name|hn_set_chim_size
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_chim_szmax
argument_list|)
expr_stmt|;
name|hn_set_tso_maxsize
argument_list|(
name|sc
argument_list|,
name|hn_tso_maxlen
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100099
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_lro
operator|.
name|lro_length_lim
operator|<
name|HN_LRO_LENLIM_MIN
argument_list|(
name|ifp
argument_list|)
condition|)
name|hn_set_lro_lenlim
argument_list|(
name|sc
argument_list|,
name|HN_LRO_LENLIM_MIN
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * All done!  Resume the interface now. 		 */
name|hn_resume
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
operator|==
literal|0
condition|)
block|{
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 				 * Caller meight hold mutex, e.g. 				 * bpf; use busy-wait for the RNDIS 				 * reply. 				 */
name|HN_NO_SLEEPING
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_rxfilter_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HN_SLEEPING_OK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hn_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|hn_stop
argument_list|(
name|sc
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|hn_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|HN_CSUM_IP_HWASSIST
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|HN_CSUM_IP_HWASSIST
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|HN_CSUM_IP6_HWASSIST
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|HN_CSUM_IP6_HWASSIST
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: flip RNDIS offload parameters for RXCSUM. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
ifdef|#
directive|ifdef
name|foo
comment|/* We can't diff IPv6 packets from IPv4 packets on RX path. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_IP_TSO
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP6_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_IP6_TSO
expr_stmt|;
block|}
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
operator|==
literal|0
condition|)
block|{
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 			 * Multicast uses mutex; use busy-wait for 			 * the RNDIS reply. 			 */
name|HN_NO_SLEEPING
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_rxfilter_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HN_SLEEPING_OK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_stop
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|bool
name|detaching
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
argument_list|,
operator|(
literal|"synthetic parts were not attached"
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable polling. */
name|hn_polling
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear RUNNING bit _before_ hn_suspend_data() */
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|hn_suspend_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear OACTIVE bit. */
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_inuse
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_oactive
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the VF is active, make sure the filter is not 0, even if 	 * the synthetic NIC is down. 	 */
if|if
condition|(
operator|!
name|detaching
operator|&&
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_VF
operator|)
condition|)
name|hn_rxfilter_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_init_locked
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
comment|/* Configure RX filter */
name|hn_rxfilter_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear OACTIVE bit. */
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_inuse
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_oactive
operator|=
literal|0
expr_stmt|;
comment|/* Clear TX 'suspended' bit. */
name|hn_resume_tx
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_tx_ring_inuse
argument_list|)
expr_stmt|;
comment|/* Everything is ready; unleash! */
name|atomic_set_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
comment|/* Re-enable polling if requested. */
if|if
condition|(
name|sc
operator|->
name|hn_pollhz
operator|>
literal|0
condition|)
name|hn_polling
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_pollhz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100099
end_if

begin_function
specifier|static
name|int
name|hn_lro_lenlim_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|unsigned
name|int
name|lenlim
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lenlim
operator|=
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_lro
operator|.
name|lro_length_lim
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|lenlim
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenlim
operator|<
name|HN_LRO_LENLIM_MIN
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|)
operator|||
name|lenlim
operator|>
name|TCP_LRO_LENGTH_MAX
condition|)
block|{
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|hn_set_lro_lenlim
argument_list|(
name|sc
argument_list|,
name|lenlim
argument_list|)
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_lro_ackcnt_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ackcnt
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * lro_ackcnt_lim is append count limit, 	 * +1 to turn it into aggregation limit. 	 */
name|ackcnt
operator|=
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_lro
operator|.
name|lro_ackcnt_lim
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|ackcnt
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ackcnt
operator|<
literal|2
operator|||
name|ackcnt
operator|>
operator|(
name|TCP_LRO_ACKCNT_MAX
operator|+
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * Convert aggregation limit back to append 	 * count limit. 	 */
operator|--
name|ackcnt
expr_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
operator|.
name|hn_lro
operator|.
name|lro_ackcnt_lim
operator|=
name|ackcnt
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|hn_trust_hcsum_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|hcsum
init|=
name|arg2
decl_stmt|;
name|int
name|on
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|on
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_trust_hcsum
operator|&
name|hcsum
condition|)
name|on
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|on
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|on
condition|)
name|rxr
operator|->
name|hn_trust_hcsum
operator||=
name|hcsum
expr_stmt|;
else|else
name|rxr
operator|->
name|hn_trust_hcsum
operator|&=
operator|~
name|hcsum
expr_stmt|;
block|}
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_chim_size_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|chim_size
decl_stmt|,
name|error
decl_stmt|;
name|chim_size
operator|=
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_chim_size
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|chim_size
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|chim_size
operator|>
name|sc
operator|->
name|hn_chim_szmax
operator|||
name|chim_size
operator|<=
literal|0
condition|)
return|return
name|EINVAL
return|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_set_chim_size
argument_list|(
name|sc
argument_list|,
name|chim_size
argument_list|)
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1100095
end_if

begin_function
specifier|static
name|int
name|hn_rx_stat_int_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|uint64_t
name|stat
decl_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|+=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|stat
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
comment|/* Zero out this stat. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|hn_rx_stat_u64_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|uint64_t
name|stat
decl_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|+=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|stat
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
comment|/* Zero out this stat. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|hn_rx_stat_ulong_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|u_long
name|stat
decl_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|+=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|stat
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
comment|/* Zero out this stat. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_tx_stat_ulong_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|u_long
name|stat
decl_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|+=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|txr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|stat
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
comment|/* Zero out this stat. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|txr
operator|+
name|ofs
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_tx_conf_int_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|,
name|conf
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
expr_stmt|;
name|conf
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|txr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|conf
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|txr
operator|+
name|ofs
operator|)
operator|)
operator|=
name|conf
expr_stmt|;
block|}
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_txagg_size_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
name|sc
operator|->
name|hn_agg_size
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|size
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_agg_size
operator|=
name|size
expr_stmt|;
name|hn_set_txagg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_txagg_pkts_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pkts
decl_stmt|;
name|pkts
operator|=
name|sc
operator|->
name|hn_agg_pkts
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|pkts
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_agg_pkts
operator|=
name|pkts
expr_stmt|;
name|hn_set_txagg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_txagg_pktmax_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|pkts
decl_stmt|;
name|pkts
operator|=
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_agg_pktmax
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|pkts
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_txagg_align_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|align
decl_stmt|;
name|align
operator|=
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_agg_align
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|align
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_chan_polling
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|u_int
name|pollhz
parameter_list|)
block|{
if|if
condition|(
name|pollhz
operator|==
literal|0
condition|)
name|vmbus_chan_poll_disable
argument_list|(
name|chan
argument_list|)
expr_stmt|;
else|else
name|vmbus_chan_poll_enable
argument_list|(
name|chan
argument_list|,
name|pollhz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_polling
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|pollhz
parameter_list|)
block|{
name|int
name|nsubch
init|=
name|sc
operator|->
name|hn_rx_ring_inuse
operator|-
literal|1
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsubch
operator|>
literal|0
condition|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|subch
operator|=
name|vmbus_subchan_get
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|,
name|nsubch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsubch
condition|;
operator|++
name|i
control|)
name|hn_chan_polling
argument_list|(
name|subch
index|[
name|i
index|]
argument_list|,
name|pollhz
argument_list|)
expr_stmt|;
name|vmbus_subchan_rel
argument_list|(
name|subch
argument_list|,
name|nsubch
argument_list|)
expr_stmt|;
block|}
name|hn_chan_polling
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|,
name|pollhz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_polling_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|pollhz
decl_stmt|,
name|error
decl_stmt|;
name|pollhz
operator|=
name|sc
operator|->
name|hn_pollhz
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|pollhz
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pollhz
operator|!=
literal|0
operator|&&
operator|(
name|pollhz
operator|<
name|VMBUS_CHAN_POLLHZ_MIN
operator|||
name|pollhz
operator|>
name|VMBUS_CHAN_POLLHZ_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_pollhz
operator|!=
name|pollhz
condition|)
block|{
name|sc
operator|->
name|hn_pollhz
operator|=
name|pollhz
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
condition|)
name|hn_polling
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_pollhz
argument_list|)
expr_stmt|;
block|}
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_ndis_version_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|char
name|verstr
index|[
literal|16
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|verstr
argument_list|,
sizeof|sizeof
argument_list|(
name|verstr
argument_list|)
argument_list|,
literal|"%u.%u"
argument_list|,
name|HN_NDIS_VERSION_MAJOR
argument_list|(
name|sc
operator|->
name|hn_ndis_ver
argument_list|)
argument_list|,
name|HN_NDIS_VERSION_MINOR
argument_list|(
name|sc
operator|->
name|hn_ndis_ver
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|verstr
argument_list|,
sizeof|sizeof
argument_list|(
name|verstr
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_caps_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|char
name|caps_str
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|caps
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|caps
operator|=
name|sc
operator|->
name|hn_caps
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|caps_str
argument_list|,
sizeof|sizeof
argument_list|(
name|caps_str
argument_list|)
argument_list|,
literal|"%b"
argument_list|,
name|caps
argument_list|,
name|HN_CAP_BITS
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|caps_str
argument_list|,
sizeof|sizeof
argument_list|(
name|caps_str
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_hwassist_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|char
name|assist_str
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|hwassist
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hwassist
operator|=
name|sc
operator|->
name|hn_ifp
operator|->
name|if_hwassist
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|assist_str
argument_list|,
sizeof|sizeof
argument_list|(
name|assist_str
argument_list|)
argument_list|,
literal|"%b"
argument_list|,
name|hwassist
argument_list|,
name|CSUM_BITS
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|assist_str
argument_list|,
sizeof|sizeof
argument_list|(
name|assist_str
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_rxfilter_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|char
name|filter_str
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|filter
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|filter
operator|=
name|sc
operator|->
name|hn_rx_filter
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|filter_str
argument_list|,
sizeof|sizeof
argument_list|(
name|filter_str
argument_list|)
argument_list|,
literal|"%b"
argument_list|,
name|filter
argument_list|,
name|NDIS_PACKET_TYPES
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|filter_str
argument_list|,
sizeof|sizeof
argument_list|(
name|filter_str
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|RSS
end_ifndef

begin_function
specifier|static
name|int
name|hn_rss_key_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sc
operator|->
name|hn_rss
operator|.
name|rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|hn_rss
operator|.
name|rss_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
goto|goto
name|back
goto|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|sc
operator|->
name|hn_rss
operator|.
name|rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|hn_rss
operator|.
name|rss_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|back
goto|;
name|sc
operator|->
name|hn_flags
operator||=
name|HN_FLAG_HAS_RSSKEY
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring_inuse
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|hn_rss_reconfig
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not RSS capable, at least for now; just save the RSS key. */
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|back
label|:
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_rss_ind_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sc
operator|->
name|hn_rss
operator|.
name|rss_ind
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|hn_rss
operator|.
name|rss_ind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
goto|goto
name|back
goto|;
comment|/* 	 * Don't allow RSS indirect table change, if this interface is not 	 * RSS capable currently. 	 */
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring_inuse
operator|==
literal|1
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|back
goto|;
block|}
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|sc
operator|->
name|hn_rss
operator|.
name|rss_ind
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|hn_rss
operator|.
name|rss_ind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|back
goto|;
name|sc
operator|->
name|hn_flags
operator||=
name|HN_FLAG_HAS_RSSIND
expr_stmt|;
name|hn_rss_ind_fixup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|hn_rss_reconfig
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|back
label|:
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !RSS */
end_comment

begin_function
specifier|static
name|int
name|hn_rss_hash_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|char
name|hash_str
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hash
operator|=
name|sc
operator|->
name|hn_rss_hash
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|hash_str
argument_list|,
sizeof|sizeof
argument_list|(
name|hash_str
argument_list|)
argument_list|,
literal|"%b"
argument_list|,
name|hash
argument_list|,
name|NDIS_HASH_BITS
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|hash_str
argument_list|,
sizeof|sizeof
argument_list|(
name|hash_str
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_vf_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|char
name|vf_name
index|[
name|IFNAMSIZ
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|vf
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vf_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vf
operator|=
name|sc
operator|->
name|hn_vf_ifp
expr_stmt|;
if|if
condition|(
name|vf
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|vf_name
argument_list|,
sizeof|sizeof
argument_list|(
name|vf_name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|if_name
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|vf_name
argument_list|,
sizeof|sizeof
argument_list|(
name|vf_name
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_rxvf_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|char
name|vf_name
index|[
name|IFNAMSIZ
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|vf
decl_stmt|;
name|HN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vf_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vf
operator|=
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_rxvf_ifp
expr_stmt|;
if|if
condition|(
name|vf
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|vf_name
argument_list|,
sizeof|sizeof
argument_list|(
name|vf_name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|if_name
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
name|HN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|vf_name
argument_list|,
sizeof|sizeof
argument_list|(
name|vf_name
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_vflist_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|pt
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|first
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rm_rlock
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|,
operator|&
name|pt
argument_list|)
expr_stmt|;
name|first
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hn_vfmap_size
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|hn_vfmap
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" %s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
block|}
block|}
name|rm_runlock
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|,
operator|&
name|pt
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_vfmap_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|pt
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|first
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rm_rlock
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|,
operator|&
name|pt
argument_list|)
expr_stmt|;
name|first
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hn_vfmap_size
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|hn_ifp
decl_stmt|;
name|hn_ifp
operator|=
name|hn_vfmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hn_ifp
operator|==
name|NULL
condition|)
continue|continue;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s:%s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|hn_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" %s:%s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|hn_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
name|false
expr_stmt|;
block|}
block|}
name|rm_runlock
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|,
operator|&
name|pt
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_check_iplen
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hoff
parameter_list|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|,
name|iphlen
decl_stmt|,
name|iplen
decl_stmt|;
specifier|const
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|int
name|thoff
decl_stmt|;
comment|/* TCP data offset */
name|len
operator|=
name|hoff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
comment|/* The packet must be at least the size of an IP header. */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|len
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* The fixed IP header must reside completely in the first mbuf. */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len
condition|)
return|return
name|IPPROTO_DONE
return|;
name|ip
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hoff
argument_list|)
expr_stmt|;
comment|/* Bound check the packet's stated IP header length. */
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|iphlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
comment|/* minimum header length */
return|return
name|IPPROTO_DONE
return|;
comment|/* The full IP header must reside completely in the one mbuf. */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
condition|)
return|return
name|IPPROTO_DONE
return|;
name|iplen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers is as 	 * at least much as the IP header would have us expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|hoff
operator|+
name|iplen
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* 	 * Ignore IP fragments. 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|&
operator|(
name|IP_OFFMASK
operator||
name|IP_MF
operator|)
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* 	 * The TCP/IP or UDP/IP header must be entirely contained within 	 * the first fragment of a packet. 	 */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|iplen
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
name|th
operator|=
operator|(
specifier|const
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|thoff
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|thoff
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|||
name|thoff
operator|+
name|iphlen
operator|>
name|iplen
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
name|thoff
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|iplen
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
default|default:
if|if
condition|(
name|iplen
operator|<
name|iphlen
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
block|}
return|return
name|ip
operator|->
name|ip_p
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_create_rx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ring_cnt
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|hn_dev
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
name|int
name|lroent_cnt
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|int
name|i
decl_stmt|;
comment|/* 	 * Create RXBUF for reception. 	 * 	 * NOTE: 	 * - It is shared by all channels. 	 * - A large enough buffer is allocated, certain version of NVSes 	 *   may further limit the usable space. 	 */
name|sc
operator|->
name|hn_rxbuf
operator|=
name|hyperv_dmamem_alloc
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|HN_RXBUF_SIZE
argument_list|,
operator|&
name|sc
operator|->
name|hn_rxbuf_dma
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rxbuf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"allocate rxbuf failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|hn_rx_ring_cnt
operator|=
name|ring_cnt
expr_stmt|;
name|sc
operator|->
name|hn_rx_ring_inuse
operator|=
name|sc
operator|->
name|hn_rx_ring_cnt
expr_stmt|;
name|sc
operator|->
name|hn_rx_ring
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|)
operator|*
name|sc
operator|->
name|hn_rx_ring_cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
name|lroent_cnt
operator|=
name|hn_lro_entry_count
expr_stmt|;
if|if
condition|(
name|lroent_cnt
operator|<
name|TCP_LRO_ENTRIES
condition|)
name|lroent_cnt
operator|=
name|TCP_LRO_ENTRIES
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LRO: entry count %d\n"
argument_list|,
name|lroent_cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* INET || INET6 */
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create dev.hn.UNIT.rx sysctl tree */
name|sc
operator|->
name|hn_rx_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
decl_stmt|;
name|rxr
operator|->
name|hn_br
operator|=
name|hyperv_dmamem_alloc
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|HN_TXBR_SIZE
operator|+
name|HN_RXBR_SIZE
argument_list|,
operator|&
name|rxr
operator|->
name|hn_br_dma
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|hn_br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"allocate bufring failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|hn_trust_hosttcp
condition|)
name|rxr
operator|->
name|hn_trust_hcsum
operator||=
name|HN_TRUST_HCSUM_TCP
expr_stmt|;
if|if
condition|(
name|hn_trust_hostudp
condition|)
name|rxr
operator|->
name|hn_trust_hcsum
operator||=
name|HN_TRUST_HCSUM_UDP
expr_stmt|;
if|if
condition|(
name|hn_trust_hostip
condition|)
name|rxr
operator|->
name|hn_trust_hcsum
operator||=
name|HN_TRUST_HCSUM_IP
expr_stmt|;
name|rxr
operator|->
name|hn_ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|)
name|rxr
operator|->
name|hn_txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|->
name|hn_pktbuf_len
operator|=
name|HN_PKTBUF_LEN_DEF
expr_stmt|;
name|rxr
operator|->
name|hn_pktbuf
operator|=
name|malloc
argument_list|(
name|rxr
operator|->
name|hn_pktbuf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_rx_idx
operator|=
name|i
expr_stmt|;
name|rxr
operator|->
name|hn_rxbuf
operator|=
name|sc
operator|->
name|hn_rxbuf
expr_stmt|;
comment|/* 		 * Initialize LRO. 		 */
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
name|tcp_lro_init_args
argument_list|(
operator|&
name|rxr
operator|->
name|hn_lro
argument_list|,
name|sc
operator|->
name|hn_ifp
argument_list|,
name|lroent_cnt
argument_list|,
name|hn_lro_mbufq_depth
argument_list|)
expr_stmt|;
else|#
directive|else
name|tcp_lro_init
argument_list|(
operator|&
name|rxr
operator|->
name|hn_lro
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_lro
operator|.
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100099
name|rxr
operator|->
name|hn_lro
operator|.
name|lro_length_lim
operator|=
name|HN_LRO_LENLIM_DEF
expr_stmt|;
name|rxr
operator|->
name|hn_lro
operator|.
name|lro_ackcnt_lim
operator|=
name|HN_LRO_ACKCNT_DEF
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* INET || INET6 */
if|if
condition|(
name|sc
operator|->
name|hn_rx_sysctl_tree
operator|!=
name|NULL
condition|)
block|{
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 			 * Create per RX ring sysctl tree: 			 * dev.hn.UNIT.rx.RINGID 			 */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_rx_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|hn_rx_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|hn_rx_sysctl_tree
operator|!=
name|NULL
condition|)
block|{
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|rxr
operator|->
name|hn_rx_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"packets"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rxr
operator|->
name|hn_pkts
argument_list|,
literal|"# of packets received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|rxr
operator|->
name|hn_rx_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rss_pkts"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rxr
operator|->
name|hn_rss_pkts
argument_list|,
literal|"# of packets w/ RSS info received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|rxr
operator|->
name|hn_rx_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pktbuf_len"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|hn_pktbuf_len
argument_list|,
literal|0
argument_list|,
literal|"Temporary channel packet buffer length"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_lro
operator|.
name|lro_queued
argument_list|)
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1100095
name|hn_rx_stat_int_sysctl
argument_list|,
else|#
directive|else
name|hn_rx_stat_u64_sysctl
argument_list|,
endif|#
directive|endif
literal|"LU"
argument_list|,
literal|"LRO queued"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_lro
operator|.
name|lro_flushed
argument_list|)
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1100095
name|hn_rx_stat_int_sysctl
argument_list|,
else|#
directive|else
name|hn_rx_stat_u64_sysctl
argument_list|,
endif|#
directive|endif
literal|"LU"
argument_list|,
literal|"LRO flushed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_tried"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_lro_tried
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of LRO tries"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100099
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_length_lim"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_lro_lenlim_sysctl
argument_list|,
literal|"IU"
argument_list|,
literal|"Max # of data bytes to be aggregated by LRO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_ackcnt_lim"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_lro_ackcnt_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Max # of ACKs to be aggregated by LRO"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trust_hosttcp"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|HN_TRUST_HCSUM_TCP
argument_list|,
name|hn_trust_hcsum_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Trust tcp segement verification on host side, "
literal|"when csum info is missing"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trust_hostudp"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|HN_TRUST_HCSUM_UDP
argument_list|,
name|hn_trust_hcsum_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Trust udp datagram verification on host side, "
literal|"when csum info is missing"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trust_hostip"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|HN_TRUST_HCSUM_IP
argument_list|,
name|hn_trust_hcsum_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Trust ip packet verification on host side, "
literal|"when csum info is missing"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_ip"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_csum_ip
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"RXCSUM IP"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_tcp"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_csum_tcp
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"RXCSUM TCP"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_udp"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_csum_udp
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"RXCSUM UDP"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_trusted"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_csum_trusted
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of packets that we trust host's csum verification"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"small_pkts"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_small_pkts
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of small packets received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_ack_failed"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_ack_failed
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of RXBUF ack failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_ring_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_rx_ring_cnt
argument_list|,
literal|0
argument_list|,
literal|"# created RX rings"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_ring_inuse"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_rx_ring_inuse
argument_list|,
literal|0
argument_list|,
literal|"# used RX rings"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_destroy_rx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rxbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_RXBUF_REF
operator|)
operator|==
literal|0
condition|)
name|hyperv_dmamem_free
argument_list|(
operator|&
name|sc
operator|->
name|hn_rxbuf_dma
argument_list|,
name|sc
operator|->
name|hn_rxbuf
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"RXBUF is referenced\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_rxbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring_cnt
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rxr
operator|->
name|hn_br
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|rxr
operator|->
name|hn_rx_flags
operator|&
name|HN_RX_FLAG_BR_REF
operator|)
operator|==
literal|0
condition|)
block|{
name|hyperv_dmamem_free
argument_list|(
operator|&
name|rxr
operator|->
name|hn_br_dma
argument_list|,
name|rxr
operator|->
name|hn_br
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"%dth channel bufring is referenced"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|rxr
operator|->
name|hn_br
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|tcp_lro_free
argument_list|(
operator|&
name|rxr
operator|->
name|hn_lro
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|rxr
operator|->
name|hn_pktbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|hn_rx_ring
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|hn_rx_ring_cnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|hn_rx_ring_inuse
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_tx_ring_create
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|id
index|]
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|hn_dev
decl_stmt|;
name|bus_dma_tag_t
name|parent_dtag
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|txr
operator|->
name|hn_sc
operator|=
name|sc
expr_stmt|;
name|txr
operator|->
name|hn_tx_idx
operator|=
name|id
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|,
literal|"hn txlist"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|,
literal|"hn tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdesc_cnt
operator|=
name|HN_TX_DESC_CNT
expr_stmt|;
name|txr
operator|->
name|hn_txdesc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hn_txdesc
argument_list|)
operator|*
name|txr
operator|->
name|hn_txdesc_cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|SLIST_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|)
expr_stmt|;
else|#
directive|else
name|txr
operator|->
name|hn_txdesc_br
operator|=
name|buf_ring_alloc
argument_list|(
name|txr
operator|->
name|hn_txdesc_cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hn_tx_taskq_mode
operator|==
name|HN_TX_TASKQ_M_EVTTQ
condition|)
block|{
name|txr
operator|->
name|hn_tx_taskq
operator|=
name|VMBUS_GET_EVENT_TASKQ
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|HN_RING_IDX2CPU
argument_list|(
name|sc
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txr
operator|->
name|hn_tx_taskq
operator|=
name|sc
operator|->
name|hn_tx_taskqs
index|[
name|id
operator|%
name|hn_tx_taskq_cnt
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
if|if
condition|(
name|hn_use_if_start
condition|)
block|{
name|txr
operator|->
name|hn_txeof
operator|=
name|hn_start_txeof
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|,
literal|0
argument_list|,
name|hn_start_taskfunc
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|,
literal|0
argument_list|,
name|hn_start_txeof_taskfunc
argument_list|,
name|txr
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|int
name|br_depth
decl_stmt|;
name|txr
operator|->
name|hn_txeof
operator|=
name|hn_xmit_txeof
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|,
literal|0
argument_list|,
name|hn_xmit_taskfunc
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|,
literal|0
argument_list|,
name|hn_xmit_txeof_taskfunc
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|br_depth
operator|=
name|hn_get_txswq_depth
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_mbuf_br
operator|=
name|buf_ring_alloc
argument_list|(
name|br_depth
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
name|txr
operator|->
name|hn_direct_tx_size
operator|=
name|hn_direct_tx_size
expr_stmt|;
comment|/* 	 * Always schedule transmission instead of trying to do direct 	 * transmission.  This one gives the best performance so far. 	 */
name|txr
operator|->
name|hn_sched_tx
operator|=
literal|1
expr_stmt|;
name|parent_dtag
operator|=
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* DMA tag for RNDIS packet messages. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|parent_dtag
argument_list|,
comment|/* parent */
name|HN_RNDIS_PKT_ALIGN
argument_list|,
comment|/* alignment */
name|HN_RNDIS_PKT_BOUNDARY
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|HN_RNDIS_PKT_LEN
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|HN_RNDIS_PKT_LEN
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create rndis dmatag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* DMA tag for data. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|parent_dtag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
name|HN_TX_DATA_BOUNDARY
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|HN_TX_DATA_MAXSIZE
argument_list|,
comment|/* maxsize */
name|HN_TX_DATA_SEGCNT_MAX
argument_list|,
comment|/* nsegments */
name|HN_TX_DATA_SEGSIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create data dmatag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txr
operator|->
name|hn_txdesc_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
init|=
operator|&
name|txr
operator|->
name|hn_txdesc
index|[
name|i
index|]
decl_stmt|;
name|txd
operator|->
name|txr
operator|=
name|txr
expr_stmt|;
name|txd
operator|->
name|chim_index
operator|=
name|HN_NVS_CHIM_IDX_INVALID
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|txd
operator|->
name|agg_list
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate and load RNDIS packet message. 		 */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|txd
operator|->
name|rndis_pkt
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|txd
operator|->
name|rndis_pkt_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate rndis_packet_msg, %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_pkt_dmap
argument_list|,
name|txd
operator|->
name|rndis_pkt
argument_list|,
name|HN_RNDIS_PKT_LEN
argument_list|,
name|hyperv_dma_map_paddr
argument_list|,
operator|&
name|txd
operator|->
name|rndis_pkt_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to load rndis_packet_msg, %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_pkt
argument_list|,
name|txd
operator|->
name|rndis_pkt_dmap
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* DMA map for TX data. */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txd
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate tx data dmamap\n"
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_pkt_dmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_pkt
argument_list|,
name|txd
operator|->
name|rndis_pkt_dmap
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* All set, put it to list */
name|txd
operator|->
name|flags
operator||=
name|HN_TXD_FLAG_ONLIST
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|,
name|txd
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|#
directive|else
name|buf_ring_enqueue
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|,
name|txd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|txr
operator|->
name|hn_txdesc_avail
operator|=
name|txr
operator|->
name|hn_txdesc_cnt
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_tx_sysctl_tree
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 		 * Create per TX ring sysctl tree: 		 * dev.hn.UNIT.tx.RINGID 		 */
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|hn_tx_sysctl_tree
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_tx_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_tx_sysctl_tree
operator|!=
name|NULL
condition|)
block|{
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|txr
operator|->
name|hn_tx_sysctl_tree
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txdesc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|hn_txdesc_avail
argument_list|,
literal|0
argument_list|,
literal|"# of available TX descs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
if|if
condition|(
operator|!
name|hn_use_if_start
condition|)
endif|#
directive|endif
block|{
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"oactive"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|hn_oactive
argument_list|,
literal|0
argument_list|,
literal|"over active"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"packets"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|txr
operator|->
name|hn_pkts
argument_list|,
literal|"# of packets transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sends"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|txr
operator|->
name|hn_sends
argument_list|,
literal|"# of sends"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_txdesc_dmamap_destroy
parameter_list|(
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|txd
operator|->
name|txr
decl_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"still has mbuf installed"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_DMAMAP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"still dma mapped"
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_pkt_dmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_pkt
argument_list|,
name|txd
operator|->
name|rndis_pkt_dmap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_txdesc_gc
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|txd
operator|->
name|refs
operator|==
literal|0
operator|||
name|txd
operator|->
name|refs
operator|==
literal|1
argument_list|,
operator|(
literal|"invalid txd refs %d"
operator|,
name|txd
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
comment|/* Aggregated txds will be freed by their aggregating txd. */
if|if
condition|(
name|txd
operator|->
name|refs
operator|>
literal|0
operator|&&
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONAGG
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|freed
decl_stmt|;
name|freed
operator|=
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|freed
argument_list|,
operator|(
literal|"can't free txdesc"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_tx_ring_destroy
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_txdesc
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * NOTE: 	 * Because the freeing of aggregated txds will be deferred 	 * to the aggregating txd, two passes are used here: 	 * - The first pass GCes any pending txds.  This GC is necessary, 	 *   since if the channels are revoked, hypervisor will not 	 *   deliver send-done for all pending txds. 	 * - The second pass frees the busdma stuffs, i.e. after all txds 	 *   were freed. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txr
operator|->
name|hn_txdesc_cnt
condition|;
operator|++
name|i
control|)
name|hn_txdesc_gc
argument_list|(
name|txr
argument_list|,
operator|&
name|txr
operator|->
name|hn_txdesc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txr
operator|->
name|hn_txdesc_cnt
condition|;
operator|++
name|i
control|)
name|hn_txdesc_dmamap_destroy
argument_list|(
operator|&
name|txr
operator|->
name|hn_txdesc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_tx_data_dtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_tx_rndis_dtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_USE_TXDESC_BUFRING
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|txr
operator|->
name|hn_txdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdesc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_mbuf_br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_destroy
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_destroy
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_create_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ring_cnt
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Create TXBUF for chimney sending. 	 * 	 * NOTE: It is shared by all channels. 	 */
name|sc
operator|->
name|hn_chim
operator|=
name|hyperv_dmamem_alloc
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|HN_CHIM_SIZE
argument_list|,
operator|&
name|sc
operator|->
name|hn_chim_dma
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_chim
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"allocate txbuf failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|hn_tx_ring_cnt
operator|=
name|ring_cnt
expr_stmt|;
name|sc
operator|->
name|hn_tx_ring_inuse
operator|=
name|sc
operator|->
name|hn_tx_ring_cnt
expr_stmt|;
name|sc
operator|->
name|hn_tx_ring
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|)
operator|*
name|sc
operator|->
name|hn_tx_ring_cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create dev.hn.UNIT.tx sysctl tree */
name|sc
operator|->
name|hn_tx_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|hn_tx_ring_create
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_txdescs"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_no_txdescs
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of times short of TX descs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"send_failed"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_send_failed
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of hyper-v sending failure"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txdma_failed"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_txdma_failed
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of TX DMA failure"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"agg_flush_failed"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_flush_failed
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of packet transmission aggregation flush failure"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_collapsed"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_tx_collapsed
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of TX mbuf collapsed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_chimney"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_tx_chimney
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of chimney send"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_chimney_tried"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_tx_chimney_tried
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of chimney send tries"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txdesc_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_txdesc_cnt
argument_list|,
literal|0
argument_list|,
literal|"# of total TX descs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_chimney_max"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_chim_szmax
argument_list|,
literal|0
argument_list|,
literal|"Chimney send packet size upper boundary"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_chimney_size"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_chim_size_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Chimney send packet size limit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"direct_tx_size"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_direct_tx_size
argument_list|)
argument_list|,
name|hn_tx_conf_int_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Size of the packet for direct transmission"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sched_tx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_sched_tx
argument_list|)
argument_list|,
name|hn_tx_conf_int_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Always schedule transmission "
literal|"instead of doing direct transmission"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_ring_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_tx_ring_cnt
argument_list|,
literal|0
argument_list|,
literal|"# created TX rings"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_ring_inuse"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_tx_ring_inuse
argument_list|,
literal|0
argument_list|,
literal|"# used TX rings"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"agg_szmax"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_agg_szmax
argument_list|,
literal|0
argument_list|,
literal|"Applied packet transmission aggregation size"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"agg_pktmax"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_txagg_pktmax_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Applied packet transmission aggregation packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"agg_align"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_txagg_align_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Applied packet transmission aggregation alignment"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_set_chim_size
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chim_size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_chim_size
operator|=
name|chim_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_set_tso_maxsize
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|tso_maxlen
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|int
name|tso_minlen
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TSO6
operator|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|sc
operator|->
name|hn_ndis_tso_sgmin
operator|>=
literal|2
argument_list|,
operator|(
literal|"invalid NDIS tso sgmin %d"
operator|,
name|sc
operator|->
name|hn_ndis_tso_sgmin
operator|)
argument_list|)
expr_stmt|;
name|tso_minlen
operator|=
name|sc
operator|->
name|hn_ndis_tso_sgmin
operator|*
name|mtu
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|hn_ndis_tso_szmax
operator|>=
name|tso_minlen
operator|&&
name|sc
operator|->
name|hn_ndis_tso_szmax
operator|<=
name|IP_MAXPACKET
argument_list|,
operator|(
literal|"invalid NDIS tso szmax %d"
operator|,
name|sc
operator|->
name|hn_ndis_tso_szmax
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tso_maxlen
operator|<
name|tso_minlen
condition|)
name|tso_maxlen
operator|=
name|tso_minlen
expr_stmt|;
elseif|else
if|if
condition|(
name|tso_maxlen
operator|>
name|IP_MAXPACKET
condition|)
name|tso_maxlen
operator|=
name|IP_MAXPACKET
expr_stmt|;
if|if
condition|(
name|tso_maxlen
operator|>
name|sc
operator|->
name|hn_ndis_tso_szmax
condition|)
name|tso_maxlen
operator|=
name|sc
operator|->
name|hn_ndis_tso_szmax
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomax
operator|=
name|tso_maxlen
operator|-
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO size max %u\n"
argument_list|,
name|ifp
operator|->
name|if_hw_tsomax
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_fixup_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint64_t
name|csum_assist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hn_set_chim_size
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_chim_szmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|hn_tx_chimney_size
operator|>
literal|0
operator|&&
name|hn_tx_chimney_size
operator|<
name|sc
operator|->
name|hn_chim_szmax
condition|)
name|hn_set_chim_size
argument_list|(
name|sc
argument_list|,
name|hn_tx_chimney_size
argument_list|)
expr_stmt|;
name|csum_assist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_IPCS
condition|)
name|csum_assist
operator||=
name|CSUM_IP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_TCP4CS
condition|)
name|csum_assist
operator||=
name|CSUM_IP_TCP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_UDP4CS
condition|)
name|csum_assist
operator||=
name|CSUM_IP_UDP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_TCP6CS
condition|)
name|csum_assist
operator||=
name|CSUM_IP6_TCP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_UDP6CS
condition|)
name|csum_assist
operator||=
name|CSUM_IP6_UDP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_csum_assist
operator|=
name|csum_assist
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_caps
operator|&
name|HN_CAP_HASHVAL
condition|)
block|{
comment|/* 		 * Support HASHVAL pktinfo on TX path. 		 */
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"support HASHVAL pktinfo\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_tx_flags
operator||=
name|HN_TX_FLAG_HASHVAL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_destroy_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_chim
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_CHIM_REF
operator|)
operator|==
literal|0
condition|)
block|{
name|hyperv_dmamem_free
argument_list|(
operator|&
name|sc
operator|->
name|hn_chim_dma
argument_list|,
name|sc
operator|->
name|hn_chim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"chimney sending buffer is referenced"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|hn_chim
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|hn_tx_ring_cnt
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|hn_tx_ring_destroy
argument_list|(
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|hn_tx_ring
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_tx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|hn_tx_ring_cnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|hn_tx_ring_inuse
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
end_ifdef

begin_function
specifier|static
name|void
name|hn_start_taskfunc
parameter_list|(
name|void
modifier|*
name|xtxr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|xtxr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|hn_start_locked
argument_list|(
name|txr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_start_locked
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|txr
operator|->
name|hn_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|int
name|sched
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|hn_use_if_start
argument_list|,
operator|(
literal|"hn_start_locked is called, when if_start is disabled"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txr
operator|==
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
argument_list|,
operator|(
literal|"not the first TX ring"
operator|)
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_agg_txd
operator|==
name|NULL
argument_list|,
operator|(
literal|"lingering aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|txr
operator|->
name|hn_suspended
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|len
condition|)
block|{
comment|/* 			 * This sending could be time consuming; let callers 			 * dispatch this packet sending (and sending of any 			 * following up packets) to tx taskqueue. 			 */
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|sched
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|m_head
operator|=
name|hn_tso_fixup
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m_head
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
name|txd
operator|=
name|hn_txdesc_get
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd
operator|==
name|NULL
condition|)
block|{
name|txr
operator|->
name|hn_no_txdescs
operator|++
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|hn_encap
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
operator|&
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Both txd and m_head are freed */
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_agg_txd
operator|==
name|NULL
argument_list|,
operator|(
literal|"encap failed w/ pending aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|txr
operator|->
name|hn_agg_pktleft
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|m_head
operator|==
name|NULL
argument_list|,
operator|(
literal|"pending mbuf for aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hn_flush_txagg
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|atomic_set_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|m_head
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mbuf was freed"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hn_txpkt
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
comment|/* txd is freed, but m_head is not */
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
else|else
block|{
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m_head
operator|==
name|NULL
argument_list|,
operator|(
literal|"pending mbuf for aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Flush pending aggerated transmission. */
if|if
condition|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
condition|)
name|hn_flush_txagg
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
return|return
operator|(
name|sched
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_sched_tx
condition|)
goto|goto
name|do_sched
goto|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
condition|)
block|{
name|int
name|sched
decl_stmt|;
name|sched
operator|=
name|hn_start_locked
argument_list|(
name|txr
argument_list|,
name|txr
operator|->
name|hn_direct_tx_size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sched
condition|)
return|return;
block|}
name|do_sched
label|:
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_start_txeof_taskfunc
parameter_list|(
name|void
modifier|*
name|xtxr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|xtxr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|txr
operator|->
name|hn_sc
operator|->
name|hn_ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|hn_start_locked
argument_list|(
name|txr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_start_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|txr
operator|->
name|hn_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|KASSERT
argument_list|(
name|txr
operator|==
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
argument_list|,
operator|(
literal|"not the first TX ring"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_sched_tx
condition|)
goto|goto
name|do_sched
goto|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
condition|)
block|{
name|int
name|sched
decl_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|sched
operator|=
name|hn_start_locked
argument_list|(
name|txr
argument_list|,
name|txr
operator|->
name|hn_direct_tx_size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_sched
label|:
comment|/* 		 * Release the OACTIVE earlier, with the hope, that 		 * others could catch up.  The task will clear the 		 * flag again with the hn_tx_lock to avoid possible 		 * races. 		 */
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HN_IFSTART_SUPPORT */
end_comment

begin_function
specifier|static
name|int
name|hn_xmit
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|txr
operator|->
name|hn_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|sched
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
name|KASSERT
argument_list|(
name|hn_use_if_start
operator|==
literal|0
argument_list|,
operator|(
literal|"hn_xmit is called, when if_start is enabled"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_agg_txd
operator|==
name|NULL
argument_list|,
operator|(
literal|"lingering aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|txr
operator|->
name|hn_suspended
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|txr
operator|->
name|hn_oactive
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|m_head
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|len
condition|)
block|{
comment|/* 			 * This sending could be time consuming; let callers 			 * dispatch this packet sending (and sending of any 			 * following up packets) to tx taskqueue. 			 */
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|sched
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|txd
operator|=
name|hn_txdesc_get
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd
operator|==
name|NULL
condition|)
block|{
name|txr
operator|->
name|hn_no_txdescs
operator|++
expr_stmt|;
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_oactive
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|hn_encap
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|,
operator|&
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Both txd and m_head are freed; discard */
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_agg_txd
operator|==
name|NULL
argument_list|,
operator|(
literal|"encap failed w/ pending aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|txr
operator|->
name|hn_agg_pktleft
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|m_head
operator|==
name|NULL
argument_list|,
operator|(
literal|"pending mbuf for aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hn_flush_txagg
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|txr
operator|->
name|hn_oactive
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|m_head
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mbuf was freed"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hn_txpkt
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
comment|/* txd is freed, but m_head is not */
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_oactive
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
else|else
block|{
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m_head
operator|==
name|NULL
argument_list|,
operator|(
literal|"pending mbuf for aggregating txdesc"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Sent */
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|)
expr_stmt|;
block|}
comment|/* Flush pending aggerated transmission. */
if|if
condition|(
name|txr
operator|->
name|hn_agg_txd
operator|!=
name|NULL
condition|)
name|hn_flush_txagg
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
return|return
operator|(
name|sched
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
comment|/* 	 * Perform TSO packet header fixup now, since the TSO 	 * packet header should be cache-hot. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|m
operator|=
name|hn_tso_fixup
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Select the TX ring based on flowid 	 */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
name|uint32_t
name|bid
decl_stmt|;
if|if
condition|(
name|rss_hash2bucket
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|,
operator|&
name|bid
argument_list|)
operator|==
literal|0
condition|)
name|idx
operator|=
name|bid
operator|%
name|sc
operator|->
name|hn_tx_ring_inuse
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
name|int
name|tcpsyn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|128
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_TCP
operator||
name|CSUM_IP6_TCP
operator|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|hn_check_tcpsyn
argument_list|(
name|m
argument_list|,
operator|&
name|tcpsyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|#
directive|else
specifier|const
name|int
name|tcpsyn
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tcpsyn
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
else|else
name|idx
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|sc
operator|->
name|hn_tx_ring_inuse
expr_stmt|;
block|}
block|}
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|idx
index|]
expr_stmt|;
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OQDROPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|txr
operator|->
name|hn_oactive
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|txr
operator|->
name|hn_sched_tx
condition|)
goto|goto
name|do_sched
goto|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
condition|)
block|{
name|int
name|sched
decl_stmt|;
name|sched
operator|=
name|hn_xmit
argument_list|(
name|txr
argument_list|,
name|txr
operator|->
name|hn_direct_tx_size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sched
condition|)
return|return
literal|0
return|;
block|}
name|do_sched
label|:
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_tx_ring_qflush
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|hn_mbuf_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_xmit_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_inuse
condition|;
operator|++
name|i
control|)
name|hn_tx_ring_qflush
argument_list|(
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_xmit_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
if|if
condition|(
name|txr
operator|->
name|hn_sched_tx
condition|)
goto|goto
name|do_sched
goto|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
condition|)
block|{
name|int
name|sched
decl_stmt|;
name|txr
operator|->
name|hn_oactive
operator|=
literal|0
expr_stmt|;
name|sched
operator|=
name|hn_xmit
argument_list|(
name|txr
argument_list|,
name|txr
operator|->
name|hn_direct_tx_size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_sched
label|:
comment|/* 		 * Release the oactive earlier, with the hope, that 		 * others could catch up.  The task will clear the 		 * oactive again with the hn_tx_lock to avoid possible 		 * races. 		 */
name|txr
operator|->
name|hn_oactive
operator|=
literal|0
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_xmit_taskfunc
parameter_list|(
name|void
modifier|*
name|xtxr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|xtxr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|hn_xmit
argument_list|(
name|txr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_xmit_txeof_taskfunc
parameter_list|(
name|void
modifier|*
name|xtxr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|xtxr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_oactive
operator|=
literal|0
expr_stmt|;
name|hn_xmit
argument_list|(
name|txr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_chan_attach
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|vmbus_chan_br
name|cbr
decl_stmt|;
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|NULL
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|error
decl_stmt|;
name|idx
operator|=
name|vmbus_chan_subidx
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * Link this channel to RX/TX ring. 	 */
name|KASSERT
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|sc
operator|->
name|hn_rx_ring_inuse
argument_list|,
operator|(
literal|"invalid channel index %d, should> 0&&< %d"
operator|,
name|idx
operator|,
name|sc
operator|->
name|hn_rx_ring_inuse
operator|)
argument_list|)
expr_stmt|;
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|rxr
operator|->
name|hn_rx_flags
operator|&
name|HN_RX_FLAG_ATTACHED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"RX ring %d already attached"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_rx_flags
operator||=
name|HN_RX_FLAG_ATTACHED
expr_stmt|;
name|rxr
operator|->
name|hn_chan
operator|=
name|chan
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"link RX ring %d to chan%u\n"
argument_list|,
name|idx
argument_list|,
name|vmbus_chan_id
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|<
name|sc
operator|->
name|hn_tx_ring_inuse
condition|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|txr
operator|->
name|hn_tx_flags
operator|&
name|HN_TX_FLAG_ATTACHED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"TX ring %d already attached"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_tx_flags
operator||=
name|HN_TX_FLAG_ATTACHED
expr_stmt|;
name|txr
operator|->
name|hn_chan
operator|=
name|chan
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"link TX ring %d to chan%u\n"
argument_list|,
name|idx
argument_list|,
name|vmbus_chan_id
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bind this channel to a proper CPU. */
name|vmbus_chan_cpu_set
argument_list|(
name|chan
argument_list|,
name|HN_RING_IDX2CPU
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Open this channel 	 */
name|cbr
operator|.
name|cbr
operator|=
name|rxr
operator|->
name|hn_br
expr_stmt|;
name|cbr
operator|.
name|cbr_paddr
operator|=
name|rxr
operator|->
name|hn_br_dma
operator|.
name|hv_paddr
expr_stmt|;
name|cbr
operator|.
name|cbr_txsz
operator|=
name|HN_TXBR_SIZE
expr_stmt|;
name|cbr
operator|.
name|cbr_rxsz
operator|=
name|HN_RXBR_SIZE
expr_stmt|;
name|error
operator|=
name|vmbus_chan_open_br
argument_list|(
name|chan
argument_list|,
operator|&
name|cbr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|hn_chan_callback
argument_list|,
name|rxr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EISCONN
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"bufring is connected after "
literal|"chan%u open failure\n"
argument_list|,
name|vmbus_chan_id
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_rx_flags
operator||=
name|HN_RX_FLAG_BR_REF
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"open chan%u failed: %d\n"
argument_list|,
name|vmbus_chan_id
argument_list|(
name|chan
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_chan_detach
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|error
decl_stmt|;
name|idx
operator|=
name|vmbus_chan_subidx
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * Link this channel to RX/TX ring. 	 */
name|KASSERT
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|sc
operator|->
name|hn_rx_ring_inuse
argument_list|,
operator|(
literal|"invalid channel index %d, should> 0&&< %d"
operator|,
name|idx
operator|,
name|sc
operator|->
name|hn_rx_ring_inuse
operator|)
argument_list|)
expr_stmt|;
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|rxr
operator|->
name|hn_rx_flags
operator|&
name|HN_RX_FLAG_ATTACHED
operator|)
argument_list|,
operator|(
literal|"RX ring %d is not attached"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_rx_flags
operator|&=
operator|~
name|HN_RX_FLAG_ATTACHED
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|sc
operator|->
name|hn_tx_ring_inuse
condition|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|idx
index|]
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|txr
operator|->
name|hn_tx_flags
operator|&
name|HN_TX_FLAG_ATTACHED
operator|)
argument_list|,
operator|(
literal|"TX ring %d is not attached attached"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_tx_flags
operator|&=
operator|~
name|HN_TX_FLAG_ATTACHED
expr_stmt|;
block|}
comment|/* 	 * Close this channel. 	 * 	 * NOTE: 	 * Channel closing does _not_ destroy the target channel. 	 */
name|error
operator|=
name|vmbus_chan_close_direct
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EISCONN
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"chan%u bufring is connected "
literal|"after being closed\n"
argument_list|,
name|vmbus_chan_id
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_rx_flags
operator||=
name|HN_RX_FLAG_BR_REF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"chan%u close failed: %d\n"
argument_list|,
name|vmbus_chan_id
argument_list|(
name|chan
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hn_attach_subchans
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subchans
decl_stmt|;
name|int
name|subchan_cnt
init|=
name|sc
operator|->
name|hn_rx_ring_inuse
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|subchan_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"no sub-channels"
operator|)
argument_list|)
expr_stmt|;
comment|/* Attach the sub-channels. */
name|subchans
operator|=
name|vmbus_subchan_get
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|,
name|subchan_cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subchan_cnt
condition|;
operator|++
name|i
control|)
block|{
name|int
name|error1
decl_stmt|;
name|error1
operator|=
name|hn_chan_attach
argument_list|(
name|sc
argument_list|,
name|subchans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error1
condition|)
block|{
name|error
operator|=
name|error1
expr_stmt|;
comment|/* Move on; all channels will be detached later. */
block|}
block|}
name|vmbus_subchan_rel
argument_list|(
name|subchans
argument_list|,
name|subchan_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"sub-channels attach failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"%d sub-channels attached\n"
argument_list|,
name|subchan_cnt
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_detach_allchans
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subchans
decl_stmt|;
name|int
name|subchan_cnt
init|=
name|sc
operator|->
name|hn_rx_ring_inuse
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|subchan_cnt
operator|==
literal|0
condition|)
goto|goto
name|back
goto|;
comment|/* Detach the sub-channels. */
name|subchans
operator|=
name|vmbus_subchan_get
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|,
name|subchan_cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subchan_cnt
condition|;
operator|++
name|i
control|)
name|hn_chan_detach
argument_list|(
name|sc
argument_list|,
name|subchans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vmbus_subchan_rel
argument_list|(
name|subchans
argument_list|,
name|subchan_cnt
argument_list|)
expr_stmt|;
name|back
label|:
comment|/* 	 * Detach the primary channel, _after_ all sub-channels 	 * are detached. 	 */
name|hn_chan_detach
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_prichan
argument_list|)
expr_stmt|;
comment|/* Wait for sub-channels to be destroyed, if any. */
name|vmbus_subchan_drain
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
operator|.
name|hn_rx_flags
operator|&
name|HN_RX_FLAG_ATTACHED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%dth RX ring is still attached"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_tx_flags
operator|&
name|HN_TX_FLAG_ATTACHED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%dth TX ring is still attached"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|hn_synth_alloc_subchans
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|nsubch
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subchans
decl_stmt|;
name|int
name|nchan
decl_stmt|,
name|rxr_cnt
decl_stmt|,
name|error
decl_stmt|;
name|nchan
operator|=
operator|*
name|nsubch
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nchan
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Multiple RX/TX rings are not requested. 		 */
operator|*
name|nsubch
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Query RSS capabilities, e.g. # of RX rings, and # of indirect 	 * table entries. 	 */
name|error
operator|=
name|hn_rndis_query_rsscaps
argument_list|(
name|sc
argument_list|,
operator|&
name|rxr_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* No RSS; this is benign. */
operator|*
name|nsubch
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"RX rings offered %u, requested %d\n"
argument_list|,
name|rxr_cnt
argument_list|,
name|nchan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nchan
operator|>
name|rxr_cnt
condition|)
name|nchan
operator|=
name|rxr_cnt
expr_stmt|;
if|if
condition|(
name|nchan
operator|==
literal|1
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"only 1 channel is supported, no vRSS\n"
argument_list|)
expr_stmt|;
operator|*
name|nsubch
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate sub-channels from NVS. 	 */
operator|*
name|nsubch
operator|=
name|nchan
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|hn_nvs_alloc_subchans
argument_list|(
name|sc
argument_list|,
name|nsubch
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|nsubch
operator|==
literal|0
condition|)
block|{
comment|/* Failed to allocate sub-channels. */
operator|*
name|nsubch
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Wait for all sub-channels to become ready before moving on. 	 */
name|subchans
operator|=
name|vmbus_subchan_get
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|,
operator|*
name|nsubch
argument_list|)
expr_stmt|;
name|vmbus_subchan_rel
argument_list|(
name|subchans
argument_list|,
operator|*
name|nsubch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|hn_synth_attachable
parameter_list|(
specifier|const
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_ERRORS
condition|)
return|return
operator|(
name|false
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rxr
operator|->
name|hn_rx_flags
operator|&
name|HN_RX_FLAG_BR_REF
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure that the RX filter is zero after the successful  * RNDIS initialization.  *  * NOTE:  * Under certain conditions on certain versions of Hyper-V,  * the RNDIS rxfilter is _not_ zero on the hypervisor side  * after the successful RNDIS initialization, which breaks  * the assumption of any following code (well, it breaks the  * RNDIS API contract actually).  Clear the RNDIS rxfilter  * explicitly, drain packets sneaking through, and drain the  * interrupt taskqueues scheduled due to the stealth packets.  */
end_comment

begin_function
specifier|static
name|void
name|hn_rndis_init_fixat
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nchan
parameter_list|)
block|{
name|hn_disable_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_drain_rxtx
argument_list|(
name|sc
argument_list|,
name|nchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_synth_attach
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
define|#
directive|define
name|ATTACHED_NVS
value|0x0002
define|#
directive|define
name|ATTACHED_RNDIS
value|0x0004
name|struct
name|ndis_rssprm_toeplitz
modifier|*
name|rss
init|=
operator|&
name|sc
operator|->
name|hn_rss
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsubch
decl_stmt|,
name|nchan
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|rndis_inited
decl_stmt|;
name|uint32_t
name|old_caps
decl_stmt|,
name|attached
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"synthetic parts were attached"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hn_synth_attachable
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Save capabilities for later verification. */
name|old_caps
operator|=
name|sc
operator|->
name|hn_caps
expr_stmt|;
name|sc
operator|->
name|hn_caps
operator|=
literal|0
expr_stmt|;
comment|/* Clear RSS stuffs. */
name|sc
operator|->
name|hn_rss_ind_size
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|hn_rss_hash
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Attach the primary channel _before_ attaching NVS and RNDIS. 	 */
name|error
operator|=
name|hn_chan_attach
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_prichan
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * Attach NVS. 	 */
name|error
operator|=
name|hn_nvs_attach
argument_list|(
name|sc
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|attached
operator||=
name|ATTACHED_NVS
expr_stmt|;
comment|/* 	 * Attach RNDIS _after_ NVS is attached. 	 */
name|error
operator|=
name|hn_rndis_attach
argument_list|(
name|sc
argument_list|,
name|mtu
argument_list|,
operator|&
name|rndis_inited
argument_list|)
expr_stmt|;
if|if
condition|(
name|rndis_inited
condition|)
name|attached
operator||=
name|ATTACHED_RNDIS
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * Make sure capabilities are not changed. 	 */
if|if
condition|(
name|device_is_attached
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
operator|&&
name|old_caps
operator|!=
name|sc
operator|->
name|hn_caps
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"caps mismatch old 0x%08x, new 0x%08x\n"
argument_list|,
name|old_caps
argument_list|,
name|sc
operator|->
name|hn_caps
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Allocate sub-channels for multi-TX/RX rings. 	 * 	 * NOTE: 	 * The # of RX rings that can be used is equivalent to the # of 	 * channels to be requested. 	 */
name|nsubch
operator|=
name|sc
operator|->
name|hn_rx_ring_cnt
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|hn_synth_alloc_subchans
argument_list|(
name|sc
argument_list|,
operator|&
name|nsubch
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* NOTE: _Full_ synthetic parts detach is required now. */
name|sc
operator|->
name|hn_flags
operator||=
name|HN_FLAG_SYNTH_ATTACHED
expr_stmt|;
comment|/* 	 * Set the # of TX/RX rings that could be used according to 	 * the # of channels that NVS offered. 	 */
name|nchan
operator|=
name|nsubch
operator|+
literal|1
expr_stmt|;
name|hn_set_ring_inuse
argument_list|(
name|sc
argument_list|,
name|nchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchan
operator|==
literal|1
condition|)
block|{
comment|/* Only the primary channel can be used; done */
goto|goto
name|back
goto|;
block|}
comment|/* 	 * Attach the sub-channels. 	 * 	 * NOTE: hn_set_ring_inuse() _must_ have been called. 	 */
name|error
operator|=
name|hn_attach_subchans
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * Configure RSS key and indirect table _after_ all sub-channels 	 * are attached. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_HAS_RSSKEY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * RSS key is not set yet; set it to the default RSS key. 		 */
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"setup default RSS key\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|rss_getkey
argument_list|(
name|rss
operator|->
name|rss_key
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|rss
operator|->
name|rss_key
argument_list|,
name|hn_rss_key_default
argument_list|,
sizeof|sizeof
argument_list|(
name|rss
operator|->
name|rss_key
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|hn_flags
operator||=
name|HN_FLAG_HAS_RSSKEY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_HAS_RSSIND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * RSS indirect table is not set yet; set it up in round- 		 * robin fashion. 		 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"setup default RSS indirect "
literal|"table\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDIS_HASH_INDCNT
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|subidx
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|subidx
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|subidx
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
name|rss
operator|->
name|rss_ind
index|[
name|i
index|]
operator|=
name|subidx
operator|%
name|nchan
expr_stmt|;
block|}
name|sc
operator|->
name|hn_flags
operator||=
name|HN_FLAG_HAS_RSSIND
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * # of usable channels may be changed, so we have to 		 * make sure that all entries in RSS indirect table 		 * are valid. 		 * 		 * NOTE: hn_set_ring_inuse() _must_ have been called. 		 */
name|hn_rss_ind_fixup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|hn_rndis_conf_rss
argument_list|(
name|sc
argument_list|,
name|NDIS_RSS_FLAG_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|back
label|:
comment|/* 	 * Fixup transmission aggregation setup. 	 */
name|hn_set_txagg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_rndis_init_fixat
argument_list|(
name|sc
argument_list|,
name|nchan
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
condition|)
block|{
name|hn_rndis_init_fixat
argument_list|(
name|sc
argument_list|,
name|nchan
argument_list|)
expr_stmt|;
name|hn_synth_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|attached
operator|&
name|ATTACHED_RNDIS
condition|)
block|{
name|hn_rndis_init_fixat
argument_list|(
name|sc
argument_list|,
name|nchan
argument_list|)
expr_stmt|;
name|hn_rndis_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attached
operator|&
name|ATTACHED_NVS
condition|)
name|hn_nvs_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_chan_detach
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_prichan
argument_list|)
expr_stmt|;
comment|/* Restore old capabilities. */
name|sc
operator|->
name|hn_caps
operator|=
name|old_caps
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
undef|#
directive|undef
name|ATTACHED_RNDIS
undef|#
directive|undef
name|ATTACHED_NVS
block|}
end_function

begin_comment
comment|/*  * NOTE:  * The interface must have been suspended though hn_suspend(), before  * this function get called.  */
end_comment

begin_function
specifier|static
name|void
name|hn_synth_detach
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_SYNTH_ATTACHED
argument_list|,
operator|(
literal|"synthetic parts were not attached"
operator|)
argument_list|)
expr_stmt|;
comment|/* Detach the RNDIS first. */
name|hn_rndis_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Detach NVS. */
name|hn_nvs_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Detach all of the channels. */
name|hn_detach_allchans
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_flags
operator|&=
operator|~
name|HN_FLAG_SYNTH_ATTACHED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_set_ring_inuse
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ring_cnt
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ring_cnt
operator|>
literal|0
operator|&&
name|ring_cnt
operator|<=
name|sc
operator|->
name|hn_rx_ring_cnt
argument_list|,
operator|(
literal|"invalid ring count %d"
operator|,
name|ring_cnt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_tx_ring_cnt
operator|>
name|ring_cnt
condition|)
name|sc
operator|->
name|hn_tx_ring_inuse
operator|=
name|ring_cnt
expr_stmt|;
else|else
name|sc
operator|->
name|hn_tx_ring_inuse
operator|=
name|sc
operator|->
name|hn_tx_ring_cnt
expr_stmt|;
name|sc
operator|->
name|hn_rx_ring_inuse
operator|=
name|ring_cnt
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring_inuse
operator|!=
name|rss_getnumbuckets
argument_list|()
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"# of RX rings (%d) does not match "
literal|"# of RSS buckets (%d)\n"
argument_list|,
name|sc
operator|->
name|hn_rx_ring_inuse
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"%d TX ring, %d RX ring\n"
argument_list|,
name|sc
operator|->
name|hn_tx_ring_inuse
argument_list|,
name|sc
operator|->
name|hn_rx_ring_inuse
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_chan_drain
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
comment|/* 	 * NOTE: 	 * The TX bufring will not be drained by the hypervisor, 	 * if the primary channel is revoked. 	 */
while|while
condition|(
operator|!
name|vmbus_chan_rx_empty
argument_list|(
name|chan
argument_list|)
operator|||
operator|(
operator|!
name|vmbus_chan_is_revoked
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|)
operator|&&
operator|!
name|vmbus_chan_tx_empty
argument_list|(
name|chan
argument_list|)
operator|)
condition|)
name|pause
argument_list|(
literal|"waitch"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmbus_chan_intr_drain
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_disable_rx
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Disable RX by clearing RX filter forcefully. 	 */
name|sc
operator|->
name|hn_rx_filter
operator|=
name|NDIS_PACKET_TYPE_NONE
expr_stmt|;
name|hn_rndis_set_rxfilter
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_rx_filter
argument_list|)
expr_stmt|;
comment|/* ignore error */
comment|/* 	 * Give RNDIS enough time to flush all pending data packets. 	 */
name|pause
argument_list|(
literal|"waitrx"
argument_list|,
operator|(
literal|200
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NOTE:  * RX/TX _must_ have been suspended/disabled, before this function  * is called.  */
end_comment

begin_function
specifier|static
name|void
name|hn_drain_rxtx
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nchan
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subch
init|=
name|NULL
decl_stmt|;
name|int
name|nsubch
decl_stmt|;
comment|/* 	 * Drain RX/TX bufrings and interrupts. 	 */
name|nsubch
operator|=
name|nchan
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nsubch
operator|>
literal|0
condition|)
name|subch
operator|=
name|vmbus_subchan_get
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|,
name|nsubch
argument_list|)
expr_stmt|;
if|if
condition|(
name|subch
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsubch
condition|;
operator|++
name|i
control|)
name|hn_chan_drain
argument_list|(
name|sc
argument_list|,
name|subch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|hn_chan_drain
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_prichan
argument_list|)
expr_stmt|;
if|if
condition|(
name|subch
operator|!=
name|NULL
condition|)
name|vmbus_subchan_rel
argument_list|(
name|subch
argument_list|,
name|nsubch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_suspend_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Suspend TX. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_inuse
condition|;
operator|++
name|i
control|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_suspended
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
comment|/* No one is able send more packets now. */
comment|/* 		 * Wait for all pending sends to finish. 		 * 		 * NOTE: 		 * We will _not_ receive all pending send-done, if the 		 * primary channel is revoked. 		 */
while|while
condition|(
name|hn_tx_ring_pending
argument_list|(
name|txr
argument_list|)
operator|&&
operator|!
name|vmbus_chan_is_revoked
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|)
condition|)
name|pause
argument_list|(
literal|"hnwtx"
argument_list|,
literal|1
comment|/* 1 tick */
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Disable RX. 	 */
name|hn_disable_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Drain RX/TX. 	 */
name|hn_drain_rxtx
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_rx_ring_inuse
argument_list|)
expr_stmt|;
comment|/* 	 * Drain any pending TX tasks. 	 * 	 * NOTE: 	 * The above hn_drain_rxtx() can dispatch TX tasks, so the TX 	 * tasks will have to be drained _after_ the above hn_drain_rxtx(). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_inuse
condition|;
operator|++
name|i
control|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_suspend_mgmt_taskfunc
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|hn_softc
operator|*
operator|)
name|xsc
operator|)
operator|->
name|hn_mgmt_taskq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_suspend_mgmt
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|task
name|task
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that hn_mgmt_taskq0 can nolonger be accessed 	 * through hn_mgmt_taskq. 	 */
name|TASK_INIT
argument_list|(
operator|&
name|task
argument_list|,
literal|0
argument_list|,
name|hn_suspend_mgmt_taskfunc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|vmbus_chan_run_task
argument_list|(
name|sc
operator|->
name|hn_prichan
argument_list|,
operator|&
name|task
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that all pending management tasks are completed. 	 */
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|hn_mgmt_taskq0
argument_list|,
operator|&
name|sc
operator|->
name|hn_netchg_init
argument_list|)
expr_stmt|;
name|taskqueue_drain_timeout
argument_list|(
name|sc
operator|->
name|hn_mgmt_taskq0
argument_list|,
operator|&
name|sc
operator|->
name|hn_netchg_status
argument_list|)
expr_stmt|;
name|taskqueue_drain_all
argument_list|(
name|sc
operator|->
name|hn_mgmt_taskq0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_suspend
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Disable polling. */
name|hn_polling
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_VF
operator|)
condition|)
name|hn_suspend_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_suspend_mgmt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_resume_tx
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|tx_ring_cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|tx_ring_cnt
operator|<=
name|sc
operator|->
name|hn_tx_ring_cnt
argument_list|,
operator|(
literal|"invalid TX ring count %d"
operator|,
name|tx_ring_cnt
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_suspended
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_resume_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|HN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Re-enable RX. 	 */
name|hn_rxfilter_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure to clear suspend status on "all" TX rings, 	 * since hn_tx_ring_inuse can be changed after 	 * hn_suspend_data(). 	 */
name|hn_resume_tx
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_tx_ring_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_IFSTART_SUPPORT
if|if
condition|(
operator|!
name|hn_use_if_start
condition|)
endif|#
directive|endif
block|{
comment|/* 		 * Flush unused drbrs, since hn_tx_ring_inuse may be 		 * reduced. 		 */
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|hn_tx_ring_inuse
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|hn_tx_ring_qflush
argument_list|(
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Kick start TX. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_inuse
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
decl_stmt|;
comment|/* 		 * Use txeof task, so that any pending oactive can be 		 * cleared properly. 		 */
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_resume_mgmt
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|hn_mgmt_taskq
operator|=
name|sc
operator|->
name|hn_mgmt_taskq0
expr_stmt|;
comment|/* 	 * Kick off network change detection, if it was pending. 	 * If no network change was pending, start link status 	 * checks, which is more lightweight than network change 	 * detection. 	 */
if|if
condition|(
name|sc
operator|->
name|hn_link_flags
operator|&
name|HN_LINK_FLAG_NETCHG
condition|)
name|hn_change_network
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|hn_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_resume
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_VF
operator|)
condition|)
name|hn_resume_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * When the VF is activated, the synthetic interface is changed 	 * to DOWN in hn_set_vf(). Here, if the VF is still active, we 	 * don't call hn_resume_mgmt() until the VF is deactivated in 	 * hn_set_vf(). 	 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|hn_flags
operator|&
name|HN_FLAG_VF
operator|)
condition|)
name|hn_resume_mgmt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Re-enable polling if this interface is running and 	 * the polling is requested. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|hn_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
name|sc
operator|->
name|hn_pollhz
operator|>
literal|0
condition|)
name|hn_polling
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_pollhz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_rndis_rx_status
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|)
block|{
specifier|const
name|struct
name|rndis_status_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|ofs
decl_stmt|;
if|if
condition|(
name|dlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS status\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|msg
operator|=
name|data
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|rm_status
condition|)
block|{
case|case
name|RNDIS_STATUS_MEDIA_CONNECT
case|:
case|case
name|RNDIS_STATUS_MEDIA_DISCONNECT
case|:
name|hn_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNDIS_STATUS_TASK_OFFLOAD_CURRENT_CONFIG
case|:
case|case
name|RNDIS_STATUS_LINK_SPEED_CHANGE
case|:
comment|/* Not really useful; ignore. */
break|break;
case|case
name|RNDIS_STATUS_NETWORK_CHANGE
case|:
name|ofs
operator|=
name|RNDIS_STBUFOFFSET_ABS
argument_list|(
name|msg
operator|->
name|rm_stbufoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|<
name|ofs
operator|+
name|msg
operator|->
name|rm_stbuflen
operator|||
name|msg
operator|->
name|rm_stbuflen
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"network changed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|change
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|change
argument_list|,
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|msg
operator|)
operator|+
name|ofs
argument_list|,
sizeof|sizeof
argument_list|(
name|change
argument_list|)
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"network changed, change %u\n"
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
name|hn_change_network
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"unknown RNDIS status 0x%08x\n"
argument_list|,
name|msg
operator|->
name|rm_status
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hn_rndis_rxinfo
parameter_list|(
specifier|const
name|void
modifier|*
name|info_data
parameter_list|,
name|int
name|info_dlen
parameter_list|,
name|struct
name|hn_rxinfo
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|struct
name|rndis_pktinfo
modifier|*
name|pi
init|=
name|info_data
decl_stmt|;
name|uint32_t
name|mask
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|info_dlen
operator|!=
literal|0
condition|)
block|{
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|uint32_t
name|dlen
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|info_dlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|__predict_false
argument_list|(
name|info_dlen
operator|<
name|pi
operator|->
name|rm_size
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info_dlen
operator|-=
name|pi
operator|->
name|rm_size
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pi
operator|->
name|rm_size
operator|&
name|RNDIS_PKTINFO_SIZE_ALIGNMASK
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pi
operator|->
name|rm_size
operator|<
name|pi
operator|->
name|rm_pktinfooffset
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dlen
operator|=
name|pi
operator|->
name|rm_size
operator|-
name|pi
operator|->
name|rm_pktinfooffset
expr_stmt|;
name|data
operator|=
name|pi
operator|->
name|rm_data
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|rm_type
condition|)
block|{
case|case
name|NDIS_PKTINFO_TYPE_VLAN
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|dlen
operator|<
name|NDIS_VLAN_INFO_SIZE
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info
operator|->
name|vlan_info
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|mask
operator||=
name|HN_RXINFO_VLAN
expr_stmt|;
break|break;
case|case
name|NDIS_PKTINFO_TYPE_CSUM
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|dlen
operator|<
name|NDIS_RXCSUM_INFO_SIZE
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info
operator|->
name|csum_info
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|mask
operator||=
name|HN_RXINFO_CSUM
expr_stmt|;
break|break;
case|case
name|HN_NDIS_PKTINFO_TYPE_HASHVAL
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|dlen
operator|<
name|HN_NDIS_HASH_VALUE_SIZE
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info
operator|->
name|hash_value
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|mask
operator||=
name|HN_RXINFO_HASHVAL
expr_stmt|;
break|break;
case|case
name|HN_NDIS_PKTINFO_TYPE_HASHINF
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|dlen
operator|<
name|HN_NDIS_HASH_INFO_SIZE
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info
operator|->
name|hash_info
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|mask
operator||=
name|HN_RXINFO_HASHINF
expr_stmt|;
break|break;
default|default:
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|mask
operator|==
name|HN_RXINFO_ALL
condition|)
block|{
comment|/* All found; done */
break|break;
block|}
name|next
label|:
name|pi
operator|=
operator|(
specifier|const
expr|struct
name|rndis_pktinfo
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|pi
operator|+
name|pi
operator|->
name|rm_size
operator|)
expr_stmt|;
block|}
comment|/* 	 * Final fixup. 	 * - If there is no hash value, invalidate the hash info. 	 */
if|if
condition|(
operator|(
name|mask
operator|&
name|HN_RXINFO_HASHVAL
operator|)
operator|==
literal|0
condition|)
name|info
operator|->
name|hash_info
operator|=
name|HN_NDIS_HASH_INFO_INVALID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|hn_rndis_check_overlap
parameter_list|(
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|check_off
parameter_list|,
name|int
name|check_len
parameter_list|)
block|{
if|if
condition|(
name|off
operator|<
name|check_off
condition|)
block|{
if|if
condition|(
name|__predict_true
argument_list|(
name|off
operator|+
name|len
operator|<=
name|check_off
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|off
operator|>
name|check_off
condition|)
block|{
if|if
condition|(
name|__predict_true
argument_list|(
name|check_off
operator|+
name|check_len
operator|<=
name|off
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_rndis_rx_data
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
name|rxr
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|)
block|{
specifier|const
name|struct
name|rndis_packet_msg
modifier|*
name|pkt
decl_stmt|;
name|struct
name|hn_rxinfo
name|info
decl_stmt|;
name|int
name|data_off
decl_stmt|,
name|pktinfo_off
decl_stmt|,
name|data_len
decl_stmt|,
name|pktinfo_len
decl_stmt|;
comment|/* 	 * Check length. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|dlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|pkt
argument_list|)
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pkt
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|dlen
operator|<
name|pkt
operator|->
name|rm_len
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"truncated RNDIS packet msg, "
literal|"dlen %d, msglen %u\n"
argument_list|,
name|dlen
argument_list|,
name|pkt
operator|->
name|rm_len
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|->
name|rm_len
operator|<
name|pkt
operator|->
name|rm_datalen
operator|+
name|pkt
operator|->
name|rm_oobdatalen
operator|+
name|pkt
operator|->
name|rm_pktinfolen
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msglen, "
literal|"msglen %u, data %u, oob %u, pktinfo %u\n"
argument_list|,
name|pkt
operator|->
name|rm_len
argument_list|,
name|pkt
operator|->
name|rm_datalen
argument_list|,
name|pkt
operator|->
name|rm_oobdatalen
argument_list|,
name|pkt
operator|->
name|rm_pktinfolen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|->
name|rm_datalen
operator|==
literal|0
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, no data\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check offests. 	 */
define|#
directive|define
name|IS_OFFSET_INVALID
parameter_list|(
name|ofs
parameter_list|)
define|\
value|((ofs)< RNDIS_PACKET_MSG_OFFSET_MIN ||	\ 	 ((ofs)& RNDIS_PACKET_MSG_OFFSET_ALIGNMASK))
comment|/* XXX Hyper-V does not meet data offset alignment requirement */
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|->
name|rm_dataoffset
operator|<
name|RNDIS_PACKET_MSG_OFFSET_MIN
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"data offset %u\n"
argument_list|,
name|pkt
operator|->
name|rm_dataoffset
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|->
name|rm_oobdataoffset
operator|>
literal|0
operator|&&
name|IS_OFFSET_INVALID
argument_list|(
name|pkt
operator|->
name|rm_oobdataoffset
argument_list|)
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"oob offset %u\n"
argument_list|,
name|pkt
operator|->
name|rm_oobdataoffset
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|__predict_true
argument_list|(
name|pkt
operator|->
name|rm_pktinfooffset
operator|>
literal|0
argument_list|)
operator|&&
name|__predict_false
argument_list|(
name|IS_OFFSET_INVALID
argument_list|(
name|pkt
operator|->
name|rm_pktinfooffset
argument_list|)
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"pktinfo offset %u\n"
argument_list|,
name|pkt
operator|->
name|rm_pktinfooffset
argument_list|)
expr_stmt|;
return|return;
block|}
undef|#
directive|undef
name|IS_OFFSET_INVALID
name|data_off
operator|=
name|RNDIS_PACKET_MSG_OFFSET_ABS
argument_list|(
name|pkt
operator|->
name|rm_dataoffset
argument_list|)
expr_stmt|;
name|data_len
operator|=
name|pkt
operator|->
name|rm_datalen
expr_stmt|;
name|pktinfo_off
operator|=
name|RNDIS_PACKET_MSG_OFFSET_ABS
argument_list|(
name|pkt
operator|->
name|rm_pktinfooffset
argument_list|)
expr_stmt|;
name|pktinfo_len
operator|=
name|pkt
operator|->
name|rm_pktinfolen
expr_stmt|;
comment|/* 	 * Check OOB coverage. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|->
name|rm_oobdatalen
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|int
name|oob_off
decl_stmt|,
name|oob_len
decl_stmt|;
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"got oobdata\n"
argument_list|)
expr_stmt|;
name|oob_off
operator|=
name|RNDIS_PACKET_MSG_OFFSET_ABS
argument_list|(
name|pkt
operator|->
name|rm_oobdataoffset
argument_list|)
expr_stmt|;
name|oob_len
operator|=
name|pkt
operator|->
name|rm_oobdatalen
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|oob_off
operator|+
name|oob_len
operator|>
name|pkt
operator|->
name|rm_len
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"oob overflow, msglen %u, oob abs %d len %d\n"
argument_list|,
name|pkt
operator|->
name|rm_len
argument_list|,
name|oob_off
argument_list|,
name|oob_len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Check against data. 		 */
if|if
condition|(
name|hn_rndis_check_overlap
argument_list|(
name|oob_off
argument_list|,
name|oob_len
argument_list|,
name|data_off
argument_list|,
name|data_len
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"oob overlaps data, oob abs %d len %d, "
literal|"data abs %d len %d\n"
argument_list|,
name|oob_off
argument_list|,
name|oob_len
argument_list|,
name|data_off
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Check against pktinfo. 		 */
if|if
condition|(
name|pktinfo_len
operator|!=
literal|0
operator|&&
name|hn_rndis_check_overlap
argument_list|(
name|oob_off
argument_list|,
name|oob_len
argument_list|,
name|pktinfo_off
argument_list|,
name|pktinfo_len
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"oob overlaps pktinfo, oob abs %d len %d, "
literal|"pktinfo abs %d len %d\n"
argument_list|,
name|oob_off
argument_list|,
name|oob_len
argument_list|,
name|pktinfo_off
argument_list|,
name|pktinfo_len
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Check per-packet-info coverage and find useful per-packet-info. 	 */
name|info
operator|.
name|vlan_info
operator|=
name|HN_NDIS_VLAN_INFO_INVALID
expr_stmt|;
name|info
operator|.
name|csum_info
operator|=
name|HN_NDIS_RXCSUM_INFO_INVALID
expr_stmt|;
name|info
operator|.
name|hash_info
operator|=
name|HN_NDIS_HASH_INFO_INVALID
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|pktinfo_len
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|bool
name|overlap
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pktinfo_off
operator|+
name|pktinfo_len
operator|>
name|pkt
operator|->
name|rm_len
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"pktinfo overflow, msglen %u, "
literal|"pktinfo abs %d len %d\n"
argument_list|,
name|pkt
operator|->
name|rm_len
argument_list|,
name|pktinfo_off
argument_list|,
name|pktinfo_len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Check packet info coverage. 		 */
name|overlap
operator|=
name|hn_rndis_check_overlap
argument_list|(
name|pktinfo_off
argument_list|,
name|pktinfo_len
argument_list|,
name|data_off
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|overlap
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"pktinfo overlap data, pktinfo abs %d len %d, "
literal|"data abs %d len %d\n"
argument_list|,
name|pktinfo_off
argument_list|,
name|pktinfo_len
argument_list|,
name|data_off
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Find useful per-packet-info. 		 */
name|error
operator|=
name|hn_rndis_rxinfo
argument_list|(
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|pkt
operator|)
operator|+
name|pktinfo_off
argument_list|,
name|pktinfo_len
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg "
literal|"pktinfo\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|data_off
operator|+
name|data_len
operator|>
name|pkt
operator|->
name|rm_len
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS packet msg, "
literal|"data overflow, msglen %u, data abs %d len %d\n"
argument_list|,
name|pkt
operator|->
name|rm_len
argument_list|,
name|data_off
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
return|return;
block|}
name|hn_rxpkt
argument_list|(
name|rxr
argument_list|,
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|pkt
operator|)
operator|+
name|data_off
argument_list|,
name|data_len
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|hn_rndis_rxpkt
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
name|rxr
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|)
block|{
specifier|const
name|struct
name|rndis_msghdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|dlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid RNDIS msg\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdr
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|hdr
operator|->
name|rm_type
operator|==
name|REMOTE_NDIS_PACKET_MSG
argument_list|)
condition|)
block|{
comment|/* Hot data path. */
name|hn_rndis_rx_data
argument_list|(
name|rxr
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
comment|/* Done! */
return|return;
block|}
if|if
condition|(
name|hdr
operator|->
name|rm_type
operator|==
name|REMOTE_NDIS_INDICATE_STATUS_MSG
condition|)
name|hn_rndis_rx_status
argument_list|(
name|rxr
operator|->
name|hn_ifp
operator|->
name|if_softc
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
else|else
name|hn_rndis_rx_ctrl
argument_list|(
name|rxr
operator|->
name|hn_ifp
operator|->
name|if_softc
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_nvs_handle_notify
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|vmbus_chanpkt_hdr
modifier|*
name|pkt
parameter_list|)
block|{
specifier|const
name|struct
name|hn_nvs_hdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|VMBUS_CHANPKT_DATALEN
argument_list|(
name|pkt
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"invalid nvs notify\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdr
operator|=
name|VMBUS_CHANPKT_CONST_DATA
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|nvs_type
operator|==
name|HN_NVS_TYPE_TXTBL_NOTE
condition|)
block|{
comment|/* Useless; ignore */
return|return;
block|}
name|if_printf
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|,
literal|"got notify, nvs type %u\n"
argument_list|,
name|hdr
operator|->
name|nvs_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_nvs_handle_comp
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|struct
name|vmbus_chanpkt_hdr
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|hn_nvs_sendctx
modifier|*
name|sndc
decl_stmt|;
name|sndc
operator|=
operator|(
expr|struct
name|hn_nvs_sendctx
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|pkt
operator|->
name|cph_xactid
expr_stmt|;
name|sndc
operator|->
name|hn_cb
argument_list|(
name|sndc
argument_list|,
name|sc
argument_list|,
name|chan
argument_list|,
name|VMBUS_CHANPKT_CONST_DATA
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|VMBUS_CHANPKT_DATALEN
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: 	 * 'sndc' CAN NOT be accessed anymore, since it can be freed by 	 * its callback. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|hn_nvs_handle_rxbuf
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
name|rxr
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|struct
name|vmbus_chanpkt_hdr
modifier|*
name|pkthdr
parameter_list|)
block|{
specifier|const
name|struct
name|vmbus_chanpkt_rxbuf
modifier|*
name|pkt
decl_stmt|;
specifier|const
name|struct
name|hn_nvs_hdr
modifier|*
name|nvs_hdr
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|hlen
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|VMBUS_CHANPKT_DATALEN
argument_list|(
name|pkthdr
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|nvs_hdr
argument_list|)
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid nvs RNDIS\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvs_hdr
operator|=
name|VMBUS_CHANPKT_CONST_DATA
argument_list|(
name|pkthdr
argument_list|)
expr_stmt|;
comment|/* Make sure that this is a RNDIS message. */
if|if
condition|(
name|__predict_false
argument_list|(
name|nvs_hdr
operator|->
name|nvs_type
operator|!=
name|HN_NVS_TYPE_RNDIS
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"nvs type %u, not RNDIS\n"
argument_list|,
name|nvs_hdr
operator|->
name|nvs_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|hlen
operator|=
name|VMBUS_CHANPKT_GETLEN
argument_list|(
name|pkthdr
operator|->
name|cph_hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|pkt
argument_list|)
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid rxbuf chanpkt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pkt
operator|=
operator|(
specifier|const
expr|struct
name|vmbus_chanpkt_rxbuf
operator|*
operator|)
name|pkthdr
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|->
name|cp_rxbuf_id
operator|!=
name|HN_NVS_RXBUF_SIG
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid rxbuf_id 0x%08x\n"
argument_list|,
name|pkt
operator|->
name|cp_rxbuf_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|=
name|pkt
operator|->
name|cp_rxbuf_cnt
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|hlen
operator|<
name|__offsetof
argument_list|(
expr|struct
name|vmbus_chanpkt_rxbuf
argument_list|,
name|cp_rxbuf
index|[
name|count
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"invalid rxbuf_cnt %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Each range represents 1 RNDIS pkt that contains 1 Ethernet frame */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ofs
decl_stmt|,
name|len
decl_stmt|;
name|ofs
operator|=
name|pkt
operator|->
name|cp_rxbuf
index|[
name|i
index|]
operator|.
name|rb_ofs
expr_stmt|;
name|len
operator|=
name|pkt
operator|->
name|cp_rxbuf
index|[
name|i
index|]
operator|.
name|rb_len
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ofs
operator|+
name|len
operator|>
name|HN_RXBUF_SIZE
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"%dth RNDIS msg overflow rxbuf, "
literal|"ofs %d, len %d\n"
argument_list|,
name|i
argument_list|,
name|ofs
argument_list|,
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hn_rndis_rxpkt
argument_list|(
name|rxr
argument_list|,
name|rxr
operator|->
name|hn_rxbuf
operator|+
name|ofs
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ack the consumed RXBUF associated w/ this channel packet, 	 * so that this RXBUF can be recycled by the hypervisor. 	 */
name|hn_nvs_ack_rxbuf
argument_list|(
name|rxr
argument_list|,
name|chan
argument_list|,
name|pkt
operator|->
name|cp_hdr
operator|.
name|cph_xactid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_nvs_ack_rxbuf
parameter_list|(
name|struct
name|hn_rx_ring
modifier|*
name|rxr
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|uint64_t
name|tid
parameter_list|)
block|{
name|struct
name|hn_nvs_rndis_ack
name|ack
decl_stmt|;
name|int
name|retries
decl_stmt|,
name|error
decl_stmt|;
name|ack
operator|.
name|nvs_type
operator|=
name|HN_NVS_TYPE_RNDIS_ACK
expr_stmt|;
name|ack
operator|.
name|nvs_status
operator|=
name|HN_NVS_STATUS_OK
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|error
operator|=
name|vmbus_chan_send
argument_list|(
name|chan
argument_list|,
name|VMBUS_CHANPKT_TYPE_COMP
argument_list|,
name|VMBUS_CHANPKT_FLAG_NONE
argument_list|,
operator|&
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|ack
argument_list|)
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|==
name|EAGAIN
argument_list|)
condition|)
block|{
comment|/* 		 * NOTE: 		 * This should _not_ happen in real world, since the 		 * consumption of the TX bufring from the TX path is 		 * controlled. 		 */
if|if
condition|(
name|rxr
operator|->
name|hn_ack_failed
operator|==
literal|0
condition|)
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"RXBUF ack retry\n"
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_ack_failed
operator|++
expr_stmt|;
name|retries
operator|++
expr_stmt|;
if|if
condition|(
name|retries
operator|<
literal|10
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* RXBUF leaks! */
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"RXBUF ack failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_chan_callback
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|void
modifier|*
name|xrxr
parameter_list|)
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
name|xrxr
decl_stmt|;
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|rxr
operator|->
name|hn_ifp
operator|->
name|if_softc
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|vmbus_chanpkt_hdr
modifier|*
name|pkt
init|=
name|rxr
operator|->
name|hn_pktbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pktlen
decl_stmt|;
name|pktlen
operator|=
name|rxr
operator|->
name|hn_pktbuf_len
expr_stmt|;
name|error
operator|=
name|vmbus_chan_recv_pkt
argument_list|(
name|chan
argument_list|,
name|pkt
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|==
name|ENOBUFS
argument_list|)
condition|)
block|{
name|void
modifier|*
name|nbuf
decl_stmt|;
name|int
name|nlen
decl_stmt|;
comment|/* 			 * Expand channel packet buffer. 			 * 			 * XXX 			 * Use M_WAITOK here, since allocation failure 			 * is fatal. 			 */
name|nlen
operator|=
name|rxr
operator|->
name|hn_pktbuf_len
operator|*
literal|2
expr_stmt|;
while|while
condition|(
name|nlen
operator|<
name|pktlen
condition|)
name|nlen
operator|*=
literal|2
expr_stmt|;
name|nbuf
operator|=
name|malloc
argument_list|(
name|nlen
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"expand pktbuf %d -> %d\n"
argument_list|,
name|rxr
operator|->
name|hn_pktbuf_len
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rxr
operator|->
name|hn_pktbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_pktbuf
operator|=
name|nbuf
expr_stmt|;
name|rxr
operator|->
name|hn_pktbuf_len
operator|=
name|nlen
expr_stmt|;
comment|/* Retry! */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|==
name|EAGAIN
argument_list|)
condition|)
block|{
comment|/* No more channel packets; done! */
break|break;
block|}
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"vmbus_chan_recv_pkt failed: %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pkt
operator|->
name|cph_type
condition|)
block|{
case|case
name|VMBUS_CHANPKT_TYPE_COMP
case|:
name|hn_nvs_handle_comp
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMBUS_CHANPKT_TYPE_RXBUF
case|:
name|hn_nvs_handle_rxbuf
argument_list|(
name|rxr
argument_list|,
name|chan
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMBUS_CHANPKT_TYPE_INBAND
case|:
name|hn_nvs_handle_notify
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|rxr
operator|->
name|hn_ifp
argument_list|,
literal|"unknown chan pkt %u\n"
argument_list|,
name|pkt
operator|->
name|cph_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|hn_chan_rollup
argument_list|(
name|rxr
argument_list|,
name|rxr
operator|->
name|hn_txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_sysinit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Initialize VF map. 	 */
name|rm_init_flags
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|,
literal|"hn_vfmap"
argument_list|,
name|RM_SLEEPABLE
argument_list|)
expr_stmt|;
name|hn_vfmap_size
operator|=
name|HN_VFMAP_SIZE_DEF
expr_stmt|;
name|hn_vfmap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
operator|*
name|hn_vfmap_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * Fix the # of TX taskqueues. 	 */
if|if
condition|(
name|hn_tx_taskq_cnt
operator|<=
literal|0
condition|)
name|hn_tx_taskq_cnt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|hn_tx_taskq_cnt
operator|>
name|mp_ncpus
condition|)
name|hn_tx_taskq_cnt
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* 	 * Fix the TX taskqueue mode. 	 */
switch|switch
condition|(
name|hn_tx_taskq_mode
condition|)
block|{
case|case
name|HN_TX_TASKQ_M_INDEP
case|:
case|case
name|HN_TX_TASKQ_M_GLOBAL
case|:
case|case
name|HN_TX_TASKQ_M_EVTTQ
case|:
break|break;
default|default:
name|hn_tx_taskq_mode
operator|=
name|HN_TX_TASKQ_M_INDEP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vm_guest
operator|!=
name|VM_GUEST_HV
condition|)
return|return;
if|if
condition|(
name|hn_tx_taskq_mode
operator|!=
name|HN_TX_TASKQ_M_GLOBAL
condition|)
return|return;
name|hn_tx_taskque
operator|=
name|malloc
argument_list|(
name|hn_tx_taskq_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|taskqueue
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hn_tx_taskq_cnt
condition|;
operator|++
name|i
control|)
block|{
name|hn_tx_taskque
index|[
name|i
index|]
operator|=
name|taskqueue_create
argument_list|(
literal|"hn_tx"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|hn_tx_taskque
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|hn_tx_taskque
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"hn tx%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|hn_sysinit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|hn_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|hn_sysuninit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|hn_tx_taskque
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hn_tx_taskq_cnt
condition|;
operator|++
name|i
control|)
name|taskqueue_free
argument_list|(
name|hn_tx_taskque
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hn_tx_taskque
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hn_vfmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hn_vfmap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rm_destroy
argument_list|(
operator|&
name|hn_vfmap_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|hn_sysuninit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|hn_sysuninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

