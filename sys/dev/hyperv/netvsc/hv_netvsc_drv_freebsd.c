begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Citrix Inc.  * Copyright (c) 2009-2012 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2004-2006 Kip Macy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv.h>
end_include

begin_include
include|#
directive|include
file|"hv_net_vsc.h"
end_include

begin_include
include|#
directive|include
file|"hv_rndis.h"
end_include

begin_include
include|#
directive|include
file|"hv_rndis_filter.h"
end_include

begin_comment
comment|/* Short for Hyper-V network interface */
end_comment

begin_define
define|#
directive|define
name|NETVSC_DEVNAME
value|"hn"
end_define

begin_comment
comment|/*  * It looks like offset 0 of buf is reserved to hold the softc pointer.  * The sc pointer evidently not needed, and is not presently populated.  * The packet offset is where the netvsc_packet starts in the buffer.  */
end_comment

begin_define
define|#
directive|define
name|HV_NV_SC_PTR_OFFSET_IN_BUF
value|0
end_define

begin_define
define|#
directive|define
name|HV_NV_PACKET_OFFSET_IN_BUF
value|16
end_define

begin_comment
comment|/*  * A unified flag for all outbound check sum flags is useful,  * and it helps avoiding unnecessary check sum calculation in  * network forwarding scenario.  */
end_comment

begin_define
define|#
directive|define
name|HV_CSUM_FOR_OUTBOUND
define|\
value|(CSUM_IP|CSUM_IP_UDP|CSUM_IP_TCP|CSUM_IP_SCTP|CSUM_IP_TSO|		\     CSUM_IP_ISCSI|CSUM_IP6_UDP|CSUM_IP6_TCP|CSUM_IP6_SCTP|		\     CSUM_IP6_TSO|CSUM_IP6_ISCSI)
end_define

begin_comment
comment|/* XXX move to netinet/tcp_lro.h */
end_comment

begin_define
define|#
directive|define
name|HN_LRO_HIWAT_MAX
value|65535
end_define

begin_define
define|#
directive|define
name|HN_LRO_HIWAT_DEF
value|HN_LRO_HIWAT_MAX
end_define

begin_comment
comment|/* YYY 2*MTU is a bit rough, but should be good enough. */
end_comment

begin_define
define|#
directive|define
name|HN_LRO_HIWAT_MTULIM
parameter_list|(
name|ifp
parameter_list|)
value|(2 * (ifp)->if_mtu)
end_define

begin_define
define|#
directive|define
name|HN_LRO_HIWAT_ISVALID
parameter_list|(
name|sc
parameter_list|,
name|hiwat
parameter_list|)
define|\
value|((hiwat)>= HN_LRO_HIWAT_MTULIM((sc)->hn_ifp) ||	\      (hiwat)<= HN_LRO_HIWAT_MAX)
end_define

begin_comment
comment|/*  * Data types  */
end_comment

begin_struct
struct|struct
name|hv_netvsc_driver_context
block|{
name|uint32_t
name|drv_inited
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Be aware that this sleepable mutex will exhibit WITNESS errors when  * certain TCP and ARP code paths are taken.  This appears to be a  * well-known condition, as all other drivers checked use a sleeping  * mutex to protect their transmit paths.  * Also Be aware that mutexes do not play well with semaphores, and there  * is a conflicting semaphore in a certain channel code path.  */
end_comment

begin_define
define|#
directive|define
name|NV_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|mtx_init(&(_sc)->hn_lock, _name, MTX_NETWORK_LOCK, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|NV_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->hn_lock)
end_define

begin_define
define|#
directive|define
name|NV_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->hn_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|NV_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->hn_lock)
end_define

begin_define
define|#
directive|define
name|NV_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&(_sc)->hn_lock)
end_define

begin_comment
comment|/*  * Globals  */
end_comment

begin_decl_stmt
name|int
name|hv_promisc_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* normal mode by default */
end_comment

begin_comment
comment|/* The one and only one */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hv_netvsc_driver_context
name|g_netvsc_drv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Trust tcp segements verification on host side. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_trust_hosttcp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"dev.hn.trust_hosttcp"
argument_list|,
operator|&
name|hn_trust_hosttcp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Forward declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|hn_stop
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifinit_locked
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HN_LRO_HIWAT
end_ifdef

begin_function_decl
specifier|static
name|int
name|hn_lro_hiwat_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|hn_check_iplen
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|hn_set_lro_hiwat
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|hiwat
parameter_list|)
block|{
name|sc
operator|->
name|hn_lro_hiwat
operator|=
name|hiwat
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_LRO_HIWAT
name|sc
operator|->
name|hn_lro
operator|.
name|lro_hiwat
operator|=
name|sc
operator|->
name|hn_lro_hiwat
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * NetVsc get message transport protocol type   */
end_comment

begin_function
specifier|static
name|uint32_t
name|get_transport_proto_type
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
block|{
name|uint32_t
name|ret_val
init|=
name|TRANSPORT_TYPE_NOT_IP
decl_stmt|;
name|uint16_t
name|ether_type
init|=
literal|0
decl_stmt|;
name|int
name|ether_len
init|=
literal|0
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|eh
operator|=
name|mtod
argument_list|(
name|m_head
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ether_len
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|ether_type
operator|=
name|eh
operator|->
name|evl_proto
expr_stmt|;
block|}
else|else
block|{
name|ether_len
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|ether_type
operator|=
name|eh
operator|->
name|evl_encap_proto
expr_stmt|;
block|}
switch|switch
condition|(
name|ntohs
argument_list|(
name|ether_type
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|m_head
operator|->
name|m_data
operator|+
name|ether_len
operator|)
expr_stmt|;
if|if
condition|(
name|IPPROTO_TCP
operator|==
name|ip6
operator|->
name|ip6_nxt
condition|)
block|{
name|ret_val
operator|=
name|TRANSPORT_TYPE_IPV6_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IPPROTO_UDP
operator|==
name|ip6
operator|->
name|ip6_nxt
condition|)
block|{
name|ret_val
operator|=
name|TRANSPORT_TYPE_IPV6_UDP
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|iph
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m_head
operator|->
name|m_data
operator|+
name|ether_len
operator|)
expr_stmt|;
if|if
condition|(
name|IPPROTO_TCP
operator|==
name|iph
operator|->
name|ip_p
condition|)
block|{
name|ret_val
operator|=
name|TRANSPORT_TYPE_IPV4_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IPPROTO_UDP
operator|==
name|iph
operator|->
name|ip_p
condition|)
block|{
name|ret_val
operator|=
name|TRANSPORT_TYPE_IPV4_UDP
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|ret_val
operator|=
name|TRANSPORT_TYPE_NOT_IP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|hn_carrier
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
operator||
name|IFM_FDX
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NetVsc driver initialization  * Note:  Filter init is no longer required  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_drv_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NetVsc global initialization entry point  */
end_comment

begin_function
specifier|static
name|void
name|netvsc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Netvsc initializing... "
argument_list|)
expr_stmt|;
comment|/* 	 * XXXKYS: cleanup initialization 	 */
if|if
condition|(
operator|!
name|cold
operator|&&
operator|!
name|g_netvsc_drv
operator|.
name|drv_inited
condition|)
block|{
name|g_netvsc_drv
operator|.
name|drv_inited
operator|=
literal|1
expr_stmt|;
name|netvsc_drv_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"done!\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Already initialized!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* {F8615163-DF3E-46c5-913F-F2D2F965ED0E} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|hv_guid
name|g_net_vsc_device_type
init|=
block|{
operator|.
name|data
operator|=
block|{
literal|0x63
block|,
literal|0x51
block|,
literal|0x61
block|,
literal|0xF8
block|,
literal|0x3E
block|,
literal|0xDF
block|,
literal|0xc5
block|,
literal|0x46
block|,
literal|0x91
block|,
literal|0x3F
block|,
literal|0xF2
block|,
literal|0xD2
block|,
literal|0xF9
block|,
literal|0x65
block|,
literal|0xED
block|,
literal|0x0E
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Standard probe entry point.  *  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|vmbus_get_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
operator|&
name|g_net_vsc_device_type
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_guid
argument_list|)
argument_list|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Synthetic Network Interface"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Netvsc probe... DONE \n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard attach entry point.  *  * Called when the driver is loaded.  It allocates needed resources,  * and initializes the "hardware" and software.  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|netvsc_device_info
name|device_info
decl_stmt|;
name|hn_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|netvsc_init
argument_list|()
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|hn_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|hn_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|hn_lro_hiwat
operator|=
name|HN_LRO_HIWAT_DEF
expr_stmt|;
name|sc
operator|->
name|hn_trust_hosttcp
operator|=
name|hn_trust_hosttcp
expr_stmt|;
name|NV_LOCK_INIT
argument_list|(
name|sc
argument_list|,
literal|"NetVSCLock"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_dev_obj
operator|=
name|device_ctx
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_dunit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_dname
operator|=
name|NETVSC_DEVNAME
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|hn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|hn_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|hn_ifinit
expr_stmt|;
comment|/* needed by hv_rf_on_device_add() code */
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
literal|511
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
literal|0
argument_list|,
name|hn_ifmedia_upd
argument_list|,
name|hn_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* XXX ifmedia_set really should do this for us */
name|sc
operator|->
name|hn_media
operator|.
name|ifm_media
operator|=
name|sc
operator|->
name|hn_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
comment|/* 	 * Tell upper layers that we support full VLAN capability. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO
operator||
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO
operator||
name|IFCAP_LRO
expr_stmt|;
comment|/* 	 * Only enable UDP checksum offloading when it is on 2012R2 or 	 * later. UDP checksum offloading doesn't work on earlier 	 * Windows releases. 	 */
if|if
condition|(
name|hv_vmbus_protocal_version
operator|>=
name|HV_VMBUS_VERSION_WIN8_1
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_TSO
expr_stmt|;
name|ret
operator|=
name|hv_rf_on_device_add
argument_list|(
name|device_ctx
argument_list|,
operator|&
name|device_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|device_info
operator|.
name|link_state
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|1
expr_stmt|;
block|}
name|tcp_lro_init
argument_list|(
operator|&
name|sc
operator|->
name|hn_lro
argument_list|)
expr_stmt|;
comment|/* Driver private LRO settings */
name|sc
operator|->
name|hn_lro
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_LRO_HIWAT
name|sc
operator|->
name|hn_lro
operator|.
name|lro_hiwat
operator|=
name|sc
operator|->
name|hn_lro_hiwat
expr_stmt|;
endif|#
directive|endif
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|device_info
operator|.
name|mac_addr
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|hn_lro
operator|.
name|lro_queued
argument_list|,
literal|0
argument_list|,
literal|"LRO queued"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|hn_lro
operator|.
name|lro_flushed
argument_list|,
literal|0
argument_list|,
literal|"LRO flushed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_tried"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|hn_lro_tried
argument_list|,
literal|"# of LRO tries"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_LRO_HIWAT
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_hiwat"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_lro_hiwat_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"LRO high watermark"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trust_hosttcp"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|hn_trust_hosttcp
argument_list|,
literal|0
argument_list|,
literal|"Trust tcp segement verification on host side, "
literal|"when csum info is missing"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_ip"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|hn_csum_ip
argument_list|,
literal|"RXCSUM IP"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_tcp"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|hn_csum_tcp
argument_list|,
literal|"RXCSUM TCP"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_trusted"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|hn_csum_trusted
argument_list|,
literal|"# of TCP segements that we trust host's csum verification"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"small_pkts"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|hn_small_pkts
argument_list|,
literal|"# of small packets received"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|dc_ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|dc_child
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
comment|/* 		 * Add sysctl nodes for devclass 		 */
name|dc
operator|=
name|device_get_devclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dc_ctx
operator|=
name|devclass_get_sysctl_ctx
argument_list|(
name|dc
argument_list|)
expr_stmt|;
name|dc_child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|devclass_get_sysctl_tree
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|dc_ctx
argument_list|,
name|dc_child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trust_hosttcp"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|hn_trust_hosttcp
argument_list|,
literal|0
argument_list|,
literal|"Trust tcp segement verification on host side, "
literal|"when csum info is missing (global setting)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard detach entry point  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|hv_device
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"netvsc_detach\n"
argument_list|)
expr_stmt|;
comment|/* 	 * XXXKYS:  Need to clean up all our 	 * driver state; this is the driver 	 * unloading. 	 */
comment|/* 	 * XXXKYS:  Need to stop outgoing traffic and unregister 	 * the netdevice. 	 */
name|hv_rf_on_device_remove
argument_list|(
name|hv_device
argument_list|,
name|HV_RF_NV_DESTROY_CHANNEL
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|)
expr_stmt|;
name|tcp_lro_free
argument_list|(
operator|&
name|sc
operator|->
name|hn_lro
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard shutdown entry point  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send completion processing  *  * Note:  It looks like offset 0 of buf is reserved to hold the softc  * pointer.  The sc pointer is not currently needed in this function, and  * it is not presently populated by the TX function.  */
end_comment

begin_function
name|void
name|netvsc_xmit_completion
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|netvsc_packet
modifier|*
name|packet
init|=
operator|(
name|netvsc_packet
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_tid
expr_stmt|;
name|buf
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|packet
operator|)
operator|-
name|HV_NV_PACKET_OFFSET_IN_BUF
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_NETVSC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start a transmit of one or more packets  */
end_comment

begin_function
specifier|static
name|int
name|hn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|netvsc_dev
modifier|*
name|net_dev
init|=
name|sc
operator|->
name|net_dev
decl_stmt|;
name|device_t
name|dev
init|=
name|device_ctx
operator|->
name|device
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|netvsc_packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc_head
init|=
name|NULL
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|rndis_msg
modifier|*
name|rndis_mesg
decl_stmt|;
name|rndis_packet
modifier|*
name|rndis_pkt
decl_stmt|;
name|rndis_per_packet_info
modifier|*
name|rppi
decl_stmt|;
name|ndis_8021q_info
modifier|*
name|rppi_vlan_info
decl_stmt|;
name|rndis_tcp_ip_csum_info
modifier|*
name|csum_info
decl_stmt|;
name|rndis_tcp_tso_info
modifier|*
name|tso_info
decl_stmt|;
name|int
name|ether_len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_frags
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|uint32_t
name|rndis_msg_size
init|=
literal|0
decl_stmt|;
name|uint32_t
name|trans_proto_type
decl_stmt|;
name|uint32_t
name|send_buf_section_idx
init|=
name|NVSP_1_CHIMNEY_SEND_INVALID_SECTION_INDEX
decl_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hn_ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|hn_ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|num_frags
operator|=
literal|0
expr_stmt|;
comment|/* Walk the mbuf list computing total length and num frags */
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
name|num_frags
operator|++
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
block|}
comment|/* 		 * Reserve the number of pages requested.  Currently, 		 * one page is reserved for the message in the RNDIS 		 * filter packet 		 */
name|num_frags
operator|+=
name|HV_RF_NUM_TX_RESERVED_PAGE_BUFS
expr_stmt|;
comment|/* If exceeds # page_buffers in netvsc_packet */
if|if
condition|(
name|num_frags
operator|>
name|NETVSC_PACKET_MAXPAGE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"exceed max page buffers,%d,%d\n"
argument_list|,
name|num_frags
argument_list|,
name|NETVSC_PACKET_MAXPAGE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * Allocate a buffer with space for a netvsc packet plus a 		 * number of reserved areas.  First comes a (currently 16 		 * bytes, currently unused) reserved data area.  Second is 		 * the netvsc_packet. Third is an area reserved for an  		 * rndis_filter_packet struct. Fourth (optional) is a  		 * rndis_per_packet_info struct. 		 * Changed malloc to M_NOWAIT to avoid sleep under spin lock. 		 * No longer reserving extra space for page buffers, as they 		 * are already part of the netvsc_packet. 		 */
name|buf
operator|=
name|malloc
argument_list|(
name|HV_NV_PACKET_OFFSET_IN_BUF
operator|+
sizeof|sizeof
argument_list|(
name|netvsc_packet
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rndis_msg
argument_list|)
operator|+
name|RNDIS_VLAN_PPI_SIZE
operator|+
name|RNDIS_TSO_PPI_SIZE
operator|+
name|RNDIS_CSUM_PPI_SIZE
argument_list|,
name|M_NETVSC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hn:malloc packet failed\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|packet
operator|=
operator|(
name|netvsc_packet
operator|*
operator|)
operator|(
name|buf
operator|+
name|HV_NV_PACKET_OFFSET_IN_BUF
operator|)
expr_stmt|;
operator|*
operator|(
name|vm_offset_t
operator|*
operator|)
name|buf
operator|=
name|HV_NV_SC_PTR_OFFSET_IN_BUF
expr_stmt|;
name|packet
operator|->
name|is_data_pkt
operator|=
name|TRUE
expr_stmt|;
comment|/* Set up the rndis header */
name|packet
operator|->
name|page_buf_count
operator|=
name|num_frags
expr_stmt|;
comment|/* Initialize it from the mbuf */
name|packet
operator|->
name|tot_data_buf_len
operator|=
name|len
expr_stmt|;
comment|/* 		 * extension points to the area reserved for the 		 * rndis_filter_packet, which is placed just after 		 * the netvsc_packet (and rppi struct, if present; 		 * length is updated later). 		 */
name|packet
operator|->
name|rndis_mesg
operator|=
name|packet
operator|+
literal|1
expr_stmt|;
name|rndis_mesg
operator|=
operator|(
name|rndis_msg
operator|*
operator|)
name|packet
operator|->
name|rndis_mesg
expr_stmt|;
name|rndis_mesg
operator|->
name|ndis_msg_type
operator|=
name|REMOTE_NDIS_PACKET_MSG
expr_stmt|;
name|rndis_pkt
operator|=
operator|&
name|rndis_mesg
operator|->
name|msg
operator|.
name|packet
expr_stmt|;
name|rndis_pkt
operator|->
name|data_offset
operator|=
sizeof|sizeof
argument_list|(
name|rndis_packet
argument_list|)
expr_stmt|;
name|rndis_pkt
operator|->
name|data_length
operator|=
name|packet
operator|->
name|tot_data_buf_len
expr_stmt|;
name|rndis_pkt
operator|->
name|per_pkt_info_offset
operator|=
sizeof|sizeof
argument_list|(
name|rndis_packet
argument_list|)
expr_stmt|;
name|rndis_msg_size
operator|=
name|RNDIS_MESSAGE_SIZE
argument_list|(
name|rndis_packet
argument_list|)
expr_stmt|;
comment|/* 		 * If the Hyper-V infrastructure needs to embed a VLAN tag, 		 * initialize netvsc_packet and rppi struct values as needed. 		 */
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
comment|/* 			 * set up some additional fields so the Hyper-V infrastructure will stuff the VLAN tag 			 * into the frame. 			 */
name|packet
operator|->
name|vlan_tci
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
expr_stmt|;
name|rndis_msg_size
operator|+=
name|RNDIS_VLAN_PPI_SIZE
expr_stmt|;
name|rppi
operator|=
name|hv_set_rppi_data
argument_list|(
name|rndis_mesg
argument_list|,
name|RNDIS_VLAN_PPI_SIZE
argument_list|,
name|ieee_8021q_info
argument_list|)
expr_stmt|;
comment|/* VLAN info immediately follows rppi struct */
name|rppi_vlan_info
operator|=
operator|(
name|ndis_8021q_info
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rppi
operator|+
name|rppi
operator|->
name|per_packet_info_offset
operator|)
expr_stmt|;
comment|/* FreeBSD does not support CFI or priority */
name|rppi_vlan_info
operator|->
name|u1
operator|.
name|s1
operator|.
name|vlan_id
operator|=
name|packet
operator|->
name|vlan_tci
operator|&
literal|0xfff
expr_stmt|;
block|}
comment|/* Only check the flags for outbound and ignore the ones for inbound */
if|if
condition|(
literal|0
operator|==
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|HV_CSUM_FOR_OUTBOUND
operator|)
condition|)
block|{
goto|goto
name|pre_send
goto|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m_head
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ether_len
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|ether_len
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
name|trans_proto_type
operator|=
name|get_transport_proto_type
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRANSPORT_TYPE_NOT_IP
operator|==
name|trans_proto_type
condition|)
block|{
goto|goto
name|pre_send
goto|;
block|}
comment|/* 		 * TSO packet needless to setup the send side checksum 		 * offload. 		 */
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
goto|goto
name|do_tso
goto|;
block|}
comment|/* setup checksum offload */
name|rndis_msg_size
operator|+=
name|RNDIS_CSUM_PPI_SIZE
expr_stmt|;
name|rppi
operator|=
name|hv_set_rppi_data
argument_list|(
name|rndis_mesg
argument_list|,
name|RNDIS_CSUM_PPI_SIZE
argument_list|,
name|tcpip_chksum_info
argument_list|)
expr_stmt|;
name|csum_info
operator|=
operator|(
name|rndis_tcp_ip_csum_info
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rppi
operator|+
name|rppi
operator|->
name|per_packet_info_offset
operator|)
expr_stmt|;
if|if
condition|(
name|trans_proto_type
operator|&
operator|(
name|TYPE_IPV4
operator|<<
literal|16
operator|)
condition|)
block|{
name|csum_info
operator|->
name|xmit
operator|.
name|is_ipv4
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|csum_info
operator|->
name|xmit
operator|.
name|is_ipv6
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|trans_proto_type
operator|&
name|TYPE_TCP
condition|)
block|{
name|csum_info
operator|->
name|xmit
operator|.
name|tcp_csum
operator|=
literal|1
expr_stmt|;
name|csum_info
operator|->
name|xmit
operator|.
name|tcp_header_offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trans_proto_type
operator|&
name|TYPE_UDP
condition|)
block|{
name|csum_info
operator|->
name|xmit
operator|.
name|udp_csum
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|pre_send
goto|;
name|do_tso
label|:
comment|/* setup TCP segmentation offload */
name|rndis_msg_size
operator|+=
name|RNDIS_TSO_PPI_SIZE
expr_stmt|;
name|rppi
operator|=
name|hv_set_rppi_data
argument_list|(
name|rndis_mesg
argument_list|,
name|RNDIS_TSO_PPI_SIZE
argument_list|,
name|tcp_large_send_info
argument_list|)
expr_stmt|;
name|tso_info
operator|=
operator|(
name|rndis_tcp_tso_info
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rppi
operator|+
name|rppi
operator|->
name|per_packet_info_offset
operator|)
expr_stmt|;
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|type
operator|=
name|RNDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|trans_proto_type
operator|&
operator|(
name|TYPE_IPV4
operator|<<
literal|16
operator|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m_head
operator|->
name|m_data
operator|+
name|ether_len
operator|)
decl_stmt|;
name|unsigned
name|long
name|iph_len
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iph_len
operator|)
decl_stmt|;
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|ip_version
operator|=
name|RNDIS_TCP_LARGE_SEND_OFFLOAD_IPV4
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|m_head
operator|->
name|m_data
operator|+
name|ether_len
operator|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
decl_stmt|;
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|ip_version
operator|=
name|RNDIS_TCP_LARGE_SEND_OFFLOAD_IPV6
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|tcp_header_offset
operator|=
literal|0
expr_stmt|;
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|mss
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|pre_send
label|:
name|rndis_mesg
operator|->
name|msg_len
operator|=
name|packet
operator|->
name|tot_data_buf_len
operator|+
name|rndis_msg_size
expr_stmt|;
name|packet
operator|->
name|tot_data_buf_len
operator|=
name|rndis_mesg
operator|->
name|msg_len
expr_stmt|;
comment|/* send packet with send buffer */
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|<
name|net_dev
operator|->
name|send_section_size
condition|)
block|{
name|send_buf_section_idx
operator|=
name|hv_nv_get_next_send_section
argument_list|(
name|net_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_buf_section_idx
operator|!=
name|NVSP_1_CHIMNEY_SEND_INVALID_SECTION_INDEX
condition|)
block|{
name|char
modifier|*
name|dest
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|net_dev
operator|->
name|send_buf
operator|+
name|send_buf_section_idx
operator|*
name|net_dev
operator|->
name|send_section_size
operator|)
decl_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|rndis_mesg
argument_list|,
name|rndis_msg_size
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|rndis_msg_size
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
block|}
name|packet
operator|->
name|send_buf_section_idx
operator|=
name|send_buf_section_idx
expr_stmt|;
name|packet
operator|->
name|send_buf_section_size
operator|=
name|packet
operator|->
name|tot_data_buf_len
expr_stmt|;
name|packet
operator|->
name|page_buf_count
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_send
goto|;
block|}
block|}
comment|/* send packet with page buffer */
name|packet
operator|->
name|page_buffers
index|[
literal|0
index|]
operator|.
name|pfn
operator|=
name|atop
argument_list|(
name|hv_get_phys_addr
argument_list|(
name|rndis_mesg
argument_list|)
argument_list|)
expr_stmt|;
name|packet
operator|->
name|page_buffers
index|[
literal|0
index|]
operator|.
name|offset
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rndis_mesg
operator|&
name|PAGE_MASK
expr_stmt|;
name|packet
operator|->
name|page_buffers
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|rndis_msg_size
expr_stmt|;
comment|/* 		 * Fill the page buffers with mbuf info starting at index 		 * HV_RF_NUM_TX_RESERVED_PAGE_BUFS. 		 */
name|i
operator|=
name|HV_RF_NUM_TX_RESERVED_PAGE_BUFS
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
condition|)
block|{
name|vm_offset_t
name|paddr
init|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
decl_stmt|;
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|pfn
operator|=
name|paddr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|paddr
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|length
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|packet
operator|->
name|send_buf_section_idx
operator|=
name|NVSP_1_CHIMNEY_SEND_INVALID_SECTION_INDEX
expr_stmt|;
name|packet
operator|->
name|send_buf_section_size
operator|=
literal|0
expr_stmt|;
name|do_send
label|:
comment|/* 		 * If bpf, copy the mbuf chain.  This is less expensive than 		 * it appears; the mbuf clusters are not copied, only their 		 * reference counts are incremented. 		 * Needed to avoid a race condition where the completion 		 * callback is invoked, freeing the mbuf chain, before the 		 * bpf_mtap code has a chance to run. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|mc_head
operator|=
name|m_copypacket
argument_list|(
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|retry_send
label|:
comment|/* Set the completion routine */
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|on_send_completion
operator|=
name|netvsc_xmit_completion
expr_stmt|;
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_context
operator|=
name|packet
expr_stmt|;
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_tid
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|m_head
expr_stmt|;
comment|/* Removed critical_enter(), does not appear necessary */
name|ret
operator|=
name|hv_nv_on_send
argument_list|(
name|device_ctx
argument_list|,
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if bpf&& mc_head, call bpf_mtap code */
if|if
condition|(
name|mc_head
condition|)
block|{
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|mc_head
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|retries
operator|++
expr_stmt|;
if|if
condition|(
name|retries
operator|<
literal|4
condition|)
block|{
goto|goto
name|retry_send
goto|;
block|}
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* 			 * Null the mbuf pointer so the completion function 			 * does not free the mbuf chain.  We just pushed the 			 * mbuf chain back on the if_snd queue. 			 */
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_tid
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Release the resources since we will not get any 			 * send completion 			 */
name|netvsc_xmit_completion
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if bpf&& mc_head, free the mbuf chain copy */
if|if
condition|(
name|mc_head
condition|)
block|{
name|m_freem
argument_list|(
name|mc_head
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Link up/down notification  */
end_comment

begin_function
name|void
name|netvsc_linkstatus_callback
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device_obj
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_obj
operator|->
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Append the specified data to the indicated mbuf chain,  * Extend the mbuf chain if the new data does not fit in  * existing space.  *  * This is a minor rewrite of m_append() from sys/kern/uipc_mbuf.c.  * There should be an equivalent in the kernel mbuf code,  * but there does not appear to be one yet.  *  * Differs from m_append() in that additional mbufs are  * allocated with cluster size MJUMPAGESIZE, and filled  * accordingly.  *  * Return 1 if able to complete the job; otherwise 0.  */
end_comment

begin_function
specifier|static
name|int
name|hv_m_append
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|len
parameter_list|,
name|c_caddr_t
name|cp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|remainder
decl_stmt|,
name|space
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|remainder
operator|=
name|len
expr_stmt|;
name|space
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Copy into available space. 		 */
if|if
condition|(
name|space
operator|>
name|remainder
condition|)
name|space
operator|=
name|remainder
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|space
expr_stmt|;
name|cp
operator|+=
name|space
expr_stmt|;
name|remainder
operator|-=
name|space
expr_stmt|;
block|}
while|while
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Allocate a new mbuf; could check space 		 * and allocate a cluster instead. 		 */
name|n
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
literal|0
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
break|break;
name|n
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MJUMPAGESIZE
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|remainder
operator|-=
name|n
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
operator|-
name|remainder
expr_stmt|;
return|return
operator|(
name|remainder
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when we receive a data packet from the "wire" on the  * specified device  *  * Note:  This is no longer used as a callback  */
end_comment

begin_function
name|int
name|netvsc_recv
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device_ctx
parameter_list|,
name|netvsc_packet
modifier|*
name|packet
parameter_list|,
name|rndis_tcp_ip_csum_info
modifier|*
name|csum_info
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
operator|(
name|hn_softc_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|device_ctx
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|device_ctx
operator|->
name|device
decl_stmt|;
name|int
name|size
decl_stmt|,
name|do_lro
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* TODO: KYS how can this be! */
block|}
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Bail out if packet contains more data than configured MTU. 	 */
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|>
operator|(
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|<=
name|MHLEN
condition|)
block|{
name|m_new
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m_new
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|packet
operator|->
name|data
argument_list|,
name|packet
operator|->
name|tot_data_buf_len
argument_list|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m_new
operator|->
name|m_len
operator|=
name|packet
operator|->
name|tot_data_buf_len
expr_stmt|;
name|sc
operator|->
name|hn_small_pkts
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Get an mbuf with a cluster.  For packets 2K or less, 		 * get a standard 2K cluster.  For anything larger, get a 		 * 4K cluster.  Any buffers larger than 4K can cause problems 		 * if looped around to the Hyper-V TX channel, so avoid them. 		 */
name|size
operator|=
name|MCLBYTES
expr_stmt|;
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|>
name|MCLBYTES
condition|)
block|{
comment|/* 4096 */
name|size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
name|m_new
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"alloc mbuf failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hv_m_append
argument_list|(
name|m_new
argument_list|,
name|packet
operator|->
name|tot_data_buf_len
argument_list|,
name|packet
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|m_new
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* receive side checksum offload */
if|if
condition|(
name|NULL
operator|!=
name|csum_info
condition|)
block|{
comment|/* IP csum offload */
if|if
condition|(
name|csum_info
operator|->
name|receive
operator|.
name|ip_csum_succeeded
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
name|sc
operator|->
name|hn_csum_ip
operator|++
expr_stmt|;
block|}
comment|/* TCP csum offload */
if|if
condition|(
name|csum_info
operator|->
name|receive
operator|.
name|tcp_csum_succeeded
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|hn_csum_tcp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|csum_info
operator|->
name|receive
operator|.
name|ip_csum_succeeded
operator|&&
name|csum_info
operator|->
name|receive
operator|.
name|tcp_csum_succeeded
condition|)
name|do_lro
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|uint16_t
name|etype
decl_stmt|;
name|int
name|hoff
decl_stmt|;
name|hoff
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|->
name|m_len
operator|<
name|hoff
condition|)
goto|goto
name|skip
goto|;
name|eh
operator|=
name|mtod
argument_list|(
name|m_new
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
specifier|const
name|struct
name|ether_vlan_header
modifier|*
name|evl
decl_stmt|;
name|hoff
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|evl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|->
name|m_len
operator|<
name|hoff
condition|)
goto|goto
name|skip
goto|;
name|evl
operator|=
name|mtod
argument_list|(
name|m_new
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|evl
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_IP
condition|)
block|{
name|int
name|pr
decl_stmt|;
name|pr
operator|=
name|hn_check_iplen
argument_list|(
name|m_new
argument_list|,
name|hoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|hn_trust_hosttcp
condition|)
block|{
name|sc
operator|->
name|hn_csum_trusted
operator|++
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
comment|/* Rely on SW csum verification though... */
name|do_lro
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|skip
label|:
if|if
condition|(
operator|(
name|packet
operator|->
name|vlan_tci
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|packet
operator|->
name|vlan_tci
expr_stmt|;
name|m_new
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
comment|/* 	 * Note:  Moved RX completion back to hv_nv_on_receive() so all 	 * messages (not just data messages) will trigger a response. 	 */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|&&
name|do_lro
condition|)
block|{
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|sc
operator|->
name|hn_lro
decl_stmt|;
if|if
condition|(
name|lro
operator|->
name|lro_cnt
condition|)
block|{
name|sc
operator|->
name|hn_lro_tried
operator|++
expr_stmt|;
if|if
condition|(
name|tcp_lro_rx
argument_list|(
name|lro
argument_list|,
name|m_new
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* DONE! */
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* We're not holding the lock here, so don't release it */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|netvsc_recv_rollup
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device_ctx
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_ctx
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|sc
operator|->
name|hn_lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
while|while
condition|(
operator|(
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Rules for using sc->temp_unusable:  * 1.  sc->temp_unusable can only be read or written while holding NV_LOCK()  * 2.  code reading sc->temp_unusable under NV_LOCK(), and finding   *     sc->temp_unusable set, must release NV_LOCK() and exit  * 3.  to retain exclusive control of the interface,  *     sc->temp_unusable must be set by code before releasing NV_LOCK()  * 4.  only code setting sc->temp_unusable can clear sc->temp_unusable  * 5.  code setting sc->temp_unusable must eventually clear sc->temp_unusable  */
end_comment

begin_comment
comment|/*  * Standard ioctl entry point.  Called when the user wants to configure  * the interface.  */
end_comment

begin_function
specifier|static
name|int
name|hn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|netvsc_device_info
name|device_info
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|hn_dev
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|retry_cnt
init|=
literal|500
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|hn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|hn_dev
operator|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
expr_stmt|;
comment|/* Check MTU value change */
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|==
name|ifr
operator|->
name|ifr_mtu
condition|)
break|break;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|NETVSC_MAX_CONFIGURABLE_MTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Obtain and record requested MTU */
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
comment|/* 		 * Make sure that LRO high watermark is still valid, 		 * after MTU change (the 2*MTU limit). 		 */
if|if
condition|(
operator|!
name|HN_LRO_HIWAT_ISVALID
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_lro_hiwat
argument_list|)
condition|)
name|hn_set_lro_hiwat
argument_list|(
name|sc
argument_list|,
name|HN_LRO_HIWAT_MTULIM
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|retry_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
block|{
name|retry_cnt
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|retry_cnt
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* We must remove and add back the device to cause the new 		 * MTU to take effect.  This includes tearing down, but not 		 * deleting the channel, then bringing it back up. 		 */
name|error
operator|=
name|hv_rf_on_device_remove
argument_list|(
name|hn_dev
argument_list|,
name|HV_RF_NV_RETAIN_CHANNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|hv_rf_on_device_add
argument_list|(
name|hn_dev
argument_list|,
operator|&
name|device_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
do|do
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|retry_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
block|{
name|retry_cnt
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|retry_cnt
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * If only the state of the PROMISC flag changed, 			 * then just use the 'set promisc mode' command 			 * instead of reinitializing the entire NIC. Doing 			 * a full re-init means reloading the firmware and 			 * waiting for it to start up, which may take a 			 * second or two. 			 */
ifdef|#
directive|ifdef
name|notyet
comment|/* Fixme:  Promiscuous mode? */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|hn_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
comment|/* do something here for Hyper-V */
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|hn_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* do something here for Hyper-V */
block|}
else|else
endif|#
directive|endif
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|hn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
comment|/* 				 * Only enable UDP checksum offloading on 				 * Windows Server 2012R2 or later releases. 				 */
if|if
condition|(
name|hv_vmbus_protocal_version
operator|>=
name|HV_VMBUS_VERSION_WIN8_1
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TCP
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_RXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_RXCSUM
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
name|CSUM_IP_TSO
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
name|CSUM_IP6_TSO
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
ifdef|#
directive|ifdef
name|notyet
comment|/* Fixme:  Multicast mode? */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|netvsc_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_stop
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" Closing Device ...\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_initdone
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_rf_on_close
argument_list|(
name|device_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FreeBSD transmit entry point  */
end_comment

begin_function
specifier|static
name|void
name|hn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|hn_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_ifinit_locked
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
return|return;
block|}
name|hv_promisc_mode
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|hv_rf_on_open
argument_list|(
name|device_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
else|else
block|{
name|sc
operator|->
name|hn_initdone
operator|=
literal|1
expr_stmt|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LATER
end_ifdef

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|printf
argument_list|(
literal|"hn%d: watchdog timeout -- resetting\n"
argument_list|,
name|sc
operator|->
name|hn_unit
argument_list|)
expr_stmt|;
name|hn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*???*/
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HN_LRO_HIWAT
end_ifdef

begin_function
specifier|static
name|int
name|hn_lro_hiwat_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|hiwat
decl_stmt|,
name|error
decl_stmt|;
name|hiwat
operator|=
name|sc
operator|->
name|hn_lro_hiwat
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|hiwat
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|HN_LRO_HIWAT_ISVALID
argument_list|(
name|sc
argument_list|,
name|hiwat
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|sc
operator|->
name|hn_lro_hiwat
operator|!=
name|hiwat
condition|)
name|hn_set_lro_hiwat
argument_list|(
name|sc
argument_list|,
name|hiwat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HN_LRO_HIWAT */
end_comment

begin_function
specifier|static
name|int
name|hn_check_iplen
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hoff
parameter_list|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|,
name|iphlen
decl_stmt|,
name|iplen
decl_stmt|;
specifier|const
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|int
name|thoff
decl_stmt|;
comment|/* TCP data offset */
name|len
operator|=
name|hoff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
comment|/* The packet must be at least the size of an IP header. */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|len
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* The fixed IP header must reside completely in the first mbuf. */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len
condition|)
return|return
name|IPPROTO_DONE
return|;
name|ip
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hoff
argument_list|)
expr_stmt|;
comment|/* Bound check the packet's stated IP header length. */
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|iphlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
comment|/* minimum header length */
return|return
name|IPPROTO_DONE
return|;
comment|/* The full IP header must reside completely in the one mbuf. */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
condition|)
return|return
name|IPPROTO_DONE
return|;
name|iplen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers is as 	 * at least much as the IP header would have us expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|hoff
operator|+
name|iplen
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* 	 * Ignore IP fragments. 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|&
operator|(
name|IP_OFFMASK
operator||
name|IP_MF
operator|)
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* 	 * The TCP/IP or UDP/IP header must be entirely contained within 	 * the first fragment of a packet. 	 */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|iplen
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
name|th
operator|=
operator|(
specifier|const
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|thoff
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|thoff
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|||
name|thoff
operator|+
name|iphlen
operator|>
name|iplen
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
name|thoff
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|iplen
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
default|default:
if|if
condition|(
name|iplen
operator|<
name|iphlen
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
block|}
return|return
name|ip
operator|->
name|ip_p
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|netvsc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|netvsc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|netvsc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|netvsc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|netvsc_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|netvsc_driver
init|=
block|{
name|NETVSC_DEVNAME
block|,
name|netvsc_methods
block|,
expr|sizeof
operator|(
name|hn_softc_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|netvsc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hn
argument_list|,
name|vmbus
argument_list|,
name|netvsc_driver
argument_list|,
name|netvsc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|hn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hn
argument_list|,
name|vmbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netvsc_initx
argument_list|,
name|SI_SUB_KTHREAD_IDLE
argument_list|,
name|SI_ORDER_MIDDLE
operator|+
literal|1
argument_list|,
name|netvsc_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

