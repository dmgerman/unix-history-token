begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Citrix Inc.  * Copyright (c) 2009-2012 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2004-2006 Kip Macy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv.h>
end_include

begin_include
include|#
directive|include
file|"hv_net_vsc.h"
end_include

begin_include
include|#
directive|include
file|"hv_rndis.h"
end_include

begin_include
include|#
directive|include
file|"hv_rndis_filter.h"
end_include

begin_comment
comment|/* Short for Hyper-V network interface */
end_comment

begin_define
define|#
directive|define
name|NETVSC_DEVNAME
value|"hn"
end_define

begin_comment
comment|/*  * It looks like offset 0 of buf is reserved to hold the softc pointer.  * The sc pointer evidently not needed, and is not presently populated.  * The packet offset is where the netvsc_packet starts in the buffer.  */
end_comment

begin_define
define|#
directive|define
name|HV_NV_SC_PTR_OFFSET_IN_BUF
value|0
end_define

begin_define
define|#
directive|define
name|HV_NV_PACKET_OFFSET_IN_BUF
value|16
end_define

begin_comment
comment|/*  * Data types  */
end_comment

begin_struct
struct|struct
name|hv_netvsc_driver_context
block|{
name|uint32_t
name|drv_inited
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Be aware that this sleepable mutex will exhibit WITNESS errors when  * certain TCP and ARP code paths are taken.  This appears to be a  * well-known condition, as all other drivers checked use a sleeping  * mutex to protect their transmit paths.  * Also Be aware that mutexes do not play well with semaphores, and there  * is a conflicting semaphore in a certain channel code path.  */
end_comment

begin_define
define|#
directive|define
name|NV_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|mtx_init(&(_sc)->hn_lock, _name, MTX_NETWORK_LOCK, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|NV_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->hn_lock)
end_define

begin_define
define|#
directive|define
name|NV_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->hn_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|NV_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->hn_lock)
end_define

begin_define
define|#
directive|define
name|NV_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&(_sc)->hn_lock)
end_define

begin_comment
comment|/*  * Globals  */
end_comment

begin_decl_stmt
name|int
name|hv_promisc_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* normal mode by default */
end_comment

begin_comment
comment|/* The one and only one */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hv_netvsc_driver_context
name|g_netvsc_drv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|hn_stop
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifinit_locked
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * NetVsc driver initialization  * Note:  Filter init is no longer required  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_drv_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NetVsc global initialization entry point  */
end_comment

begin_function
specifier|static
name|void
name|netvsc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Netvsc initializing... "
argument_list|)
expr_stmt|;
comment|/* 	 * XXXKYS: cleanup initialization 	 */
if|if
condition|(
operator|!
name|cold
operator|&&
operator|!
name|g_netvsc_drv
operator|.
name|drv_inited
condition|)
block|{
name|g_netvsc_drv
operator|.
name|drv_inited
operator|=
literal|1
expr_stmt|;
name|netvsc_drv_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"done!\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Already initialized!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* {F8615163-DF3E-46c5-913F-F2D2F965ED0E} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|hv_guid
name|g_net_vsc_device_type
init|=
block|{
operator|.
name|data
operator|=
block|{
literal|0x63
block|,
literal|0x51
block|,
literal|0x61
block|,
literal|0xF8
block|,
literal|0x3E
block|,
literal|0xDF
block|,
literal|0xc5
block|,
literal|0x46
block|,
literal|0x91
block|,
literal|0x3F
block|,
literal|0xF2
block|,
literal|0xD2
block|,
literal|0xF9
block|,
literal|0x65
block|,
literal|0xED
block|,
literal|0x0E
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Standard probe entry point.  *  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|vmbus_get_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
operator|&
name|g_net_vsc_device_type
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_guid
argument_list|)
argument_list|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Synthetic Network Interface"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Netvsc probe... DONE \n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard attach entry point.  *  * Called when the driver is loaded.  It allocates needed resources,  * and initializes the "hardware" and software.  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|netvsc_device_info
name|device_info
decl_stmt|;
name|hn_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|netvsc_init
argument_list|()
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|hn_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|hn_dev
operator|=
name|dev
expr_stmt|;
name|NV_LOCK_INIT
argument_list|(
name|sc
argument_list|,
literal|"NetVSCLock"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_dev_obj
operator|=
name|device_ctx
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_dunit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_dname
operator|=
name|NETVSC_DEVNAME
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|hn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|hn_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|hn_ifinit
expr_stmt|;
comment|/* needed by hv_rf_on_device_add() code */
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
literal|511
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* 	 * Tell upper layers that we support full VLAN capability. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ret
operator|=
name|hv_rf_on_device_add
argument_list|(
name|device_ctx
argument_list|,
operator|&
name|device_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|device_info
operator|.
name|link_state
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|1
expr_stmt|;
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|device_info
operator|.
name|mac_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard detach entry point  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hv_device
modifier|*
name|hv_device
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"netvsc_detach\n"
argument_list|)
expr_stmt|;
comment|/* 	 * XXXKYS:  Need to clean up all our 	 * driver state; this is the driver 	 * unloading. 	 */
comment|/* 	 * XXXKYS:  Need to stop outgoing traffic and unregister 	 * the netdevice. 	 */
name|hv_rf_on_device_remove
argument_list|(
name|hv_device
argument_list|,
name|HV_RF_NV_DESTROY_CHANNEL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard shutdown entry point  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send completion processing  *  * Note:  It looks like offset 0 of buf is reserved to hold the softc  * pointer.  The sc pointer is not currently needed in this function, and  * it is not presently populated by the TX function.  */
end_comment

begin_function
name|void
name|netvsc_xmit_completion
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|netvsc_packet
modifier|*
name|packet
init|=
operator|(
name|netvsc_packet
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_tid
expr_stmt|;
name|buf
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|packet
operator|)
operator|-
name|HV_NV_PACKET_OFFSET_IN_BUF
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start a transmit of one or more packets  */
end_comment

begin_function
specifier|static
name|int
name|hn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|netvsc_packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc_head
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_frags
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|xlen
decl_stmt|;
name|int
name|rppi_size
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hn_ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|hn_ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|num_frags
operator|=
literal|0
expr_stmt|;
name|xlen
operator|=
literal|0
expr_stmt|;
comment|/* Walk the mbuf list computing total length and num frags */
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
name|num_frags
operator|++
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
block|}
comment|/* 		 * Reserve the number of pages requested.  Currently, 		 * one page is reserved for the message in the RNDIS 		 * filter packet 		 */
name|num_frags
operator|+=
name|HV_RF_NUM_TX_RESERVED_PAGE_BUFS
expr_stmt|;
comment|/* If exceeds # page_buffers in netvsc_packet */
if|if
condition|(
name|num_frags
operator|>
name|NETVSC_PACKET_MAXPAGE
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|rppi_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|rppi_size
operator|=
sizeof|sizeof
argument_list|(
name|rndis_per_packet_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ndis_8021q_info
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Allocate a buffer with space for a netvsc packet plus a 		 * number of reserved areas.  First comes a (currently 16 		 * bytes, currently unused) reserved data area.  Second is 		 * the netvsc_packet, which includes (currently 4) page 		 * buffers.  Third (optional) is a rndis_per_packet_info 		 * struct, but only if a VLAN tag should be inserted into the 		 * Ethernet frame by the Hyper-V infrastructure.  Fourth is 		 * an area reserved for an rndis_filter_packet struct. 		 * Changed malloc to M_NOWAIT to avoid sleep under spin lock. 		 * No longer reserving extra space for page buffers, as they 		 * are already part of the netvsc_packet. 		 */
name|buf
operator|=
name|malloc
argument_list|(
name|HV_NV_PACKET_OFFSET_IN_BUF
operator|+
sizeof|sizeof
argument_list|(
name|netvsc_packet
argument_list|)
operator|+
name|rppi_size
operator|+
sizeof|sizeof
argument_list|(
name|rndis_filter_packet
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|packet
operator|=
operator|(
name|netvsc_packet
operator|*
operator|)
operator|(
name|buf
operator|+
name|HV_NV_PACKET_OFFSET_IN_BUF
operator|)
expr_stmt|;
operator|*
operator|(
name|vm_offset_t
operator|*
operator|)
name|buf
operator|=
name|HV_NV_SC_PTR_OFFSET_IN_BUF
expr_stmt|;
comment|/* 		 * extension points to the area reserved for the 		 * rndis_filter_packet, which is placed just after 		 * the netvsc_packet (and rppi struct, if present; 		 * length is updated later). 		 */
name|packet
operator|->
name|extension
operator|=
name|packet
operator|+
literal|1
expr_stmt|;
comment|/* Set up the rndis header */
name|packet
operator|->
name|page_buf_count
operator|=
name|num_frags
expr_stmt|;
comment|/* Initialize it from the mbuf */
name|packet
operator|->
name|tot_data_buf_len
operator|=
name|len
expr_stmt|;
comment|/* 		 * If the Hyper-V infrastructure needs to embed a VLAN tag, 		 * initialize netvsc_packet and rppi struct values as needed. 		 */
if|if
condition|(
name|rppi_size
condition|)
block|{
comment|/* Lower layers need the VLAN TCI */
name|packet
operator|->
name|vlan_tci
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
expr_stmt|;
block|}
comment|/* 		 * Fill the page buffers with mbuf info starting at index 		 * HV_RF_NUM_TX_RESERVED_PAGE_BUFS. 		 */
name|i
operator|=
name|HV_RF_NUM_TX_RESERVED_PAGE_BUFS
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
condition|)
block|{
name|vm_offset_t
name|paddr
init|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
decl_stmt|;
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|pfn
operator|=
name|paddr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|paddr
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|length
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * If bpf, copy the mbuf chain.  This is less expensive than 		 * it appears; the mbuf clusters are not copied, only their 		 * reference counts are incremented. 		 * Needed to avoid a race condition where the completion 		 * callback is invoked, freeing the mbuf chain, before the 		 * bpf_mtap code has a chance to run. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|mc_head
operator|=
name|m_copypacket
argument_list|(
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|retry_send
label|:
comment|/* Set the completion routine */
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|on_send_completion
operator|=
name|netvsc_xmit_completion
expr_stmt|;
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_context
operator|=
name|packet
expr_stmt|;
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_tid
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|m_head
expr_stmt|;
comment|/* Removed critical_enter(), does not appear necessary */
name|ret
operator|=
name|hv_rf_on_send
argument_list|(
name|device_ctx
argument_list|,
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if bpf&& mc_head, call bpf_mtap code */
if|if
condition|(
name|mc_head
condition|)
block|{
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|mc_head
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|retries
operator|++
expr_stmt|;
if|if
condition|(
name|retries
operator|<
literal|4
condition|)
block|{
goto|goto
name|retry_send
goto|;
block|}
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* 			 * Null the mbuf pointer so the completion function 			 * does not free the mbuf chain.  We just pushed the 			 * mbuf chain back on the if_snd queue. 			 */
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_tid
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Release the resources since we will not get any 			 * send completion 			 */
name|netvsc_xmit_completion
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
comment|/* if bpf&& mc_head, free the mbuf chain copy */
if|if
condition|(
name|mc_head
condition|)
block|{
name|m_freem
argument_list|(
name|mc_head
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Link up/down notification  */
end_comment

begin_function
name|void
name|netvsc_linkstatus_callback
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device_obj
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_obj
operator|->
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Append the specified data to the indicated mbuf chain,  * Extend the mbuf chain if the new data does not fit in  * existing space.  *  * This is a minor rewrite of m_append() from sys/kern/uipc_mbuf.c.  * There should be an equivalent in the kernel mbuf code,  * but there does not appear to be one yet.  *  * Differs from m_append() in that additional mbufs are  * allocated with cluster size MJUMPAGESIZE, and filled  * accordingly.  *  * Return 1 if able to complete the job; otherwise 0.  */
end_comment

begin_function
specifier|static
name|int
name|hv_m_append
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|len
parameter_list|,
name|c_caddr_t
name|cp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|remainder
decl_stmt|,
name|space
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|remainder
operator|=
name|len
expr_stmt|;
name|space
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Copy into available space. 		 */
if|if
condition|(
name|space
operator|>
name|remainder
condition|)
name|space
operator|=
name|remainder
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|space
expr_stmt|;
name|cp
operator|+=
name|space
expr_stmt|;
name|remainder
operator|-=
name|space
expr_stmt|;
block|}
while|while
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Allocate a new mbuf; could check space 		 * and allocate a cluster instead. 		 */
name|n
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
literal|0
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
break|break;
name|n
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MJUMPAGESIZE
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|remainder
operator|-=
name|n
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
operator|-
name|remainder
expr_stmt|;
return|return
operator|(
name|remainder
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when we receive a data packet from the "wire" on the  * specified device  *  * Note:  This is no longer used as a callback  */
end_comment

begin_function
name|int
name|netvsc_recv
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device_ctx
parameter_list|,
name|netvsc_packet
modifier|*
name|packet
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
operator|(
name|hn_softc_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|device_ctx
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* TODO: KYS how can this be! */
block|}
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Bail out if packet contains more data than configured MTU. 	 */
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|>
operator|(
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Get an mbuf with a cluster.  For packets 2K or less, 	 * get a standard 2K cluster.  For anything larger, get a 	 * 4K cluster.  Any buffers larger than 4K can cause problems 	 * if looped around to the Hyper-V TX channel, so avoid them. 	 */
name|size
operator|=
name|MCLBYTES
expr_stmt|;
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|>
name|MCLBYTES
condition|)
block|{
comment|/* 4096 */
name|size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
name|m_new
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Remove trailing junk from RX data buffer. 	 * Fixme:  This will not work for multiple Hyper-V RX buffers. 	 * Fortunately, the channel gathers all RX data into one buffer. 	 * 	 * L2 frame length, with L2 header, not including CRC 	 */
name|packet
operator|->
name|page_buffers
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|packet
operator|->
name|tot_data_buf_len
expr_stmt|;
comment|/* 	 * Copy the received packet to one or more mbufs.  	 * The copy is required since the memory pointed to by netvsc_packet 	 * cannot be deallocated 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|packet
operator|->
name|page_buf_count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Shift virtual page number to form virtual page address */
name|uint8_t
modifier|*
name|vaddr
init|=
operator|(
name|uint8_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|pfn
operator|<<
name|PAGE_SHIFT
argument_list|)
decl_stmt|;
name|hv_m_append
argument_list|(
name|m_new
argument_list|,
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|length
argument_list|,
name|vaddr
operator|+
name|packet
operator|->
name|page_buffers
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
name|m_new
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|packet
operator|->
name|vlan_tci
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|packet
operator|->
name|vlan_tci
expr_stmt|;
name|m_new
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
comment|/* 	 * Note:  Moved RX completion back to hv_nv_on_receive() so all 	 * messages (not just data messages) will trigger a response. 	 */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We're not holding the lock here, so don't release it */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rules for using sc->temp_unusable:  * 1.  sc->temp_unusable can only be read or written while holding NV_LOCK()  * 2.  code reading sc->temp_unusable under NV_LOCK(), and finding   *     sc->temp_unusable set, must release NV_LOCK() and exit  * 3.  to retain exclusive control of the interface,  *     sc->temp_unusable must be set by code before releasing NV_LOCK()  * 4.  only code setting sc->temp_unusable can clear sc->temp_unusable  * 5.  code setting sc->temp_unusable must eventually clear sc->temp_unusable  */
end_comment

begin_comment
comment|/*  * Standard ioctl entry point.  Called when the user wants to configure  * the interface.  */
end_comment

begin_function
specifier|static
name|int
name|hn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|netvsc_device_info
name|device_info
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|hn_dev
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|retry_cnt
init|=
literal|500
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|hn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|hn_dev
operator|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
expr_stmt|;
comment|/* Check MTU value change */
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|==
name|ifr
operator|->
name|ifr_mtu
condition|)
break|break;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|NETVSC_MAX_CONFIGURABLE_MTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Obtain and record requested MTU */
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
do|do
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|retry_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
block|{
name|retry_cnt
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|retry_cnt
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* We must remove and add back the device to cause the new 		 * MTU to take effect.  This includes tearing down, but not 		 * deleting the channel, then bringing it back up. 		 */
name|error
operator|=
name|hv_rf_on_device_remove
argument_list|(
name|hn_dev
argument_list|,
name|HV_RF_NV_RETAIN_CHANNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|hv_rf_on_device_add
argument_list|(
name|hn_dev
argument_list|,
operator|&
name|device_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
do|do
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|retry_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
block|{
name|retry_cnt
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|retry_cnt
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * If only the state of the PROMISC flag changed, 			 * then just use the 'set promisc mode' command 			 * instead of reinitializing the entire NIC. Doing 			 * a full re-init means reloading the firmware and 			 * waiting for it to start up, which may take a 			 * second or two. 			 */
ifdef|#
directive|ifdef
name|notyet
comment|/* Fixme:  Promiscuous mode? */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|hn_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
comment|/* do something here for Hyper-V */
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|hn_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* do something here for Hyper-V */
block|}
else|else
endif|#
directive|endif
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|hn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_HWCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_HWCSUM
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
ifdef|#
directive|ifdef
name|notyet
comment|/* Fixme:  Multicast mode? */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|netvsc_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_stop
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" Closing Device ...\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_initdone
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_rf_on_close
argument_list|(
name|device_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FreeBSD transmit entry point  */
end_comment

begin_function
specifier|static
name|void
name|hn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|hn_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_ifinit_locked
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
return|return;
block|}
name|hv_promisc_mode
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|hv_rf_on_open
argument_list|(
name|device_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
else|else
block|{
name|sc
operator|->
name|hn_initdone
operator|=
literal|1
expr_stmt|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LATER
end_ifdef

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|printf
argument_list|(
literal|"hn%d: watchdog timeout -- resetting\n"
argument_list|,
name|sc
operator|->
name|hn_unit
argument_list|)
expr_stmt|;
name|hn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*???*/
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|device_method_t
name|netvsc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|netvsc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|netvsc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|netvsc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|netvsc_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|netvsc_driver
init|=
block|{
name|NETVSC_DEVNAME
block|,
name|netvsc_methods
block|,
expr|sizeof
operator|(
name|hn_softc_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|netvsc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hn
argument_list|,
name|vmbus
argument_list|,
name|netvsc_driver
argument_list|,
name|netvsc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|hn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hn
argument_list|,
name|vmbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netvsc_initx
argument_list|,
name|SI_SUB_KTHREAD_IDLE
argument_list|,
name|SI_ORDER_MIDDLE
operator|+
literal|1
argument_list|,
name|netvsc_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

