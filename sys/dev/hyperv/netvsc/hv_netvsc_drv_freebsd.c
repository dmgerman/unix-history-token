begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Citrix Inc.  * Copyright (c) 2009-2012 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2004-2006 Kip Macy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf_ring.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv.h>
end_include

begin_include
include|#
directive|include
file|"hv_net_vsc.h"
end_include

begin_include
include|#
directive|include
file|"hv_rndis.h"
end_include

begin_include
include|#
directive|include
file|"hv_rndis_filter.h"
end_include

begin_comment
comment|/* Short for Hyper-V network interface */
end_comment

begin_define
define|#
directive|define
name|NETVSC_DEVNAME
value|"hn"
end_define

begin_comment
comment|/*  * It looks like offset 0 of buf is reserved to hold the softc pointer.  * The sc pointer evidently not needed, and is not presently populated.  * The packet offset is where the netvsc_packet starts in the buffer.  */
end_comment

begin_define
define|#
directive|define
name|HV_NV_SC_PTR_OFFSET_IN_BUF
value|0
end_define

begin_define
define|#
directive|define
name|HV_NV_PACKET_OFFSET_IN_BUF
value|16
end_define

begin_comment
comment|/* YYY should get it from the underlying channel */
end_comment

begin_define
define|#
directive|define
name|HN_TX_DESC_CNT
value|512
end_define

begin_define
define|#
directive|define
name|HN_LROENT_CNT_DEF
value|128
end_define

begin_define
define|#
directive|define
name|HN_RNDIS_MSG_LEN
define|\
value|(sizeof(rndis_msg) +		\      RNDIS_VLAN_PPI_SIZE +		\      RNDIS_TSO_PPI_SIZE +		\      RNDIS_CSUM_PPI_SIZE)
end_define

begin_define
define|#
directive|define
name|HN_RNDIS_MSG_BOUNDARY
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|HN_RNDIS_MSG_ALIGN
value|CACHE_LINE_SIZE
end_define

begin_define
define|#
directive|define
name|HN_TX_DATA_BOUNDARY
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|HN_TX_DATA_MAXSIZE
value|IP_MAXPACKET
end_define

begin_define
define|#
directive|define
name|HN_TX_DATA_SEGSIZE
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|HN_TX_DATA_SEGCNT_MAX
define|\
value|(NETVSC_PACKET_MAXPAGE - HV_RF_NUM_TX_RESERVED_PAGE_BUFS)
end_define

begin_define
define|#
directive|define
name|HN_DIRECT_TX_SIZE_DEF
value|128
end_define

begin_struct
struct|struct
name|hn_txdesc
block|{
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|SLIST_ENTRY
argument_list|(
argument|hn_txdesc
argument_list|)
name|link
expr_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|refs
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
comment|/* HN_TXD_FLAG_ */
name|netvsc_packet
name|netvsc_pkt
decl_stmt|;
comment|/* XXX to be removed */
name|bus_dmamap_t
name|data_dmap
decl_stmt|;
name|bus_addr_t
name|rndis_msg_paddr
decl_stmt|;
name|rndis_msg
modifier|*
name|rndis_msg
decl_stmt|;
name|bus_dmamap_t
name|rndis_msg_dmap
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HN_TXD_FLAG_ONLIST
value|0x1
end_define

begin_define
define|#
directive|define
name|HN_TXD_FLAG_DMAMAP
value|0x2
end_define

begin_comment
comment|/*  * Only enable UDP checksum offloading when it is on 2012R2 or  * later.  UDP checksum offloading doesn't work on earlier  * Windows releases.  */
end_comment

begin_define
define|#
directive|define
name|HN_CSUM_ASSIST_WIN8
value|(CSUM_IP | CSUM_TCP)
end_define

begin_define
define|#
directive|define
name|HN_CSUM_ASSIST
value|(CSUM_IP | CSUM_UDP | CSUM_TCP)
end_define

begin_define
define|#
directive|define
name|HN_LRO_LENLIM_DEF
value|(25 * ETHERMTU)
end_define

begin_comment
comment|/* YYY 2*MTU is a bit rough, but should be good enough. */
end_comment

begin_define
define|#
directive|define
name|HN_LRO_LENLIM_MIN
parameter_list|(
name|ifp
parameter_list|)
value|(2 * (ifp)->if_mtu)
end_define

begin_define
define|#
directive|define
name|HN_LRO_ACKCNT_DEF
value|1
end_define

begin_comment
comment|/*  * Be aware that this sleepable mutex will exhibit WITNESS errors when  * certain TCP and ARP code paths are taken.  This appears to be a  * well-known condition, as all other drivers checked use a sleeping  * mutex to protect their transmit paths.  * Also Be aware that mutexes do not play well with semaphores, and there  * is a conflicting semaphore in a certain channel code path.  */
end_comment

begin_define
define|#
directive|define
name|NV_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|mtx_init(&(_sc)->hn_lock, _name, MTX_NETWORK_LOCK, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|NV_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->hn_lock)
end_define

begin_define
define|#
directive|define
name|NV_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->hn_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|NV_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->hn_lock)
end_define

begin_define
define|#
directive|define
name|NV_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&(_sc)->hn_lock)
end_define

begin_comment
comment|/*  * Globals  */
end_comment

begin_decl_stmt
name|int
name|hv_promisc_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* normal mode by default */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|hn
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Hyper-V network interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Trust tcp segements verification on host side. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_trust_hosttcp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|trust_hosttcp
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_trust_hosttcp
argument_list|,
literal|0
argument_list|,
literal|"Trust tcp segement verification on host side, "
literal|"when csum info is missing (global setting)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Trust udp datagrams verification on host side. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_trust_hostudp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|trust_hostudp
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_trust_hostudp
argument_list|,
literal|0
argument_list|,
literal|"Trust udp datagram verification on host side, "
literal|"when csum info is missing (global setting)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Trust ip packets verification on host side. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_trust_hostip
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|trust_hostip
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_trust_hostip
argument_list|,
literal|0
argument_list|,
literal|"Trust ip packet verification on host side, "
literal|"when csum info is missing (global setting)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100045
end_if

begin_comment
comment|/* Limit TSO burst size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_tso_maxlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tso_maxlen
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tso_maxlen
argument_list|,
literal|0
argument_list|,
literal|"TSO burst limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Limit chimney send size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_tx_chimney_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_chimney_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_tx_chimney_size
argument_list|,
literal|0
argument_list|,
literal|"Chimney send packet size limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Limit the size of packet for direct transmission */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hn_direct_tx_size
init|=
name|HN_DIRECT_TX_SIZE_DEF
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|direct_tx_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_direct_tx_size
argument_list|,
literal|0
argument_list|,
literal|"Size of the packet for direct transmission"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
end_if

begin_decl_stmt
specifier|static
name|int
name|hn_lro_entry_count
init|=
name|HN_LROENT_CNT_DEF
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|lro_entry_count
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_lro_entry_count
argument_list|,
literal|0
argument_list|,
literal|"LRO entry count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|hn_share_tx_taskq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|share_tx_taskq
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_share_tx_taskq
argument_list|,
literal|0
argument_list|,
literal|"Enable shared TX taskqueue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|taskqueue
modifier|*
name|hn_tx_taskq
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|hn_use_txdesc_bufring
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|hn_use_txdesc_bufring
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|use_txdesc_bufring
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|hn_use_txdesc_bufring
argument_list|,
literal|0
argument_list|,
literal|"Use buf_ring for TX descriptors"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|hn_bind_tx_taskq
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|bind_tx_taskq
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_bind_tx_taskq
argument_list|,
literal|0
argument_list|,
literal|"Bind TX taskqueue to the specified cpu"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|hn_use_if_start
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hn
argument_list|,
name|OID_AUTO
argument_list|,
name|use_if_start
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hn_use_if_start
argument_list|,
literal|0
argument_list|,
literal|"Use if_start TX method"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Forward declarations  */
end_comment

begin_function_decl
specifier|static
name|void
name|hn_stop
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifinit_locked
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_start_locked
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_lro_lenlim_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_lro_ackcnt_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_trust_hcsum_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_tx_chimney_size_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_rx_stat_ulong_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_rx_stat_u64_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_tx_stat_ulong_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_tx_conf_int_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_check_iplen
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_create_tx_ring
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_destroy_tx_ring
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_create_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_destroy_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_start_txeof_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_stop_tx_tasks
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_encap
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_create_rx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_destroy_rx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_set_tx_chimney_size
parameter_list|(
name|struct
name|hn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_xmit_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hn_xmit
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_xmit_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_xmit_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hn_xmit_txeof_taskfunc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|hn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|hn_carrier
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
operator||
name|IFM_FDX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* {F8615163-DF3E-46c5-913F-F2D2F965ED0E} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|hv_guid
name|g_net_vsc_device_type
init|=
block|{
operator|.
name|data
operator|=
block|{
literal|0x63
block|,
literal|0x51
block|,
literal|0x61
block|,
literal|0xF8
block|,
literal|0x3E
block|,
literal|0xDF
block|,
literal|0xc5
block|,
literal|0x46
block|,
literal|0x91
block|,
literal|0x3F
block|,
literal|0xF2
block|,
literal|0xD2
block|,
literal|0xF9
block|,
literal|0x65
block|,
literal|0xED
block|,
literal|0x0E
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Standard probe entry point.  *  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|vmbus_get_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
operator|&
name|g_net_vsc_device_type
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_guid
argument_list|)
argument_list|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Synthetic Network Interface"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Netvsc probe... DONE \n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard attach entry point.  *  * Called when the driver is loaded.  It allocates needed resources,  * and initializes the "hardware" and software.  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|netvsc_device_info
name|device_info
decl_stmt|;
name|hn_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100045
name|int
name|tso_maxlen
decl_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|hn_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|hn_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|hn_tx_taskq
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|hn_tx_taskq
operator|=
name|taskqueue_create
argument_list|(
literal|"hn_tx"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|hn_tx_taskq
argument_list|)
expr_stmt|;
if|if
condition|(
name|hn_bind_tx_taskq
operator|>=
literal|0
condition|)
block|{
name|int
name|cpu
init|=
name|hn_bind_tx_taskq
decl_stmt|;
name|cpuset_t
name|cpu_set
decl_stmt|;
if|if
condition|(
name|cpu
operator|>
name|mp_ncpus
operator|-
literal|1
condition|)
name|cpu
operator|=
name|mp_ncpus
operator|-
literal|1
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|cpu
argument_list|,
operator|&
name|cpu_set
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|sc
operator|->
name|hn_tx_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_set
argument_list|,
literal|"%s tx"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|hn_tx_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s tx"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|hn_tx_taskq
operator|=
name|hn_tx_taskq
expr_stmt|;
block|}
name|NV_LOCK_INIT
argument_list|(
name|sc
argument_list|,
literal|"NetVSCLock"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_dev_obj
operator|=
name|device_ctx
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|error
operator|=
name|hn_create_tx_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|hn_create_rx_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_dunit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_dname
operator|=
name|NETVSC_DEVNAME
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|hn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|hn_ifinit
expr_stmt|;
comment|/* needed by hv_rf_on_device_add() code */
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
if|if
condition|(
name|hn_use_if_start
condition|)
block|{
name|ifp
operator|->
name|if_start
operator|=
name|hn_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
literal|511
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_transmit
operator|=
name|hn_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|hn_xmit_qflush
expr_stmt|;
block|}
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
literal|0
argument_list|,
name|hn_ifmedia_upd
argument_list|,
name|hn_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* XXX ifmedia_set really should do this for us */
name|sc
operator|->
name|hn_media
operator|.
name|ifm_media
operator|=
name|sc
operator|->
name|hn_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
comment|/* 	 * Tell upper layers that we support full VLAN capability. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO
operator||
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO
operator||
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_csum_assist
operator||
name|CSUM_TSO
expr_stmt|;
name|error
operator|=
name|hv_rf_on_device_add
argument_list|(
name|device_ctx
argument_list|,
operator|&
name|device_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|device_info
operator|.
name|link_state
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100045
name|tso_maxlen
operator|=
name|hn_tso_maxlen
expr_stmt|;
if|if
condition|(
name|tso_maxlen
operator|<=
literal|0
operator|||
name|tso_maxlen
operator|>
name|IP_MAXPACKET
condition|)
name|tso_maxlen
operator|=
name|IP_MAXPACKET
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|HN_TX_DATA_SEGCNT_MAX
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomax
operator|=
name|tso_maxlen
operator|-
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
endif|#
directive|endif
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|device_info
operator|.
name|mac_addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100045
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO: %u/%u/%u\n"
argument_list|,
name|ifp
operator|->
name|if_hw_tsomax
argument_list|,
name|ifp
operator|->
name|if_hw_tsomaxsegcount
argument_list|,
name|ifp
operator|->
name|if_hw_tsomaxsegsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|hn_tx_chimney_max
operator|=
name|sc
operator|->
name|net_dev
operator|->
name|send_section_size
expr_stmt|;
name|hn_set_tx_chimney_size
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_tx_chimney_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|hn_tx_chimney_size
operator|>
literal|0
operator|&&
name|hn_tx_chimney_size
operator|<
name|sc
operator|->
name|hn_tx_chimney_max
condition|)
name|hn_set_tx_chimney_size
argument_list|(
name|sc
argument_list|,
name|hn_tx_chimney_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|hn_destroy_tx_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard detach entry point  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|hv_device
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"netvsc_detach\n"
argument_list|)
expr_stmt|;
comment|/* 	 * XXXKYS:  Need to clean up all our 	 * driver state; this is the driver 	 * unloading. 	 */
comment|/* 	 * XXXKYS:  Need to stop outgoing traffic and unregister 	 * the netdevice. 	 */
name|hv_rf_on_device_remove
argument_list|(
name|hv_device
argument_list|,
name|HV_RF_NV_DESTROY_CHANNEL
argument_list|)
expr_stmt|;
name|hn_stop_tx_tasks
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|hn_media
argument_list|)
expr_stmt|;
name|hn_destroy_rx_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_destroy_tx_data
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_tx_taskq
operator|!=
name|hn_tx_taskq
condition|)
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|hn_tx_taskq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Standard shutdown entry point  */
end_comment

begin_function
specifier|static
name|int
name|netvsc_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hn_txdesc_dmamap_load
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m_head
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|m_new
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|HN_TX_DATA_SEGCNT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
else|else
operator|*
name|m_head
operator|=
name|m
operator|=
name|m_new
expr_stmt|;
name|txr
operator|->
name|hn_tx_collapsed
operator|++
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|txd
operator|->
name|flags
operator||=
name|HN_TXD_FLAG_DMAMAP
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|hn_txdesc_dmamap_unload
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
if|if
condition|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_DMAMAP
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
name|txd
operator|->
name|flags
operator|&=
operator|~
name|HN_TXD_FLAG_DMAMAP
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hn_txdesc_put
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONLIST
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"put an onlist txd %#x"
operator|,
name|txd
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|refs
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid txd refs %d"
operator|,
name|txd
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|txd
operator|->
name|refs
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|hn_txdesc_dmamap_unload
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txd
operator|->
name|m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|txd
operator|->
name|flags
operator||=
name|HN_TXD_FLAG_ONLIST
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_lock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_txdesc_avail
operator|>=
literal|0
operator|&&
name|txr
operator|->
name|hn_txdesc_avail
operator|<
name|txr
operator|->
name|hn_txdesc_cnt
argument_list|,
operator|(
literal|"txdesc_put: invalid txd avail %d"
operator|,
name|txr
operator|->
name|hn_txdesc_avail
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdesc_avail
operator|++
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|,
name|txd
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
else|#
directive|else
name|atomic_add_int
argument_list|(
operator|&
name|txr
operator|->
name|hn_txdesc_avail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_ring_enqueue
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|,
name|txd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|hn_txdesc
operator|*
name|hn_txdesc_get
argument_list|(
argument|struct hn_tx_ring *txr
argument_list|)
block|{ 	struct
name|hn_txdesc
operator|*
name|txd
block|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_lock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
block|;
name|txd
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|)
block|;
if|if
condition|(
name|txd
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|txr
operator|->
name|hn_txdesc_avail
operator|>
literal|0
argument_list|,
operator|(
literal|"txdesc_get: invalid txd avail %d"
operator|,
name|txr
operator|->
name|hn_txdesc_avail
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdesc_avail
operator|--
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|txd
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|txd
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HN_USE_TXDESC_BUFRING
name|atomic_subtract_int
argument_list|(
operator|&
name|txr
operator|->
name|hn_txdesc_avail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|txd
operator|->
name|m
operator|==
name|NULL
operator|&&
name|txd
operator|->
name|refs
operator|==
literal|0
operator|&&
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_ONLIST
operator|)
argument_list|,
operator|(
literal|"invalid txd"
operator|)
argument_list|)
expr_stmt|;
name|txd
operator|->
name|flags
operator|&=
operator|~
name|HN_TXD_FLAG_ONLIST
expr_stmt|;
name|txd
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_return
return|return
name|txd
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|hn_txdesc_hold
parameter_list|(
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
comment|/* 0->1 transition will never work */
name|KASSERT
argument_list|(
name|txd
operator|->
name|refs
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid refs %d"
operator|,
name|txd
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|txd
operator|->
name|refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_tx_done
parameter_list|(
name|void
modifier|*
name|xpkt
parameter_list|)
block|{
name|netvsc_packet
modifier|*
name|packet
init|=
name|xpkt
decl_stmt|;
name|struct
name|hn_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|txd
operator|=
operator|(
expr|struct
name|hn_txdesc
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_tid
expr_stmt|;
name|txr
operator|=
name|txd
operator|->
name|txr
expr_stmt|;
name|txr
operator|->
name|hn_has_txeof
operator|=
literal|1
expr_stmt|;
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|netvsc_channel_rollup
parameter_list|(
name|struct
name|hv_vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|chan
operator|->
name|device
decl_stmt|;
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_ctx
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
decl_stmt|;
comment|/* TODO: vRSS */
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
decl_stmt|;
comment|/* TODO: vRSS */
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|hn_lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
while|while
condition|(
operator|(
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|txr
operator|->
name|hn_has_txeof
condition|)
return|return;
name|txr
operator|->
name|hn_has_txeof
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NOTE:  * If this function fails, then both txd and m_head0 will be freed.  */
end_comment

begin_function
specifier|static
name|int
name|hn_encap
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head0
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
name|HN_TX_DATA_SEGCNT_MAX
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
init|=
operator|*
name|m_head0
decl_stmt|;
name|netvsc_packet
modifier|*
name|packet
decl_stmt|;
name|rndis_msg
modifier|*
name|rndis_mesg
decl_stmt|;
name|rndis_packet
modifier|*
name|rndis_pkt
decl_stmt|;
name|rndis_per_packet_info
modifier|*
name|rppi
decl_stmt|;
name|uint32_t
name|rndis_msg_size
decl_stmt|;
name|packet
operator|=
operator|&
name|txd
operator|->
name|netvsc_pkt
expr_stmt|;
name|packet
operator|->
name|is_data_pkt
operator|=
name|TRUE
expr_stmt|;
name|packet
operator|->
name|tot_data_buf_len
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * extension points to the area reserved for the 	 * rndis_filter_packet, which is placed just after 	 * the netvsc_packet (and rppi struct, if present; 	 * length is updated later). 	 */
name|rndis_mesg
operator|=
name|txd
operator|->
name|rndis_msg
expr_stmt|;
comment|/* XXX not necessary */
name|memset
argument_list|(
name|rndis_mesg
argument_list|,
literal|0
argument_list|,
name|HN_RNDIS_MSG_LEN
argument_list|)
expr_stmt|;
name|rndis_mesg
operator|->
name|ndis_msg_type
operator|=
name|REMOTE_NDIS_PACKET_MSG
expr_stmt|;
name|rndis_pkt
operator|=
operator|&
name|rndis_mesg
operator|->
name|msg
operator|.
name|packet
expr_stmt|;
name|rndis_pkt
operator|->
name|data_offset
operator|=
sizeof|sizeof
argument_list|(
name|rndis_packet
argument_list|)
expr_stmt|;
name|rndis_pkt
operator|->
name|data_length
operator|=
name|packet
operator|->
name|tot_data_buf_len
expr_stmt|;
name|rndis_pkt
operator|->
name|per_pkt_info_offset
operator|=
sizeof|sizeof
argument_list|(
name|rndis_packet
argument_list|)
expr_stmt|;
name|rndis_msg_size
operator|=
name|RNDIS_MESSAGE_SIZE
argument_list|(
name|rndis_packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|ndis_8021q_info
modifier|*
name|rppi_vlan_info
decl_stmt|;
name|rndis_msg_size
operator|+=
name|RNDIS_VLAN_PPI_SIZE
expr_stmt|;
name|rppi
operator|=
name|hv_set_rppi_data
argument_list|(
name|rndis_mesg
argument_list|,
name|RNDIS_VLAN_PPI_SIZE
argument_list|,
name|ieee_8021q_info
argument_list|)
expr_stmt|;
name|rppi_vlan_info
operator|=
operator|(
name|ndis_8021q_info
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rppi
operator|+
name|rppi
operator|->
name|per_packet_info_offset
operator|)
expr_stmt|;
name|rppi_vlan_info
operator|->
name|u1
operator|.
name|s1
operator|.
name|vlan_id
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|&
literal|0xfff
expr_stmt|;
block|}
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|rndis_tcp_tso_info
modifier|*
name|tso_info
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|int
name|ether_len
decl_stmt|;
comment|/* 		 * XXX need m_pullup and use mtodo 		 */
name|eh
operator|=
name|mtod
argument_list|(
name|m_head
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
name|ether_len
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
else|else
name|ether_len
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|rndis_msg_size
operator|+=
name|RNDIS_TSO_PPI_SIZE
expr_stmt|;
name|rppi
operator|=
name|hv_set_rppi_data
argument_list|(
name|rndis_mesg
argument_list|,
name|RNDIS_TSO_PPI_SIZE
argument_list|,
name|tcp_large_send_info
argument_list|)
expr_stmt|;
name|tso_info
operator|=
operator|(
name|rndis_tcp_tso_info
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rppi
operator|+
name|rppi
operator|->
name|per_packet_info_offset
operator|)
expr_stmt|;
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|type
operator|=
name|RNDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_TSO
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m_head
operator|->
name|m_data
operator|+
name|ether_len
operator|)
decl_stmt|;
name|unsigned
name|long
name|iph_len
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iph_len
operator|)
decl_stmt|;
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|ip_version
operator|=
name|RNDIS_TCP_LARGE_SEND_OFFLOAD_IPV4
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|m_head
operator|->
name|m_data
operator|+
name|ether_len
operator|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
decl_stmt|;
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|ip_version
operator|=
name|RNDIS_TCP_LARGE_SEND_OFFLOAD_IPV6
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|tcp_header_offset
operator|=
literal|0
expr_stmt|;
name|tso_info
operator|->
name|lso_v2_xmit
operator|.
name|mss
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|txr
operator|->
name|hn_csum_assist
condition|)
block|{
name|rndis_tcp_ip_csum_info
modifier|*
name|csum_info
decl_stmt|;
name|rndis_msg_size
operator|+=
name|RNDIS_CSUM_PPI_SIZE
expr_stmt|;
name|rppi
operator|=
name|hv_set_rppi_data
argument_list|(
name|rndis_mesg
argument_list|,
name|RNDIS_CSUM_PPI_SIZE
argument_list|,
name|tcpip_chksum_info
argument_list|)
expr_stmt|;
name|csum_info
operator|=
operator|(
name|rndis_tcp_ip_csum_info
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rppi
operator|+
name|rppi
operator|->
name|per_packet_info_offset
operator|)
expr_stmt|;
name|csum_info
operator|->
name|xmit
operator|.
name|is_ipv4
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
name|csum_info
operator|->
name|xmit
operator|.
name|ip_header_csum
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
block|{
name|csum_info
operator|->
name|xmit
operator|.
name|tcp_csum
operator|=
literal|1
expr_stmt|;
name|csum_info
operator|->
name|xmit
operator|.
name|tcp_header_offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
block|{
name|csum_info
operator|->
name|xmit
operator|.
name|udp_csum
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|rndis_mesg
operator|->
name|msg_len
operator|=
name|packet
operator|->
name|tot_data_buf_len
operator|+
name|rndis_msg_size
expr_stmt|;
name|packet
operator|->
name|tot_data_buf_len
operator|=
name|rndis_mesg
operator|->
name|msg_len
expr_stmt|;
comment|/* 	 * Chimney send, if the packet could fit into one chimney buffer. 	 */
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|<
name|txr
operator|->
name|hn_tx_chimney_size
condition|)
block|{
name|netvsc_dev
modifier|*
name|net_dev
init|=
name|txr
operator|->
name|hn_sc
operator|->
name|net_dev
decl_stmt|;
name|uint32_t
name|send_buf_section_idx
decl_stmt|;
name|send_buf_section_idx
operator|=
name|hv_nv_get_next_send_section
argument_list|(
name|net_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_buf_section_idx
operator|!=
name|NVSP_1_CHIMNEY_SEND_INVALID_SECTION_INDEX
condition|)
block|{
name|uint8_t
modifier|*
name|dest
init|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|net_dev
operator|->
name|send_buf
operator|+
operator|(
name|send_buf_section_idx
operator|*
name|net_dev
operator|->
name|send_section_size
operator|)
operator|)
decl_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|rndis_mesg
argument_list|,
name|rndis_msg_size
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|rndis_msg_size
expr_stmt|;
name|m_copydata
argument_list|(
name|m_head
argument_list|,
literal|0
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|packet
operator|->
name|send_buf_section_idx
operator|=
name|send_buf_section_idx
expr_stmt|;
name|packet
operator|->
name|send_buf_section_size
operator|=
name|packet
operator|->
name|tot_data_buf_len
expr_stmt|;
name|packet
operator|->
name|page_buf_count
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|hn_tx_chimney
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|error
operator|=
name|hn_txdesc_dmamap_load
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|,
operator|&
name|m_head
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|int
name|freed
decl_stmt|;
comment|/* 		 * This mbuf is not linked w/ the txd yet, so free it now. 		 */
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head0
operator|=
name|NULL
expr_stmt|;
name|freed
operator|=
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|freed
operator|!=
literal|0
argument_list|,
operator|(
literal|"fail to free txd upon txdma error"
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdma_failed
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|txr
operator|->
name|hn_sc
operator|->
name|hn_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
operator|*
name|m_head0
operator|=
name|m_head
expr_stmt|;
name|packet
operator|->
name|page_buf_count
operator|=
name|nsegs
operator|+
name|HV_RF_NUM_TX_RESERVED_PAGE_BUFS
expr_stmt|;
comment|/* send packet with page buffer */
name|packet
operator|->
name|page_buffers
index|[
literal|0
index|]
operator|.
name|pfn
operator|=
name|atop
argument_list|(
name|txd
operator|->
name|rndis_msg_paddr
argument_list|)
expr_stmt|;
name|packet
operator|->
name|page_buffers
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|txd
operator|->
name|rndis_msg_paddr
operator|&
name|PAGE_MASK
expr_stmt|;
name|packet
operator|->
name|page_buffers
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|rndis_msg_size
expr_stmt|;
comment|/* 	 * Fill the page buffers with mbuf info starting at index 	 * HV_RF_NUM_TX_RESERVED_PAGE_BUFS. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
operator|++
name|i
control|)
block|{
name|hv_vmbus_page_buffer
modifier|*
name|pb
init|=
operator|&
name|packet
operator|->
name|page_buffers
index|[
name|i
operator|+
name|HV_RF_NUM_TX_RESERVED_PAGE_BUFS
index|]
decl_stmt|;
name|pb
operator|->
name|pfn
operator|=
name|atop
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|pb
operator|->
name|offset
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|&
name|PAGE_MASK
expr_stmt|;
name|pb
operator|->
name|length
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
name|packet
operator|->
name|send_buf_section_idx
operator|=
name|NVSP_1_CHIMNEY_SEND_INVALID_SECTION_INDEX
expr_stmt|;
name|packet
operator|->
name|send_buf_section_size
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|txd
operator|->
name|m
operator|=
name|m_head
expr_stmt|;
comment|/* Set the completion routine */
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|on_send_completion
operator|=
name|hn_tx_done
expr_stmt|;
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_context
operator|=
name|packet
expr_stmt|;
name|packet
operator|->
name|compl
operator|.
name|send
operator|.
name|send_completion_tid
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|txd
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE:  * If this function fails, then txd will be freed, but the mbuf  * associated w/ the txd will _not_ be freed.  */
end_comment

begin_function
specifier|static
name|int
name|hn_send_pkt
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|hv_device
modifier|*
name|device_ctx
parameter_list|,
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|send_failed
init|=
literal|0
decl_stmt|;
name|again
label|:
comment|/* 	 * Make sure that txd is not freed before ETHER_BPF_MTAP. 	 */
name|hn_txdesc_hold
argument_list|(
name|txd
argument_list|)
expr_stmt|;
name|error
operator|=
name|hv_nv_on_send
argument_list|(
name|device_ctx
argument_list|,
operator|&
name|txd
operator|->
name|netvsc_pkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|txd
operator|->
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hn_use_if_start
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|txd
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|int
name|freed
decl_stmt|;
comment|/* 		 * This should "really rarely" happen. 		 * 		 * XXX Too many RX to be acked or too many sideband 		 * commands to run?  Ask netvsc_channel_rollup() 		 * to kick start later. 		 */
name|txr
operator|->
name|hn_has_txeof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|send_failed
condition|)
block|{
name|txr
operator|->
name|hn_send_failed
operator|++
expr_stmt|;
name|send_failed
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Try sending again after set hn_has_txeof; 			 * in case that we missed the last 			 * netvsc_channel_rollup(). 			 */
goto|goto
name|again
goto|;
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"send failed\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Caller will perform further processing on the 		 * associated mbuf, so don't free it in hn_txdesc_put(); 		 * only unload it from the DMA map in hn_txdesc_put(), 		 * if it was loaded. 		 */
name|txd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|freed
operator|=
name|hn_txdesc_put
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|freed
operator|!=
literal|0
argument_list|,
operator|(
literal|"fail to free txd upon send error"
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_send_failed
operator|++
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Start a transmit of one or more packets  */
end_comment

begin_function
specifier|static
name|int
name|hn_start_locked
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|txr
operator|->
name|hn_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|hn_use_if_start
argument_list|,
operator|(
literal|"hn_start_locked is called, when if_start is disabled"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txr
operator|==
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
argument_list|,
operator|(
literal|"not the first TX ring"
operator|)
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|len
condition|)
block|{
comment|/* 			 * This sending could be time consuming; let callers 			 * dispatch this packet sending (and sending of any 			 * following up packets) to tx taskqueue. 			 */
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|txd
operator|=
name|hn_txdesc_get
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd
operator|==
name|NULL
condition|)
block|{
name|txr
operator|->
name|hn_no_txdescs
operator|++
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|hn_encap
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|,
operator|&
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Both txd and m_head are freed */
continue|continue;
block|}
name|error
operator|=
name|hn_send_pkt
argument_list|(
name|ifp
argument_list|,
name|device_ctx
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
comment|/* txd is freed, but m_head is not */
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Link up/down notification  */
end_comment

begin_function
name|void
name|netvsc_linkstatus_callback
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device_obj
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_obj
operator|->
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|hn_carrier
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Append the specified data to the indicated mbuf chain,  * Extend the mbuf chain if the new data does not fit in  * existing space.  *  * This is a minor rewrite of m_append() from sys/kern/uipc_mbuf.c.  * There should be an equivalent in the kernel mbuf code,  * but there does not appear to be one yet.  *  * Differs from m_append() in that additional mbufs are  * allocated with cluster size MJUMPAGESIZE, and filled  * accordingly.  *  * Return 1 if able to complete the job; otherwise 0.  */
end_comment

begin_function
specifier|static
name|int
name|hv_m_append
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|len
parameter_list|,
name|c_caddr_t
name|cp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|remainder
decl_stmt|,
name|space
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|remainder
operator|=
name|len
expr_stmt|;
name|space
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Copy into available space. 		 */
if|if
condition|(
name|space
operator|>
name|remainder
condition|)
name|space
operator|=
name|remainder
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|space
expr_stmt|;
name|cp
operator|+=
name|space
expr_stmt|;
name|remainder
operator|-=
name|space
expr_stmt|;
block|}
while|while
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Allocate a new mbuf; could check space 		 * and allocate a cluster instead. 		 */
name|n
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
literal|0
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
break|break;
name|n
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MJUMPAGESIZE
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|remainder
operator|-=
name|n
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
operator|-
name|remainder
expr_stmt|;
return|return
operator|(
name|remainder
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when we receive a data packet from the "wire" on the  * specified device  *  * Note:  This is no longer used as a callback  */
end_comment

begin_function
name|int
name|netvsc_recv
parameter_list|(
name|struct
name|hv_vmbus_channel
modifier|*
name|chan
parameter_list|,
name|netvsc_packet
modifier|*
name|packet
parameter_list|,
name|rndis_tcp_ip_csum_info
modifier|*
name|csum_info
parameter_list|)
block|{
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|chan
operator|->
name|device
decl_stmt|;
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_ctx
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
decl_stmt|;
comment|/* TODO: vRSS */
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|size
decl_stmt|,
name|do_lro
init|=
literal|0
decl_stmt|,
name|do_csum
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* TODO: KYS how can this be! */
block|}
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Bail out if packet contains more data than configured MTU. 	 */
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|>
operator|(
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|<=
name|MHLEN
condition|)
block|{
name|m_new
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m_new
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|packet
operator|->
name|data
argument_list|,
name|packet
operator|->
name|tot_data_buf_len
argument_list|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m_new
operator|->
name|m_len
operator|=
name|packet
operator|->
name|tot_data_buf_len
expr_stmt|;
name|rxr
operator|->
name|hn_small_pkts
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Get an mbuf with a cluster.  For packets 2K or less, 		 * get a standard 2K cluster.  For anything larger, get a 		 * 4K cluster.  Any buffers larger than 4K can cause problems 		 * if looped around to the Hyper-V TX channel, so avoid them. 		 */
name|size
operator|=
name|MCLBYTES
expr_stmt|;
if|if
condition|(
name|packet
operator|->
name|tot_data_buf_len
operator|>
name|MCLBYTES
condition|)
block|{
comment|/* 4096 */
name|size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
name|m_new
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"alloc mbuf failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hv_m_append
argument_list|(
name|m_new
argument_list|,
name|packet
operator|->
name|tot_data_buf_len
argument_list|,
name|packet
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|m_new
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|do_csum
operator|=
literal|0
expr_stmt|;
comment|/* receive side checksum offload */
if|if
condition|(
name|csum_info
operator|!=
name|NULL
condition|)
block|{
comment|/* IP csum offload */
if|if
condition|(
name|csum_info
operator|->
name|receive
operator|.
name|ip_csum_succeeded
operator|&&
name|do_csum
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
name|rxr
operator|->
name|hn_csum_ip
operator|++
expr_stmt|;
block|}
comment|/* TCP/UDP csum offload */
if|if
condition|(
operator|(
name|csum_info
operator|->
name|receive
operator|.
name|tcp_csum_succeeded
operator|||
name|csum_info
operator|->
name|receive
operator|.
name|udp_csum_succeeded
operator|)
operator|&&
name|do_csum
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|csum_info
operator|->
name|receive
operator|.
name|tcp_csum_succeeded
condition|)
name|rxr
operator|->
name|hn_csum_tcp
operator|++
expr_stmt|;
else|else
name|rxr
operator|->
name|hn_csum_udp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|csum_info
operator|->
name|receive
operator|.
name|ip_csum_succeeded
operator|&&
name|csum_info
operator|->
name|receive
operator|.
name|tcp_csum_succeeded
condition|)
name|do_lro
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|uint16_t
name|etype
decl_stmt|;
name|int
name|hoff
decl_stmt|;
name|hoff
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|->
name|m_len
operator|<
name|hoff
condition|)
goto|goto
name|skip
goto|;
name|eh
operator|=
name|mtod
argument_list|(
name|m_new
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
specifier|const
name|struct
name|ether_vlan_header
modifier|*
name|evl
decl_stmt|;
name|hoff
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|evl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|->
name|m_len
operator|<
name|hoff
condition|)
goto|goto
name|skip
goto|;
name|evl
operator|=
name|mtod
argument_list|(
name|m_new
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|evl
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_IP
condition|)
block|{
name|int
name|pr
decl_stmt|;
name|pr
operator|=
name|hn_check_iplen
argument_list|(
name|m_new
argument_list|,
name|hoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|do_csum
operator|&&
operator|(
name|rxr
operator|->
name|hn_trust_hcsum
operator|&
name|HN_TRUST_HCSUM_TCP
operator|)
condition|)
block|{
name|rxr
operator|->
name|hn_csum_trusted
operator|++
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
comment|/* Rely on SW csum verification though... */
name|do_lro
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pr
operator|==
name|IPPROTO_UDP
condition|)
block|{
if|if
condition|(
name|do_csum
operator|&&
operator|(
name|rxr
operator|->
name|hn_trust_hcsum
operator|&
name|HN_TRUST_HCSUM_UDP
operator|)
condition|)
block|{
name|rxr
operator|->
name|hn_csum_trusted
operator|++
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pr
operator|!=
name|IPPROTO_DONE
operator|&&
name|do_csum
operator|&&
operator|(
name|rxr
operator|->
name|hn_trust_hcsum
operator|&
name|HN_TRUST_HCSUM_IP
operator|)
condition|)
block|{
name|rxr
operator|->
name|hn_csum_trusted
operator|++
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
block|}
block|}
name|skip
label|:
if|if
condition|(
operator|(
name|packet
operator|->
name|vlan_tci
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|m_new
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|packet
operator|->
name|vlan_tci
expr_stmt|;
name|m_new
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
comment|/* 	 * Note:  Moved RX completion back to hv_nv_on_receive() so all 	 * messages (not just data messages) will trigger a response. 	 */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|&&
name|do_lro
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|hn_lro
decl_stmt|;
if|if
condition|(
name|lro
operator|->
name|lro_cnt
condition|)
block|{
name|rxr
operator|->
name|hn_lro_tried
operator|++
expr_stmt|;
if|if
condition|(
name|tcp_lro_rx
argument_list|(
name|lro
argument_list|,
name|m_new
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* DONE! */
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* We're not holding the lock here, so don't release it */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rules for using sc->temp_unusable:  * 1.  sc->temp_unusable can only be read or written while holding NV_LOCK()  * 2.  code reading sc->temp_unusable under NV_LOCK(), and finding   *     sc->temp_unusable set, must release NV_LOCK() and exit  * 3.  to retain exclusive control of the interface,  *     sc->temp_unusable must be set by code before releasing NV_LOCK()  * 4.  only code setting sc->temp_unusable can clear sc->temp_unusable  * 5.  code setting sc->temp_unusable must eventually clear sc->temp_unusable  */
end_comment

begin_comment
comment|/*  * Standard ioctl entry point.  Called when the user wants to configure  * the interface.  */
end_comment

begin_function
specifier|static
name|int
name|hn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|netvsc_device_info
name|device_info
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|hn_dev
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|retry_cnt
init|=
literal|500
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|hn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|hn_dev
operator|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
expr_stmt|;
comment|/* Check MTU value change */
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|==
name|ifr
operator|->
name|ifr_mtu
condition|)
break|break;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|NETVSC_MAX_CONFIGURABLE_MTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Obtain and record requested MTU */
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
comment|/* 		 * Make sure that LRO aggregation length limit is still 		 * valid, after the MTU change. 		 */
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_lro
operator|.
name|lro_length_lim
operator|<
name|HN_LRO_LENLIM_MIN
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
operator|.
name|hn_lro
operator|.
name|lro_length_lim
operator|=
name|HN_LRO_LENLIM_MIN
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
do|do
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|retry_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
block|{
name|retry_cnt
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|retry_cnt
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* We must remove and add back the device to cause the new 		 * MTU to take effect.  This includes tearing down, but not 		 * deleting the channel, then bringing it back up. 		 */
name|error
operator|=
name|hv_rf_on_device_remove
argument_list|(
name|hn_dev
argument_list|,
name|HV_RF_NV_RETAIN_CHANNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|hv_rf_on_device_add
argument_list|(
name|hn_dev
argument_list|,
operator|&
name|device_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|hn_tx_chimney_max
operator|=
name|sc
operator|->
name|net_dev
operator|->
name|send_section_size
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_tx_chimney_size
operator|>
name|sc
operator|->
name|hn_tx_chimney_max
condition|)
name|hn_set_tx_chimney_size
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hn_tx_chimney_max
argument_list|)
expr_stmt|;
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
do|do
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|retry_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
block|{
name|retry_cnt
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry_cnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|retry_cnt
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * If only the state of the PROMISC flag changed, 			 * then just use the 'set promisc mode' command 			 * instead of reinitializing the entire NIC. Doing 			 * a full re-init means reloading the firmware and 			 * waiting for it to start up, which may take a 			 * second or two. 			 */
ifdef|#
directive|ifdef
name|notyet
comment|/* Fixme:  Promiscuous mode? */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|hn_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
comment|/* do something here for Hyper-V */
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|hn_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* do something here for Hyper-V */
block|}
else|else
endif|#
directive|endif
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|hn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_csum_assist
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_csum_assist
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_IP_TSO
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP6_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_IP6_TSO
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
ifdef|#
directive|ifdef
name|notyet
comment|/* Fixme:  Multicast mode? */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|netvsc_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|hn_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_stop
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" Closing Device ...\n"
argument_list|)
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_oactive
operator|=
literal|0
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_initdone
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_rf_on_close
argument_list|(
name|device_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FreeBSD transmit entry point  */
end_comment

begin_function
specifier|static
name|void
name|hn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_sched_tx
condition|)
goto|goto
name|do_sched
goto|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
condition|)
block|{
name|int
name|sched
decl_stmt|;
name|sched
operator|=
name|hn_start_locked
argument_list|(
name|txr
argument_list|,
name|txr
operator|->
name|hn_direct_tx_size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sched
condition|)
return|return;
block|}
name|do_sched
label|:
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_start_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|txr
operator|->
name|hn_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|KASSERT
argument_list|(
name|txr
operator|==
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
argument_list|,
operator|(
literal|"not the first TX ring"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_sched_tx
condition|)
goto|goto
name|do_sched
goto|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
condition|)
block|{
name|int
name|sched
decl_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|sched
operator|=
name|hn_start_locked
argument_list|(
name|txr
argument_list|,
name|txr
operator|->
name|hn_direct_tx_size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_sched
label|:
comment|/* 		 * Release the OACTIVE earlier, with the hope, that 		 * others could catch up.  The task will clear the 		 * flag again with the hn_tx_lock to avoid possible 		 * races. 		 */
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_ifinit_locked
parameter_list|(
name|hn_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
return|return;
block|}
name|hv_promisc_mode
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|hv_rf_on_open
argument_list|(
name|device_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
else|else
block|{
name|sc
operator|->
name|hn_initdone
operator|=
literal|1
expr_stmt|;
block|}
name|atomic_clear_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_oactive
operator|=
literal|0
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|temp_unusable
condition|)
block|{
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|temp_unusable
operator|=
name|TRUE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_unusable
operator|=
name|FALSE
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LATER
end_ifdef

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|hn_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|hn_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|printf
argument_list|(
literal|"hn%d: watchdog timeout -- resetting\n"
argument_list|,
name|sc
operator|->
name|hn_unit
argument_list|)
expr_stmt|;
name|hn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*???*/
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|hn_lro_lenlim_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|unsigned
name|int
name|lenlim
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|lenlim
operator|=
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_lro
operator|.
name|lro_length_lim
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|lenlim
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|lenlim
operator|<
name|HN_LRO_LENLIM_MIN
argument_list|(
name|sc
operator|->
name|hn_ifp
argument_list|)
operator|||
name|lenlim
operator|>
name|TCP_LRO_LENGTH_MAX
condition|)
return|return
name|EINVAL
return|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
operator|.
name|hn_lro
operator|.
name|lro_length_lim
operator|=
name|lenlim
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_lro_ackcnt_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ackcnt
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * lro_ackcnt_lim is append count limit, 	 * +1 to turn it into aggregation limit. 	 */
name|ackcnt
operator|=
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_lro
operator|.
name|lro_ackcnt_lim
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|ackcnt
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ackcnt
operator|<
literal|2
operator|||
name|ackcnt
operator|>
operator|(
name|TCP_LRO_ACKCNT_MAX
operator|+
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * Convert aggregation limit back to append 	 * count limit. 	 */
operator|--
name|ackcnt
expr_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
operator|.
name|hn_lro
operator|.
name|lro_ackcnt_lim
operator|=
name|ackcnt
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_trust_hcsum_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|hcsum
init|=
name|arg2
decl_stmt|;
name|int
name|on
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|on
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring
index|[
literal|0
index|]
operator|.
name|hn_trust_hcsum
operator|&
name|hcsum
condition|)
name|on
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|on
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|on
condition|)
name|rxr
operator|->
name|hn_trust_hcsum
operator||=
name|hcsum
expr_stmt|;
else|else
name|rxr
operator|->
name|hn_trust_hcsum
operator|&=
operator|~
name|hcsum
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_tx_chimney_size_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|chimney_size
decl_stmt|,
name|error
decl_stmt|;
name|chimney_size
operator|=
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_tx_chimney_size
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|chimney_size
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|chimney_size
operator|>
name|sc
operator|->
name|hn_tx_chimney_max
operator|||
name|chimney_size
operator|<=
literal|0
condition|)
return|return
name|EINVAL
return|;
name|hn_set_tx_chimney_size
argument_list|(
name|sc
argument_list|,
name|chimney_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_rx_stat_ulong_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|u_long
name|stat
decl_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|+=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|stat
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
comment|/* Zero out this stat. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_rx_stat_u64_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|hn_rx_ring
modifier|*
name|rxr
decl_stmt|;
name|uint64_t
name|stat
decl_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|+=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|stat
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
comment|/* Zero out this stat. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rxr
operator|+
name|ofs
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_tx_stat_ulong_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|u_long
name|stat
decl_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|+=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|txr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|stat
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
comment|/* Zero out this stat. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|txr
operator|+
name|ofs
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_tx_conf_int_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ofs
init|=
name|arg2
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|,
name|conf
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
expr_stmt|;
name|conf
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|txr
operator|+
name|ofs
operator|)
operator|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|conf
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|txr
operator|+
name|ofs
operator|)
operator|)
operator|=
name|conf
expr_stmt|;
block|}
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_check_iplen
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hoff
parameter_list|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|,
name|iphlen
decl_stmt|,
name|iplen
decl_stmt|;
specifier|const
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|int
name|thoff
decl_stmt|;
comment|/* TCP data offset */
name|len
operator|=
name|hoff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
comment|/* The packet must be at least the size of an IP header. */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|len
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* The fixed IP header must reside completely in the first mbuf. */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len
condition|)
return|return
name|IPPROTO_DONE
return|;
name|ip
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hoff
argument_list|)
expr_stmt|;
comment|/* Bound check the packet's stated IP header length. */
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|iphlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
comment|/* minimum header length */
return|return
name|IPPROTO_DONE
return|;
comment|/* The full IP header must reside completely in the one mbuf. */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
condition|)
return|return
name|IPPROTO_DONE
return|;
name|iplen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers is as 	 * at least much as the IP header would have us expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|hoff
operator|+
name|iplen
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* 	 * Ignore IP fragments. 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|&
operator|(
name|IP_OFFMASK
operator||
name|IP_MF
operator|)
condition|)
return|return
name|IPPROTO_DONE
return|;
comment|/* 	 * The TCP/IP or UDP/IP header must be entirely contained within 	 * the first fragment of a packet. 	 */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|iplen
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
name|th
operator|=
operator|(
specifier|const
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|thoff
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|thoff
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|||
name|thoff
operator|+
name|iphlen
operator|>
name|iplen
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
name|thoff
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|iplen
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hoff
operator|+
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
default|default:
if|if
condition|(
name|iplen
operator|<
name|iphlen
condition|)
return|return
name|IPPROTO_DONE
return|;
break|break;
block|}
return|return
name|ip
operator|->
name|ip_p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_dma_map_paddr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many segments %d!"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_create_rx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|hn_dev
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
name|int
name|lroent_cnt
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|hn_rx_ring_cnt
operator|=
literal|1
expr_stmt|;
comment|/* TODO: vRSS */
name|sc
operator|->
name|hn_rx_ring
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|)
operator|*
name|sc
operator|->
name|hn_rx_ring_cnt
argument_list|,
name|M_NETVSC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
name|lroent_cnt
operator|=
name|hn_lro_entry_count
expr_stmt|;
if|if
condition|(
name|lroent_cnt
operator|<
name|TCP_LRO_ENTRIES
condition|)
name|lroent_cnt
operator|=
name|TCP_LRO_ENTRIES
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LRO: entry count %d\n"
argument_list|,
name|lroent_cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* INET || INET6 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_rx_ring
modifier|*
name|rxr
init|=
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hn_trust_hosttcp
condition|)
name|rxr
operator|->
name|hn_trust_hcsum
operator||=
name|HN_TRUST_HCSUM_TCP
expr_stmt|;
if|if
condition|(
name|hn_trust_hostudp
condition|)
name|rxr
operator|->
name|hn_trust_hcsum
operator||=
name|HN_TRUST_HCSUM_UDP
expr_stmt|;
if|if
condition|(
name|hn_trust_hostip
condition|)
name|rxr
operator|->
name|hn_trust_hcsum
operator||=
name|HN_TRUST_HCSUM_IP
expr_stmt|;
comment|/* 		 * Initialize LRO. 		 */
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100095
name|tcp_lro_init_args
argument_list|(
operator|&
name|rxr
operator|->
name|hn_lro
argument_list|,
name|sc
operator|->
name|hn_ifp
argument_list|,
name|lroent_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|tcp_lro_init
argument_list|(
operator|&
name|rxr
operator|->
name|hn_lro
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hn_lro
operator|.
name|ifp
operator|=
name|sc
operator|->
name|hn_ifp
expr_stmt|;
endif|#
directive|endif
name|rxr
operator|->
name|hn_lro
operator|.
name|lro_length_lim
operator|=
name|HN_LRO_LENLIM_DEF
expr_stmt|;
name|rxr
operator|->
name|hn_lro
operator|.
name|lro_ackcnt_lim
operator|=
name|HN_LRO_ACKCNT_DEF
expr_stmt|;
endif|#
directive|endif
comment|/* INET || INET6 */
block|}
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_lro
operator|.
name|lro_queued
argument_list|)
argument_list|,
name|hn_rx_stat_u64_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"LRO queued"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_lro
operator|.
name|lro_flushed
argument_list|)
argument_list|,
name|hn_rx_stat_u64_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"LRO flushed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_tried"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_lro_tried
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of LRO tries"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_length_lim"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_lro_lenlim_sysctl
argument_list|,
literal|"IU"
argument_list|,
literal|"Max # of data bytes to be aggregated by LRO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_ackcnt_lim"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_lro_ackcnt_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Max # of ACKs to be aggregated by LRO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trust_hosttcp"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|HN_TRUST_HCSUM_TCP
argument_list|,
name|hn_trust_hcsum_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Trust tcp segement verification on host side, "
literal|"when csum info is missing"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trust_hostudp"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|HN_TRUST_HCSUM_UDP
argument_list|,
name|hn_trust_hcsum_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Trust udp datagram verification on host side, "
literal|"when csum info is missing"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trust_hostip"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|HN_TRUST_HCSUM_IP
argument_list|,
name|hn_trust_hcsum_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Trust ip packet verification on host side, "
literal|"when csum info is missing"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_ip"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_csum_ip
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"RXCSUM IP"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_tcp"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_csum_tcp
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"RXCSUM TCP"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_udp"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_csum_udp
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"RXCSUM UDP"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_trusted"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_csum_trusted
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of packets that we trust host's csum verification"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"small_pkts"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_rx_ring
argument_list|,
name|hn_small_pkts
argument_list|)
argument_list|,
name|hn_rx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of small packets received"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_destroy_rx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|hn_rx_ring_cnt
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_rx_ring_cnt
condition|;
operator|++
name|i
control|)
name|tcp_lro_free
argument_list|(
operator|&
name|sc
operator|->
name|hn_rx_ring
index|[
name|i
index|]
operator|.
name|hn_lro
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|sc
operator|->
name|hn_rx_ring
argument_list|,
name|M_NETVSC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|hn_rx_ring_cnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_create_tx_ring
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|id
index|]
decl_stmt|;
name|bus_dma_tag_t
name|parent_dtag
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|txr
operator|->
name|hn_sc
operator|=
name|sc
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|,
literal|"hn txlist"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|,
literal|"hn tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdesc_cnt
operator|=
name|HN_TX_DESC_CNT
expr_stmt|;
name|txr
operator|->
name|hn_txdesc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hn_txdesc
argument_list|)
operator|*
name|txr
operator|->
name|hn_txdesc_cnt
argument_list|,
name|M_NETVSC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|SLIST_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|)
expr_stmt|;
else|#
directive|else
name|txr
operator|->
name|hn_txdesc_br
operator|=
name|buf_ring_alloc
argument_list|(
name|txr
operator|->
name|hn_txdesc_cnt
argument_list|,
name|M_NETVSC
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|txr
operator|->
name|hn_tx_taskq
operator|=
name|sc
operator|->
name|hn_tx_taskq
expr_stmt|;
if|if
condition|(
name|hn_use_if_start
condition|)
block|{
name|txr
operator|->
name|hn_txeof
operator|=
name|hn_start_txeof
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|,
literal|0
argument_list|,
name|hn_start_taskfunc
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|,
literal|0
argument_list|,
name|hn_start_txeof_taskfunc
argument_list|,
name|txr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txr
operator|->
name|hn_txeof
operator|=
name|hn_xmit_txeof
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|,
literal|0
argument_list|,
name|hn_xmit_taskfunc
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|,
literal|0
argument_list|,
name|hn_xmit_txeof_taskfunc
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_mbuf_br
operator|=
name|buf_ring_alloc
argument_list|(
name|txr
operator|->
name|hn_txdesc_cnt
argument_list|,
name|M_NETVSC
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
name|txr
operator|->
name|hn_direct_tx_size
operator|=
name|hn_direct_tx_size
expr_stmt|;
if|if
condition|(
name|hv_vmbus_protocal_version
operator|>=
name|HV_VMBUS_VERSION_WIN8_1
condition|)
name|txr
operator|->
name|hn_csum_assist
operator|=
name|HN_CSUM_ASSIST
expr_stmt|;
else|else
name|txr
operator|->
name|hn_csum_assist
operator|=
name|HN_CSUM_ASSIST_WIN8
expr_stmt|;
comment|/* 	 * Always schedule transmission instead of trying to do direct 	 * transmission.  This one gives the best performance so far. 	 */
name|txr
operator|->
name|hn_sched_tx
operator|=
literal|1
expr_stmt|;
name|parent_dtag
operator|=
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
expr_stmt|;
comment|/* DMA tag for RNDIS messages. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|parent_dtag
argument_list|,
comment|/* parent */
name|HN_RNDIS_MSG_ALIGN
argument_list|,
comment|/* alignment */
name|HN_RNDIS_MSG_BOUNDARY
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|HN_RNDIS_MSG_LEN
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|HN_RNDIS_MSG_LEN
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"failed to create rndis dmatag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* DMA tag for data. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|parent_dtag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
name|HN_TX_DATA_BOUNDARY
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|HN_TX_DATA_MAXSIZE
argument_list|,
comment|/* maxsize */
name|HN_TX_DATA_SEGCNT_MAX
argument_list|,
comment|/* nsegments */
name|HN_TX_DATA_SEGSIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"failed to create data dmatag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txr
operator|->
name|hn_txdesc_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
init|=
operator|&
name|txr
operator|->
name|hn_txdesc
index|[
name|i
index|]
decl_stmt|;
name|txd
operator|->
name|txr
operator|=
name|txr
expr_stmt|;
comment|/* 		 * Allocate and load RNDIS messages. 		 */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|txd
operator|->
name|rndis_msg
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|txd
operator|->
name|rndis_msg_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"failed to allocate rndis_msg, %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_msg_dmap
argument_list|,
name|txd
operator|->
name|rndis_msg
argument_list|,
name|HN_RNDIS_MSG_LEN
argument_list|,
name|hn_dma_map_paddr
argument_list|,
operator|&
name|txd
operator|->
name|rndis_msg_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"failed to load rndis_msg, %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_msg
argument_list|,
name|txd
operator|->
name|rndis_msg_dmap
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* DMA map for TX data. */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txd
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|,
literal|"failed to allocate tx data dmamap\n"
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_msg_dmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_msg
argument_list|,
name|txd
operator|->
name|rndis_msg_dmap
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* All set, put it to list */
name|txd
operator|->
name|flags
operator||=
name|HN_TXD_FLAG_ONLIST
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|,
name|txd
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|#
directive|else
name|buf_ring_enqueue
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|,
name|txd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|txr
operator|->
name|hn_txdesc_avail
operator|=
name|txr
operator|->
name|hn_txdesc_cnt
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_tx_sysctl_tree
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 		 * Create per TX ring sysctl tree: 		 * dev.hn.UNIT.tx.RINGID 		 */
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|hn_tx_sysctl_tree
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_tx_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_tx_sysctl_tree
operator|!=
name|NULL
condition|)
block|{
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|txr
operator|->
name|hn_tx_sysctl_tree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txdesc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|hn_txdesc_avail
argument_list|,
literal|0
argument_list|,
literal|"# of available TX descs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hn_use_if_start
condition|)
block|{
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"oactive"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|hn_oactive
argument_list|,
literal|0
argument_list|,
literal|"over active"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_txdesc_dmamap_destroy
parameter_list|(
name|struct
name|hn_txdesc
modifier|*
name|txd
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|txd
operator|->
name|txr
decl_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|m
operator|==
name|NULL
argument_list|,
operator|(
literal|"still has mbuf installed"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|txd
operator|->
name|flags
operator|&
name|HN_TXD_FLAG_DMAMAP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"still dma mapped"
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_msg_dmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|,
name|txd
operator|->
name|rndis_msg
argument_list|,
name|txd
operator|->
name|rndis_msg_dmap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|,
name|txd
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_destroy_tx_ring
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
decl_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_txdesc
operator|==
name|NULL
condition|)
return|return;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
while|while
condition|(
operator|(
name|txd
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|hn_txdesc_dmamap_destroy
argument_list|(
name|txd
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txd
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|hn_txdesc_dmamap_destroy
argument_list|(
name|txd
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txr
operator|->
name|hn_tx_data_dtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|hn_tx_data_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_tx_rndis_dtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|hn_tx_rndis_dtag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HN_USE_TXDESC_BUFRING
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|hn_txdesc_br
argument_list|,
name|M_NETVSC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|txr
operator|->
name|hn_txdesc
argument_list|,
name|M_NETVSC
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_txdesc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|hn_mbuf_br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|M_NETVSC
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HN_USE_TXDESC_BUFRING
name|mtx_destroy
argument_list|(
operator|&
name|txr
operator|->
name|hn_txlist_spin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_destroy
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_create_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hn_use_if_start
condition|)
block|{
comment|/* ifnet.if_start only needs one TX ring */
name|sc
operator|->
name|hn_tx_ring_cnt
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|hn_tx_ring_cnt
operator|=
literal|1
expr_stmt|;
comment|/* TODO: vRSS */
block|}
name|sc
operator|->
name|hn_tx_ring
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|)
operator|*
name|sc
operator|->
name|hn_tx_ring_cnt
argument_list|,
name|M_NETVSC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create dev.hn.UNIT.tx sysctl tree */
name|sc
operator|->
name|hn_tx_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|hn_create_tx_ring
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_txdescs"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_no_txdescs
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of times short of TX descs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"send_failed"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_send_failed
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of hyper-v sending failure"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txdma_failed"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_txdma_failed
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of TX DMA failure"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_collapsed"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_tx_collapsed
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of TX mbuf collapsed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_chimney"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_tx_chimney
argument_list|)
argument_list|,
name|hn_tx_stat_ulong_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"# of chimney send"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txdesc_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
operator|.
name|hn_txdesc_cnt
argument_list|,
literal|0
argument_list|,
literal|"# of total TX descs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_chimney_max"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|hn_tx_chimney_max
argument_list|,
literal|0
argument_list|,
literal|"Chimney send packet size upper boundary"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_chimney_size"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hn_tx_chimney_size_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Chimney send packet size limit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"direct_tx_size"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_direct_tx_size
argument_list|)
argument_list|,
name|hn_tx_conf_int_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Size of the packet for direct transmission"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sched_tx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|hn_tx_ring
argument_list|,
name|hn_sched_tx
argument_list|)
argument_list|,
name|hn_tx_conf_int_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Always schedule transmission "
literal|"instead of doing direct transmission"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_set_tx_chimney_size
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chimney_size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NV_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
operator|.
name|hn_tx_chimney_size
operator|=
name|chimney_size
expr_stmt|;
name|NV_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_destroy_tx_data
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hn_tx_ring_cnt
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
name|hn_destroy_tx_ring
argument_list|(
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|hn_tx_ring
argument_list|,
name|M_NETVSC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hn_tx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|hn_tx_ring_cnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_start_taskfunc
parameter_list|(
name|void
modifier|*
name|xtxr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|xtxr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|hn_start_locked
argument_list|(
name|txr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_start_txeof_taskfunc
parameter_list|(
name|void
modifier|*
name|xtxr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|xtxr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|txr
operator|->
name|hn_sc
operator|->
name|hn_ifp
operator|->
name|if_drv_flags
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|hn_start_locked
argument_list|(
name|txr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_stop_tx_tasks
parameter_list|(
name|struct
name|hn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
decl_stmt|;
name|taskqueue_drain
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hn_xmit
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|txr
operator|->
name|hn_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|hn_ifp
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device_ctx
init|=
name|vmbus_get_devctx
argument_list|(
name|sc
operator|->
name|hn_dev
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|hn_use_if_start
operator|==
literal|0
argument_list|,
operator|(
literal|"hn_xmit is called, when if_start is enabled"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|txr
operator|->
name|hn_oactive
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|m_head
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|hn_txdesc
modifier|*
name|txd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|len
condition|)
block|{
comment|/* 			 * This sending could be time consuming; let callers 			 * dispatch this packet sending (and sending of any 			 * following up packets) to tx taskqueue. 			 */
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|txd
operator|=
name|hn_txdesc_get
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd
operator|==
name|NULL
condition|)
block|{
name|txr
operator|->
name|hn_no_txdescs
operator|++
expr_stmt|;
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_oactive
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|hn_encap
argument_list|(
name|txr
argument_list|,
name|txd
argument_list|,
operator|&
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Both txd and m_head are freed; discard */
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|hn_send_pkt
argument_list|(
name|ifp
argument_list|,
name|device_ctx
argument_list|,
name|txr
argument_list|,
name|txd
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
comment|/* txd is freed, but m_head is not */
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_oactive
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Sent */
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hn_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|hn_tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* TODO: vRSS, TX ring selection */
name|txr
operator|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
literal|0
index|]
expr_stmt|;
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|hn_mbuf_br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|txr
operator|->
name|hn_oactive
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|txr
operator|->
name|hn_sched_tx
condition|)
goto|goto
name|do_sched
goto|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
condition|)
block|{
name|int
name|sched
decl_stmt|;
name|sched
operator|=
name|hn_xmit
argument_list|(
name|txr
argument_list|,
name|txr
operator|->
name|hn_direct_tx_size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sched
condition|)
return|return
literal|0
return|;
block|}
name|do_sched
label|:
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_xmit_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hn_tx_ring_cnt
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
operator|&
name|sc
operator|->
name|hn_tx_ring
index|[
name|i
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|hn_mbuf_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_xmit_txeof
parameter_list|(
name|struct
name|hn_tx_ring
modifier|*
name|txr
parameter_list|)
block|{
if|if
condition|(
name|txr
operator|->
name|hn_sched_tx
condition|)
goto|goto
name|do_sched
goto|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
condition|)
block|{
name|int
name|sched
decl_stmt|;
name|txr
operator|->
name|hn_oactive
operator|=
literal|0
expr_stmt|;
name|sched
operator|=
name|hn_xmit
argument_list|(
name|txr
argument_list|,
name|txr
operator|->
name|hn_direct_tx_size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_tx_task
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_sched
label|:
comment|/* 		 * Release the oactive earlier, with the hope, that 		 * others could catch up.  The task will clear the 		 * oactive again with the hn_tx_lock to avoid possible 		 * races. 		 */
name|txr
operator|->
name|hn_oactive
operator|=
literal|0
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|hn_tx_taskq
argument_list|,
operator|&
name|txr
operator|->
name|hn_txeof_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hn_xmit_taskfunc
parameter_list|(
name|void
modifier|*
name|xtxr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|xtxr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|hn_xmit
argument_list|(
name|txr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_xmit_txeof_taskfunc
parameter_list|(
name|void
modifier|*
name|xtxr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hn_tx_ring
modifier|*
name|txr
init|=
name|xtxr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
name|txr
operator|->
name|hn_oactive
operator|=
literal|0
expr_stmt|;
name|hn_xmit
argument_list|(
name|txr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|hn_tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hn_tx_taskq_create
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hn_share_tx_taskq
condition|)
return|return;
name|hn_tx_taskq
operator|=
name|taskqueue_create
argument_list|(
literal|"hn_tx"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|hn_tx_taskq
argument_list|)
expr_stmt|;
if|if
condition|(
name|hn_bind_tx_taskq
operator|>=
literal|0
condition|)
block|{
name|int
name|cpu
init|=
name|hn_bind_tx_taskq
decl_stmt|;
name|cpuset_t
name|cpu_set
decl_stmt|;
if|if
condition|(
name|cpu
operator|>
name|mp_ncpus
operator|-
literal|1
condition|)
name|cpu
operator|=
name|mp_ncpus
operator|-
literal|1
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|cpu
argument_list|,
operator|&
name|cpu_set
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|hn_tx_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_set
argument_list|,
literal|"hn tx"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskqueue_start_threads
argument_list|(
operator|&
name|hn_tx_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"hn tx"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|hn_txtq_create
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|hn_tx_taskq_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|hn_tx_taskq_destroy
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|hn_tx_taskq
operator|!=
name|NULL
condition|)
name|taskqueue_free
argument_list|(
name|hn_tx_taskq
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|hn_txtq_destroy
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|hn_tx_taskq_destroy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|netvsc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|netvsc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|netvsc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|netvsc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|netvsc_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|netvsc_driver
init|=
block|{
name|NETVSC_DEVNAME
block|,
name|netvsc_methods
block|,
expr|sizeof
operator|(
name|hn_softc_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|netvsc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hn
argument_list|,
name|vmbus
argument_list|,
name|netvsc_driver
argument_list|,
name|netvsc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|hn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hn
argument_list|,
name|vmbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

