begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2012,2016 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * Copyright (c) 2012 Citrix Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * StorVSC driver for Hyper-V.  This driver presents a SCSI HBA interface  * to the Comman Access Method (CAM) layer.  CAM control blocks (CCBs) are  * converted into VSCSI protocol messages which are delivered to the parent  * partition StorVSP driver over the Hyper-V VMBUS.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/vmbus.h>
end_include

begin_include
include|#
directive|include
file|"hv_vstorage.h"
end_include

begin_include
include|#
directive|include
file|"vmbus_if.h"
end_include

begin_define
define|#
directive|define
name|STORVSC_MAX_LUNS_PER_TARGET
value|(64)
end_define

begin_define
define|#
directive|define
name|STORVSC_MAX_IO_REQUESTS
value|(STORVSC_MAX_LUNS_PER_TARGET * 2)
end_define

begin_define
define|#
directive|define
name|BLKVSC_MAX_IDE_DISKS_PER_TARGET
value|(1)
end_define

begin_define
define|#
directive|define
name|BLKVSC_MAX_IO_REQUESTS
value|STORVSC_MAX_IO_REQUESTS
end_define

begin_define
define|#
directive|define
name|STORVSC_MAX_TARGETS
value|(2)
end_define

begin_define
define|#
directive|define
name|VSTOR_PKT_SIZE
value|(sizeof(struct vstor_packet) - vmscsi_size_delta)
end_define

begin_comment
comment|/*  * 33 segments are needed to allow 128KB maxio, in case the data  * in the first page is _not_ PAGE_SIZE aligned, e.g.  *  *     |<----------- 128KB ----------->|  *     |                               |  *  0  2K 4K    8K   16K   124K  128K  130K  *  |  |  |     |     |       |     |  |  *  +--+--+-----+-----+.......+-----+--+--+  *  |  |  |     |     |       |     |  |  | DATA  *  |  |  |     |     |       |     |  |  |  *  +--+--+-----+-----+.......------+--+--+  *     |  |                         |  |  *     | 1|            31           | 1| ...... # of segments  */
end_comment

begin_define
define|#
directive|define
name|STORVSC_DATA_SEGCNT_MAX
value|33
end_define

begin_define
define|#
directive|define
name|STORVSC_DATA_SEGSZ_MAX
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|STORVSC_DATA_SIZE_MAX
define|\
value|((STORVSC_DATA_SEGCNT_MAX - 1) * STORVSC_DATA_SEGSZ_MAX)
end_define

begin_struct_decl
struct_decl|struct
name|storvsc_softc
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|hv_sgl_node
block|{
name|LIST_ENTRY
argument_list|(
argument|hv_sgl_node
argument_list|)
name|link
expr_stmt|;
name|struct
name|sglist
modifier|*
name|sgl_data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hv_sgl_page_pool
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|hv_sgl_node
argument_list|)
name|in_use_sgl_list
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|hv_sgl_node
argument_list|)
name|free_sgl_list
expr_stmt|;
name|boolean_t
name|is_init
decl_stmt|;
block|}
name|g_hv_sgl_page_pool
struct|;
end_struct

begin_enum
enum|enum
name|storvsc_request_type
block|{
name|WRITE_TYPE
block|,
name|READ_TYPE
block|,
name|UNKNOWN_TYPE
block|}
enum|;
end_enum

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|storvsc
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|"Hyper-V storage interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|hv_storvsc_use_win8ext_flags
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_storvsc
argument_list|,
name|OID_AUTO
argument_list|,
name|use_win8ext_flags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|hv_storvsc_use_win8ext_flags
argument_list|,
literal|0
argument_list|,
literal|"Use win8 extension flags or not"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|hv_storvsc_use_pim_unmapped
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_storvsc
argument_list|,
name|OID_AUTO
argument_list|,
name|use_pim_unmapped
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hv_storvsc_use_pim_unmapped
argument_list|,
literal|0
argument_list|,
literal|"Optimize storvsc by using unmapped I/O"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|hv_storvsc_ringbuffer_size
init|=
operator|(
literal|64
operator|*
name|PAGE_SIZE
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_storvsc
argument_list|,
name|OID_AUTO
argument_list|,
name|ringbuffer_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hv_storvsc_ringbuffer_size
argument_list|,
literal|0
argument_list|,
literal|"Hyper-V storage ringbuffer size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|hv_storvsc_max_io
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_storvsc
argument_list|,
name|OID_AUTO
argument_list|,
name|max_io
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hv_storvsc_max_io
argument_list|,
literal|0
argument_list|,
literal|"Hyper-V storage max io limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|hv_storvsc_chan_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_storvsc
argument_list|,
name|OID_AUTO
argument_list|,
name|chan_cnt
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hv_storvsc_chan_cnt
argument_list|,
literal|0
argument_list|,
literal|"# of channels to use"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|STORVSC_MAX_IO
define|\
value|vmbus_chan_prplist_nelem(hv_storvsc_ringbuffer_size,	\ 	   STORVSC_DATA_SEGCNT_MAX, VSTOR_PKT_SIZE)
end_define

begin_struct
struct|struct
name|hv_storvsc_sysctl
block|{
name|u_long
name|data_bio_cnt
decl_stmt|;
name|u_long
name|data_vaddr_cnt
decl_stmt|;
name|u_long
name|data_sg_cnt
decl_stmt|;
name|u_long
name|chan_send_cnt
index|[
name|MAXCPU
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|storvsc_gpa_range
block|{
name|struct
name|vmbus_gpa_range
name|gpa_range
decl_stmt|;
name|uint64_t
name|gpa_page
index|[
name|STORVSC_DATA_SEGCNT_MAX
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|hv_storvsc_request
block|{
name|LIST_ENTRY
argument_list|(
argument|hv_storvsc_request
argument_list|)
name|link
expr_stmt|;
name|struct
name|vstor_packet
name|vstor_packet
decl_stmt|;
name|int
name|prp_cnt
decl_stmt|;
name|struct
name|storvsc_gpa_range
name|prp_list
decl_stmt|;
name|void
modifier|*
name|sense_data
decl_stmt|;
name|uint8_t
name|sense_info_len
decl_stmt|;
name|uint8_t
name|retries
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
name|struct
name|sema
name|synch_sema
decl_stmt|;
comment|/*Synchronize the request/response if needed */
name|struct
name|sglist
modifier|*
name|bounce_sgl
decl_stmt|;
name|unsigned
name|int
name|bounce_sgl_count
decl_stmt|;
name|uint64_t
name|not_aligned_seg_bits
decl_stmt|;
name|bus_dmamap_t
name|data_dmap
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|storvsc_softc
block|{
name|struct
name|vmbus_channel
modifier|*
name|hs_chan
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|hv_storvsc_request
argument_list|)
name|hs_free_list
expr_stmt|;
name|struct
name|mtx
name|hs_lock
decl_stmt|;
name|struct
name|storvsc_driver_props
modifier|*
name|hs_drv_props
decl_stmt|;
name|int
name|hs_unit
decl_stmt|;
name|uint32_t
name|hs_frozen
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|hs_sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|hs_path
decl_stmt|;
name|uint32_t
name|hs_num_out_reqs
decl_stmt|;
name|boolean_t
name|hs_destroy
decl_stmt|;
name|boolean_t
name|hs_drain_notify
decl_stmt|;
name|struct
name|sema
name|hs_drain_sema
decl_stmt|;
name|struct
name|hv_storvsc_request
name|hs_init_req
decl_stmt|;
name|struct
name|hv_storvsc_request
name|hs_reset_req
decl_stmt|;
name|device_t
name|hs_dev
decl_stmt|;
name|bus_dma_tag_t
name|storvsc_req_dtag
decl_stmt|;
name|struct
name|hv_storvsc_sysctl
name|sysctl_data
decl_stmt|;
name|uint32_t
name|hs_nchan
decl_stmt|;
name|struct
name|vmbus_channel
modifier|*
name|hs_sel_chan
index|[
name|MAXCPU
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|storvsc_handler_tag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The size of the vmscsi_request has changed in win8. The  * additional size is for the newly added elements in the  * structure. These elements are valid only when we are talking  * to a win8 host.  * Track the correct size we need to apply.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vmscsi_size_delta
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|vmscsi_win8_extension
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * HyperV storvsc timeout testing cases:  * a. IO returned after first timeout;  * b. IO returned after second timeout and queue freeze;  * c. IO returned while timer handler is running  * The first can be tested by "sg_senddiag -vv /dev/daX",  * and the second and third can be done by  * "sg_wr_mode -v -p 08 -c 0,1a -m 0,ff /dev/daX".  */
end_comment

begin_define
define|#
directive|define
name|HVS_TIMEOUT_TEST
value|0
end_define

begin_comment
comment|/*  * Bus/adapter reset functionality on the Hyper-V host is  * buggy and it will be disabled until  * it can be further tested.  */
end_comment

begin_define
define|#
directive|define
name|HVS_HOST_RESET
value|0
end_define

begin_struct
struct|struct
name|storvsc_driver_props
block|{
name|char
modifier|*
name|drv_name
decl_stmt|;
name|char
modifier|*
name|drv_desc
decl_stmt|;
name|uint8_t
name|drv_max_luns_per_target
decl_stmt|;
name|uint32_t
name|drv_max_ios_per_target
decl_stmt|;
name|uint32_t
name|drv_ringbuffer_size
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|hv_storage_type
block|{
name|DRIVER_BLKVSC
block|,
name|DRIVER_STORVSC
block|,
name|DRIVER_UNKNOWN
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|HS_MAX_ADAPTERS
value|10
end_define

begin_define
define|#
directive|define
name|HV_STORAGE_SUPPORTS_MULTI_CHANNEL
value|0x1
end_define

begin_comment
comment|/* {ba6163d9-04a1-4d29-b605-72e2ffb1dc7f} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|hyperv_guid
name|gStorVscDeviceType
init|=
block|{
operator|.
name|hv_guid
operator|=
block|{
literal|0xd9
block|,
literal|0x63
block|,
literal|0x61
block|,
literal|0xba
block|,
literal|0xa1
block|,
literal|0x04
block|,
literal|0x29
block|,
literal|0x4d
block|,
literal|0xb6
block|,
literal|0x05
block|,
literal|0x72
block|,
literal|0xe2
block|,
literal|0xff
block|,
literal|0xb1
block|,
literal|0xdc
block|,
literal|0x7f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* {32412632-86cb-44a2-9b5c-50d1417354f5} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|hyperv_guid
name|gBlkVscDeviceType
init|=
block|{
operator|.
name|hv_guid
operator|=
block|{
literal|0x32
block|,
literal|0x26
block|,
literal|0x41
block|,
literal|0x32
block|,
literal|0xcb
block|,
literal|0x86
block|,
literal|0xa2
block|,
literal|0x44
block|,
literal|0x9b
block|,
literal|0x5c
block|,
literal|0x50
block|,
literal|0xd1
block|,
literal|0x41
block|,
literal|0x73
block|,
literal|0x54
block|,
literal|0xf5
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|storvsc_driver_props
name|g_drv_props_table
index|[]
init|=
block|{
block|{
literal|"blkvsc"
block|,
literal|"Hyper-V IDE"
block|,
name|BLKVSC_MAX_IDE_DISKS_PER_TARGET
block|,
name|BLKVSC_MAX_IO_REQUESTS
block|,
literal|20
operator|*
name|PAGE_SIZE
block|}
block|,
block|{
literal|"storvsc"
block|,
literal|"Hyper-V SCSI"
block|,
name|STORVSC_MAX_LUNS_PER_TARGET
block|,
name|STORVSC_MAX_IO_REQUESTS
block|,
literal|20
operator|*
name|PAGE_SIZE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Sense buffer size changed in win8; have a run-time  * variable to track the size we should use.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sense_buffer_size
init|=
name|PRE_WIN8_STORVSC_SENSE_BUFFER_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The storage protocol version is determined during the  * initial exchange with the host.  It will indicate which  * storage functionality is available in the host. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vmstor_proto_version
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|vmstor_proto
block|{
name|int
name|proto_version
decl_stmt|;
name|int
name|sense_buffer_size
decl_stmt|;
name|int
name|vmscsi_size_delta
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vmstor_proto
name|vmstor_proto_list
index|[]
init|=
block|{
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN10
block|,
name|POST_WIN7_STORVSC_SENSE_BUFFER_SIZE
block|,
literal|0
block|}
block|,
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN8_1
block|,
name|POST_WIN7_STORVSC_SENSE_BUFFER_SIZE
block|,
literal|0
block|}
block|,
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN8
block|,
name|POST_WIN7_STORVSC_SENSE_BUFFER_SIZE
block|,
literal|0
block|}
block|,
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN7
block|,
name|PRE_WIN8_STORVSC_SENSE_BUFFER_SIZE
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmscsi_win8_extension
argument_list|)
block|,         }
block|,
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN6
block|,
name|PRE_WIN8_STORVSC_SENSE_BUFFER_SIZE
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmscsi_win8_extension
argument_list|)
block|,         }
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static functions */
end_comment

begin_function_decl
specifier|static
name|int
name|storvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|storvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|storvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_storvsc_request
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_free_request
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|hv_storage_type
name|storvsc_get_storage_type
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hv_storvsc_rescan_target
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hv_storvsc_on_channel_callback
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hv_storvsc_on_iocompletion
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hv_storvsc_connect_vsp
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_io_done
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_copy_sgl_to_bounce_buf
parameter_list|(
name|struct
name|sglist
modifier|*
name|bounce_sgl
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|orig_sgl
parameter_list|,
name|unsigned
name|int
name|orig_sgl_count
parameter_list|,
name|uint64_t
name|seg_bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|storvsc_copy_from_bounce_buf_to_sgl
parameter_list|(
name|bus_dma_segment_t
modifier|*
name|dest_sgl
parameter_list|,
name|unsigned
name|int
name|dest_sgl_count
parameter_list|,
name|struct
name|sglist
modifier|*
name|src_sgl
parameter_list|,
name|uint64_t
name|seg_bits
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|storvsc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|storvsc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|storvsc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|storvsc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|storvsc_driver
init|=
block|{
literal|"storvsc"
block|,
name|storvsc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|storvsc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|storvsc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|storvsc
argument_list|,
name|vmbus
argument_list|,
name|storvsc_driver
argument_list|,
name|storvsc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|storvsc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|storvsc
argument_list|,
name|vmbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|storvsc_subchan_attach
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|new_channel
parameter_list|)
block|{
name|struct
name|vmstor_chan_props
name|props
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|props
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
name|vmbus_chan_cpu_rr
argument_list|(
name|new_channel
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_open
argument_list|(
name|new_channel
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|props
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmstor_chan_props
argument_list|)
argument_list|,
name|hv_storvsc_on_channel_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Send multi-channel creation request to host  *  * @param device  a Hyper-V device pointer  * @param max_chans  the max channels supported by vmbus  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_send_multichannel_request
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|int
name|max_subch
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subchan
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|int
name|request_subch
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
comment|/* get sub-channel count that need to create */
name|request_subch
operator|=
name|MIN
argument_list|(
name|max_subch
argument_list|,
name|mp_ncpus
operator|-
literal|1
argument_list|)
expr_stmt|;
name|request
operator|=
operator|&
name|sc
operator|->
name|hs_init_req
expr_stmt|;
comment|/* request the host to create multi-channel */
name|memset
argument_list|(
name|request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|0
argument_list|,
operator|(
literal|"stor_synch_sema"
operator|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|=
operator|&
name|request
operator|->
name|vstor_packet
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_CREATE_MULTI_CHANNELS
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|multi_channels_cnt
operator|=
name|request_subch
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_send
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|VMBUS_CHANPKT_TYPE_INBAND
argument_list|,
name|VMBUS_CHANPKT_FLAG_RC
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|)
expr_stmt|;
name|sema_wait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc_error: create multi-channel invalid operation "
literal|"(%d) or statue (%u)\n"
argument_list|,
name|vstor_packet
operator|->
name|operation
argument_list|,
name|vstor_packet
operator|->
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Update channel count */
name|sc
operator|->
name|hs_nchan
operator|=
name|request_subch
operator|+
literal|1
expr_stmt|;
comment|/* Wait for sub-channels setup to complete. */
name|subchan
operator|=
name|vmbus_subchan_get
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|request_subch
argument_list|)
expr_stmt|;
comment|/* Attach the sub-channels. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|request_subch
condition|;
operator|++
name|i
control|)
name|storvsc_subchan_attach
argument_list|(
name|sc
argument_list|,
name|subchan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Release the sub-channels. */
name|vmbus_subchan_rel
argument_list|(
name|subchan
argument_list|,
name|request_subch
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Storvsc create multi-channel success!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief initialize channel connection to parent partition  *  * @param dev  a Hyper-V device pointer  * @returns  0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_channel_init
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|uint16_t
name|max_subch
decl_stmt|;
name|boolean_t
name|support_multichannel
decl_stmt|;
name|uint32_t
name|version
decl_stmt|;
name|max_subch
operator|=
literal|0
expr_stmt|;
name|support_multichannel
operator|=
name|FALSE
expr_stmt|;
name|request
operator|=
operator|&
name|sc
operator|->
name|hs_init_req
expr_stmt|;
name|memset
argument_list|(
name|request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|=
operator|&
name|request
operator|->
name|vstor_packet
expr_stmt|;
name|request
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
comment|/** 	 * Initiate the vsc/vsp initialization protocol on the open channel 	 */
name|sema_init
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|0
argument_list|,
operator|(
literal|"stor_synch_sema"
operator|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_BEGININITIALIZATION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_send
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|VMBUS_CHANPKT_TYPE_INBAND
argument_list|,
name|VMBUS_CHANPKT_FLAG_RC
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|sema_wait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|vmstor_proto_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* reuse the packet for version range supported */
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_QUERYPROTOCOLVERSION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|version
operator|.
name|major_minor
operator|=
name|vmstor_proto_list
index|[
name|i
index|]
operator|.
name|proto_version
expr_stmt|;
comment|/* revision is only significant for Windows guests */
name|vstor_packet
operator|->
name|u
operator|.
name|version
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_send
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|VMBUS_CHANPKT_TYPE_INBAND
argument_list|,
name|VMBUS_CHANPKT_FLAG_RC
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|sema_wait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|vstor_packet
operator|->
name|status
operator|==
literal|0
condition|)
block|{
name|vmstor_proto_version
operator|=
name|vmstor_proto_list
index|[
name|i
index|]
operator|.
name|proto_version
expr_stmt|;
name|sense_buffer_size
operator|=
name|vmstor_proto_list
index|[
name|i
index|]
operator|.
name|sense_buffer_size
expr_stmt|;
name|vmscsi_size_delta
operator|=
name|vmstor_proto_list
index|[
name|i
index|]
operator|.
name|vmscsi_size_delta
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/** 	 * Query channel properties 	 */
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_QUERYPROPERTIES
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_send
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|VMBUS_CHANPKT_TYPE_INBAND
argument_list|,
name|VMBUS_CHANPKT_FLAG_RC
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|sema_wait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
comment|/* TODO: Check returned version */
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|max_subch
operator|=
name|vstor_packet
operator|->
name|u
operator|.
name|chan_props
operator|.
name|max_channel_cnt
expr_stmt|;
if|if
condition|(
name|hv_storvsc_chan_cnt
operator|>
literal|0
operator|&&
name|hv_storvsc_chan_cnt
operator|<
operator|(
name|max_subch
operator|+
literal|1
operator|)
condition|)
name|max_subch
operator|=
name|hv_storvsc_chan_cnt
operator|-
literal|1
expr_stmt|;
comment|/* multi-channels feature is supported by WIN8 and above version */
name|version
operator|=
name|VMBUS_GET_VERSION
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|hs_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|VMBUS_VERSION_WIN7
operator|&&
name|version
operator|!=
name|VMBUS_VERSION_WS2008
operator|&&
operator|(
name|vstor_packet
operator|->
name|u
operator|.
name|chan_props
operator|.
name|flags
operator|&
name|HV_STORAGE_SUPPORTS_MULTI_CHANNEL
operator|)
condition|)
block|{
name|support_multichannel
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|,
literal|"max chans %d%s\n"
argument_list|,
name|max_subch
operator|+
literal|1
argument_list|,
name|support_multichannel
condition|?
literal|", multi-chan capable"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_ENDINITIALIZATION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_send
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|VMBUS_CHANPKT_TYPE_INBAND
argument_list|,
name|VMBUS_CHANPKT_FLAG_RC
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|sema_wait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * If multi-channel is supported, send multichannel create 	 * request to host. 	 */
if|if
condition|(
name|support_multichannel
operator|&&
name|max_subch
operator|>
literal|0
condition|)
name|storvsc_send_multichannel_request
argument_list|(
name|sc
argument_list|,
name|max_subch
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|sema_destroy
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Open channel connection to paraent partition StorVSP driver  *  * Open and initialize channel connection to parent partition StorVSP driver.  *  * @param pointer to a Hyper-V device  * @returns 0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_connect_vsp
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|vmstor_chan_props
name|props
decl_stmt|;
name|memset
argument_list|(
operator|&
name|props
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmstor_chan_props
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Open the channel 	 */
name|vmbus_chan_cpu_rr
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_open
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|props
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmstor_chan_props
argument_list|)
argument_list|,
name|hv_storvsc_on_channel_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|hv_storvsc_channel_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HVS_HOST_RESET
end_if

begin_function
specifier|static
name|int
name|hv_storvsc_host_reset
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|request
operator|=
operator|&
name|sc
operator|->
name|hs_reset_req
expr_stmt|;
name|request
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|vstor_packet
operator|=
operator|&
name|request
operator|->
name|vstor_packet
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|0
argument_list|,
literal|"stor synch sema"
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_RESETBUS
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_send
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|VMBUS_CHANPKT_TYPE_INBAND
argument_list|,
name|VMBUS_CHANPKT_FLAG_RC
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
call|(
name|uint64_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
operator|&
name|sc
operator|->
name|hs_reset_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|sema_wait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, all outstanding requests in the adapter 	 * should have been flushed out and return to us 	 */
name|cleanup
label|:
name|sema_destroy
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HVS_HOST_RESET */
end_comment

begin_comment
comment|/**  * @brief Function to initiate an I/O request  *  * @param device Hyper-V device pointer  * @param request pointer to a request structure  * @returns 0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_io_request
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
init|=
operator|&
name|request
operator|->
name|vstor_packet
decl_stmt|;
name|struct
name|vmbus_channel
modifier|*
name|outgoing_channel
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|ch_sel
decl_stmt|;
name|vstor_packet
operator|->
name|flags
operator||=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vmscsi_req
argument_list|)
operator|-
name|vmscsi_size_delta
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|sense_info_len
operator|=
name|sense_buffer_size
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|transfer_len
operator|=
name|request
operator|->
name|prp_list
operator|.
name|gpa_range
operator|.
name|gpa_len
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_EXECUTESRB
expr_stmt|;
name|ch_sel
operator|=
operator|(
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|lun
operator|+
name|curcpu
operator|)
operator|%
name|sc
operator|->
name|hs_nchan
expr_stmt|;
name|outgoing_channel
operator|=
name|sc
operator|->
name|hs_sel_chan
index|[
name|ch_sel
index|]
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|request
operator|->
name|softc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|prp_list
operator|.
name|gpa_range
operator|.
name|gpa_len
condition|)
block|{
name|ret
operator|=
name|vmbus_chan_send_prplist
argument_list|(
name|outgoing_channel
argument_list|,
operator|&
name|request
operator|->
name|prp_list
operator|.
name|gpa_range
argument_list|,
name|request
operator|->
name|prp_cnt
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|vmbus_chan_send
argument_list|(
name|outgoing_channel
argument_list|,
name|VMBUS_CHANPKT_TYPE_INBAND
argument_list|,
name|VMBUS_CHANPKT_FLAG_RC
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|)
expr_stmt|;
block|}
comment|/* statistic for successful request sending on each channel */
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|sc
operator|->
name|sysctl_data
operator|.
name|chan_send_cnt
index|[
name|ch_sel
index|]
operator|++
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|request
operator|->
name|softc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to send packet %p ret %d"
argument_list|,
name|vstor_packet
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomic_add_int
argument_list|(
operator|&
name|sc
operator|->
name|hs_num_out_reqs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Process IO_COMPLETION_OPERATION and ready  * the result to be completed for upper layer  * processing by the CAM layer.  */
end_comment

begin_function
specifier|static
name|void
name|hv_storvsc_on_iocompletion
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|vmscsi_req
modifier|*
name|vm_srb
decl_stmt|;
name|vm_srb
operator|=
operator|&
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
expr_stmt|;
comment|/* 	 * Copy some fields of the host's response into the request structure, 	 * because the fields will be used later in storvsc_io_done(). 	 */
name|request
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|scsi_status
operator|=
name|vm_srb
operator|->
name|scsi_status
expr_stmt|;
name|request
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|srb_status
operator|=
name|vm_srb
operator|->
name|srb_status
expr_stmt|;
name|request
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|transfer_len
operator|=
name|vm_srb
operator|->
name|transfer_len
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|vm_srb
operator|->
name|scsi_status
operator|&
literal|0xFF
operator|)
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
operator|&&
operator|(
name|vm_srb
operator|->
name|srb_status
operator|&
name|SRB_STATUS_AUTOSENSE_VALID
operator|)
condition|)
block|{
comment|/* Autosense data available */
name|KASSERT
argument_list|(
name|vm_srb
operator|->
name|sense_info_len
operator|<=
name|request
operator|->
name|sense_info_len
argument_list|,
operator|(
literal|"vm_srb->sense_info_len<= "
literal|"request->sense_info_len"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|request
operator|->
name|sense_data
argument_list|,
name|vm_srb
operator|->
name|u
operator|.
name|sense_data
argument_list|,
name|vm_srb
operator|->
name|sense_info_len
argument_list|)
expr_stmt|;
name|request
operator|->
name|sense_info_len
operator|=
name|vm_srb
operator|->
name|sense_info_len
expr_stmt|;
block|}
comment|/* Complete request by passing to the CAM layer */
name|storvsc_io_done
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sc
operator|->
name|hs_num_out_reqs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_drain_notify
operator|&&
operator|(
name|sc
operator|->
name|hs_num_out_reqs
operator|==
literal|0
operator|)
condition|)
block|{
name|sema_post
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hv_storvsc_rescan_target
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|path_id_t
name|pathid
decl_stmt|;
name|target_id_t
name|targetid
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|pathid
operator|=
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|)
expr_stmt|;
name|targetid
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
comment|/* 	 * Allocate a CCB and schedule a rescan. 	 */
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"unable to alloc CCB for rescan\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|pathid
argument_list|,
name|targetid
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"unable to create path for rescan, pathid: %u,"
literal|"targetid: %u\n"
argument_list|,
name|pathid
argument_list|,
name|targetid
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|targetid
operator|==
name|CAM_TARGET_WILDCARD
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_TGT
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_storvsc_on_channel_callback
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|uint32_t
name|bytes_recvd
decl_stmt|;
name|uint64_t
name|request_id
decl_stmt|;
name|uint8_t
name|packet
index|[
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
literal|8
argument_list|)
index|]
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|bytes_recvd
operator|=
name|roundup2
argument_list|(
name|VSTOR_PKT_SIZE
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_recv
argument_list|(
name|channel
argument_list|,
name|packet
argument_list|,
operator|&
name|bytes_recvd
argument_list|,
operator|&
name|request_id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
operator|!=
name|ENOBUFS
argument_list|,
operator|(
literal|"storvsc recvbuf is not large enough"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX check bytes_recvd to make sure that it contains enough data */
while|while
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bytes_recvd
operator|>
literal|0
operator|)
condition|)
block|{
name|request
operator|=
operator|(
expr|struct
name|hv_storvsc_request
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|request_id
expr_stmt|;
if|if
condition|(
operator|(
name|request
operator|==
operator|&
name|sc
operator|->
name|hs_init_req
operator|)
operator|||
operator|(
name|request
operator|==
operator|&
name|sc
operator|->
name|hs_reset_req
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|request
operator|->
name|vstor_packet
argument_list|,
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|sema_post
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vstor_packet
operator|=
operator|(
expr|struct
name|vstor_packet
operator|*
operator|)
name|packet
expr_stmt|;
switch|switch
condition|(
name|vstor_packet
operator|->
name|operation
condition|)
block|{
case|case
name|VSTOR_OPERATION_COMPLETEIO
case|:
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"VMBUS: storvsc received a "
literal|"packet with NULL request id in "
literal|"COMPLETEIO operation."
argument_list|)
expr_stmt|;
name|hv_storvsc_on_iocompletion
argument_list|(
name|sc
argument_list|,
name|vstor_packet
argument_list|,
name|request
argument_list|)
expr_stmt|;
break|break;
case|case
name|VSTOR_OPERATION_REMOVEDEVICE
case|:
name|printf
argument_list|(
literal|"VMBUS: storvsc operation %d not "
literal|"implemented.\n"
argument_list|,
name|vstor_packet
operator|->
name|operation
argument_list|)
expr_stmt|;
comment|/* TODO: implement */
break|break;
case|case
name|VSTOR_OPERATION_ENUMERATE_BUS
case|:
name|hv_storvsc_rescan_target
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|bytes_recvd
operator|=
name|roundup2
argument_list|(
name|VSTOR_PKT_SIZE
argument_list|,
literal|8
argument_list|)
operator|,
name|ret
operator|=
name|vmbus_chan_recv
argument_list|(
name|channel
argument_list|,
name|packet
argument_list|,
operator|&
name|bytes_recvd
argument_list|,
operator|&
name|request_id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
operator|!=
name|ENOBUFS
argument_list|,
operator|(
literal|"storvsc recvbuf is not large enough"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * XXX check bytes_recvd to make sure that it contains 		 * enough data 		 */
block|}
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC probe function  *  * Device probe function.  Returns 0 if the input device is a StorVSC  * device.  Otherwise, a ENXIO is returned.  If the input device is  * for BlkVSC (paravirtual IDE) device and this support is disabled in  * favor of the emulated ATA/IDE device, return ENXIO.  *  * @param a device  * @returns 0 on success, ENXIO if not a matcing StorVSC device  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
name|ENXIO
decl_stmt|;
switch|switch
condition|(
name|storvsc_get_storage_type
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|DRIVER_BLKVSC
case|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enlightened ATA/IDE detected\n"
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|g_drv_props_table
index|[
name|DRIVER_BLKVSC
index|]
operator|.
name|drv_desc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
break|break;
case|case
name|DRIVER_STORVSC
case|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enlightened SCSI device detected\n"
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|g_drv_props_table
index|[
name|DRIVER_STORVSC
index|]
operator|.
name|drv_desc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|storvsc_create_chan_sel
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsubch
decl_stmt|;
name|sc
operator|->
name|hs_sel_chan
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|hs_chan
expr_stmt|;
name|nsubch
operator|=
name|sc
operator|->
name|hs_nchan
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nsubch
operator|==
literal|0
condition|)
return|return;
name|subch
operator|=
name|vmbus_subchan_get
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|nsubch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsubch
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|hs_sel_chan
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|subch
index|[
name|i
index|]
expr_stmt|;
name|vmbus_subchan_rel
argument_list|(
name|subch
argument_list|,
name|nsubch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|storvsc_init_requests
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
name|PAGE_SIZE
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|STORVSC_DATA_SIZE_MAX
argument_list|,
comment|/* maxsize */
name|STORVSC_DATA_SEGCNT_MAX
argument_list|,
comment|/* nsegments */
name|STORVSC_DATA_SEGSZ_MAX
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|storvsc_req_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create storvsc dma tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
condition|;
operator|++
name|i
control|)
block|{
name|reqp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|storvsc_req_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|reqp
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate storvsc "
literal|"data dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|,
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
while|while
condition|(
operator|(
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|storvsc_req_dtag
argument_list|,
name|reqp
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|storvsc_sysctl
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|ch_tree
decl_stmt|,
modifier|*
name|chid_tree
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"data_bio_cnt"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sysctl_data
operator|.
name|data_bio_cnt
argument_list|,
literal|"# of bio data block"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"data_vaddr_cnt"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sysctl_data
operator|.
name|data_vaddr_cnt
argument_list|,
literal|"# of vaddr data block"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"data_sg_cnt"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sysctl_data
operator|.
name|data_sg_cnt
argument_list|,
literal|"# of sg data block"
argument_list|)
expr_stmt|;
comment|/* dev.storvsc.UNIT.channel */
name|ch_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"channel"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch_tree
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hs_nchan
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|ch_id
decl_stmt|;
name|ch_id
operator|=
name|vmbus_chan_id
argument_list|(
name|sc
operator|->
name|hs_sel_chan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ch_id
argument_list|)
expr_stmt|;
comment|/* dev.storvsc.UNIT.channel.CHID */
name|chid_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|ch_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|chid_tree
operator|==
name|NULL
condition|)
return|return;
comment|/* dev.storvsc.UNIT.channel.CHID.send_req */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chid_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"send_req"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sysctl_data
operator|.
name|chan_send_cnt
index|[
name|i
index|]
argument_list|,
literal|"# of request sending from this channel"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC attach function  *  * Function responsible for allocating per-device structures,  * setting up CAM interfaces and scanning for available LUNs to  * be used for SCSI device peripherals.  *  * @param a device  * @returns 0 on success or an error on failure  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|enum
name|hv_storage_type
name|stor_type
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
decl_stmt|;
name|struct
name|root_hold_token
modifier|*
name|root_mount_token
init|=
name|NULL
decl_stmt|;
name|struct
name|hv_sgl_node
modifier|*
name|sgl_node
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|tmp_buff
init|=
name|NULL
decl_stmt|;
comment|/* 	 * We need to serialize storvsc attach calls. 	 */
name|root_mount_token
operator|=
name|root_mount_hold
argument_list|(
literal|"storvsc"
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_nchan
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|hs_chan
operator|=
name|vmbus_get_channel
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|stor_type
operator|=
name|storvsc_get_storage_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|stor_type
operator|==
name|DRIVER_UNKNOWN
condition|)
block|{
name|ret
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* fill in driver specific properties */
name|sc
operator|->
name|hs_drv_props
operator|=
operator|&
name|g_drv_props_table
index|[
name|stor_type
index|]
expr_stmt|;
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
operator|=
name|hv_storvsc_ringbuffer_size
expr_stmt|;
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
operator|=
name|MIN
argument_list|(
name|STORVSC_MAX_IO
argument_list|,
name|hv_storvsc_max_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"storvsc ringbuffer size: %d, max_io: %d\n"
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
argument_list|)
expr_stmt|;
block|}
comment|/* fill in device specific properties */
name|sc
operator|->
name|hs_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
literal|"hvslck"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ret
operator|=
name|storvsc_init_requests
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* create sg-list page pool */
if|if
condition|(
name|FALSE
operator|==
name|g_hv_sgl_page_pool
operator|.
name|is_init
condition|)
block|{
name|g_hv_sgl_page_pool
operator|.
name|is_init
operator|=
name|TRUE
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|in_use_sgl_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
expr_stmt|;
comment|/* 		 * Pre-create SG list, each SG list with 		 * STORVSC_DATA_SEGCNT_MAX segments, each 		 * segment has one page buffer 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
condition|;
name|i
operator|++
control|)
block|{
name|sgl_node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hv_sgl_node
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sgl_node
operator|->
name|sgl_data
operator|=
name|sglist_alloc
argument_list|(
name|STORVSC_DATA_SEGCNT_MAX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|STORVSC_DATA_SEGCNT_MAX
condition|;
name|j
operator|++
control|)
block|{
name|tmp_buff
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
operator|=
operator|(
name|vm_paddr_t
operator|)
name|tmp_buff
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|,
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|hs_destroy
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|hs_drain_notify
operator|=
name|FALSE
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|,
literal|0
argument_list|,
literal|"Store Drain Sema"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hv_storvsc_connect_vsp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* Construct cpu to channel mapping */
name|storvsc_create_chan_sel
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Create the device queue. 	 * Hyper-V maps each target to one SCSI HBA 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to alloc device queue\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|sc
operator|->
name|hs_sim
operator|=
name|cam_sim_alloc
argument_list|(
name|storvsc_action
argument_list|,
name|storvsc_poll
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_name
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|hs_unit
argument_list|,
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_sim
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to alloc sim\n"
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
comment|/* bus_id is set to 0, need to get it from VMBUS channel query? */
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to register SCSI bus\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|sc
operator|->
name|hs_path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create path\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|storvsc_sysctl
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|root_mount_token
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|root_mount_rel
argument_list|(
name|root_mount_token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|storvsc_req_dtag
argument_list|,
name|reqp
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
condition|)
block|{
name|sgl_node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|STORVSC_DATA_SEGCNT_MAX
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|void
operator|*
operator|)
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|sglist_free
argument_list|(
name|sgl_node
operator|->
name|sgl_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgl_node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC device detach function  *  * This function is responsible for safely detaching a  * StorVSC device.  This includes waiting for inbound responses  * to complete and freeing associated per-device structures.  *  * @param dev a device  * returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|NULL
decl_stmt|;
name|struct
name|hv_sgl_node
modifier|*
name|sgl_node
init|=
name|NULL
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|hs_destroy
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * At this point, all outbound traffic should be disabled. We 	 * only allow inbound traffic (responses) to proceed so that 	 * outstanding requests can be completed. 	 */
name|sc
operator|->
name|hs_drain_notify
operator|=
name|TRUE
expr_stmt|;
name|sema_wait
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_drain_notify
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Since we have already drained, we don't need to busy wait. 	 * The call to close the channel will reset the callback 	 * under the protection of the incoming channel lock. 	 */
name|vmbus_chan_close
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|storvsc_req_dtag
argument_list|,
name|reqp
operator|->
name|data_dmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
condition|)
block|{
name|sgl_node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|STORVSC_DATA_SEGCNT_MAX
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|void
operator|*
operator|)
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|sglist_free
argument_list|(
name|sgl_node
operator|->
name|sgl_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgl_node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HVS_TIMEOUT_TEST
end_if

begin_comment
comment|/**  * @brief unit test for timed out operations  *  * This function provides unit testing capability to simulate  * timed out operations.  Recompilation with HV_TIMEOUT_TEST=1  * is required.  *  * @param reqp pointer to a request structure  * @param opcode SCSI operation being performed  * @param wait if 1, wait for I/O to complete  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_timeout_test
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
if|if
condition|(
name|reqp
operator|->
name|vstor_packet
operator|.
name|vm_srb
operator|.
name|cdb
index|[
literal|0
index|]
operator|!=
name|opcode
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|wait
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|hv_storvsc_io_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|wait
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: io_request failed with %d.\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wait
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: waiting for IO return.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|,
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: %s.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|,
operator|(
name|ret
operator|==
literal|0
operator|)
condition|?
literal|"IO return detected"
else|:
literal|"IO return not detected"
argument_list|)
expr_stmt|;
comment|/* 		 * Now both the timer handler and io done are running 		 * simultaneously. We want to confirm the io done always 		 * finishes after the timer handler exits. So reqp used by 		 * timer handler is not freed or stale. Do busy loop for 		 * another 1/10 second to make sure io done does 		 * wait for the timer handler to complete. 		 */
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: finishing, queue frozen %d, "
literal|"ccb status 0x%x scsi_status 0x%x.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|hs_frozen
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HVS_TIMEOUT_TEST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/**  * @brief timeout handler for requests  *  * This function is called as a result of a callout expiring.  *  * @param arg pointer to a request  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|arg
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
if|if
condition|(
name|reqp
operator|->
name|retries
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO timed out (req=0x%p), wait for another %u secs.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|retries
operator|++
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
name|SBT_1MS
operator|*
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
literal|0
argument_list|,
name|storvsc_timeout
argument_list|,
name|reqp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|storvsc_timeout_test
argument_list|(
name|reqp
argument_list|,
name|SEND_DIAGNOSTIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO (reqp = 0x%p) did not return for %u seconds, %s.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
operator|(
name|reqp
operator|->
name|retries
operator|+
literal|1
operator|)
operator|/
literal|1000
argument_list|,
operator|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
operator|)
condition|?
literal|"freezing the queue"
else|:
literal|"the queue is already frozen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hs_frozen
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|storvsc_timeout_test
argument_list|(
name|reqp
argument_list|,
name|MODE_SELECT_10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @brief StorVSC device poll function  *  * This function is responsible for servicing requests when  * interrupts are disabled (i.e when we are dumping core.)  *  * @param sim a pointer to a CAM SCSI interface module  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|hv_storvsc_on_channel_callback
argument_list|(
name|sc
operator|->
name|hs_chan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC device action function  *  * This function is responsible for handling SCSI operations which  * are passed from the CAM layer.  The requests are in the form of  * CAM control blocks which indicate the action being performed.  * Not all actions require converting the request to a VSCSI protocol  * message - these actions can be responded to by this driver.  * Requests which are destined for a backend storage device are converted  * to a VSCSI protocol message and sent on the channel connection associated  * with this device.  *  * @param sim pointer to a CAM SCSI interface module  * @param ccb pointer to a CAM control block  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|int
name|res
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
operator||
name|PI_SDTR_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
if|if
condition|(
name|hv_storvsc_use_pim_unmapped
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_UNMAPPED
expr_stmt|;
name|cpi
operator|->
name|maxio
operator|=
name|STORVSC_DATA_SIZE_MAX
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|STORVSC_MAX_TARGETS
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_luns_per_target
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|cpi
operator|->
name|max_target
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|300000
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_name
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
comment|/* enable tag queuing and disconnected mode */
name|cts
operator|->
name|proto_specific
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
operator|.
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|valid
operator|=
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
if|#
directive|if
name|HVS_HOST_RESET
if|if
condition|(
operator|(
name|res
operator|=
name|hv_storvsc_host_reset
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"hv_storvsc_host_reset failed with %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%s reset not supported.\n"
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_BUS
operator|)
condition|?
literal|"bus"
else|:
literal|"dev"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* HVS_HOST_RESET */
block|}
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|NULL
decl_stmt|;
name|bus_dmamap_t
name|dmap_saved
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"cdl_len is 0\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hs_frozen
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/* count*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* Save the data_dmap before reset request */
name|dmap_saved
operator|=
name|reqp
operator|->
name|data_dmap
expr_stmt|;
comment|/* XXX this is ugly */
name|bzero
argument_list|(
name|reqp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore necessary bits */
name|reqp
operator|->
name|data_dmap
operator|=
name|dmap_saved
expr_stmt|;
name|reqp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|create_storvsc_request
argument_list|(
name|ccb
argument_list|,
name|reqp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|callout_init
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
name|SBT_1MS
operator|*
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
literal|0
argument_list|,
name|storvsc_timeout
argument_list|,
name|reqp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|cv_init
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|,
literal|"storvsc timeout cv"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|,
literal|"storvsc timeout mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reqp
operator|->
name|vstor_packet
operator|.
name|vm_srb
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SELECT_10
case|:
case|case
name|SEND_DIAGNOSTIC
case|:
comment|/* To have timer send the request. */
return|return;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* HVS_TIMEOUT_TEST */
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|res
operator|=
name|hv_storvsc_io_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"hv_storvsc_io_request failed with %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief destroy bounce buffer  *  * This function is responsible for destroy a Scatter/Gather list  * that create by storvsc_create_bounce_buffer()  *  * @param sgl- the Scatter/Gather need be destroy  * @param sg_count- page count of the SG list.  *  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_destroy_bounce_buffer
parameter_list|(
name|struct
name|sglist
modifier|*
name|sgl
parameter_list|)
block|{
name|struct
name|hv_sgl_node
modifier|*
name|sgl_node
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|in_use_sgl_list
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"storvsc error: not enough in use sgl\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sgl_node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|in_use_sgl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sgl_node
operator|->
name|sgl_data
operator|=
name|sgl
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|,
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief create bounce buffer  *  * This function is responsible for create a Scatter/Gather list,  * which hold several pages that can be aligned with page size.  *  * @param seg_count- SG-list segments count  * @param write - if WRITE_TYPE, set SG list page used size to 0,  * otherwise set used size to page size.  *  * return NULL if create failed  */
end_comment

begin_function
specifier|static
name|struct
name|sglist
modifier|*
name|storvsc_create_bounce_buffer
parameter_list|(
name|uint16_t
name|seg_count
parameter_list|,
name|int
name|write
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|sglist
modifier|*
name|bounce_sgl
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|buf_len
init|=
operator|(
operator|(
name|write
operator|==
name|WRITE_TYPE
operator|)
condition|?
literal|0
else|:
name|PAGE_SIZE
operator|)
decl_stmt|;
name|struct
name|hv_sgl_node
modifier|*
name|sgl_node
init|=
name|NULL
decl_stmt|;
comment|/* get struct sglist from free_sgl_list */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"storvsc error: not enough free sgl\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sgl_node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bounce_sgl
operator|=
name|sgl_node
operator|->
name|sgl_data
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|in_use_sgl_list
argument_list|,
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bounce_sgl
operator|->
name|sg_maxseg
operator|=
name|seg_count
expr_stmt|;
if|if
condition|(
name|write
operator|==
name|WRITE_TYPE
condition|)
name|bounce_sgl
operator|->
name|sg_nseg
operator|=
literal|0
expr_stmt|;
else|else
name|bounce_sgl
operator|->
name|sg_nseg
operator|=
name|seg_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seg_count
condition|;
name|i
operator|++
control|)
name|bounce_sgl
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
operator|=
name|buf_len
expr_stmt|;
return|return
name|bounce_sgl
return|;
block|}
end_function

begin_comment
comment|/**  * @brief copy data from SG list to bounce buffer  *  * This function is responsible for copy data from one SG list's segments  * to another SG list which used as bounce buffer.  *  * @param bounce_sgl - the destination SG list  * @param orig_sgl - the segment of the source SG list.  * @param orig_sgl_count - the count of segments.  * @param orig_sgl_count - indicate which segment need bounce buffer,  *  set 1 means need.  *  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_copy_sgl_to_bounce_buf
parameter_list|(
name|struct
name|sglist
modifier|*
name|bounce_sgl
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|orig_sgl
parameter_list|,
name|unsigned
name|int
name|orig_sgl_count
parameter_list|,
name|uint64_t
name|seg_bits
parameter_list|)
block|{
name|int
name|src_sgl_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|src_sgl_idx
operator|=
literal|0
init|;
name|src_sgl_idx
operator|<
name|orig_sgl_count
condition|;
name|src_sgl_idx
operator|++
control|)
block|{
if|if
condition|(
name|seg_bits
operator|&
operator|(
literal|1
operator|<<
name|src_sgl_idx
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bounce_sgl
operator|->
name|sg_segs
index|[
name|src_sgl_idx
index|]
operator|.
name|ss_paddr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|orig_sgl
index|[
name|src_sgl_idx
index|]
operator|.
name|ds_addr
argument_list|,
name|orig_sgl
index|[
name|src_sgl_idx
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|bounce_sgl
operator|->
name|sg_segs
index|[
name|src_sgl_idx
index|]
operator|.
name|ss_len
operator|=
name|orig_sgl
index|[
name|src_sgl_idx
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief copy data from SG list which used as bounce to another SG list  *  * This function is responsible for copy data from one SG list with bounce  * buffer to another SG list's segments.  *  * @param dest_sgl - the destination SG list's segments  * @param dest_sgl_count - the count of destination SG list's segment.  * @param src_sgl - the source SG list.  * @param seg_bits - indicate which segment used bounce buffer of src SG-list.  *  */
end_comment

begin_function
name|void
name|storvsc_copy_from_bounce_buf_to_sgl
parameter_list|(
name|bus_dma_segment_t
modifier|*
name|dest_sgl
parameter_list|,
name|unsigned
name|int
name|dest_sgl_count
parameter_list|,
name|struct
name|sglist
modifier|*
name|src_sgl
parameter_list|,
name|uint64_t
name|seg_bits
parameter_list|)
block|{
name|int
name|sgl_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sgl_idx
operator|=
literal|0
init|;
name|sgl_idx
operator|<
name|dest_sgl_count
condition|;
name|sgl_idx
operator|++
control|)
block|{
if|if
condition|(
name|seg_bits
operator|&
operator|(
literal|1
operator|<<
name|sgl_idx
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|dest_sgl
index|[
name|sgl_idx
index|]
operator|.
name|ds_addr
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|src_sgl
operator|->
name|sg_segs
index|[
name|sgl_idx
index|]
operator|.
name|ss_paddr
operator|)
argument_list|,
name|src_sgl
operator|->
name|sg_segs
index|[
name|sgl_idx
index|]
operator|.
name|ss_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief check SG list with bounce buffer or not  *  * This function is responsible for check if need bounce buffer for SG list.  *  * @param sgl - the SG list's segments  * @param sg_count - the count of SG list's segment.  * @param bits - segmengs number that need bounce buffer  *  * return -1 if SG list needless bounce buffer  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_check_bounce_buffer_sgl
parameter_list|(
name|bus_dma_segment_t
modifier|*
name|sgl
parameter_list|,
name|unsigned
name|int
name|sg_count
parameter_list|,
name|uint64_t
modifier|*
name|bits
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|uint64_t
name|phys_addr
init|=
literal|0
decl_stmt|;
name|uint64_t
name|tmp_bits
init|=
literal|0
decl_stmt|;
name|boolean_t
name|found_hole
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|pre_aligned
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|sg_count
operator|<
literal|2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|bits
operator|=
literal|0
expr_stmt|;
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|sgl
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|phys_addr
operator|-
name|trunc_page
argument_list|(
name|phys_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|pre_aligned
operator|=
name|FALSE
expr_stmt|;
name|tmp_bits
operator||=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|sgl
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|phys_addr
operator|-
name|trunc_page
argument_list|(
name|phys_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|FALSE
operator|==
name|pre_aligned
condition|)
block|{
comment|/* 				 * This segment is aligned, if the previous 				 * one is not aligned, find a hole 				 */
name|found_hole
operator|=
name|TRUE
expr_stmt|;
block|}
name|pre_aligned
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|tmp_bits
operator||=
literal|1ULL
operator|<<
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|pre_aligned
condition|)
block|{
if|if
condition|(
name|phys_addr
operator|!=
name|vtophys
argument_list|(
name|sgl
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
operator|+
name|sgl
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_len
argument_list|)
condition|)
block|{
comment|/* 					 * Check whether connect to previous 					 * segment,if not, find the hole 					 */
name|found_hole
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|found_hole
operator|=
name|TRUE
expr_stmt|;
block|}
name|pre_aligned
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found_hole
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|*
name|bits
operator|=
name|tmp_bits
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Copy bus_dma segments to multiple page buffer, which requires  * the pages are compact composed except for the 1st and last pages.  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_xferbuf_prepare
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|arg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|storvsc_gpa_range
modifier|*
name|prplist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|prplist
operator|=
operator|&
name|reqp
operator|->
name|prp_list
expr_stmt|;
name|prplist
operator|->
name|gpa_range
operator|.
name|gpa_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|prplist
operator|->
name|gpa_range
operator|.
name|gpa_ofs
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|&
name|PAGE_MASK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|nsegs
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|&
name|PAGE_MASK
operator|)
operator|+
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|==
name|PAGE_SIZE
argument_list|,
operator|(
literal|"invalid 1st page, ofs 0x%jx, len %zu"
operator|,
operator|(
name|uintmax_t
operator|)
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|nsegs
operator|-
literal|1
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid last page, ofs 0x%jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
operator|&&
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|==
name|PAGE_SIZE
argument_list|,
operator|(
literal|"not a full page, ofs 0x%jx, len %zu"
operator|,
operator|(
name|uintmax_t
operator|)
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|prplist
operator|->
name|gpa_page
index|[
name|i
index|]
operator|=
name|atop
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
name|reqp
operator|->
name|prp_cnt
operator|=
name|nsegs
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Fill in a request structure based on a CAM control block  *  * Fills in a request structure based on the contents of a CAM control  * block.  The request structure holds the payload information for  * VSCSI protocol request.  *  * @param ccb pointer to a CAM contorl block  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|int
name|create_storvsc_request
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|uint64_t
name|phys_addr
decl_stmt|;
name|uint32_t
name|pfn
decl_stmt|;
name|uint64_t
name|not_aligned_seg_bits
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* refer to struct vmscsi_req for meanings of these two fields */
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|port
operator|=
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|path_id
operator|=
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|cdb_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|u
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|u
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hv_storvsc_use_win8ext_flags
condition|)
block|{
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|win8_extension
operator|.
name|time_out_value
operator|=
literal|60
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|win8_extension
operator|.
name|srb_flags
operator||=
name|SRB_FLAGS_DISABLE_SYNCH_TRANSFER
expr_stmt|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_OUT
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|WRITE_TYPE
expr_stmt|;
if|if
condition|(
name|hv_storvsc_use_win8ext_flags
condition|)
block|{
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|win8_extension
operator|.
name|srb_flags
operator||=
name|SRB_FLAGS_DATA_OUT
expr_stmt|;
block|}
break|break;
case|case
name|CAM_DIR_IN
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|READ_TYPE
expr_stmt|;
if|if
condition|(
name|hv_storvsc_use_win8ext_flags
condition|)
block|{
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|win8_extension
operator|.
name|srb_flags
operator||=
name|SRB_FLAGS_DATA_IN
expr_stmt|;
block|}
break|break;
case|case
name|CAM_DIR_NONE
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|UNKNOWN_TYPE
expr_stmt|;
if|if
condition|(
name|hv_storvsc_use_win8ext_flags
condition|)
block|{
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|win8_extension
operator|.
name|srb_flags
operator||=
name|SRB_FLAGS_NO_DATA_TRANSFER
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"Error: unexpected data direction: 0x%x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|reqp
operator|->
name|sense_data
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|reqp
operator|->
name|sense_info_len
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
name|reqp
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|csio
operator|->
name|dxfer_len
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
condition|)
block|{
case|case
name|CAM_DATA_BIO
case|:
case|case
name|CAM_DATA_VADDR
case|:
name|error
operator|=
name|bus_dmamap_load_ccb
argument_list|(
name|reqp
operator|->
name|softc
operator|->
name|storvsc_req_dtag
argument_list|,
name|reqp
operator|->
name|data_dmap
argument_list|,
name|ccb
argument_list|,
name|storvsc_xferbuf_prepare
argument_list|,
name|reqp
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"bus_dmamap_load_ccb failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
operator|==
name|CAM_DATA_BIO
condition|)
name|reqp
operator|->
name|softc
operator|->
name|sysctl_data
operator|.
name|data_bio_cnt
operator|++
expr_stmt|;
else|else
name|reqp
operator|->
name|softc
operator|->
name|sysctl_data
operator|.
name|data_vaddr_cnt
operator|++
expr_stmt|;
break|break;
case|case
name|CAM_DATA_SG
case|:
block|{
name|struct
name|storvsc_gpa_range
modifier|*
name|prplist
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|storvsc_sglist
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
name|u_int16_t
name|storvsc_sg_count
init|=
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
decl_stmt|;
name|prplist
operator|=
operator|&
name|reqp
operator|->
name|prp_list
expr_stmt|;
name|prplist
operator|->
name|gpa_range
operator|.
name|gpa_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|printf
argument_list|(
literal|"Storvsc: get SG I/O operation, %d\n"
argument_list|,
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|storvsc_sg_count
operator|>
name|STORVSC_DATA_SEGCNT_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc: %d segments is too much, "
literal|"only support %d segments\n"
argument_list|,
name|storvsc_sg_count
argument_list|,
name|STORVSC_DATA_SEGCNT_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * We create our own bounce buffer function currently. Idealy 		 * we should use BUS_DMA(9) framework. But with current BUS_DMA 		 * code there is no callback API to check the page alignment of 		 * middle segments before busdma can decide if a bounce buffer 		 * is needed for particular segment. There is callback, 		 * "bus_dma_filter_t *filter", but the parrameters are not 		 * sufficient for storvsc driver. 		 * TODO: 		 *	Add page alignment check in BUS_DMA(9) callback. Once 		 *	this is complete, switch the following code to use 		 *	BUS_DMA(9) for storvsc bounce buffer support. 		 */
comment|/* check if we need to create bounce buffer */
name|ret
operator|=
name|storvsc_check_bounce_buffer_sgl
argument_list|(
name|storvsc_sglist
argument_list|,
name|storvsc_sg_count
argument_list|,
operator|&
name|not_aligned_seg_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
name|reqp
operator|->
name|bounce_sgl
operator|=
name|storvsc_create_bounce_buffer
argument_list|(
name|storvsc_sg_count
argument_list|,
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|reqp
operator|->
name|bounce_sgl
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc_error: "
literal|"create bounce buffer failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|reqp
operator|->
name|bounce_sgl_count
operator|=
name|storvsc_sg_count
expr_stmt|;
name|reqp
operator|->
name|not_aligned_seg_bits
operator|=
name|not_aligned_seg_bits
expr_stmt|;
comment|/* 			 * if it is write, we need copy the original data 			 *to bounce buffer 			 */
if|if
condition|(
name|WRITE_TYPE
operator|==
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
condition|)
block|{
name|storvsc_copy_sgl_to_bounce_buf
argument_list|(
name|reqp
operator|->
name|bounce_sgl
argument_list|,
name|storvsc_sglist
argument_list|,
name|storvsc_sg_count
argument_list|,
name|reqp
operator|->
name|not_aligned_seg_bits
argument_list|)
expr_stmt|;
block|}
comment|/* transfer virtual address to physical frame number */
if|if
condition|(
name|reqp
operator|->
name|not_aligned_seg_bits
operator|&
literal|0x1
condition|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|reqp
operator|->
name|bounce_sgl
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_paddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
name|prplist
operator|->
name|gpa_range
operator|.
name|gpa_ofs
operator|=
name|phys_addr
operator|&
name|PAGE_MASK
expr_stmt|;
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|prplist
operator|->
name|gpa_page
index|[
literal|0
index|]
operator|=
name|pfn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|storvsc_sg_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reqp
operator|->
name|not_aligned_seg_bits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|reqp
operator|->
name|bounce_sgl
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_paddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|prplist
operator|->
name|gpa_page
index|[
name|i
index|]
operator|=
name|pfn
expr_stmt|;
block|}
name|reqp
operator|->
name|prp_cnt
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|prplist
operator|->
name|gpa_range
operator|.
name|gpa_ofs
operator|=
name|phys_addr
operator|&
name|PAGE_MASK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|storvsc_sg_count
condition|;
name|i
operator|++
control|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|prplist
operator|->
name|gpa_page
index|[
name|i
index|]
operator|=
name|pfn
expr_stmt|;
block|}
name|reqp
operator|->
name|prp_cnt
operator|=
name|i
expr_stmt|;
comment|/* check the last segment cross boundary or not */
name|offset
operator|=
name|phys_addr
operator|&
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
comment|/* Add one more PRP entry */
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
operator|+
name|PAGE_SIZE
operator|-
name|offset
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|prplist
operator|->
name|gpa_page
index|[
name|i
index|]
operator|=
name|pfn
expr_stmt|;
name|reqp
operator|->
name|prp_cnt
operator|++
expr_stmt|;
block|}
name|reqp
operator|->
name|bounce_sgl_count
operator|=
literal|0
expr_stmt|;
block|}
name|reqp
operator|->
name|softc
operator|->
name|sysctl_data
operator|.
name|data_sg_cnt
operator|++
expr_stmt|;
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"Unknow flags: %d\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|is_scsi_valid
parameter_list|(
specifier|const
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
name|u_int8_t
name|type
decl_stmt|;
name|type
operator|=
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_NODEVICE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|SID_QUAL
argument_list|(
name|inq_data
argument_list|)
operator|==
name|SID_QUAL_BAD_LU
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief completion function before returning to CAM  *  * I/O process has been completed and the result needs  * to be passed to the CAM layer.  * Free resources related to this request.  *  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_io_done
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
name|struct
name|vmscsi_req
modifier|*
name|vm_srb
init|=
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|ori_sglist
init|=
name|NULL
decl_stmt|;
name|int
name|ori_sg_count
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|scsi_generic
modifier|*
name|cmd
decl_stmt|;
comment|/* destroy bounce buffer if it is used */
if|if
condition|(
name|reqp
operator|->
name|bounce_sgl_count
condition|)
block|{
name|ori_sglist
operator|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|ori_sg_count
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
expr_stmt|;
comment|/* 		 * If it is READ operation, we should copy back the data 		 * to original SG list. 		 */
if|if
condition|(
name|READ_TYPE
operator|==
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
condition|)
block|{
name|storvsc_copy_from_bounce_buf_to_sgl
argument_list|(
name|ori_sglist
argument_list|,
name|ori_sg_count
argument_list|,
name|reqp
operator|->
name|bounce_sgl
argument_list|,
name|reqp
operator|->
name|not_aligned_seg_bits
argument_list|)
expr_stmt|;
block|}
name|storvsc_destroy_bounce_buffer
argument_list|(
name|reqp
operator|->
name|bounce_sgl
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|bounce_sgl_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|reqp
operator|->
name|retries
operator|>
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO returned after timeout, "
literal|"waking up timer handler if any.\n"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reqp
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO returned after timeout, "
literal|"stopping timer if any.\n"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * callout_drain() will wait for the timer handler to finish 	 * if it is running. So we don't need any lock to synchronize 	 * between this routine and the timer handler. 	 * Note that we need to make sure reqp is not freed when timer 	 * handler is using or will use it. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|callout_drain
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cmd
operator|=
operator|(
specifier|const
expr|struct
name|scsi_generic
operator|*
operator|)
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
operator|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|int
name|srb_status
init|=
name|SRB_STATUS
argument_list|(
name|vm_srb
operator|->
name|srb_status
argument_list|)
decl_stmt|;
if|if
condition|(
name|vm_srb
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_OK
condition|)
block|{
if|if
condition|(
name|srb_status
operator|!=
name|SRB_STATUS_SUCCESS
condition|)
block|{
comment|/* 			 * If there are errors, for example, invalid LUN, 			 * host will inform VM through SRB status. 			 */
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|srb_status
operator|==
name|SRB_STATUS_INVALID_LUN
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"invalid LUN %d for op: %s\n"
argument_list|,
name|vm_srb
operator|->
name|lun
argument_list|,
name|scsi_op_desc
argument_list|(
name|cmd
operator|->
name|opcode
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"Unknown SRB flag: %d for op: %s\n"
argument_list|,
name|srb_status
argument_list|,
name|scsi_op_desc
argument_list|(
name|cmd
operator|->
name|opcode
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * XXX For a selection timeout, all of the LUNs 			 * on the target will be gone.  It works for SCSI 			 * disks, but does not work for IDE disks. 			 * 			 * For CAM_DEV_NOT_THERE, CAM will only get 			 * rid of the device(s) specified by the path. 			 */
if|if
condition|(
name|storvsc_get_storage_type
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|)
operator|==
name|DRIVER_STORVSC
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|==
name|INQUIRY
operator|&&
name|srb_status
operator|==
name|SRB_STATUS_SUCCESS
condition|)
block|{
name|int
name|resp_xfer_len
decl_stmt|,
name|resp_buf_len
decl_stmt|,
name|data_len
decl_stmt|;
name|uint8_t
modifier|*
name|resp_buf
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|csio
operator|->
name|data_ptr
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
init|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|csio
operator|->
name|data_ptr
decl_stmt|;
comment|/* Get the buffer length reported by host */
name|resp_xfer_len
operator|=
name|vm_srb
operator|->
name|transfer_len
expr_stmt|;
comment|/* Get the available buffer length */
name|resp_buf_len
operator|=
name|resp_xfer_len
operator|>=
literal|5
condition|?
name|resp_buf
index|[
literal|4
index|]
operator|+
literal|5
else|:
literal|0
expr_stmt|;
name|data_len
operator|=
operator|(
name|resp_buf_len
operator|<
name|resp_xfer_len
operator|)
condition|?
name|resp_buf_len
else|:
name|resp_xfer_len
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|data_len
operator|>=
literal|5
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"storvsc inquiry "
literal|"(%d) [%x %x %x %x %x ... ]\n"
argument_list|,
name|data_len
argument_list|,
name|resp_buf
index|[
literal|0
index|]
argument_list|,
name|resp_buf
index|[
literal|1
index|]
argument_list|,
name|resp_buf
index|[
literal|2
index|]
argument_list|,
name|resp_buf
index|[
literal|3
index|]
argument_list|,
name|resp_buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * XXX: Hyper-V (since win2012r2) responses inquiry with 			 * unknown version (0) for GEN-2 DVD device. 			 * Manually set the version number to SPC3 in order to 			 * ask CAM to continue probing with "PROBE_REPORT_LUNS". 			 * see probedone() in scsi_xpt.c 			 */
if|if
condition|(
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
operator|==
name|T_CDROM
operator|&&
name|inq_data
operator|->
name|version
operator|==
literal|0
operator|&&
operator|(
name|vmstor_proto_version
operator|>=
name|VMSTOR_PROTOCOL_VERSION_WIN8
operator|)
condition|)
block|{
name|inq_data
operator|->
name|version
operator|=
name|SCSI_REV_SPC3
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"set version from 0 to %d\n"
argument_list|,
name|inq_data
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * XXX: Manually fix the wrong response returned from WS2012 			 */
if|if
condition|(
operator|!
name|is_scsi_valid
argument_list|(
name|inq_data
argument_list|)
operator|&&
operator|(
name|vmstor_proto_version
operator|==
name|VMSTOR_PROTOCOL_VERSION_WIN8_1
operator|||
name|vmstor_proto_version
operator|==
name|VMSTOR_PROTOCOL_VERSION_WIN8
operator|||
name|vmstor_proto_version
operator|==
name|VMSTOR_PROTOCOL_VERSION_WIN7
operator|)
condition|)
block|{
if|if
condition|(
name|data_len
operator|>=
literal|4
operator|&&
operator|(
name|resp_buf
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|resp_buf
index|[
literal|3
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|resp_buf
index|[
literal|2
index|]
operator|=
name|SCSI_REV_SPC3
expr_stmt|;
name|resp_buf
index|[
literal|3
index|]
operator|=
literal|2
expr_stmt|;
comment|// resp fmt must be 2
if|if
condition|(
name|bootverbose
condition|)
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"fix version and resp fmt for 0x%x\n"
argument_list|,
name|vmstor_proto_version
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|data_len
operator|>=
name|SHORT_INQUIRY_LENGTH
condition|)
block|{
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|;
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|inq_data
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * XXX: Upgrade SPC2 to SPC3 if host is WIN8 or 				 * WIN2012 R2 in order to support UNMAP feature. 				 */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|vendor
argument_list|,
literal|"Msft"
argument_list|,
literal|4
argument_list|)
operator|&&
name|SID_ANSI_REV
argument_list|(
name|inq_data
argument_list|)
operator|==
name|SCSI_REV_SPC2
operator|&&
operator|(
name|vmstor_proto_version
operator|==
name|VMSTOR_PROTOCOL_VERSION_WIN8_1
operator|||
name|vmstor_proto_version
operator|==
name|VMSTOR_PROTOCOL_VERSION_WIN8
operator|)
condition|)
block|{
name|inq_data
operator|->
name|version
operator|=
name|SCSI_REV_SPC3
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"storvsc upgrades "
literal|"SPC2 to SPC3\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|/** 		 * On Some Windows hosts TEST_UNIT_READY command can return 		 * SRB_STATUS_ERROR and sense data, for example, asc=0x3a,1 		 * "(Medium not present - tray closed)". This error can be 		 * ignored since it will be sent to host periodically. 		 */
name|boolean_t
name|unit_not_ready
init|= \
name|vm_srb
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|&&
name|cmd
operator|->
name|opcode
operator|==
name|TEST_UNIT_READY
operator|&&
name|srb_status
operator|==
name|SRB_STATUS_ERROR
decl_stmt|;
if|if
condition|(
operator|!
name|unit_not_ready
operator|&&
name|bootverbose
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"storvsc scsi_status = %d, srb_status = %d\n"
argument_list|,
name|vm_srb
operator|->
name|scsi_status
argument_list|,
name|srb_status
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
operator|(
name|vm_srb
operator|->
name|scsi_status
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|vm_srb
operator|->
name|transfer_len
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|sense_info_len
operator|!=
literal|0
condition|)
block|{
name|csio
operator|->
name|sense_resid
operator|=
name|csio
operator|->
name|sense_len
operator|-
name|reqp
operator|->
name|sense_info_len
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|softc
operator|->
name|hs_frozen
operator|==
literal|1
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: storvsc unfreezing softc 0x%p.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
operator|->
name|softc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|reqp
operator|->
name|softc
operator|->
name|hs_frozen
operator|=
literal|0
expr_stmt|;
block|}
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_done_direct
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Free a request structure  *  * Free a request structure by returning it to the free list  *  * @param sc pointer to a softc  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_free_request
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|,
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Determine type of storage device from GUID  *  * Using the type GUID, determine if this is a StorVSC (paravirtual  * SCSI or BlkVSC (paravirtual IDE) device.  *  * @param dev a device  * returns an enum  */
end_comment

begin_function
specifier|static
name|enum
name|hv_storage_type
name|storvsc_get_storage_type
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|parent
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|VMBUS_PROBE_GUID
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
operator|&
name|gBlkVscDeviceType
argument_list|)
operator|==
literal|0
condition|)
return|return
name|DRIVER_BLKVSC
return|;
if|if
condition|(
name|VMBUS_PROBE_GUID
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
operator|&
name|gStorVscDeviceType
argument_list|)
operator|==
literal|0
condition|)
return|return
name|DRIVER_STORVSC
return|;
return|return
name|DRIVER_UNKNOWN
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PCI_VENDOR_INTEL
value|0x8086
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_PIIX4
value|0x7111
end_define

begin_function
specifier|static
name|void
name|storvsc_ada_probe_veto
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|struct
name|ata_params
modifier|*
name|ident_buf
name|__unused
parameter_list|,
name|int
modifier|*
name|veto
parameter_list|)
block|{
comment|/* 	 * The ATA disks are shared with the controllers managed 	 * by this driver, so veto the ATA disks' attachment; the 	 * ATA disks will be attached as SCSI disks once this driver 	 * attached. 	 */
if|if
condition|(
name|path
operator|->
name|device
operator|->
name|protocol
operator|==
name|PROTO_ATA
condition|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|cpi
argument_list|,
sizeof|sizeof
argument_list|(
name|cpi
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cpi
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NONE
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|&&
name|cpi
operator|.
name|hba_vendor
operator|==
name|PCI_VENDOR_INTEL
operator|&&
name|cpi
operator|.
name|hba_device
operator|==
name|PCI_PRODUCT_PIIX4
condition|)
block|{
operator|(
operator|*
name|veto
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"Disable ATA disks on "
literal|"simulated ATA controller (0x%04x%04x)\n"
argument_list|,
name|cpi
operator|.
name|hba_device
argument_list|,
name|cpi
operator|.
name|hba_vendor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|storvsc_sysinit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|vm_guest
operator|==
name|VM_GUEST_HV
condition|)
block|{
name|storvsc_handler_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ada_probe_veto
argument_list|,
name|storvsc_ada_probe_veto
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|storvsc_sys_init
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|storvsc_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|storvsc_sysuninit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|storvsc_handler_tag
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ada_probe_veto
argument_list|,
name|storvsc_handler_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|storvsc_sys_uninit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|storvsc_sysuninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

