begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2012 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * Copyright (c) 2012 Citrix Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * StorVSC driver for Hyper-V.  This driver presents a SCSI HBA interface  * to the Comman Access Method (CAM) layer.  CAM control blocks (CCBs) are  * converted into VSCSI protocol messages which are delivered to the parent  * partition StorVSP driver over the Hyper-V VMBUS.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv.h>
end_include

begin_include
include|#
directive|include
file|"hv_vstorage.h"
end_include

begin_define
define|#
directive|define
name|STORVSC_RINGBUFFER_SIZE
value|(20*PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|STORVSC_MAX_LUNS_PER_TARGET
value|(64)
end_define

begin_define
define|#
directive|define
name|STORVSC_MAX_IO_REQUESTS
value|(STORVSC_MAX_LUNS_PER_TARGET * 2)
end_define

begin_define
define|#
directive|define
name|BLKVSC_MAX_IDE_DISKS_PER_TARGET
value|(1)
end_define

begin_define
define|#
directive|define
name|BLKVSC_MAX_IO_REQUESTS
value|STORVSC_MAX_IO_REQUESTS
end_define

begin_define
define|#
directive|define
name|STORVSC_MAX_TARGETS
value|(2)
end_define

begin_define
define|#
directive|define
name|VSTOR_PKT_SIZE
value|(sizeof(struct vstor_packet) - vmscsi_size_delta)
end_define

begin_define
define|#
directive|define
name|HV_ALIGN
parameter_list|(
name|x
parameter_list|,
name|a
parameter_list|)
value|roundup2(x, a)
end_define

begin_struct_decl
struct_decl|struct
name|storvsc_softc
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|hv_sgl_node
block|{
name|LIST_ENTRY
argument_list|(
argument|hv_sgl_node
argument_list|)
name|link
expr_stmt|;
name|struct
name|sglist
modifier|*
name|sgl_data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hv_sgl_page_pool
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|hv_sgl_node
argument_list|)
name|in_use_sgl_list
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|hv_sgl_node
argument_list|)
name|free_sgl_list
expr_stmt|;
name|boolean_t
name|is_init
decl_stmt|;
block|}
name|g_hv_sgl_page_pool
struct|;
end_struct

begin_define
define|#
directive|define
name|STORVSC_MAX_SG_PAGE_CNT
value|STORVSC_MAX_IO_REQUESTS * HV_MAX_MULTIPAGE_BUFFER_COUNT
end_define

begin_enum
enum|enum
name|storvsc_request_type
block|{
name|WRITE_TYPE
block|,
name|READ_TYPE
block|,
name|UNKNOWN_TYPE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|hv_storvsc_request
block|{
name|LIST_ENTRY
argument_list|(
argument|hv_storvsc_request
argument_list|)
name|link
expr_stmt|;
name|struct
name|vstor_packet
name|vstor_packet
decl_stmt|;
name|hv_vmbus_multipage_buffer
name|data_buf
decl_stmt|;
name|void
modifier|*
name|sense_data
decl_stmt|;
name|uint8_t
name|sense_info_len
decl_stmt|;
name|uint8_t
name|retries
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
name|struct
name|sema
name|synch_sema
decl_stmt|;
comment|/*Synchronize the request/response if needed */
name|struct
name|sglist
modifier|*
name|bounce_sgl
decl_stmt|;
name|unsigned
name|int
name|bounce_sgl_count
decl_stmt|;
name|uint64_t
name|not_aligned_seg_bits
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|storvsc_softc
block|{
name|struct
name|hv_device
modifier|*
name|hs_dev
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|hv_storvsc_request
argument_list|)
name|hs_free_list
expr_stmt|;
name|struct
name|mtx
name|hs_lock
decl_stmt|;
name|struct
name|storvsc_driver_props
modifier|*
name|hs_drv_props
decl_stmt|;
name|int
name|hs_unit
decl_stmt|;
name|uint32_t
name|hs_frozen
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|hs_sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|hs_path
decl_stmt|;
name|uint32_t
name|hs_num_out_reqs
decl_stmt|;
name|boolean_t
name|hs_destroy
decl_stmt|;
name|boolean_t
name|hs_drain_notify
decl_stmt|;
name|boolean_t
name|hs_open_multi_channel
decl_stmt|;
name|struct
name|sema
name|hs_drain_sema
decl_stmt|;
name|struct
name|hv_storvsc_request
name|hs_init_req
decl_stmt|;
name|struct
name|hv_storvsc_request
name|hs_reset_req
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * HyperV storvsc timeout testing cases:  * a. IO returned after first timeout;  * b. IO returned after second timeout and queue freeze;  * c. IO returned while timer handler is running  * The first can be tested by "sg_senddiag -vv /dev/daX",  * and the second and third can be done by  * "sg_wr_mode -v -p 08 -c 0,1a -m 0,ff /dev/daX".  */
end_comment

begin_define
define|#
directive|define
name|HVS_TIMEOUT_TEST
value|0
end_define

begin_comment
comment|/*  * Bus/adapter reset functionality on the Hyper-V host is  * buggy and it will be disabled until  * it can be further tested.  */
end_comment

begin_define
define|#
directive|define
name|HVS_HOST_RESET
value|0
end_define

begin_struct
struct|struct
name|storvsc_driver_props
block|{
name|char
modifier|*
name|drv_name
decl_stmt|;
name|char
modifier|*
name|drv_desc
decl_stmt|;
name|uint8_t
name|drv_max_luns_per_target
decl_stmt|;
name|uint8_t
name|drv_max_ios_per_target
decl_stmt|;
name|uint32_t
name|drv_ringbuffer_size
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|hv_storage_type
block|{
name|DRIVER_BLKVSC
block|,
name|DRIVER_STORVSC
block|,
name|DRIVER_UNKNOWN
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|HS_MAX_ADAPTERS
value|10
end_define

begin_define
define|#
directive|define
name|HV_STORAGE_SUPPORTS_MULTI_CHANNEL
value|0x1
end_define

begin_comment
comment|/* {ba6163d9-04a1-4d29-b605-72e2ffb1dc7f} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|hv_guid
name|gStorVscDeviceType
init|=
block|{
operator|.
name|data
operator|=
block|{
literal|0xd9
block|,
literal|0x63
block|,
literal|0x61
block|,
literal|0xba
block|,
literal|0xa1
block|,
literal|0x04
block|,
literal|0x29
block|,
literal|0x4d
block|,
literal|0xb6
block|,
literal|0x05
block|,
literal|0x72
block|,
literal|0xe2
block|,
literal|0xff
block|,
literal|0xb1
block|,
literal|0xdc
block|,
literal|0x7f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* {32412632-86cb-44a2-9b5c-50d1417354f5} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|hv_guid
name|gBlkVscDeviceType
init|=
block|{
operator|.
name|data
operator|=
block|{
literal|0x32
block|,
literal|0x26
block|,
literal|0x41
block|,
literal|0x32
block|,
literal|0xcb
block|,
literal|0x86
block|,
literal|0xa2
block|,
literal|0x44
block|,
literal|0x9b
block|,
literal|0x5c
block|,
literal|0x50
block|,
literal|0xd1
block|,
literal|0x41
block|,
literal|0x73
block|,
literal|0x54
block|,
literal|0xf5
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|storvsc_driver_props
name|g_drv_props_table
index|[]
init|=
block|{
block|{
literal|"blkvsc"
block|,
literal|"Hyper-V IDE Storage Interface"
block|,
name|BLKVSC_MAX_IDE_DISKS_PER_TARGET
block|,
name|BLKVSC_MAX_IO_REQUESTS
block|,
name|STORVSC_RINGBUFFER_SIZE
block|}
block|,
block|{
literal|"storvsc"
block|,
literal|"Hyper-V SCSI Storage Interface"
block|,
name|STORVSC_MAX_LUNS_PER_TARGET
block|,
name|STORVSC_MAX_IO_REQUESTS
block|,
name|STORVSC_RINGBUFFER_SIZE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Sense buffer size changed in win8; have a run-time  * variable to track the size we should use.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sense_buffer_size
init|=
name|PRE_WIN8_STORVSC_SENSE_BUFFER_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The size of the vmscsi_request has changed in win8. The  * additional size is for the newly added elements in the  * structure. These elements are valid only when we are talking  * to a win8 host.  * Track the correct size we need to apply.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vmscsi_size_delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The storage protocol version is determined during the  * initial exchange with the host.  It will indicate which  * storage functionality is available in the host. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vmstor_proto_version
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|vmstor_proto
block|{
name|int
name|proto_version
decl_stmt|;
name|int
name|sense_buffer_size
decl_stmt|;
name|int
name|vmscsi_size_delta
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vmstor_proto
name|vmstor_proto_list
index|[]
init|=
block|{
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN10
block|,
name|POST_WIN7_STORVSC_SENSE_BUFFER_SIZE
block|,
literal|0
block|}
block|,
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN8_1
block|,
name|POST_WIN7_STORVSC_SENSE_BUFFER_SIZE
block|,
literal|0
block|}
block|,
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN8
block|,
name|POST_WIN7_STORVSC_SENSE_BUFFER_SIZE
block|,
literal|0
block|}
block|,
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN7
block|,
name|PRE_WIN8_STORVSC_SENSE_BUFFER_SIZE
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmscsi_win8_extension
argument_list|)
block|,         }
block|,
block|{
name|VMSTOR_PROTOCOL_VERSION_WIN6
block|,
name|PRE_WIN8_STORVSC_SENSE_BUFFER_SIZE
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmscsi_win8_extension
argument_list|)
block|,         }
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static functions */
end_comment

begin_function_decl
specifier|static
name|int
name|storvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|storvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|storvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_storvsc_request
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_free_request
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|hv_storage_type
name|storvsc_get_storage_type
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hv_storvsc_rescan_target
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hv_storvsc_on_channel_callback
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hv_storvsc_on_iocompletion
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hv_storvsc_connect_vsp
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_io_done
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_copy_sgl_to_bounce_buf
parameter_list|(
name|struct
name|sglist
modifier|*
name|bounce_sgl
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|orig_sgl
parameter_list|,
name|unsigned
name|int
name|orig_sgl_count
parameter_list|,
name|uint64_t
name|seg_bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|storvsc_copy_from_bounce_buf_to_sgl
parameter_list|(
name|bus_dma_segment_t
modifier|*
name|dest_sgl
parameter_list|,
name|unsigned
name|int
name|dest_sgl_count
parameter_list|,
name|struct
name|sglist
modifier|*
name|src_sgl
parameter_list|,
name|uint64_t
name|seg_bits
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|storvsc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|storvsc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|storvsc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|storvsc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|storvsc_driver
init|=
block|{
literal|"storvsc"
block|,
name|storvsc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|storvsc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|storvsc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|storvsc
argument_list|,
name|vmbus
argument_list|,
name|storvsc_driver
argument_list|,
name|storvsc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|storvsc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|storvsc
argument_list|,
name|vmbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * The host is capable of sending messages to us that are  * completely unsolicited. So, we need to address the race  * condition where we may be in the process of unloading the  * driver when the host may send us an unsolicited message.  * We address this issue by implementing a sequentially  * consistent protocol:  *  * 1. Channel callback is invoked while holding the the channel lock  *    and an unloading driver will reset the channel callback under  *    the protection of this channel lock.  *  * 2. To ensure bounded wait time for unloading a driver, we don't  *    permit outgoing traffic once the device is marked as being  *    destroyed.  *  * 3. Once the device is marked as being destroyed, we only  *    permit incoming traffic to properly account for  *    packets already sent out.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|storvsc_softc
modifier|*
name|get_stor_device
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device
parameter_list|,
name|boolean_t
name|outbound
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|device
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound
condition|)
block|{
comment|/* 		 * Here we permit outgoing I/O only 		 * if the device is not being destroyed. 		 */
if|if
condition|(
name|sc
operator|->
name|hs_destroy
condition|)
block|{
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * inbound case; if being destroyed 		 * only permit to account for 		 * messages already sent out. 		 */
if|if
condition|(
name|sc
operator|->
name|hs_destroy
operator|&&
operator|(
name|sc
operator|->
name|hs_num_out_reqs
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|sc
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Callback handler, will be invoked when receive mutil-channel offer  *  * @param context  new multi-channel  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_handle_sc_creation
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|hv_vmbus_channel
modifier|*
name|new_channel
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vmstor_chan_props
name|props
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|new_channel
operator|=
operator|(
name|hv_vmbus_channel
operator|*
operator|)
name|context
expr_stmt|;
name|device
operator|=
name|new_channel
operator|->
name|device
expr_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|device
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|FALSE
operator|==
name|sc
operator|->
name|hs_open_multi_channel
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|props
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_open
argument_list|(
name|new_channel
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|props
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmstor_chan_props
argument_list|)
argument_list|,
name|hv_storvsc_on_channel_callback
argument_list|,
name|new_channel
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * @brief Send multi-channel creation request to host  *  * @param device  a Hyper-V device pointer  * @param max_chans  the max channels supported by vmbus  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_send_multichannel_request
parameter_list|(
name|struct
name|hv_device
modifier|*
name|dev
parameter_list|,
name|int
name|max_chans
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|int
name|request_channels_cnt
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* get multichannels count that need to create */
name|request_channels_cnt
operator|=
name|MIN
argument_list|(
name|max_chans
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|dev
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc_error: get sc failed while send mutilchannel "
literal|"request\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|request
operator|=
operator|&
name|sc
operator|->
name|hs_init_req
expr_stmt|;
comment|/* Establish a handler for multi-channel */
name|dev
operator|->
name|channel
operator|->
name|sc_creation_callback
operator|=
name|storvsc_handle_sc_creation
expr_stmt|;
comment|/* request the host to create multi-channel */
name|memset
argument_list|(
name|request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|0
argument_list|,
operator|(
literal|"stor_synch_sema"
operator|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|=
operator|&
name|request
operator|->
name|vstor_packet
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_CREATE_MULTI_CHANNELS
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|multi_channels_cnt
operator|=
name|request_channels_cnt
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
comment|/* wait for 5 seconds */
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc_error: create multi-channel timeout, %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc_error: create multi-channel invalid operation "
literal|"(%d) or statue (%u)\n"
argument_list|,
name|vstor_packet
operator|->
name|operation
argument_list|,
name|vstor_packet
operator|->
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|hs_open_multi_channel
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Storvsc create multi-channel success!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief initialize channel connection to parent partition  *  * @param dev  a Hyper-V device pointer  * @returns  0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_channel_init
parameter_list|(
name|struct
name|hv_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|max_chans
init|=
literal|0
decl_stmt|;
name|boolean_t
name|support_multichannel
init|=
name|FALSE
decl_stmt|;
name|max_chans
operator|=
literal|0
expr_stmt|;
name|support_multichannel
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|dev
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|request
operator|=
operator|&
name|sc
operator|->
name|hs_init_req
expr_stmt|;
name|memset
argument_list|(
name|request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|=
operator|&
name|request
operator|->
name|vstor_packet
expr_stmt|;
name|request
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
comment|/** 	 * Initiate the vsc/vsp initialization protocol on the open channel 	 */
name|sema_init
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|0
argument_list|,
operator|(
literal|"stor_synch_sema"
operator|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_BEGININITIALIZATION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* wait 5 seconds */
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|vmstor_proto_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* reuse the packet for version range supported */
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_QUERYPROTOCOLVERSION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|version
operator|.
name|major_minor
operator|=
name|vmstor_proto_list
index|[
name|i
index|]
operator|.
name|proto_version
expr_stmt|;
comment|/* revision is only significant for Windows guests */
name|vstor_packet
operator|->
name|u
operator|.
name|version
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* wait 5 seconds */
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|vstor_packet
operator|->
name|status
operator|==
literal|0
condition|)
block|{
name|vmstor_proto_version
operator|=
name|vmstor_proto_list
index|[
name|i
index|]
operator|.
name|proto_version
expr_stmt|;
name|sense_buffer_size
operator|=
name|vmstor_proto_list
index|[
name|i
index|]
operator|.
name|sense_buffer_size
expr_stmt|;
name|vmscsi_size_delta
operator|=
name|vmstor_proto_list
index|[
name|i
index|]
operator|.
name|vmscsi_size_delta
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/** 	 * Query channel properties 	 */
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_QUERYPROPERTIES
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* wait 5 seconds */
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* TODO: Check returned version */
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* multi-channels feature is supported by WIN8 and above version */
name|max_chans
operator|=
name|vstor_packet
operator|->
name|u
operator|.
name|chan_props
operator|.
name|max_channel_cnt
expr_stmt|;
if|if
condition|(
operator|(
name|hv_vmbus_protocal_version
operator|!=
name|HV_VMBUS_VERSION_WIN7
operator|)
operator|&&
operator|(
name|hv_vmbus_protocal_version
operator|!=
name|HV_VMBUS_VERSION_WS2008
operator|)
operator|&&
operator|(
name|vstor_packet
operator|->
name|u
operator|.
name|chan_props
operator|.
name|flags
operator|&
name|HV_STORAGE_SUPPORTS_MULTI_CHANNEL
operator|)
condition|)
block|{
name|support_multichannel
operator|=
name|TRUE
expr_stmt|;
block|}
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_ENDINITIALIZATION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* wait 5 seconds */
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * If multi-channel is supported, send multichannel create 	 * request to host. 	 */
if|if
condition|(
name|support_multichannel
condition|)
name|storvsc_send_multichannel_request
argument_list|(
name|dev
argument_list|,
name|max_chans
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|sema_destroy
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Open channel connection to paraent partition StorVSP driver  *  * Open and initialize channel connection to parent partition StorVSP driver.  *  * @param pointer to a Hyper-V device  * @returns 0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_connect_vsp
parameter_list|(
name|struct
name|hv_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|vmstor_chan_props
name|props
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
operator|->
name|device
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|props
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmstor_chan_props
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Open the channel 	 */
name|ret
operator|=
name|hv_vmbus_channel_open
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|props
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmstor_chan_props
argument_list|)
argument_list|,
name|hv_storvsc_on_channel_callback
argument_list|,
name|dev
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|hv_storvsc_channel_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HVS_HOST_RESET
end_if

begin_function
specifier|static
name|int
name|hv_storvsc_host_reset
parameter_list|(
name|struct
name|hv_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|dev
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
name|ENODEV
return|;
block|}
name|request
operator|=
operator|&
name|sc
operator|->
name|hs_reset_req
expr_stmt|;
name|request
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|vstor_packet
operator|=
operator|&
name|request
operator|->
name|vstor_packet
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|0
argument_list|,
literal|"stor synch sema"
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_RESETBUS
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
call|(
name|uint64_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
operator|&
name|sc
operator|->
name|hs_reset_req
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds */
if|if
condition|(
name|ret
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * At this point, all outstanding requests in the adapter 	 * should have been flushed out and return to us 	 */
name|cleanup
label|:
name|sema_destroy
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HVS_HOST_RESET */
end_comment

begin_comment
comment|/**  * @brief Function to initiate an I/O request  *  * @param device Hyper-V device pointer  * @param request pointer to a request structure  * @returns 0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_io_request
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
init|=
operator|&
name|request
operator|->
name|vstor_packet
decl_stmt|;
name|struct
name|hv_vmbus_channel
modifier|*
name|outgoing_channel
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|device
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
name|ENODEV
return|;
block|}
name|vstor_packet
operator|->
name|flags
operator||=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|length
operator|=
name|VSTOR_PKT_SIZE
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|sense_info_len
operator|=
name|sense_buffer_size
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|transfer_len
operator|=
name|request
operator|->
name|data_buf
operator|.
name|length
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_EXECUTESRB
expr_stmt|;
name|outgoing_channel
operator|=
name|vmbus_select_outgoing_channel
argument_list|(
name|device
operator|->
name|channel
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|request
operator|->
name|softc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|data_buf
operator|.
name|length
condition|)
block|{
name|ret
operator|=
name|hv_vmbus_channel_send_packet_multipagebuffer
argument_list|(
name|outgoing_channel
argument_list|,
operator|&
name|request
operator|->
name|data_buf
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|outgoing_channel
argument_list|,
name|vstor_packet
argument_list|,
name|VSTOR_PKT_SIZE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|request
operator|->
name|softc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to send packet %p ret %d"
argument_list|,
name|vstor_packet
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomic_add_int
argument_list|(
operator|&
name|sc
operator|->
name|hs_num_out_reqs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Process IO_COMPLETION_OPERATION and ready  * the result to be completed for upper layer  * processing by the CAM layer.  */
end_comment

begin_function
specifier|static
name|void
name|hv_storvsc_on_iocompletion
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|vmscsi_req
modifier|*
name|vm_srb
decl_stmt|;
name|vm_srb
operator|=
operator|&
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|vm_srb
operator|->
name|scsi_status
operator|&
literal|0xFF
operator|)
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
operator|&&
operator|(
name|vm_srb
operator|->
name|srb_status
operator|&
name|SRB_STATUS_AUTOSENSE_VALID
operator|)
condition|)
block|{
comment|/* Autosense data available */
name|KASSERT
argument_list|(
name|vm_srb
operator|->
name|sense_info_len
operator|<=
name|request
operator|->
name|sense_info_len
argument_list|,
operator|(
literal|"vm_srb->sense_info_len<= "
literal|"request->sense_info_len"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|request
operator|->
name|sense_data
argument_list|,
name|vm_srb
operator|->
name|u
operator|.
name|sense_data
argument_list|,
name|vm_srb
operator|->
name|sense_info_len
argument_list|)
expr_stmt|;
name|request
operator|->
name|sense_info_len
operator|=
name|vm_srb
operator|->
name|sense_info_len
expr_stmt|;
block|}
comment|/* Complete request by passing to the CAM layer */
name|storvsc_io_done
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sc
operator|->
name|hs_num_out_reqs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_drain_notify
operator|&&
operator|(
name|sc
operator|->
name|hs_num_out_reqs
operator|==
literal|0
operator|)
condition|)
block|{
name|sema_post
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hv_storvsc_rescan_target
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|path_id_t
name|pathid
decl_stmt|;
name|target_id_t
name|targetid
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|pathid
operator|=
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|)
expr_stmt|;
name|targetid
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
comment|/* 	 * Allocate a CCB and schedule a rescan. 	 */
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"unable to alloc CCB for rescan\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|pathid
argument_list|,
name|targetid
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"unable to create path for rescan, pathid: %u,"
literal|"targetid: %u\n"
argument_list|,
name|pathid
argument_list|,
name|targetid
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|targetid
operator|==
name|CAM_TARGET_WILDCARD
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_TGT
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_storvsc_on_channel_callback
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|hv_vmbus_channel
modifier|*
name|channel
init|=
operator|(
name|hv_vmbus_channel
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device
init|=
name|NULL
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|bytes_recvd
decl_stmt|;
name|uint64_t
name|request_id
decl_stmt|;
name|uint8_t
name|packet
index|[
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
literal|8
argument_list|)
index|]
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|device
operator|=
name|channel
operator|->
name|device
expr_stmt|;
name|KASSERT
argument_list|(
name|device
argument_list|,
operator|(
literal|"device is NULL"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|device
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc_error: get stor device failed.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ret
operator|=
name|hv_vmbus_channel_recv_packet
argument_list|(
name|channel
argument_list|,
name|packet
argument_list|,
name|roundup2
argument_list|(
name|VSTOR_PKT_SIZE
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|&
name|bytes_recvd
argument_list|,
operator|&
name|request_id
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bytes_recvd
operator|>
literal|0
operator|)
condition|)
block|{
name|request
operator|=
operator|(
expr|struct
name|hv_storvsc_request
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|request_id
expr_stmt|;
if|if
condition|(
operator|(
name|request
operator|==
operator|&
name|sc
operator|->
name|hs_init_req
operator|)
operator|||
operator|(
name|request
operator|==
operator|&
name|sc
operator|->
name|hs_reset_req
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|request
operator|->
name|vstor_packet
argument_list|,
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|sema_post
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vstor_packet
operator|=
operator|(
expr|struct
name|vstor_packet
operator|*
operator|)
name|packet
expr_stmt|;
switch|switch
condition|(
name|vstor_packet
operator|->
name|operation
condition|)
block|{
case|case
name|VSTOR_OPERATION_COMPLETEIO
case|:
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"VMBUS: storvsc received a "
literal|"packet with NULL request id in "
literal|"COMPLETEIO operation."
argument_list|)
expr_stmt|;
name|hv_storvsc_on_iocompletion
argument_list|(
name|sc
argument_list|,
name|vstor_packet
argument_list|,
name|request
argument_list|)
expr_stmt|;
break|break;
case|case
name|VSTOR_OPERATION_REMOVEDEVICE
case|:
name|printf
argument_list|(
literal|"VMBUS: storvsc operation %d not "
literal|"implemented.\n"
argument_list|,
name|vstor_packet
operator|->
name|operation
argument_list|)
expr_stmt|;
comment|/* TODO: implement */
break|break;
case|case
name|VSTOR_OPERATION_ENUMERATE_BUS
case|:
name|hv_storvsc_rescan_target
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|ret
operator|=
name|hv_vmbus_channel_recv_packet
argument_list|(
name|channel
argument_list|,
name|packet
argument_list|,
name|roundup2
argument_list|(
name|VSTOR_PKT_SIZE
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|&
name|bytes_recvd
argument_list|,
operator|&
name|request_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC probe function  *  * Device probe function.  Returns 0 if the input device is a StorVSC  * device.  Otherwise, a ENXIO is returned.  If the input device is  * for BlkVSC (paravirtual IDE) device and this support is disabled in  * favor of the emulated ATA/IDE device, return ENXIO.  *  * @param a device  * @returns 0 on success, ENXIO if not a matcing StorVSC device  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|ata_disk_enable
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
name|ENXIO
decl_stmt|;
switch|switch
condition|(
name|storvsc_get_storage_type
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|DRIVER_BLKVSC
case|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DRIVER_BLKVSC-Emulated ATA/IDE probe\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getenv_int
argument_list|(
literal|"hw.ata.disk_enable"
argument_list|,
operator|&
name|ata_disk_enable
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enlightened ATA/IDE detected\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Emulated ATA/IDE set (hw.ata.disk_enable set)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRIVER_STORVSC
case|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enlightened SCSI device detected\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC attach function  *  * Function responsible for allocating per-device structures,  * setting up CAM interfaces and scanning for available LUNs to  * be used for SCSI device peripherals.  *  * @param a device  * @returns 0 on success or an error on failure  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hv_device
modifier|*
name|hv_dev
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|enum
name|hv_storage_type
name|stor_type
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
decl_stmt|;
name|struct
name|root_hold_token
modifier|*
name|root_mount_token
init|=
name|NULL
decl_stmt|;
name|struct
name|hv_sgl_node
modifier|*
name|sgl_node
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|tmp_buff
init|=
name|NULL
decl_stmt|;
comment|/* 	 * We need to serialize storvsc attach calls. 	 */
name|root_mount_token
operator|=
name|root_mount_hold
argument_list|(
literal|"storvsc"
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|stor_type
operator|=
name|storvsc_get_storage_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|stor_type
operator|==
name|DRIVER_UNKNOWN
condition|)
block|{
name|ret
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|storvsc_softc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in driver specific properties */
name|sc
operator|->
name|hs_drv_props
operator|=
operator|&
name|g_drv_props_table
index|[
name|stor_type
index|]
expr_stmt|;
comment|/* fill in device specific properties */
name|sc
operator|->
name|hs_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_dev
operator|=
name|hv_dev
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|g_drv_props_table
index|[
name|stor_type
index|]
operator|.
name|drv_desc
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
literal|"hvslck"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
condition|;
operator|++
name|i
control|)
block|{
name|reqp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|,
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* create sg-list page pool */
if|if
condition|(
name|FALSE
operator|==
name|g_hv_sgl_page_pool
operator|.
name|is_init
condition|)
block|{
name|g_hv_sgl_page_pool
operator|.
name|is_init
operator|=
name|TRUE
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|in_use_sgl_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
expr_stmt|;
comment|/* 		 * Pre-create SG list, each SG list with 		 * HV_MAX_MULTIPAGE_BUFFER_COUNT segments, each 		 * segment has one page buffer 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORVSC_MAX_IO_REQUESTS
condition|;
name|i
operator|++
control|)
block|{
name|sgl_node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hv_sgl_node
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sgl_node
operator|->
name|sgl_data
operator|=
name|sglist_alloc
argument_list|(
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|tmp_buff
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
operator|=
operator|(
name|vm_paddr_t
operator|)
name|tmp_buff
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|,
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|hs_destroy
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|hs_drain_notify
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|hs_open_multi_channel
operator|=
name|FALSE
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|,
literal|0
argument_list|,
literal|"Store Drain Sema"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hv_storvsc_connect_vsp
argument_list|(
name|hv_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Create the device queue. 	 * Hyper-V maps each target to one SCSI HBA 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to alloc device queue\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|sc
operator|->
name|hs_sim
operator|=
name|cam_sim_alloc
argument_list|(
name|storvsc_action
argument_list|,
name|storvsc_poll
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_name
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|hs_unit
argument_list|,
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_sim
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to alloc sim\n"
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
comment|/* bus_id is set to 0, need to get it from VMBUS channel query? */
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to register SCSI bus\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|sc
operator|->
name|hs_path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create path\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|root_mount_token
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|root_mount_rel
argument_list|(
name|root_mount_token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
condition|)
block|{
name|sgl_node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|void
operator|*
operator|)
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|sglist_free
argument_list|(
name|sgl_node
operator|->
name|sgl_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgl_node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC device detach function  *  * This function is responsible for safely detaching a  * StorVSC device.  This includes waiting for inbound responses  * to complete and freeing associated per-device structures.  *  * @param dev a device  * returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|NULL
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|hv_device
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hv_sgl_node
modifier|*
name|sgl_node
init|=
name|NULL
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|hs_destroy
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * At this point, all outbound traffic should be disabled. We 	 * only allow inbound traffic (responses) to proceed so that 	 * outstanding requests can be completed. 	 */
name|sc
operator|->
name|hs_drain_notify
operator|=
name|TRUE
expr_stmt|;
name|sema_wait
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_drain_notify
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Since we have already drained, we don't need to busy wait. 	 * The call to close the channel will reset the callback 	 * under the protection of the incoming channel lock. 	 */
name|hv_vmbus_channel_close
argument_list|(
name|hv_device
operator|->
name|channel
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
condition|)
block|{
name|sgl_node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|void
operator|*
operator|)
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sgl_node
operator|->
name|sgl_data
operator|->
name|sg_segs
index|[
name|j
index|]
operator|.
name|ss_paddr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|sglist_free
argument_list|(
name|sgl_node
operator|->
name|sgl_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgl_node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HVS_TIMEOUT_TEST
end_if

begin_comment
comment|/**  * @brief unit test for timed out operations  *  * This function provides unit testing capability to simulate  * timed out operations.  Recompilation with HV_TIMEOUT_TEST=1  * is required.  *  * @param reqp pointer to a request structure  * @param opcode SCSI operation being performed  * @param wait if 1, wait for I/O to complete  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_timeout_test
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
if|if
condition|(
name|reqp
operator|->
name|vstor_packet
operator|.
name|vm_srb
operator|.
name|cdb
index|[
literal|0
index|]
operator|!=
name|opcode
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|wait
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|hv_storvsc_io_request
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|wait
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: io_request failed with %d.\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wait
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: waiting for IO return.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|,
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: %s.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|,
operator|(
name|ret
operator|==
literal|0
operator|)
condition|?
literal|"IO return detected"
else|:
literal|"IO return not detected"
argument_list|)
expr_stmt|;
comment|/* 		 * Now both the timer handler and io done are running 		 * simultaneously. We want to confirm the io done always 		 * finishes after the timer handler exits. So reqp used by 		 * timer handler is not freed or stale. Do busy loop for 		 * another 1/10 second to make sure io done does 		 * wait for the timer handler to complete. 		 */
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: finishing, queue frozen %d, "
literal|"ccb status 0x%x scsi_status 0x%x.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|hs_frozen
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HVS_TIMEOUT_TEST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/**  * @brief timeout handler for requests  *  * This function is called as a result of a callout expiring.  *  * @param arg pointer to a request  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|arg
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
if|if
condition|(
name|reqp
operator|->
name|retries
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO timed out (req=0x%p), wait for another %u secs.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|retries
operator|++
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
name|SBT_1MS
operator|*
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
literal|0
argument_list|,
name|storvsc_timeout
argument_list|,
name|reqp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|storvsc_timeout_test
argument_list|(
name|reqp
argument_list|,
name|SEND_DIAGNOSTIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO (reqp = 0x%p) did not return for %u seconds, %s.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
operator|(
name|reqp
operator|->
name|retries
operator|+
literal|1
operator|)
operator|/
literal|1000
argument_list|,
operator|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
operator|)
condition|?
literal|"freezing the queue"
else|:
literal|"the queue is already frozen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hs_frozen
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|storvsc_timeout_test
argument_list|(
name|reqp
argument_list|,
name|MODE_SELECT_10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @brief StorVSC device poll function  *  * This function is responsible for servicing requests when  * interrupts are disabled (i.e when we are dumping core.)  *  * @param sim a pointer to a CAM SCSI interface module  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|hv_storvsc_on_channel_callback
argument_list|(
name|sc
operator|->
name|hs_dev
operator|->
name|channel
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC device action function  *  * This function is responsible for handling SCSI operations which  * are passed from the CAM layer.  The requests are in the form of  * CAM control blocks which indicate the action being performed.  * Not all actions require converting the request to a VSCSI protocol  * message - these actions can be responded to by this driver.  * Requests which are destined for a backend storage device are converted  * to a VSCSI protocol message and sent on the channel connection associated  * with this device.  *  * @param sim pointer to a CAM SCSI interface module  * @param ccb pointer to a CAM control block  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|int
name|res
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
operator||
name|PI_SDTR_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|STORVSC_MAX_TARGETS
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_luns_per_target
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|cpi
operator|->
name|max_target
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|300000
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_name
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
comment|/* enable tag queuing and disconnected mode */
name|cts
operator|->
name|proto_specific
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
operator|.
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|valid
operator|=
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
if|#
directive|if
name|HVS_HOST_RESET
if|if
condition|(
operator|(
name|res
operator|=
name|hv_storvsc_host_reset
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"hv_storvsc_host_reset failed with %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%s reset not supported.\n"
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_BUS
operator|)
condition|?
literal|"bus"
else|:
literal|"dev"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* HVS_HOST_RESET */
block|}
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"cdl_len is 0\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hs_frozen
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/* count*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reqp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|create_storvsc_request
argument_list|(
name|ccb
argument_list|,
name|reqp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|callout_init
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
name|SBT_1MS
operator|*
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
literal|0
argument_list|,
name|storvsc_timeout
argument_list|,
name|reqp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|cv_init
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|,
literal|"storvsc timeout cv"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|,
literal|"storvsc timeout mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reqp
operator|->
name|vstor_packet
operator|.
name|vm_srb
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SELECT_10
case|:
case|case
name|SEND_DIAGNOSTIC
case|:
comment|/* To have timer send the request. */
return|return;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* HVS_TIMEOUT_TEST */
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|res
operator|=
name|hv_storvsc_io_request
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|,
name|reqp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"hv_storvsc_io_request failed with %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief destroy bounce buffer  *  * This function is responsible for destroy a Scatter/Gather list  * that create by storvsc_create_bounce_buffer()  *  * @param sgl- the Scatter/Gather need be destroy  * @param sg_count- page count of the SG list.  *  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_destroy_bounce_buffer
parameter_list|(
name|struct
name|sglist
modifier|*
name|sgl
parameter_list|)
block|{
name|struct
name|hv_sgl_node
modifier|*
name|sgl_node
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|in_use_sgl_list
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"storvsc error: not enough in use sgl\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sgl_node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|in_use_sgl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sgl_node
operator|->
name|sgl_data
operator|=
name|sgl
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|,
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief create bounce buffer  *  * This function is responsible for create a Scatter/Gather list,  * which hold several pages that can be aligned with page size.  *  * @param seg_count- SG-list segments count  * @param write - if WRITE_TYPE, set SG list page used size to 0,  * otherwise set used size to page size.  *  * return NULL if create failed  */
end_comment

begin_function
specifier|static
name|struct
name|sglist
modifier|*
name|storvsc_create_bounce_buffer
parameter_list|(
name|uint16_t
name|seg_count
parameter_list|,
name|int
name|write
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|sglist
modifier|*
name|bounce_sgl
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|buf_len
init|=
operator|(
operator|(
name|write
operator|==
name|WRITE_TYPE
operator|)
condition|?
literal|0
else|:
name|PAGE_SIZE
operator|)
decl_stmt|;
name|struct
name|hv_sgl_node
modifier|*
name|sgl_node
init|=
name|NULL
decl_stmt|;
comment|/* get struct sglist from free_sgl_list */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"storvsc error: not enough free sgl\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sgl_node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|free_sgl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bounce_sgl
operator|=
name|sgl_node
operator|->
name|sgl_data
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_hv_sgl_page_pool
operator|.
name|in_use_sgl_list
argument_list|,
name|sgl_node
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bounce_sgl
operator|->
name|sg_maxseg
operator|=
name|seg_count
expr_stmt|;
if|if
condition|(
name|write
operator|==
name|WRITE_TYPE
condition|)
name|bounce_sgl
operator|->
name|sg_nseg
operator|=
literal|0
expr_stmt|;
else|else
name|bounce_sgl
operator|->
name|sg_nseg
operator|=
name|seg_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seg_count
condition|;
name|i
operator|++
control|)
name|bounce_sgl
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
operator|=
name|buf_len
expr_stmt|;
return|return
name|bounce_sgl
return|;
block|}
end_function

begin_comment
comment|/**  * @brief copy data from SG list to bounce buffer  *  * This function is responsible for copy data from one SG list's segments  * to another SG list which used as bounce buffer.  *  * @param bounce_sgl - the destination SG list  * @param orig_sgl - the segment of the source SG list.  * @param orig_sgl_count - the count of segments.  * @param orig_sgl_count - indicate which segment need bounce buffer,  *  set 1 means need.  *  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_copy_sgl_to_bounce_buf
parameter_list|(
name|struct
name|sglist
modifier|*
name|bounce_sgl
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|orig_sgl
parameter_list|,
name|unsigned
name|int
name|orig_sgl_count
parameter_list|,
name|uint64_t
name|seg_bits
parameter_list|)
block|{
name|int
name|src_sgl_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|src_sgl_idx
operator|=
literal|0
init|;
name|src_sgl_idx
operator|<
name|orig_sgl_count
condition|;
name|src_sgl_idx
operator|++
control|)
block|{
if|if
condition|(
name|seg_bits
operator|&
operator|(
literal|1
operator|<<
name|src_sgl_idx
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bounce_sgl
operator|->
name|sg_segs
index|[
name|src_sgl_idx
index|]
operator|.
name|ss_paddr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|orig_sgl
index|[
name|src_sgl_idx
index|]
operator|.
name|ds_addr
argument_list|,
name|orig_sgl
index|[
name|src_sgl_idx
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|bounce_sgl
operator|->
name|sg_segs
index|[
name|src_sgl_idx
index|]
operator|.
name|ss_len
operator|=
name|orig_sgl
index|[
name|src_sgl_idx
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief copy data from SG list which used as bounce to another SG list  *  * This function is responsible for copy data from one SG list with bounce  * buffer to another SG list's segments.  *  * @param dest_sgl - the destination SG list's segments  * @param dest_sgl_count - the count of destination SG list's segment.  * @param src_sgl - the source SG list.  * @param seg_bits - indicate which segment used bounce buffer of src SG-list.  *  */
end_comment

begin_function
name|void
name|storvsc_copy_from_bounce_buf_to_sgl
parameter_list|(
name|bus_dma_segment_t
modifier|*
name|dest_sgl
parameter_list|,
name|unsigned
name|int
name|dest_sgl_count
parameter_list|,
name|struct
name|sglist
modifier|*
name|src_sgl
parameter_list|,
name|uint64_t
name|seg_bits
parameter_list|)
block|{
name|int
name|sgl_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sgl_idx
operator|=
literal|0
init|;
name|sgl_idx
operator|<
name|dest_sgl_count
condition|;
name|sgl_idx
operator|++
control|)
block|{
if|if
condition|(
name|seg_bits
operator|&
operator|(
literal|1
operator|<<
name|sgl_idx
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|dest_sgl
index|[
name|sgl_idx
index|]
operator|.
name|ds_addr
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|src_sgl
operator|->
name|sg_segs
index|[
name|sgl_idx
index|]
operator|.
name|ss_paddr
operator|)
argument_list|,
name|src_sgl
operator|->
name|sg_segs
index|[
name|sgl_idx
index|]
operator|.
name|ss_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief check SG list with bounce buffer or not  *  * This function is responsible for check if need bounce buffer for SG list.  *  * @param sgl - the SG list's segments  * @param sg_count - the count of SG list's segment.  * @param bits - segmengs number that need bounce buffer  *  * return -1 if SG list needless bounce buffer  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_check_bounce_buffer_sgl
parameter_list|(
name|bus_dma_segment_t
modifier|*
name|sgl
parameter_list|,
name|unsigned
name|int
name|sg_count
parameter_list|,
name|uint64_t
modifier|*
name|bits
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|uint64_t
name|phys_addr
init|=
literal|0
decl_stmt|;
name|uint64_t
name|tmp_bits
init|=
literal|0
decl_stmt|;
name|boolean_t
name|found_hole
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|pre_aligned
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|sg_count
operator|<
literal|2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|bits
operator|=
literal|0
expr_stmt|;
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|sgl
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|phys_addr
operator|-
name|trunc_page
argument_list|(
name|phys_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|pre_aligned
operator|=
name|FALSE
expr_stmt|;
name|tmp_bits
operator||=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|sgl
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|phys_addr
operator|-
name|trunc_page
argument_list|(
name|phys_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|FALSE
operator|==
name|pre_aligned
condition|)
block|{
comment|/* 				 * This segment is aligned, if the previous 				 * one is not aligned, find a hole 				 */
name|found_hole
operator|=
name|TRUE
expr_stmt|;
block|}
name|pre_aligned
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|tmp_bits
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|pre_aligned
condition|)
block|{
if|if
condition|(
name|phys_addr
operator|!=
name|vtophys
argument_list|(
name|sgl
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
operator|+
name|sgl
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_len
argument_list|)
condition|)
block|{
comment|/* 					 * Check whether connect to previous 					 * segment,if not, find the hole 					 */
name|found_hole
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|found_hole
operator|=
name|TRUE
expr_stmt|;
block|}
name|pre_aligned
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found_hole
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|*
name|bits
operator|=
name|tmp_bits
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief Fill in a request structure based on a CAM control block  *  * Fills in a request structure based on the contents of a CAM control  * block.  The request structure holds the payload information for  * VSCSI protocol request.  *  * @param ccb pointer to a CAM contorl block  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|int
name|create_storvsc_request
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|uint64_t
name|phys_addr
decl_stmt|;
name|uint32_t
name|bytes_to_copy
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pfn_num
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pfn
decl_stmt|;
name|uint64_t
name|not_aligned_seg_bits
init|=
literal|0
decl_stmt|;
comment|/* refer to struct vmscsi_req for meanings of these two fields */
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|port
operator|=
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|path_id
operator|=
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|cdb_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|u
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|u
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_OUT
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|WRITE_TYPE
expr_stmt|;
break|break;
case|case
name|CAM_DIR_IN
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|READ_TYPE
expr_stmt|;
break|break;
case|case
name|CAM_DIR_NONE
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|UNKNOWN_TYPE
expr_stmt|;
break|break;
default|default:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|UNKNOWN_TYPE
expr_stmt|;
break|break;
block|}
name|reqp
operator|->
name|sense_data
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|reqp
operator|->
name|sense_info_len
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
name|reqp
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|csio
operator|->
name|dxfer_len
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reqp
operator|->
name|data_buf
operator|.
name|length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
condition|)
block|{
case|case
name|CAM_DATA_VADDR
case|:
block|{
name|bytes_to_copy
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|csio
operator|->
name|data_ptr
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|offset
operator|=
name|phys_addr
operator|&
name|PAGE_MASK
expr_stmt|;
while|while
condition|(
name|bytes_to_copy
operator|!=
literal|0
condition|)
block|{
name|int
name|bytes
decl_stmt|,
name|page_offset
decl_stmt|;
name|phys_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|csio
operator|->
name|data_ptr
index|[
name|reqp
operator|->
name|data_buf
operator|.
name|length
operator|-
name|bytes_to_copy
index|]
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|pfn_array
index|[
name|pfn_num
index|]
operator|=
name|pfn
expr_stmt|;
name|page_offset
operator|=
name|phys_addr
operator|&
name|PAGE_MASK
expr_stmt|;
name|bytes
operator|=
name|min
argument_list|(
name|PAGE_SIZE
operator|-
name|page_offset
argument_list|,
name|bytes_to_copy
argument_list|)
expr_stmt|;
name|bytes_to_copy
operator|-=
name|bytes
expr_stmt|;
name|pfn_num
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CAM_DATA_SG
case|:
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|storvsc_sglist
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
name|u_int16_t
name|storvsc_sg_count
init|=
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
decl_stmt|;
name|printf
argument_list|(
literal|"Storvsc: get SG I/O operation, %d\n"
argument_list|,
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|storvsc_sg_count
operator|>
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc: %d segments is too much, "
literal|"only support %d segments\n"
argument_list|,
name|storvsc_sg_count
argument_list|,
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * We create our own bounce buffer function currently. Idealy 		 * we should use BUS_DMA(9) framework. But with current BUS_DMA 		 * code there is no callback API to check the page alignment of 		 * middle segments before busdma can decide if a bounce buffer 		 * is needed for particular segment. There is callback, 		 * "bus_dma_filter_t *filter", but the parrameters are not 		 * sufficient for storvsc driver. 		 * TODO: 		 *	Add page alignment check in BUS_DMA(9) callback. Once 		 *	this is complete, switch the following code to use 		 *	BUS_DMA(9) for storvsc bounce buffer support. 		 */
comment|/* check if we need to create bounce buffer */
name|ret
operator|=
name|storvsc_check_bounce_buffer_sgl
argument_list|(
name|storvsc_sglist
argument_list|,
name|storvsc_sg_count
argument_list|,
operator|&
name|not_aligned_seg_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
name|reqp
operator|->
name|bounce_sgl
operator|=
name|storvsc_create_bounce_buffer
argument_list|(
name|storvsc_sg_count
argument_list|,
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|reqp
operator|->
name|bounce_sgl
condition|)
block|{
name|printf
argument_list|(
literal|"Storvsc_error: "
literal|"create bounce buffer failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|reqp
operator|->
name|bounce_sgl_count
operator|=
name|storvsc_sg_count
expr_stmt|;
name|reqp
operator|->
name|not_aligned_seg_bits
operator|=
name|not_aligned_seg_bits
expr_stmt|;
comment|/* 			 * if it is write, we need copy the original data 			 *to bounce buffer 			 */
if|if
condition|(
name|WRITE_TYPE
operator|==
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
condition|)
block|{
name|storvsc_copy_sgl_to_bounce_buf
argument_list|(
name|reqp
operator|->
name|bounce_sgl
argument_list|,
name|storvsc_sglist
argument_list|,
name|storvsc_sg_count
argument_list|,
name|reqp
operator|->
name|not_aligned_seg_bits
argument_list|)
expr_stmt|;
block|}
comment|/* transfer virtual address to physical frame number */
if|if
condition|(
name|reqp
operator|->
name|not_aligned_seg_bits
operator|&
literal|0x1
condition|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|reqp
operator|->
name|bounce_sgl
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_paddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
name|reqp
operator|->
name|data_buf
operator|.
name|offset
operator|=
name|phys_addr
operator|&
name|PAGE_MASK
expr_stmt|;
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|pfn_array
index|[
literal|0
index|]
operator|=
name|pfn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|storvsc_sg_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reqp
operator|->
name|not_aligned_seg_bits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|reqp
operator|->
name|bounce_sgl
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_paddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|pfn_array
index|[
name|i
index|]
operator|=
name|pfn
expr_stmt|;
block|}
block|}
else|else
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|offset
operator|=
name|phys_addr
operator|&
name|PAGE_MASK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|storvsc_sg_count
condition|;
name|i
operator|++
control|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|pfn_array
index|[
name|i
index|]
operator|=
name|pfn
expr_stmt|;
block|}
comment|/* check the last segment cross boundary or not */
name|offset
operator|=
name|phys_addr
operator|&
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|storvsc_sglist
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
operator|+
name|PAGE_SIZE
operator|-
name|offset
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|pfn_array
index|[
name|i
index|]
operator|=
name|pfn
expr_stmt|;
block|}
name|reqp
operator|->
name|bounce_sgl_count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"Unknow flags: %d\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Modified based on scsi_print_inquiry which is responsible to  * print the detail information for scsi_inquiry_data.  *  * Return 1 if it is valid, 0 otherwise.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_inquiry_valid
parameter_list|(
specifier|const
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
parameter_list|)
block|{
name|uint8_t
name|type
decl_stmt|;
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|,
name|product
index|[
literal|48
index|]
decl_stmt|,
name|revision
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * Check device type and qualifier 	 */
if|if
condition|(
operator|!
operator|(
name|SID_QUAL_IS_VENDOR_UNIQUE
argument_list|(
name|inq_data
argument_list|)
operator|||
name|SID_QUAL
argument_list|(
name|inq_data
argument_list|)
operator|==
name|SID_QUAL_LU_CONNECTED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|type
operator|=
name|SID_TYPE
argument_list|(
name|inq_data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_DIRECT
case|:
case|case
name|T_SEQUENTIAL
case|:
case|case
name|T_PRINTER
case|:
case|case
name|T_PROCESSOR
case|:
case|case
name|T_WORM
case|:
case|case
name|T_CDROM
case|:
case|case
name|T_SCANNER
case|:
case|case
name|T_OPTICAL
case|:
case|case
name|T_CHANGER
case|:
case|case
name|T_COMM
case|:
case|case
name|T_STORARRAY
case|:
case|case
name|T_ENCLOSURE
case|:
case|case
name|T_RBC
case|:
case|case
name|T_OCRW
case|:
case|case
name|T_OSD
case|:
case|case
name|T_ADC
case|:
break|break;
case|case
name|T_NODEVICE
case|:
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check vendor, product, and revision 	 */
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|inq_data
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|inq_data
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|inq_data
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq_data
operator|->
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|vendor
argument_list|)
operator|==
literal|0
operator|||
name|strlen
argument_list|(
name|product
argument_list|)
operator|==
literal|0
operator|||
name|strlen
argument_list|(
name|revision
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief completion function before returning to CAM  *  * I/O process has been completed and the result needs  * to be passed to the CAM layer.  * Free resources related to this request.  *  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_io_done
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
name|struct
name|vmscsi_req
modifier|*
name|vm_srb
init|=
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|ori_sglist
init|=
name|NULL
decl_stmt|;
name|int
name|ori_sg_count
init|=
literal|0
decl_stmt|;
comment|/* destroy bounce buffer if it is used */
if|if
condition|(
name|reqp
operator|->
name|bounce_sgl_count
condition|)
block|{
name|ori_sglist
operator|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|ori_sg_count
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
expr_stmt|;
comment|/* 		 * If it is READ operation, we should copy back the data 		 * to original SG list. 		 */
if|if
condition|(
name|READ_TYPE
operator|==
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
condition|)
block|{
name|storvsc_copy_from_bounce_buf_to_sgl
argument_list|(
name|ori_sglist
argument_list|,
name|ori_sg_count
argument_list|,
name|reqp
operator|->
name|bounce_sgl
argument_list|,
name|reqp
operator|->
name|not_aligned_seg_bits
argument_list|)
expr_stmt|;
block|}
name|storvsc_destroy_bounce_buffer
argument_list|(
name|reqp
operator|->
name|bounce_sgl
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|bounce_sgl_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|reqp
operator|->
name|retries
operator|>
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO returned after timeout, "
literal|"waking up timer handler if any.\n"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reqp
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO returned after timeout, "
literal|"stopping timer if any.\n"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * callout_drain() will wait for the timer handler to finish 	 * if it is running. So we don't need any lock to synchronize 	 * between this routine and the timer handler. 	 * Note that we need to make sure reqp is not freed when timer 	 * handler is using or will use it. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|callout_drain
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|vm_srb
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_OK
condition|)
block|{
specifier|const
name|struct
name|scsi_generic
modifier|*
name|cmd
decl_stmt|;
comment|/* 		 * Check whether the data for INQUIRY cmd is valid or 		 * not.  Windows 10 and Windows 2016 send all zero 		 * inquiry data to VM even for unpopulated slots. 		 */
name|cmd
operator|=
operator|(
specifier|const
expr|struct
name|scsi_generic
operator|*
operator|)
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|==
name|INQUIRY
operator|&&
comment|/*  		     * XXX: Temporary work around disk hot plugin on win2k12r2, 		     * only filtering the invalid disk on win10 or 2016 server. 		     * So, the hot plugin on win10 and 2016 server needs 		     * to be fixed. 		     */
name|vmstor_proto_version
operator|==
name|VMSTOR_PROTOCOL_VERSION_WIN10
operator|&&
name|is_inquiry_valid
argument_list|(
operator|(
specifier|const
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|csio
operator|->
name|data_ptr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"storvsc uninstalled device\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"storvsc scsi_status = %d\n"
argument_list|,
name|vm_srb
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
operator|(
name|vm_srb
operator|->
name|scsi_status
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|vm_srb
operator|->
name|transfer_len
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|sense_info_len
operator|!=
literal|0
condition|)
block|{
name|csio
operator|->
name|sense_resid
operator|=
name|csio
operator|->
name|sense_len
operator|-
name|reqp
operator|->
name|sense_info_len
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|softc
operator|->
name|hs_frozen
operator|==
literal|1
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: storvsc unfreezing softc 0x%p.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
operator|->
name|softc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|reqp
operator|->
name|softc
operator|->
name|hs_frozen
operator|=
literal|0
expr_stmt|;
block|}
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_done_direct
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Free a request structure  *  * Free a request structure by returning it to the free list  *  * @param sc pointer to a softc  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_free_request
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|,
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Determine type of storage device from GUID  *  * Using the type GUID, determine if this is a StorVSC (paravirtual  * SCSI or BlkVSC (paravirtual IDE) device.  *  * @param dev a device  * returns an enum  */
end_comment

begin_function
specifier|static
name|enum
name|hv_storage_type
name|storvsc_get_storage_type
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|vmbus_get_type
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
operator|&
name|gBlkVscDeviceType
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_guid
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|DRIVER_BLKVSC
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
operator|&
name|gStorVscDeviceType
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_guid
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|DRIVER_STORVSC
return|;
block|}
return|return
operator|(
name|DRIVER_UNKNOWN
operator|)
return|;
block|}
end_function

end_unit

