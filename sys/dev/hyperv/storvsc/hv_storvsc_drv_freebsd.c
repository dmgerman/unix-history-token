begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2012 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * Copyright (c) 2012 Citrix Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * StorVSC driver for Hyper-V.  This driver presents a SCSI HBA interface  * to the Comman Access Method (CAM) layer.  CAM control blocks (CCBs) are  * converted into VSCSI protocol messages which are delivered to the parent  * partition StorVSP driver over the Hyper-V VMBUS.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_internal.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv.h>
end_include

begin_include
include|#
directive|include
file|"hv_vstorage.h"
end_include

begin_define
define|#
directive|define
name|STORVSC_RINGBUFFER_SIZE
value|(20*PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|STORVSC_MAX_LUNS_PER_TARGET
value|(64)
end_define

begin_define
define|#
directive|define
name|STORVSC_MAX_IO_REQUESTS
value|(STORVSC_MAX_LUNS_PER_TARGET * 2)
end_define

begin_define
define|#
directive|define
name|BLKVSC_MAX_IDE_DISKS_PER_TARGET
value|(1)
end_define

begin_define
define|#
directive|define
name|BLKVSC_MAX_IO_REQUESTS
value|STORVSC_MAX_IO_REQUESTS
end_define

begin_define
define|#
directive|define
name|STORVSC_MAX_TARGETS
value|(1)
end_define

begin_struct_decl
struct_decl|struct
name|storvsc_softc
struct_decl|;
end_struct_decl

begin_enum
enum|enum
name|storvsc_request_type
block|{
name|WRITE_TYPE
block|,
name|READ_TYPE
block|,
name|UNKNOWN_TYPE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|hv_storvsc_request
block|{
name|LIST_ENTRY
argument_list|(
argument|hv_storvsc_request
argument_list|)
name|link
expr_stmt|;
name|struct
name|vstor_packet
name|vstor_packet
decl_stmt|;
name|hv_vmbus_multipage_buffer
name|data_buf
decl_stmt|;
name|void
modifier|*
name|sense_data
decl_stmt|;
name|uint8_t
name|sense_info_len
decl_stmt|;
name|uint8_t
name|retries
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|softc
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
name|struct
name|sema
name|synch_sema
decl_stmt|;
comment|/*Synchronize the request/response if needed */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|storvsc_softc
block|{
name|struct
name|hv_device
modifier|*
name|hs_dev
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|hv_storvsc_request
argument_list|)
name|hs_free_list
expr_stmt|;
name|struct
name|mtx
name|hs_lock
decl_stmt|;
name|struct
name|storvsc_driver_props
modifier|*
name|hs_drv_props
decl_stmt|;
name|int
name|hs_unit
decl_stmt|;
name|uint32_t
name|hs_frozen
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|hs_sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|hs_path
decl_stmt|;
name|uint32_t
name|hs_num_out_reqs
decl_stmt|;
name|boolean_t
name|hs_destroy
decl_stmt|;
name|boolean_t
name|hs_drain_notify
decl_stmt|;
name|struct
name|sema
name|hs_drain_sema
decl_stmt|;
name|struct
name|hv_storvsc_request
name|hs_init_req
decl_stmt|;
name|struct
name|hv_storvsc_request
name|hs_reset_req
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * HyperV storvsc timeout testing cases:  * a. IO returned after first timeout;  * b. IO returned after second timeout and queue freeze;  * c. IO returned while timer handler is running  * The first can be tested by "sg_senddiag -vv /dev/daX",  * and the second and third can be done by  * "sg_wr_mode -v -p 08 -c 0,1a -m 0,ff /dev/daX".  */
end_comment

begin_define
define|#
directive|define
name|HVS_TIMEOUT_TEST
value|0
end_define

begin_comment
comment|/*  * Bus/adapter reset functionality on the Hyper-V host is  * buggy and it will be disabled until  * it can be further tested.  */
end_comment

begin_define
define|#
directive|define
name|HVS_HOST_RESET
value|0
end_define

begin_struct
struct|struct
name|storvsc_driver_props
block|{
name|char
modifier|*
name|drv_name
decl_stmt|;
name|char
modifier|*
name|drv_desc
decl_stmt|;
name|uint8_t
name|drv_max_luns_per_target
decl_stmt|;
name|uint8_t
name|drv_max_ios_per_target
decl_stmt|;
name|uint32_t
name|drv_ringbuffer_size
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|hv_storage_type
block|{
name|DRIVER_BLKVSC
block|,
name|DRIVER_STORVSC
block|,
name|DRIVER_UNKNOWN
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|HS_MAX_ADAPTERS
value|10
end_define

begin_comment
comment|/* {ba6163d9-04a1-4d29-b605-72e2ffb1dc7f} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|hv_guid
name|gStorVscDeviceType
init|=
block|{
operator|.
name|data
operator|=
block|{
literal|0xd9
block|,
literal|0x63
block|,
literal|0x61
block|,
literal|0xba
block|,
literal|0xa1
block|,
literal|0x04
block|,
literal|0x29
block|,
literal|0x4d
block|,
literal|0xb6
block|,
literal|0x05
block|,
literal|0x72
block|,
literal|0xe2
block|,
literal|0xff
block|,
literal|0xb1
block|,
literal|0xdc
block|,
literal|0x7f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* {32412632-86cb-44a2-9b5c-50d1417354f5} */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|hv_guid
name|gBlkVscDeviceType
init|=
block|{
operator|.
name|data
operator|=
block|{
literal|0x32
block|,
literal|0x26
block|,
literal|0x41
block|,
literal|0x32
block|,
literal|0xcb
block|,
literal|0x86
block|,
literal|0xa2
block|,
literal|0x44
block|,
literal|0x9b
block|,
literal|0x5c
block|,
literal|0x50
block|,
literal|0xd1
block|,
literal|0x41
block|,
literal|0x73
block|,
literal|0x54
block|,
literal|0xf5
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|storvsc_driver_props
name|g_drv_props_table
index|[]
init|=
block|{
block|{
literal|"blkvsc"
block|,
literal|"Hyper-V IDE Storage Interface"
block|,
name|BLKVSC_MAX_IDE_DISKS_PER_TARGET
block|,
name|BLKVSC_MAX_IO_REQUESTS
block|,
name|STORVSC_RINGBUFFER_SIZE
block|}
block|,
block|{
literal|"storvsc"
block|,
literal|"Hyper-V SCSI Storage Interface"
block|,
name|STORVSC_MAX_LUNS_PER_TARGET
block|,
name|STORVSC_MAX_IO_REQUESTS
block|,
name|STORVSC_RINGBUFFER_SIZE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|storvsc_softc
modifier|*
name|hs_softc
index|[
name|HS_MAX_ADAPTERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static functions */
end_comment

begin_function_decl
specifier|static
name|int
name|storvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|storvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|storvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_for_luns
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_storvsc_request
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_free_request
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|hv_storage_type
name|storvsc_get_storage_type
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hv_storvsc_on_channel_callback
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hv_storvsc_on_iocompletion
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hv_storvsc_connect_vsp
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storvsc_io_done
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|storvsc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|storvsc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|storvsc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|storvsc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|storvsc_driver
init|=
block|{
literal|"storvsc"
block|,
name|storvsc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|storvsc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|storvsc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|storvsc
argument_list|,
name|vmbus
argument_list|,
name|storvsc_driver
argument_list|,
name|storvsc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|storvsc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|storvsc
argument_list|,
name|vmbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * The host is capable of sending messages to us that are   * completely unsolicited. So, we need to address the race  * condition where we may be in the process of unloading the  * driver when the host may send us an unsolicited message.  * We address this issue by implementing a sequentially  * consistent protocol:  *  * 1. Channel callback is invoked while holding the the channel lock  *    and an unloading driver will reset the channel callback under  *    the protection of this channel lock.  *  * 2. To ensure bounded wait time for unloading a driver, we don't  *    permit outgoing traffic once the device is marked as being  *    destroyed.  *  * 3. Once the device is marked as being destroyed, we only  *    permit incoming traffic to properly account for   *    packets already sent out.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|storvsc_softc
modifier|*
name|get_stor_device
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device
parameter_list|,
name|boolean_t
name|outbound
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|device
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|outbound
condition|)
block|{
comment|/* 		 * Here we permit outgoing I/O only 		 * if the device is not being destroyed. 		 */
if|if
condition|(
name|sc
operator|->
name|hs_destroy
condition|)
block|{
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * inbound case; if being destroyed 		 * only permit to account for 		 * messages already sent out. 		 */
if|if
condition|(
name|sc
operator|->
name|hs_destroy
operator|&&
operator|(
name|sc
operator|->
name|hs_num_out_reqs
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|sc
return|;
block|}
end_function

begin_comment
comment|/**  * @brief initialize channel connection to parent partition  *  * @param dev  a Hyper-V device pointer  * @returns  0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_channel_init
parameter_list|(
name|struct
name|hv_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|dev
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
name|ENODEV
return|;
block|}
name|request
operator|=
operator|&
name|sc
operator|->
name|hs_init_req
expr_stmt|;
name|memset
argument_list|(
name|request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|=
operator|&
name|request
operator|->
name|vstor_packet
expr_stmt|;
name|request
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
comment|/** 	 * Initiate the vsc/vsp initialization protocol on the open channel 	 */
name|sema_init
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|0
argument_list|,
operator|(
literal|"stor_synch_sema"
operator|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_BEGININITIALIZATION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* reuse the packet for version range supported */
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_QUERYPROTOCOLVERSION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|version
operator|.
name|major_minor
operator|=
name|VMSTOR_PROTOCOL_VERSION_CURRENT
expr_stmt|;
comment|/* revision is only significant for Windows guests */
name|vstor_packet
operator|->
name|u
operator|.
name|version
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds */
if|if
condition|(
name|ret
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* TODO: Check returned version */
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/** 	 * Query channel properties 	 */
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_QUERYPROPERTIES
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* TODO: Check returned version */
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|memset
argument_list|(
name|vstor_packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_ENDINITIALIZATION
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|vstor_packet
operator|->
name|operation
operator|!=
name|VSTOR_OPERATION_COMPLETEIO
operator|||
name|vstor_packet
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|sema_destroy
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Open channel connection to paraent partition StorVSP driver  *  * Open and initialize channel connection to parent partition StorVSP driver.  *  * @param pointer to a Hyper-V device  * @returns 0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_connect_vsp
parameter_list|(
name|struct
name|hv_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|vmstor_chan_props
name|props
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
operator|->
name|device
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|props
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmstor_chan_props
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Open the channel 	 */
name|ret
operator|=
name|hv_vmbus_channel_open
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_ringbuffer_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|props
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmstor_chan_props
argument_list|)
argument_list|,
name|hv_storvsc_on_channel_callback
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|hv_storvsc_channel_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HVS_HOST_RESET
end_if

begin_function
specifier|static
name|int
name|hv_storvsc_host_reset
parameter_list|(
name|struct
name|hv_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|dev
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
name|ENODEV
return|;
block|}
name|request
operator|=
operator|&
name|sc
operator|->
name|hs_reset_req
expr_stmt|;
name|request
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|vstor_packet
operator|=
operator|&
name|request
operator|->
name|vstor_packet
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|0
argument_list|,
literal|"stor synch sema"
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_RESETBUS
expr_stmt|;
name|vstor_packet
operator|->
name|flags
operator|=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|dev
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|)
operator|&
name|sc
operator|->
name|hs_reset_req
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds */
if|if
condition|(
name|ret
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * At this point, all outstanding requests in the adapter  	 * should have been flushed out and return to us 	 */
name|cleanup
label|:
name|sema_destroy
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HVS_HOST_RESET */
end_comment

begin_comment
comment|/**  * @brief Function to initiate an I/O request  *  * @param device Hyper-V device pointer  * @param request pointer to a request structure  * @returns 0 on success, non-zero error on failure  */
end_comment

begin_function
specifier|static
name|int
name|hv_storvsc_io_request
parameter_list|(
name|struct
name|hv_device
modifier|*
name|device
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
init|=
operator|&
name|request
operator|->
name|vstor_packet
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|device
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
name|ENODEV
return|;
block|}
name|vstor_packet
operator|->
name|flags
operator||=
name|REQUEST_COMPLETION_FLAG
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vmscsi_req
argument_list|)
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|sense_info_len
operator|=
name|SENSE_BUFFER_SIZE
expr_stmt|;
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
operator|.
name|transfer_len
operator|=
name|request
operator|->
name|data_buf
operator|.
name|length
expr_stmt|;
name|vstor_packet
operator|->
name|operation
operator|=
name|VSTOR_OPERATION_EXECUTESRB
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|request
operator|->
name|softc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|data_buf
operator|.
name|length
condition|)
block|{
name|ret
operator|=
name|hv_vmbus_channel_send_packet_multipagebuffer
argument_list|(
name|device
operator|->
name|channel
argument_list|,
operator|&
name|request
operator|->
name|data_buf
argument_list|,
name|vstor_packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|)
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|hv_vmbus_channel_send_packet
argument_list|(
name|device
operator|->
name|channel
argument_list|,
name|vstor_packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|)
name|request
argument_list|,
name|HV_VMBUS_PACKET_TYPE_DATA_IN_BAND
argument_list|,
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|request
operator|->
name|softc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to send packet %p ret %d"
argument_list|,
name|vstor_packet
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomic_add_int
argument_list|(
operator|&
name|sc
operator|->
name|hs_num_out_reqs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Process IO_COMPLETION_OPERATION and ready  * the result to be completed for upper layer  * processing by the CAM layer.  */
end_comment

begin_function
specifier|static
name|void
name|hv_storvsc_on_iocompletion
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|vmscsi_req
modifier|*
name|vm_srb
decl_stmt|;
name|vm_srb
operator|=
operator|&
name|vstor_packet
operator|->
name|u
operator|.
name|vm_srb
expr_stmt|;
name|request
operator|->
name|sense_info_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|vm_srb
operator|->
name|scsi_status
operator|&
literal|0xFF
operator|)
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
operator|&&
operator|(
name|vm_srb
operator|->
name|srb_status
operator|&
name|SRB_STATUS_AUTOSENSE_VALID
operator|)
condition|)
block|{
comment|/* Autosense data available */
name|KASSERT
argument_list|(
name|vm_srb
operator|->
name|sense_info_len
operator|<=
name|request
operator|->
name|sense_info_len
argument_list|,
operator|(
literal|"vm_srb->sense_info_len<= "
literal|"request->sense_info_len"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|request
operator|->
name|sense_data
argument_list|,
name|vm_srb
operator|->
name|u
operator|.
name|sense_data
argument_list|,
name|vm_srb
operator|->
name|sense_info_len
argument_list|)
expr_stmt|;
name|request
operator|->
name|sense_info_len
operator|=
name|vm_srb
operator|->
name|sense_info_len
expr_stmt|;
block|}
comment|/* Complete request by passing to the CAM layer */
name|storvsc_io_done
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sc
operator|->
name|hs_num_out_reqs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_drain_notify
operator|&&
operator|(
name|sc
operator|->
name|hs_num_out_reqs
operator|==
literal|0
operator|)
condition|)
block|{
name|sema_post
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hv_storvsc_on_channel_callback
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|device
init|=
operator|(
expr|struct
name|hv_device
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|bytes_recvd
decl_stmt|;
name|uint64_t
name|request_id
decl_stmt|;
name|uint8_t
name|packet
index|[
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
literal|8
argument_list|)
index|]
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|request
decl_stmt|;
name|struct
name|vstor_packet
modifier|*
name|vstor_packet
decl_stmt|;
name|sc
operator|=
name|get_stor_device
argument_list|(
name|device
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|KASSERT
argument_list|(
name|device
argument_list|,
operator|(
literal|"device"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_recv_packet
argument_list|(
name|device
operator|->
name|channel
argument_list|,
name|packet
argument_list|,
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|&
name|bytes_recvd
argument_list|,
operator|&
name|request_id
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bytes_recvd
operator|>
literal|0
operator|)
condition|)
block|{
name|request
operator|=
operator|(
expr|struct
name|hv_storvsc_request
operator|*
operator|)
name|request_id
expr_stmt|;
name|KASSERT
argument_list|(
name|request
argument_list|,
operator|(
literal|"request"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|request
operator|==
operator|&
name|sc
operator|->
name|hs_init_req
operator|)
operator|||
operator|(
name|request
operator|==
operator|&
name|sc
operator|->
name|hs_reset_req
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|request
operator|->
name|vstor_packet
argument_list|,
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|)
expr_stmt|;
name|sema_post
argument_list|(
operator|&
name|request
operator|->
name|synch_sema
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vstor_packet
operator|=
operator|(
expr|struct
name|vstor_packet
operator|*
operator|)
name|packet
expr_stmt|;
switch|switch
condition|(
name|vstor_packet
operator|->
name|operation
condition|)
block|{
case|case
name|VSTOR_OPERATION_COMPLETEIO
case|:
name|hv_storvsc_on_iocompletion
argument_list|(
name|sc
argument_list|,
name|vstor_packet
argument_list|,
name|request
argument_list|)
expr_stmt|;
break|break;
case|case
name|VSTOR_OPERATION_REMOVEDEVICE
case|:
comment|/* TODO: implement */
break|break;
default|default:
break|break;
block|}
block|}
name|ret
operator|=
name|hv_vmbus_channel_recv_packet
argument_list|(
name|device
operator|->
name|channel
argument_list|,
name|packet
argument_list|,
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vstor_packet
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|&
name|bytes_recvd
argument_list|,
operator|&
name|request_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief callback function for completing a single LUN scan  *  * This function is responsible for waking up the executer of  * the scan LUN CCB action (cam_periph_runccb.)  cam_periph_ccbwait  * sleeps on the mutex being signaled.  *  * @param periph a pointer to a CAM peripheral  * @param done_ccb pointer to CAM control block  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_xptdone
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|wakeup
argument_list|(
operator|&
name|done_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief scan for attached logical unit numbers (LUNs)  *  * In Hyper-V there is no backend changed device operation which  * presents FreeBSD with a list of devices to connect.  The result is  * that we have to scan for a list of luns in the storvsc_attach()  * routine.  There is only one SCSI target, so scan for the maximum  * number of luns.  *  * @param pointer to softc  */
end_comment

begin_function
specifier|static
name|void
name|scan_for_luns
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|request_ccb
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
init|=
name|sc
operator|->
name|hs_path
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|my_path
init|=
name|NULL
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|lun_nb
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|request_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|my_path
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_path
argument_list|)
argument_list|,
name|M_CAMXPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 		 * Scan the next LUN. Reuse path and ccb structs. 		 */
name|bzero
argument_list|(
name|my_path
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|my_path
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|request_ccb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|request_ccb
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xpt_compile_path
argument_list|(
name|my_path
argument_list|,
name|xpt_periph
argument_list|,
name|path
operator|->
name|bus
operator|->
name|path_id
argument_list|,
literal|0
argument_list|,
name|lun_nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|path
argument_list|,
literal|"scan_for_lunYYY: can't compile"
literal|" path, 0x%p can't continue\n"
argument_list|,
name|sc
operator|->
name|hs_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request_ccb
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|my_path
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|request_ccb
operator|->
name|ccb_h
argument_list|,
name|my_path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|request_ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|storvsc_xptdone
expr_stmt|;
name|request_ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
name|error
operator|=
name|cam_periph_runccb
argument_list|(
name|request_ccb
argument_list|,
name|NULL
argument_list|,
name|CAM_FLAG_NONE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"cam_periph_runccb failed %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|xpt_release_path
argument_list|(
name|my_path
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|lun_nb
operator|<
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_luns_per_target
condition|)
do|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request_ccb
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|my_path
argument_list|,
name|M_CAMXPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC probe function  *  * Device probe function.  Returns 0 if the input device is a StorVSC  * device.  Otherwise, a ENXIO is returned.  If the input device is  * for BlkVSC (paravirtual IDE) device and this support is disabled in  * favor of the emulated ATA/IDE device, return ENXIO.  *  * @param a device  * @returns 0 on success, ENXIO if not a matcing StorVSC device  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|ata_disk_enable
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
name|ENXIO
decl_stmt|;
switch|switch
condition|(
name|storvsc_get_storage_type
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|DRIVER_BLKVSC
case|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DRIVER_BLKVSC-Emulated ATA/IDE probe\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getenv_int
argument_list|(
literal|"hw.ata.disk_enable"
argument_list|,
operator|&
name|ata_disk_enable
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enlightened ATA/IDE detected\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Emulated ATA/IDE set (hw.ata.disk_enable set)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRIVER_STORVSC
case|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enlightened SCSI device detected\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC attach function  *  * Function responsible for allocating per-device structures,  * setting up CAM interfaces and scanning for available LUNs to  * be used for SCSI device peripherals.  *  * @param a device  * @returns 0 on success or an error on failure  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hv_device
modifier|*
name|hv_dev
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|enum
name|hv_storage_type
name|stor_type
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
decl_stmt|;
name|struct
name|root_hold_token
modifier|*
name|root_mount_token
init|=
name|NULL
decl_stmt|;
comment|/* 	 * We need to serialize storvsc attach calls. 	 */
name|root_mount_token
operator|=
name|root_mount_hold
argument_list|(
literal|"storvsc"
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|stor_type
operator|=
name|storvsc_get_storage_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|stor_type
operator|==
name|DRIVER_UNKNOWN
condition|)
block|{
name|ret
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|storvsc_softc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in driver specific properties */
name|sc
operator|->
name|hs_drv_props
operator|=
operator|&
name|g_drv_props_table
index|[
name|stor_type
index|]
expr_stmt|;
comment|/* fill in device specific properties */
name|sc
operator|->
name|hs_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_dev
operator|=
name|hv_dev
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|g_drv_props_table
index|[
name|stor_type
index|]
operator|.
name|drv_desc
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
literal|"hvslck"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
condition|;
operator|++
name|i
control|)
block|{
name|reqp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|,
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|hs_destroy
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|hs_drain_notify
operator|=
name|FALSE
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|,
literal|0
argument_list|,
literal|"Store Drain Sema"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hv_storvsc_connect_vsp
argument_list|(
name|hv_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Create the device queue. 	 * Hyper-V maps each target to one SCSI HBA 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to alloc device queue\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|sc
operator|->
name|hs_sim
operator|=
name|cam_sim_alloc
argument_list|(
name|storvsc_action
argument_list|,
name|storvsc_poll
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_name
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|hs_unit
argument_list|,
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_ios_per_target
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_sim
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to alloc sim\n"
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
comment|/* bus_id is set to 0, need to get it from VMBUS channel query? */
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to register SCSI bus\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|sc
operator|->
name|hs_path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|hs_sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create path\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|scan_for_luns
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|hs_softc
index|[
name|i
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<
name|HS_MAX_ADAPTERS
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|KASSERT
argument_list|(
name|i
operator|<
name|HS_MAX_ADAPTERS
argument_list|,
operator|(
literal|"storvsc_attach: hs_softc full\n"
operator|)
argument_list|)
expr_stmt|;
name|hs_softc
index|[
name|i
index|]
operator|=
name|sc
expr_stmt|;
name|root_mount_rel
argument_list|(
name|root_mount_token
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|root_mount_rel
argument_list|(
name|root_mount_token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC device detach function  *  * This function is responsible for safely detaching a  * StorVSC device.  This includes waiting for inbound responses  * to complete and freeing associated per-device structures.  *  * @param dev a device  * returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|storvsc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|NULL
decl_stmt|;
name|struct
name|hv_device
modifier|*
name|hv_device
init|=
name|vmbus_get_devctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hv_device
operator|->
name|channel
operator|->
name|inbound_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_destroy
operator|=
name|TRUE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hv_device
operator|->
name|channel
operator|->
name|inbound_lock
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, all outbound traffic should be disabled. We 	 * only allow inbound traffic (responses) to proceed so that 	 * outstanding requests can be completed. 	 */
name|sc
operator|->
name|hs_drain_notify
operator|=
name|TRUE
expr_stmt|;
name|sema_wait
argument_list|(
operator|&
name|sc
operator|->
name|hs_drain_sema
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_drain_notify
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Since we have already drained, we don't need to busy wait. 	 * The call to close the channel will reset the callback 	 * under the protection of the incoming channel lock. 	 */
name|hv_vmbus_channel_close
argument_list|(
name|hv_device
operator|->
name|channel
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HVS_TIMEOUT_TEST
end_if

begin_comment
comment|/**  * @brief unit test for timed out operations  *  * This function provides unit testing capability to simulate  * timed out operations.  Recompilation with HV_TIMEOUT_TEST=1  * is required.  *  * @param reqp pointer to a request structure  * @param opcode SCSI operation being performed  * @param wait if 1, wait for I/O to complete  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_timeout_test
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
if|if
condition|(
name|reqp
operator|->
name|vstor_packet
operator|.
name|vm_srb
operator|.
name|cdb
index|[
literal|0
index|]
operator|!=
name|opcode
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|wait
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|hv_storvsc_io_request
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|wait
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: io_request failed with %d.\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wait
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: waiting for IO return.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|,
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: %s.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|,
operator|(
name|ret
operator|==
literal|0
operator|)
condition|?
literal|"IO return detected"
else|:
literal|"IO return not detected"
argument_list|)
expr_stmt|;
comment|/*  		 * Now both the timer handler and io done are running 		 * simultaneously. We want to confirm the io done always 		 * finishes after the timer handler exits. So reqp used by 		 * timer handler is not freed or stale. Do busy loop for 		 * another 1/10 second to make sure io done does 		 * wait for the timer handler to complete. 		 */
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: %s: finishing, queue frozen %d, "
literal|"ccb status 0x%x scsi_status 0x%x.\n"
argument_list|,
name|ticks
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|hs_frozen
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HVS_TIMEOUT_TEST */
end_comment

begin_comment
comment|/**  * @brief timeout handler for requests  *  * This function is called as a result of a callout expiring.  *  * @param arg pointer to a request  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|arg
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
if|if
condition|(
name|reqp
operator|->
name|retries
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO timed out (req=0x%p), wait for another %u secs.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|retries
operator|++
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|storvsc_timeout
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|storvsc_timeout_test
argument_list|(
name|reqp
argument_list|,
name|SEND_DIAGNOSTIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO (reqp = 0x%p) did not return for %u seconds, %s.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
operator|(
name|reqp
operator|->
name|retries
operator|+
literal|1
operator|)
operator|/
literal|1000
argument_list|,
operator|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
operator|)
condition|?
literal|"freezing the queue"
else|:
literal|"the queue is already frozen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hs_frozen
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|storvsc_timeout_test
argument_list|(
name|reqp
argument_list|,
name|MODE_SELECT_10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC device poll function  *  * This function is responsible for servicing requests when  * interrupts are disabled (i.e when we are dumping core.)  *  * @param sim a pointer to a CAM SCSI interface module  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|hv_storvsc_on_channel_callback
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief StorVSC device action function  *  * This function is responsible for handling SCSI operations which  * are passed from the CAM layer.  The requests are in the form of  * CAM control blocks which indicate the action being performed.  * Not all actions require converting the request to a VSCSI protocol  * message - these actions can be responded to by this driver.  * Requests which are destined for a backend storage device are converted  * to a VSCSI protocol message and sent on the channel connection associated  * with this device.  *  * @param sim pointer to a CAM SCSI interface module  * @param ccb pointer to a CAM control block  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|int
name|res
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
operator||
name|PI_SDTR_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|STORVSC_MAX_TARGETS
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_max_luns_per_target
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|300000
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
name|sc
operator|->
name|hs_drv_props
operator|->
name|drv_name
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
comment|/* enable tag queuing and disconnected mode */
name|cts
operator|->
name|proto_specific
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
operator|.
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
operator|.
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|valid
operator|=
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_RESET_DEV
case|:
block|{
if|#
directive|if
name|HVS_HOST_RESET
if|if
condition|(
operator|(
name|res
operator|=
name|hv_storvsc_host_reset
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"hv_storvsc_host_reset failed with %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%s reset not supported.\n"
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_BUS
operator|)
condition|?
literal|"bus"
else|:
literal|"dev"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* HVS_HOST_RESET */
block|}
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"cdl_len is 0\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hs_frozen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|hs_frozen
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/* count*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reqp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_storvsc_request
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|create_storvsc_request
argument_list|(
name|ccb
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|callout_init
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|storvsc_timeout
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|cv_init
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|,
literal|"storvsc timeout cv"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|,
literal|"storvsc timeout mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reqp
operator|->
name|vstor_packet
operator|.
name|vm_srb
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MODE_SELECT_10
case|:
case|case
name|SEND_DIAGNOSTIC
case|:
comment|/* To have timer send the request. */
return|return;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* HVS_TIMEOUT_TEST */
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|hv_storvsc_io_request
argument_list|(
name|sc
operator|->
name|hs_dev
argument_list|,
name|reqp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"hv_storvsc_io_request failed with %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief Fill in a request structure based on a CAM control block  *  * Fills in a request structure based on the contents of a CAM control  * block.  The request structure holds the payload information for  * VSCSI protocol request.  *  * @param ccb pointer to a CAM contorl block  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|void
name|create_storvsc_request
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|uint64_t
name|phys_addr
decl_stmt|;
name|uint32_t
name|bytes_to_copy
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pfn_num
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pfn
decl_stmt|;
comment|/* refer to struct vmscsi_req for meanings of these two fields */
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|port
operator|=
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|path_id
operator|=
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|cdb_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|u
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|u
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_OUT
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|WRITE_TYPE
expr_stmt|;
break|break;
case|case
name|CAM_DIR_IN
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|READ_TYPE
expr_stmt|;
break|break;
case|case
name|CAM_DIR_NONE
case|:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|UNKNOWN_TYPE
expr_stmt|;
break|break;
default|default:
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
operator|.
name|data_in
operator|=
name|UNKNOWN_TYPE
expr_stmt|;
break|break;
block|}
name|reqp
operator|->
name|sense_data
operator|=
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|reqp
operator|->
name|sense_info_len
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
name|reqp
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* 	KASSERT((ccb->ccb_h.flags& CAM_SCATTER_VALID) == 0, 			("ccb is scatter gather valid\n")); 	*/
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|!=
literal|0
condition|)
block|{
name|reqp
operator|->
name|data_buf
operator|.
name|length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|bytes_to_copy
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|csio
operator|->
name|data_ptr
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|offset
operator|=
name|phys_addr
operator|-
name|trunc_page
argument_list|(
name|phys_addr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|bytes_to_copy
operator|!=
literal|0
condition|)
block|{
name|int
name|bytes
decl_stmt|,
name|page_offset
decl_stmt|;
name|phys_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|csio
operator|->
name|data_ptr
index|[
name|reqp
operator|->
name|data_buf
operator|.
name|length
operator|-
name|bytes_to_copy
index|]
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|phys_addr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|reqp
operator|->
name|data_buf
operator|.
name|pfn_array
index|[
name|pfn_num
index|]
operator|=
name|pfn
expr_stmt|;
name|page_offset
operator|=
name|phys_addr
operator|-
name|trunc_page
argument_list|(
name|phys_addr
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|min
argument_list|(
name|PAGE_SIZE
operator|-
name|page_offset
argument_list|,
name|bytes_to_copy
argument_list|)
expr_stmt|;
name|bytes_to_copy
operator|-=
name|bytes
expr_stmt|;
name|pfn_num
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief completion function before returning to CAM  *  * I/O process has been completed and the result needs  * to be passed to the CAM layer.  * Free resources related to this request.  *  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_io_done
parameter_list|(
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|reqp
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|storvsc_softc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|softc
decl_stmt|;
name|struct
name|vmscsi_req
modifier|*
name|vm_srb
init|=
operator|&
name|reqp
operator|->
name|vstor_packet
operator|.
name|u
operator|.
name|vm_srb
decl_stmt|;
if|if
condition|(
name|reqp
operator|->
name|retries
operator|>
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|HVS_TIMEOUT_TEST
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO returned after timeout, "
literal|"waking up timer handler if any.\n"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|event
operator|.
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reqp
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: IO returned after timeout, "
literal|"stopping timer if any.\n"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * callout_drain() will wait for the timer handler to finish 	 * if it is running. So we don't need any lock to synchronize 	 * between this routine and the timer handler. 	 * Note that we need to make sure reqp is not freed when timer 	 * handler is using or will use it. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|callout_drain
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|vm_srb
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_OK
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"srovsc scsi_status = %d\n"
argument_list|,
name|vm_srb
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
operator|(
name|vm_srb
operator|->
name|scsi_status
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|vm_srb
operator|->
name|transfer_len
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|sense_info_len
operator|!=
literal|0
condition|)
block|{
name|csio
operator|->
name|sense_resid
operator|=
name|csio
operator|->
name|sense_len
operator|-
name|reqp
operator|->
name|sense_info_len
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|softc
operator|->
name|hs_frozen
operator|==
literal|1
condition|)
block|{
name|xpt_print
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|"%u: storvsc unfreezing softc 0x%p.\n"
argument_list|,
name|ticks
argument_list|,
name|reqp
operator|->
name|softc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|reqp
operator|->
name|softc
operator|->
name|hs_frozen
operator|=
literal|0
expr_stmt|;
block|}
name|storvsc_free_request
argument_list|(
name|sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|hs_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Free a request structure  *  * Free a request structure by returning it to the free list  *  * @param sc pointer to a softc  * @param reqp pointer to a request structure  */
end_comment

begin_function
specifier|static
name|void
name|storvsc_free_request
parameter_list|(
name|struct
name|storvsc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hv_storvsc_request
modifier|*
name|reqp
parameter_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|hs_free_list
argument_list|,
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Determine type of storage device from GUID  *  * Using the type GUID, determine if this is a StorVSC (paravirtual  * SCSI or BlkVSC (paravirtual IDE) device.  *  * @param dev a device  * returns an enum  */
end_comment

begin_function
specifier|static
name|enum
name|hv_storage_type
name|storvsc_get_storage_type
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|vmbus_get_type
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
operator|&
name|gBlkVscDeviceType
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_guid
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|DRIVER_BLKVSC
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
operator|&
name|gStorVscDeviceType
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_guid
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|DRIVER_STORVSC
return|;
block|}
return|return
operator|(
name|DRIVER_UNKNOWN
operator|)
return|;
block|}
end_function

end_unit

