begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2012,2016 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * Copyright (c) 2012 Citrix Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/vmbus_xact.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/hyperv_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/vmbus_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/vmbus_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/vmbus_brvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/vmbus_chanvar.h>
end_include

begin_function_decl
specifier|static
name|void
name|vmbus_chan_update_evtflagcnt
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vmbus_chan_close_internal
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vmbus_chan_sysctl_mnf
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_sysctl_create
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|vmbus_channel
modifier|*
name|vmbus_chan_alloc
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_free
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vmbus_chan_add
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_cpu_default
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vmbus_chan_release
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_set_chmap
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_clear_chmap
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_detach
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vmbus_chan_wait_revoke
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_ins_prilist
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_rem_prilist
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_ins_list
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_rem_list
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_ins_sublist
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_rem_sublist
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_task_nobatch
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_clrchmap_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_prichan_attach_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_subchan_attach_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_prichan_detach_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_subchan_detach_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_msgproc_choffer
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|vmbus_message
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_msgproc_chrescind
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|vmbus_message
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vmbus_chan_printf
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__printflike
parameter_list|(
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Vmbus channel message processing.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|vmbus_chanmsg_proc_t
name|vmbus_chan_msgprocs
index|[
name|VMBUS_CHANMSG_TYPE_MAX
index|]
init|=
block|{
name|VMBUS_CHANMSG_PROC
argument_list|(
name|CHOFFER
argument_list|,
name|vmbus_chan_msgproc_choffer
argument_list|)
block|,
name|VMBUS_CHANMSG_PROC
argument_list|(
name|CHRESCIND
argument_list|,
name|vmbus_chan_msgproc_chrescind
argument_list|)
block|,
name|VMBUS_CHANMSG_PROC_WAKEUP
argument_list|(
name|CHOPEN_RESP
argument_list|)
block|,
name|VMBUS_CHANMSG_PROC_WAKEUP
argument_list|(
name|GPADL_CONNRESP
argument_list|)
block|,
name|VMBUS_CHANMSG_PROC_WAKEUP
argument_list|(
argument|GPADL_DISCONNRESP
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Notify host that there are data pending on our TX bufring.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|vmbus_chan_signal_tx
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|atomic_set_long
argument_list|(
name|chan
operator|->
name|ch_evtflag
argument_list|,
name|chan
operator|->
name|ch_evtflag_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_txflags
operator|&
name|VMBUS_CHAN_TXF_HASMNF
condition|)
name|atomic_set_int
argument_list|(
name|chan
operator|->
name|ch_montrig
argument_list|,
name|chan
operator|->
name|ch_montrig_mask
argument_list|)
expr_stmt|;
else|else
name|hypercall_signal_event
argument_list|(
name|chan
operator|->
name|ch_monprm_dma
operator|.
name|hv_paddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_ins_prilist
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_testandset_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_ONPRIL_SHIFT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"channel is already on the prilist"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichans
argument_list|,
name|chan
argument_list|,
name|ch_prilink
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_rem_prilist
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_testandclear_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_ONPRIL_SHIFT
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"channel is not on the prilist"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichans
argument_list|,
name|chan
argument_list|,
name|ch_prilink
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_ins_sublist
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|prichan
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|prichan
operator|->
name|ch_subchan_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_testandset_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_ONSUBL_SHIFT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"channel is already on the sublist"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|prichan
operator|->
name|ch_subchans
argument_list|,
name|chan
argument_list|,
name|ch_sublink
argument_list|)
expr_stmt|;
comment|/* Bump sub-channel count. */
name|prichan
operator|->
name|ch_subchan_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_rem_sublist
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|prichan
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|prichan
operator|->
name|ch_subchan_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|prichan
operator|->
name|ch_subchan_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid subchan_cnt %d"
operator|,
name|prichan
operator|->
name|ch_subchan_cnt
operator|)
argument_list|)
expr_stmt|;
name|prichan
operator|->
name|ch_subchan_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|atomic_testandclear_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_ONSUBL_SHIFT
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"channel is not on the sublist"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|prichan
operator|->
name|ch_subchans
argument_list|,
name|chan
argument_list|,
name|ch_sublink
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_ins_list
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_testandset_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_ONLIST_SHIFT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"channel is already on the list"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chans
argument_list|,
name|chan
argument_list|,
name|ch_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_rem_list
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_testandclear_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_ONLIST_SHIFT
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"channel is not on the list"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chans
argument_list|,
name|chan
argument_list|,
name|ch_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmbus_chan_sysctl_mnf
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
init|=
name|arg1
decl_stmt|;
name|int
name|mnf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_txflags
operator|&
name|VMBUS_CHAN_TXF_HASMNF
condition|)
name|mnf
operator|=
literal|1
expr_stmt|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|mnf
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_sysctl_create
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|ch_tree
decl_stmt|,
modifier|*
name|chid_tree
decl_stmt|,
modifier|*
name|br_tree
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|uint32_t
name|ch_id
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * Add sysctl nodes related to this channel to this 	 * channel's sysctl ctx, so that they can be destroyed 	 * independently upon close of this channel, which can 	 * happen even if the device is not detached. 	 */
name|ctx
operator|=
operator|&
name|chan
operator|->
name|ch_sysctl_ctx
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Create dev.NAME.UNIT.channel tree. 	 */
name|ch_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|chan
operator|->
name|ch_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"channel"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch_tree
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Create dev.NAME.UNIT.channel.CHANID tree. 	 */
if|if
condition|(
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
condition|)
name|ch_id
operator|=
name|chan
operator|->
name|ch_id
expr_stmt|;
else|else
name|ch_id
operator|=
name|chan
operator|->
name|ch_prichan
operator|->
name|ch_id
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ch_id
argument_list|)
expr_stmt|;
name|chid_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|ch_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|chid_tree
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 		 * Create dev.NAME.UNIT.channel.CHANID.sub tree. 		 */
name|ch_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chid_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sub"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch_tree
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * Create dev.NAME.UNIT.channel.CHANID.sub.SUBIDX tree. 		 * 		 * NOTE: 		 * chid_tree is changed to this new sysctl tree. 		 */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|chan
operator|->
name|ch_subidx
argument_list|)
expr_stmt|;
name|chid_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|ch_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|chid_tree
operator|==
name|NULL
condition|)
return|return;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chid_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chanid"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|chan
operator|->
name|ch_id
argument_list|,
literal|0
argument_list|,
literal|"channel id"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chid_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpu"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|chan
operator|->
name|ch_cpuid
argument_list|,
literal|0
argument_list|,
literal|"owner CPU id"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chid_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mnf"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|chan
argument_list|,
literal|0
argument_list|,
name|vmbus_chan_sysctl_mnf
argument_list|,
literal|"I"
argument_list|,
literal|"has monitor notification facilities"
argument_list|)
expr_stmt|;
name|br_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chid_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"br"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|br_tree
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Create sysctl tree for RX bufring. 		 */
name|vmbus_br_sysctl_create
argument_list|(
name|ctx
argument_list|,
name|br_tree
argument_list|,
operator|&
name|chan
operator|->
name|ch_rxbr
operator|.
name|rxbr
argument_list|,
literal|"rx"
argument_list|)
expr_stmt|;
comment|/* 		 * Create sysctl tree for TX bufring. 		 */
name|vmbus_br_sysctl_create
argument_list|(
name|ctx
argument_list|,
name|br_tree
argument_list|,
operator|&
name|chan
operator|->
name|ch_txbr
operator|.
name|txbr
argument_list|,
literal|"tx"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|vmbus_chan_open
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|int
name|txbr_size
parameter_list|,
name|int
name|rxbr_size
parameter_list|,
specifier|const
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|udlen
parameter_list|,
name|vmbus_chan_callback_t
name|cb
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|struct
name|vmbus_chan_br
name|cbr
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Allocate the TX+RX bufrings. 	 */
name|KASSERT
argument_list|(
name|chan
operator|->
name|ch_bufring
operator|==
name|NULL
argument_list|,
operator|(
literal|"bufrings are allocated"
operator|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_bufring
operator|=
name|hyperv_dmamem_alloc
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|chan
operator|->
name|ch_dev
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|txbr_size
operator|+
name|rxbr_size
argument_list|,
operator|&
name|chan
operator|->
name|ch_bufring_dma
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_bufring
operator|==
name|NULL
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"bufring allocation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|cbr
operator|.
name|cbr
operator|=
name|chan
operator|->
name|ch_bufring
expr_stmt|;
name|cbr
operator|.
name|cbr_paddr
operator|=
name|chan
operator|->
name|ch_bufring_dma
operator|.
name|hv_paddr
expr_stmt|;
name|cbr
operator|.
name|cbr_txsz
operator|=
name|txbr_size
expr_stmt|;
name|cbr
operator|.
name|cbr_rxsz
operator|=
name|rxbr_size
expr_stmt|;
name|error
operator|=
name|vmbus_chan_open_br
argument_list|(
name|chan
argument_list|,
operator|&
name|cbr
argument_list|,
name|udata
argument_list|,
name|udlen
argument_list|,
name|cb
argument_list|,
name|cbarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EISCONN
condition|)
block|{
comment|/* 			 * XXX 			 * The bufring GPADL is still connected; abandon 			 * this bufring, instead of having mysterious 			 * crash or trashed data later on. 			 */
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u bufring GPADL "
literal|"is still connected upon channel open error; "
literal|"leak %d bytes memory\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|txbr_size
operator|+
name|rxbr_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hyperv_dmamem_free
argument_list|(
operator|&
name|chan
operator|->
name|ch_bufring_dma
argument_list|,
name|chan
operator|->
name|ch_bufring
argument_list|)
expr_stmt|;
block|}
name|chan
operator|->
name|ch_bufring
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vmbus_chan_open_br
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|struct
name|vmbus_chan_br
modifier|*
name|cbr
parameter_list|,
specifier|const
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|udlen
parameter_list|,
name|vmbus_chan_callback_t
name|cb
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|chan
operator|->
name|ch_vmbus
decl_stmt|;
specifier|const
name|struct
name|vmbus_chanmsg_chopen_resp
modifier|*
name|resp
decl_stmt|;
specifier|const
name|struct
name|vmbus_message
modifier|*
name|msg
decl_stmt|;
name|struct
name|vmbus_chanmsg_chopen
modifier|*
name|req
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|error
decl_stmt|,
name|txbr_size
decl_stmt|,
name|rxbr_size
decl_stmt|;
name|task_fn_t
modifier|*
name|task_fn
decl_stmt|;
name|uint8_t
modifier|*
name|br
decl_stmt|;
if|if
condition|(
name|udlen
operator|>
name|VMBUS_CHANMSG_CHOPEN_UDATA_SIZE
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"invalid udata len %d for chan%u\n"
argument_list|,
name|udlen
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|br
operator|=
name|cbr
operator|->
name|cbr
expr_stmt|;
name|txbr_size
operator|=
name|cbr
operator|->
name|cbr_txsz
expr_stmt|;
name|rxbr_size
operator|=
name|cbr
operator|->
name|cbr_rxsz
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|txbr_size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"send bufring size is not multiple page"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|rxbr_size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"recv bufring size is not multiple page"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|cbr
operator|->
name|cbr_paddr
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"bufring is not page aligned"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Zero out the TX/RX bufrings, in case that they were used before. 	 */
name|memset
argument_list|(
name|br
argument_list|,
literal|0
argument_list|,
name|txbr_size
operator|+
name|rxbr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_testandset_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_OPENED_SHIFT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"double-open chan%u"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_cb
operator|=
name|cb
expr_stmt|;
name|chan
operator|->
name|ch_cbarg
operator|=
name|cbarg
expr_stmt|;
name|vmbus_chan_update_evtflagcnt
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_tq
operator|=
name|VMBUS_PCPU_GET
argument_list|(
name|chan
operator|->
name|ch_vmbus
argument_list|,
name|event_tq
argument_list|,
name|chan
operator|->
name|ch_cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_flags
operator|&
name|VMBUS_CHAN_FLAG_BATCHREAD
condition|)
name|task_fn
operator|=
name|vmbus_chan_task
expr_stmt|;
else|else
name|task_fn
operator|=
name|vmbus_chan_task_nobatch
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|chan
operator|->
name|ch_task
argument_list|,
literal|0
argument_list|,
name|task_fn
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* TX bufring comes first */
name|vmbus_txbr_setup
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|,
name|br
argument_list|,
name|txbr_size
argument_list|)
expr_stmt|;
comment|/* RX bufring immediately follows TX bufring */
name|vmbus_rxbr_setup
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|,
name|br
operator|+
name|txbr_size
argument_list|,
name|rxbr_size
argument_list|)
expr_stmt|;
comment|/* Create sysctl tree for this channel */
name|vmbus_chan_sysctl_create
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * Connect the bufrings, both RX and TX, to this channel. 	 */
name|KASSERT
argument_list|(
name|chan
operator|->
name|ch_bufring_gpadl
operator|==
literal|0
argument_list|,
operator|(
literal|"bufring GPADL is still connected"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmbus_chan_gpadl_connect
argument_list|(
name|chan
argument_list|,
name|cbr
operator|->
name|cbr_paddr
argument_list|,
name|txbr_size
operator|+
name|rxbr_size
argument_list|,
operator|&
name|chan
operator|->
name|ch_bufring_gpadl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"failed to connect bufring GPADL to chan%u\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Install this channel, before it is opened, but after everything 	 * else has been setup. 	 */
name|vmbus_chan_set_chmap
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * Open channel w/ the bufring GPADL on the target CPU. 	 */
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"can not get msg hypercall for chopen(chan%u)\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_CHOPEN
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|chan
operator|->
name|ch_id
expr_stmt|;
name|req
operator|->
name|chm_openid
operator|=
name|chan
operator|->
name|ch_id
expr_stmt|;
name|req
operator|->
name|chm_gpadl
operator|=
name|chan
operator|->
name|ch_bufring_gpadl
expr_stmt|;
name|req
operator|->
name|chm_vcpuid
operator|=
name|chan
operator|->
name|ch_vcpuid
expr_stmt|;
name|req
operator|->
name|chm_txbr_pgcnt
operator|=
name|txbr_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|udlen
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|req
operator|->
name|chm_udata
argument_list|,
name|udata
argument_list|,
name|udlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmbus_msghc_exec
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chopen(chan%u) msg hypercall exec failed: %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|msg
operator|=
name|vmbus_msghc_wait_result
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|(
specifier|const
expr|struct
name|vmbus_chanmsg_chopen_resp
operator|*
operator|)
name|msg
operator|->
name|msg_data
expr_stmt|;
name|status
operator|=
name|resp
operator|->
name|chm_status
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u opened\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"failed to open chan%u\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
name|failed
label|:
name|sysctl_ctx_free
argument_list|(
operator|&
name|chan
operator|->
name|ch_sysctl_ctx
argument_list|)
expr_stmt|;
name|vmbus_chan_clear_chmap
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_bufring_gpadl
operator|!=
literal|0
condition|)
block|{
name|int
name|error1
decl_stmt|;
name|error1
operator|=
name|vmbus_chan_gpadl_disconnect
argument_list|(
name|chan
argument_list|,
name|chan
operator|->
name|ch_bufring_gpadl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error1
condition|)
block|{
comment|/* 			 * Give caller a hint that the bufring GPADL is still 			 * connected. 			 */
name|error
operator|=
name|EISCONN
expr_stmt|;
block|}
name|chan
operator|->
name|ch_bufring_gpadl
operator|=
literal|0
expr_stmt|;
block|}
name|atomic_clear_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_OPENED
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vmbus_chan_gpadl_connect
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|int
name|size
parameter_list|,
name|uint32_t
modifier|*
name|gpadl0
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|chan
operator|->
name|ch_vmbus
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|struct
name|vmbus_chanmsg_gpadl_conn
modifier|*
name|req
decl_stmt|;
specifier|const
name|struct
name|vmbus_message
modifier|*
name|msg
decl_stmt|;
name|size_t
name|reqsz
decl_stmt|;
name|uint32_t
name|gpadl
decl_stmt|,
name|status
decl_stmt|;
name|int
name|page_count
decl_stmt|,
name|range_len
decl_stmt|,
name|i
decl_stmt|,
name|cnt
decl_stmt|,
name|error
decl_stmt|;
name|uint64_t
name|page_id
decl_stmt|;
comment|/* 	 * Preliminary checks. 	 */
name|KASSERT
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid GPA size %d, not multiple page size"
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|page_count
operator|=
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|paddr
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"GPA is not page aligned %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|paddr
operator|)
argument_list|)
expr_stmt|;
name|page_id
operator|=
name|paddr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|range_len
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_gpa_range
argument_list|,
name|gpa_page
index|[
name|page_count
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * We don't support multiple GPA ranges. 	 */
if|if
condition|(
name|range_len
operator|>
name|UINT16_MAX
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"GPA too large, %d pages\n"
argument_list|,
name|page_count
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
comment|/* 	 * Allocate GPADL id. 	 */
name|gpadl
operator|=
name|vmbus_gpadl_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Connect this GPADL to the target channel. 	 * 	 * NOTE: 	 * Since each message can only hold small set of page 	 * addresses, several messages may be required to 	 * complete the connection. 	 */
if|if
condition|(
name|page_count
operator|>
name|VMBUS_CHANMSG_GPADL_CONN_PGMAX
condition|)
name|cnt
operator|=
name|VMBUS_CHANMSG_GPADL_CONN_PGMAX
expr_stmt|;
else|else
name|cnt
operator|=
name|page_count
expr_stmt|;
name|page_count
operator|-=
name|cnt
expr_stmt|;
name|reqsz
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_chanmsg_gpadl_conn
argument_list|,
name|chm_range
operator|.
name|gpa_page
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
name|reqsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"can not get msg hypercall for gpadl_conn(chan%u)\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_GPADL_CONN
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|chan
operator|->
name|ch_id
expr_stmt|;
name|req
operator|->
name|chm_gpadl
operator|=
name|gpadl
expr_stmt|;
name|req
operator|->
name|chm_range_len
operator|=
name|range_len
expr_stmt|;
name|req
operator|->
name|chm_range_cnt
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|chm_range
operator|.
name|gpa_len
operator|=
name|size
expr_stmt|;
name|req
operator|->
name|chm_range
operator|.
name|gpa_ofs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
operator|++
name|i
control|)
name|req
operator|->
name|chm_range
operator|.
name|gpa_page
index|[
name|i
index|]
operator|=
name|page_id
operator|++
expr_stmt|;
name|error
operator|=
name|vmbus_msghc_exec
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"gpadl_conn(chan%u) msg hypercall exec failed: %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
while|while
condition|(
name|page_count
operator|>
literal|0
condition|)
block|{
name|struct
name|vmbus_chanmsg_gpadl_subconn
modifier|*
name|subreq
decl_stmt|;
if|if
condition|(
name|page_count
operator|>
name|VMBUS_CHANMSG_GPADL_SUBCONN_PGMAX
condition|)
name|cnt
operator|=
name|VMBUS_CHANMSG_GPADL_SUBCONN_PGMAX
expr_stmt|;
else|else
name|cnt
operator|=
name|page_count
expr_stmt|;
name|page_count
operator|-=
name|cnt
expr_stmt|;
name|reqsz
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_chanmsg_gpadl_subconn
argument_list|,
name|chm_gpa_page
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|vmbus_msghc_reset
argument_list|(
name|mh
argument_list|,
name|reqsz
argument_list|)
expr_stmt|;
name|subreq
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|subreq
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_GPADL_SUBCONN
expr_stmt|;
name|subreq
operator|->
name|chm_gpadl
operator|=
name|gpadl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
operator|++
name|i
control|)
name|subreq
operator|->
name|chm_gpa_page
index|[
name|i
index|]
operator|=
name|page_id
operator|++
expr_stmt|;
name|vmbus_msghc_exec_noresult
argument_list|(
name|mh
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|page_count
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid page count %d"
operator|,
name|page_count
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|vmbus_msghc_wait_result
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|vmbus_chanmsg_gpadl_connresp
operator|*
operator|)
name|msg
operator|->
name|msg_data
operator|)
operator|->
name|chm_status
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"gpadl_conn(chan%u) failed: %u\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* Done; commit the GPADL id. */
operator|*
name|gpadl0
operator|=
name|gpadl
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"gpadl_conn(chan%u) succeeded\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|vmbus_chan_wait_revoke
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|WAIT_COUNT
value|200
comment|/* 200ms */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WAIT_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vmbus_chan_is_revoked
argument_list|(
name|chan
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* Not sure about the context; use busy-wait. */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
undef|#
directive|undef
name|WAIT_COUNT
block|}
end_function

begin_comment
comment|/*  * Disconnect the GPA from the target channel  */
end_comment

begin_function
name|int
name|vmbus_chan_gpadl_disconnect
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|uint32_t
name|gpadl
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|chan
operator|->
name|ch_vmbus
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|struct
name|vmbus_chanmsg_gpadl_disconn
modifier|*
name|req
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"can not get msg hypercall for gpadl_disconn(chan%u)\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_GPADL_DISCONN
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|chan
operator|->
name|ch_id
expr_stmt|;
name|req
operator|->
name|chm_gpadl
operator|=
name|gpadl
expr_stmt|;
name|error
operator|=
name|vmbus_msghc_exec
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmbus_chan_wait_revoke
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 			 * Error is benign; this channel is revoked, 			 * so this GPADL will not be touched anymore. 			 */
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"gpadl_disconn(revoked chan%u) msg hypercall "
literal|"exec failed: %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"gpadl_disconn(chan%u) msg hypercall exec failed: %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vmbus_msghc_wait_result
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
comment|/* Discard result; no useful information */
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_detach
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|refs
decl_stmt|;
name|KASSERT
argument_list|(
name|chan
operator|->
name|ch_refs
operator|>
literal|0
argument_list|,
operator|(
literal|"chan%u: invalid refcnt %d"
operator|,
name|chan
operator|->
name|ch_id
operator|,
name|chan
operator|->
name|ch_refs
operator|)
argument_list|)
expr_stmt|;
name|refs
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_refs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|refs
operator|==
literal|1
argument_list|,
operator|(
literal|"chan%u: invalid refcnt %d for prichan"
operator|,
name|chan
operator|->
name|ch_id
operator|,
name|refs
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|refs
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Detach the target channel. 		 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u detached\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
block|}
name|taskqueue_enqueue
argument_list|(
name|chan
operator|->
name|ch_mgmt_tq
argument_list|,
operator|&
name|chan
operator|->
name|ch_detach_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_clrchmap_task
parameter_list|(
name|void
modifier|*
name|xchan
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
init|=
name|xchan
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|chan
operator|->
name|ch_vmbus
operator|->
name|vmbus_chmap
index|[
name|chan
operator|->
name|ch_id
index|]
operator|=
name|NULL
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_clear_chmap
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|task
name|chmap_task
decl_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|chmap_task
argument_list|,
literal|0
argument_list|,
name|vmbus_chan_clrchmap_task
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|chan
operator|->
name|ch_tq
argument_list|,
operator|&
name|chmap_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|chan
operator|->
name|ch_tq
argument_list|,
operator|&
name|chmap_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_set_chmap
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|__compiler_membar
argument_list|()
expr_stmt|;
name|chan
operator|->
name|ch_vmbus
operator|->
name|vmbus_chmap
index|[
name|chan
operator|->
name|ch_id
index|]
operator|=
name|chan
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmbus_chan_close_internal
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|chan
operator|->
name|ch_vmbus
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|struct
name|vmbus_chanmsg_chclose
modifier|*
name|req
decl_stmt|;
name|uint32_t
name|old_stflags
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * NOTE: 	 * Sub-channels are closed upon their primary channel closing, 	 * so they can be closed even before they are opened. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|old_stflags
operator|=
name|chan
operator|->
name|ch_stflags
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|old_stflags
argument_list|,
name|old_stflags
operator|&
operator|~
name|VMBUS_CHAN_ST_OPENED
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|old_stflags
operator|&
name|VMBUS_CHAN_ST_OPENED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Not opened yet; done */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u not opened\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Free this channel's sysctl tree attached to its device's 	 * sysctl tree. 	 */
name|sysctl_ctx_free
argument_list|(
operator|&
name|chan
operator|->
name|ch_sysctl_ctx
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: 	 * Order is critical.  This channel _must_ be uninstalled first, 	 * else the channel task may be enqueued by the IDT after it has 	 * been drained. 	 */
name|vmbus_chan_clear_chmap
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|chan
operator|->
name|ch_tq
argument_list|,
operator|&
name|chan
operator|->
name|ch_task
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_tq
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Close this channel. 	 */
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"can not get msg hypercall for chclose(chan%u)\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|disconnect
goto|;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_CHCLOSE
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|chan
operator|->
name|ch_id
expr_stmt|;
name|error
operator|=
name|vmbus_msghc_exec_noresult
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chclose(chan%u) msg hypercall exec failed: %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|disconnect
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u closed\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|disconnect
label|:
comment|/* 	 * Disconnect the TX+RX bufrings from this channel. 	 */
if|if
condition|(
name|chan
operator|->
name|ch_bufring_gpadl
operator|!=
literal|0
condition|)
block|{
name|int
name|error1
decl_stmt|;
name|error1
operator|=
name|vmbus_chan_gpadl_disconnect
argument_list|(
name|chan
argument_list|,
name|chan
operator|->
name|ch_bufring_gpadl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error1
condition|)
block|{
comment|/* 			 * XXX 			 * The bufring GPADL is still connected; abandon 			 * this bufring, instead of having mysterious 			 * crash or trashed data later on. 			 */
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u bufring GPADL "
literal|"is still connected after close\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_bufring
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Give caller a hint that the bufring GPADL is 			 * still connected. 			 */
name|error
operator|=
name|EISCONN
expr_stmt|;
block|}
name|chan
operator|->
name|ch_bufring_gpadl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Destroy the TX+RX bufrings. 	 */
if|if
condition|(
name|chan
operator|->
name|ch_bufring
operator|!=
name|NULL
condition|)
block|{
name|hyperv_dmamem_free
argument_list|(
operator|&
name|chan
operator|->
name|ch_bufring_dma
argument_list|,
name|chan
operator|->
name|ch_bufring
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_bufring
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Caller should make sure that all sub-channels have  * been added to 'chan' and all to-be-closed channels  * are not being opened.  */
end_comment

begin_function
name|void
name|vmbus_chan_close
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|subchan_cnt
decl_stmt|;
if|if
condition|(
operator|!
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 		 * Sub-channel is closed when its primary channel 		 * is closed; done. 		 */
return|return;
block|}
comment|/* 	 * Close all sub-channels, if any. 	 */
name|subchan_cnt
operator|=
name|chan
operator|->
name|ch_subchan_cnt
expr_stmt|;
if|if
condition|(
name|subchan_cnt
operator|>
literal|0
condition|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subchan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|subchan
operator|=
name|vmbus_subchan_get
argument_list|(
name|chan
argument_list|,
name|subchan_cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subchan_cnt
condition|;
operator|++
name|i
control|)
block|{
name|vmbus_chan_close_internal
argument_list|(
name|subchan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * This sub-channel is referenced, when it is 			 * linked to the primary channel; drop that 			 * reference now. 			 */
name|vmbus_chan_detach
argument_list|(
name|subchan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|vmbus_subchan_rel
argument_list|(
name|subchan
argument_list|,
name|subchan_cnt
argument_list|)
expr_stmt|;
block|}
comment|/* Then close the primary channel. */
name|vmbus_chan_close_internal
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmbus_chan_intr_drain
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|taskqueue_drain
argument_list|(
name|chan
operator|->
name|ch_tq
argument_list|,
operator|&
name|chan
operator|->
name|ch_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vmbus_chan_send
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|,
name|uint64_t
name|xactid
parameter_list|)
block|{
name|struct
name|vmbus_chanpkt
name|pkt
decl_stmt|;
name|int
name|pktlen
decl_stmt|,
name|pad_pktlen
decl_stmt|,
name|hlen
decl_stmt|,
name|error
decl_stmt|;
name|uint64_t
name|pad
init|=
literal|0
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|3
index|]
decl_stmt|;
name|boolean_t
name|send_evt
decl_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|hlen
operator|+
name|dlen
expr_stmt|;
name|pad_pktlen
operator|=
name|VMBUS_CHANPKT_TOTLEN
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pad_pktlen
operator|<=
name|vmbus_txbr_maxpktsz
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|)
argument_list|,
operator|(
literal|"invalid packet size %d"
operator|,
name|pad_pktlen
operator|)
argument_list|)
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_type
operator|=
name|type
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_flags
operator|=
name|flags
expr_stmt|;
name|VMBUS_CHANPKT_SETLEN
argument_list|(
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_hlen
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|VMBUS_CHANPKT_SETLEN
argument_list|(
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_tlen
argument_list|,
name|pad_pktlen
argument_list|)
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_xactid
operator|=
name|xactid
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|&
name|pkt
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|hlen
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|data
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|dlen
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_base
operator|=
operator|&
name|pad
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_len
operator|=
name|pad_pktlen
operator|-
name|pktlen
expr_stmt|;
name|error
operator|=
name|vmbus_txbr_write
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|,
name|iov
argument_list|,
literal|3
argument_list|,
operator|&
name|send_evt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|send_evt
condition|)
name|vmbus_chan_signal_tx
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|vmbus_chan_send_sglist
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|struct
name|vmbus_gpa
name|sg
index|[]
parameter_list|,
name|int
name|sglen
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|,
name|uint64_t
name|xactid
parameter_list|)
block|{
name|struct
name|vmbus_chanpkt_sglist
name|pkt
decl_stmt|;
name|int
name|pktlen
decl_stmt|,
name|pad_pktlen
decl_stmt|,
name|hlen
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|4
index|]
decl_stmt|;
name|boolean_t
name|send_evt
decl_stmt|;
name|uint64_t
name|pad
init|=
literal|0
decl_stmt|;
name|hlen
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_chanpkt_sglist
argument_list|,
name|cp_gpa
index|[
name|sglen
index|]
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|hlen
operator|+
name|dlen
expr_stmt|;
name|pad_pktlen
operator|=
name|VMBUS_CHANPKT_TOTLEN
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pad_pktlen
operator|<=
name|vmbus_txbr_maxpktsz
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|)
argument_list|,
operator|(
literal|"invalid packet size %d"
operator|,
name|pad_pktlen
operator|)
argument_list|)
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_type
operator|=
name|VMBUS_CHANPKT_TYPE_GPA
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_flags
operator|=
name|VMBUS_CHANPKT_FLAG_RC
expr_stmt|;
name|VMBUS_CHANPKT_SETLEN
argument_list|(
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_hlen
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|VMBUS_CHANPKT_SETLEN
argument_list|(
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_tlen
argument_list|,
name|pad_pktlen
argument_list|)
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_xactid
operator|=
name|xactid
expr_stmt|;
name|pkt
operator|.
name|cp_rsvd
operator|=
literal|0
expr_stmt|;
name|pkt
operator|.
name|cp_gpa_cnt
operator|=
name|sglen
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|&
name|pkt
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|sg
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vmbus_gpa
argument_list|)
operator|*
name|sglen
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_base
operator|=
name|data
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_len
operator|=
name|dlen
expr_stmt|;
name|iov
index|[
literal|3
index|]
operator|.
name|iov_base
operator|=
operator|&
name|pad
expr_stmt|;
name|iov
index|[
literal|3
index|]
operator|.
name|iov_len
operator|=
name|pad_pktlen
operator|-
name|pktlen
expr_stmt|;
name|error
operator|=
name|vmbus_txbr_write
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|,
name|iov
argument_list|,
literal|4
argument_list|,
operator|&
name|send_evt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|send_evt
condition|)
name|vmbus_chan_signal_tx
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|vmbus_chan_send_prplist
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|struct
name|vmbus_gpa_range
modifier|*
name|prp
parameter_list|,
name|int
name|prp_cnt
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|,
name|uint64_t
name|xactid
parameter_list|)
block|{
name|struct
name|vmbus_chanpkt_prplist
name|pkt
decl_stmt|;
name|int
name|pktlen
decl_stmt|,
name|pad_pktlen
decl_stmt|,
name|hlen
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|4
index|]
decl_stmt|;
name|boolean_t
name|send_evt
decl_stmt|;
name|uint64_t
name|pad
init|=
literal|0
decl_stmt|;
name|hlen
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_chanpkt_prplist
argument_list|,
name|cp_range
index|[
literal|0
index|]
operator|.
name|gpa_page
index|[
name|prp_cnt
index|]
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|hlen
operator|+
name|dlen
expr_stmt|;
name|pad_pktlen
operator|=
name|VMBUS_CHANPKT_TOTLEN
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pad_pktlen
operator|<=
name|vmbus_txbr_maxpktsz
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|)
argument_list|,
operator|(
literal|"invalid packet size %d"
operator|,
name|pad_pktlen
operator|)
argument_list|)
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_type
operator|=
name|VMBUS_CHANPKT_TYPE_GPA
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_flags
operator|=
name|VMBUS_CHANPKT_FLAG_RC
expr_stmt|;
name|VMBUS_CHANPKT_SETLEN
argument_list|(
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_hlen
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|VMBUS_CHANPKT_SETLEN
argument_list|(
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_tlen
argument_list|,
name|pad_pktlen
argument_list|)
expr_stmt|;
name|pkt
operator|.
name|cp_hdr
operator|.
name|cph_xactid
operator|=
name|xactid
expr_stmt|;
name|pkt
operator|.
name|cp_rsvd
operator|=
literal|0
expr_stmt|;
name|pkt
operator|.
name|cp_range_cnt
operator|=
literal|1
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|&
name|pkt
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|prp
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_gpa_range
argument_list|,
name|gpa_page
index|[
name|prp_cnt
index|]
argument_list|)
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_base
operator|=
name|data
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_len
operator|=
name|dlen
expr_stmt|;
name|iov
index|[
literal|3
index|]
operator|.
name|iov_base
operator|=
operator|&
name|pad
expr_stmt|;
name|iov
index|[
literal|3
index|]
operator|.
name|iov_len
operator|=
name|pad_pktlen
operator|-
name|pktlen
expr_stmt|;
name|error
operator|=
name|vmbus_txbr_write
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|,
name|iov
argument_list|,
literal|4
argument_list|,
operator|&
name|send_evt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|send_evt
condition|)
name|vmbus_chan_signal_tx
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|vmbus_chan_recv
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|dlen0
parameter_list|,
name|uint64_t
modifier|*
name|xactid
parameter_list|)
block|{
name|struct
name|vmbus_chanpkt_hdr
name|pkt
decl_stmt|;
name|int
name|error
decl_stmt|,
name|dlen
decl_stmt|,
name|hlen
decl_stmt|;
name|error
operator|=
name|vmbus_rxbr_peek
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|,
operator|&
name|pkt
argument_list|,
sizeof|sizeof
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|.
name|cph_hlen
operator|<
name|VMBUS_CHANPKT_HLEN_MIN
argument_list|)
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"invalid hlen %u\n"
argument_list|,
name|pkt
operator|.
name|cph_hlen
argument_list|)
expr_stmt|;
comment|/* XXX this channel is dead actually. */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|.
name|cph_hlen
operator|>
name|pkt
operator|.
name|cph_tlen
argument_list|)
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"invalid hlen %u and tlen %u\n"
argument_list|,
name|pkt
operator|.
name|cph_hlen
argument_list|,
name|pkt
operator|.
name|cph_tlen
argument_list|)
expr_stmt|;
comment|/* XXX this channel is dead actually. */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|hlen
operator|=
name|VMBUS_CHANPKT_GETLEN
argument_list|(
name|pkt
operator|.
name|cph_hlen
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|VMBUS_CHANPKT_GETLEN
argument_list|(
name|pkt
operator|.
name|cph_tlen
argument_list|)
operator|-
name|hlen
expr_stmt|;
if|if
condition|(
operator|*
name|dlen0
operator|<
name|dlen
condition|)
block|{
comment|/* Return the size of this packet's data. */
operator|*
name|dlen0
operator|=
name|dlen
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|xactid
operator|=
name|pkt
operator|.
name|cph_xactid
expr_stmt|;
operator|*
name|dlen0
operator|=
name|dlen
expr_stmt|;
comment|/* Skip packet header */
name|error
operator|=
name|vmbus_rxbr_read
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"vmbus_rxbr_read failed"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vmbus_chan_recv_pkt
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|struct
name|vmbus_chanpkt_hdr
modifier|*
name|pkt
parameter_list|,
name|int
modifier|*
name|pktlen0
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|pktlen
decl_stmt|,
name|pkt_hlen
decl_stmt|;
name|pkt_hlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pkt
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmbus_rxbr_peek
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|,
name|pkt
argument_list|,
name|pkt_hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|->
name|cph_hlen
operator|<
name|VMBUS_CHANPKT_HLEN_MIN
argument_list|)
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"invalid hlen %u\n"
argument_list|,
name|pkt
operator|->
name|cph_hlen
argument_list|)
expr_stmt|;
comment|/* XXX this channel is dead actually. */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|pkt
operator|->
name|cph_hlen
operator|>
name|pkt
operator|->
name|cph_tlen
argument_list|)
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"invalid hlen %u and tlen %u\n"
argument_list|,
name|pkt
operator|->
name|cph_hlen
argument_list|,
name|pkt
operator|->
name|cph_tlen
argument_list|)
expr_stmt|;
comment|/* XXX this channel is dead actually. */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|pktlen
operator|=
name|VMBUS_CHANPKT_GETLEN
argument_list|(
name|pkt
operator|->
name|cph_tlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pktlen0
operator|<
name|pktlen
condition|)
block|{
comment|/* Return the size of this packet. */
operator|*
name|pktlen0
operator|=
name|pktlen
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|pktlen0
operator|=
name|pktlen
expr_stmt|;
comment|/* 	 * Skip the fixed-size packet header, which has been filled 	 * by the above vmbus_rxbr_peek(). 	 */
name|error
operator|=
name|vmbus_rxbr_read
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|,
name|pkt
operator|+
literal|1
argument_list|,
name|pktlen
operator|-
name|pkt_hlen
argument_list|,
name|pkt_hlen
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"vmbus_rxbr_read failed"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_task
parameter_list|(
name|void
modifier|*
name|xchan
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
init|=
name|xchan
decl_stmt|;
name|vmbus_chan_callback_t
name|cb
init|=
name|chan
operator|->
name|ch_cb
decl_stmt|;
name|void
modifier|*
name|cbarg
init|=
name|chan
operator|->
name|ch_cbarg
decl_stmt|;
comment|/* 	 * Optimize host to guest signaling by ensuring: 	 * 1. While reading the channel, we disable interrupts from 	 *    host. 	 * 2. Ensure that we process all posted messages from the host 	 *    before returning from this callback. 	 * 3. Once we return, enable signaling from the host. Once this 	 *    state is set we check to see if additional packets are 	 *    available to read. In this case we repeat the process. 	 * 	 * NOTE: Interrupt has been disabled in the ISR. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint32_t
name|left
decl_stmt|;
name|cb
argument_list|(
name|chan
argument_list|,
name|cbarg
argument_list|)
expr_stmt|;
name|left
operator|=
name|vmbus_rxbr_intr_unmask
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
comment|/* No more data in RX bufring; done */
break|break;
block|}
name|vmbus_rxbr_intr_mask
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_task_nobatch
parameter_list|(
name|void
modifier|*
name|xchan
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
init|=
name|xchan
decl_stmt|;
name|chan
operator|->
name|ch_cb
argument_list|(
name|chan
argument_list|,
name|chan
operator|->
name|ch_cbarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vmbus_event_flags_proc
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|u_long
modifier|*
name|event_flags
parameter_list|,
name|int
name|flag_cnt
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|flag_cnt
condition|;
operator|++
name|f
control|)
block|{
name|uint32_t
name|chid_base
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|int
name|chid_ofs
decl_stmt|;
if|if
condition|(
name|event_flags
index|[
name|f
index|]
operator|==
literal|0
condition|)
continue|continue;
name|flags
operator|=
name|atomic_swap_long
argument_list|(
operator|&
name|event_flags
index|[
name|f
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chid_base
operator|=
name|f
operator|<<
name|VMBUS_EVTFLAG_SHIFT
expr_stmt|;
while|while
condition|(
operator|(
name|chid_ofs
operator|=
name|ffsl
argument_list|(
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
decl_stmt|;
operator|--
name|chid_ofs
expr_stmt|;
comment|/* NOTE: ffsl is 1-based */
name|flags
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|chid_ofs
operator|)
expr_stmt|;
name|chan
operator|=
name|sc
operator|->
name|vmbus_chmap
index|[
name|chid_base
operator|+
name|chid_ofs
index|]
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|chan
operator|==
name|NULL
argument_list|)
condition|)
block|{
comment|/* Channel is closed. */
continue|continue;
block|}
name|__compiler_membar
argument_list|()
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_flags
operator|&
name|VMBUS_CHAN_FLAG_BATCHREAD
condition|)
name|vmbus_rxbr_intr_mask
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|chan
operator|->
name|ch_tq
argument_list|,
operator|&
name|chan
operator|->
name|ch_task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vmbus_event_proc
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|vmbus_evtflags
modifier|*
name|eventf
decl_stmt|;
comment|/* 	 * On Host with Win8 or above, the event page can be checked directly 	 * to get the id of the channel that has the pending interrupt. 	 */
name|eventf
operator|=
name|VMBUS_PCPU_GET
argument_list|(
name|sc
argument_list|,
name|event_flags
argument_list|,
name|cpu
argument_list|)
operator|+
name|VMBUS_SINT_MESSAGE
expr_stmt|;
name|vmbus_event_flags_proc
argument_list|(
name|sc
argument_list|,
name|eventf
operator|->
name|evt_flags
argument_list|,
name|VMBUS_PCPU_GET
argument_list|(
name|sc
argument_list|,
name|event_flags_cnt
argument_list|,
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmbus_event_proc_compat
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|vmbus_evtflags
modifier|*
name|eventf
decl_stmt|;
name|eventf
operator|=
name|VMBUS_PCPU_GET
argument_list|(
name|sc
argument_list|,
name|event_flags
argument_list|,
name|cpu
argument_list|)
operator|+
name|VMBUS_SINT_MESSAGE
expr_stmt|;
if|if
condition|(
name|atomic_testandclear_long
argument_list|(
operator|&
name|eventf
operator|->
name|evt_flags
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|vmbus_event_flags_proc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vmbus_rx_evtflags
argument_list|,
name|VMBUS_CHAN_MAX_COMPAT
operator|>>
name|VMBUS_EVTFLAG_SHIFT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_update_evtflagcnt
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
specifier|volatile
name|int
modifier|*
name|flag_cnt_ptr
decl_stmt|;
name|int
name|flag_cnt
decl_stmt|;
name|flag_cnt
operator|=
operator|(
name|chan
operator|->
name|ch_id
operator|/
name|VMBUS_EVTFLAG_LEN
operator|)
operator|+
literal|1
expr_stmt|;
name|flag_cnt_ptr
operator|=
name|VMBUS_PCPU_PTR
argument_list|(
name|sc
argument_list|,
name|event_flags_cnt
argument_list|,
name|chan
operator|->
name|ch_cpuid
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|old_flag_cnt
decl_stmt|;
name|old_flag_cnt
operator|=
operator|*
name|flag_cnt_ptr
expr_stmt|;
if|if
condition|(
name|old_flag_cnt
operator|>=
name|flag_cnt
condition|)
break|break;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
name|flag_cnt_ptr
argument_list|,
name|old_flag_cnt
argument_list|,
name|flag_cnt
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u update cpu%d flag_cnt to %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|chan
operator|->
name|ch_cpuid
argument_list|,
name|flag_cnt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|vmbus_channel
modifier|*
name|vmbus_chan_alloc
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
decl_stmt|;
name|chan
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|chan
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_monprm
operator|=
name|hyperv_dmamem_alloc
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|)
argument_list|,
name|HYPERCALL_PARAM_ALIGN
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hyperv_mon_param
argument_list|)
argument_list|,
operator|&
name|chan
operator|->
name|ch_monprm_dma
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_monprm
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"monprm alloc failed\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chan
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|chan
operator|->
name|ch_refs
operator|=
literal|1
expr_stmt|;
name|chan
operator|->
name|ch_vmbus
operator|=
name|sc
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|ch_subchan_lock
argument_list|,
literal|"vmbus subchan"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|chan
operator|->
name|ch_orphan_lock
argument_list|,
literal|"vmbus chorphan"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|chan
operator|->
name|ch_subchans
argument_list|)
expr_stmt|;
name|vmbus_rxbr_init
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|)
expr_stmt|;
name|vmbus_txbr_init
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|)
expr_stmt|;
return|return
name|chan
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_free
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|chan
operator|->
name|ch_subchans
argument_list|)
operator|&&
name|chan
operator|->
name|ch_subchan_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"still owns sub-channels"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|chan
operator|->
name|ch_stflags
operator|&
operator|(
name|VMBUS_CHAN_ST_OPENED
operator||
name|VMBUS_CHAN_ST_ONPRIL
operator||
name|VMBUS_CHAN_ST_ONSUBL
operator||
name|VMBUS_CHAN_ST_ONLIST
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"free busy channel"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|chan
operator|->
name|ch_orphan_xact
operator|==
name|NULL
argument_list|,
operator|(
literal|"still has orphan xact installed"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|chan
operator|->
name|ch_refs
operator|==
literal|0
argument_list|,
operator|(
literal|"chan%u: invalid refcnt %d"
operator|,
name|chan
operator|->
name|ch_id
operator|,
name|chan
operator|->
name|ch_refs
operator|)
argument_list|)
expr_stmt|;
name|hyperv_dmamem_free
argument_list|(
operator|&
name|chan
operator|->
name|ch_monprm_dma
argument_list|,
name|chan
operator|->
name|ch_monprm
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|chan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|chan
operator|->
name|ch_orphan_lock
argument_list|)
expr_stmt|;
name|vmbus_rxbr_deinit
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|)
expr_stmt|;
name|vmbus_txbr_deinit
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chan
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmbus_chan_add
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|newchan
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|newchan
operator|->
name|ch_vmbus
decl_stmt|;
name|struct
name|vmbus_channel
modifier|*
name|prichan
decl_stmt|;
if|if
condition|(
name|newchan
operator|->
name|ch_id
operator|==
literal|0
condition|)
block|{
comment|/* 		 * XXX 		 * Chan0 will neither be processed nor should be offered; 		 * skip it. 		 */
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"got chan0 offer, discard\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
name|newchan
operator|->
name|ch_id
operator|>=
name|VMBUS_CHAN_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"invalid chan%u offer\n"
argument_list|,
name|newchan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|prichan
argument_list|,
argument|&sc->vmbus_prichans
argument_list|,
argument|ch_prilink
argument_list|)
block|{
comment|/* 		 * Sub-channel will have the same type GUID and instance 		 * GUID as its primary channel. 		 */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|prichan
operator|->
name|ch_guid_type
argument_list|,
operator|&
name|newchan
operator|->
name|ch_guid_type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hyperv_guid
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
operator|&
name|prichan
operator|->
name|ch_guid_inst
argument_list|,
operator|&
name|newchan
operator|->
name|ch_guid_inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hyperv_guid
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|newchan
argument_list|)
condition|)
block|{
if|if
condition|(
name|prichan
operator|==
name|NULL
condition|)
block|{
comment|/* Install the new primary channel */
name|vmbus_chan_ins_prilist
argument_list|(
name|sc
argument_list|,
name|newchan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"duplicated primary chan%u\n"
argument_list|,
name|newchan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
else|else
block|{
comment|/* Sub-channel */
if|if
condition|(
name|prichan
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"no primary chan for chan%u\n"
argument_list|,
name|newchan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 		 * Found the primary channel for this sub-channel and 		 * move on. 		 * 		 * XXX refcnt prichan 		 */
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
comment|/* 	 * This is a sub-channel; link it with the primary channel. 	 */
name|KASSERT
argument_list|(
operator|!
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|newchan
argument_list|)
argument_list|,
operator|(
literal|"new channel is not sub-channel"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|prichan
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no primary channel"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reference count this sub-channel; it will be dereferenced 	 * when this sub-channel is closed. 	 */
name|KASSERT
argument_list|(
name|newchan
operator|->
name|ch_refs
operator|==
literal|1
argument_list|,
operator|(
literal|"chan%u: invalid refcnt %d"
operator|,
name|newchan
operator|->
name|ch_id
operator|,
name|newchan
operator|->
name|ch_refs
operator|)
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|newchan
operator|->
name|ch_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newchan
operator|->
name|ch_prichan
operator|=
name|prichan
expr_stmt|;
name|newchan
operator|->
name|ch_dev
operator|=
name|prichan
operator|->
name|ch_dev
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|prichan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
name|vmbus_chan_ins_sublist
argument_list|(
name|prichan
argument_list|,
name|newchan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|prichan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Notify anyone that is interested in this sub-channel, 	 * after this sub-channel is setup. 	 */
name|wakeup
argument_list|(
name|prichan
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * Hook this channel up for later revocation. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|)
expr_stmt|;
name|vmbus_chan_ins_list
argument_list|(
name|sc
argument_list|,
name|newchan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|newchan
argument_list|,
literal|"chan%u subidx%u offer\n"
argument_list|,
name|newchan
operator|->
name|ch_id
argument_list|,
name|newchan
operator|->
name|ch_subidx
argument_list|)
expr_stmt|;
block|}
comment|/* Select default cpu for this channel. */
name|vmbus_chan_cpu_default
argument_list|(
name|newchan
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|vmbus_chan_cpu_set
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"invalid cpu %d"
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_vmbus
operator|->
name|vmbus_version
operator|==
name|VMBUS_VERSION_WS2008
operator|||
name|chan
operator|->
name|ch_vmbus
operator|->
name|vmbus_version
operator|==
name|VMBUS_VERSION_WIN7
condition|)
block|{
comment|/* Only cpu0 is supported */
name|cpu
operator|=
literal|0
expr_stmt|;
block|}
name|chan
operator|->
name|ch_cpuid
operator|=
name|cpu
expr_stmt|;
name|chan
operator|->
name|ch_vcpuid
operator|=
name|VMBUS_PCPU_GET
argument_list|(
name|chan
operator|->
name|ch_vmbus
argument_list|,
name|vcpuid
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u assigned to cpu%u [vcpu%u]\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|chan
operator|->
name|ch_cpuid
argument_list|,
name|chan
operator|->
name|ch_vcpuid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vmbus_chan_cpu_rr
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
specifier|static
name|uint32_t
name|vmbus_chan_nextcpu
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|cpu
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|vmbus_chan_nextcpu
argument_list|,
literal|1
argument_list|)
operator|%
name|mp_ncpus
expr_stmt|;
name|vmbus_chan_cpu_set
argument_list|(
name|chan
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_cpu_default
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
comment|/* 	 * By default, pin the channel to cpu0.  Devices having 	 * special channel-cpu mapping requirement should call 	 * vmbus_chan_cpu_{set,rr}(). 	 */
name|vmbus_chan_cpu_set
argument_list|(
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_msgproc_choffer
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|vmbus_message
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|struct
name|vmbus_chanmsg_choffer
modifier|*
name|offer
decl_stmt|;
name|struct
name|vmbus_channel
modifier|*
name|chan
decl_stmt|;
name|task_fn_t
modifier|*
name|detach_fn
decl_stmt|,
modifier|*
name|attach_fn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|offer
operator|=
operator|(
specifier|const
expr|struct
name|vmbus_chanmsg_choffer
operator|*
operator|)
name|msg
operator|->
name|msg_data
expr_stmt|;
name|chan
operator|=
name|vmbus_chan_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"allocate chan%u failed\n"
argument_list|,
name|offer
operator|->
name|chm_chanid
argument_list|)
expr_stmt|;
return|return;
block|}
name|chan
operator|->
name|ch_id
operator|=
name|offer
operator|->
name|chm_chanid
expr_stmt|;
name|chan
operator|->
name|ch_subidx
operator|=
name|offer
operator|->
name|chm_subidx
expr_stmt|;
name|chan
operator|->
name|ch_guid_type
operator|=
name|offer
operator|->
name|chm_chtype
expr_stmt|;
name|chan
operator|->
name|ch_guid_inst
operator|=
name|offer
operator|->
name|chm_chinst
expr_stmt|;
comment|/* Batch reading is on by default */
name|chan
operator|->
name|ch_flags
operator||=
name|VMBUS_CHAN_FLAG_BATCHREAD
expr_stmt|;
name|chan
operator|->
name|ch_monprm
operator|->
name|mp_connid
operator|=
name|VMBUS_CONNID_EVENT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vmbus_version
operator|!=
name|VMBUS_VERSION_WS2008
condition|)
name|chan
operator|->
name|ch_monprm
operator|->
name|mp_connid
operator|=
name|offer
operator|->
name|chm_connid
expr_stmt|;
if|if
condition|(
name|offer
operator|->
name|chm_flags1
operator|&
name|VMBUS_CHOFFER_FLAG1_HASMNF
condition|)
block|{
name|int
name|trig_idx
decl_stmt|;
comment|/* 		 * Setup MNF stuffs. 		 */
name|chan
operator|->
name|ch_txflags
operator||=
name|VMBUS_CHAN_TXF_HASMNF
expr_stmt|;
name|trig_idx
operator|=
name|offer
operator|->
name|chm_montrig
operator|/
name|VMBUS_MONTRIG_LEN
expr_stmt|;
if|if
condition|(
name|trig_idx
operator|>=
name|VMBUS_MONTRIGS_MAX
condition|)
name|panic
argument_list|(
literal|"invalid monitor trigger %u"
argument_list|,
name|offer
operator|->
name|chm_montrig
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_montrig
operator|=
operator|&
name|sc
operator|->
name|vmbus_mnf2
operator|->
name|mnf_trigs
index|[
name|trig_idx
index|]
operator|.
name|mt_pending
expr_stmt|;
name|chan
operator|->
name|ch_montrig_mask
operator|=
literal|1
operator|<<
operator|(
name|offer
operator|->
name|chm_montrig
operator|%
name|VMBUS_MONTRIG_LEN
operator|)
expr_stmt|;
block|}
comment|/* 	 * Setup event flag. 	 */
name|chan
operator|->
name|ch_evtflag
operator|=
operator|&
name|sc
operator|->
name|vmbus_tx_evtflags
index|[
name|chan
operator|->
name|ch_id
operator|>>
name|VMBUS_EVTFLAG_SHIFT
index|]
expr_stmt|;
name|chan
operator|->
name|ch_evtflag_mask
operator|=
literal|1UL
operator|<<
operator|(
name|chan
operator|->
name|ch_id
operator|&
name|VMBUS_EVTFLAG_MASK
operator|)
expr_stmt|;
comment|/* 	 * Setup attach and detach tasks. 	 */
if|if
condition|(
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|chan
operator|->
name|ch_mgmt_tq
operator|=
name|sc
operator|->
name|vmbus_devtq
expr_stmt|;
name|attach_fn
operator|=
name|vmbus_prichan_attach_task
expr_stmt|;
name|detach_fn
operator|=
name|vmbus_prichan_detach_task
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|ch_mgmt_tq
operator|=
name|sc
operator|->
name|vmbus_subchtq
expr_stmt|;
name|attach_fn
operator|=
name|vmbus_subchan_attach_task
expr_stmt|;
name|detach_fn
operator|=
name|vmbus_subchan_detach_task
expr_stmt|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|chan
operator|->
name|ch_attach_task
argument_list|,
literal|0
argument_list|,
name|attach_fn
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|chan
operator|->
name|ch_detach_task
argument_list|,
literal|0
argument_list|,
name|detach_fn
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmbus_chan_add
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"add chan%u failed: %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmbus_chan_free
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return;
block|}
name|taskqueue_enqueue
argument_list|(
name|chan
operator|->
name|ch_mgmt_tq
argument_list|,
operator|&
name|chan
operator|->
name|ch_attach_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_msgproc_chrescind
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|vmbus_message
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|struct
name|vmbus_chanmsg_chrescind
modifier|*
name|note
decl_stmt|;
name|struct
name|vmbus_channel
modifier|*
name|chan
decl_stmt|;
name|note
operator|=
operator|(
specifier|const
expr|struct
name|vmbus_chanmsg_chrescind
operator|*
operator|)
name|msg
operator|->
name|msg_data
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|chm_chanid
operator|>
name|VMBUS_CHAN_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"invalid revoked chan%u\n"
argument_list|,
name|note
operator|->
name|chm_chanid
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Find and remove the target channel from the channel list. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chan
argument_list|,
argument|&sc->vmbus_chans
argument_list|,
argument|ch_link
argument_list|)
block|{
if|if
condition|(
name|chan
operator|->
name|ch_id
operator|==
name|note
operator|->
name|chm_chanid
condition|)
break|break;
block|}
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"chan%u is not offered\n"
argument_list|,
name|note
operator|->
name|chm_chanid
argument_list|)
expr_stmt|;
return|return;
block|}
name|vmbus_chan_rem_list
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 		 * The target channel is a primary channel; remove the 		 * target channel from the primary channel list now, 		 * instead of later, so that it will not be found by 		 * other sub-channel offers, which are processed in 		 * this thread. 		 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
name|vmbus_chan_rem_prilist
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * NOTE: 	 * The following processing order is critical: 	 * Set the REVOKED state flag before orphaning the installed xact. 	 */
if|if
condition|(
name|atomic_testandset_int
argument_list|(
operator|&
name|chan
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_REVOKED_SHIFT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"channel has already been revoked"
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|chan
operator|->
name|ch_orphan_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_orphan_xact
operator|!=
name|NULL
condition|)
name|vmbus_xact_ctx_orphan
argument_list|(
name|chan
operator|->
name|ch_orphan_xact
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|chan
operator|->
name|ch_orphan_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u revoked\n"
argument_list|,
name|note
operator|->
name|chm_chanid
argument_list|)
expr_stmt|;
name|vmbus_chan_detach
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmbus_chan_release
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|chan
operator|->
name|ch_vmbus
decl_stmt|;
name|struct
name|vmbus_chanmsg_chfree
modifier|*
name|req
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"can not get msg hypercall for chfree(chan%u)\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_CHFREE
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|chan
operator|->
name|ch_id
expr_stmt|;
name|error
operator|=
name|vmbus_msghc_exec_noresult
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chfree(chan%u) msg hypercall exec failed: %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|vmbus_chan_printf
argument_list|(
name|chan
argument_list|,
literal|"chan%u freed\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_prichan_detach_task
parameter_list|(
name|void
modifier|*
name|xchan
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
init|=
name|xchan
decl_stmt|;
name|KASSERT
argument_list|(
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
argument_list|,
operator|(
literal|"chan%u is not primary channel"
operator|,
name|chan
operator|->
name|ch_id
operator|)
argument_list|)
expr_stmt|;
comment|/* Delete and detach the device associated with this channel. */
name|vmbus_delete_child
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* Release this channel (back to vmbus). */
name|vmbus_chan_release
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* Free this channel's resource. */
name|vmbus_chan_free
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_subchan_detach_task
parameter_list|(
name|void
modifier|*
name|xchan
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
init|=
name|xchan
decl_stmt|;
name|struct
name|vmbus_channel
modifier|*
name|pri_chan
init|=
name|chan
operator|->
name|ch_prichan
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
argument_list|,
operator|(
literal|"chan%u is primary channel"
operator|,
name|chan
operator|->
name|ch_id
operator|)
argument_list|)
expr_stmt|;
comment|/* Release this channel (back to vmbus). */
name|vmbus_chan_release
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* Unlink from its primary channel's sub-channel list. */
name|mtx_lock
argument_list|(
operator|&
name|pri_chan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
name|vmbus_chan_rem_sublist
argument_list|(
name|pri_chan
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pri_chan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
comment|/* Notify anyone that is waiting for this sub-channel to vanish. */
name|wakeup
argument_list|(
name|pri_chan
argument_list|)
expr_stmt|;
comment|/* Free this channel's resource. */
name|vmbus_chan_free
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_prichan_attach_task
parameter_list|(
name|void
modifier|*
name|xchan
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
comment|/* 	 * Add device for this primary channel. 	 */
name|vmbus_add_child
argument_list|(
name|xchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_subchan_attach_task
parameter_list|(
name|void
modifier|*
name|xchan
name|__unused
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
comment|/* Nothing */
block|}
end_function

begin_function
name|void
name|vmbus_chan_destroy_all
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Detach all devices and destroy the corresponding primary 	 * channels. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|vmbus_channel
modifier|*
name|chan
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chan
argument_list|,
argument|&sc->vmbus_chans
argument_list|,
argument|ch_link
argument_list|)
block|{
if|if
condition|(
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
comment|/* No more primary channels; done. */
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|vmbus_chan_rem_list
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_chan_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
name|vmbus_chan_rem_prilist
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_prichan_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|chan
operator|->
name|ch_mgmt_tq
argument_list|,
operator|&
name|chan
operator|->
name|ch_detach_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|vmbus_subchan_get
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|pri_chan
parameter_list|,
name|int
name|subchan_cnt
parameter_list|)
block|{
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|ret
decl_stmt|,
modifier|*
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|subchan_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid sub-channel count %d"
operator|,
name|subchan_cnt
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
name|subchan_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vmbus_channel
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pri_chan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|pri_chan
operator|->
name|ch_subchan_cnt
operator|<
name|subchan_cnt
condition|)
name|mtx_sleep
argument_list|(
name|pri_chan
argument_list|,
operator|&
name|pri_chan
operator|->
name|ch_subchan_lock
argument_list|,
literal|0
argument_list|,
literal|"subch"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chan
argument_list|,
argument|&pri_chan->ch_subchans
argument_list|,
argument|ch_sublink
argument_list|)
block|{
comment|/* TODO: refcnt chan */
name|ret
index|[
name|i
index|]
operator|=
name|chan
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|subchan_cnt
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|i
operator|==
name|subchan_cnt
argument_list|,
operator|(
literal|"invalid subchan count %d, should be %d"
operator|,
name|pri_chan
operator|->
name|ch_subchan_cnt
operator|,
name|subchan_cnt
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pri_chan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|vmbus_subchan_rel
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
modifier|*
name|subchan
parameter_list|,
name|int
name|subchan_cnt
name|__unused
parameter_list|)
block|{
name|free
argument_list|(
name|subchan
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmbus_subchan_drain
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|pri_chan
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pri_chan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|pri_chan
operator|->
name|ch_subchan_cnt
operator|>
literal|0
condition|)
name|mtx_sleep
argument_list|(
name|pri_chan
argument_list|,
operator|&
name|pri_chan
operator|->
name|ch_subchan_lock
argument_list|,
literal|0
argument_list|,
literal|"dsubch"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pri_chan
operator|->
name|ch_subchan_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmbus_chan_msgproc
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|vmbus_message
modifier|*
name|msg
parameter_list|)
block|{
name|vmbus_chanmsg_proc_t
name|msg_proc
decl_stmt|;
name|uint32_t
name|msg_type
decl_stmt|;
name|msg_type
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|vmbus_chanmsg_hdr
operator|*
operator|)
name|msg
operator|->
name|msg_data
operator|)
operator|->
name|chm_type
expr_stmt|;
name|KASSERT
argument_list|(
name|msg_type
operator|<
name|VMBUS_CHANMSG_TYPE_MAX
argument_list|,
operator|(
literal|"invalid message type %u"
operator|,
name|msg_type
operator|)
argument_list|)
expr_stmt|;
name|msg_proc
operator|=
name|vmbus_chan_msgprocs
index|[
name|msg_type
index|]
expr_stmt|;
if|if
condition|(
name|msg_proc
operator|!=
name|NULL
condition|)
name|msg_proc
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmbus_chan_set_readbatch
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
operator|!
name|on
condition|)
name|chan
operator|->
name|ch_flags
operator|&=
operator|~
name|VMBUS_CHAN_FLAG_BATCHREAD
expr_stmt|;
else|else
name|chan
operator|->
name|ch_flags
operator||=
name|VMBUS_CHAN_FLAG_BATCHREAD
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|vmbus_chan_id
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
return|return
name|chan
operator|->
name|ch_id
return|;
block|}
end_function

begin_function
name|uint32_t
name|vmbus_chan_subidx
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
return|return
name|chan
operator|->
name|ch_subidx
return|;
block|}
end_function

begin_function
name|bool
name|vmbus_chan_is_primary
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
name|VMBUS_CHAN_ISPRIMARY
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|hyperv_guid
modifier|*
name|vmbus_chan_guid_inst
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
return|return
operator|&
name|chan
operator|->
name|ch_guid_inst
return|;
block|}
end_function

begin_function
name|int
name|vmbus_chan_prplist_nelem
parameter_list|(
name|int
name|br_size
parameter_list|,
name|int
name|prpcnt_max
parameter_list|,
name|int
name|dlen_max
parameter_list|)
block|{
name|int
name|elem_size
decl_stmt|;
name|elem_size
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_chanpkt_prplist
argument_list|,
name|cp_range
index|[
literal|0
index|]
operator|.
name|gpa_page
index|[
name|prpcnt_max
index|]
argument_list|)
expr_stmt|;
name|elem_size
operator|+=
name|dlen_max
expr_stmt|;
name|elem_size
operator|=
name|VMBUS_CHANPKT_TOTLEN
argument_list|(
name|elem_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|vmbus_br_nelem
argument_list|(
name|br_size
argument_list|,
name|elem_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|vmbus_chan_tx_empty
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
return|return
operator|(
name|vmbus_txbr_empty
argument_list|(
operator|&
name|chan
operator|->
name|ch_txbr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|vmbus_chan_rx_empty
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
return|return
operator|(
name|vmbus_rxbr_empty
argument_list|(
operator|&
name|chan
operator|->
name|ch_rxbr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmbus_chan_printf
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_dev
operator|==
name|NULL
operator|||
operator|!
name|device_is_alive
argument_list|(
name|chan
operator|->
name|ch_dev
argument_list|)
condition|)
name|dev
operator|=
name|chan
operator|->
name|ch_vmbus
operator|->
name|vmbus_dev
expr_stmt|;
else|else
name|dev
operator|=
name|chan
operator|->
name|ch_dev
expr_stmt|;
name|retval
operator|=
name|device_print_prettyname
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vmbus_chan_run_task
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|struct
name|task
modifier|*
name|task
parameter_list|)
block|{
name|taskqueue_enqueue
argument_list|(
name|chan
operator|->
name|ch_tq
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|chan
operator|->
name|ch_tq
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|taskqueue
modifier|*
name|vmbus_chan_mgmt_tq
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
return|return
operator|(
name|chan
operator|->
name|ch_mgmt_tq
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|vmbus_chan_is_revoked
parameter_list|(
specifier|const
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|->
name|ch_stflags
operator|&
name|VMBUS_CHAN_ST_REVOKED
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vmbus_chan_set_orphan
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|,
name|struct
name|vmbus_xact_ctx
modifier|*
name|xact
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|chan
operator|->
name|ch_orphan_lock
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_orphan_xact
operator|=
name|xact
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|chan
operator|->
name|ch_orphan_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmbus_chan_unset_orphan
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|chan
operator|->
name|ch_orphan_lock
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ch_orphan_xact
operator|=
name|NULL
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|chan
operator|->
name|ch_orphan_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

