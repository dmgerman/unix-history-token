begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2012,2016 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * Copyright (c) 2012 Citrix Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/hv_vmbus_priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/hyperv_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/vmbus_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/vmbus/vmbus_var.h>
end_include

begin_function_decl
specifier|static
name|void
name|vmbus_chan_send_event
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_update_evtflagcnt
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|hv_vmbus_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_chan_task_nobatch
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  @brief Trigger an event notification on the specified channel  */
end_comment

begin_function
specifier|static
name|void
name|vmbus_chan_send_event
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|channel
operator|->
name|vmbus_sc
decl_stmt|;
name|uint32_t
name|chanid
init|=
name|channel
operator|->
name|ch_id
decl_stmt|;
name|atomic_set_long
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_tx_evtflags
index|[
name|chanid
operator|>>
name|VMBUS_EVTFLAG_SHIFT
index|]
argument_list|,
literal|1UL
operator|<<
operator|(
name|chanid
operator|&
name|VMBUS_EVTFLAG_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|ch_flags
operator|&
name|VMBUS_CHAN_FLAG_HASMNF
condition|)
block|{
name|atomic_set_int
argument_list|(
operator|&
name|sc
operator|->
name|vmbus_mnf2
operator|->
name|mnf_trigs
index|[
name|channel
operator|->
name|ch_montrig_idx
index|]
operator|.
name|mt_pending
argument_list|,
name|channel
operator|->
name|ch_montrig_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hypercall_signal_event
argument_list|(
name|channel
operator|->
name|ch_monprm_dma
operator|.
name|hv_paddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vmbus_channel_sysctl_monalloc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hv_vmbus_channel
modifier|*
name|chan
init|=
name|arg1
decl_stmt|;
name|int
name|alloc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chan
operator|->
name|ch_flags
operator|&
name|VMBUS_CHAN_FLAG_HASMNF
condition|)
name|alloc
operator|=
literal|1
expr_stmt|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|alloc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_channel_sysctl_create
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|devch_sysctl
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|devch_id_sysctl
decl_stmt|,
modifier|*
name|devch_sub_sysctl
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|devch_id_in_sysctl
decl_stmt|,
modifier|*
name|devch_id_out_sysctl
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|uint32_t
name|ch_id
decl_stmt|;
name|uint16_t
name|sub_ch_id
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|hv_vmbus_channel
modifier|*
name|primary_ch
init|=
name|channel
operator|->
name|primary_channel
decl_stmt|;
if|if
condition|(
name|primary_ch
operator|==
name|NULL
condition|)
block|{
name|dev
operator|=
name|channel
operator|->
name|ch_dev
expr_stmt|;
name|ch_id
operator|=
name|channel
operator|->
name|ch_id
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|=
name|primary_ch
operator|->
name|ch_dev
expr_stmt|;
name|ch_id
operator|=
name|primary_ch
operator|->
name|ch_id
expr_stmt|;
name|sub_ch_id
operator|=
name|channel
operator|->
name|ch_subidx
expr_stmt|;
block|}
name|ctx
operator|=
operator|&
name|channel
operator|->
name|ch_sysctl_ctx
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* This creates dev.DEVNAME.DEVUNIT.channel tree */
name|devch_sysctl
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"channel"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* This creates dev.DEVNAME.DEVUNIT.channel.CHANID tree */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ch_id
argument_list|)
expr_stmt|;
name|devch_id_sysctl
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_sysctl
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary_ch
operator|!=
name|NULL
condition|)
block|{
name|devch_sub_sysctl
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_id_sysctl
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sub"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|sub_ch_id
argument_list|)
expr_stmt|;
name|devch_id_sysctl
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_sub_sysctl
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_id_sysctl
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chanid"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|channel
operator|->
name|ch_id
argument_list|,
literal|0
argument_list|,
literal|"channel id"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_id_sysctl
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpu"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|channel
operator|->
name|target_cpu
argument_list|,
literal|0
argument_list|,
literal|"owner CPU id"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_id_sysctl
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"monitor_allocated"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|channel
argument_list|,
literal|0
argument_list|,
name|vmbus_channel_sysctl_monalloc
argument_list|,
literal|"I"
argument_list|,
literal|"is monitor allocated to this channel"
argument_list|)
expr_stmt|;
name|devch_id_in_sysctl
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_id_sysctl
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"in"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|devch_id_out_sysctl
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_id_sysctl
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"out"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|hv_ring_buffer_stat
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_id_in_sysctl
argument_list|)
argument_list|,
operator|&
operator|(
name|channel
operator|->
name|inbound
operator|)
argument_list|,
literal|"inbound ring buffer stats"
argument_list|)
expr_stmt|;
name|hv_ring_buffer_stat
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|devch_id_out_sysctl
argument_list|)
argument_list|,
operator|&
operator|(
name|channel
operator|->
name|outbound
operator|)
argument_list|,
literal|"outbound ring buffer stats"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Open the specified channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_open
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|new_channel
parameter_list|,
name|uint32_t
name|send_ring_buffer_size
parameter_list|,
name|uint32_t
name|recv_ring_buffer_size
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|,
name|uint32_t
name|user_data_len
parameter_list|,
name|hv_vmbus_pfn_channel_callback
name|pfn_on_channel_callback
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|new_channel
operator|->
name|vmbus_sc
decl_stmt|;
specifier|const
name|struct
name|vmbus_chanmsg_chopen_resp
modifier|*
name|resp
decl_stmt|;
specifier|const
name|struct
name|vmbus_message
modifier|*
name|msg
decl_stmt|;
name|struct
name|vmbus_chanmsg_chopen
modifier|*
name|req
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|user_data_len
operator|>
name|VMBUS_CHANMSG_CHOPEN_UDATA_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"invalid udata len %u for chan%u\n"
argument_list|,
name|user_data_len
argument_list|,
name|new_channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|atomic_testandset_int
argument_list|(
operator|&
name|new_channel
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_OPENED_SHIFT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"double-open chan%u"
argument_list|,
name|new_channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|new_channel
operator|->
name|on_channel_callback
operator|=
name|pfn_on_channel_callback
expr_stmt|;
name|new_channel
operator|->
name|channel_callback_context
operator|=
name|context
expr_stmt|;
name|vmbus_chan_update_evtflagcnt
argument_list|(
name|sc
argument_list|,
name|new_channel
argument_list|)
expr_stmt|;
name|new_channel
operator|->
name|rxq
operator|=
name|VMBUS_PCPU_GET
argument_list|(
name|new_channel
operator|->
name|vmbus_sc
argument_list|,
name|event_tq
argument_list|,
name|new_channel
operator|->
name|target_cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_channel
operator|->
name|ch_flags
operator|&
name|VMBUS_CHAN_FLAG_BATCHREAD
condition|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|new_channel
operator|->
name|channel_task
argument_list|,
literal|0
argument_list|,
name|vmbus_chan_task
argument_list|,
name|new_channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TASK_INIT
argument_list|(
operator|&
name|new_channel
operator|->
name|channel_task
argument_list|,
literal|0
argument_list|,
name|vmbus_chan_task_nobatch
argument_list|,
name|new_channel
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the ring buffer */
name|out
operator|=
name|contigmalloc
argument_list|(
operator|(
name|send_ring_buffer_size
operator|+
name|recv_ring_buffer_size
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
argument_list|,
literal|0UL
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|out
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Error VMBUS: contigmalloc failed to allocate Ring Buffer!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|in
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|out
operator|+
name|send_ring_buffer_size
operator|)
expr_stmt|;
name|new_channel
operator|->
name|ring_buffer_pages
operator|=
name|out
expr_stmt|;
name|new_channel
operator|->
name|ring_buffer_page_count
operator|=
operator|(
name|send_ring_buffer_size
operator|+
name|recv_ring_buffer_size
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|new_channel
operator|->
name|ring_buffer_size
operator|=
name|send_ring_buffer_size
operator|+
name|recv_ring_buffer_size
expr_stmt|;
name|hv_vmbus_ring_buffer_init
argument_list|(
operator|&
name|new_channel
operator|->
name|outbound
argument_list|,
name|out
argument_list|,
name|send_ring_buffer_size
argument_list|)
expr_stmt|;
name|hv_vmbus_ring_buffer_init
argument_list|(
operator|&
name|new_channel
operator|->
name|inbound
argument_list|,
name|in
argument_list|,
name|recv_ring_buffer_size
argument_list|)
expr_stmt|;
comment|/* Create sysctl tree for this channel */
name|vmbus_channel_sysctl_create
argument_list|(
name|new_channel
argument_list|)
expr_stmt|;
comment|/** 	 * Establish the gpadl for the ring buffer 	 */
name|new_channel
operator|->
name|ring_buffer_gpadl_handle
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_establish_gpadl
argument_list|(
name|new_channel
argument_list|,
name|new_channel
operator|->
name|outbound
operator|.
name|ring_buffer
argument_list|,
name|send_ring_buffer_size
operator|+
name|recv_ring_buffer_size
argument_list|,
operator|&
name|new_channel
operator|->
name|ring_buffer_gpadl_handle
argument_list|)
expr_stmt|;
comment|/* 	 * Open channel w/ the bufring GPADL on the target CPU. 	 */
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"can not get msg hypercall for chopen(chan%u)\n"
argument_list|,
name|new_channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_CHOPEN
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|new_channel
operator|->
name|ch_id
expr_stmt|;
name|req
operator|->
name|chm_openid
operator|=
name|new_channel
operator|->
name|ch_id
expr_stmt|;
name|req
operator|->
name|chm_gpadl
operator|=
name|new_channel
operator|->
name|ring_buffer_gpadl_handle
expr_stmt|;
name|req
operator|->
name|chm_vcpuid
operator|=
name|new_channel
operator|->
name|target_vcpu
expr_stmt|;
name|req
operator|->
name|chm_rxbr_pgofs
operator|=
name|send_ring_buffer_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|user_data_len
condition|)
name|memcpy
argument_list|(
name|req
operator|->
name|chm_udata
argument_list|,
name|user_data
argument_list|,
name|user_data_len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vmbus_msghc_exec
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"chopen(chan%u) msg hypercall exec failed: %d\n"
argument_list|,
name|new_channel
operator|->
name|ch_id
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|msg
operator|=
name|vmbus_msghc_wait_result
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|(
specifier|const
expr|struct
name|vmbus_chanmsg_chopen_resp
operator|*
operator|)
name|msg
operator|->
name|msg_data
expr_stmt|;
name|status
operator|=
name|resp
operator|->
name|chm_status
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"chan%u opened\n"
argument_list|,
name|new_channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"failed to open chan%u\n"
argument_list|,
name|new_channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
name|failed
label|:
name|atomic_clear_int
argument_list|(
operator|&
name|new_channel
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_OPENED
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Establish a GPADL for the specified buffer  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_establish_gpadl
parameter_list|(
name|struct
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|contig_buffer
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint32_t
modifier|*
name|gpadl0
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|channel
operator|->
name|vmbus_sc
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|struct
name|vmbus_chanmsg_gpadl_conn
modifier|*
name|req
decl_stmt|;
specifier|const
name|struct
name|vmbus_message
modifier|*
name|msg
decl_stmt|;
name|size_t
name|reqsz
decl_stmt|;
name|uint32_t
name|gpadl
decl_stmt|,
name|status
decl_stmt|;
name|int
name|page_count
decl_stmt|,
name|range_len
decl_stmt|,
name|i
decl_stmt|,
name|cnt
decl_stmt|,
name|error
decl_stmt|;
name|uint64_t
name|page_id
decl_stmt|,
name|paddr
decl_stmt|;
comment|/* 	 * Preliminary checks. 	 */
name|KASSERT
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid GPA size %u, not multiple page size"
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|page_count
operator|=
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|paddr
operator|=
name|hv_get_phys_addr
argument_list|(
name|contig_buffer
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|paddr
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"GPA is not page aligned %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|paddr
operator|)
argument_list|)
expr_stmt|;
name|page_id
operator|=
name|paddr
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|range_len
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_gpa_range
argument_list|,
name|gpa_page
index|[
name|page_count
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * We don't support multiple GPA ranges. 	 */
if|if
condition|(
name|range_len
operator|>
name|UINT16_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"GPA too large, %d pages\n"
argument_list|,
name|page_count
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
comment|/* 	 * Allocate GPADL id. 	 */
name|gpadl
operator|=
name|vmbus_gpadl_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|gpadl0
operator|=
name|gpadl
expr_stmt|;
comment|/* 	 * Connect this GPADL to the target channel. 	 * 	 * NOTE: 	 * Since each message can only hold small set of page 	 * addresses, several messages may be required to 	 * complete the connection. 	 */
if|if
condition|(
name|page_count
operator|>
name|VMBUS_CHANMSG_GPADL_CONN_PGMAX
condition|)
name|cnt
operator|=
name|VMBUS_CHANMSG_GPADL_CONN_PGMAX
expr_stmt|;
else|else
name|cnt
operator|=
name|page_count
expr_stmt|;
name|page_count
operator|-=
name|cnt
expr_stmt|;
name|reqsz
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_chanmsg_gpadl_conn
argument_list|,
name|chm_range
operator|.
name|gpa_page
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
name|reqsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"can not get msg hypercall for gpadl->chan%u\n"
argument_list|,
name|channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_GPADL_CONN
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|channel
operator|->
name|ch_id
expr_stmt|;
name|req
operator|->
name|chm_gpadl
operator|=
name|gpadl
expr_stmt|;
name|req
operator|->
name|chm_range_len
operator|=
name|range_len
expr_stmt|;
name|req
operator|->
name|chm_range_cnt
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|chm_range
operator|.
name|gpa_len
operator|=
name|size
expr_stmt|;
name|req
operator|->
name|chm_range
operator|.
name|gpa_ofs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
operator|++
name|i
control|)
name|req
operator|->
name|chm_range
operator|.
name|gpa_page
index|[
name|i
index|]
operator|=
name|page_id
operator|++
expr_stmt|;
name|error
operator|=
name|vmbus_msghc_exec
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"gpadl->chan%u msg hypercall exec failed: %d\n"
argument_list|,
name|channel
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
while|while
condition|(
name|page_count
operator|>
literal|0
condition|)
block|{
name|struct
name|vmbus_chanmsg_gpadl_subconn
modifier|*
name|subreq
decl_stmt|;
if|if
condition|(
name|page_count
operator|>
name|VMBUS_CHANMSG_GPADL_SUBCONN_PGMAX
condition|)
name|cnt
operator|=
name|VMBUS_CHANMSG_GPADL_SUBCONN_PGMAX
expr_stmt|;
else|else
name|cnt
operator|=
name|page_count
expr_stmt|;
name|page_count
operator|-=
name|cnt
expr_stmt|;
name|reqsz
operator|=
name|__offsetof
argument_list|(
expr|struct
name|vmbus_chanmsg_gpadl_subconn
argument_list|,
name|chm_gpa_page
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|vmbus_msghc_reset
argument_list|(
name|mh
argument_list|,
name|reqsz
argument_list|)
expr_stmt|;
name|subreq
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|subreq
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_GPADL_SUBCONN
expr_stmt|;
name|subreq
operator|->
name|chm_gpadl
operator|=
name|gpadl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
operator|++
name|i
control|)
name|subreq
operator|->
name|chm_gpa_page
index|[
name|i
index|]
operator|=
name|page_id
operator|++
expr_stmt|;
name|vmbus_msghc_exec_noresult
argument_list|(
name|mh
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|page_count
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid page count %d"
operator|,
name|page_count
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|vmbus_msghc_wait_result
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|vmbus_chanmsg_gpadl_connresp
operator|*
operator|)
name|msg
operator|->
name|msg_data
operator|)
operator|->
name|chm_status
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"gpadl->chan%u failed: "
literal|"status %u\n"
argument_list|,
name|channel
operator|->
name|ch_id
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"gpadl->chan%u "
literal|"succeeded\n"
argument_list|,
name|channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Disconnect the GPA from the target channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_teardown_gpdal
parameter_list|(
name|struct
name|hv_vmbus_channel
modifier|*
name|chan
parameter_list|,
name|uint32_t
name|gpadl
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|chan
operator|->
name|vmbus_sc
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|struct
name|vmbus_chanmsg_gpadl_disconn
modifier|*
name|req
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"can not get msg hypercall for gpa x->chan%u\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_GPADL_DISCONN
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|chan
operator|->
name|ch_id
expr_stmt|;
name|req
operator|->
name|chm_gpadl
operator|=
name|gpadl
expr_stmt|;
name|error
operator|=
name|vmbus_msghc_exec
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"gpa x->chan%u msg hypercall exec failed: %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|vmbus_msghc_wait_result
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
comment|/* Discard result; no useful information */
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_vmbus_channel_close_internal
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|)
block|{
name|struct
name|vmbus_softc
modifier|*
name|sc
init|=
name|channel
operator|->
name|vmbus_sc
decl_stmt|;
name|struct
name|vmbus_msghc
modifier|*
name|mh
decl_stmt|;
name|struct
name|vmbus_chanmsg_chclose
modifier|*
name|req
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|rxq
init|=
name|channel
operator|->
name|rxq
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* TODO: stringent check */
name|atomic_clear_int
argument_list|(
operator|&
name|channel
operator|->
name|ch_stflags
argument_list|,
name|VMBUS_CHAN_ST_OPENED
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|channel
operator|->
name|ch_sysctl_ctx
argument_list|)
expr_stmt|;
comment|/* 	 * set rxq to NULL to avoid more requests be scheduled 	 */
name|channel
operator|->
name|rxq
operator|=
name|NULL
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|rxq
argument_list|,
operator|&
name|channel
operator|->
name|channel_task
argument_list|)
expr_stmt|;
name|channel
operator|->
name|on_channel_callback
operator|=
name|NULL
expr_stmt|;
comment|/** 	 * Send a closing message 	 */
name|mh
operator|=
name|vmbus_msghc_get
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"can not get msg hypercall for chclose(chan%u)\n"
argument_list|,
name|channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|vmbus_msghc_dataptr
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|req
operator|->
name|chm_hdr
operator|.
name|chm_type
operator|=
name|VMBUS_CHANMSG_TYPE_CHCLOSE
expr_stmt|;
name|req
operator|->
name|chm_chanid
operator|=
name|channel
operator|->
name|ch_id
expr_stmt|;
name|error
operator|=
name|vmbus_msghc_exec_noresult
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|vmbus_msghc_put
argument_list|(
name|sc
argument_list|,
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"chclose(chan%u) msg hypercall exec failed: %d\n"
argument_list|,
name|channel
operator|->
name|ch_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"close chan%u\n"
argument_list|,
name|channel
operator|->
name|ch_id
argument_list|)
expr_stmt|;
block|}
comment|/* Tear down the gpadl for the channel's ring buffer */
if|if
condition|(
name|channel
operator|->
name|ring_buffer_gpadl_handle
condition|)
block|{
name|hv_vmbus_channel_teardown_gpdal
argument_list|(
name|channel
argument_list|,
name|channel
operator|->
name|ring_buffer_gpadl_handle
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: Send a msg to release the childRelId */
comment|/* cleanup the ring buffers for this channel */
name|hv_ring_buffer_cleanup
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|)
expr_stmt|;
name|hv_ring_buffer_cleanup
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|channel
operator|->
name|ring_buffer_pages
argument_list|,
name|channel
operator|->
name|ring_buffer_size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Close the specified channel  */
end_comment

begin_function
name|void
name|hv_vmbus_channel_close
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|)
block|{
name|hv_vmbus_channel
modifier|*
name|sub_channel
decl_stmt|;
if|if
condition|(
name|channel
operator|->
name|primary_channel
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We only close multi-channels when the primary is 		 * closed. 		 */
return|return;
block|}
comment|/* 	 * Close all multi-channels first. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|sub_channel
argument_list|,
argument|&channel->sc_list_anchor
argument_list|,
argument|sc_list_entry
argument_list|)
block|{
if|if
condition|(
operator|(
name|sub_channel
operator|->
name|ch_stflags
operator|&
name|VMBUS_CHAN_ST_OPENED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|hv_vmbus_channel_close_internal
argument_list|(
name|sub_channel
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Then close the primary channel. 	 */
name|hv_vmbus_channel_close_internal
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Send the specified buffer on the given channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_send_packet
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint64_t
name|request_id
parameter_list|,
name|hv_vmbus_packet_type
name|type
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|hv_vm_packet_descriptor
name|desc
decl_stmt|;
name|uint32_t
name|packet_len
decl_stmt|;
name|uint64_t
name|aligned_data
decl_stmt|;
name|uint32_t
name|packet_len_aligned
decl_stmt|;
name|boolean_t
name|need_sig
decl_stmt|;
name|hv_vmbus_sg_buffer_list
name|buffer_list
index|[
literal|3
index|]
decl_stmt|;
name|packet_len
operator|=
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
operator|+
name|buffer_len
expr_stmt|;
name|packet_len_aligned
operator|=
name|HV_ALIGN_UP
argument_list|(
name|packet_len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|aligned_data
operator|=
literal|0
expr_stmt|;
comment|/* Setup the descriptor */
name|desc
operator|.
name|type
operator|=
name|type
expr_stmt|;
comment|/* HV_VMBUS_PACKET_TYPE_DATA_IN_BAND;             */
name|desc
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
comment|/* HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED */
comment|/* in 8-bytes granularity */
name|desc
operator|.
name|data_offset8
operator|=
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
operator|>>
literal|3
expr_stmt|;
name|desc
operator|.
name|length8
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|packet_len_aligned
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|desc
operator|.
name|transaction_id
operator|=
name|request_id
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|data
operator|=
operator|&
name|desc
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|length
operator|=
name|buffer_len
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|data
operator|=
operator|&
name|aligned_data
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|length
operator|=
name|packet_len_aligned
operator|-
name|packet_len
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_write
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|,
name|buffer_list
argument_list|,
literal|3
argument_list|,
operator|&
name|need_sig
argument_list|)
expr_stmt|;
comment|/* TODO: We should determine if this is optional */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|need_sig
condition|)
name|vmbus_chan_send_event
argument_list|(
name|channel
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Send a range of single-page buffer packets using  * a GPADL Direct packet type  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_send_packet_pagebuffer
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|hv_vmbus_page_buffer
name|page_buffers
index|[]
parameter_list|,
name|uint32_t
name|page_count
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint64_t
name|request_id
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean_t
name|need_sig
decl_stmt|;
name|uint32_t
name|packet_len
decl_stmt|;
name|uint32_t
name|page_buflen
decl_stmt|;
name|uint32_t
name|packetLen_aligned
decl_stmt|;
name|hv_vmbus_sg_buffer_list
name|buffer_list
index|[
literal|4
index|]
decl_stmt|;
name|hv_vmbus_channel_packet_page_buffer
name|desc
decl_stmt|;
name|uint32_t
name|descSize
decl_stmt|;
name|uint64_t
name|alignedData
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|page_count
operator|>
name|HV_MAX_PAGE_BUFFER_COUNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Adjust the size down since hv_vmbus_channel_packet_page_buffer 	 *  is the largest size we support 	 */
name|descSize
operator|=
name|__offsetof
argument_list|(
name|hv_vmbus_channel_packet_page_buffer
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|page_buflen
operator|=
sizeof|sizeof
argument_list|(
name|hv_vmbus_page_buffer
argument_list|)
operator|*
name|page_count
expr_stmt|;
name|packet_len
operator|=
name|descSize
operator|+
name|page_buflen
operator|+
name|buffer_len
expr_stmt|;
name|packetLen_aligned
operator|=
name|HV_ALIGN_UP
argument_list|(
name|packet_len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the descriptor */
name|desc
operator|.
name|type
operator|=
name|HV_VMBUS_PACKET_TYPE_DATA_USING_GPA_DIRECT
expr_stmt|;
name|desc
operator|.
name|flags
operator|=
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
expr_stmt|;
comment|/* in 8-bytes granularity */
name|desc
operator|.
name|data_offset8
operator|=
operator|(
name|descSize
operator|+
name|page_buflen
operator|)
operator|>>
literal|3
expr_stmt|;
name|desc
operator|.
name|length8
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|packetLen_aligned
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|desc
operator|.
name|transaction_id
operator|=
name|request_id
expr_stmt|;
name|desc
operator|.
name|range_count
operator|=
name|page_count
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|data
operator|=
operator|&
name|desc
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|descSize
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|data
operator|=
name|page_buffers
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|length
operator|=
name|page_buflen
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|length
operator|=
name|buffer_len
expr_stmt|;
name|buffer_list
index|[
literal|3
index|]
operator|.
name|data
operator|=
operator|&
name|alignedData
expr_stmt|;
name|buffer_list
index|[
literal|3
index|]
operator|.
name|length
operator|=
name|packetLen_aligned
operator|-
name|packet_len
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_write
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|,
name|buffer_list
argument_list|,
literal|4
argument_list|,
operator|&
name|need_sig
argument_list|)
expr_stmt|;
comment|/* TODO: We should determine if this is optional */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|need_sig
condition|)
name|vmbus_chan_send_event
argument_list|(
name|channel
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Send a multi-page buffer packet using a GPADL Direct packet type  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_send_packet_multipagebuffer
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|hv_vmbus_multipage_buffer
modifier|*
name|multi_page_buffer
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint64_t
name|request_id
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|uint32_t
name|desc_size
decl_stmt|;
name|boolean_t
name|need_sig
decl_stmt|;
name|uint32_t
name|packet_len
decl_stmt|;
name|uint32_t
name|packet_len_aligned
decl_stmt|;
name|uint32_t
name|pfn_count
decl_stmt|;
name|uint64_t
name|aligned_data
init|=
literal|0
decl_stmt|;
name|hv_vmbus_sg_buffer_list
name|buffer_list
index|[
literal|3
index|]
decl_stmt|;
name|hv_vmbus_channel_packet_multipage_buffer
name|desc
decl_stmt|;
name|pfn_count
operator|=
name|HV_NUM_PAGES_SPANNED
argument_list|(
name|multi_page_buffer
operator|->
name|offset
argument_list|,
name|multi_page_buffer
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pfn_count
operator|==
literal|0
operator|)
operator|||
operator|(
name|pfn_count
operator|>
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Adjust the size down since hv_vmbus_channel_packet_multipage_buffer 	 * is the largest size we support 	 */
name|desc_size
operator|=
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_packet_multipage_buffer
argument_list|)
operator|-
operator|(
operator|(
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
operator|-
name|pfn_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
name|packet_len
operator|=
name|desc_size
operator|+
name|buffer_len
expr_stmt|;
name|packet_len_aligned
operator|=
name|HV_ALIGN_UP
argument_list|(
name|packet_len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the descriptor 	 */
name|desc
operator|.
name|type
operator|=
name|HV_VMBUS_PACKET_TYPE_DATA_USING_GPA_DIRECT
expr_stmt|;
name|desc
operator|.
name|flags
operator|=
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
expr_stmt|;
name|desc
operator|.
name|data_offset8
operator|=
name|desc_size
operator|>>
literal|3
expr_stmt|;
comment|/* in 8-bytes granularity */
name|desc
operator|.
name|length8
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|packet_len_aligned
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|desc
operator|.
name|transaction_id
operator|=
name|request_id
expr_stmt|;
name|desc
operator|.
name|range_count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|range
operator|.
name|length
operator|=
name|multi_page_buffer
operator|->
name|length
expr_stmt|;
name|desc
operator|.
name|range
operator|.
name|offset
operator|=
name|multi_page_buffer
operator|->
name|offset
expr_stmt|;
name|memcpy
argument_list|(
name|desc
operator|.
name|range
operator|.
name|pfn_array
argument_list|,
name|multi_page_buffer
operator|->
name|pfn_array
argument_list|,
name|pfn_count
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|data
operator|=
operator|&
name|desc
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|desc_size
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|length
operator|=
name|buffer_len
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|data
operator|=
operator|&
name|aligned_data
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|length
operator|=
name|packet_len_aligned
operator|-
name|packet_len
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_write
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|,
name|buffer_list
argument_list|,
literal|3
argument_list|,
operator|&
name|need_sig
argument_list|)
expr_stmt|;
comment|/* TODO: We should determine if this is optional */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|need_sig
condition|)
name|vmbus_chan_send_event
argument_list|(
name|channel
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve the user packet on the specified channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_recv_packet
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|Buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint32_t
modifier|*
name|buffer_actual_len
parameter_list|,
name|uint64_t
modifier|*
name|request_id
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint32_t
name|user_len
decl_stmt|;
name|uint32_t
name|packet_len
decl_stmt|;
name|hv_vm_packet_descriptor
name|desc
decl_stmt|;
operator|*
name|buffer_actual_len
operator|=
literal|0
expr_stmt|;
operator|*
name|request_id
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_peek
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|packet_len
operator|=
name|desc
operator|.
name|length8
operator|<<
literal|3
expr_stmt|;
name|user_len
operator|=
name|packet_len
operator|-
operator|(
name|desc
operator|.
name|data_offset8
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|buffer_actual_len
operator|=
name|user_len
expr_stmt|;
if|if
condition|(
name|user_len
operator|>
name|buffer_len
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|request_id
operator|=
name|desc
operator|.
name|transaction_id
expr_stmt|;
comment|/* Copy over the packet to the user buffer */
name|ret
operator|=
name|hv_ring_buffer_read
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|,
name|Buffer
argument_list|,
name|user_len
argument_list|,
operator|(
name|desc
operator|.
name|data_offset8
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve the raw packet on the specified channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_recv_packet_raw
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint32_t
modifier|*
name|buffer_actual_len
parameter_list|,
name|uint64_t
modifier|*
name|request_id
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint32_t
name|packetLen
decl_stmt|;
name|hv_vm_packet_descriptor
name|desc
decl_stmt|;
operator|*
name|buffer_actual_len
operator|=
literal|0
expr_stmt|;
operator|*
name|request_id
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_peek
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|packetLen
operator|=
name|desc
operator|.
name|length8
operator|<<
literal|3
expr_stmt|;
operator|*
name|buffer_actual_len
operator|=
name|packetLen
expr_stmt|;
if|if
condition|(
name|packetLen
operator|>
name|buffer_len
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
operator|*
name|request_id
operator|=
name|desc
operator|.
name|transaction_id
expr_stmt|;
comment|/* Copy over the entire packet to the user buffer */
name|ret
operator|=
name|hv_ring_buffer_read
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|,
name|buffer
argument_list|,
name|packetLen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_task
parameter_list|(
name|void
modifier|*
name|xchan
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hv_vmbus_channel
modifier|*
name|chan
init|=
name|xchan
decl_stmt|;
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
name|chan
operator|->
name|channel_callback_context
expr_stmt|;
name|callback
operator|=
name|chan
operator|->
name|on_channel_callback
expr_stmt|;
comment|/* 	 * Optimize host to guest signaling by ensuring: 	 * 1. While reading the channel, we disable interrupts from 	 *    host. 	 * 2. Ensure that we process all posted messages from the host 	 *    before returning from this callback. 	 * 3. Once we return, enable signaling from the host. Once this 	 *    state is set we check to see if additional packets are 	 *    available to read. In this case we repeat the process. 	 * 	 * NOTE: Interrupt has been disabled in the ISR. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint32_t
name|left
decl_stmt|;
name|callback
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|left
operator|=
name|hv_ring_buffer_read_end
argument_list|(
operator|&
name|chan
operator|->
name|inbound
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
comment|/* No more data in RX bufring; done */
break|break;
block|}
name|hv_ring_buffer_read_begin
argument_list|(
operator|&
name|chan
operator|->
name|inbound
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_task_nobatch
parameter_list|(
name|void
modifier|*
name|xchan
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|hv_vmbus_channel
modifier|*
name|chan
init|=
name|xchan
decl_stmt|;
name|chan
operator|->
name|on_channel_callback
argument_list|(
name|chan
operator|->
name|channel_callback_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vmbus_event_flags_proc
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|u_long
modifier|*
name|event_flags
parameter_list|,
name|int
name|flag_cnt
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|flag_cnt
condition|;
operator|++
name|f
control|)
block|{
name|uint32_t
name|chid_base
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|int
name|chid_ofs
decl_stmt|;
if|if
condition|(
name|event_flags
index|[
name|f
index|]
operator|==
literal|0
condition|)
continue|continue;
name|flags
operator|=
name|atomic_swap_long
argument_list|(
operator|&
name|event_flags
index|[
name|f
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chid_base
operator|=
name|f
operator|<<
name|VMBUS_EVTFLAG_SHIFT
expr_stmt|;
while|while
condition|(
operator|(
name|chid_ofs
operator|=
name|ffsl
argument_list|(
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|hv_vmbus_channel
modifier|*
name|channel
decl_stmt|;
operator|--
name|chid_ofs
expr_stmt|;
comment|/* NOTE: ffsl is 1-based */
name|flags
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|chid_ofs
operator|)
expr_stmt|;
name|channel
operator|=
name|sc
operator|->
name|vmbus_chmap
index|[
name|chid_base
operator|+
name|chid_ofs
index|]
expr_stmt|;
comment|/* if channel is closed or closing */
if|if
condition|(
name|channel
operator|==
name|NULL
operator|||
name|channel
operator|->
name|rxq
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|channel
operator|->
name|ch_flags
operator|&
name|VMBUS_CHAN_FLAG_BATCHREAD
condition|)
name|hv_ring_buffer_read_begin
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|channel
operator|->
name|rxq
argument_list|,
operator|&
name|channel
operator|->
name|channel_task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vmbus_event_proc
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|vmbus_evtflags
modifier|*
name|eventf
decl_stmt|;
comment|/* 	 * On Host with Win8 or above, the event page can be checked directly 	 * to get the id of the channel that has the pending interrupt. 	 */
name|eventf
operator|=
name|VMBUS_PCPU_GET
argument_list|(
name|sc
argument_list|,
name|event_flags
argument_list|,
name|cpu
argument_list|)
operator|+
name|VMBUS_SINT_MESSAGE
expr_stmt|;
name|vmbus_event_flags_proc
argument_list|(
name|sc
argument_list|,
name|eventf
operator|->
name|evt_flags
argument_list|,
name|VMBUS_PCPU_GET
argument_list|(
name|sc
argument_list|,
name|event_flags_cnt
argument_list|,
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmbus_event_proc_compat
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|vmbus_evtflags
modifier|*
name|eventf
decl_stmt|;
name|eventf
operator|=
name|VMBUS_PCPU_GET
argument_list|(
name|sc
argument_list|,
name|event_flags
argument_list|,
name|cpu
argument_list|)
operator|+
name|VMBUS_SINT_MESSAGE
expr_stmt|;
if|if
condition|(
name|atomic_testandclear_long
argument_list|(
operator|&
name|eventf
operator|->
name|evt_flags
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|vmbus_event_flags_proc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vmbus_rx_evtflags
argument_list|,
name|VMBUS_CHAN_MAX_COMPAT
operator|>>
name|VMBUS_EVTFLAG_SHIFT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vmbus_chan_update_evtflagcnt
parameter_list|(
name|struct
name|vmbus_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|hv_vmbus_channel
modifier|*
name|chan
parameter_list|)
block|{
specifier|volatile
name|int
modifier|*
name|flag_cnt_ptr
decl_stmt|;
name|int
name|flag_cnt
decl_stmt|;
name|flag_cnt
operator|=
operator|(
name|chan
operator|->
name|ch_id
operator|/
name|VMBUS_EVTFLAG_LEN
operator|)
operator|+
literal|1
expr_stmt|;
name|flag_cnt_ptr
operator|=
name|VMBUS_PCPU_PTR
argument_list|(
name|sc
argument_list|,
name|event_flags_cnt
argument_list|,
name|chan
operator|->
name|target_cpu
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|old_flag_cnt
decl_stmt|;
name|old_flag_cnt
operator|=
operator|*
name|flag_cnt_ptr
expr_stmt|;
if|if
condition|(
name|old_flag_cnt
operator|>=
name|flag_cnt
condition|)
break|break;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
name|flag_cnt_ptr
argument_list|,
name|old_flag_cnt
argument_list|,
name|flag_cnt
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vmbus_dev
argument_list|,
literal|"channel%u update cpu%d flag_cnt to %d\n"
argument_list|,
name|chan
operator|->
name|ch_id
argument_list|,
name|chan
operator|->
name|target_cpu
argument_list|,
name|flag_cnt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

end_unit

