begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2012 Microsoft Corp.  * Copyright (c) 2012 NetApp Inc.  * Copyright (c) 2012 Citrix Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|"hv_vmbus_priv.h"
end_include

begin_function_decl
specifier|static
name|int
name|vmbus_channel_create_gpadl_header
parameter_list|(
comment|/* must be phys and virt contiguous*/
name|void
modifier|*
name|contig_buffer
parameter_list|,
comment|/* page-size multiple */
name|uint32_t
name|size
parameter_list|,
name|hv_vmbus_channel_msg_info
modifier|*
modifier|*
name|msg_info
parameter_list|,
name|uint32_t
modifier|*
name|message_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmbus_channel_set_event
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  @brief Trigger an event notification on the specified channel  */
end_comment

begin_function
specifier|static
name|void
name|vmbus_channel_set_event
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|)
block|{
name|hv_vmbus_monitor_page
modifier|*
name|monitor_page
decl_stmt|;
if|if
condition|(
name|channel
operator|->
name|offer_msg
operator|.
name|monitor_allocated
condition|)
block|{
comment|/* Each uint32_t represents 32 channels */
name|synch_set_bit
argument_list|(
operator|(
name|channel
operator|->
name|offer_msg
operator|.
name|child_rel_id
operator|&
literal|31
operator|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|hv_vmbus_g_connection
operator|.
name|send_interrupt_page
operator|+
operator|(
operator|(
name|channel
operator|->
name|offer_msg
operator|.
name|child_rel_id
operator|>>
literal|5
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|monitor_page
operator|=
operator|(
name|hv_vmbus_monitor_page
operator|*
operator|)
name|hv_vmbus_g_connection
operator|.
name|monitor_pages
expr_stmt|;
name|monitor_page
operator|++
expr_stmt|;
comment|/* Get the child to parent monitor page */
name|synch_set_bit
argument_list|(
name|channel
operator|->
name|monitor_bit
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|monitor_page
operator|->
name|trigger_group
index|[
name|channel
operator|->
name|monitor_group
index|]
operator|.
name|u
operator|.
name|pending
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hv_vmbus_set_event
argument_list|(
name|channel
operator|->
name|offer_msg
operator|.
name|child_rel_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief Open the specified channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_open
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|new_channel
parameter_list|,
name|uint32_t
name|send_ring_buffer_size
parameter_list|,
name|uint32_t
name|recv_ring_buffer_size
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|,
name|uint32_t
name|user_data_len
parameter_list|,
name|hv_vmbus_pfn_channel_callback
name|pfn_on_channel_callback
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|hv_vmbus_channel_open_channel
modifier|*
name|open_msg
decl_stmt|;
name|hv_vmbus_channel_msg_info
modifier|*
name|open_info
decl_stmt|;
name|new_channel
operator|->
name|on_channel_callback
operator|=
name|pfn_on_channel_callback
expr_stmt|;
name|new_channel
operator|->
name|channel_callback_context
operator|=
name|context
expr_stmt|;
comment|/* Allocate the ring buffer */
name|out
operator|=
name|contigmalloc
argument_list|(
operator|(
name|send_ring_buffer_size
operator|+
name|recv_ring_buffer_size
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
argument_list|,
literal|0UL
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|out
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Error VMBUS: contigmalloc failed to allocate Ring Buffer!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|in
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|out
operator|+
name|send_ring_buffer_size
operator|)
expr_stmt|;
name|new_channel
operator|->
name|ring_buffer_pages
operator|=
name|out
expr_stmt|;
name|new_channel
operator|->
name|ring_buffer_page_count
operator|=
operator|(
name|send_ring_buffer_size
operator|+
name|recv_ring_buffer_size
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|new_channel
operator|->
name|ring_buffer_size
operator|=
name|send_ring_buffer_size
operator|+
name|recv_ring_buffer_size
expr_stmt|;
name|hv_vmbus_ring_buffer_init
argument_list|(
operator|&
name|new_channel
operator|->
name|outbound
argument_list|,
name|out
argument_list|,
name|send_ring_buffer_size
argument_list|)
expr_stmt|;
name|hv_vmbus_ring_buffer_init
argument_list|(
operator|&
name|new_channel
operator|->
name|inbound
argument_list|,
name|in
argument_list|,
name|recv_ring_buffer_size
argument_list|)
expr_stmt|;
comment|/** 	 * Establish the gpadl for the ring buffer 	 */
name|new_channel
operator|->
name|ring_buffer_gpadl_handle
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_channel_establish_gpadl
argument_list|(
name|new_channel
argument_list|,
name|new_channel
operator|->
name|outbound
operator|.
name|ring_buffer
argument_list|,
name|send_ring_buffer_size
operator|+
name|recv_ring_buffer_size
argument_list|,
operator|&
name|new_channel
operator|->
name|ring_buffer_gpadl_handle
argument_list|)
expr_stmt|;
comment|/** 	 * Create and init the channel open message 	 */
name|open_info
operator|=
operator|(
name|hv_vmbus_channel_msg_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_msg_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_open_channel
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|open_info
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Error VMBUS: malloc failed to allocate Open Channel message!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|open_info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sema_init
argument_list|(
operator|&
name|open_info
operator|->
name|wait_sema
argument_list|,
literal|0
argument_list|,
literal|"Open Info Sema"
argument_list|)
expr_stmt|;
name|open_msg
operator|=
operator|(
name|hv_vmbus_channel_open_channel
operator|*
operator|)
name|open_info
operator|->
name|msg
expr_stmt|;
name|open_msg
operator|->
name|header
operator|.
name|message_type
operator|=
name|HV_CHANNEL_MESSAGE_OPEN_CHANNEL
expr_stmt|;
name|open_msg
operator|->
name|open_id
operator|=
name|new_channel
operator|->
name|offer_msg
operator|.
name|child_rel_id
expr_stmt|;
name|open_msg
operator|->
name|child_rel_id
operator|=
name|new_channel
operator|->
name|offer_msg
operator|.
name|child_rel_id
expr_stmt|;
name|open_msg
operator|->
name|ring_buffer_gpadl_handle
operator|=
name|new_channel
operator|->
name|ring_buffer_gpadl_handle
expr_stmt|;
name|open_msg
operator|->
name|downstream_ring_buffer_page_offset
operator|=
name|send_ring_buffer_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|open_msg
operator|->
name|server_context_area_gpadl_handle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|user_data_len
condition|)
name|memcpy
argument_list|(
name|open_msg
operator|->
name|user_data
argument_list|,
name|user_data
argument_list|,
name|user_data_len
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_anchor
argument_list|,
name|open_info
argument_list|,
name|msg_list_entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_post_message
argument_list|(
name|open_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_open_channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|open_info
operator|->
name|wait_sema
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds */
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|open_info
operator|->
name|response
operator|.
name|open_result
operator|.
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"VMBUS: channel<%p> open success.\n"
argument_list|,
name|new_channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Error VMBUS: channel<%p> open failed - %d!\n"
argument_list|,
name|new_channel
argument_list|,
name|open_info
operator|->
name|response
operator|.
name|open_result
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|mtx_lock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_anchor
argument_list|,
name|open_info
argument_list|,
name|msg_list_entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|sema_destroy
argument_list|(
operator|&
name|open_info
operator|->
name|wait_sema
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|open_info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Create a gpadl for the specified buffer  */
end_comment

begin_function
specifier|static
name|int
name|vmbus_channel_create_gpadl_header
parameter_list|(
name|void
modifier|*
name|contig_buffer
parameter_list|,
name|uint32_t
name|size
parameter_list|,
comment|/* page-size multiple */
name|hv_vmbus_channel_msg_info
modifier|*
modifier|*
name|msg_info
parameter_list|,
name|uint32_t
modifier|*
name|message_count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|page_count
decl_stmt|;
name|unsigned
name|long
name|long
name|pfn
decl_stmt|;
name|uint32_t
name|msg_size
decl_stmt|;
name|hv_vmbus_channel_gpadl_header
modifier|*
name|gpa_header
decl_stmt|;
name|hv_vmbus_channel_gpadl_body
modifier|*
name|gpadl_body
decl_stmt|;
name|hv_vmbus_channel_msg_info
modifier|*
name|msg_header
decl_stmt|;
name|hv_vmbus_channel_msg_info
modifier|*
name|msg_body
decl_stmt|;
name|int
name|pfnSum
decl_stmt|,
name|pfnCount
decl_stmt|,
name|pfnLeft
decl_stmt|,
name|pfnCurr
decl_stmt|,
name|pfnSize
decl_stmt|;
name|page_count
operator|=
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|pfn
operator|=
name|hv_get_phys_addr
argument_list|(
name|contig_buffer
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
comment|/*do we need a gpadl body msg */
name|pfnSize
operator|=
name|HV_MAX_SIZE_CHANNEL_MESSAGE
operator|-
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_gpadl_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|hv_gpa_range
argument_list|)
expr_stmt|;
name|pfnCount
operator|=
name|pfnSize
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_count
operator|>
name|pfnCount
condition|)
block|{
comment|/* if(we need a gpadl body)	*/
comment|/* fill in the header		*/
name|msg_size
operator|=
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_msg_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_gpadl_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hv_gpa_range
argument_list|)
operator|+
name|pfnCount
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|msg_header
operator|=
name|malloc
argument_list|(
name|msg_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|msg_header
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Error VMBUS: malloc failed to allocate Gpadl Message!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_header
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|msg_header
operator|->
name|sub_msg_list_anchor
argument_list|)
expr_stmt|;
name|msg_header
operator|->
name|message_size
operator|=
name|msg_size
expr_stmt|;
name|gpa_header
operator|=
operator|(
name|hv_vmbus_channel_gpadl_header
operator|*
operator|)
name|msg_header
operator|->
name|msg
expr_stmt|;
name|gpa_header
operator|->
name|range_count
operator|=
literal|1
expr_stmt|;
name|gpa_header
operator|->
name|range_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|hv_gpa_range
argument_list|)
operator|+
name|page_count
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|gpa_header
operator|->
name|range
index|[
literal|0
index|]
operator|.
name|byte_offset
operator|=
literal|0
expr_stmt|;
name|gpa_header
operator|->
name|range
index|[
literal|0
index|]
operator|.
name|byte_count
operator|=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pfnCount
condition|;
name|i
operator|++
control|)
block|{
name|gpa_header
operator|->
name|range
index|[
literal|0
index|]
operator|.
name|pfn_array
index|[
name|i
index|]
operator|=
name|pfn
operator|+
name|i
expr_stmt|;
block|}
operator|*
name|msg_info
operator|=
name|msg_header
expr_stmt|;
operator|*
name|message_count
operator|=
literal|1
expr_stmt|;
name|pfnSum
operator|=
name|pfnCount
expr_stmt|;
name|pfnLeft
operator|=
name|page_count
operator|-
name|pfnCount
expr_stmt|;
comment|/* 	     *  figure out how many pfns we can fit 	     */
name|pfnSize
operator|=
name|HV_MAX_SIZE_CHANNEL_MESSAGE
operator|-
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_gpadl_body
argument_list|)
expr_stmt|;
name|pfnCount
operator|=
name|pfnSize
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
comment|/* 	     * fill in the body 	     */
while|while
condition|(
name|pfnLeft
condition|)
block|{
if|if
condition|(
name|pfnLeft
operator|>
name|pfnCount
condition|)
block|{
name|pfnCurr
operator|=
name|pfnCount
expr_stmt|;
block|}
else|else
block|{
name|pfnCurr
operator|=
name|pfnLeft
expr_stmt|;
block|}
name|msg_size
operator|=
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_msg_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_gpadl_body
argument_list|)
operator|+
name|pfnCurr
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|msg_body
operator|=
name|malloc
argument_list|(
name|msg_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|msg_body
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Error VMBUS: malloc failed to allocate Gpadl msg_body!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_body
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|msg_body
operator|->
name|message_size
operator|=
name|msg_size
expr_stmt|;
operator|(
operator|*
name|message_count
operator|)
operator|++
expr_stmt|;
name|gpadl_body
operator|=
operator|(
name|hv_vmbus_channel_gpadl_body
operator|*
operator|)
name|msg_body
operator|->
name|msg
expr_stmt|;
comment|/* 		 * gpadl_body->gpadl = kbuffer; 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pfnCurr
condition|;
name|i
operator|++
control|)
block|{
name|gpadl_body
operator|->
name|pfn
index|[
name|i
index|]
operator|=
name|pfn
operator|+
name|pfnSum
operator|+
name|i
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|msg_header
operator|->
name|sub_msg_list_anchor
argument_list|,
name|msg_body
argument_list|,
name|msg_list_entry
argument_list|)
expr_stmt|;
name|pfnSum
operator|+=
name|pfnCurr
expr_stmt|;
name|pfnLeft
operator|-=
name|pfnCurr
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* else everything fits in a header */
name|msg_size
operator|=
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_msg_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_gpadl_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hv_gpa_range
argument_list|)
operator|+
name|page_count
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|msg_header
operator|=
name|malloc
argument_list|(
name|msg_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|msg_header
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Error VMBUS: malloc failed to allocate Gpadl Message!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_header
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|msg_header
operator|->
name|message_size
operator|=
name|msg_size
expr_stmt|;
name|gpa_header
operator|=
operator|(
name|hv_vmbus_channel_gpadl_header
operator|*
operator|)
name|msg_header
operator|->
name|msg
expr_stmt|;
name|gpa_header
operator|->
name|range_count
operator|=
literal|1
expr_stmt|;
name|gpa_header
operator|->
name|range_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|hv_gpa_range
argument_list|)
operator|+
name|page_count
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|gpa_header
operator|->
name|range
index|[
literal|0
index|]
operator|.
name|byte_offset
operator|=
literal|0
expr_stmt|;
name|gpa_header
operator|->
name|range
index|[
literal|0
index|]
operator|.
name|byte_count
operator|=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|gpa_header
operator|->
name|range
index|[
literal|0
index|]
operator|.
name|pfn_array
index|[
name|i
index|]
operator|=
name|pfn
operator|+
name|i
expr_stmt|;
block|}
operator|*
name|msg_info
operator|=
name|msg_header
expr_stmt|;
operator|*
name|message_count
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Establish a GPADL for the specified buffer  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_establish_gpadl
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|contig_buffer
parameter_list|,
name|uint32_t
name|size
parameter_list|,
comment|/* page-size multiple */
name|uint32_t
modifier|*
name|gpadl_handle
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|hv_vmbus_channel_gpadl_header
modifier|*
name|gpadl_msg
decl_stmt|;
name|hv_vmbus_channel_gpadl_body
modifier|*
name|gpadl_body
decl_stmt|;
name|hv_vmbus_channel_msg_info
modifier|*
name|msg_info
decl_stmt|;
name|hv_vmbus_channel_msg_info
modifier|*
name|sub_msg_info
decl_stmt|;
name|uint32_t
name|msg_count
decl_stmt|;
name|hv_vmbus_channel_msg_info
modifier|*
name|curr
decl_stmt|;
name|uint32_t
name|next_gpadl_handle
decl_stmt|;
name|next_gpadl_handle
operator|=
name|hv_vmbus_g_connection
operator|.
name|next_gpadl_handle
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|hv_vmbus_g_connection
operator|.
name|next_gpadl_handle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vmbus_channel_create_gpadl_header
argument_list|(
name|contig_buffer
argument_list|,
name|size
argument_list|,
operator|&
name|msg_info
argument_list|,
operator|&
name|msg_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* if(allocation failed) return immediately */
comment|/* reverse atomic_add_int above */
name|atomic_subtract_int
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|hv_vmbus_g_connection
operator|.
name|next_gpadl_handle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|sema_init
argument_list|(
operator|&
name|msg_info
operator|->
name|wait_sema
argument_list|,
literal|0
argument_list|,
literal|"Open Info Sema"
argument_list|)
expr_stmt|;
name|gpadl_msg
operator|=
operator|(
name|hv_vmbus_channel_gpadl_header
operator|*
operator|)
name|msg_info
operator|->
name|msg
expr_stmt|;
name|gpadl_msg
operator|->
name|header
operator|.
name|message_type
operator|=
name|HV_CHANNEL_MESSAGEL_GPADL_HEADER
expr_stmt|;
name|gpadl_msg
operator|->
name|child_rel_id
operator|=
name|channel
operator|->
name|offer_msg
operator|.
name|child_rel_id
expr_stmt|;
name|gpadl_msg
operator|->
name|gpadl
operator|=
name|next_gpadl_handle
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_anchor
argument_list|,
name|msg_info
argument_list|,
name|msg_list_entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_post_message
argument_list|(
name|gpadl_msg
argument_list|,
name|msg_info
operator|->
name|message_size
operator|-
operator|(
name|uint32_t
operator|)
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_msg_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|msg_count
operator|>
literal|1
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|curr
argument_list|,
argument|&msg_info->sub_msg_list_anchor
argument_list|,
argument|msg_list_entry
argument_list|)
block|{
name|sub_msg_info
operator|=
name|curr
expr_stmt|;
name|gpadl_body
operator|=
operator|(
name|hv_vmbus_channel_gpadl_body
operator|*
operator|)
name|sub_msg_info
operator|->
name|msg
expr_stmt|;
name|gpadl_body
operator|->
name|header
operator|.
name|message_type
operator|=
name|HV_CHANNEL_MESSAGE_GPADL_BODY
expr_stmt|;
name|gpadl_body
operator|->
name|gpadl
operator|=
name|next_gpadl_handle
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_post_message
argument_list|(
name|gpadl_body
argument_list|,
name|sub_msg_info
operator|->
name|message_size
operator|-
operator|(
name|uint32_t
operator|)
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_msg_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if (the post message failed) give up and clean up */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
block|}
block|}
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|msg_info
operator|->
name|wait_sema
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds*/
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
operator|*
name|gpadl_handle
operator|=
name|gpadl_msg
operator|->
name|gpadl
expr_stmt|;
name|cleanup
label|:
name|mtx_lock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_anchor
argument_list|,
name|msg_info
argument_list|,
name|msg_list_entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|sema_destroy
argument_list|(
operator|&
name|msg_info
operator|->
name|wait_sema
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg_info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Teardown the specified GPADL handle  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_teardown_gpdal
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|uint32_t
name|gpadl_handle
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|hv_vmbus_channel_gpadl_teardown
modifier|*
name|msg
decl_stmt|;
name|hv_vmbus_channel_msg_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
operator|(
name|hv_vmbus_channel_msg_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_msg_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_gpadl_teardown
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|info
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Error VMBUS: malloc failed to allocate Gpadl Teardown Msg!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|sema_init
argument_list|(
operator|&
name|info
operator|->
name|wait_sema
argument_list|,
literal|0
argument_list|,
literal|"Open Info Sema"
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|hv_vmbus_channel_gpadl_teardown
operator|*
operator|)
name|info
operator|->
name|msg
expr_stmt|;
name|msg
operator|->
name|header
operator|.
name|message_type
operator|=
name|HV_CHANNEL_MESSAGE_GPADL_TEARDOWN
expr_stmt|;
name|msg
operator|->
name|child_rel_id
operator|=
name|channel
operator|->
name|offer_msg
operator|.
name|child_rel_id
expr_stmt|;
name|msg
operator|->
name|gpadl
operator|=
name|gpadl_handle
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_anchor
argument_list|,
name|info
argument_list|,
name|msg_list_entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_post_message
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_gpadl_teardown
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|ret
operator|=
name|sema_timedwait
argument_list|(
operator|&
name|info
operator|->
name|wait_sema
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* KYS 5 seconds */
name|cleanup
label|:
comment|/* 	 * Received a torndown response 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_anchor
argument_list|,
name|info
argument_list|,
name|msg_list_entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_msg_lock
argument_list|)
expr_stmt|;
name|sema_destroy
argument_list|(
operator|&
name|info
operator|->
name|wait_sema
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Close the specified channel  */
end_comment

begin_function
name|void
name|hv_vmbus_channel_close
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|hv_vmbus_channel_close_channel
modifier|*
name|msg
decl_stmt|;
name|hv_vmbus_channel_msg_info
modifier|*
name|info
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|channel
operator|->
name|inbound_lock
argument_list|)
expr_stmt|;
name|channel
operator|->
name|on_channel_callback
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|channel
operator|->
name|inbound_lock
argument_list|)
expr_stmt|;
comment|/** 	 * Send a closing message 	 */
name|info
operator|=
operator|(
name|hv_vmbus_channel_msg_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_msg_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_close_channel
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|info
operator|!=
name|NULL
argument_list|,
operator|(
literal|"VMBUS: malloc failed hv_vmbus_channel_close!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return;
name|msg
operator|=
operator|(
name|hv_vmbus_channel_close_channel
operator|*
operator|)
name|info
operator|->
name|msg
expr_stmt|;
name|msg
operator|->
name|header
operator|.
name|message_type
operator|=
name|HV_CHANNEL_MESSAGE_CLOSE_CHANNEL
expr_stmt|;
name|msg
operator|->
name|child_rel_id
operator|=
name|channel
operator|->
name|offer_msg
operator|.
name|child_rel_id
expr_stmt|;
name|ret
operator|=
name|hv_vmbus_post_message
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_close_channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tear down the gpadl for the channel's ring buffer */
if|if
condition|(
name|channel
operator|->
name|ring_buffer_gpadl_handle
condition|)
block|{
name|hv_vmbus_channel_teardown_gpdal
argument_list|(
name|channel
argument_list|,
name|channel
operator|->
name|ring_buffer_gpadl_handle
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: Send a msg to release the childRelId */
comment|/* cleanup the ring buffers for this channel */
name|hv_ring_buffer_cleanup
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|)
expr_stmt|;
name|hv_ring_buffer_cleanup
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|channel
operator|->
name|ring_buffer_pages
argument_list|,
name|channel
operator|->
name|ring_buffer_size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* 	 *  If we are closing the channel during an error path in 	 *  opening the channel, don't free the channel 	 *  since the caller will free the channel 	 */
if|if
condition|(
name|channel
operator|->
name|state
operator|==
name|HV_CHANNEL_OPEN_STATE
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_anchor
argument_list|,
name|channel
argument_list|,
name|list_entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|hv_vmbus_g_connection
operator|.
name|channel_lock
argument_list|)
expr_stmt|;
name|hv_vmbus_free_vmbus_channel
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief Send the specified buffer on the given channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_send_packet
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint64_t
name|request_id
parameter_list|,
name|hv_vmbus_packet_type
name|type
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|hv_vm_packet_descriptor
name|desc
decl_stmt|;
name|uint32_t
name|packet_len
decl_stmt|;
name|uint64_t
name|aligned_data
decl_stmt|;
name|uint32_t
name|packet_len_aligned
decl_stmt|;
name|hv_vmbus_sg_buffer_list
name|buffer_list
index|[
literal|3
index|]
decl_stmt|;
name|packet_len
operator|=
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
operator|+
name|buffer_len
expr_stmt|;
name|packet_len_aligned
operator|=
name|HV_ALIGN_UP
argument_list|(
name|packet_len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|aligned_data
operator|=
literal|0
expr_stmt|;
comment|/* Setup the descriptor */
name|desc
operator|.
name|type
operator|=
name|type
expr_stmt|;
comment|/* HV_VMBUS_PACKET_TYPE_DATA_IN_BAND;             */
name|desc
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
comment|/* HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED */
comment|/* in 8-bytes granularity */
name|desc
operator|.
name|data_offset8
operator|=
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
operator|>>
literal|3
expr_stmt|;
name|desc
operator|.
name|length8
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|packet_len_aligned
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|desc
operator|.
name|transaction_id
operator|=
name|request_id
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|data
operator|=
operator|&
name|desc
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|length
operator|=
name|buffer_len
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|data
operator|=
operator|&
name|aligned_data
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|length
operator|=
name|packet_len_aligned
operator|-
name|packet_len
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_write
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|,
name|buffer_list
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* TODO: We should determine if this is optional */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|hv_vmbus_get_ring_buffer_interrupt_mask
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|)
condition|)
block|{
name|vmbus_channel_set_event
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Send a range of single-page buffer packets using  * a GPADL Direct packet type  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_send_packet_pagebuffer
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|hv_vmbus_page_buffer
name|page_buffers
index|[]
parameter_list|,
name|uint32_t
name|page_count
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint64_t
name|request_id
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|packet_len
decl_stmt|;
name|uint32_t
name|packetLen_aligned
decl_stmt|;
name|hv_vmbus_sg_buffer_list
name|buffer_list
index|[
literal|3
index|]
decl_stmt|;
name|hv_vmbus_channel_packet_page_buffer
name|desc
decl_stmt|;
name|uint32_t
name|descSize
decl_stmt|;
name|uint64_t
name|alignedData
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|page_count
operator|>
name|HV_MAX_PAGE_BUFFER_COUNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Adjust the size down since hv_vmbus_channel_packet_page_buffer 	 *  is the largest size we support 	 */
name|descSize
operator|=
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_packet_page_buffer
argument_list|)
operator|-
operator|(
operator|(
name|HV_MAX_PAGE_BUFFER_COUNT
operator|-
name|page_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hv_vmbus_page_buffer
argument_list|)
operator|)
expr_stmt|;
name|packet_len
operator|=
name|descSize
operator|+
name|buffer_len
expr_stmt|;
name|packetLen_aligned
operator|=
name|HV_ALIGN_UP
argument_list|(
name|packet_len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the descriptor */
name|desc
operator|.
name|type
operator|=
name|HV_VMBUS_PACKET_TYPE_DATA_USING_GPA_DIRECT
expr_stmt|;
name|desc
operator|.
name|flags
operator|=
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
expr_stmt|;
name|desc
operator|.
name|data_offset8
operator|=
name|descSize
operator|>>
literal|3
expr_stmt|;
comment|/* in 8-bytes granularity */
name|desc
operator|.
name|length8
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|packetLen_aligned
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|desc
operator|.
name|transaction_id
operator|=
name|request_id
expr_stmt|;
name|desc
operator|.
name|range_count
operator|=
name|page_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_count
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|.
name|range
index|[
name|i
index|]
operator|.
name|length
operator|=
name|page_buffers
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|desc
operator|.
name|range
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|page_buffers
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
name|desc
operator|.
name|range
index|[
name|i
index|]
operator|.
name|pfn
operator|=
name|page_buffers
index|[
name|i
index|]
operator|.
name|pfn
expr_stmt|;
block|}
name|buffer_list
index|[
literal|0
index|]
operator|.
name|data
operator|=
operator|&
name|desc
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|descSize
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|length
operator|=
name|buffer_len
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|data
operator|=
operator|&
name|alignedData
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|length
operator|=
name|packetLen_aligned
operator|-
name|packet_len
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_write
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|,
name|buffer_list
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* TODO: We should determine if this is optional */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|hv_vmbus_get_ring_buffer_interrupt_mask
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|)
condition|)
block|{
name|vmbus_channel_set_event
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Send a multi-page buffer packet using a GPADL Direct packet type  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_send_packet_multipagebuffer
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|hv_vmbus_multipage_buffer
modifier|*
name|multi_page_buffer
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint64_t
name|request_id
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|uint32_t
name|desc_size
decl_stmt|;
name|uint32_t
name|packet_len
decl_stmt|;
name|uint32_t
name|packet_len_aligned
decl_stmt|;
name|uint32_t
name|pfn_count
decl_stmt|;
name|uint64_t
name|aligned_data
init|=
literal|0
decl_stmt|;
name|hv_vmbus_sg_buffer_list
name|buffer_list
index|[
literal|3
index|]
decl_stmt|;
name|hv_vmbus_channel_packet_multipage_buffer
name|desc
decl_stmt|;
name|pfn_count
operator|=
name|HV_NUM_PAGES_SPANNED
argument_list|(
name|multi_page_buffer
operator|->
name|offset
argument_list|,
name|multi_page_buffer
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pfn_count
operator|==
literal|0
operator|)
operator|||
operator|(
name|pfn_count
operator|>
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Adjust the size down since hv_vmbus_channel_packet_multipage_buffer 	 * is the largest size we support 	 */
name|desc_size
operator|=
sizeof|sizeof
argument_list|(
name|hv_vmbus_channel_packet_multipage_buffer
argument_list|)
operator|-
operator|(
operator|(
name|HV_MAX_MULTIPAGE_BUFFER_COUNT
operator|-
name|pfn_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
name|packet_len
operator|=
name|desc_size
operator|+
name|buffer_len
expr_stmt|;
name|packet_len_aligned
operator|=
name|HV_ALIGN_UP
argument_list|(
name|packet_len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the descriptor 	 */
name|desc
operator|.
name|type
operator|=
name|HV_VMBUS_PACKET_TYPE_DATA_USING_GPA_DIRECT
expr_stmt|;
name|desc
operator|.
name|flags
operator|=
name|HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
expr_stmt|;
name|desc
operator|.
name|data_offset8
operator|=
name|desc_size
operator|>>
literal|3
expr_stmt|;
comment|/* in 8-bytes granularity */
name|desc
operator|.
name|length8
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|packet_len_aligned
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|desc
operator|.
name|transaction_id
operator|=
name|request_id
expr_stmt|;
name|desc
operator|.
name|range_count
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|range
operator|.
name|length
operator|=
name|multi_page_buffer
operator|->
name|length
expr_stmt|;
name|desc
operator|.
name|range
operator|.
name|offset
operator|=
name|multi_page_buffer
operator|->
name|offset
expr_stmt|;
name|memcpy
argument_list|(
name|desc
operator|.
name|range
operator|.
name|pfn_array
argument_list|,
name|multi_page_buffer
operator|->
name|pfn_array
argument_list|,
name|pfn_count
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|data
operator|=
operator|&
name|desc
expr_stmt|;
name|buffer_list
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|desc_size
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|buffer_list
index|[
literal|1
index|]
operator|.
name|length
operator|=
name|buffer_len
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|data
operator|=
operator|&
name|aligned_data
expr_stmt|;
name|buffer_list
index|[
literal|2
index|]
operator|.
name|length
operator|=
name|packet_len_aligned
operator|-
name|packet_len
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_write
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|,
name|buffer_list
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* TODO: We should determine if this is optional */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|hv_vmbus_get_ring_buffer_interrupt_mask
argument_list|(
operator|&
name|channel
operator|->
name|outbound
argument_list|)
condition|)
block|{
name|vmbus_channel_set_event
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve the user packet on the specified channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_recv_packet
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|Buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint32_t
modifier|*
name|buffer_actual_len
parameter_list|,
name|uint64_t
modifier|*
name|request_id
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint32_t
name|user_len
decl_stmt|;
name|uint32_t
name|packet_len
decl_stmt|;
name|hv_vm_packet_descriptor
name|desc
decl_stmt|;
operator|*
name|buffer_actual_len
operator|=
literal|0
expr_stmt|;
operator|*
name|request_id
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_peek
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|packet_len
operator|=
name|desc
operator|.
name|length8
operator|<<
literal|3
expr_stmt|;
name|user_len
operator|=
name|packet_len
operator|-
operator|(
name|desc
operator|.
name|data_offset8
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|buffer_actual_len
operator|=
name|user_len
expr_stmt|;
if|if
condition|(
name|user_len
operator|>
name|buffer_len
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|request_id
operator|=
name|desc
operator|.
name|transaction_id
expr_stmt|;
comment|/* Copy over the packet to the user buffer */
name|ret
operator|=
name|hv_ring_buffer_read
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|,
name|Buffer
argument_list|,
name|user_len
argument_list|,
operator|(
name|desc
operator|.
name|data_offset8
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve the raw packet on the specified channel  */
end_comment

begin_function
name|int
name|hv_vmbus_channel_recv_packet_raw
parameter_list|(
name|hv_vmbus_channel
modifier|*
name|channel
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buffer_len
parameter_list|,
name|uint32_t
modifier|*
name|buffer_actual_len
parameter_list|,
name|uint64_t
modifier|*
name|request_id
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint32_t
name|packetLen
decl_stmt|;
name|uint32_t
name|userLen
decl_stmt|;
name|hv_vm_packet_descriptor
name|desc
decl_stmt|;
operator|*
name|buffer_actual_len
operator|=
literal|0
expr_stmt|;
operator|*
name|request_id
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hv_ring_buffer_peek
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_vm_packet_descriptor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|packetLen
operator|=
name|desc
operator|.
name|length8
operator|<<
literal|3
expr_stmt|;
name|userLen
operator|=
name|packetLen
operator|-
operator|(
name|desc
operator|.
name|data_offset8
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|buffer_actual_len
operator|=
name|packetLen
expr_stmt|;
if|if
condition|(
name|packetLen
operator|>
name|buffer_len
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
operator|*
name|request_id
operator|=
name|desc
operator|.
name|transaction_id
expr_stmt|;
comment|/* Copy over the entire packet to the user buffer */
name|ret
operator|=
name|hv_ring_buffer_read
argument_list|(
operator|&
name|channel
operator|->
name|inbound
argument_list|,
name|buffer
argument_list|,
name|packetLen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

