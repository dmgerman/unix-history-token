begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Microsoft Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/include/hyperv.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/utilities/hv_utilreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hyperv/utilities/vmbus_icreg.h>
end_include

begin_include
include|#
directive|include
file|"hv_util.h"
end_include

begin_include
include|#
directive|include
file|"hv_snapshot.h"
end_include

begin_include
include|#
directive|include
file|"vmbus_if.h"
end_include

begin_define
define|#
directive|define
name|VSS_MAJOR
value|5
end_define

begin_define
define|#
directive|define
name|VSS_MINOR
value|0
end_define

begin_define
define|#
directive|define
name|VSS_MSGVER
value|VMBUS_IC_VERSION(VSS_MAJOR, VSS_MINOR)
end_define

begin_define
define|#
directive|define
name|VSS_FWVER_MAJOR
value|3
end_define

begin_define
define|#
directive|define
name|VSS_FWVER
value|VMBUS_IC_VERSION(VSS_FWVER_MAJOR, 0)
end_define

begin_define
define|#
directive|define
name|TIMEOUT_LIMIT
value|(15)
end_define

begin_comment
comment|// seconds
end_comment

begin_enum
enum|enum
name|hv_vss_op
block|{
name|VSS_OP_CREATE
init|=
literal|0
block|,
name|VSS_OP_DELETE
block|,
name|VSS_OP_HOT_BACKUP
block|,
name|VSS_OP_GET_DM_INFO
block|,
name|VSS_OP_BU_COMPLETE
block|,
comment|/* 	 * Following operations are only supported with IC version>= 5.0 	 */
name|VSS_OP_FREEZE
block|,
comment|/* Freeze the file systems in the VM */
name|VSS_OP_THAW
block|,
comment|/* Unfreeze the file systems */
name|VSS_OP_AUTO_RECOVER
block|,
name|VSS_OP_COUNT
comment|/* Number of operations, must be last */
block|}
enum|;
end_enum

begin_comment
comment|/*  * Header for all VSS messages.  */
end_comment

begin_struct
struct|struct
name|hv_vss_hdr
block|{
name|struct
name|vmbus_icmsg_hdr
name|ic_hdr
decl_stmt|;
name|uint8_t
name|operation
decl_stmt|;
name|uint8_t
name|reserved
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_comment
comment|/*  * Flag values for the hv_vss_check_feature. Here supports only  * one value.  */
end_comment

begin_define
define|#
directive|define
name|VSS_HBU_NO_AUTO_RECOVERY
value|0x00000005
end_define

begin_struct
struct|struct
name|hv_vss_check_feature
block|{
name|uint32_t
name|flags
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|hv_vss_check_dm_info
block|{
name|uint32_t
name|flags
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|hv_vss_msg
block|{
union|union
block|{
name|struct
name|hv_vss_hdr
name|vss_hdr
decl_stmt|;
block|}
name|hdr
union|;
union|union
block|{
name|struct
name|hv_vss_check_feature
name|vss_cf
decl_stmt|;
name|struct
name|hv_vss_check_dm_info
name|dm_info
decl_stmt|;
block|}
name|body
union|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|hv_vss_req
block|{
name|struct
name|hv_vss_opt_msg
name|opt_msg
decl_stmt|;
comment|/* used to communicate with daemon */
name|struct
name|hv_vss_msg
name|msg
decl_stmt|;
comment|/* used to communicate with host */
block|}
name|__packed
struct|;
end_struct

begin_comment
comment|/* hv_vss debug control */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hv_vss_log
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hv_vss_log_error
parameter_list|(
modifier|...
parameter_list|)
value|do {				\ 	if (hv_vss_log> 0)					\ 		log(LOG_ERR, "hv_vss: " __VA_ARGS__);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|hv_vss_log_info
parameter_list|(
modifier|...
parameter_list|)
value|do {				\ 	if (hv_vss_log> 1)					\ 		log(LOG_INFO, "hv_vss: " __VA_ARGS__);		\ } while (0)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vmbus_ic_desc
name|vmbus_vss_descs
index|[]
init|=
block|{
block|{
operator|.
name|ic_guid
operator|=
block|{
operator|.
name|hv_guid
operator|=
block|{
literal|0x29
block|,
literal|0x2e
block|,
literal|0xfa
block|,
literal|0x35
block|,
literal|0x23
block|,
literal|0xea
block|,
literal|0x36
block|,
literal|0x42
block|,
literal|0x96
block|,
literal|0xae
block|,
literal|0x3a
block|,
literal|0x6e
block|,
literal|0xba
block|,
literal|0xcb
block|,
literal|0xa4
block|,
literal|0x40
block|}
block|}
block|,
operator|.
name|ic_desc
operator|=
literal|"Hyper-V VSS"
block|}
block|,
name|VMBUS_IC_DESC_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|vss_opt_name
index|[]
init|=
block|{
literal|"None"
block|,
literal|"VSSCheck"
block|,
literal|"Freeze"
block|,
literal|"Thaw"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character device prototypes */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|hv_vss_dev_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|hv_vss_dev_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|hv_vss_dev_daemon_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|hv_vss_dev_daemon_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|hv_appvss_dev_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|hv_appvss_dev_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|hv_appvss_dev_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|hv_appvss_dev_ioctl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hv_vss character device structure */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|hv_vss_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|hv_vss_dev_open
block|,
operator|.
name|d_close
operator|=
name|hv_vss_dev_close
block|,
operator|.
name|d_poll
operator|=
name|hv_vss_dev_daemon_poll
block|,
operator|.
name|d_ioctl
operator|=
name|hv_vss_dev_daemon_ioctl
block|,
operator|.
name|d_name
operator|=
name|FS_VSS_DEV_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|hv_appvss_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|hv_appvss_dev_open
block|,
operator|.
name|d_close
operator|=
name|hv_appvss_dev_close
block|,
operator|.
name|d_poll
operator|=
name|hv_appvss_dev_poll
block|,
operator|.
name|d_ioctl
operator|=
name|hv_appvss_dev_ioctl
block|,
operator|.
name|d_name
operator|=
name|APP_VSS_DEV_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|hv_vss_sc
struct_decl|;
end_struct_decl

begin_comment
comment|/*  * Global state to track cdev  */
end_comment

begin_struct
struct|struct
name|hv_vss_dev_sc
block|{
comment|/* 	 * msg was transferred from host to notify queue, and 	 * ack queue. Finally, it was recyled to free list. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|hv_vss_req_internal
argument_list|)
name|to_notify_queue
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|hv_vss_req_internal
argument_list|)
name|to_ack_queue
expr_stmt|;
name|struct
name|hv_vss_sc
modifier|*
name|sc
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc_task
decl_stmt|;
name|struct
name|selinfo
name|hv_vss_selinfo
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Global state to track and synchronize the transaction requests from the host.  * The VSS allows user to register their function to do freeze/thaw for application.  * VSS kernel will notify both vss daemon and user application if it is registered.  * The implementation state transition is illustrated by:  * https://clovertrail.github.io/assets/vssdot.png  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|hv_vss_sc
block|{
name|struct
name|vmbus_ic_softc
name|util_sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|task
name|task
decl_stmt|;
comment|/* 	 * mutex is used to protect access of list/queue, 	 * callout in request is also used this mutex. 	 */
name|struct
name|mtx
name|pending_mutex
decl_stmt|;
comment|/* 	 * req_free_list contains all free items 	 */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|hv_vss_req_internal
argument_list|)
name|req_free_list
expr_stmt|;
comment|/* Indicates if daemon registered with driver */
name|boolean_t
name|register_done
decl_stmt|;
name|boolean_t
name|app_register_done
decl_stmt|;
comment|/* cdev for file system freeze/thaw */
name|struct
name|cdev
modifier|*
name|hv_vss_dev
decl_stmt|;
comment|/* cdev for application freeze/thaw */
name|struct
name|cdev
modifier|*
name|hv_appvss_dev
decl_stmt|;
comment|/* sc for app */
name|struct
name|hv_vss_dev_sc
name|app_sc
decl_stmt|;
comment|/* sc for deamon */
name|struct
name|hv_vss_dev_sc
name|daemon_sc
decl_stmt|;
block|}
name|hv_vss_sc
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|hv_vss_req_internal
block|{
name|LIST_ENTRY
argument_list|(
argument|hv_vss_req_internal
argument_list|)
name|link
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|hv_vss_req_internal
argument_list|)
name|slink
expr_stmt|;
name|struct
name|hv_vss_req
name|vss_req
decl_stmt|;
comment|/* Rcv buffer for communicating with the host*/
name|uint8_t
modifier|*
name|rcv_buf
decl_stmt|;
comment|/* Length of host message */
name|uint32_t
name|host_msg_len
decl_stmt|;
comment|/* Host message id */
name|uint64_t
name|host_msg_id
decl_stmt|;
name|hv_vss_sc
modifier|*
name|sc
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
block|}
name|hv_vss_req_internal
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SEARCH_REMOVE_REQ_LOCKED
parameter_list|(
name|reqp
parameter_list|,
name|queue
parameter_list|,
name|link
parameter_list|,
name|tmp
parameter_list|,
name|id
parameter_list|)
define|\
value|do {								\ 		STAILQ_FOREACH_SAFE(reqp, queue, link, tmp) {		\ 			if (reqp->vss_req.opt_msg.msgid == id) {	\ 				STAILQ_REMOVE(queue,			\ 				    reqp, hv_vss_req_internal, link);	\ 				break;					\ 			}						\ 		}							\ 	} while (0)
end_define

begin_function
specifier|static
name|bool
name|hv_vss_is_daemon_killed_after_launch
parameter_list|(
name|hv_vss_sc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
operator|!
name|sc
operator|->
name|register_done
operator|&&
name|sc
operator|->
name|daemon_sc
operator|.
name|proc_task
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback routine that gets called whenever there is a message from host  */
end_comment

begin_function
specifier|static
name|void
name|hv_vss_callback
parameter_list|(
name|struct
name|vmbus_channel
modifier|*
name|chan
name|__unused
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|hv_vss_sc
modifier|*
name|sc
init|=
operator|(
name|hv_vss_sc
operator|*
operator|)
name|context
decl_stmt|;
if|if
condition|(
name|hv_vss_is_daemon_killed_after_launch
argument_list|(
name|sc
argument_list|)
condition|)
name|hv_vss_log_info
argument_list|(
literal|"%s: daemon was killed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|register_done
operator|||
name|sc
operator|->
name|daemon_sc
operator|.
name|proc_task
condition|)
block|{
name|hv_vss_log_info
argument_list|(
literal|"%s: Queuing work item\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|hv_vss_is_daemon_killed_after_launch
argument_list|(
name|sc
argument_list|)
condition|)
name|hv_vss_log_info
argument_list|(
literal|"%s: daemon was killed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hv_vss_log_info
argument_list|(
literal|"%s: daemon has never been registered\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|hv_vss_log_info
argument_list|(
literal|"%s: received msg from host\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the response back to the host.  */
end_comment

begin_function
specifier|static
name|void
name|hv_vss_respond_host
parameter_list|(
name|uint8_t
modifier|*
name|rcv_buf
parameter_list|,
name|struct
name|vmbus_channel
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|recvlen
parameter_list|,
name|uint64_t
name|requestid
parameter_list|,
name|uint32_t
name|error
parameter_list|)
block|{
name|struct
name|vmbus_icmsg_hdr
modifier|*
name|hv_icmsg_hdrp
decl_stmt|;
name|hv_icmsg_hdrp
operator|=
operator|(
expr|struct
name|vmbus_icmsg_hdr
operator|*
operator|)
name|rcv_buf
expr_stmt|;
name|hv_icmsg_hdrp
operator|->
name|ic_status
operator|=
name|error
expr_stmt|;
name|hv_icmsg_hdrp
operator|->
name|ic_flags
operator|=
name|HV_ICMSGHDRFLAG_TRANSACTION
operator||
name|HV_ICMSGHDRFLAG_RESPONSE
expr_stmt|;
name|error
operator|=
name|vmbus_chan_send
argument_list|(
name|ch
argument_list|,
name|VMBUS_CHANPKT_TYPE_INBAND
argument_list|,
literal|0
argument_list|,
name|rcv_buf
argument_list|,
name|recvlen
argument_list|,
name|requestid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|hv_vss_log_info
argument_list|(
literal|"%s: hv_vss_respond_host: sendpacket error:%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_vss_notify_host_result_locked
parameter_list|(
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|struct
name|hv_vss_msg
modifier|*
name|msg
init|=
operator|(
expr|struct
name|hv_vss_msg
operator|*
operator|)
name|reqp
operator|->
name|rcv_buf
decl_stmt|;
name|hv_vss_sc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
operator|==
name|HV_VSS_CHECK
condition|)
block|{
name|msg
operator|->
name|body
operator|.
name|vss_cf
operator|.
name|flags
operator|=
name|VSS_HBU_NO_AUTO_RECOVERY
expr_stmt|;
block|}
name|hv_vss_log_info
argument_list|(
literal|"%s, %s response %s to host\n"
argument_list|,
name|__func__
argument_list|,
name|vss_opt_name
index|[
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
index|]
argument_list|,
name|status
operator|==
name|HV_S_OK
condition|?
literal|"Success"
else|:
literal|"Fail"
argument_list|)
expr_stmt|;
name|hv_vss_respond_host
argument_list|(
name|reqp
operator|->
name|rcv_buf
argument_list|,
name|vmbus_get_channel
argument_list|(
name|reqp
operator|->
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|reqp
operator|->
name|host_msg_len
argument_list|,
name|reqp
operator|->
name|host_msg_id
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* recycle the request */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|req_free_list
argument_list|,
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_vss_notify_host_result
parameter_list|(
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|reqp
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
name|hv_vss_notify_host_result_locked
argument_list|(
name|reqp
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|reqp
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_vss_cp_vssreq_to_user
parameter_list|(
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
parameter_list|,
name|struct
name|hv_vss_opt_msg
modifier|*
name|userdata
parameter_list|)
block|{
name|struct
name|hv_vss_req
modifier|*
name|hv_vss_dev_buf
decl_stmt|;
name|hv_vss_dev_buf
operator|=
operator|&
name|reqp
operator|->
name|vss_req
expr_stmt|;
name|hv_vss_dev_buf
operator|->
name|opt_msg
operator|.
name|opt
operator|=
name|HV_VSS_NONE
expr_stmt|;
switch|switch
condition|(
name|reqp
operator|->
name|vss_req
operator|.
name|msg
operator|.
name|hdr
operator|.
name|vss_hdr
operator|.
name|operation
condition|)
block|{
case|case
name|VSS_OP_FREEZE
case|:
name|hv_vss_dev_buf
operator|->
name|opt_msg
operator|.
name|opt
operator|=
name|HV_VSS_FREEZE
expr_stmt|;
break|break;
case|case
name|VSS_OP_THAW
case|:
name|hv_vss_dev_buf
operator|->
name|opt_msg
operator|.
name|opt
operator|=
name|HV_VSS_THAW
expr_stmt|;
break|break;
case|case
name|VSS_OP_HOT_BACKUP
case|:
name|hv_vss_dev_buf
operator|->
name|opt_msg
operator|.
name|opt
operator|=
name|HV_VSS_CHECK
expr_stmt|;
break|break;
block|}
operator|*
name|userdata
operator|=
name|hv_vss_dev_buf
operator|->
name|opt_msg
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s, read data from user for "
literal|"%s (%ju) \n"
argument_list|,
name|__func__
argument_list|,
name|vss_opt_name
index|[
name|userdata
operator|->
name|opt
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|userdata
operator|->
name|msgid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Remove the request id from app notifiy or ack queue,  * and recyle the request by inserting it to free list.  *  * When app was notified but not yet sending ack, the request  * should locate in either notify queue or ack queue.  */
end_comment

begin_function
specifier|static
name|struct
name|hv_vss_req_internal
modifier|*
name|hv_vss_drain_req_queue_locked
parameter_list|(
name|hv_vss_sc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|req_id
parameter_list|)
block|{
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|SEARCH_REMOVE_REQ_LOCKED
argument_list|(
name|reqp
argument_list|,
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_notify_queue
argument_list|,
name|slink
argument_list|,
name|tmp
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|==
name|NULL
condition|)
name|SEARCH_REMOVE_REQ_LOCKED
argument_list|(
name|reqp
argument_list|,
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_ack_queue
argument_list|,
name|slink
argument_list|,
name|tmp
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|==
name|NULL
condition|)
name|SEARCH_REMOVE_REQ_LOCKED
argument_list|(
name|reqp
argument_list|,
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_notify_queue
argument_list|,
name|slink
argument_list|,
name|tmp
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|==
name|NULL
condition|)
name|SEARCH_REMOVE_REQ_LOCKED
argument_list|(
name|reqp
argument_list|,
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_ack_queue
argument_list|,
name|slink
argument_list|,
name|tmp
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|reqp
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Actions for daemon who has been notified.  */
end_comment

begin_function
specifier|static
name|void
name|hv_vss_notified
parameter_list|(
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
parameter_list|,
name|struct
name|hv_vss_opt_msg
modifier|*
name|userdata
parameter_list|)
block|{
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|dev_sc
operator|->
name|to_notify_queue
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev_sc
operator|->
name|to_notify_queue
argument_list|)
expr_stmt|;
name|hv_vss_cp_vssreq_to_user
argument_list|(
name|reqp
argument_list|,
name|userdata
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|dev_sc
operator|->
name|to_notify_queue
argument_list|,
name|slink
argument_list|)
expr_stmt|;
comment|/* insert the msg to queue for write */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev_sc
operator|->
name|to_ack_queue
argument_list|,
name|reqp
argument_list|,
name|slink
argument_list|)
expr_stmt|;
name|userdata
operator|->
name|status
operator|=
name|VSS_SUCCESS
expr_stmt|;
block|}
else|else
block|{
comment|/* Timeout occur, thus request was removed from queue. */
name|hv_vss_log_info
argument_list|(
literal|"%s: notify queue is empty!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|userdata
operator|->
name|status
operator|=
name|VSS_FAIL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_vss_notify
parameter_list|(
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
parameter_list|,
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
parameter_list|)
block|{
name|uint32_t
name|opt
init|=
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev_sc
operator|->
name|to_notify_queue
argument_list|,
name|reqp
argument_list|,
name|slink
argument_list|)
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: issuing query %s (%ju) to %s\n"
argument_list|,
name|__func__
argument_list|,
name|vss_opt_name
index|[
name|opt
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|msgid
argument_list|,
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|app_sc
operator|==
name|dev_sc
condition|?
literal|"app"
else|:
literal|"daemon"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|dev_sc
operator|->
name|hv_vss_selinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Actions for daemon who has acknowledged.  */
end_comment

begin_function
specifier|static
name|void
name|hv_vss_daemon_acked
parameter_list|(
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
parameter_list|,
name|struct
name|hv_vss_opt_msg
modifier|*
name|userdata
parameter_list|)
block|{
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|uint64_t
name|req_id
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|opt
operator|=
name|userdata
operator|->
name|opt
expr_stmt|;
name|req_id
operator|=
name|userdata
operator|->
name|msgid
expr_stmt|;
name|status
operator|=
name|userdata
operator|->
name|status
expr_stmt|;
comment|/* make sure the reserved fields are all zeros. */
name|memset
argument_list|(
operator|&
name|userdata
operator|->
name|reserved
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_vss_opt_msg
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|hv_vss_opt_msg
argument_list|,
name|reserved
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
name|SEARCH_REMOVE_REQ_LOCKED
argument_list|(
name|reqp
argument_list|,
operator|&
name|dev_sc
operator|->
name|to_ack_queue
argument_list|,
name|slink
argument_list|,
name|tmp
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|==
name|NULL
condition|)
block|{
name|hv_vss_log_info
argument_list|(
literal|"%s Timeout: fail to find daemon ack request\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|userdata
operator|->
name|status
operator|=
name|VSS_FAIL
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|opt
operator|==
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
argument_list|,
operator|(
literal|"Mismatched VSS operation!"
operator|)
argument_list|)
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s, get response %d from daemon for %s (%ju) \n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|,
name|vss_opt_name
index|[
name|opt
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|req_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|HV_VSS_CHECK
case|:
case|case
name|HV_VSS_FREEZE
case|:
name|callout_drain
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|hv_vss_notify_host_result
argument_list|(
name|reqp
argument_list|,
name|status
operator|==
name|VSS_SUCCESS
condition|?
name|HV_S_OK
else|:
name|HV_E_FAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|HV_VSS_THAW
case|:
if|if
condition|(
name|dev_sc
operator|->
name|sc
operator|->
name|app_register_done
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|VSS_SUCCESS
condition|)
block|{
name|hv_vss_notify
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|app_sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* handle error */
name|callout_drain
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|hv_vss_notify_host_result
argument_list|(
name|reqp
argument_list|,
name|HV_E_FAIL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|callout_drain
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|hv_vss_notify_host_result
argument_list|(
name|reqp
argument_list|,
name|status
operator|==
name|VSS_SUCCESS
condition|?
name|HV_S_OK
else|:
name|HV_E_FAIL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * Actions for app who has acknowledged.  */
end_comment

begin_function
specifier|static
name|void
name|hv_vss_app_acked
parameter_list|(
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
parameter_list|,
name|struct
name|hv_vss_opt_msg
modifier|*
name|userdata
parameter_list|)
block|{
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|uint64_t
name|req_id
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|opt
operator|=
name|userdata
operator|->
name|opt
expr_stmt|;
name|req_id
operator|=
name|userdata
operator|->
name|msgid
expr_stmt|;
name|status
operator|=
name|userdata
operator|->
name|status
expr_stmt|;
comment|/* make sure the reserved fields are all zeros. */
name|memset
argument_list|(
operator|&
name|userdata
operator|->
name|reserved
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_vss_opt_msg
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|hv_vss_opt_msg
argument_list|,
name|reserved
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
name|SEARCH_REMOVE_REQ_LOCKED
argument_list|(
name|reqp
argument_list|,
operator|&
name|dev_sc
operator|->
name|to_ack_queue
argument_list|,
name|slink
argument_list|,
name|tmp
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|==
name|NULL
condition|)
block|{
name|hv_vss_log_info
argument_list|(
literal|"%s Timeout: fail to find app ack request\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|userdata
operator|->
name|status
operator|=
name|VSS_FAIL
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|opt
operator|==
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
argument_list|,
operator|(
literal|"Mismatched VSS operation!"
operator|)
argument_list|)
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s, get response %d from app for %s (%ju) \n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|,
name|vss_opt_name
index|[
name|opt
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|req_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_sc
operator|->
name|sc
operator|->
name|register_done
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|HV_VSS_CHECK
case|:
case|case
name|HV_VSS_FREEZE
case|:
if|if
condition|(
name|status
operator|==
name|VSS_SUCCESS
condition|)
block|{
name|hv_vss_notify
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|daemon_sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* handle error */
name|callout_drain
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|hv_vss_notify_host_result
argument_list|(
name|reqp
argument_list|,
name|HV_E_FAIL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HV_VSS_THAW
case|:
name|callout_drain
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|hv_vss_notify_host_result
argument_list|(
name|reqp
argument_list|,
name|status
operator|==
name|VSS_SUCCESS
condition|?
name|HV_S_OK
else|:
name|HV_E_FAIL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|hv_vss_log_info
argument_list|(
literal|"%s, Fatal: vss daemon was killed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hv_vss_dev_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|td_proc
decl_stmt|;
name|td_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
init|=
operator|(
expr|struct
name|hv_vss_dev_sc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: %s opens device \"%s\" successfully.\n"
argument_list|,
name|__func__
argument_list|,
name|td_proc
operator|->
name|p_comm
argument_list|,
name|FS_VSS_DEV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_sc
operator|->
name|sc
operator|->
name|register_done
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|dev_sc
operator|->
name|sc
operator|->
name|register_done
operator|=
name|true
expr_stmt|;
name|hv_vss_callback
argument_list|(
name|vmbus_get_channel
argument_list|(
name|dev_sc
operator|->
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|dev_sc
operator|->
name|sc
argument_list|)
expr_stmt|;
name|dev_sc
operator|->
name|proc_task
operator|=
name|curproc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_vss_dev_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
name|__unused
parameter_list|,
name|int
name|devtype
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|td_proc
decl_stmt|;
name|td_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
init|=
operator|(
expr|struct
name|hv_vss_dev_sc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: %s closes device \"%s\"\n"
argument_list|,
name|__func__
argument_list|,
name|td_proc
operator|->
name|p_comm
argument_list|,
name|FS_VSS_DEV_NAME
argument_list|)
expr_stmt|;
name|dev_sc
operator|->
name|sc
operator|->
name|register_done
operator|=
name|false
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_vss_dev_daemon_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|td_proc
decl_stmt|;
name|struct
name|hv_vss_dev_sc
modifier|*
name|sc
decl_stmt|;
name|td_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hv_vss_dev_sc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: %s invoked vss ioctl\n"
argument_list|,
name|__func__
argument_list|,
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|struct
name|hv_vss_opt_msg
modifier|*
name|userdata
init|=
operator|(
expr|struct
name|hv_vss_opt_msg
operator|*
operator|)
name|data
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IOCHVVSSREAD
case|:
name|hv_vss_notified
argument_list|(
name|sc
argument_list|,
name|userdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCHVVSSWRITE
case|:
name|hv_vss_daemon_acked
argument_list|(
name|sc
argument_list|,
name|userdata
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * hv_vss_daemon poll invokes this function to check if data is available  * for daemon to read.  */
end_comment

begin_function
specifier|static
name|int
name|hv_vss_dev_daemon_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|revent
init|=
literal|0
decl_stmt|;
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
init|=
operator|(
expr|struct
name|hv_vss_dev_sc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
comment|/** 	 * if there is data ready, inform daemon's poll 	 */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|dev_sc
operator|->
name|to_notify_queue
argument_list|)
condition|)
name|revent
operator|=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|revent
operator|==
literal|0
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|dev_sc
operator|->
name|hv_vss_selinfo
argument_list|)
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s return 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|revent
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|revent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_appvss_dev_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|td_proc
decl_stmt|;
name|td_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
init|=
operator|(
expr|struct
name|hv_vss_dev_sc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: %s opens device \"%s\" successfully.\n"
argument_list|,
name|__func__
argument_list|,
name|td_proc
operator|->
name|p_comm
argument_list|,
name|APP_VSS_DEV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_sc
operator|->
name|sc
operator|->
name|app_register_done
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|dev_sc
operator|->
name|sc
operator|->
name|app_register_done
operator|=
name|true
expr_stmt|;
name|dev_sc
operator|->
name|proc_task
operator|=
name|curproc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_appvss_dev_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
name|__unused
parameter_list|,
name|int
name|devtype
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|td_proc
decl_stmt|;
name|td_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
init|=
operator|(
expr|struct
name|hv_vss_dev_sc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: %s closes device \"%s\".\n"
argument_list|,
name|__func__
argument_list|,
name|td_proc
operator|->
name|p_comm
argument_list|,
name|APP_VSS_DEV_NAME
argument_list|)
expr_stmt|;
name|dev_sc
operator|->
name|sc
operator|->
name|app_register_done
operator|=
name|false
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_appvss_dev_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|td_proc
decl_stmt|;
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
decl_stmt|;
name|td_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|dev_sc
operator|=
operator|(
expr|struct
name|hv_vss_dev_sc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: %s invoked vss ioctl\n"
argument_list|,
name|__func__
argument_list|,
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|struct
name|hv_vss_opt_msg
modifier|*
name|userdata
init|=
operator|(
expr|struct
name|hv_vss_opt_msg
operator|*
operator|)
name|data
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IOCHVVSSREAD
case|:
name|hv_vss_notified
argument_list|(
name|dev_sc
argument_list|,
name|userdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCHVVSSWRITE
case|:
name|hv_vss_app_acked
argument_list|(
name|dev_sc
argument_list|,
name|userdata
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * hv_vss_daemon poll invokes this function to check if data is available  * for daemon to read.  */
end_comment

begin_function
specifier|static
name|int
name|hv_appvss_dev_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|revent
init|=
literal|0
decl_stmt|;
name|struct
name|hv_vss_dev_sc
modifier|*
name|dev_sc
init|=
operator|(
expr|struct
name|hv_vss_dev_sc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
comment|/** 	 * if there is data ready, inform daemon's poll 	 */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|dev_sc
operator|->
name|to_notify_queue
argument_list|)
condition|)
name|revent
operator|=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|revent
operator|==
literal|0
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|dev_sc
operator|->
name|hv_vss_selinfo
argument_list|)
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s return 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|revent
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dev_sc
operator|->
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|revent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_vss_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|hv_vss_req_internal
modifier|*
name|reqp
init|=
name|arg
decl_stmt|;
name|hv_vss_req_internal
modifier|*
name|request
decl_stmt|;
name|hv_vss_sc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|sc
decl_stmt|;
name|uint64_t
name|req_id
init|=
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|msgid
decl_stmt|;
comment|/* This thread is locked */
name|KASSERT
argument_list|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|pending_mutex
argument_list|)
argument_list|,
operator|(
literal|"mutex lock is not owned!"
operator|)
argument_list|)
expr_stmt|;
name|request
operator|=
name|hv_vss_drain_req_queue_locked
argument_list|(
name|sc
argument_list|,
name|req_id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|request
operator|!=
name|NULL
argument_list|,
operator|(
literal|"timeout but fail to find request"
operator|)
argument_list|)
expr_stmt|;
name|hv_vss_notify_host_result_locked
argument_list|(
name|reqp
argument_list|,
name|HV_E_FAIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called whenever a message is received from the host  */
end_comment

begin_function
specifier|static
name|void
name|hv_vss_init_req
parameter_list|(
name|hv_vss_req_internal
modifier|*
name|reqp
parameter_list|,
name|uint32_t
name|recvlen
parameter_list|,
name|uint64_t
name|requestid
parameter_list|,
name|uint8_t
modifier|*
name|vss_buf
parameter_list|,
name|hv_vss_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|timespec
name|vm_ts
decl_stmt|;
name|struct
name|hv_vss_msg
modifier|*
name|msg
init|=
operator|(
expr|struct
name|hv_vss_msg
operator|*
operator|)
name|vss_buf
decl_stmt|;
name|memset
argument_list|(
name|reqp
argument_list|,
literal|0
argument_list|,
name|__offsetof
argument_list|(
name|hv_vss_req_internal
argument_list|,
name|callout
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|host_msg_len
operator|=
name|recvlen
expr_stmt|;
name|reqp
operator|->
name|host_msg_id
operator|=
name|requestid
expr_stmt|;
name|reqp
operator|->
name|rcv_buf
operator|=
name|vss_buf
expr_stmt|;
name|reqp
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|reqp
operator|->
name|vss_req
operator|.
name|msg
argument_list|,
operator|(
expr|struct
name|hv_vss_msg
operator|*
operator|)
name|vss_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hv_vss_msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set the opt for users */
switch|switch
condition|(
name|msg
operator|->
name|hdr
operator|.
name|vss_hdr
operator|.
name|operation
condition|)
block|{
case|case
name|VSS_OP_FREEZE
case|:
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
operator|=
name|HV_VSS_FREEZE
expr_stmt|;
break|break;
case|case
name|VSS_OP_THAW
case|:
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
operator|=
name|HV_VSS_THAW
expr_stmt|;
break|break;
case|case
name|VSS_OP_HOT_BACKUP
case|:
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
operator|=
name|HV_VSS_CHECK
expr_stmt|;
break|break;
block|}
comment|/* Use a timestamp as msg request ID */
name|nanotime
argument_list|(
operator|&
name|vm_ts
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|msgid
operator|=
operator|(
name|vm_ts
operator|.
name|tv_sec
operator|*
name|NANOSEC
operator|)
operator|+
name|vm_ts
operator|.
name|tv_nsec
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|hv_vss_req_internal
modifier|*
name|hv_vss_get_new_req_locked
parameter_list|(
name|hv_vss_sc
modifier|*
name|sc
parameter_list|)
block|{
name|hv_vss_req_internal
modifier|*
name|reqp
decl_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_notify_queue
argument_list|)
operator|||
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_ack_queue
argument_list|)
operator|||
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_notify_queue
argument_list|)
operator|||
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_ack_queue
argument_list|)
condition|)
block|{
comment|/* 		 * There is request coming from host before 		 * finishing previous requests 		 */
name|hv_vss_log_info
argument_list|(
literal|"%s: Warning: there is new request "
literal|"coming before finishing previous requests\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|req_free_list
argument_list|)
condition|)
block|{
comment|/* TODO Error: no buffer */
name|hv_vss_log_info
argument_list|(
literal|"Error: No buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|req_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|reqp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_vss_start_notify
parameter_list|(
name|hv_vss_req_internal
modifier|*
name|reqp
parameter_list|,
name|uint32_t
name|opt
parameter_list|)
block|{
name|hv_vss_sc
modifier|*
name|sc
init|=
name|reqp
operator|->
name|sc
decl_stmt|;
comment|/* 	 * Freeze/Check notification sequence: kernel -> app -> daemon(fs) 	 * Thaw notification sequence:         kernel -> daemon(fs) -> app 	 * 	 * We should wake up the daemon, in case it's doing poll(). 	 * The response should be received after 5s, otherwise, trigger timeout. 	 */
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|VSS_OP_FREEZE
case|:
case|case
name|VSS_OP_HOT_BACKUP
case|:
if|if
condition|(
name|sc
operator|->
name|app_register_done
condition|)
name|hv_vss_notify
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
else|else
name|hv_vss_notify
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
name|TIMEOUT_LIMIT
operator|*
name|hz
argument_list|,
name|hv_vss_timeout
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
break|break;
case|case
name|VSS_OP_THAW
case|:
name|hv_vss_notify
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
name|TIMEOUT_LIMIT
operator|*
name|hz
argument_list|,
name|hv_vss_timeout
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Function to read the vss request buffer from host  * and interact with daemon  */
end_comment

begin_function
specifier|static
name|void
name|hv_vss_process_request
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|uint8_t
modifier|*
name|vss_buf
decl_stmt|;
name|struct
name|vmbus_channel
modifier|*
name|channel
decl_stmt|;
name|uint32_t
name|recvlen
init|=
literal|0
decl_stmt|;
name|uint64_t
name|requestid
decl_stmt|;
name|struct
name|vmbus_icmsg_hdr
modifier|*
name|icmsghdrp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|hv_vss_sc
modifier|*
name|sc
decl_stmt|;
name|hv_vss_req_internal
modifier|*
name|reqp
decl_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: entering hv_vss_process_request\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
name|hv_vss_sc
operator|*
operator|)
name|context
expr_stmt|;
name|vss_buf
operator|=
name|sc
operator|->
name|util_sc
operator|.
name|ic_buf
expr_stmt|;
name|channel
operator|=
name|vmbus_get_channel
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|recvlen
operator|=
name|sc
operator|->
name|util_sc
operator|.
name|ic_buflen
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_recv
argument_list|(
name|channel
argument_list|,
name|vss_buf
argument_list|,
operator|&
name|recvlen
argument_list|,
operator|&
name|requestid
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
operator|!=
name|ENOBUFS
argument_list|,
operator|(
literal|"hvvss recvbuf is not large enough"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX check recvlen to make sure that it contains enough data */
while|while
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|recvlen
operator|>
literal|0
operator|)
condition|)
block|{
name|icmsghdrp
operator|=
operator|(
expr|struct
name|vmbus_icmsg_hdr
operator|*
operator|)
name|vss_buf
expr_stmt|;
if|if
condition|(
name|icmsghdrp
operator|->
name|ic_type
operator|==
name|HV_ICMSGTYPE_NEGOTIATE
condition|)
block|{
name|ret
operator|=
name|vmbus_ic_negomsg
argument_list|(
operator|&
name|sc
operator|->
name|util_sc
argument_list|,
name|vss_buf
argument_list|,
operator|&
name|recvlen
argument_list|,
name|VSS_FWVER
argument_list|,
name|VSS_MSGVER
argument_list|)
expr_stmt|;
name|hv_vss_respond_host
argument_list|(
name|vss_buf
argument_list|,
name|vmbus_get_channel
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|recvlen
argument_list|,
name|requestid
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: version negotiated\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hv_vss_is_daemon_killed_after_launch
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|struct
name|hv_vss_msg
modifier|*
name|msg
init|=
operator|(
expr|struct
name|hv_vss_msg
operator|*
operator|)
name|vss_buf
decl_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|hdr
operator|.
name|vss_hdr
operator|.
name|operation
condition|)
block|{
case|case
name|VSS_OP_FREEZE
case|:
case|case
name|VSS_OP_THAW
case|:
case|case
name|VSS_OP_HOT_BACKUP
case|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
name|reqp
operator|=
name|hv_vss_get_new_req_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqp
operator|==
name|NULL
condition|)
block|{
comment|/* ignore this request from host */
break|break;
block|}
name|hv_vss_init_req
argument_list|(
name|reqp
argument_list|,
name|recvlen
argument_list|,
name|requestid
argument_list|,
name|vss_buf
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|hv_vss_log_info
argument_list|(
literal|"%s: receive %s (%ju) from host\n"
argument_list|,
name|__func__
argument_list|,
name|vss_opt_name
index|[
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|opt
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|reqp
operator|->
name|vss_req
operator|.
name|opt_msg
operator|.
name|msgid
argument_list|)
expr_stmt|;
name|hv_vss_start_notify
argument_list|(
name|reqp
argument_list|,
name|msg
operator|->
name|hdr
operator|.
name|vss_hdr
operator|.
name|operation
argument_list|)
expr_stmt|;
break|break;
case|case
name|VSS_OP_GET_DM_INFO
case|:
name|hv_vss_log_info
argument_list|(
literal|"%s: receive GET_DM_INFO from host\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|msg
operator|->
name|body
operator|.
name|dm_info
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|hv_vss_respond_host
argument_list|(
name|vss_buf
argument_list|,
name|vmbus_get_channel
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|recvlen
argument_list|,
name|requestid
argument_list|,
name|HV_S_OK
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown opt from host: %d\n"
argument_list|,
name|msg
operator|->
name|hdr
operator|.
name|vss_hdr
operator|.
name|operation
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* daemon was killed for some reason after it was launched */
name|struct
name|hv_vss_msg
modifier|*
name|msg
init|=
operator|(
expr|struct
name|hv_vss_msg
operator|*
operator|)
name|vss_buf
decl_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|hdr
operator|.
name|vss_hdr
operator|.
name|operation
condition|)
block|{
case|case
name|VSS_OP_FREEZE
case|:
name|hv_vss_log_info
argument_list|(
literal|"%s: response fail for FREEZE\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|VSS_OP_THAW
case|:
name|hv_vss_log_info
argument_list|(
literal|"%s: response fail for THAW\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|VSS_OP_HOT_BACKUP
case|:
name|hv_vss_log_info
argument_list|(
literal|"%s: response fail for HOT_BACKUP\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|msg
operator|->
name|body
operator|.
name|vss_cf
operator|.
name|flags
operator|=
name|VSS_HBU_NO_AUTO_RECOVERY
expr_stmt|;
break|break;
case|case
name|VSS_OP_GET_DM_INFO
case|:
name|hv_vss_log_info
argument_list|(
literal|"%s: response fail for GET_DM_INFO\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|msg
operator|->
name|body
operator|.
name|dm_info
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown opt from host: %d\n"
argument_list|,
name|msg
operator|->
name|hdr
operator|.
name|vss_hdr
operator|.
name|operation
argument_list|)
expr_stmt|;
break|break;
block|}
name|hv_vss_respond_host
argument_list|(
name|vss_buf
argument_list|,
name|vmbus_get_channel
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|recvlen
argument_list|,
name|requestid
argument_list|,
name|HV_E_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Try reading next buffer 		 */
name|recvlen
operator|=
name|sc
operator|->
name|util_sc
operator|.
name|ic_buflen
expr_stmt|;
name|ret
operator|=
name|vmbus_chan_recv
argument_list|(
name|channel
argument_list|,
name|vss_buf
argument_list|,
operator|&
name|recvlen
argument_list|,
operator|&
name|requestid
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
operator|!=
name|ENOBUFS
argument_list|,
operator|(
literal|"hvvss recvbuf is not large enough"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX check recvlen to make sure that it contains enough data */
name|hv_vss_log_info
argument_list|(
literal|"%s: read: context %p, ret =%d, recvlen=%d\n"
argument_list|,
name|__func__
argument_list|,
name|context
argument_list|,
name|ret
argument_list|,
name|recvlen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hv_vss_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|vmbus_ic_probe
argument_list|(
name|dev
argument_list|,
name|vmbus_vss_descs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_vss_init_send_receive_queue
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|hv_vss_sc
modifier|*
name|sc
init|=
operator|(
name|hv_vss_sc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|max_list
init|=
literal|4
decl_stmt|;
comment|/* It is big enough for the list */
name|struct
name|hv_vss_req_internal
modifier|*
name|reqp
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|req_free_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_notify_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_ack_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_notify_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_ack_queue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_list
condition|;
name|i
operator|++
control|)
block|{
name|reqp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hv_vss_req_internal
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|req_free_list
argument_list|,
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|reqp
operator|->
name|callout
argument_list|,
operator|&
name|sc
operator|->
name|pending_mutex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_vss_destroy_send_receive_queue
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|hv_vss_sc
modifier|*
name|sc
init|=
operator|(
name|hv_vss_sc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|hv_vss_req_internal
modifier|*
name|reqp
decl_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|req_free_list
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|req_free_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|reqp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_notify_queue
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_notify_queue
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_notify_queue
argument_list|,
name|slink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_ack_queue
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_ack_queue
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|daemon_sc
operator|.
name|to_ack_queue
argument_list|,
name|slink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_notify_queue
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_notify_queue
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_notify_queue
argument_list|,
name|slink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_ack_queue
argument_list|)
condition|)
block|{
name|reqp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_ack_queue
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|app_sc
operator|.
name|to_ack_queue
argument_list|,
name|slink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_vss_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|hv_vss_sc
modifier|*
name|sc
init|=
operator|(
name|hv_vss_sc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|pending_mutex
argument_list|,
literal|"hv_vss pending mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hv_vss_log"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|hv_vss_log
argument_list|,
literal|0
argument_list|,
literal|"Hyperv VSS service log level"
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|hv_vss_process_request
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|hv_vss_init_send_receive_queue
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* create character device for file system freeze/thaw */
name|error
operator|=
name|make_dev_p
argument_list|(
name|MAKEDEV_CHECKNAME
operator||
name|MAKEDEV_WAITOK
argument_list|,
operator|&
name|sc
operator|->
name|hv_vss_dev
argument_list|,
operator|&
name|hv_vss_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0640
argument_list|,
name|FS_VSS_DEV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|hv_vss_log_info
argument_list|(
literal|"Fail to create '%s': %d\n"
argument_list|,
name|FS_VSS_DEV_NAME
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|hv_vss_dev
operator|->
name|si_drv1
operator|=
operator|&
name|sc
operator|->
name|daemon_sc
expr_stmt|;
name|sc
operator|->
name|daemon_sc
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
comment|/* create character device for application freeze/thaw */
name|error
operator|=
name|make_dev_p
argument_list|(
name|MAKEDEV_CHECKNAME
operator||
name|MAKEDEV_WAITOK
argument_list|,
operator|&
name|sc
operator|->
name|hv_appvss_dev
argument_list|,
operator|&
name|hv_appvss_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0640
argument_list|,
name|APP_VSS_DEV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|hv_vss_log_info
argument_list|(
literal|"Fail to create '%s': %d\n"
argument_list|,
name|APP_VSS_DEV_NAME
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|hv_appvss_dev
operator|->
name|si_drv1
operator|=
operator|&
name|sc
operator|->
name|app_sc
expr_stmt|;
name|sc
operator|->
name|app_sc
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
return|return
operator|(
name|vmbus_ic_attach
argument_list|(
name|dev
argument_list|,
name|hv_vss_callback
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hv_vss_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|hv_vss_sc
modifier|*
name|sc
init|=
operator|(
name|hv_vss_sc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|pending_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|daemon_sc
operator|.
name|proc_task
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|sc
operator|->
name|daemon_sc
operator|.
name|proc_task
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|sc
operator|->
name|daemon_sc
operator|.
name|proc_task
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|sc
operator|->
name|daemon_sc
operator|.
name|proc_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|app_sc
operator|.
name|proc_task
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|sc
operator|->
name|app_sc
operator|.
name|proc_task
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|sc
operator|->
name|app_sc
operator|.
name|proc_task
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|sc
operator|->
name|app_sc
operator|.
name|proc_task
argument_list|)
expr_stmt|;
block|}
name|hv_vss_destroy_send_receive_queue
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|hv_vss_dev
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|hv_appvss_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|vmbus_ic_detach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|vss_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hv_vss_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hv_vss_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hv_vss_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|vss_driver
init|=
block|{
literal|"hvvss"
block|,
name|vss_methods
block|,
expr|sizeof
operator|(
name|hv_vss_sc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|vss_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hv_vss
argument_list|,
name|vmbus
argument_list|,
name|vss_driver
argument_list|,
name|vss_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|hv_vss
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hv_vss
argument_list|,
name|vmbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

