begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: ubsec.c,v 1.115 2002/09/24 18:33:26 jason Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2000 Jason L. Wright (jason@thought.net)  * Copyright (c) 2000 Theo de Raadt (deraadt@openbsd.org)  * Copyright (c) 2001 Patrik Lindergren (patrik@ipunplugged.com)  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jason L. Wright  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Effort sponsored in part by the Defense Advanced Research Projects  * Agency (DARPA) and Air Force Research Laboratory, Air Force  * Materiel Command, USAF, under agreement number F30602-01-2-0537.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * uBsec 5[56]01, 58xx hardware crypto accelerator  */
end_comment

begin_include
include|#
directive|include
file|"opt_ubsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<crypto/sha1.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptosoft.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|"cryptodev_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_comment
comment|/* grr, #defines for gratuitous incompatibility in queue.h */
end_comment

begin_define
define|#
directive|define
name|SIMPLEQ_HEAD
value|STAILQ_HEAD
end_define

begin_define
define|#
directive|define
name|SIMPLEQ_ENTRY
value|STAILQ_ENTRY
end_define

begin_define
define|#
directive|define
name|SIMPLEQ_INIT
value|STAILQ_INIT
end_define

begin_define
define|#
directive|define
name|SIMPLEQ_INSERT_TAIL
value|STAILQ_INSERT_TAIL
end_define

begin_define
define|#
directive|define
name|SIMPLEQ_EMPTY
value|STAILQ_EMPTY
end_define

begin_define
define|#
directive|define
name|SIMPLEQ_FIRST
value|STAILQ_FIRST
end_define

begin_define
define|#
directive|define
name|SIMPLEQ_REMOVE_HEAD
value|STAILQ_REMOVE_HEAD
end_define

begin_define
define|#
directive|define
name|SIMPLEQ_FOREACH
value|STAILQ_FOREACH
end_define

begin_comment
comment|/* ditto for endian.h */
end_comment

begin_define
define|#
directive|define
name|letoh16
parameter_list|(
name|x
parameter_list|)
value|le16toh(x)
end_define

begin_define
define|#
directive|define
name|letoh32
parameter_list|(
name|x
parameter_list|)
value|le32toh(x)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UBSEC_RNDTEST
end_ifdef

begin_include
include|#
directive|include
file|<dev/rndtest/rndtest.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ubsec/ubsecreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ubsec/ubsecvar.h>
end_include

begin_comment
comment|/*  * Prototypes and count for the pci_device structure  */
end_comment

begin_function_decl
specifier|static
name|int
name|ubsec_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_newsession
parameter_list|(
name|device_t
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|,
name|struct
name|cryptoini
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_freesession
parameter_list|(
name|device_t
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_process
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|cryptop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_kprocess
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|cryptkop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|ubsec_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ubsec_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ubsec_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ubsec_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ubsec_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ubsec_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ubsec_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* crypto device methods */
name|DEVMETHOD
argument_list|(
name|cryptodev_newsession
argument_list|,
name|ubsec_newsession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_freesession
argument_list|,
name|ubsec_freesession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_process
argument_list|,
name|ubsec_process
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_kprocess
argument_list|,
name|ubsec_kprocess
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ubsec_driver
init|=
block|{
literal|"ubsec"
block|,
name|ubsec_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ubsec_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ubsec_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ubsec
argument_list|,
name|pci
argument_list|,
name|ubsec_driver
argument_list|,
name|ubsec_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ubsec
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UBSEC_RNDTEST
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ubsec
argument_list|,
name|rndtest
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ubsec_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_callback
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|,
name|struct
name|ubsec_q
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_feed
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_mcopy
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_callback2
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|,
name|struct
name|ubsec_q2
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_feed2
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_rng
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_dma_malloc
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|struct
name|ubsec_dma_alloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ubsec_dma_sync
parameter_list|(
name|_dma
parameter_list|,
name|_flags
parameter_list|)
define|\
value|bus_dmamap_sync((_dma)->dma_tag, (_dma)->dma_map, (_flags))
end_define

begin_function_decl
specifier|static
name|void
name|ubsec_dma_free
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|,
name|struct
name|ubsec_dma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_dmamap_aligned
parameter_list|(
name|struct
name|ubsec_operand
modifier|*
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_reset_board
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_init_board
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_init_pciregs
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_totalreset
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_free_q
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ubsec_q
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_kprocess_modexp_hw
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|,
name|struct
name|cryptkop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_kprocess_modexp_sw
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|,
name|struct
name|cryptkop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_kprocess_rsapriv
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|,
name|struct
name|cryptkop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_kfree
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
parameter_list|,
name|struct
name|ubsec_q2
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ubsec_ksigbits
parameter_list|(
name|struct
name|crparam
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_kshift_r
parameter_list|(
name|u_int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_kshift_l
parameter_list|(
name|u_int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ubsec
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Broadcom driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|ubsec_dump_pb
parameter_list|(
specifier|volatile
name|struct
name|ubsec_pktbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_dump_mcr
parameter_list|(
name|struct
name|ubsec_mcr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ubsec_dump_ctx2
parameter_list|(
name|struct
name|ubsec_ctx_keyop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ubsec_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ubsec
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ubsec_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging msgs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|READ_REG
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
define|\
value|bus_space_read_4((sc)->sc_st, (sc)->sc_sh, (r))
end_define

begin_define
define|#
directive|define
name|WRITE_REG
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4((sc)->sc_st, (sc)->sc_sh, reg, val)
end_define

begin_define
define|#
directive|define
name|SWAP32
parameter_list|(
name|x
parameter_list|)
value|(x) = htole32(ntohl((x)))
end_define

begin_define
define|#
directive|define
name|HTOLE32
parameter_list|(
name|x
parameter_list|)
value|(x) = htole32(x)
end_define

begin_decl_stmt
name|struct
name|ubsec_stats
name|ubsecstats
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_hw_ubsec
argument_list|,
name|OID_AUTO
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ubsecstats
argument_list|,
name|ubsec_stats
argument_list|,
literal|"driver statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ubsec_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_SUN
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_SUN_5821
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_SUN_SCA1K
operator|)
condition|)
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_BLUESTEEL
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BLUESTEEL_5501
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BLUESTEEL_5601
operator|)
condition|)
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_BROADCOM
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5801
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5802
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5805
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5820
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5821
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5822
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5823
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5825
operator|)
condition|)
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ubsec_partname
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX sprintf numbers when not decoded */
switch|switch
condition|(
name|pci_get_vendor
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_VENDOR_BROADCOM
case|:
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_BROADCOM_5801
case|:
return|return
literal|"Broadcom 5801"
return|;
case|case
name|PCI_PRODUCT_BROADCOM_5802
case|:
return|return
literal|"Broadcom 5802"
return|;
case|case
name|PCI_PRODUCT_BROADCOM_5805
case|:
return|return
literal|"Broadcom 5805"
return|;
case|case
name|PCI_PRODUCT_BROADCOM_5820
case|:
return|return
literal|"Broadcom 5820"
return|;
case|case
name|PCI_PRODUCT_BROADCOM_5821
case|:
return|return
literal|"Broadcom 5821"
return|;
case|case
name|PCI_PRODUCT_BROADCOM_5822
case|:
return|return
literal|"Broadcom 5822"
return|;
case|case
name|PCI_PRODUCT_BROADCOM_5823
case|:
return|return
literal|"Broadcom 5823"
return|;
case|case
name|PCI_PRODUCT_BROADCOM_5825
case|:
return|return
literal|"Broadcom 5825"
return|;
block|}
return|return
literal|"Broadcom unknown-part"
return|;
case|case
name|PCI_VENDOR_BLUESTEEL
case|:
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_BLUESTEEL_5601
case|:
return|return
literal|"Bluesteel 5601"
return|;
block|}
return|return
literal|"Bluesteel unknown-part"
return|;
case|case
name|PCI_VENDOR_SUN
case|:
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_SUN_5821
case|:
return|return
literal|"Sun Crypto 5821"
return|;
case|case
name|PCI_PRODUCT_SUN_SCA1K
case|:
return|return
literal|"Sun Crypto 1K"
return|;
block|}
return|return
literal|"Sun unknown-part"
return|;
block|}
return|return
literal|"Unknown-vendor unknown-part"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|default_harvest
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|random_harvest
argument_list|(
name|buf
argument_list|,
name|count
argument_list|,
name|count
operator|*
name|NBBY
argument_list|,
literal|0
argument_list|,
name|RANDOM_PURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ubsec_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ubsec_dma
modifier|*
name|dmap
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|,
name|i
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|)
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue2
argument_list|)
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip2
argument_list|)
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_q2free
argument_list|)
expr_stmt|;
comment|/* XXX handle power management */
name|sc
operator|->
name|sc_statmask
operator|=
name|BS_STAT_MCR1_DONE
operator||
name|BS_STAT_DMAERR
expr_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_BLUESTEEL
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BLUESTEEL_5601
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|UBS_FLAGS_KEY
operator||
name|UBS_FLAGS_RNG
expr_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_BROADCOM
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5802
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5805
operator|)
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|UBS_FLAGS_KEY
operator||
name|UBS_FLAGS_RNG
expr_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_BROADCOM
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5820
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|UBS_FLAGS_KEY
operator||
name|UBS_FLAGS_RNG
operator||
name|UBS_FLAGS_LONGCTX
operator||
name|UBS_FLAGS_HWNORM
operator||
name|UBS_FLAGS_BIGKEY
expr_stmt|;
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_BROADCOM
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5821
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5822
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5823
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_BROADCOM_5825
operator|)
operator|)
operator|||
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_SUN
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_SUN_SCA1K
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_SUN_5821
operator|)
operator|)
condition|)
block|{
comment|/* NB: the 5821/5822 defines some additional status bits */
name|sc
operator|->
name|sc_statmask
operator||=
name|BS_STAT_MCR1_ALLEMPTY
operator||
name|BS_STAT_MCR2_ALLEMPTY
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|UBS_FLAGS_KEY
operator||
name|UBS_FLAGS_RNG
operator||
name|UBS_FLAGS_LONGCTX
operator||
name|UBS_FLAGS_HWNORM
operator||
name|UBS_FLAGS_BIGKEY
expr_stmt|;
block|}
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cmd
operator|&
name|PCIM_CMD_MEMEN
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to enable memory mapping\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|cmd
operator|&
name|PCIM_CMD_BUSMASTEREN
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to enable bus mastering\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Setup memory-mapping of PCI registers. 	 */
name|rid
operator|=
name|BS_BAR
expr_stmt|;
name|sc
operator|->
name|sc_sr
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot map register space\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
comment|/* 	 * Arrange interrupt line. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
comment|/* 	 * NB: Network code assumes we are blocked with splimp() 	 *     so make sure the IRQ is mapped appropriately. 	 */
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ubsec_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not establish interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_cid
operator|=
name|crypto_get_driverid
argument_list|(
name|dev
argument_list|,
name|CRYPTOCAP_F_HARDWARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cid
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not get crypto driver id\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad3
goto|;
block|}
comment|/* 	 * Setup DMA descriptor area. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
literal|0x3ffff
argument_list|,
comment|/* maxsize */
name|UBS_MAX_SCATTER
argument_list|,
comment|/* nsegments */
literal|0xffff
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sc_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad4
goto|;
block|}
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|)
expr_stmt|;
name|dmap
operator|=
name|sc
operator|->
name|sc_dmaa
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UBS_MAX_NQUEUE
condition|;
name|i
operator|++
operator|,
name|dmap
operator|++
control|)
block|{
name|struct
name|ubsec_q
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ubsec_q
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_q
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate queue buffers\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|)
argument_list|,
operator|&
name|dmap
operator|->
name|d_alloc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate dma buffers\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|dmap
operator|->
name|d_dma
operator|=
operator|(
expr|struct
name|ubsec_dmachunk
operator|*
operator|)
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_vaddr
expr_stmt|;
name|q
operator|->
name|q_dma
operator|=
name|dmap
expr_stmt|;
name|sc
operator|->
name|sc_queuea
index|[
name|i
index|]
operator|=
name|q
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|,
name|q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr1lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"mcr1 operations"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"mcr1 free q"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s\n"
argument_list|,
name|ubsec_partname
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_3DES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_DES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_MD5_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA1_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset Broadcom chip 	 */
name|ubsec_reset_board
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Init Broadcom specific PCI settings 	 */
name|ubsec_init_pciregs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Init Broadcom chip 	 */
name|ubsec_init_board
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UBSEC_NO_RNG
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_RNG
condition|)
block|{
name|sc
operator|->
name|sc_statmask
operator||=
name|BS_STAT_MCR2_DONE
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_RNDTEST
name|sc
operator|->
name|sc_rndtest
operator|=
name|rndtest_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rndtest
condition|)
name|sc
operator|->
name|sc_harvest
operator|=
name|rndtest_harvest
expr_stmt|;
else|else
name|sc
operator|->
name|sc_harvest
operator|=
name|default_harvest
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_harvest
operator|=
name|default_harvest
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_mcr
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_q
operator|.
name|q_mcr
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|skip_rng
goto|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_ctx_rngbypass
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_q
operator|.
name|q_ctx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_q
operator|.
name|q_mcr
argument_list|)
expr_stmt|;
goto|goto
name|skip_rng
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
name|UBSEC_RNG_BUFSIZ
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_buf
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_q
operator|.
name|q_ctx
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_q
operator|.
name|q_mcr
argument_list|)
expr_stmt|;
goto|goto
name|skip_rng
goto|;
block|}
if|if
condition|(
name|hz
operator|>=
literal|100
condition|)
name|sc
operator|->
name|sc_rnghz
operator|=
name|hz
operator|/
literal|100
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rnghz
operator|=
literal|1
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|sc
operator|->
name|sc_rnghz
argument_list|,
name|ubsec_rng
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|skip_rng
label|:
empty_stmt|;
block|}
endif|#
directive|endif
comment|/* UBSEC_NO_RNG */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"mcr2 operations"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_KEY
condition|)
block|{
name|sc
operator|->
name|sc_statmask
operator||=
name|BS_STAT_MCR2_DONE
expr_stmt|;
name|crypto_kregister
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRK_MOD_EXP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|crypto_kregister(sc->sc_cid, CRK_MOD_EXP_CRT, 0);
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad4
label|:
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|)
expr_stmt|;
name|bad3
label|:
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bad2
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|bad1
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|BS_BAR
argument_list|,
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
name|bad
label|:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a device that successfully probed.  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* XXX wait/abort active ops */
comment|/* disable interrupts */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|BS_CTRL
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|BS_CTRL
argument_list|)
operator|&
operator|~
operator|(
name|BS_CTRL_MCR2INT
operator||
name|BS_CTRL_MCR1INT
operator||
name|BS_CTRL_DMAERR
operator|)
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|)
expr_stmt|;
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_RNDTEST
if|if
condition|(
name|sc
operator|->
name|sc_rndtest
condition|)
name|rndtest_detach
argument_list|(
name|sc
operator|->
name|sc_rndtest
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|SIMPLEQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|)
condition|)
block|{
name|struct
name|ubsec_q
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|)
expr_stmt|;
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|q_dma
operator|->
name|d_alloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr1lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UBSEC_NO_RNG
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_RNG
condition|)
block|{
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_q
operator|.
name|q_mcr
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_q
operator|.
name|q_ctx
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rng
operator|.
name|rng_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UBSEC_NO_RNG */
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|BS_BAR
argument_list|,
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop all chip i/o so that the kernel's probe routines don't  * get confused by errant DMAs when rebooting.  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|ubsec_stop
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Device suspend routine.  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX stop the device and save PCI settings */
endif|#
directive|endif
name|sc
operator|->
name|sc_suspended
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ubsec_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX retore PCI settings and start the device */
endif|#
directive|endif
name|sc
operator|->
name|sc_suspended
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * UBSEC Interrupt routine  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
specifier|volatile
name|u_int32_t
name|stat
decl_stmt|;
name|struct
name|ubsec_q
modifier|*
name|q
decl_stmt|;
name|struct
name|ubsec_dma
modifier|*
name|dmap
decl_stmt|;
name|int
name|npkts
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|stat
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|BS_STAT
argument_list|)
expr_stmt|;
name|stat
operator|&=
name|sc
operator|->
name|sc_statmask
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
return|return;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|BS_STAT
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/* IACK */
comment|/* 	 * Check to see if we have any packets waiting for us 	 */
if|if
condition|(
operator|(
name|stat
operator|&
name|BS_STAT_MCR1_DONE
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr1lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|SIMPLEQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|)
condition|)
block|{
name|q
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|)
expr_stmt|;
name|dmap
operator|=
name|q
operator|->
name|q_dma
expr_stmt|;
if|if
condition|(
operator|(
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_flags
operator|&
name|htole16
argument_list|(
name|UBS_MCR_DONE
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|npkts
operator|=
name|q
operator|->
name|q_nstacked_mcrs
expr_stmt|;
name|sc
operator|->
name|sc_nqchip
operator|-=
literal|1
operator|+
name|npkts
expr_stmt|;
comment|/* 			 * search for further sc_qchip ubsec_q's that share 			 * the same MCR, and complete them too, they must be 			 * at the top. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npkts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|q_stacked_mcr
index|[
name|i
index|]
condition|)
block|{
name|ubsec_callback
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|q_stacked_mcr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|ubsec_callback
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Don't send any more packet to chip if there has been 		 * a DMAERR. 		 */
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|BS_STAT_DMAERR
operator|)
condition|)
name|ubsec_feed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr1lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check to see if we have any key setups/rng's waiting for us 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|UBS_FLAGS_KEY
operator||
name|UBS_FLAGS_RNG
operator|)
operator|)
operator|&&
operator|(
name|stat
operator|&
name|BS_STAT_MCR2_DONE
operator|)
condition|)
block|{
name|struct
name|ubsec_q2
modifier|*
name|q2
decl_stmt|;
name|struct
name|ubsec_mcr
modifier|*
name|mcr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|SIMPLEQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip2
argument_list|)
condition|)
block|{
name|q2
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip2
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|q2
operator|->
name|q_mcr
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|mcr
operator|=
operator|(
expr|struct
name|ubsec_mcr
operator|*
operator|)
name|q2
operator|->
name|q_mcr
operator|.
name|dma_vaddr
expr_stmt|;
if|if
condition|(
operator|(
name|mcr
operator|->
name|mcr_flags
operator|&
name|htole16
argument_list|(
name|UBS_MCR_DONE
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ubsec_dma_sync
argument_list|(
operator|&
name|q2
operator|->
name|q_mcr
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
break|break;
block|}
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip2
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|ubsec_callback2
argument_list|(
name|sc
argument_list|,
name|q2
argument_list|)
expr_stmt|;
comment|/* 			 * Don't send any more packet to chip if there has been 			 * a DMAERR. 			 */
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|BS_STAT_DMAERR
operator|)
condition|)
name|ubsec_feed2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check to see if we got any DMA Error 	 */
if|if
condition|(
name|stat
operator|&
name|BS_STAT_DMAERR
condition|)
block|{
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
block|{
specifier|volatile
name|u_int32_t
name|a
init|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|BS_ERR
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"dmaerr %s@%08x\n"
argument_list|,
operator|(
name|a
operator|&
name|BS_ERR_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|a
operator|&
name|BS_ERR_ADDR
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UBSEC_DEBUG */
name|ubsecstats
operator|.
name|hst_dmaerr
operator|++
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr1lock
argument_list|)
expr_stmt|;
name|ubsec_totalreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ubsec_feed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr1lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_needwakeup
condition|)
block|{
comment|/* XXX check high watermark */
name|int
name|wakeup
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
name|wakeup
operator|=
name|sc
operator|->
name|sc_needwakeup
operator|&
operator|(
name|CRYPTO_SYMQ
operator||
name|CRYPTO_ASYMQ
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"wakeup crypto (%x)\n"
argument_list|,
name|sc
operator|->
name|sc_needwakeup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UBSEC_DEBUG */
name|sc
operator|->
name|sc_needwakeup
operator|&=
operator|~
name|wakeup
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
name|crypto_unblock
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|wakeup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ubsec_feed() - aggregate and post requests to chip  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_feed
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ubsec_q
modifier|*
name|q
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
name|int
name|npkts
decl_stmt|,
name|i
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|;
comment|/* 	 * Decide how many ops to combine in a single MCR.  We cannot 	 * aggregate more than UBS_MAX_AGGR because this is the number 	 * of slots defined in the data structure.  Note that 	 * aggregation only happens if ops are marked batch'able. 	 * Aggregating ops reduces the number of interrupts to the host 	 * but also (potentially) increases the latency for processing 	 * completed ops as we only get an interrupt when all aggregated 	 * ops have completed. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_nqueue
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|sc_nqueue
operator|>
literal|1
condition|)
block|{
name|npkts
operator|=
literal|0
expr_stmt|;
name|SIMPLEQ_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&sc->sc_queue
argument_list|,
argument|q_next
argument_list|)
block|{
name|npkts
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|->
name|q_crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_BATCH
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
else|else
name|npkts
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Check device status before going any further. 	 */
if|if
condition|(
operator|(
name|stat
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|BS_STAT
argument_list|)
operator|)
operator|&
operator|(
name|BS_STAT_MCR1_FULL
operator||
name|BS_STAT_DMAERR
operator|)
condition|)
block|{
if|if
condition|(
name|stat
operator|&
name|BS_STAT_DMAERR
condition|)
block|{
name|ubsec_totalreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ubsecstats
operator|.
name|hst_dmaerr
operator|++
expr_stmt|;
block|}
else|else
name|ubsecstats
operator|.
name|hst_mcr1full
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_nqueue
operator|>
name|ubsecstats
operator|.
name|hst_maxqueue
condition|)
name|ubsecstats
operator|.
name|hst_maxqueue
operator|=
name|sc
operator|->
name|sc_nqueue
expr_stmt|;
if|if
condition|(
name|npkts
operator|>
name|UBS_MAX_AGGR
condition|)
name|npkts
operator|=
name|UBS_MAX_AGGR
expr_stmt|;
if|if
condition|(
name|npkts
operator|<
literal|2
condition|)
comment|/* special case 1 op */
goto|goto
name|feed1
goto|;
name|ubsecstats
operator|.
name|hst_totbatch
operator|+=
name|npkts
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
name|printf
argument_list|(
literal|"merging %d records\n"
argument_list|,
name|npkts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UBSEC_DEBUG */
name|q
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
operator|--
name|sc
operator|->
name|sc_nqueue
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_dst_map
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_nstacked_mcrs
operator|=
name|npkts
operator|-
literal|1
expr_stmt|;
comment|/* Number of packets stacked */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|q_nstacked_mcrs
condition|;
name|i
operator|++
control|)
block|{
name|q2
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q2
operator|->
name|q_src_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|q2
operator|->
name|q_dst_map
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q2
operator|->
name|q_dst_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
operator|--
name|sc
operator|->
name|sc_nqueue
expr_stmt|;
name|v
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|q2
operator|->
name|q_dma
operator|->
name|d_dma
operator|->
name|d_mcr
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_mcr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_mcr_add
argument_list|)
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|v
argument_list|,
operator|&
name|q
operator|->
name|q_dma
operator|->
name|d_dma
operator|->
name|d_mcradd
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_mcr_add
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_stacked_mcr
index|[
name|i
index|]
operator|=
name|q2
expr_stmt|;
block|}
name|q
operator|->
name|q_dma
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_pkts
operator|=
name|htole16
argument_list|(
name|npkts
argument_list|)
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|,
name|q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nqchip
operator|+=
name|npkts
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nqchip
operator|>
name|ubsecstats
operator|.
name|hst_maxqchip
condition|)
name|ubsecstats
operator|.
name|hst_maxqchip
operator|=
name|sc
operator|->
name|sc_nqchip
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|q
operator|->
name|q_dma
operator|->
name|d_alloc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|BS_MCR1
argument_list|,
name|q
operator|->
name|q_dma
operator|->
name|d_alloc
operator|.
name|dma_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_mcr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|feed1
label|:
name|q
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_dst_map
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|q
operator|->
name|q_dma
operator|->
name|d_alloc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|BS_MCR1
argument_list|,
name|q
operator|->
name|q_dma
operator|->
name|d_alloc
operator|.
name|dma_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_mcr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
name|printf
argument_list|(
literal|"feed1: q->chip %p %08x stat %08x\n"
argument_list|,
name|q
argument_list|,
operator|(
name|u_int32_t
operator|)
name|vtophys
argument_list|(
operator|&
name|q
operator|->
name|q_dma
operator|->
name|d_dma
operator|->
name|d_mcr
argument_list|)
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UBSEC_DEBUG */
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
operator|--
name|sc
operator|->
name|sc_nqueue
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|,
name|q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nqchip
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nqchip
operator|>
name|ubsecstats
operator|.
name|hst_maxqchip
condition|)
name|ubsecstats
operator|.
name|hst_maxqchip
operator|=
name|sc
operator|->
name|sc_nqchip
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_setup_enckey
parameter_list|(
name|struct
name|ubsec_session
modifier|*
name|ses
parameter_list|,
name|int
name|algo
parameter_list|,
name|caddr_t
name|key
parameter_list|)
block|{
comment|/* Go ahead and compute key in ubsec's byte order */
if|if
condition|(
name|algo
operator|==
name|CRYPTO_DES_CBC
condition|)
block|{
name|bcopy
argument_list|(
name|key
argument_list|,
operator|&
name|ses
operator|->
name|ses_deskey
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
operator|&
name|ses
operator|->
name|ses_deskey
index|[
literal|2
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
operator|&
name|ses
operator|->
name|ses_deskey
index|[
literal|4
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|key
argument_list|,
name|ses
operator|->
name|ses_deskey
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|SWAP32
argument_list|(
name|ses
operator|->
name|ses_deskey
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SWAP32
argument_list|(
name|ses
operator|->
name|ses_deskey
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SWAP32
argument_list|(
name|ses
operator|->
name|ses_deskey
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|SWAP32
argument_list|(
name|ses
operator|->
name|ses_deskey
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|SWAP32
argument_list|(
name|ses
operator|->
name|ses_deskey
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|SWAP32
argument_list|(
name|ses
operator|->
name|ses_deskey
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_setup_mackey
parameter_list|(
name|struct
name|ubsec_session
modifier|*
name|ses
parameter_list|,
name|int
name|algo
parameter_list|,
name|caddr_t
name|key
parameter_list|,
name|int
name|klen
parameter_list|)
block|{
name|MD5_CTX
name|md5ctx
decl_stmt|;
name|SHA1_CTX
name|sha1ctx
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klen
condition|;
name|i
operator|++
control|)
name|key
index|[
name|i
index|]
operator|^=
name|HMAC_IPAD_VAL
expr_stmt|;
if|if
condition|(
name|algo
operator|==
name|CRYPTO_MD5_HMAC
condition|)
block|{
name|MD5Init
argument_list|(
operator|&
name|md5ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|hmac_ipad_buffer
argument_list|,
name|MD5_HMAC_BLOCK_LEN
operator|-
name|klen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|,
name|ses
operator|->
name|ses_hminner
argument_list|,
sizeof|sizeof
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SHA1Init
argument_list|(
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|hmac_ipad_buffer
argument_list|,
name|SHA1_HMAC_BLOCK_LEN
operator|-
name|klen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|,
name|ses
operator|->
name|ses_hminner
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klen
condition|;
name|i
operator|++
control|)
name|key
index|[
name|i
index|]
operator|^=
operator|(
name|HMAC_IPAD_VAL
operator|^
name|HMAC_OPAD_VAL
operator|)
expr_stmt|;
if|if
condition|(
name|algo
operator|==
name|CRYPTO_MD5_HMAC
condition|)
block|{
name|MD5Init
argument_list|(
operator|&
name|md5ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|hmac_opad_buffer
argument_list|,
name|MD5_HMAC_BLOCK_LEN
operator|-
name|klen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|,
name|ses
operator|->
name|ses_hmouter
argument_list|,
sizeof|sizeof
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SHA1Init
argument_list|(
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|hmac_opad_buffer
argument_list|,
name|SHA1_HMAC_BLOCK_LEN
operator|-
name|klen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|,
name|ses
operator|->
name|ses_hmouter
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klen
condition|;
name|i
operator|++
control|)
name|key
index|[
name|i
index|]
operator|^=
name|HMAC_OPAD_VAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new 'session' and return an encoded session id.  'sidp'  * contains our registration id, and should contain an encoded session  * id on successful allocation.  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_newsession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
modifier|*
name|sidp
parameter_list|,
name|struct
name|cryptoini
modifier|*
name|cri
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cryptoini
modifier|*
name|c
decl_stmt|,
modifier|*
name|encini
init|=
name|NULL
decl_stmt|,
modifier|*
name|macini
init|=
name|NULL
decl_stmt|;
name|struct
name|ubsec_session
modifier|*
name|ses
init|=
name|NULL
decl_stmt|;
name|int
name|sesn
decl_stmt|;
if|if
condition|(
name|sidp
operator|==
name|NULL
operator|||
name|cri
operator|==
name|NULL
operator|||
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|c
operator|=
name|cri
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|cri_next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_SHA1_HMAC
condition|)
block|{
if|if
condition|(
name|macini
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|macini
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_3DES_CBC
condition|)
block|{
if|if
condition|(
name|encini
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|encini
operator|=
name|c
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|encini
operator|==
name|NULL
operator|&&
name|macini
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_sessions
operator|==
name|NULL
condition|)
block|{
name|ses
operator|=
name|sc
operator|->
name|sc_sessions
operator|=
operator|(
expr|struct
name|ubsec_session
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_session
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sesn
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_nsessions
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|sesn
operator|=
literal|0
init|;
name|sesn
operator|<
name|sc
operator|->
name|sc_nsessions
condition|;
name|sesn
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
operator|.
name|ses_used
operator|==
literal|0
condition|)
block|{
name|ses
operator|=
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
block|{
name|sesn
operator|=
name|sc
operator|->
name|sc_nsessions
expr_stmt|;
name|ses
operator|=
operator|(
expr|struct
name|ubsec_session
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|sesn
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_session
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|ses
argument_list|,
name|sesn
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_session
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|sesn
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_session
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sessions
operator|=
name|ses
expr_stmt|;
name|ses
operator|=
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
expr_stmt|;
name|sc
operator|->
name|sc_nsessions
operator|++
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
name|ses
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_session
argument_list|)
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|encini
condition|)
block|{
comment|/* get an IV, network byte order */
comment|/* XXX may read fewer than requested */
name|read_random
argument_list|(
name|ses
operator|->
name|ses_iv
argument_list|,
sizeof|sizeof
argument_list|(
name|ses
operator|->
name|ses_iv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|encini
operator|->
name|cri_key
operator|!=
name|NULL
condition|)
block|{
name|ubsec_setup_enckey
argument_list|(
name|ses
argument_list|,
name|encini
operator|->
name|cri_alg
argument_list|,
name|encini
operator|->
name|cri_key
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|macini
condition|)
block|{
name|ses
operator|->
name|ses_mlen
operator|=
name|macini
operator|->
name|cri_mlen
expr_stmt|;
if|if
condition|(
name|ses
operator|->
name|ses_mlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|macini
operator|->
name|cri_alg
operator|==
name|CRYPTO_MD5_HMAC
condition|)
name|ses
operator|->
name|ses_mlen
operator|=
name|MD5_HASH_LEN
expr_stmt|;
else|else
name|ses
operator|->
name|ses_mlen
operator|=
name|SHA1_HASH_LEN
expr_stmt|;
block|}
if|if
condition|(
name|macini
operator|->
name|cri_key
operator|!=
name|NULL
condition|)
block|{
name|ubsec_setup_mackey
argument_list|(
name|ses
argument_list|,
name|macini
operator|->
name|cri_alg
argument_list|,
name|macini
operator|->
name|cri_key
argument_list|,
name|macini
operator|->
name|cri_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|sidp
operator|=
name|UBSEC_SID
argument_list|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sesn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a session.  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_freesession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int64_t
name|tid
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|session
decl_stmt|,
name|ret
decl_stmt|;
name|u_int32_t
name|sid
init|=
name|CRYPTO_SESID2LID
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|session
operator|=
name|UBSEC_SESSION
argument_list|(
name|sid
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|<
name|sc
operator|->
name|sc_nsessions
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|session
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_sessions
index|[
name|session
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_op_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ubsec_operand
modifier|*
name|op
init|=
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|UBS_MAX_SCATTER
argument_list|,
operator|(
literal|"Too many DMA segments returned when mapping operand"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
name|printf
argument_list|(
literal|"ubsec_op_cb: mapsize %u nsegs %d error %d\n"
argument_list|,
operator|(
name|u_int
operator|)
name|mapsize
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|op
operator|->
name|mapsize
operator|=
name|mapsize
expr_stmt|;
name|op
operator|->
name|nsegs
operator|=
name|nsegs
expr_stmt|;
name|bcopy
argument_list|(
name|seg
argument_list|,
name|op
operator|->
name|segs
argument_list|,
name|nsegs
operator|*
sizeof|sizeof
argument_list|(
name|seg
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ubsec_process
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ubsec_q
modifier|*
name|q
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nicealign
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd1
decl_stmt|,
modifier|*
name|crd2
decl_stmt|,
modifier|*
name|maccrd
decl_stmt|,
modifier|*
name|enccrd
decl_stmt|;
name|int
name|encoffset
init|=
literal|0
decl_stmt|,
name|macoffset
init|=
literal|0
decl_stmt|,
name|cpskip
decl_stmt|,
name|cpoffset
decl_stmt|;
name|int
name|sskip
decl_stmt|,
name|dskip
decl_stmt|,
name|stheend
decl_stmt|,
name|dtheend
decl_stmt|;
name|int16_t
name|coffset
decl_stmt|;
name|struct
name|ubsec_session
modifier|*
name|ses
decl_stmt|;
name|struct
name|ubsec_pktctx
name|ctx
decl_stmt|;
name|struct
name|ubsec_dma
modifier|*
name|dmap
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|crp
operator|==
name|NULL
operator|||
name|crp
operator|->
name|crp_callback
operator|==
name|NULL
operator|||
name|sc
operator|==
name|NULL
condition|)
block|{
name|ubsecstats
operator|.
name|hst_invalid
operator|++
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|UBSEC_SESSION
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
operator|>=
name|sc
operator|->
name|sc_nsessions
condition|)
block|{
name|ubsecstats
operator|.
name|hst_badsession
operator|++
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIMPLEQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|)
condition|)
block|{
name|ubsecstats
operator|.
name|hst_queuefull
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_needwakeup
operator||=
name|CRYPTO_SYMQ
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|q
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|)
expr_stmt|;
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
name|dmap
operator|=
name|q
operator|->
name|q_dma
expr_stmt|;
comment|/* Save dma pointer */
name|bzero
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_q
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_sesn
operator|=
name|UBSEC_SESSION
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_dma
operator|=
name|dmap
expr_stmt|;
name|ses
operator|=
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|q
operator|->
name|q_sesn
index|]
expr_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
name|q
operator|->
name|q_src_m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|q
operator|->
name|q_dst_m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
name|q
operator|->
name|q_src_io
operator|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|q
operator|->
name|q_dst_io
operator|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
block|}
else|else
block|{
name|ubsecstats
operator|.
name|hst_badflags
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
comment|/* XXX we don't handle contiguous blocks! */
block|}
name|bzero
argument_list|(
operator|&
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_mcr
argument_list|)
argument_list|)
expr_stmt|;
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_pkts
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_flags
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|q_crp
operator|=
name|crp
expr_stmt|;
name|crd1
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
if|if
condition|(
name|crd1
operator|==
name|NULL
condition|)
block|{
name|ubsecstats
operator|.
name|hst_nodesc
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|crd2
operator|=
name|crd1
operator|->
name|crd_next
expr_stmt|;
if|if
condition|(
name|crd2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
condition|)
block|{
name|maccrd
operator|=
name|crd1
expr_stmt|;
name|enccrd
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
condition|)
block|{
name|maccrd
operator|=
name|NULL
expr_stmt|;
name|enccrd
operator|=
name|crd1
expr_stmt|;
block|}
else|else
block|{
name|ubsecstats
operator|.
name|hst_badalg
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|)
operator|&&
operator|(
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
operator|)
operator|&&
operator|(
operator|(
name|crd2
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|maccrd
operator|=
name|crd1
expr_stmt|;
name|enccrd
operator|=
name|crd2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
operator|)
operator|&&
operator|(
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|)
operator|&&
operator|(
name|crd1
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
condition|)
block|{
name|enccrd
operator|=
name|crd1
expr_stmt|;
name|maccrd
operator|=
name|crd2
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We cannot order the ubsec as requested 			 */
name|ubsecstats
operator|.
name|hst_badalg
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
if|if
condition|(
name|enccrd
condition|)
block|{
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
block|{
name|ubsec_setup_enckey
argument_list|(
name|ses
argument_list|,
name|enccrd
operator|->
name|crd_alg
argument_list|,
name|enccrd
operator|->
name|crd_key
argument_list|)
expr_stmt|;
block|}
name|encoffset
operator|=
name|enccrd
operator|->
name|crd_skip
expr_stmt|;
name|ctx
operator|.
name|pc_flags
operator||=
name|htole16
argument_list|(
name|UBS_PKTCTX_ENC_3DES
argument_list|)
expr_stmt|;
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|q
operator|->
name|q_flags
operator||=
name|UBSEC_QFLAGS_COPYOUTIV
expr_stmt|;
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|enccrd
operator|->
name|crd_iv
argument_list|,
name|ctx
operator|.
name|pc_iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
name|ctx
operator|.
name|pc_iv
index|[
literal|0
index|]
operator|=
name|ses
operator|->
name|ses_iv
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|.
name|pc_iv
index|[
literal|1
index|]
operator|=
name|ses
operator|->
name|ses_iv
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
operator|==
literal|0
condition|)
block|{
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|,
literal|8
argument_list|,
operator|(
name|caddr_t
operator|)
name|ctx
operator|.
name|pc_iv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctx
operator|.
name|pc_flags
operator||=
name|htole16
argument_list|(
name|UBS_PKTCTX_INBOUND
argument_list|)
expr_stmt|;
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|enccrd
operator|->
name|crd_iv
argument_list|,
name|ctx
operator|.
name|pc_iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|,
literal|8
argument_list|,
operator|(
name|caddr_t
operator|)
name|ctx
operator|.
name|pc_iv
argument_list|)
expr_stmt|;
block|}
block|}
name|ctx
operator|.
name|pc_deskey
index|[
literal|0
index|]
operator|=
name|ses
operator|->
name|ses_deskey
index|[
literal|0
index|]
expr_stmt|;
name|ctx
operator|.
name|pc_deskey
index|[
literal|1
index|]
operator|=
name|ses
operator|->
name|ses_deskey
index|[
literal|1
index|]
expr_stmt|;
name|ctx
operator|.
name|pc_deskey
index|[
literal|2
index|]
operator|=
name|ses
operator|->
name|ses_deskey
index|[
literal|2
index|]
expr_stmt|;
name|ctx
operator|.
name|pc_deskey
index|[
literal|3
index|]
operator|=
name|ses
operator|->
name|ses_deskey
index|[
literal|3
index|]
expr_stmt|;
name|ctx
operator|.
name|pc_deskey
index|[
literal|4
index|]
operator|=
name|ses
operator|->
name|ses_deskey
index|[
literal|4
index|]
expr_stmt|;
name|ctx
operator|.
name|pc_deskey
index|[
literal|5
index|]
operator|=
name|ses
operator|->
name|ses_deskey
index|[
literal|5
index|]
expr_stmt|;
name|SWAP32
argument_list|(
name|ctx
operator|.
name|pc_iv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SWAP32
argument_list|(
name|ctx
operator|.
name|pc_iv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maccrd
condition|)
block|{
if|if
condition|(
name|maccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
block|{
name|ubsec_setup_mackey
argument_list|(
name|ses
argument_list|,
name|maccrd
operator|->
name|crd_alg
argument_list|,
name|maccrd
operator|->
name|crd_key
argument_list|,
name|maccrd
operator|->
name|crd_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
name|macoffset
operator|=
name|maccrd
operator|->
name|crd_skip
expr_stmt|;
if|if
condition|(
name|maccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
condition|)
name|ctx
operator|.
name|pc_flags
operator||=
name|htole16
argument_list|(
name|UBS_PKTCTX_AUTH_MD5
argument_list|)
expr_stmt|;
else|else
name|ctx
operator|.
name|pc_flags
operator||=
name|htole16
argument_list|(
name|UBS_PKTCTX_AUTH_SHA1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|ctx
operator|.
name|pc_hminner
index|[
name|i
index|]
operator|=
name|ses
operator|->
name|ses_hminner
index|[
name|i
index|]
expr_stmt|;
name|ctx
operator|.
name|pc_hmouter
index|[
name|i
index|]
operator|=
name|ses
operator|->
name|ses_hmouter
index|[
name|i
index|]
expr_stmt|;
name|HTOLE32
argument_list|(
name|ctx
operator|.
name|pc_hminner
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|HTOLE32
argument_list|(
name|ctx
operator|.
name|pc_hmouter
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enccrd
operator|&&
name|maccrd
condition|)
block|{
comment|/* 		 * ubsec cannot handle packets where the end of encryption 		 * and authentication are not the same, or where the 		 * encrypted part begins before the authenticated part. 		 */
if|if
condition|(
operator|(
name|encoffset
operator|+
name|enccrd
operator|->
name|crd_len
operator|)
operator|!=
operator|(
name|macoffset
operator|+
name|maccrd
operator|->
name|crd_len
operator|)
condition|)
block|{
name|ubsecstats
operator|.
name|hst_lenmismatch
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|enccrd
operator|->
name|crd_skip
operator|<
name|maccrd
operator|->
name|crd_skip
condition|)
block|{
name|ubsecstats
operator|.
name|hst_skipmismatch
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|sskip
operator|=
name|maccrd
operator|->
name|crd_skip
expr_stmt|;
name|cpskip
operator|=
name|dskip
operator|=
name|enccrd
operator|->
name|crd_skip
expr_stmt|;
name|stheend
operator|=
name|maccrd
operator|->
name|crd_len
expr_stmt|;
name|dtheend
operator|=
name|enccrd
operator|->
name|crd_len
expr_stmt|;
name|coffset
operator|=
name|enccrd
operator|->
name|crd_skip
operator|-
name|maccrd
operator|->
name|crd_skip
expr_stmt|;
name|cpoffset
operator|=
name|cpskip
operator|+
name|dtheend
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
block|{
name|printf
argument_list|(
literal|"mac: skip %d, len %d, inject %d\n"
argument_list|,
name|maccrd
operator|->
name|crd_skip
argument_list|,
name|maccrd
operator|->
name|crd_len
argument_list|,
name|maccrd
operator|->
name|crd_inject
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enc: skip %d, len %d, inject %d\n"
argument_list|,
name|enccrd
operator|->
name|crd_skip
argument_list|,
name|enccrd
operator|->
name|crd_len
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src: skip %d, len %d\n"
argument_list|,
name|sskip
argument_list|,
name|stheend
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst: skip %d, len %d\n"
argument_list|,
name|dskip
argument_list|,
name|dtheend
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ubs: coffset %d, pktlen %d, cpskip %d, cpoffset %d\n"
argument_list|,
name|coffset
argument_list|,
name|stheend
argument_list|,
name|cpskip
argument_list|,
name|cpoffset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|cpskip
operator|=
name|dskip
operator|=
name|sskip
operator|=
name|macoffset
operator|+
name|encoffset
expr_stmt|;
name|dtheend
operator|=
name|stheend
operator|=
operator|(
name|enccrd
operator|)
condition|?
name|enccrd
operator|->
name|crd_len
else|:
name|maccrd
operator|->
name|crd_len
expr_stmt|;
name|cpoffset
operator|=
name|cpskip
operator|+
name|dtheend
expr_stmt|;
name|coffset
operator|=
literal|0
expr_stmt|;
block|}
name|ctx
operator|.
name|pc_offset
operator|=
name|htole16
argument_list|(
name|coffset
operator|>>
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|q
operator|->
name|q_src_map
argument_list|)
condition|)
block|{
name|ubsecstats
operator|.
name|hst_nomap
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
if|if
condition|(
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|,
name|q
operator|->
name|q_src_m
argument_list|,
name|ubsec_op_cb
argument_list|,
operator|&
name|q
operator|->
name|q_src
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_src_map
operator|=
name|NULL
expr_stmt|;
name|ubsecstats
operator|.
name|hst_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
if|if
condition|(
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|,
name|q
operator|->
name|q_src_io
argument_list|,
name|ubsec_op_cb
argument_list|,
operator|&
name|q
operator|->
name|q_src
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_src_map
operator|=
name|NULL
expr_stmt|;
name|ubsecstats
operator|.
name|hst_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
name|nicealign
operator|=
name|ubsec_dmamap_aligned
argument_list|(
operator|&
name|q
operator|->
name|q_src
argument_list|)
expr_stmt|;
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_pktlen
operator|=
name|htole16
argument_list|(
name|stheend
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
name|printf
argument_list|(
literal|"src skip: %d nicealign: %u\n"
argument_list|,
name|sskip
argument_list|,
name|nicealign
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|q_src_nsegs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ubsec_pktbuf
modifier|*
name|pb
decl_stmt|;
name|bus_size_t
name|packl
init|=
name|q
operator|->
name|q_src_segs
index|[
name|i
index|]
operator|.
name|ds_len
decl_stmt|;
name|bus_addr_t
name|packp
init|=
name|q
operator|->
name|q_src_segs
index|[
name|i
index|]
operator|.
name|ds_addr
decl_stmt|;
if|if
condition|(
name|sskip
operator|>=
name|packl
condition|)
block|{
name|sskip
operator|-=
name|packl
expr_stmt|;
continue|continue;
block|}
name|packl
operator|-=
name|sskip
expr_stmt|;
name|packp
operator|+=
name|sskip
expr_stmt|;
name|sskip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|packl
operator|>
literal|0xfffc
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|pb
operator|=
operator|&
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_ipktbuf
expr_stmt|;
else|else
name|pb
operator|=
operator|&
name|dmap
operator|->
name|d_dma
operator|->
name|d_sbuf
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|pb
operator|->
name|pb_addr
operator|=
name|htole32
argument_list|(
name|packp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stheend
condition|)
block|{
if|if
condition|(
name|packl
operator|>
name|stheend
condition|)
block|{
name|pb
operator|->
name|pb_len
operator|=
name|htole32
argument_list|(
name|stheend
argument_list|)
expr_stmt|;
name|stheend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pb
operator|->
name|pb_len
operator|=
name|htole32
argument_list|(
name|packl
argument_list|)
expr_stmt|;
name|stheend
operator|-=
name|packl
expr_stmt|;
block|}
block|}
else|else
name|pb
operator|->
name|pb_len
operator|=
name|htole32
argument_list|(
name|packl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|q
operator|->
name|q_src_nsegs
condition|)
name|pb
operator|->
name|pb_next
operator|=
literal|0
expr_stmt|;
else|else
name|pb
operator|->
name|pb_next
operator|=
name|htole32
argument_list|(
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_sbuf
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|enccrd
operator|==
name|NULL
operator|&&
name|maccrd
operator|!=
name|NULL
condition|)
block|{
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_opktbuf
operator|.
name|pb_addr
operator|=
literal|0
expr_stmt|;
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_opktbuf
operator|.
name|pb_len
operator|=
literal|0
expr_stmt|;
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_opktbuf
operator|.
name|pb_next
operator|=
name|htole32
argument_list|(
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_macbuf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
name|printf
argument_list|(
literal|"opkt: %x %x %x\n"
argument_list|,
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_opktbuf
operator|.
name|pb_addr
argument_list|,
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_opktbuf
operator|.
name|pb_len
argument_list|,
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_opktbuf
operator|.
name|pb_next
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
if|if
condition|(
operator|!
name|nicealign
condition|)
block|{
name|ubsecstats
operator|.
name|hst_iovmisaligned
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|q
operator|->
name|q_dst_map
argument_list|)
condition|)
block|{
name|ubsecstats
operator|.
name|hst_nomap
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|,
name|q
operator|->
name|q_dst_io
argument_list|,
name|ubsec_op_cb
argument_list|,
operator|&
name|q
operator|->
name|q_dst
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_dst_map
operator|=
name|NULL
expr_stmt|;
name|ubsecstats
operator|.
name|hst_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
if|if
condition|(
name|nicealign
condition|)
block|{
name|q
operator|->
name|q_dst
operator|=
name|q
operator|->
name|q_src
expr_stmt|;
block|}
else|else
block|{
name|int
name|totlen
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|ubsecstats
operator|.
name|hst_unaligned
operator|++
expr_stmt|;
name|totlen
operator|=
name|q
operator|->
name|q_src_mapsize
expr_stmt|;
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|q
operator|->
name|q_src_m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
argument_list|)
expr_stmt|;
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|q_src_m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|len
operator|=
name|MHLEN
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|&&
name|q
operator|->
name|q_src_m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|&&
operator|!
name|m_dup_pkthdr
argument_list|(
name|m
argument_list|,
name|q
operator|->
name|q_src_m
argument_list|,
name|M_DONTWAIT
argument_list|)
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ubsecstats
operator|.
name|hst_nombuf
operator|++
expr_stmt|;
name|err
operator|=
name|sc
operator|->
name|sc_nqueue
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
name|top
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|ubsecstats
operator|.
name|hst_nombuf
operator|++
expr_stmt|;
name|err
operator|=
name|sc
operator|->
name|sc_nqueue
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|q
operator|->
name|q_dst_m
operator|=
name|top
expr_stmt|;
name|ubsec_mcopy
argument_list|(
name|q
operator|->
name|q_src_m
argument_list|,
name|q
operator|->
name|q_dst_m
argument_list|,
name|cpskip
argument_list|,
name|cpoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|q
operator|->
name|q_dst_map
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ubsecstats
operator|.
name|hst_nomap
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|,
name|q
operator|->
name|q_dst_m
argument_list|,
name|ubsec_op_cb
argument_list|,
operator|&
name|q
operator|->
name|q_dst
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_dst_map
operator|=
name|NULL
expr_stmt|;
name|ubsecstats
operator|.
name|hst_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
block|}
else|else
block|{
name|ubsecstats
operator|.
name|hst_badflags
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
name|printf
argument_list|(
literal|"dst skip: %d\n"
argument_list|,
name|dskip
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|q_dst_nsegs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ubsec_pktbuf
modifier|*
name|pb
decl_stmt|;
name|bus_size_t
name|packl
init|=
name|q
operator|->
name|q_dst_segs
index|[
name|i
index|]
operator|.
name|ds_len
decl_stmt|;
name|bus_addr_t
name|packp
init|=
name|q
operator|->
name|q_dst_segs
index|[
name|i
index|]
operator|.
name|ds_addr
decl_stmt|;
if|if
condition|(
name|dskip
operator|>=
name|packl
condition|)
block|{
name|dskip
operator|-=
name|packl
expr_stmt|;
continue|continue;
block|}
name|packl
operator|-=
name|dskip
expr_stmt|;
name|packp
operator|+=
name|dskip
expr_stmt|;
name|dskip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|packl
operator|>
literal|0xfffc
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|pb
operator|=
operator|&
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_opktbuf
expr_stmt|;
else|else
name|pb
operator|=
operator|&
name|dmap
operator|->
name|d_dma
operator|->
name|d_dbuf
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|pb
operator|->
name|pb_addr
operator|=
name|htole32
argument_list|(
name|packp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtheend
condition|)
block|{
if|if
condition|(
name|packl
operator|>
name|dtheend
condition|)
block|{
name|pb
operator|->
name|pb_len
operator|=
name|htole32
argument_list|(
name|dtheend
argument_list|)
expr_stmt|;
name|dtheend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pb
operator|->
name|pb_len
operator|=
name|htole32
argument_list|(
name|packl
argument_list|)
expr_stmt|;
name|dtheend
operator|-=
name|packl
expr_stmt|;
block|}
block|}
else|else
name|pb
operator|->
name|pb_len
operator|=
name|htole32
argument_list|(
name|packl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|q
operator|->
name|q_dst_nsegs
condition|)
block|{
if|if
condition|(
name|maccrd
condition|)
name|pb
operator|->
name|pb_next
operator|=
name|htole32
argument_list|(
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_macbuf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pb
operator|->
name|pb_next
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pb
operator|->
name|pb_next
operator|=
name|htole32
argument_list|(
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_dbuf
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|dmap
operator|->
name|d_dma
operator|->
name|d_mcr
operator|.
name|mcr_cmdctxp
operator|=
name|htole32
argument_list|(
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_LONGCTX
condition|)
block|{
name|struct
name|ubsec_pktctx_long
modifier|*
name|ctxl
decl_stmt|;
name|ctxl
operator|=
operator|(
expr|struct
name|ubsec_pktctx_long
operator|*
operator|)
operator|(
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_vaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_ctx
argument_list|)
operator|)
expr_stmt|;
comment|/* transform small context into long context */
name|ctxl
operator|->
name|pc_len
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_pktctx_long
argument_list|)
argument_list|)
expr_stmt|;
name|ctxl
operator|->
name|pc_type
operator|=
name|htole16
argument_list|(
name|UBS_PKTCTX_TYPE_IPSEC
argument_list|)
expr_stmt|;
name|ctxl
operator|->
name|pc_flags
operator|=
name|ctx
operator|.
name|pc_flags
expr_stmt|;
name|ctxl
operator|->
name|pc_offset
operator|=
name|ctx
operator|.
name|pc_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|ctxl
operator|->
name|pc_deskey
index|[
name|i
index|]
operator|=
name|ctx
operator|.
name|pc_deskey
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|ctxl
operator|->
name|pc_hminner
index|[
name|i
index|]
operator|=
name|ctx
operator|.
name|pc_hminner
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|ctxl
operator|->
name|pc_hmouter
index|[
name|i
index|]
operator|=
name|ctx
operator|.
name|pc_hmouter
index|[
name|i
index|]
expr_stmt|;
name|ctxl
operator|->
name|pc_iv
index|[
literal|0
index|]
operator|=
name|ctx
operator|.
name|pc_iv
index|[
literal|0
index|]
expr_stmt|;
name|ctxl
operator|->
name|pc_iv
index|[
literal|1
index|]
operator|=
name|ctx
operator|.
name|pc_iv
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|&
name|ctx
argument_list|,
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_vaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ubsec_dmachunk
argument_list|,
name|d_ctx
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_pktctx
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr1lock
argument_list|)
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nqueue
operator|++
expr_stmt|;
name|ubsecstats
operator|.
name|hst_ipackets
operator|++
expr_stmt|;
name|ubsecstats
operator|.
name|hst_ibytes
operator|+=
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_size
expr_stmt|;
if|if
condition|(
operator|(
name|hint
operator|&
name|CRYPTO_HINT_MORE
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_nqueue
operator|>=
name|UBS_MAX_AGGR
condition|)
name|ubsec_feed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr1lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|errout
label|:
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|q_dst_m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|q
operator|->
name|q_src_m
operator|!=
name|q
operator|->
name|q_dst_m
operator|)
condition|)
name|m_freem
argument_list|(
name|q
operator|->
name|q_dst_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_dst_map
operator|!=
name|NULL
operator|&&
name|q
operator|->
name|q_dst_map
operator|!=
name|q
operator|->
name|q_src_map
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|q_src_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|!=
name|NULL
operator|||
name|err
operator|==
name|ERESTART
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|,
name|q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERESTART
condition|)
name|sc
operator|->
name|sc_needwakeup
operator||=
name|CRYPTO_SYMQ
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|ERESTART
condition|)
block|{
name|crp
operator|->
name|crp_etype
operator|=
name|err
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_callback
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ubsec_q
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|cryptop
modifier|*
name|crp
init|=
operator|(
expr|struct
name|cryptop
operator|*
operator|)
name|q
operator|->
name|q_crp
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|struct
name|ubsec_dma
modifier|*
name|dmap
init|=
name|q
operator|->
name|q_dma
decl_stmt|;
name|ubsecstats
operator|.
name|hst_opackets
operator|++
expr_stmt|;
name|ubsecstats
operator|.
name|hst_obytes
operator|+=
name|dmap
operator|->
name|d_alloc
operator|.
name|dma_size
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|dmap
operator|->
name|d_alloc
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_dst_map
operator|!=
name|NULL
operator|&&
name|q
operator|->
name|q_dst_map
operator|!=
name|q
operator|->
name|q_src_map
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_dst_map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|q
operator|->
name|q_src_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
operator|)
operator|&&
operator|(
name|q
operator|->
name|q_src_m
operator|!=
name|q
operator|->
name|q_dst_m
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|q
operator|->
name|q_src_m
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|caddr_t
operator|)
name|q
operator|->
name|q_dst_m
expr_stmt|;
block|}
comment|/* copy out IV for future use */
if|if
condition|(
name|q
operator|->
name|q_flags
operator|&
name|UBSEC_QFLAGS_COPYOUTIV
condition|)
block|{
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_DES_CBC
operator|&&
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_3DES_CBC
condition|)
continue|continue;
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_skip
operator|+
name|crd
operator|->
name|crd_len
operator|-
literal|8
argument_list|,
literal|8
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_sessions
index|[
name|q
operator|->
name|q_sesn
index|]
operator|.
name|ses_iv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_MD5_HMAC
operator|&&
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_SHA1_HMAC
condition|)
continue|continue;
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|sc
operator|->
name|sc_sessions
index|[
name|q
operator|->
name|q_sesn
index|]
operator|.
name|ses_mlen
argument_list|,
operator|(
name|caddr_t
operator|)
name|dmap
operator|->
name|d_dma
operator|->
name|d_macbuf
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|,
name|q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_freeqlock
argument_list|)
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_mcopy
parameter_list|(
name|struct
name|mbuf
modifier|*
name|srcm
parameter_list|,
name|struct
name|mbuf
modifier|*
name|dstm
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|toffset
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|dlen
decl_stmt|,
name|slen
decl_stmt|;
name|caddr_t
name|dptr
decl_stmt|,
name|sptr
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|sptr
operator|=
name|srcm
operator|->
name|m_data
expr_stmt|;
name|slen
operator|=
name|srcm
operator|->
name|m_len
expr_stmt|;
name|dptr
operator|=
name|dstm
operator|->
name|m_data
expr_stmt|;
name|dlen
operator|=
name|dstm
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min
argument_list|(
name|slen
argument_list|,
name|dlen
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|hoffset
operator|||
name|j
operator|>=
name|toffset
condition|)
operator|*
name|dptr
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|slen
operator|--
expr_stmt|;
name|dlen
operator|--
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|slen
operator|==
literal|0
condition|)
block|{
name|srcm
operator|=
name|srcm
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|srcm
operator|==
name|NULL
condition|)
return|return;
name|sptr
operator|=
name|srcm
operator|->
name|m_data
expr_stmt|;
name|slen
operator|=
name|srcm
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|dlen
operator|==
literal|0
condition|)
block|{
name|dstm
operator|=
name|dstm
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|dstm
operator|==
name|NULL
condition|)
return|return;
name|dptr
operator|=
name|dstm
operator|->
name|m_data
expr_stmt|;
name|dlen
operator|=
name|dstm
operator|->
name|m_len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * feed the key generator, must be called at splimp() or higher.  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_feed2
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ubsec_q2
modifier|*
name|q
decl_stmt|;
while|while
condition|(
operator|!
name|SIMPLEQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue2
argument_list|)
condition|)
block|{
if|if
condition|(
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|BS_STAT
argument_list|)
operator|&
name|BS_STAT_MCR2_FULL
condition|)
break|break;
name|q
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue2
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|q
operator|->
name|q_mcr
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|q
operator|->
name|q_ctx
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|BS_MCR2
argument_list|,
name|q
operator|->
name|q_mcr
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue2
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
operator|--
name|sc
operator|->
name|sc_nqueue2
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip2
argument_list|,
name|q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback for handling random numbers  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_callback2
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ubsec_q2
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|cryptkop
modifier|*
name|krp
decl_stmt|;
name|struct
name|ubsec_ctx_keyop
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|ubsec_ctx_keyop
operator|*
operator|)
name|q
operator|->
name|q_ctx
operator|.
name|dma_vaddr
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|q
operator|->
name|q_ctx
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|q
operator|->
name|q_type
condition|)
block|{
ifndef|#
directive|ifndef
name|UBSEC_NO_RNG
case|case
name|UBS_CTXOP_RNGBYPASS
case|:
block|{
name|struct
name|ubsec_q2_rng
modifier|*
name|rng
init|=
operator|(
expr|struct
name|ubsec_q2_rng
operator|*
operator|)
name|q
decl_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|rng
operator|->
name|rng_buf
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_harvest
call|)
argument_list|(
name|sc
operator|->
name|sc_rndtest
argument_list|,
name|rng
operator|->
name|rng_buf
operator|.
name|dma_vaddr
argument_list|,
name|UBSEC_RNG_BUFSIZ
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|rng
operator|->
name|rng_used
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|sc
operator|->
name|sc_rnghz
argument_list|,
name|ubsec_rng
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|UBS_CTXOP_MODEXP
case|:
block|{
name|struct
name|ubsec_q2_modexp
modifier|*
name|me
init|=
operator|(
expr|struct
name|ubsec_q2_modexp
operator|*
operator|)
name|q
decl_stmt|;
name|u_int
name|rlen
decl_stmt|,
name|clen
decl_stmt|;
name|krp
operator|=
name|me
operator|->
name|me_krp
expr_stmt|;
name|rlen
operator|=
operator|(
name|me
operator|->
name|me_modbits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|clen
operator|=
operator|(
name|krp
operator|->
name|krp_param
index|[
name|krp
operator|->
name|krp_iparams
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_M
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_E
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_C
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_epb
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|<
name|rlen
condition|)
name|krp
operator|->
name|krp_status
operator|=
name|E2BIG
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_HWNORM
condition|)
block|{
name|bzero
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|krp
operator|->
name|krp_iparams
index|]
operator|.
name|crp_p
argument_list|,
operator|(
name|krp
operator|->
name|krp_param
index|[
name|krp
operator|->
name|krp_iparams
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|me
operator|->
name|me_C
operator|.
name|dma_vaddr
argument_list|,
name|krp
operator|->
name|krp_param
index|[
name|krp
operator|->
name|krp_iparams
index|]
operator|.
name|crp_p
argument_list|,
operator|(
name|me
operator|->
name|me_modbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|ubsec_kshift_l
argument_list|(
name|me
operator|->
name|me_shiftbits
argument_list|,
name|me
operator|->
name|me_C
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_normbits
argument_list|,
name|krp
operator|->
name|krp_param
index|[
name|krp
operator|->
name|krp_iparams
index|]
operator|.
name|crp_p
argument_list|,
name|krp
operator|->
name|krp_param
index|[
name|krp
operator|->
name|krp_iparams
index|]
operator|.
name|crp_nbits
argument_list|)
expr_stmt|;
block|}
name|crypto_kdone
argument_list|(
name|krp
argument_list|)
expr_stmt|;
comment|/* bzero all potentially sensitive data */
name|bzero
argument_list|(
name|me
operator|->
name|me_E
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_E
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|me
operator|->
name|me_M
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_M
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|me
operator|->
name|me_C
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_C
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_size
argument_list|)
expr_stmt|;
comment|/* Can't free here, so put us on the free list. */
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_q2free
argument_list|,
operator|&
name|me
operator|->
name|me_q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UBS_CTXOP_RSAPRIV
case|:
block|{
name|struct
name|ubsec_q2_rsapriv
modifier|*
name|rp
init|=
operator|(
expr|struct
name|ubsec_q2_rsapriv
operator|*
operator|)
name|q
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|krp
operator|=
name|rp
operator|->
name|rpr_krp
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|rp
operator|->
name|rpr_msgin
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|rp
operator|->
name|rpr_msgout
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_MSGOUT
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|bcopy
argument_list|(
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_vaddr
argument_list|,
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_MSGOUT
index|]
operator|.
name|crp_p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|crypto_kdone
argument_list|(
name|krp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_vaddr
argument_list|,
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_vaddr
argument_list|,
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rp
operator|->
name|rpr_q
operator|.
name|q_ctx
operator|.
name|dma_vaddr
argument_list|,
name|rp
operator|->
name|rpr_q
operator|.
name|q_ctx
operator|.
name|dma_size
argument_list|)
expr_stmt|;
comment|/* Can't free here, so put us on the free list. */
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_q2free
argument_list|,
operator|&
name|rp
operator|->
name|rpr_q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown ctx op: %x\n"
argument_list|,
name|letoh16
argument_list|(
name|ctx
operator|->
name|ctx_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|UBSEC_NO_RNG
end_ifndef

begin_function
specifier|static
name|void
name|ubsec_rng
parameter_list|(
name|void
modifier|*
name|vsc
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|vsc
decl_stmt|;
name|struct
name|ubsec_q2_rng
modifier|*
name|rng
init|=
operator|&
name|sc
operator|->
name|sc_rng
decl_stmt|;
name|struct
name|ubsec_mcr
modifier|*
name|mcr
decl_stmt|;
name|struct
name|ubsec_ctx_rngbypass
modifier|*
name|ctx
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rng
operator|->
name|rng_used
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_nqueue2
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nqueue2
operator|>=
name|UBS_MAX_NQUEUE
condition|)
goto|goto
name|out
goto|;
name|mcr
operator|=
operator|(
expr|struct
name|ubsec_mcr
operator|*
operator|)
name|rng
operator|->
name|rng_q
operator|.
name|q_mcr
operator|.
name|dma_vaddr
expr_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|ubsec_ctx_rngbypass
operator|*
operator|)
name|rng
operator|->
name|rng_q
operator|.
name|q_ctx
operator|.
name|dma_vaddr
expr_stmt|;
name|mcr
operator|->
name|mcr_pkts
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_flags
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_cmdctxp
operator|=
name|htole32
argument_list|(
name|rng
operator|->
name|rng_q
operator|.
name|q_ctx
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_addr
operator|=
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_next
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_len
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_reserved
operator|=
name|mcr
operator|->
name|mcr_pktlen
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_addr
operator|=
name|htole32
argument_list|(
name|rng
operator|->
name|rng_buf
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_len
operator|=
name|htole32
argument_list|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
name|UBSEC_RNG_BUFSIZ
operator|)
operator|)
operator|&
name|UBS_PKTBUF_LEN
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_next
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|rbp_len
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_ctx_rngbypass
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rbp_op
operator|=
name|htole16
argument_list|(
name|UBS_CTXOP_RNGBYPASS
argument_list|)
expr_stmt|;
name|rng
operator|->
name|rng_q
operator|.
name|q_type
operator|=
name|UBS_CTXOP_RNGBYPASS
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|rng
operator|->
name|rng_buf
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue2
argument_list|,
operator|&
name|rng
operator|->
name|rng_q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|rng
operator|->
name|rng_used
operator|=
literal|1
expr_stmt|;
name|ubsec_feed2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ubsecstats
operator|.
name|hst_rng
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
return|return;
name|out
label|:
comment|/* 	 * Something weird happened, generate our own call back. 	 */
name|sc
operator|->
name|sc_nqueue2
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|sc
operator|->
name|sc_rnghz
argument_list|,
name|ubsec_rng
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UBSEC_NO_RNG */
end_comment

begin_function
specifier|static
name|void
name|ubsec_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ubsec_dma_malloc
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|ubsec_dma_alloc
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* XXX could specify sc_dmat as parent but that just adds overhead */
name|r
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"ubsec_dma_malloc: "
literal|"bus_dma_tag_create failed; error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|r
operator|=
name|bus_dmamap_create
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"ubsec_dma_malloc: "
literal|"bus_dmamap_create failed; error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_1
goto|;
block|}
name|r
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"ubsec_dma_malloc: "
literal|"bus_dmammem_alloc failed; size %zu, error %u\n"
argument_list|,
name|size
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|r
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|ubsec_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"ubsec_dma_malloc: "
literal|"bus_dmamap_load failed; error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_3
goto|;
block|}
name|dma
operator|->
name|dma_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_3
label|:
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_1
label|:
name|bus_dmamap_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|dma_map
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_dma_free
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ubsec_dma_alloc
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resets the board.  Values in the regesters are left as is  * from the reset (i.e. initial values are assigned elsewhere).  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_reset_board
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|volatile
name|u_int32_t
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|BS_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|BS_CTRL_RESET
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|BS_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/*      * Wait aprox. 30 PCI clocks = 900 ns = 0.9 us      */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Init Broadcom registers  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_init_board
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|BS_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|BS_CTRL_BE32
operator||
name|BS_CTRL_BE64
operator|)
expr_stmt|;
name|ctrl
operator||=
name|BS_CTRL_LITTLE_ENDIAN
operator||
name|BS_CTRL_MCR1INT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|UBS_FLAGS_KEY
operator||
name|UBS_FLAGS_RNG
operator|)
condition|)
name|ctrl
operator||=
name|BS_CTRL_MCR2INT
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|BS_CTRL_MCR2INT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_HWNORM
condition|)
name|ctrl
operator|&=
operator|~
name|BS_CTRL_SWNORM
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|BS_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Init Broadcom PCI registers  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_init_pciregs
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|#
directive|if
literal|0
block|u_int32_t misc;  	misc = pci_conf_read(pc, pa->pa_tag, BS_RTY_TOUT); 	misc = (misc& ~(UBS_PCI_RTY_MASK<< UBS_PCI_RTY_SHIFT)) 	    | ((UBS_DEF_RTY& 0xff)<< UBS_PCI_RTY_SHIFT); 	misc = (misc& ~(UBS_PCI_TOUT_MASK<< UBS_PCI_TOUT_SHIFT)) 	    | ((UBS_DEF_TOUT& 0xff)<< UBS_PCI_TOUT_SHIFT); 	pci_conf_write(pc, pa->pa_tag, BS_RTY_TOUT, misc);
endif|#
directive|endif
comment|/* 	 * This will set the cache line size to 1, this will 	 * force the BCM58xx chip just to do burst read/writes. 	 * Cache line read/writes are to slow 	 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|UBS_DEF_CACHELINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean up after a chip crash.  * It is assumed that the caller in splimp()  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_cleanchip
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ubsec_q
modifier|*
name|q
decl_stmt|;
while|while
condition|(
operator|!
name|SIMPLEQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|)
condition|)
block|{
name|q
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|)
expr_stmt|;
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_qchip
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|ubsec_free_q
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_nqchip
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free a ubsec_q  * It is assumed that the caller is within splimp().  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_free_q
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ubsec_q
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|ubsec_q
modifier|*
name|q2
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|int
name|npkts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|npkts
operator|=
name|q
operator|->
name|q_nstacked_mcrs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npkts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|q_stacked_mcr
index|[
name|i
index|]
condition|)
block|{
name|q2
operator|=
name|q
operator|->
name|q_stacked_mcr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|q2
operator|->
name|q_dst_m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|q2
operator|->
name|q_src_m
operator|!=
name|q2
operator|->
name|q_dst_m
operator|)
condition|)
name|m_freem
argument_list|(
name|q2
operator|->
name|q_dst_m
argument_list|)
expr_stmt|;
name|crp
operator|=
operator|(
expr|struct
name|cryptop
operator|*
operator|)
name|q2
operator|->
name|q_crp
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|,
name|q2
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|EFAULT
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* 	 * Free header MCR 	 */
if|if
condition|(
operator|(
name|q
operator|->
name|q_dst_m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|q
operator|->
name|q_src_m
operator|!=
name|q
operator|->
name|q_dst_m
operator|)
condition|)
name|m_freem
argument_list|(
name|q
operator|->
name|q_dst_m
argument_list|)
expr_stmt|;
name|crp
operator|=
operator|(
expr|struct
name|cryptop
operator|*
operator|)
name|q
operator|->
name|q_crp
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_freequeue
argument_list|,
name|q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|EFAULT
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routine to reset the chip and clean up.  * It is assumed that the caller is in splimp()  */
end_comment

begin_function
specifier|static
name|void
name|ubsec_totalreset
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ubsec_reset_board
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ubsec_init_board
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ubsec_cleanchip
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ubsec_dmamap_aligned
parameter_list|(
name|struct
name|ubsec_operand
modifier|*
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op
operator|->
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|&
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|!=
operator|(
name|op
operator|->
name|nsegs
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|op
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|&
literal|3
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_kfree
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ubsec_q2
modifier|*
name|q
parameter_list|)
block|{
switch|switch
condition|(
name|q
operator|->
name|q_type
condition|)
block|{
case|case
name|UBS_CTXOP_MODEXP
case|:
block|{
name|struct
name|ubsec_q2_modexp
modifier|*
name|me
init|=
operator|(
expr|struct
name|ubsec_q2_modexp
operator|*
operator|)
name|q
decl_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_mcr
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_ctx
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_M
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_E
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_C
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_epb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|me
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UBS_CTXOP_RSAPRIV
case|:
block|{
name|struct
name|ubsec_q2_rsapriv
modifier|*
name|rp
init|=
operator|(
expr|struct
name|ubsec_q2_rsapriv
operator|*
operator|)
name|q
decl_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|rp
operator|->
name|rpr_q
operator|.
name|q_mcr
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|rp
operator|->
name|rpr_q
operator|.
name|q_ctx
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|rp
operator|->
name|rpr_msgin
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|rp
operator|->
name|rpr_msgout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid kfree 0x%x\n"
argument_list|,
name|q
operator|->
name|q_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ubsec_kprocess
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cryptkop
modifier|*
name|krp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|ubsec_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|krp
operator|==
name|NULL
operator|||
name|krp
operator|->
name|krp_callback
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
while|while
condition|(
operator|!
name|SIMPLEQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_q2free
argument_list|)
condition|)
block|{
name|struct
name|ubsec_q2
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_q2free
argument_list|)
expr_stmt|;
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_q2free
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|ubsec_kfree
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|krp
operator|->
name|krp_op
condition|)
block|{
case|case
name|CRK_MOD_EXP
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_HWNORM
condition|)
name|r
operator|=
name|ubsec_kprocess_modexp_hw
argument_list|(
name|sc
argument_list|,
name|krp
argument_list|,
name|hint
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|ubsec_kprocess_modexp_sw
argument_list|(
name|sc
argument_list|,
name|krp
argument_list|,
name|hint
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRK_MOD_EXP_CRT
case|:
return|return
operator|(
name|ubsec_kprocess_rsapriv
argument_list|(
name|sc
argument_list|,
name|krp
argument_list|,
name|hint
argument_list|)
operator|)
return|;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"kprocess: invalid op 0x%x\n"
argument_list|,
name|krp
operator|->
name|krp_op
argument_list|)
expr_stmt|;
name|krp
operator|->
name|krp_status
operator|=
name|EOPNOTSUPP
expr_stmt|;
name|crypto_kdone
argument_list|(
name|krp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* silence compiler */
block|}
end_function

begin_comment
comment|/*  * Start computation of cr[C] = (cr[M] ^ cr[E]) mod cr[N] (sw normalization)  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_kprocess_modexp_sw
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cryptkop
modifier|*
name|krp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|ubsec_q2_modexp
modifier|*
name|me
decl_stmt|;
name|struct
name|ubsec_mcr
modifier|*
name|mcr
decl_stmt|;
name|struct
name|ubsec_ctx_modexp
modifier|*
name|ctx
decl_stmt|;
name|struct
name|ubsec_pktbuf
modifier|*
name|epb
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u_int
name|nbits
decl_stmt|,
name|normbits
decl_stmt|,
name|mbits
decl_stmt|,
name|shiftbits
decl_stmt|,
name|ebits
decl_stmt|;
name|me
operator|=
operator|(
expr|struct
name|ubsec_q2_modexp
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|me
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|bzero
argument_list|(
name|me
argument_list|,
sizeof|sizeof
expr|*
name|me
argument_list|)
expr_stmt|;
name|me
operator|->
name|me_krp
operator|=
name|krp
expr_stmt|;
name|me
operator|->
name|me_q
operator|.
name|q_type
operator|=
name|UBS_CTXOP_MODEXP
expr_stmt|;
name|nbits
operator|=
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_N
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|<=
literal|512
condition|)
name|normbits
operator|=
literal|512
expr_stmt|;
elseif|else
if|if
condition|(
name|nbits
operator|<=
literal|768
condition|)
name|normbits
operator|=
literal|768
expr_stmt|;
elseif|else
if|if
condition|(
name|nbits
operator|<=
literal|1024
condition|)
name|normbits
operator|=
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_BIGKEY
operator|&&
name|nbits
operator|<=
literal|1536
condition|)
name|normbits
operator|=
literal|1536
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_BIGKEY
operator|&&
name|nbits
operator|<=
literal|2048
condition|)
name|normbits
operator|=
literal|2048
expr_stmt|;
else|else
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|shiftbits
operator|=
name|normbits
operator|-
name|nbits
expr_stmt|;
name|me
operator|->
name|me_modbits
operator|=
name|nbits
expr_stmt|;
name|me
operator|->
name|me_shiftbits
operator|=
name|shiftbits
expr_stmt|;
name|me
operator|->
name|me_normbits
operator|=
name|normbits
expr_stmt|;
comment|/* Sanity check: result bits must be>= true modulus bits. */
if|if
condition|(
name|krp
operator|->
name|krp_param
index|[
name|krp
operator|->
name|krp_iparams
index|]
operator|.
name|crp_nbits
operator|<
name|nbits
condition|)
block|{
name|err
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_mcr
argument_list|)
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_mcr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|mcr
operator|=
operator|(
expr|struct
name|ubsec_mcr
operator|*
operator|)
name|me
operator|->
name|me_q
operator|.
name|q_mcr
operator|.
name|dma_vaddr
expr_stmt|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_ctx_modexp
argument_list|)
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_ctx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|mbits
operator|=
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_M
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbits
operator|>
name|nbits
condition|)
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
name|normbits
operator|/
literal|8
argument_list|,
operator|&
name|me
operator|->
name|me_M
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|ubsec_kshift_r
argument_list|(
name|shiftbits
argument_list|,
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_M
index|]
operator|.
name|crp_p
argument_list|,
name|mbits
argument_list|,
name|me
operator|->
name|me_M
operator|.
name|dma_vaddr
argument_list|,
name|normbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
name|normbits
operator|/
literal|8
argument_list|,
operator|&
name|me
operator|->
name|me_C
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|bzero
argument_list|(
name|me
operator|->
name|me_C
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_C
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ebits
operator|=
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_E
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ebits
operator|>
name|nbits
condition|)
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
name|normbits
operator|/
literal|8
argument_list|,
operator|&
name|me
operator|->
name|me_E
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|ubsec_kshift_r
argument_list|(
name|shiftbits
argument_list|,
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_E
index|]
operator|.
name|crp_p
argument_list|,
name|ebits
argument_list|,
name|me
operator|->
name|me_E
operator|.
name|dma_vaddr
argument_list|,
name|normbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_pktbuf
argument_list|)
argument_list|,
operator|&
name|me
operator|->
name|me_epb
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|epb
operator|=
operator|(
expr|struct
name|ubsec_pktbuf
operator|*
operator|)
name|me
operator|->
name|me_epb
operator|.
name|dma_vaddr
expr_stmt|;
name|epb
operator|->
name|pb_addr
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_E
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|epb
operator|->
name|pb_next
operator|=
literal|0
expr_stmt|;
name|epb
operator|->
name|pb_len
operator|=
name|htole32
argument_list|(
name|normbits
operator|/
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Epb "
argument_list|)
expr_stmt|;
name|ubsec_dump_pb
argument_list|(
name|epb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mcr
operator|->
name|mcr_pkts
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_flags
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_cmdctxp
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_reserved
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_pktlen
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_addr
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_M
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_len
operator|=
name|htole32
argument_list|(
name|normbits
operator|/
literal|8
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_next
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_epb
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_addr
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_C
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_next
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_len
operator|=
name|htole32
argument_list|(
name|normbits
operator|/
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Misaligned output buffer will hang the chip. */
if|if
condition|(
operator|(
name|letoh32
argument_list|(
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_addr
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: modexp invalid addr 0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|letoh32
argument_list|(
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|letoh32
argument_list|(
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_len
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: modexp invalid len 0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|letoh32
argument_list|(
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_len
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|=
operator|(
expr|struct
name|ubsec_ctx_modexp
operator|*
operator|)
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ubsec_kshift_r
argument_list|(
name|shiftbits
argument_list|,
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_N
index|]
operator|.
name|crp_p
argument_list|,
name|nbits
argument_list|,
name|ctx
operator|->
name|me_N
argument_list|,
name|normbits
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|me_len
operator|=
name|htole16
argument_list|(
operator|(
name|normbits
operator|/
literal|8
operator|)
operator|+
operator|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|me_op
operator|=
name|htole16
argument_list|(
name|UBS_CTXOP_MODEXP
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|me_E_len
operator|=
name|htole16
argument_list|(
name|nbits
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|me_N_len
operator|=
name|htole16
argument_list|(
name|nbits
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
block|{
name|ubsec_dump_mcr
argument_list|(
name|mcr
argument_list|)
expr_stmt|;
name|ubsec_dump_ctx2
argument_list|(
operator|(
expr|struct
name|ubsec_ctx_keyop
operator|*
operator|)
name|ctx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * ubsec_feed2 will sync mcr and ctx, we just need to sync 	 * everything else. 	 */
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_M
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_E
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_C
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_epb
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Enqueue and we're done... */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue2
argument_list|,
operator|&
name|me
operator|->
name|me_q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|ubsec_feed2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ubsecstats
operator|.
name|hst_modexp
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|errout
label|:
if|if
condition|(
name|me
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|me
operator|->
name|me_q
operator|.
name|q_mcr
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_mcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|me_M
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|me
operator|->
name|me_M
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_M
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_M
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|me_E
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|me
operator|->
name|me_E
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_E
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_E
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|me_C
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|me
operator|->
name|me_C
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_C
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_C
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|me_epb
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_epb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|me
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|krp
operator|->
name|krp_status
operator|=
name|err
expr_stmt|;
name|crypto_kdone
argument_list|(
name|krp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start computation of cr[C] = (cr[M] ^ cr[E]) mod cr[N] (hw normalization)  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_kprocess_modexp_hw
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cryptkop
modifier|*
name|krp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|ubsec_q2_modexp
modifier|*
name|me
decl_stmt|;
name|struct
name|ubsec_mcr
modifier|*
name|mcr
decl_stmt|;
name|struct
name|ubsec_ctx_modexp
modifier|*
name|ctx
decl_stmt|;
name|struct
name|ubsec_pktbuf
modifier|*
name|epb
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u_int
name|nbits
decl_stmt|,
name|normbits
decl_stmt|,
name|mbits
decl_stmt|,
name|shiftbits
decl_stmt|,
name|ebits
decl_stmt|;
name|me
operator|=
operator|(
expr|struct
name|ubsec_q2_modexp
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|me
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|bzero
argument_list|(
name|me
argument_list|,
sizeof|sizeof
expr|*
name|me
argument_list|)
expr_stmt|;
name|me
operator|->
name|me_krp
operator|=
name|krp
expr_stmt|;
name|me
operator|->
name|me_q
operator|.
name|q_type
operator|=
name|UBS_CTXOP_MODEXP
expr_stmt|;
name|nbits
operator|=
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_N
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|<=
literal|512
condition|)
name|normbits
operator|=
literal|512
expr_stmt|;
elseif|else
if|if
condition|(
name|nbits
operator|<=
literal|768
condition|)
name|normbits
operator|=
literal|768
expr_stmt|;
elseif|else
if|if
condition|(
name|nbits
operator|<=
literal|1024
condition|)
name|normbits
operator|=
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_BIGKEY
operator|&&
name|nbits
operator|<=
literal|1536
condition|)
name|normbits
operator|=
literal|1536
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_BIGKEY
operator|&&
name|nbits
operator|<=
literal|2048
condition|)
name|normbits
operator|=
literal|2048
expr_stmt|;
else|else
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|shiftbits
operator|=
name|normbits
operator|-
name|nbits
expr_stmt|;
comment|/* XXX ??? */
name|me
operator|->
name|me_modbits
operator|=
name|nbits
expr_stmt|;
name|me
operator|->
name|me_shiftbits
operator|=
name|shiftbits
expr_stmt|;
name|me
operator|->
name|me_normbits
operator|=
name|normbits
expr_stmt|;
comment|/* Sanity check: result bits must be>= true modulus bits. */
if|if
condition|(
name|krp
operator|->
name|krp_param
index|[
name|krp
operator|->
name|krp_iparams
index|]
operator|.
name|crp_nbits
operator|<
name|nbits
condition|)
block|{
name|err
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_mcr
argument_list|)
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_mcr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|mcr
operator|=
operator|(
expr|struct
name|ubsec_mcr
operator|*
operator|)
name|me
operator|->
name|me_q
operator|.
name|q_mcr
operator|.
name|dma_vaddr
expr_stmt|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_ctx_modexp
argument_list|)
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_ctx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|mbits
operator|=
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_M
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbits
operator|>
name|nbits
condition|)
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
name|normbits
operator|/
literal|8
argument_list|,
operator|&
name|me
operator|->
name|me_M
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|bzero
argument_list|(
name|me
operator|->
name|me_M
operator|.
name|dma_vaddr
argument_list|,
name|normbits
operator|/
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_M
index|]
operator|.
name|crp_p
argument_list|,
name|me
operator|->
name|me_M
operator|.
name|dma_vaddr
argument_list|,
operator|(
name|mbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
name|normbits
operator|/
literal|8
argument_list|,
operator|&
name|me
operator|->
name|me_C
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|bzero
argument_list|(
name|me
operator|->
name|me_C
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_C
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ebits
operator|=
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_E
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ebits
operator|>
name|nbits
condition|)
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
name|normbits
operator|/
literal|8
argument_list|,
operator|&
name|me
operator|->
name|me_E
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|bzero
argument_list|(
name|me
operator|->
name|me_E
operator|.
name|dma_vaddr
argument_list|,
name|normbits
operator|/
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_E
index|]
operator|.
name|crp_p
argument_list|,
name|me
operator|->
name|me_E
operator|.
name|dma_vaddr
argument_list|,
operator|(
name|ebits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_pktbuf
argument_list|)
argument_list|,
operator|&
name|me
operator|->
name|me_epb
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|epb
operator|=
operator|(
expr|struct
name|ubsec_pktbuf
operator|*
operator|)
name|me
operator|->
name|me_epb
operator|.
name|dma_vaddr
expr_stmt|;
name|epb
operator|->
name|pb_addr
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_E
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|epb
operator|->
name|pb_next
operator|=
literal|0
expr_stmt|;
name|epb
operator|->
name|pb_len
operator|=
name|htole32
argument_list|(
operator|(
name|ebits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Epb "
argument_list|)
expr_stmt|;
name|ubsec_dump_pb
argument_list|(
name|epb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mcr
operator|->
name|mcr_pkts
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_flags
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_cmdctxp
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_reserved
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_pktlen
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_addr
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_M
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_len
operator|=
name|htole32
argument_list|(
name|normbits
operator|/
literal|8
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_next
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_epb
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_addr
operator|=
name|htole32
argument_list|(
name|me
operator|->
name|me_C
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_next
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_len
operator|=
name|htole32
argument_list|(
name|normbits
operator|/
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Misaligned output buffer will hang the chip. */
if|if
condition|(
operator|(
name|letoh32
argument_list|(
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_addr
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: modexp invalid addr 0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|letoh32
argument_list|(
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|letoh32
argument_list|(
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_len
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: modexp invalid len 0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|letoh32
argument_list|(
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_len
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|=
operator|(
expr|struct
name|ubsec_ctx_modexp
operator|*
operator|)
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_MODEXP_PAR_N
index|]
operator|.
name|crp_p
argument_list|,
name|ctx
operator|->
name|me_N
argument_list|,
operator|(
name|nbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|me_len
operator|=
name|htole16
argument_list|(
operator|(
name|normbits
operator|/
literal|8
operator|)
operator|+
operator|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|me_op
operator|=
name|htole16
argument_list|(
name|UBS_CTXOP_MODEXP
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|me_E_len
operator|=
name|htole16
argument_list|(
name|ebits
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|me_N_len
operator|=
name|htole16
argument_list|(
name|nbits
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
if|if
condition|(
name|ubsec_debug
condition|)
block|{
name|ubsec_dump_mcr
argument_list|(
name|mcr
argument_list|)
expr_stmt|;
name|ubsec_dump_ctx2
argument_list|(
operator|(
expr|struct
name|ubsec_ctx_keyop
operator|*
operator|)
name|ctx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * ubsec_feed2 will sync mcr and ctx, we just need to sync 	 * everything else. 	 */
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_M
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_E
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_C
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|me
operator|->
name|me_epb
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Enqueue and we're done... */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue2
argument_list|,
operator|&
name|me
operator|->
name|me_q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|ubsec_feed2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|errout
label|:
if|if
condition|(
name|me
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|me
operator|->
name|me_q
operator|.
name|q_mcr
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_mcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_q
operator|.
name|q_ctx
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_q
operator|.
name|q_ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|me_M
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|me
operator|->
name|me_M
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_M
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_M
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|me_E
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|me
operator|->
name|me_E
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_E
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_E
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|me_C
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|me
operator|->
name|me_C
operator|.
name|dma_vaddr
argument_list|,
name|me
operator|->
name|me_C
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_C
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|me_epb
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|me
operator|->
name|me_epb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|me
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|krp
operator|->
name|krp_status
operator|=
name|err
expr_stmt|;
name|crypto_kdone
argument_list|(
name|krp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ubsec_kprocess_rsapriv
parameter_list|(
name|struct
name|ubsec_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cryptkop
modifier|*
name|krp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|ubsec_q2_rsapriv
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
name|struct
name|ubsec_mcr
modifier|*
name|mcr
decl_stmt|;
name|struct
name|ubsec_ctx_rsapriv
modifier|*
name|ctx
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u_int
name|padlen
decl_stmt|,
name|msglen
decl_stmt|;
name|msglen
operator|=
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_P
index|]
argument_list|)
expr_stmt|;
name|padlen
operator|=
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_Q
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|>
name|padlen
condition|)
name|padlen
operator|=
name|msglen
expr_stmt|;
if|if
condition|(
name|padlen
operator|<=
literal|256
condition|)
name|padlen
operator|=
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
name|padlen
operator|<=
literal|384
condition|)
name|padlen
operator|=
literal|384
expr_stmt|;
elseif|else
if|if
condition|(
name|padlen
operator|<=
literal|512
condition|)
name|padlen
operator|=
literal|512
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_BIGKEY
operator|&&
name|padlen
operator|<=
literal|768
condition|)
name|padlen
operator|=
literal|768
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|UBS_FLAGS_BIGKEY
operator|&&
name|padlen
operator|<=
literal|1024
condition|)
name|padlen
operator|=
literal|1024
expr_stmt|;
else|else
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_DP
index|]
argument_list|)
operator|>
name|padlen
condition|)
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_DQ
index|]
argument_list|)
operator|>
name|padlen
condition|)
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_PINV
index|]
argument_list|)
operator|>
name|padlen
condition|)
block|{
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|rp
operator|=
operator|(
expr|struct
name|ubsec_q2_rsapriv
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|rp
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|rp
argument_list|,
sizeof|sizeof
expr|*
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rpr_krp
operator|=
name|krp
expr_stmt|;
name|rp
operator|->
name|rpr_q
operator|.
name|q_type
operator|=
name|UBS_CTXOP_RSAPRIV
expr_stmt|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_mcr
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|rpr_q
operator|.
name|q_mcr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|mcr
operator|=
operator|(
expr|struct
name|ubsec_mcr
operator|*
operator|)
name|rp
operator|->
name|rpr_q
operator|.
name|q_mcr
operator|.
name|dma_vaddr
expr_stmt|;
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ubsec_ctx_rsapriv
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|rpr_q
operator|.
name|q_ctx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|ctx
operator|=
operator|(
expr|struct
name|ubsec_ctx_rsapriv
operator|*
operator|)
name|rp
operator|->
name|rpr_q
operator|.
name|q_ctx
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
comment|/* Copy in p */
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_P
index|]
operator|.
name|crp_p
argument_list|,
operator|&
name|ctx
operator|->
name|rpr_buf
index|[
literal|0
operator|*
operator|(
name|padlen
operator|/
literal|8
operator|)
index|]
argument_list|,
operator|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_P
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Copy in q */
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_Q
index|]
operator|.
name|crp_p
argument_list|,
operator|&
name|ctx
operator|->
name|rpr_buf
index|[
literal|1
operator|*
operator|(
name|padlen
operator|/
literal|8
operator|)
index|]
argument_list|,
operator|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_Q
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Copy in dp */
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_DP
index|]
operator|.
name|crp_p
argument_list|,
operator|&
name|ctx
operator|->
name|rpr_buf
index|[
literal|2
operator|*
operator|(
name|padlen
operator|/
literal|8
operator|)
index|]
argument_list|,
operator|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_DP
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Copy in dq */
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_DQ
index|]
operator|.
name|crp_p
argument_list|,
operator|&
name|ctx
operator|->
name|rpr_buf
index|[
literal|3
operator|*
operator|(
name|padlen
operator|/
literal|8
operator|)
index|]
argument_list|,
operator|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_DQ
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Copy in pinv */
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_PINV
index|]
operator|.
name|crp_p
argument_list|,
operator|&
name|ctx
operator|->
name|rpr_buf
index|[
literal|4
operator|*
operator|(
name|padlen
operator|/
literal|8
operator|)
index|]
argument_list|,
operator|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_PINV
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|padlen
operator|*
literal|2
expr_stmt|;
comment|/* Copy in input message (aligned buffer/length). */
if|if
condition|(
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_MSGIN
index|]
argument_list|)
operator|>
name|msglen
condition|)
block|{
comment|/* Is this likely? */
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
operator|(
name|msglen
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
operator|&
name|rp
operator|->
name|rpr_msgin
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|bzero
argument_list|(
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_vaddr
argument_list|,
operator|(
name|msglen
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_MSGIN
index|]
operator|.
name|crp_p
argument_list|,
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_vaddr
argument_list|,
operator|(
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_MSGIN
index|]
operator|.
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Prepare space for output message (aligned buffer/length). */
if|if
condition|(
name|ubsec_ksigbits
argument_list|(
operator|&
name|krp
operator|->
name|krp_param
index|[
name|UBS_RSAPRIV_PAR_MSGOUT
index|]
argument_list|)
operator|<
name|msglen
condition|)
block|{
comment|/* Is this likely? */
name|err
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|ubsec_dma_malloc
argument_list|(
name|sc
argument_list|,
operator|(
name|msglen
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
operator|&
name|rp
operator|->
name|rpr_msgout
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|bzero
argument_list|(
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_vaddr
argument_list|,
operator|(
name|msglen
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_pkts
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_flags
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_cmdctxp
operator|=
name|htole32
argument_list|(
name|rp
operator|->
name|rpr_q
operator|.
name|q_ctx
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_addr
operator|=
name|htole32
argument_list|(
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_next
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_ipktbuf
operator|.
name|pb_len
operator|=
name|htole32
argument_list|(
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_reserved
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_pktlen
operator|=
name|htole16
argument_list|(
name|msglen
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_addr
operator|=
name|htole32
argument_list|(
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_next
operator|=
literal|0
expr_stmt|;
name|mcr
operator|->
name|mcr_opktbuf
operator|.
name|pb_len
operator|=
name|htole32
argument_list|(
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_paddr
operator|&
literal|3
operator|||
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_size
operator|&
literal|3
condition|)
block|{
name|panic
argument_list|(
literal|"%s: rsapriv: invalid msgin %x(0x%jx)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_paddr
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_paddr
operator|&
literal|3
operator|||
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_size
operator|&
literal|3
condition|)
block|{
name|panic
argument_list|(
literal|"%s: rsapriv: invalid msgout %x(0x%jx)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_paddr
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ctx
operator|->
name|rpr_len
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
literal|5
operator|*
operator|(
name|padlen
operator|/
literal|8
operator|)
operator|)
expr_stmt|;
name|ctx
operator|->
name|rpr_op
operator|=
name|htole16
argument_list|(
name|UBS_CTXOP_RSAPRIV
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rpr_q_len
operator|=
name|htole16
argument_list|(
name|padlen
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rpr_p_len
operator|=
name|htole16
argument_list|(
name|padlen
argument_list|)
expr_stmt|;
comment|/* 	 * ubsec_feed2 will sync mcr and ctx, we just need to sync 	 * everything else. 	 */
name|ubsec_dma_sync
argument_list|(
operator|&
name|rp
operator|->
name|rpr_msgin
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ubsec_dma_sync
argument_list|(
operator|&
name|rp
operator|->
name|rpr_msgout
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Enqueue and we're done... */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue2
argument_list|,
operator|&
name|rp
operator|->
name|rpr_q
argument_list|,
name|q_next
argument_list|)
expr_stmt|;
name|ubsec_feed2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ubsecstats
operator|.
name|hst_modexpcrt
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcr2lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|errout
label|:
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|rpr_q
operator|.
name|q_mcr
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|rp
operator|->
name|rpr_q
operator|.
name|q_mcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_vaddr
argument_list|,
name|rp
operator|->
name|rpr_msgin
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|rp
operator|->
name|rpr_msgin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_vaddr
argument_list|,
name|rp
operator|->
name|rpr_msgout
operator|.
name|dma_size
argument_list|)
expr_stmt|;
name|ubsec_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|rp
operator|->
name|rpr_msgout
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|krp
operator|->
name|krp_status
operator|=
name|err
expr_stmt|;
name|crypto_kdone
argument_list|(
name|krp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UBSEC_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ubsec_dump_pb
parameter_list|(
specifier|volatile
name|struct
name|ubsec_pktbuf
modifier|*
name|pb
parameter_list|)
block|{
name|printf
argument_list|(
literal|"addr 0x%x (0x%x) next 0x%x\n"
argument_list|,
name|pb
operator|->
name|pb_addr
argument_list|,
name|pb
operator|->
name|pb_len
argument_list|,
name|pb
operator|->
name|pb_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_dump_ctx2
parameter_list|(
name|struct
name|ubsec_ctx_keyop
modifier|*
name|c
parameter_list|)
block|{
name|printf
argument_list|(
literal|"CTX (0x%x):\n"
argument_list|,
name|c
operator|->
name|ctx_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|letoh16
argument_list|(
name|c
operator|->
name|ctx_op
argument_list|)
condition|)
block|{
case|case
name|UBS_CTXOP_RNGBYPASS
case|:
case|case
name|UBS_CTXOP_RNGSHA1
case|:
break|break;
case|case
name|UBS_CTXOP_MODEXP
case|:
block|{
name|struct
name|ubsec_ctx_modexp
modifier|*
name|cx
init|=
operator|(
name|void
operator|*
operator|)
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|printf
argument_list|(
literal|" Elen %u, Nlen %u\n"
argument_list|,
name|letoh16
argument_list|(
name|cx
operator|->
name|me_E_len
argument_list|)
argument_list|,
name|letoh16
argument_list|(
name|cx
operator|->
name|me_N_len
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|cx
operator|->
name|me_N_len
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s%02x"
argument_list|,
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|" N: "
else|:
literal|":"
argument_list|,
name|cx
operator|->
name|me_N
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"unknown context: %x\n"
argument_list|,
name|c
operator|->
name|ctx_op
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"END CTX\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_dump_mcr
parameter_list|(
name|struct
name|ubsec_mcr
modifier|*
name|mcr
parameter_list|)
block|{
specifier|volatile
name|struct
name|ubsec_mcr_add
modifier|*
name|ma
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"MCR:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" pkts: %u, flags 0x%x\n"
argument_list|,
name|letoh16
argument_list|(
name|mcr
operator|->
name|mcr_pkts
argument_list|)
argument_list|,
name|letoh16
argument_list|(
name|mcr
operator|->
name|mcr_flags
argument_list|)
argument_list|)
expr_stmt|;
name|ma
operator|=
operator|(
specifier|volatile
expr|struct
name|ubsec_mcr_add
operator|*
operator|)
operator|&
name|mcr
operator|->
name|mcr_cmdctxp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|letoh16
argument_list|(
name|mcr
operator|->
name|mcr_pkts
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %d: ctx 0x%x len 0x%x rsvd 0x%x\n"
argument_list|,
name|i
argument_list|,
name|letoh32
argument_list|(
name|ma
operator|->
name|mcr_cmdctxp
argument_list|)
argument_list|,
name|letoh16
argument_list|(
name|ma
operator|->
name|mcr_pktlen
argument_list|)
argument_list|,
name|letoh16
argument_list|(
name|ma
operator|->
name|mcr_reserved
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d: ipkt "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ubsec_dump_pb
argument_list|(
operator|&
name|ma
operator|->
name|mcr_ipktbuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d: opkt "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ubsec_dump_pb
argument_list|(
operator|&
name|ma
operator|->
name|mcr_opktbuf
argument_list|)
expr_stmt|;
name|ma
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"END MCR\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UBSEC_DEBUG */
end_comment

begin_comment
comment|/*  * Return the number of significant bits of a big number.  */
end_comment

begin_function
specifier|static
name|int
name|ubsec_ksigbits
parameter_list|(
name|struct
name|crparam
modifier|*
name|cr
parameter_list|)
block|{
name|u_int
name|plen
init|=
operator|(
name|cr
operator|->
name|crp_nbits
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sig
init|=
name|plen
operator|*
literal|8
decl_stmt|;
name|u_int8_t
name|c
decl_stmt|,
modifier|*
name|p
init|=
name|cr
operator|->
name|crp_p
decl_stmt|;
for|for
control|(
name|i
operator|=
name|plen
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|c
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|sig
operator|--
expr_stmt|;
name|c
operator|<<=
literal|1
expr_stmt|;
block|}
break|break;
block|}
name|sig
operator|-=
literal|8
expr_stmt|;
block|}
return|return
operator|(
name|sig
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_kshift_r
parameter_list|(
name|u_int
name|shiftbits
parameter_list|,
name|u_int8_t
modifier|*
name|src
parameter_list|,
name|u_int
name|srcbits
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|,
name|u_int
name|dstbits
parameter_list|)
block|{
name|u_int
name|slen
decl_stmt|,
name|dlen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|si
decl_stmt|,
name|di
decl_stmt|,
name|n
decl_stmt|;
name|slen
operator|=
operator|(
name|srcbits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|dlen
operator|=
operator|(
name|dstbits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slen
condition|;
name|i
operator|++
control|)
name|dst
index|[
name|i
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlen
operator|-
name|slen
condition|;
name|i
operator|++
control|)
name|dst
index|[
name|slen
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|shiftbits
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|si
operator|=
name|dlen
operator|-
name|n
operator|-
literal|1
expr_stmt|;
name|di
operator|=
name|dlen
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|si
operator|>=
literal|0
condition|)
name|dst
index|[
name|di
operator|--
index|]
operator|=
name|dst
index|[
name|si
operator|--
index|]
expr_stmt|;
while|while
condition|(
name|di
operator|>=
literal|0
condition|)
name|dst
index|[
name|di
operator|--
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|=
name|shiftbits
operator|%
literal|8
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|dlen
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|dst
index|[
name|i
index|]
operator|=
operator|(
name|dst
index|[
name|i
index|]
operator|<<
name|n
operator|)
operator||
operator|(
name|dst
index|[
name|i
operator|-
literal|1
index|]
operator|>>
operator|(
literal|8
operator|-
name|n
operator|)
operator|)
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
name|dst
index|[
literal|0
index|]
operator|<<
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ubsec_kshift_l
parameter_list|(
name|u_int
name|shiftbits
parameter_list|,
name|u_int8_t
modifier|*
name|src
parameter_list|,
name|u_int
name|srcbits
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|,
name|u_int
name|dstbits
parameter_list|)
block|{
name|int
name|slen
decl_stmt|,
name|dlen
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|slen
operator|=
operator|(
name|srcbits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|dlen
operator|=
operator|(
name|dstbits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|n
operator|=
name|shiftbits
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slen
condition|;
name|i
operator|++
control|)
name|dst
index|[
name|i
index|]
operator|=
name|src
index|[
name|i
operator|+
name|n
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlen
operator|-
name|slen
condition|;
name|i
operator|++
control|)
name|dst
index|[
name|slen
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|shiftbits
operator|%
literal|8
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|dlen
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|dst
index|[
name|i
index|]
operator|=
operator|(
name|dst
index|[
name|i
index|]
operator|>>
name|n
operator|)
operator||
operator|(
name|dst
index|[
name|i
operator|+
literal|1
index|]
operator|<<
operator|(
literal|8
operator|-
name|n
operator|)
operator|)
expr_stmt|;
name|dst
index|[
name|dlen
operator|-
literal|1
index|]
operator|=
name|dst
index|[
name|dlen
operator|-
literal|1
index|]
operator|>>
name|n
expr_stmt|;
block|}
block|}
end_function

end_unit

