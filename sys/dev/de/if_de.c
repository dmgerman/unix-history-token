begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_de.c,v 1.86 1999/06/01 19:17:59 thorpej Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1994-1997 Matt Thomas (matt@3am-software.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Id: if_de.c,v 1.94 1997/07/03 16:55:07 thomas Exp  */
end_comment

begin_comment
comment|/*  * DEC 21040 PCI Ethernet Controller  *  * Written by Matt Thomas  * BPF support code stolen directly from if_ec.c  *  *   This driver supports the DEC DE435 or any other PCI  *   board which support 21040, 21041, or 21140 (mostly).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TULIP_HDR_DATA
end_define

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/de/dc21040reg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Intel CPUs should use I/O mapped access.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_define
define|#
directive|define
name|TULIP_IOMAPPED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This enables KTR traces at KTR_DEV. */
end_comment

begin_define
define|#
directive|define
name|KTR_TULIP
value|KTR_DEV
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KTR_TULIP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * This turns on all sort of debugging stuff and make the  * driver much larger.  */
end_comment

begin_define
define|#
directive|define
name|TULIP_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TULIP_PERFSTATS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TULIP_HZ
value|10
end_define

begin_include
include|#
directive|include
file|<dev/de/if_devar.h>
end_include

begin_define
define|#
directive|define
name|SYNC_NONE
value|0
end_define

begin_define
define|#
directive|define
name|SYNC_RX
value|1
end_define

begin_define
define|#
directive|define
name|SYNC_TX
value|2
end_define

begin_comment
comment|/*  * This module supports  *	the DEC 21040 PCI Ethernet Controller.  *	the DEC 21041 PCI Ethernet Controller.  *	the DEC 21140 PCI Fast Ethernet Controller.  */
end_comment

begin_function_decl
specifier|static
name|void
name|tulip_addr_filter
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tulip_ifmedia_change
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_init_locked
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_intr_shared
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_intr_normal
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_mii_autonegotiate
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
specifier|const
name|unsigned
name|phyaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tulip_mii_map_abilities
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|abilities
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tulip_media_t
name|tulip_mii_phy_readspecific
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|tulip_mii_readreg
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_mii_writereg
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|,
name|unsigned
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_reset
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_rx_intr
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tulip_srom_decode
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_start_locked
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|tulip_txput
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_txput_setup
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mbuf
modifier|*
name|tulip_dequeue_mbuf
parameter_list|(
name|tulip_ringinfo_t
modifier|*
name|ri
parameter_list|,
name|tulip_descinfo_t
modifier|*
name|di
parameter_list|,
name|int
name|sync
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_dma_map_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_dma_map_rxbuf
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|tulip_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|paddr
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|paddr
operator|=
name|arg
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_dma_map_rxbuf
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|tulip_desc_t
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|desc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
operator|>=
name|TULIP_RX_BUFLEN
argument_list|,
operator|(
literal|"receive buffer too small"
operator|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|d_addr1
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|desc
operator|->
name|d_length1
operator|=
name|TULIP_RX_BUFLEN
expr_stmt|;
ifdef|#
directive|ifdef
name|not_needed
comment|/* These should already always be zero. */
name|desc
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|tulip_dequeue_mbuf
parameter_list|(
name|tulip_ringinfo_t
modifier|*
name|ri
parameter_list|,
name|tulip_descinfo_t
modifier|*
name|di
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|di
operator|->
name|di_mbuf
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|sync
condition|)
block|{
case|case
name|SYNC_NONE
case|:
break|break;
case|case
name|SYNC_RX
case|:
name|TULIP_RXMAP_POSTSYNC
argument_list|(
name|ri
argument_list|,
name|di
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYNC_TX
case|:
name|TULIP_TXMAP_POSTSYNC
argument_list|(
name|ri
argument_list|,
name|di
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad sync flag: %d"
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|ri
operator|->
name|ri_data_tag
argument_list|,
operator|*
name|di
operator|->
name|di_map
argument_list|)
expr_stmt|;
name|di
operator|->
name|di_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_timeout_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
name|arg
decl_stmt|;
name|TULIP_PERFSTART
argument_list|(
argument|timeout
argument_list|)
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TIMEOUTPENDING
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|-=
literal|1000
operator|/
name|TULIP_HZ
expr_stmt|;
call|(
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_poll
call|)
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIAPOLL_TIMER
argument_list|)
expr_stmt|;
name|TULIP_PERFEND
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_timeout
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TIMEOUTPENDING
condition|)
return|return;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_TIMEOUTPENDING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|tulip_callout
argument_list|,
operator|(
name|hz
operator|+
name|TULIP_HZ
operator|/
literal|2
operator|)
operator|/
name|TULIP_HZ
argument_list|,
name|tulip_timeout_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_txprobe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_char
modifier|*
name|enaddr
decl_stmt|;
comment|/*      * Before we are sure this is the right media we need      * to send a small packet to make sure there's carrier.      * Strangely, BNC and AUI will "see" receive data if      * either is connected so the transmit is the only way      * to verify the connectivity.      */
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*      * Construct a LLC TEST message which will point to ourselves.      */
if|if
condition|(
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_input
operator|!=
name|NULL
condition|)
name|enaddr
operator|=
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|tulip_ifp
argument_list|)
expr_stmt|;
else|else
name|enaddr
operator|=
name|sc
operator|->
name|tulip_enaddr
expr_stmt|;
name|bcopy
argument_list|(
name|enaddr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|enaddr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned char *
argument_list|)
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned char *
argument_list|)
index|[
literal|15
index|]
operator|=
literal|0
expr_stmt|;
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned char *
argument_list|)
index|[
literal|16
index|]
operator|=
literal|0xE3
expr_stmt|;
comment|/* LLC Class1 TEST (no poll) */
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
literal|3
expr_stmt|;
comment|/*      * send it!      */
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_TXINTR
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|tulip_txput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_probe
operator|.
name|probe_txprobes
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_media_set
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_media_t
name|media
parameter_list|)
block|{
specifier|const
name|tulip_media_info_t
modifier|*
name|mi
init|=
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|==
name|NULL
condition|)
return|return;
comment|/*      * If we are switching media, make sure we don't think there's      * any stale RX activity      */
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_RXACT
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_SIA
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|mi
operator|->
name|mi_sia_tx_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_SIAGP
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|mi
operator|->
name|mi_sia_gp_control
operator||
name|mi
operator|->
name|mi_sia_general
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|mi
operator|->
name|mi_sia_gp_data
operator||
name|mi
operator|->
name|mi_sia_general
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|mi
operator|->
name|mi_sia_general
argument_list|)
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|mi
operator|->
name|mi_sia_connectivity
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_GPR
condition|)
block|{
define|#
directive|define
name|TULIP_GPR_CMDBITS
value|(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)
comment|/* 	 * If the cmdmode bits don't match the currently operating mode, 	 * set the cmdmode appropriately and reset the chip. 	 */
if|if
condition|(
operator|(
operator|(
name|mi
operator|->
name|mi_cmdmode
operator|^
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|)
operator|&
name|TULIP_GPR_CMDBITS
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_GPR_CMDBITS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|mi
operator|->
name|mi_cmdmode
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_PINSET
operator||
name|sc
operator|->
name|tulip_gpinit
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
operator|(
name|u_int8_t
operator|)
name|mi
operator|->
name|mi_gpdata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_SYM
condition|)
block|{
comment|/* 	 * If the cmdmode bits don't match the currently operating mode, 	 * set the cmdmode appropriately and reset the chip. 	 */
if|if
condition|(
operator|(
operator|(
name|mi
operator|->
name|mi_cmdmode
operator|^
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|)
operator|&
name|TULIP_GPR_CMDBITS
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_GPR_CMDBITS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|mi
operator|->
name|mi_cmdmode
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|mi
operator|->
name|mi_gpcontrol
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|mi
operator|->
name|mi_gpdata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_MII
operator|&&
name|sc
operator|->
name|tulip_probe_state
operator|!=
name|TULIP_PROBE_INACTIVE
condition|)
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_SIAGP
condition|)
block|{
specifier|const
name|u_int8_t
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
name|mi
operator|->
name|mi_reset_offset
index|]
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|mi
operator|->
name|mi_reset_length
condition|;
name|idx
operator|++
operator|,
name|dp
operator|+=
literal|2
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
operator|(
name|dp
index|[
literal|0
index|]
operator|+
literal|256
operator|*
name|dp
index|[
literal|1
index|]
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_phyaddr
operator|=
name|mi
operator|->
name|mi_phyaddr
expr_stmt|;
name|dp
operator|=
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
name|mi
operator|->
name|mi_gpr_offset
index|]
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|mi
operator|->
name|mi_gpr_length
condition|;
name|idx
operator|++
operator|,
name|dp
operator|+=
literal|2
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
operator|(
name|dp
index|[
literal|0
index|]
operator|+
literal|256
operator|*
name|dp
index|[
literal|1
index|]
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|mi
operator|->
name|mi_reset_length
condition|;
name|idx
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|sc
operator|->
name|tulip_rombuf
index|[
name|mi
operator|->
name|mi_reset_offset
operator|+
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_phyaddr
operator|=
name|mi
operator|->
name|mi_phyaddr
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|mi
operator|->
name|mi_gpr_length
condition|;
name|idx
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|sc
operator|->
name|tulip_rombuf
index|[
name|mi
operator|->
name|mi_gpr_offset
operator|+
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TRYNWAY
condition|)
block|{
name|tulip_mii_autonegotiate
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DIDNWAY
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|data
init|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
decl_stmt|;
name|data
operator|&=
operator|~
operator|(
name|PHYCTL_SELECT_100MB
operator||
name|PHYCTL_FULL_DUPLEX
operator||
name|PHYCTL_AUTONEG_ENABLE
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DIDNWAY
expr_stmt|;
if|if
condition|(
name|TULIP_IS_MEDIA_FD
argument_list|(
name|media
argument_list|)
condition|)
name|data
operator||=
name|PHYCTL_FULL_DUPLEX
expr_stmt|;
if|if
condition|(
name|TULIP_IS_MEDIA_100MB
argument_list|(
name|media
argument_list|)
condition|)
name|data
operator||=
name|PHYCTL_SELECT_100MB
expr_stmt|;
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_linkup
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_media_t
name|media
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_LINKUP
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTLINKUP
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX how does with work with ifmedia? */
block|if ((sc->tulip_flags& TULIP_DIDNWAY) == 0) { 	if (sc->tulip_ifp->if_flags& IFF_FULLDUPLEX) { 	    if (TULIP_CAN_MEDIA_FD(media)&& sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL) 		media = TULIP_FD_MEDIA_OF(media); 	} else { 	    if (TULIP_IS_MEDIA_FD(media)&& sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL) 		media = TULIP_HD_MEDIA_OF(media); 	}     }
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|!=
name|media
condition|)
block|{
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_last_media
operator|=
name|sc
operator|->
name|tulip_media
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_media
operator|=
name|media
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
if|if
condition|(
name|TULIP_IS_MEDIA_FD
argument_list|(
name|sc
operator|->
name|tulip_media
argument_list|)
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|!=
name|TULIP_21041
operator|||
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DIDNWAY
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
block|}
comment|/*      * We could set probe_timeout to 0 but setting to 3000 puts this      * in one central place and the only matters is tulip_link is      * followed by a tulip_timeout.  Therefore setting it should not      * result in aberrant behavour.      */
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|3000
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_TXPROBE_ACTIVE
operator||
name|TULIP_TRYNWAY
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_INRESET
condition|)
block|{
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_media
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_probe_media
operator|!=
name|sc
operator|->
name|tulip_media
condition|)
block|{
comment|/* 	 * No reason to change media if we have the right media. 	 */
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|tulip_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_media_print
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_LINKUP
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_PRINTMEDIA
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"enabling %s port\n"
argument_list|,
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_media
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_PRINTMEDIA
operator||
name|TULIP_PRINTLINKUP
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_PRINTLINKUP
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"link up\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_PRINTLINKUP
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DO_GPR_SENSE
argument_list|)
end_if

begin_function
specifier|static
name|tulip_media_t
name|tulip_21140_gpr_media_sense
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
name|sc
operator|->
name|tulip_ifp
decl_stmt|;
name|tulip_media_t
name|maybe_media
init|=
name|TULIP_MEDIA_UNKNOWN
decl_stmt|;
name|tulip_media_t
name|last_media
init|=
name|TULIP_MEDIA_UNKNOWN
decl_stmt|;
name|tulip_media_t
name|media
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * If one of the media blocks contained a default media flag,      * use that.      */
for|for
control|(
name|media
operator|=
name|TULIP_MEDIA_UNKNOWN
init|;
name|media
operator|<
name|TULIP_MEDIA_MAX
condition|;
name|media
operator|++
control|)
block|{
specifier|const
name|tulip_media_info_t
modifier|*
name|mi
decl_stmt|;
comment|/* 	 * Media is not supported (or is full-duplex). 	 */
if|if
condition|(
operator|(
name|mi
operator|=
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|)
operator|==
name|NULL
operator|||
name|TULIP_IS_MEDIA_FD
argument_list|(
name|media
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|!=
name|TULIP_MEDIAINFO_GPR
condition|)
continue|continue;
comment|/* 	 * Remember the media is this is the "default" media. 	 */
if|if
condition|(
name|mi
operator|->
name|mi_default
operator|&&
name|maybe_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
name|maybe_media
operator|=
name|media
expr_stmt|;
comment|/* 	 * No activity mask?  Can't see if it is active if there's no mask. 	 */
if|if
condition|(
name|mi
operator|->
name|mi_actmask
operator|==
literal|0
condition|)
continue|continue;
comment|/* 	 * Does the activity data match? 	 */
if|if
condition|(
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
operator|&
name|mi
operator|->
name|mi_actmask
operator|)
operator|!=
name|mi
operator|->
name|mi_actdata
condition|)
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"%s: %s: 0x%02x& 0x%02x == 0x%02x\n"
argument_list|,
name|__func__
argument_list|,
name|tulip_mediums
index|[
name|media
index|]
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
operator|&
literal|0xFF
argument_list|,
name|mi
operator|->
name|mi_actmask
argument_list|,
name|mi
operator|->
name|mi_actdata
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * It does!  If this is the first media we detected, then  	 * remember this media.  If isn't the first, then there were 	 * multiple matches which we equate to no match (since we don't 	 * which to select (if any). 	 */
if|if
condition|(
name|last_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|last_media
operator|=
name|media
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_media
operator|!=
name|media
condition|)
block|{
name|last_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
block|}
block|}
return|return
operator|(
name|last_media
operator|!=
name|TULIP_MEDIA_UNKNOWN
operator|)
condition|?
name|last_media
else|:
name|maybe_media
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TULIP_DO_GPR_SENSE */
end_comment

begin_function
specifier|static
name|tulip_link_status_t
name|tulip_media_link_monitor
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
specifier|const
name|tulip_media_info_t
modifier|*
specifier|const
name|mi
init|=
name|sc
operator|->
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_media
index|]
decl_stmt|;
name|tulip_link_status_t
name|linkup
init|=
name|TULIP_LINK_DOWN
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|panic
argument_list|(
literal|"tulip_media_link_monitor: %s: botch at line %d\n"
argument_list|,
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_media
index|]
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
name|TULIP_LINK_UNKNOWN
return|;
endif|#
directive|endif
block|}
comment|/*      * Have we seen some packets?  If so, the link must be good.      */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_RXACT
operator||
name|TULIP_LINKUP
operator|)
operator|)
operator|==
operator|(
name|TULIP_RXACT
operator||
name|TULIP_LINKUP
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_RXACT
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|3000
expr_stmt|;
return|return
name|TULIP_LINK_UP
return|;
block|}
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_RXACT
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_MII
condition|)
block|{
name|u_int32_t
name|status
decl_stmt|;
comment|/* 	 * Read the PHY status register. 	 */
name|status
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|PHYSTS_AUTONEG_DONE
condition|)
block|{
comment|/* 	     * If the PHY has completed autonegotiation, see the if the 	     * remote systems abilities have changed.  If so, upgrade or 	     * downgrade as appropriate. 	     */
name|u_int32_t
name|abilities
init|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|PHYREG_AUTONEG_ABILITIES
argument_list|)
decl_stmt|;
name|abilities
operator|=
operator|(
name|abilities
operator|<<
literal|6
operator|)
operator|&
name|status
expr_stmt|;
if|if
condition|(
name|abilities
operator|!=
name|sc
operator|->
name|tulip_abilities
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|loudprintf
argument_list|(
literal|"%s(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|sc
operator|->
name|tulip_abilities
argument_list|,
name|abilities
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tulip_mii_map_abilities
argument_list|(
name|sc
argument_list|,
name|abilities
argument_list|)
condition|)
block|{
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
return|return
name|TULIP_LINK_UP
return|;
block|}
comment|/* 		 * if we had selected media because of autonegotiation, 		 * we need to probe for the new media. 		 */
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DIDNWAY
condition|)
return|return
name|TULIP_LINK_DOWN
return|;
block|}
block|}
comment|/* 	 * The link is now up.  If was down, say its back up. 	 */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|PHYSTS_LINK_UP
operator||
name|PHYSTS_REMOTE_FAULT
operator|)
operator|)
operator|==
name|PHYSTS_LINK_UP
condition|)
name|linkup
operator|=
name|TULIP_LINK_UP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_GPR
condition|)
block|{
comment|/* 	 * No activity sensor?  Assume all's well. 	 */
if|if
condition|(
name|mi
operator|->
name|mi_actmask
operator|==
literal|0
condition|)
return|return
name|TULIP_LINK_UNKNOWN
return|;
comment|/* 	 * Does the activity data match? 	 */
if|if
condition|(
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
operator|&
name|mi
operator|->
name|mi_actmask
operator|)
operator|==
name|mi
operator|->
name|mi_actdata
condition|)
name|linkup
operator|=
name|TULIP_LINK_UP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_SIA
condition|)
block|{
comment|/* 	 * Assume non TP ok for now. 	 */
if|if
condition|(
operator|!
name|TULIP_IS_MEDIA_TP
argument_list|(
name|sc
operator|->
name|tulip_media
argument_list|)
condition|)
return|return
name|TULIP_LINK_UNKNOWN
return|;
if|if
condition|(
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
operator|&
name|TULIP_SIASTS_LINKFAIL
operator|)
operator|==
literal|0
condition|)
name|linkup
operator|=
name|TULIP_LINK_UP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
name|sc
operator|->
name|tulip_probe_timeout
operator|<=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"sia status = 0x%08x\n"
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_SYM
condition|)
block|{
return|return
name|TULIP_LINK_UNKNOWN
return|;
block|}
comment|/*      * We will wait for 3 seconds until the link goes into suspect mode.      */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_LINKUP
condition|)
block|{
if|if
condition|(
name|linkup
operator|==
name|TULIP_LINK_UP
condition|)
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|3000
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_timeout
operator|>
literal|0
condition|)
return|return
name|TULIP_LINK_UP
return|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_LINKUP
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"link down: cable problem?\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_link_downed
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|TULIP_LINK_DOWN
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_media_poll
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_mediapoll_event_t
name|event
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_events
index|[
name|event
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_INACTIVE
operator|&&
name|event
operator|==
name|TULIP_MEDIAPOLL_TIMER
condition|)
block|{
switch|switch
condition|(
name|tulip_media_link_monitor
argument_list|(
name|sc
argument_list|)
condition|)
block|{
case|case
name|TULIP_LINK_DOWN
case|:
block|{
comment|/* 		 * Link Monitor failed.  Probe for new media. 		 */
name|event
operator|=
name|TULIP_MEDIAPOLL_LINKFAIL
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_LINK_UP
case|:
block|{
comment|/* 		 * Check again soon. 		 */
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|TULIP_LINK_UNKNOWN
case|:
block|{
comment|/* 		 * We can't tell so don't bother. 		 */
return|return;
block|}
block|}
block|}
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_LINKFAIL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_INACTIVE
condition|)
block|{
if|if
condition|(
name|TULIP_DO_AUTOSENSE
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_link_failures
operator|++
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* restart probe */
block|}
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_link_pollintrs
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_START
condition|)
block|{
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|!=
name|TULIP_PROBE_INACTIVE
condition|)
return|return;
name|sc
operator|->
name|tulip_probe_mediamask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tulip_probe_passes
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_media_probes
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the SROM contained an explicit media to use, use it. 	 */
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
operator|(
name|TULIP_CMD_RXRUN
operator||
name|TULIP_CMD_FULLDUPLEX
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_TRYNWAY
operator||
name|TULIP_PROBE1STPASS
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_DIDNWAY
operator||
name|TULIP_PRINTMEDIA
operator||
name|TULIP_PRINTLINKUP
operator|)
expr_stmt|;
comment|/* 	 * connidx is defaulted to a media_unknown type. 	 */
name|sc
operator|->
name|tulip_probe_media
operator|=
name|tulip_srom_conninfo
index|[
name|sc
operator|->
name|tulip_connidx
index|]
operator|.
name|sc_media
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_media
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_GPR
condition|)
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_GPRTEST
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|2000
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_MAX
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
block|}
block|}
comment|/*      * Ignore txprobe failures or spurious callbacks.      */
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_TXPROBE_FAILED
operator|&&
name|sc
operator|->
name|tulip_probe_state
operator|!=
name|TULIP_PROBE_MEDIATEST
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
return|return;
block|}
comment|/*      * If we really transmitted a packet, then that's the media we'll use.      */
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_TXPROBE_OK
operator|||
name|event
operator|==
name|TULIP_MEDIAPOLL_LINKPASS
condition|)
block|{
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_LINKPASS
condition|)
block|{
comment|/* XXX Check media status just to be sure */
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
block|}
else|else
block|{
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txprobes_ok
index|[
name|sc
operator|->
name|tulip_probe_media
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_GPRTEST
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DO_GPR_SENSE
argument_list|)
comment|/* 	 * Check for media via the general purpose register. 	 * 	 * Try to sense the media via the GPR.  If the same value 	 * occurs 3 times in a row then just use that. 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_probe_timeout
operator|>
literal|0
condition|)
block|{
name|tulip_media_t
name|new_probe_media
init|=
name|tulip_21140_gpr_media_sense
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"%s: gpr sensing = %s\n"
argument_list|,
name|__func__
argument_list|,
name|tulip_mediums
index|[
name|new_probe_media
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|new_probe_media
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
if|if
condition|(
name|new_probe_media
operator|==
name|sc
operator|->
name|tulip_probe_media
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|tulip_probe_count
operator|==
literal|0
condition|)
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_probe_count
operator|=
literal|10
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|tulip_probe_media
operator|=
name|new_probe_media
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* TULIP_DO_GPR_SENSE */
comment|/* 	 * Brute force.  We cycle through each of the media types 	 * and try to transmit a packet. 	 */
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_MAX
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|0
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|!=
name|TULIP_PROBE_MEDIATEST
operator|&&
operator|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_MII
operator|)
condition|)
block|{
name|tulip_media_t
name|old_media
init|=
name|sc
operator|->
name|tulip_probe_media
decl_stmt|;
name|tulip_mii_autonegotiate
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|tulip_probe_state
condition|)
block|{
case|case
name|TULIP_PROBE_FAILED
case|:
case|case
name|TULIP_PROBE_MEDIATEST
case|:
block|{
comment|/* 		 * Try the next media. 		 */
name|sc
operator|->
name|tulip_probe_mediamask
operator||=
name|sc
operator|->
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_probe_media
index|]
operator|->
name|mi_mediamask
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_FAILED
condition|)
break|break;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_media
operator|!=
name|tulip_mii_phy_readspecific
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
name|TULIP_IS_MEDIA_TP
argument_list|(
name|sc
operator|->
name|tulip_probe_media
argument_list|)
condition|?
literal|2500
else|:
literal|300
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|TULIP_PROBE_PHYAUTONEG
case|:
block|{
return|return;
block|}
case|case
name|TULIP_PROBE_INACTIVE
case|:
block|{
comment|/* 		 * Only probe if we autonegotiated a media that hasn't failed. 		 */
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_mediamask
operator|&
name|TULIP_BIT
argument_list|(
name|sc
operator|->
name|tulip_probe_media
argument_list|)
condition|)
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|old_media
expr_stmt|;
break|break;
block|}
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
block|{
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|panic
argument_list|(
literal|"tulip_media_poll: botch at line %d\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_TXPROBE_FAILED
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txprobes_failed
index|[
name|sc
operator|->
name|tulip_probe_media
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
return|return;
block|}
comment|/*      * switch to another media if we tried this one enough.      */
if|if
condition|(
comment|/* event == TULIP_MEDIAPOLL_TXPROBE_FAILED || */
name|sc
operator|->
name|tulip_probe_timeout
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
name|sc
operator|->
name|tulip_probe_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"poll media unknown!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_MAX
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Find the next media type to check for.  Full Duplex 	 * types are not allowed. 	 */
do|do
block|{
name|sc
operator|->
name|tulip_probe_media
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|tulip_probe_passes
operator|==
literal|3
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"autosense failed: cable problem?\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
return|return;
block|}
block|}
name|sc
operator|->
name|tulip_flags
operator|^=
name|TULIP_TRYNWAY
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|tulip_probe_mediamask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_MAX
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|sc
operator|->
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_probe_media
index|]
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|tulip_probe_mediamask
operator|&
name|TULIP_BIT
argument_list|(
name|sc
operator|->
name|tulip_probe_media
argument_list|)
operator|)
operator|||
name|TULIP_IS_MEDIA_FD
argument_list|(
name|sc
operator|->
name|tulip_probe_media
argument_list|)
condition|)
do|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"%s: probing %s\n"
argument_list|,
name|event
operator|==
name|TULIP_MEDIAPOLL_TXPROBE_FAILED
condition|?
literal|"txprobe failed"
else|:
literal|"timeout"
argument_list|,
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_probe_media
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_probe_timeout
operator|=
name|TULIP_IS_MEDIA_TP
argument_list|(
name|sc
operator|->
name|tulip_probe_media
argument_list|)
condition|?
literal|2500
else|:
literal|1000
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
name|sc
operator|->
name|tulip_probe
operator|.
name|probe_txprobes
operator|=
literal|0
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
block|}
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * If this is hanging off a phy, we know are doing NWAY and we have      * forced the phy to a specific speed.  Wait for link up before      * before sending a packet.      */
switch|switch
condition|(
name|sc
operator|->
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_probe_media
index|]
operator|->
name|mi_type
condition|)
block|{
case|case
name|TULIP_MEDIAINFO_MII
case|:
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_probe_media
operator|!=
name|tulip_mii_phy_readspecific
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
break|break;
block|}
case|case
name|TULIP_MEDIAINFO_SIA
case|:
block|{
if|if
condition|(
name|TULIP_IS_MEDIA_TP
argument_list|(
name|sc
operator|->
name|tulip_probe_media
argument_list|)
condition|)
block|{
if|if
condition|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
operator|&
name|TULIP_SIASTS_LINKFAIL
condition|)
return|return;
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_MII
condition|)
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
break|break;
block|}
case|case
name|TULIP_MEDIAINFO_RESET
case|:
case|case
name|TULIP_MEDIAINFO_SYM
case|:
case|case
name|TULIP_MEDIAINFO_NONE
case|:
case|case
name|TULIP_MEDIAINFO_GPR
case|:
block|{
break|break;
block|}
block|}
comment|/*      * Try to send a packet.      */
name|tulip_txprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_GPR
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_PINSET
operator||
name|sc
operator|->
name|tulip_gpinit
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|sc
operator|->
name|tulip_gpdata
argument_list|)
expr_stmt|;
block|}
comment|/*      * If this board has no media, just return      */
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_NOMEDIA
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_poll
call|)
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIAPOLL_START
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_media
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_mediainfo_init
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_media_t
name|media
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_CAPTREFFCT
operator||
name|TULIP_CMD_THRSHLD160
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
if|if
condition|(
name|media
operator|==
name|TULIP_MEDIA_10BASET
operator|||
name|media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_mediainfo
index|[
literal|0
index|]
argument_list|,
literal|21040
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_mediainfo
index|[
literal|1
index|]
argument_list|,
literal|21040
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
expr_stmt|;
block|}
if|if
condition|(
name|media
operator|==
name|TULIP_MEDIA_AUIBNC
operator|||
name|media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_mediainfo
index|[
literal|2
index|]
argument_list|,
literal|21040
argument_list|,
name|AUIBNC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_mediainfo
index|[
literal|3
index|]
argument_list|,
literal|21040
argument_list|,
name|EXTSIA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_21040_mediainfo_init
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIA_UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_10baset_only_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_21040_mediainfo_init
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIA_10BASET
argument_list|)
expr_stmt|;
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIA_10BASET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_10baset_only_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|==
name|TULIP_MEDIA_10BASET_FD
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_SQETEST
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
expr_stmt|;
block|}
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_media
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_auibnc_only_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_21040_mediainfo_init
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIA_AUIBNC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
operator||
name|TULIP_LINKUP
expr_stmt|;
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIA_AUIBNC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_AUIBNC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_auibnc_only_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIA_AUIBNC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21040_boardsw
init|=
block|{
name|TULIP_21040_GENERIC
block|,
name|tulip_21040_media_probe
block|,
name|tulip_media_select
block|,
name|tulip_media_poll
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21040_10baset_only_boardsw
init|=
block|{
name|TULIP_21040_GENERIC
block|,
name|tulip_21040_10baset_only_media_probe
block|,
name|tulip_21040_10baset_only_media_select
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21040_auibnc_only_boardsw
init|=
block|{
name|TULIP_21040_GENERIC
block|,
name|tulip_21040_auibnc_only_media_probe
block|,
name|tulip_21040_auibnc_only_media_select
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tulip_21041_mediainfo_init
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_media_info_t
modifier|*
specifier|const
name|mi
init|=
name|sc
operator|->
name|tulip_mediainfo
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|sc
operator|->
name|tulip_revinfo
operator|>=
literal|0x20
condition|)
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|mi
index|[
literal|0
index|]
argument_list|,
literal|21041P2
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|mi
index|[
literal|1
index|]
argument_list|,
literal|21041P2
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|mi
index|[
literal|0
index|]
argument_list|,
literal|21041P2
argument_list|,
name|AUI
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|mi
index|[
literal|1
index|]
argument_list|,
literal|21041P2
argument_list|,
name|BNC
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|mi
index|[
literal|0
index|]
argument_list|,
literal|21041
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|mi
index|[
literal|1
index|]
argument_list|,
literal|21041
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|mi
index|[
literal|2
index|]
argument_list|,
literal|21041
argument_list|,
name|AUI
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
operator|&
name|mi
index|[
literal|3
index|]
argument_list|,
literal|21041
argument_list|,
name|BNC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21041_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_CAPTREFFCT
operator||
name|TULIP_CMD_ENHCAPTEFFCT
operator||
name|TULIP_CMD_THRSHLD160
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
expr_stmt|;
name|tulip_21041_mediainfo_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21041_media_poll
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
specifier|const
name|tulip_mediapoll_event_t
name|event
parameter_list|)
block|{
name|u_int32_t
name|sia_status
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_events
index|[
name|event
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_LINKFAIL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|!=
name|TULIP_PROBE_INACTIVE
operator|||
operator|!
name|TULIP_DO_AUTOSENSE
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* start probe */
return|return;
block|}
comment|/*      * If we've been been asked to start a poll or link change interrupt      * restart the probe (and reset the tulip to a known state).      */
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_START
condition|)
block|{
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
operator|(
name|TULIP_CMD_FULLDUPLEX
operator||
name|TULIP_CMD_RXRUN
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|sc
operator|->
name|tulip_revinfo
operator|>=
literal|0x20
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_DIDNWAY
expr_stmt|;
block|}
endif|#
directive|endif
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
name|TULIP_21041_PROBE_10BASET_TIMEOUT
expr_stmt|;
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|TULIP_MEDIA_10BASET
argument_list|)
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_INACTIVE
condition|)
return|return;
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_TXPROBE_OK
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txprobes_ok
index|[
name|sc
operator|->
name|tulip_probe_media
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
return|return;
block|}
name|sia_status
operator|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|,
name|sia_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sia_status
operator|&
name|TULIP_SIASTS_LINKFAIL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_revinfo
operator|>=
literal|0x20
condition|)
block|{
if|if
condition|(
name|sia_status
operator|&
operator|(
name|PHYSTS_10BASET_FD
operator|<<
operator|(
literal|16
operator|-
literal|6
operator|)
operator|)
condition|)
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_10BASET_FD
expr_stmt|;
block|}
comment|/* 	 * If the link has passed LinkPass, 10baseT is the 	 * proper media to use. 	 */
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * wait for up to 2.4 seconds for the link to reach pass state.      * Only then start scanning the other media for activity.      * choose media with receive activity over those without.      */
if|if
condition|(
name|sc
operator|->
name|tulip_probe_media
operator|==
name|TULIP_MEDIA_10BASET
condition|)
block|{
if|if
condition|(
name|event
operator|!=
name|TULIP_MEDIAPOLL_TIMER
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_timeout
operator|>
literal|0
operator|&&
operator|(
name|sia_status
operator|&
name|TULIP_SIASTS_OTHERRXACTIVITY
operator|)
operator|==
literal|0
condition|)
block|{
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|tulip_probe_timeout
operator|=
name|TULIP_21041_PROBE_AUIBNC_TIMEOUT
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTRXACT
expr_stmt|;
if|if
condition|(
name|sia_status
operator|&
name|TULIP_SIASTS_OTHERRXACTIVITY
condition|)
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_BNC
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_AUI
expr_stmt|;
block|}
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * If we failed, clear the txprobe active flag.      */
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_TXPROBE_FAILED
condition|)
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|TULIP_MEDIAPOLL_TIMER
condition|)
block|{
comment|/* 	 * If we've received something, then that's our link! 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_RXACT
condition|)
block|{
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * if no txprobe active   	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTRXACT
operator|)
operator|==
literal|0
operator|||
operator|(
name|sia_status
operator|&
name|TULIP_SIASTS_RXACTIVITY
operator|)
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_probe_timeout
operator|=
name|TULIP_21041_PROBE_AUIBNC_TIMEOUT
expr_stmt|;
name|tulip_txprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Take 2 passes through before deciding to not 	 * wait for receive activity.  Then take another 	 * two passes before spitting out a warning. 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_probe_timeout
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTRXACT
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_WANTRXACT
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
name|TULIP_21041_PROBE_AUIBNC_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"autosense failed: cable problem?\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/*      * Since this media failed to probe, try the other one.      */
name|sc
operator|->
name|tulip_probe_timeout
operator|=
name|TULIP_21041_PROBE_AUIBNC_TIMEOUT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_media
operator|==
name|TULIP_MEDIA_AUI
condition|)
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_BNC
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_AUI
expr_stmt|;
block|}
name|tulip_media_set
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_probe_media
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21041_boardsw
init|=
block|{
name|TULIP_21041_GENERIC
block|,
name|tulip_21041_media_probe
block|,
name|tulip_media_select
block|,
name|tulip_21041_media_poll
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_phy_attr_t
name|tulip_mii_phy_attrlist
index|[]
init|=
block|{
block|{
literal|0x20005c00
block|,
literal|0
block|,
comment|/* 08-00-17 */
block|{
block|{
literal|0x19
block|,
literal|0x0040
block|,
literal|0x0040
block|}
block|,
comment|/* 10TX */
block|{
literal|0x19
block|,
literal|0x0040
block|,
literal|0x0000
block|}
block|,
comment|/* 100TX */
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
literal|"NS DP83840"
block|,
endif|#
directive|endif
block|}
block|,
block|{
literal|0x0281F400
block|,
literal|0
block|,
comment|/* 00-A0-7D */
block|{
block|{
literal|0x12
block|,
literal|0x0010
block|,
literal|0x0000
block|}
block|,
comment|/* 10T */
block|{ }
block|,
comment|/* 100TX */
block|{
literal|0x12
block|,
literal|0x0010
block|,
literal|0x0010
block|}
block|,
comment|/* 100T4 */
block|{
literal|0x12
block|,
literal|0x0008
block|,
literal|0x0008
block|}
block|,
comment|/* FULL_DUPLEX */
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
literal|"Seeq 80C240"
endif|#
directive|endif
block|}
block|,
if|#
directive|if
literal|0
block|{ 0x0015F420, 0,
comment|/* 00-A0-7D */
block|{ 	{ 0x12, 0x0010, 0x0000 },
comment|/* 10T */
block|{ },
comment|/* 100TX */
block|{ 0x12, 0x0010, 0x0010 },
comment|/* 100T4 */
block|{ 0x12, 0x0008, 0x0008 },
comment|/* FULL_DUPLEX */
block|},
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
block|"Broadcom BCM5000"
endif|#
directive|endif
block|},
endif|#
directive|endif
block|{
literal|0x0281F400
block|,
literal|0
block|,
comment|/* 00-A0-BE */
block|{
block|{
literal|0x11
block|,
literal|0x8000
block|,
literal|0x0000
block|}
block|,
comment|/* 10T */
block|{
literal|0x11
block|,
literal|0x8000
block|,
literal|0x8000
block|}
block|,
comment|/* 100TX */
block|{ }
block|,
comment|/* 100T4 */
block|{
literal|0x11
block|,
literal|0x4000
block|,
literal|0x4000
block|}
block|,
comment|/* FULL_DUPLEX */
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
literal|"ICS 1890"
endif|#
directive|endif
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tulip_media_t
name|tulip_mii_phy_readspecific
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
specifier|const
name|tulip_phy_attr_t
modifier|*
name|attr
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|;
name|u_int32_t
name|id
decl_stmt|;
name|unsigned
name|idx
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|tulip_media_t
name|table
index|[]
init|=
block|{
name|TULIP_MEDIA_UNKNOWN
block|,
name|TULIP_MEDIA_10BASET
block|,
name|TULIP_MEDIA_100BASETX
block|,
name|TULIP_MEDIA_100BASET4
block|,
name|TULIP_MEDIA_UNKNOWN
block|,
name|TULIP_MEDIA_10BASET_FD
block|,
name|TULIP_MEDIA_100BASETX_FD
block|,
name|TULIP_MEDIA_UNKNOWN
block|}
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Don't read phy specific registers if link is not up.      */
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
operator|(
name|PHYSTS_LINK_UP
operator||
name|PHYSTS_EXTENDED_REGS
operator|)
operator|)
operator|!=
operator|(
name|PHYSTS_LINK_UP
operator||
name|PHYSTS_EXTENDED_REGS
operator|)
condition|)
return|return
name|TULIP_MEDIA_UNKNOWN
return|;
name|id
operator|=
operator|(
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|PHYREG_IDLOW
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|PHYREG_IDHIGH
argument_list|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|tulip_mii_phy_attrlist
init|;
condition|;
name|attr
operator|++
control|)
block|{
if|if
condition|(
name|attr
operator|->
name|attr_id
operator|==
literal|0
condition|)
return|return
name|TULIP_MEDIA_UNKNOWN
return|;
if|if
condition|(
operator|(
name|id
operator|&
operator|~
literal|0x0F
operator|)
operator|==
name|attr
operator|->
name|attr_id
condition|)
break|break;
block|}
if|if
condition|(
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_100TX
index|]
operator|.
name|pm_regno
condition|)
block|{
specifier|const
name|tulip_phy_modedata_t
modifier|*
specifier|const
name|pm
init|=
operator|&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_100TX
index|]
decl_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|pm
operator|->
name|pm_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|pm
operator|->
name|pm_mask
operator|)
operator|==
name|pm
operator|->
name|pm_value
condition|)
name|idx
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_100T4
index|]
operator|.
name|pm_regno
condition|)
block|{
specifier|const
name|tulip_phy_modedata_t
modifier|*
specifier|const
name|pm
init|=
operator|&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_100T4
index|]
decl_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|pm
operator|->
name|pm_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|pm
operator|->
name|pm_mask
operator|)
operator|==
name|pm
operator|->
name|pm_value
condition|)
name|idx
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_10T
index|]
operator|.
name|pm_regno
condition|)
block|{
specifier|const
name|tulip_phy_modedata_t
modifier|*
specifier|const
name|pm
init|=
operator|&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_10T
index|]
decl_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|pm
operator|->
name|pm_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|pm
operator|->
name|pm_mask
operator|)
operator|==
name|pm
operator|->
name|pm_value
condition|)
name|idx
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|!=
literal|0
operator|&&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_FULLDUPLEX
index|]
operator|.
name|pm_regno
condition|)
block|{
specifier|const
name|tulip_phy_modedata_t
modifier|*
specifier|const
name|pm
init|=
operator|&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_FULLDUPLEX
index|]
decl_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_phyaddr
argument_list|,
name|pm
operator|->
name|pm_regno
argument_list|)
expr_stmt|;
name|idx
operator|+=
operator|(
operator|(
name|data
operator|&
name|pm
operator|->
name|pm_mask
operator|)
operator|==
name|pm
operator|->
name|pm_value
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|table
index|[
name|idx
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|tulip_mii_get_phyaddr
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|offset
parameter_list|)
block|{
name|unsigned
name|phyaddr
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|phyaddr
operator|=
literal|1
init|;
name|phyaddr
operator|<
literal|32
condition|;
name|phyaddr
operator|++
control|)
block|{
name|unsigned
name|status
init|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|0xFFFF
operator|||
name|status
operator|<
name|PHYSTS_10BASET
condition|)
continue|continue;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
name|phyaddr
return|;
name|offset
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|unsigned
name|status
init|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|PHYREG_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|0xFFFF
operator|||
name|status
operator|<
name|PHYSTS_10BASET
condition|)
return|return
name|TULIP_MII_NOPHY
return|;
return|return
literal|0
return|;
block|}
return|return
name|TULIP_MII_NOPHY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_mii_map_abilities
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|abilities
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_abilities
operator|=
name|abilities
expr_stmt|;
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_100BASETX_FD
condition|)
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_100BASETX_FD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_100BASET4
condition|)
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_100BASET4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_100BASETX
condition|)
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_10BASET_FD
condition|)
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_10BASET_FD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_10BASET
condition|)
block|{
name|sc
operator|->
name|tulip_probe_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_mii_autonegotiate
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
specifier|const
name|unsigned
name|phyaddr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|tulip_ifp
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|tulip_probe_state
condition|)
block|{
case|case
name|TULIP_PROBE_MEDIATEST
case|:
case|case
name|TULIP_PROBE_INACTIVE
case|:
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_DIDNWAY
expr_stmt|;
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|,
name|PHYCTL_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|3000
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_NORMALINTR
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_PHYRESET
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|TULIP_PROBE_PHYRESET
case|:
block|{
name|u_int32_t
name|status
decl_stmt|;
name|u_int32_t
name|data
init|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|&
name|PHYCTL_RESET
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_probe_timeout
operator|>
literal|0
condition|)
block|{
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s(phy%d): error: reset of PHY never completed!\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phyaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_FAILED
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|PHYSTS_CAN_AUTONEG
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|loudprintf
argument_list|(
literal|"%s(phy%d): autonegotiation disabled\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phyaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DIDNWAY
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_AUTONEG_ADVERTISEMENT
argument_list|)
operator|!=
operator|(
operator|(
name|status
operator|>>
literal|6
operator|)
operator||
literal|0x01
operator|)
condition|)
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_AUTONEG_ADVERTISEMENT
argument_list|,
operator|(
name|status
operator|>>
literal|6
operator|)
operator||
literal|0x01
argument_list|)
expr_stmt|;
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|,
name|data
operator||
name|PHYCTL_AUTONEG_RESTART
operator||
name|PHYCTL_AUTONEG_ENABLE
argument_list|)
expr_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|data
operator|&
name|PHYCTL_AUTONEG_ENABLE
operator|)
operator|==
literal|0
condition|)
name|loudprintf
argument_list|(
literal|"%s(phy%d): oops: enable autonegotiation failed: 0x%04x\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phyaddr
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|loudprintf
argument_list|(
literal|"%s(phy%d): autonegotiation restarted: 0x%04x\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phyaddr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_nway_starts
operator|++
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_PHYAUTONEG
expr_stmt|;
name|sc
operator|->
name|tulip_probe_timeout
operator|=
literal|3000
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|TULIP_PROBE_PHYAUTONEG
case|:
block|{
name|u_int32_t
name|status
init|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|PHYSTS_AUTONEG_DONE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_probe_timeout
operator|>
literal|0
condition|)
block|{
name|tulip_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|loudprintf
argument_list|(
literal|"%s(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phyaddr
argument_list|,
name|status
argument_list|,
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DIDNWAY
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
return|return;
block|}
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phyaddr
argument_list|,
name|PHYREG_AUTONEG_ABILITIES
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|loudprintf
argument_list|(
literal|"%s(phy%d): autonegotiation complete: 0x%04x\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phyaddr
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data
operator|=
operator|(
name|data
operator|<<
literal|6
operator|)
operator|&
name|status
expr_stmt|;
if|if
condition|(
operator|!
name|tulip_mii_map_abilities
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
condition|)
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DIDNWAY
expr_stmt|;
return|return;
block|}
default|default:
block|{
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
name|panic
argument_list|(
literal|"tulip_media_poll: botch at line %d\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|loudprintf
argument_list|(
literal|"%s(phy%d): autonegotiation failure: state = %d\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phyaddr
argument_list|,
name|sc
operator|->
name|tulip_probe_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_nway_failures
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_2114x_media_preset
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
specifier|const
name|tulip_media_info_t
modifier|*
name|mi
init|=
name|NULL
decl_stmt|;
name|tulip_media_t
name|media
init|=
name|sc
operator|->
name|tulip_media
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_INACTIVE
condition|)
name|media
operator|=
name|sc
operator|->
name|tulip_media
expr_stmt|;
else|else
name|media
operator|=
name|sc
operator|->
name|tulip_probe_media
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_PORTSELECT
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_SQETEST
expr_stmt|;
if|if
condition|(
name|media
operator|!=
name|TULIP_MEDIA_UNKNOWN
operator|&&
name|media
operator|!=
name|TULIP_MEDIA_MAX
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
name|media
operator|<
name|TULIP_MEDIA_MAX
operator|&&
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|!=
name|NULL
condition|)
block|{
endif|#
directive|endif
name|mi
operator|=
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_MII
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_PORTSELECT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_GPR
operator|||
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_SYM
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_GPR_CMDBITS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|mi
operator|->
name|mi_cmdmode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|==
name|TULIP_MEDIAINFO_SIA
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"preset: bad media %d!\n"
argument_list|,
name|media
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
switch|switch
condition|(
name|media
condition|)
block|{
case|case
name|TULIP_MEDIA_BNC
case|:
case|case
name|TULIP_MEDIA_AUI
case|:
case|case
name|TULIP_MEDIA_10BASET
case|:
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_10BASET_FD
case|:
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
operator||
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_100BASEFX
case|:
case|case
name|TULIP_MEDIA_100BASET4
case|:
case|case
name|TULIP_MEDIA_100BASETX
case|:
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
operator|(
name|TULIP_CMD_FULLDUPLEX
operator||
name|TULIP_CMD_TXTHRSHLDCTL
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_PORTSELECT
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_100BASEFX_FD
case|:
case|case
name|TULIP_MEDIA_100BASETX_FD
case|:
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
operator||
name|TULIP_CMD_PORTSELECT
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
break|break;
block|}
default|default:
block|{
break|break;
block|}
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  ********************************************************************  *  Start of 21140/21140A support which does not use the MII interface   */
end_comment

begin_function
specifier|static
name|void
name|tulip_null_media_poll
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_mediapoll_event_t
name|event
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_events
index|[
name|event
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"botch(media_poll) at line %d\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|__inline
specifier|static
name|void
name|tulip_21140_mediainit
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_media_info_t
modifier|*
specifier|const
name|mip
parameter_list|,
name|tulip_media_t
specifier|const
name|media
parameter_list|,
name|unsigned
name|gpdata
parameter_list|,
name|unsigned
name|cmdmode
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|=
name|mip
expr_stmt|;
name|mip
operator|->
name|mi_type
operator|=
name|TULIP_MEDIAINFO_GPR
expr_stmt|;
name|mip
operator|->
name|mi_cmdmode
operator|=
name|cmdmode
expr_stmt|;
name|mip
operator|->
name|mi_gpdata
operator|=
name|gpdata
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_evalboard_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_media_info_t
modifier|*
name|mip
init|=
name|sc
operator|->
name|tulip_mediainfo
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_gpinit
operator|=
name|TULIP_GP_EB_PINS
expr_stmt|;
name|sc
operator|->
name|tulip_gpdata
operator|=
name|TULIP_GP_EB_INIT
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EB_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EB_INIT
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator||
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|&
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
operator|&
name|TULIP_GP_EB_OK100
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
block|}
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_10BASET
argument_list|,
name|TULIP_GP_EB_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_10BASET_FD
argument_list|,
name|TULIP_GP_EB_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX
argument_list|,
name|TULIP_GP_EB_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX_FD
argument_list|,
name|TULIP_GP_EB_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_eb_boardsw
init|=
block|{
name|TULIP_21140_DEC_EB
block|,
name|tulip_21140_evalboard_media_probe
block|,
name|tulip_media_select
block|,
name|tulip_null_media_poll
block|,
name|tulip_2114x_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tulip_21140_accton_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_media_info_t
modifier|*
name|mip
init|=
name|sc
operator|->
name|tulip_mediainfo
decl_stmt|;
name|unsigned
name|gpdata
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_gpinit
operator|=
name|TULIP_GP_EB_PINS
expr_stmt|;
name|sc
operator|->
name|tulip_gpdata
operator|=
name|TULIP_GP_EB_INIT
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EB_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EB_INIT
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator||
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|&
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|gpdata
operator|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gpdata
operator|&
name|TULIP_GP_EN1207_UTP_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|gpdata
operator|&
name|TULIP_GP_EN1207_BNC_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_BNC
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
block|}
block|}
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_BNC
argument_list|,
name|TULIP_GP_EN1207_BNC_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_10BASET
argument_list|,
name|TULIP_GP_EN1207_UTP_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_10BASET_FD
argument_list|,
name|TULIP_GP_EN1207_UTP_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX
argument_list|,
name|TULIP_GP_EN1207_100_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX_FD
argument_list|,
name|TULIP_GP_EN1207_100_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_accton_boardsw
init|=
block|{
name|TULIP_21140_EN1207
block|,
name|tulip_21140_accton_media_probe
block|,
name|tulip_media_select
block|,
name|tulip_null_media_poll
block|,
name|tulip_2114x_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tulip_21140_smc9332_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_media_info_t
modifier|*
name|mip
init|=
name|sc
operator|->
name|tulip_mediainfo
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_gpinit
operator|=
name|TULIP_GP_SMC_9332_PINS
expr_stmt|;
name|sc
operator|->
name|tulip_gpdata
operator|=
name|TULIP_GP_SMC_9332_INIT
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_SMC_9332_PINS
operator||
name|TULIP_GP_PINSET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_SMC_9332_INIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|1000
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
block|{
name|u_int32_t
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
operator|(
name|TULIP_GP_SMC_9332_OK10
operator||
name|TULIP_GP_SMC_9332_OK100
operator|)
operator|)
operator|==
operator|(
name|TULIP_GP_SMC_9332_OK10
operator||
name|TULIP_GP_SMC_9332_OK100
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|cnt
operator|>
literal|100
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|csr
operator|&
name|TULIP_GP_SMC_9332_OK10
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_media
operator|=
name|cnt
operator|>
literal|100
condition|?
name|TULIP_MEDIA_100BASETX
else|:
name|TULIP_MEDIA_10BASET
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX
argument_list|,
name|TULIP_GP_SMC_9332_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX_FD
argument_list|,
name|TULIP_GP_SMC_9332_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_10BASET
argument_list|,
name|TULIP_GP_SMC_9332_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_10BASET_FD
argument_list|,
name|TULIP_GP_SMC_9332_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_smc9332_boardsw
init|=
block|{
name|TULIP_21140_SMC_9332
block|,
name|tulip_21140_smc9332_media_probe
block|,
name|tulip_media_select
block|,
name|tulip_null_media_poll
block|,
name|tulip_2114x_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tulip_21140_cogent_em100_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_media_info_t
modifier|*
name|mip
init|=
name|sc
operator|->
name|tulip_mediainfo
decl_stmt|;
name|u_int32_t
name|cmdmode
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_gpinit
operator|=
name|TULIP_GP_EM100_PINS
expr_stmt|;
name|sc
operator|->
name|tulip_gpdata
operator|=
name|TULIP_GP_EM100_INIT
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EM100_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EM100_INIT
argument_list|)
expr_stmt|;
name|cmdmode
operator|=
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_MUSTBEONE
expr_stmt|;
name|cmdmode
operator|&=
operator|~
operator|(
name|TULIP_CMD_TXTHRSHLDCTL
operator||
name|TULIP_CMD_SCRAMBLER
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|32
index|]
operator|==
name|TULIP_COGENT_EM100FX_ID
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|cmdmode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASEFX
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASEFX
argument_list|,
name|TULIP_GP_EM100_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASEFX_FD
argument_list|,
name|TULIP_GP_EM100_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|cmdmode
operator||
name|TULIP_CMD_SCRAMBLER
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX
argument_list|,
name|TULIP_GP_EM100_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX_FD
argument_list|,
name|TULIP_GP_EM100_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_cogent_em100_boardsw
init|=
block|{
name|TULIP_21140_COGENT_EM100
block|,
name|tulip_21140_cogent_em100_media_probe
block|,
name|tulip_media_select
block|,
name|tulip_null_media_poll
block|,
name|tulip_2114x_media_preset
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tulip_21140_znyx_zx34x_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_media_info_t
modifier|*
name|mip
init|=
name|sc
operator|->
name|tulip_mediainfo
decl_stmt|;
name|int
name|cnt10
init|=
literal|0
decl_stmt|,
name|cnt100
init|=
literal|0
decl_stmt|,
name|idx
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_gpinit
operator|=
name|TULIP_GP_ZX34X_PINS
expr_stmt|;
name|sc
operator|->
name|tulip_gpdata
operator|=
name|TULIP_GP_ZX34X_INIT
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_ZX34X_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_ZX34X_INIT
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator||
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|&
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|1000
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
block|{
name|u_int32_t
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
operator|(
name|TULIP_GP_ZX34X_LNKFAIL
operator||
name|TULIP_GP_ZX34X_SYMDET
operator||
name|TULIP_GP_ZX34X_SIGDET
operator|)
operator|)
operator|==
operator|(
name|TULIP_GP_ZX34X_LNKFAIL
operator||
name|TULIP_GP_ZX34X_SYMDET
operator||
name|TULIP_GP_ZX34X_SIGDET
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|cnt100
operator|>
literal|100
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|csr
operator|&
name|TULIP_GP_ZX34X_LNKFAIL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|cnt10
operator|>
literal|100
condition|)
break|break;
block|}
else|else
block|{
name|cnt10
operator|=
literal|0
expr_stmt|;
name|cnt100
operator|=
literal|0
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_media
operator|=
name|cnt100
operator|>
literal|100
condition|?
name|TULIP_MEDIA_100BASETX
else|:
name|TULIP_MEDIA_10BASET
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_10BASET
argument_list|,
name|TULIP_GP_ZX34X_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_10BASET_FD
argument_list|,
name|TULIP_GP_ZX34X_INIT
argument_list|,
name|TULIP_CMD_TXTHRSHLDCTL
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX
argument_list|,
name|TULIP_GP_ZX34X_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
argument_list|)
expr_stmt|;
name|tulip_21140_mediainit
argument_list|(
name|sc
argument_list|,
name|mip
operator|++
argument_list|,
name|TULIP_MEDIA_100BASETX_FD
argument_list|,
name|TULIP_GP_ZX34X_INIT
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_FULLDUPLEX
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_znyx_zx34x_boardsw
init|=
block|{
name|TULIP_21140_ZNYX_ZX34X
block|,
name|tulip_21140_znyx_zx34x_media_probe
block|,
name|tulip_media_select
block|,
name|tulip_null_media_poll
block|,
name|tulip_2114x_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tulip_2114x_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_MUSTBEONE
operator||
name|TULIP_CMD_BACKOFFCTR
operator||
name|TULIP_CMD_THRSHLD72
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_2114x_isv_boardsw
init|=
block|{
name|TULIP_21140_ISV
block|,
name|tulip_2114x_media_probe
block|,
name|tulip_media_select
block|,
name|tulip_media_poll
block|,
name|tulip_2114x_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ******** END of chip-specific handlers. ***********  */
end_comment

begin_comment
comment|/*  * Code the read the SROM and MII bit streams (I2C)  */
end_comment

begin_define
define|#
directive|define
name|EMIT
value|do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); DELAY(1); } while (0)
end_define

begin_function
specifier|static
name|void
name|tulip_srom_idle
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|bit
decl_stmt|,
name|csr
decl_stmt|;
name|csr
operator|=
name|SROMSEL
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCS
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/*      * Write 25 cycles of 0 which will force the SROM to be idle.      */
for|for
control|(
name|bit
operator|=
literal|3
operator|+
name|SROM_BITWIDTH
operator|+
literal|16
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|--
control|)
block|{
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; data not valid */
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock high; data valid */
block|}
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCS
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
name|EMIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_srom_read
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|idx
decl_stmt|;
specifier|const
name|unsigned
name|bitwidth
init|=
name|SROM_BITWIDTH
decl_stmt|;
specifier|const
name|unsigned
name|cmdmask
init|=
operator|(
name|SROMCMD_RD
operator|<<
name|bitwidth
operator|)
decl_stmt|;
specifier|const
name|unsigned
name|msb
init|=
literal|1
operator|<<
operator|(
name|bitwidth
operator|+
literal|3
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|lastidx
init|=
operator|(
literal|1
operator|<<
name|bitwidth
operator|)
operator|-
literal|1
decl_stmt|;
name|tulip_srom_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<=
name|lastidx
condition|;
name|idx
operator|++
control|)
block|{
name|unsigned
name|lastbit
decl_stmt|,
name|data
decl_stmt|,
name|bits
decl_stmt|,
name|bit
decl_stmt|,
name|csr
decl_stmt|;
name|csr
operator|=
name|SROMSEL
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCSON
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
name|lastbit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bits
operator|=
name|idx
operator||
name|cmdmask
operator|,
name|bit
operator|=
name|bitwidth
operator|+
literal|3
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|--
operator|,
name|bits
operator|<<=
literal|1
control|)
block|{
specifier|const
name|unsigned
name|thisbit
init|=
name|bits
operator|&
name|msb
decl_stmt|;
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; data not valid */
if|if
condition|(
name|thisbit
operator|!=
name|lastbit
condition|)
block|{
name|csr
operator|^=
name|SROMDOUT
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; invert data */
block|}
else|else
block|{
name|EMIT
expr_stmt|;
block|}
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|lastbit
operator|=
name|thisbit
expr_stmt|;
block|}
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|bits
operator|=
literal|0
init|;
name|bits
operator|<
literal|16
condition|;
name|bits
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|data
operator||=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
name|SROMDIN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
operator|*
literal|2
index|]
operator|=
name|data
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|data
operator|>>
literal|8
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
name|EMIT
expr_stmt|;
block|}
name|tulip_srom_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MII_EMIT
value|do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); DELAY(1); } while (0)
end_define

begin_function
specifier|static
name|void
name|tulip_mii_writebits
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|data
parameter_list|,
name|unsigned
name|bits
parameter_list|)
block|{
name|unsigned
name|msb
init|=
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|unsigned
name|lastbit
init|=
operator|(
name|csr
operator|&
name|MII_DOUT
operator|)
condition|?
name|msb
else|:
literal|0
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator||=
name|MII_WR
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; assert write */
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
operator|,
name|data
operator|<<=
literal|1
control|)
block|{
specifier|const
name|unsigned
name|thisbit
init|=
name|data
operator|&
name|msb
decl_stmt|;
if|if
condition|(
name|thisbit
operator|!=
name|lastbit
condition|)
block|{
name|csr
operator|^=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; invert data */
block|}
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|lastbit
operator|=
name|thisbit
expr_stmt|;
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_mii_turnaround
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|cmd
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MII_WRCMD
condition|)
block|{
name|csr
operator||=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; change data */
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
name|csr
operator|^=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; change data */
block|}
else|else
block|{
name|csr
operator||=
name|MII_RD
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; switch to read */
block|}
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
end_function

begin_function
specifier|static
name|unsigned
name|tulip_mii_readbits
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|data
decl_stmt|;
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|data
operator|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
comment|/* this is NOOP on the first pass through */
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
if|if
condition|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
name|MII_DIN
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
name|csr
operator|^=
name|MII_RD
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; turn off read */
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|tulip_mii_readreg
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|unsigned
name|data
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|MII_RD
operator||
name|MII_CLK
operator|)
expr_stmt|;
name|MII_EMIT
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_PREAMBLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_RDCMD
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tulip_mii_turnaround
argument_list|(
name|sc
argument_list|,
name|MII_RDCMD
argument_list|)
expr_stmt|;
name|data
operator|=
name|tulip_mii_readbits
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_phyregs
index|[
name|regno
index|]
index|[
literal|0
index|]
operator|=
name|data
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_phyregs
index|[
name|regno
index|]
index|[
literal|1
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_mii_writereg
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|,
name|unsigned
name|data
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|MII_RD
operator||
name|MII_CLK
operator|)
expr_stmt|;
name|MII_EMIT
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_PREAMBLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_WRCMD
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tulip_mii_turnaround
argument_list|(
name|sc
argument_list|,
name|MII_WRCMD
argument_list|)
expr_stmt|;
name|tulip_mii_writebits
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_phyregs
index|[
name|regno
index|]
index|[
literal|2
index|]
operator|=
name|data
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_phyregs
index|[
name|regno
index|]
index|[
literal|3
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|tulip_mchash
parameter_list|(
name|mca
parameter_list|)
value|(ether_crc32_le(mca, 6)& 0x1FF)
end_define

begin_define
define|#
directive|define
name|tulip_srom_crcok
parameter_list|(
name|databuf
parameter_list|)
value|( \     ((ether_crc32_le(databuf, 126)& 0xFFFFU) ^ 0xFFFFU) == \      ((databuf)[126] | ((databuf)[127]<< 8)))
end_define

begin_function
specifier|static
name|void
name|tulip_identify_dec_nic
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"DEC "
argument_list|)
expr_stmt|;
define|#
directive|define
name|D0
value|4
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|<=
name|TULIP_21040
condition|)
return|return;
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|tulip_rombuf
operator|+
literal|29
argument_list|,
literal|"DE500"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|bcmp
argument_list|(
name|sc
operator|->
name|tulip_rombuf
operator|+
literal|29
argument_list|,
literal|"DE450"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_rombuf
operator|+
literal|29
argument_list|,
operator|&
name|sc
operator|->
name|tulip_boardid
index|[
name|D0
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardid
index|[
name|D0
operator|+
literal|8
index|]
operator|=
literal|' '
expr_stmt|;
block|}
undef|#
directive|undef
name|D0
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_identify_znyx_nic
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|id
init|=
literal|0
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"ZNYX ZX3XX "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140
operator|||
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
condition|)
block|{
name|unsigned
name|znyx_ptr
decl_stmt|;
name|sc
operator|->
name|tulip_boardid
index|[
literal|8
index|]
operator|=
literal|'4'
expr_stmt|;
name|znyx_ptr
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|124
index|]
operator|+
literal|256
operator|*
name|sc
operator|->
name|tulip_rombuf
index|[
literal|125
index|]
expr_stmt|;
if|if
condition|(
name|znyx_ptr
operator|<
literal|26
operator|||
name|znyx_ptr
operator|>
literal|116
condition|)
block|{
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_znyx_zx34x_boardsw
expr_stmt|;
return|return;
block|}
comment|/* ZX344 = 0010 .. 0013FF 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
name|znyx_ptr
index|]
operator|==
literal|0x4A
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
name|znyx_ptr
operator|+
literal|1
index|]
operator|==
literal|0x52
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
name|znyx_ptr
operator|+
literal|2
index|]
operator|==
literal|0x01
condition|)
block|{
name|id
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
name|znyx_ptr
operator|+
literal|5
index|]
operator|+
literal|256
operator|*
name|sc
operator|->
name|tulip_rombuf
index|[
name|znyx_ptr
operator|+
literal|4
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|>>
literal|8
operator|)
operator|==
operator|(
name|TULIP_ZNYX_ID_ZX342
operator|>>
literal|8
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'2'
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX342B
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|10
index|]
operator|=
literal|'B'
expr_stmt|;
name|sc
operator|->
name|tulip_boardid
index|[
literal|11
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_znyx_zx34x_boardsw
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX344
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|10
index|]
operator|=
literal|'4'
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_znyx_zx34x_boardsw
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX345
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|19
index|]
operator|>
literal|1
operator|)
condition|?
literal|'8'
else|:
literal|'5'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX346
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'6'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX351
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|8
index|]
operator|=
literal|'5'
expr_stmt|;
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'1'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Assume it's a ZX342... 	     */
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_znyx_zx34x_boardsw
expr_stmt|;
block|}
return|return;
block|}
name|sc
operator|->
name|tulip_boardid
index|[
literal|8
index|]
operator|=
literal|'1'
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|10
index|]
operator|=
literal|'1'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|32
index|]
operator|==
literal|0x4A
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|33
index|]
operator|==
literal|0x52
condition|)
block|{
name|id
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|37
index|]
operator|+
literal|256
operator|*
name|sc
operator|->
name|tulip_rombuf
index|[
literal|36
index|]
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX312T
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'2'
expr_stmt|;
name|sc
operator|->
name|tulip_boardid
index|[
literal|10
index|]
operator|=
literal|'T'
expr_stmt|;
name|sc
operator|->
name|tulip_boardid
index|[
literal|11
index|]
operator|=
literal|' '
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_10baset_only_boardsw
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX314_INTA
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'4'
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_10baset_only_boardsw
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SHAREDINTR
operator||
name|TULIP_HAVE_BASEROM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX314
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'4'
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_10baset_only_boardsw
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_BASEROM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX315_INTA
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'5'
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SHAREDINTR
operator||
name|TULIP_HAVE_BASEROM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|TULIP_ZNYX_ID_ZX315
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'5'
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_BASEROM
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_enaddr
index|[
literal|3
index|]
operator|&
operator|~
literal|3
operator|)
operator|==
literal|0xF0
operator|&&
operator|(
name|sc
operator|->
name|tulip_enaddr
index|[
literal|5
index|]
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'4'
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_10baset_only_boardsw
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SHAREDINTR
operator||
name|TULIP_HAVE_BASEROM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_enaddr
index|[
literal|3
index|]
operator|&
operator|~
literal|3
operator|)
operator|==
literal|0xF4
operator|&&
operator|(
name|sc
operator|->
name|tulip_enaddr
index|[
literal|5
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'5'
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_boardsw
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SHAREDINTR
operator||
name|TULIP_HAVE_BASEROM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_enaddr
index|[
literal|3
index|]
operator|&
operator|~
literal|3
operator|)
operator|==
literal|0xEC
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|9
index|]
operator|=
literal|'2'
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_boardsw
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_identify_smc_nic
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|u_int32_t
name|id1
decl_stmt|,
name|id2
decl_stmt|,
name|ei
decl_stmt|;
name|int
name|auibnc
init|=
literal|0
decl_stmt|,
name|utp
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"SMC "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|!=
name|TULIP_21040
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|!=
operator|&
name|tulip_2114x_isv_boardsw
condition|)
block|{
name|strcpy
argument_list|(
operator|&
name|sc
operator|->
name|tulip_boardid
index|[
literal|4
index|]
argument_list|,
literal|"9332DST "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_smc9332_boardsw
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
operator|(
name|TULIP_HAVE_BASEROM
operator||
name|TULIP_HAVE_SLAVEDROM
operator|)
condition|)
block|{
name|strcpy
argument_list|(
operator|&
name|sc
operator|->
name|tulip_boardid
index|[
literal|4
index|]
argument_list|,
literal|"9334BDT "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
operator|&
name|sc
operator|->
name|tulip_boardid
index|[
literal|4
index|]
argument_list|,
literal|"9332BDT "
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|id1
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x60
index|]
operator||
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x61
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|id2
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x62
index|]
operator||
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x63
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|ei
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x66
index|]
operator||
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x67
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|sc
operator|->
name|tulip_boardid
index|[
literal|4
index|]
argument_list|,
literal|"8432"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|sc
operator|->
name|tulip_boardid
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'B'
operator|,
name|auibnc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|&
literal|0xFF
operator|)
operator|>
literal|0x32
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'T'
operator|,
name|utp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|&
literal|0x4000
operator|)
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'A'
operator|,
name|auibnc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|id2
operator|==
literal|0x15
condition|)
block|{
name|sc
operator|->
name|tulip_boardid
index|[
literal|7
index|]
operator|=
literal|'4'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'C'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'H'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|ei
condition|?
literal|'2'
else|:
literal|'1'
operator|)
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|utp
operator|&&
operator|!
name|auibnc
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_10baset_only_boardsw
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|utp
operator|&&
name|auibnc
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_auibnc_only_boardsw
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_identify_cogent_nic
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"Cogent "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140
operator|||
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|32
index|]
operator|==
name|TULIP_COGENT_EM100TX_ID
condition|)
block|{
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"EM100TX "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_cogent_em100_boardsw
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_COGENT_EM110TX_ID
argument_list|)
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|32
index|]
operator|==
name|TULIP_COGENT_EM110TX_ID
condition|)
block|{
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"EM110TX "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_cogent_em100_boardsw
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|32
index|]
operator|==
name|TULIP_COGENT_EM100FX_ID
condition|)
block|{
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"EM100FX "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_cogent_em100_boardsw
expr_stmt|;
block|}
comment|/* 	 * Magic number (0x24001109U) is the SubVendor (0x2400) and 	 * SubDevId (0x1109) for the ANA6944TX (EM440TX). 	 */
if|if
condition|(
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|sc
operator|->
name|tulip_rombuf
operator|==
literal|0x24001109U
operator|&&
operator|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_BASEROM
operator|)
condition|)
block|{
comment|/* 	     * Cogent (Adaptec) is still mapping all INTs to INTA of 	     * first 21140.  Dumb!  Dumb! 	     */
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"EM440TX "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SHAREDINTR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21040
condition|)
block|{
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SHAREDINTR
operator||
name|TULIP_HAVE_BASEROM
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_identify_accton_nic
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"ACCTON "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|tulip_chipid
condition|)
block|{
case|case
name|TULIP_21140A
case|:
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"EN1207 "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|!=
operator|&
name|tulip_2114x_isv_boardsw
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_accton_boardsw
expr_stmt|;
break|break;
case|case
name|TULIP_21140
case|:
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"EN1207TX "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|!=
operator|&
name|tulip_2114x_isv_boardsw
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_eb_boardsw
expr_stmt|;
break|break;
case|case
name|TULIP_21040
case|:
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"EN1203 "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_boardsw
expr_stmt|;
break|break;
case|case
name|TULIP_21041
case|:
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"EN1203 "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21041_boardsw
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_2114x_isv_boardsw
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_identify_asante_nic
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"Asante "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140
operator|||
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
operator|)
operator|&&
name|sc
operator|->
name|tulip_boardsw
operator|!=
operator|&
name|tulip_2114x_isv_boardsw
condition|)
block|{
name|tulip_media_info_t
modifier|*
name|mi
init|=
name|sc
operator|->
name|tulip_mediainfo
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* 	 * The Asante Fast Ethernet doesn't always ship with a valid 	 * new format SROM.  So if isn't in the new format, we cheat 	 * set it up as if we had. 	 */
name|sc
operator|->
name|tulip_gpinit
operator|=
name|TULIP_GP_ASANTE_PINS
expr_stmt|;
name|sc
operator|->
name|tulip_gpdata
operator|=
literal|0
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_ASANTE_PINS
operator||
name|TULIP_GP_PINSET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_ASANTE_PHYRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_type
operator|=
name|TULIP_MEDIAINFO_MII
expr_stmt|;
name|mi
operator|->
name|mi_gpr_length
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|mi_gpr_offset
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|mi_reset_length
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|mi_reset_offset
operator|=
literal|0
expr_stmt|;
empty_stmt|;
name|mi
operator|->
name|mi_phyaddr
operator|=
name|TULIP_MII_NOPHY
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|20
init|;
name|idx
operator|>
literal|0
operator|&&
name|mi
operator|->
name|mi_phyaddr
operator|==
name|TULIP_MII_NOPHY
condition|;
name|idx
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_phyaddr
operator|=
name|tulip_mii_get_phyaddr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mi
operator|->
name|mi_phyaddr
operator|==
name|TULIP_MII_NOPHY
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"can't find phy 0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_MII
expr_stmt|;
name|mi
operator|->
name|mi_capabilities
operator|=
name|PHYSTS_10BASET
operator||
name|PHYSTS_10BASET_FD
operator||
name|PHYSTS_100BASETX
operator||
name|PHYSTS_100BASETX_FD
expr_stmt|;
name|mi
operator|->
name|mi_advertisement
operator|=
name|PHYSTS_10BASET
operator||
name|PHYSTS_10BASET_FD
operator||
name|PHYSTS_100BASETX
operator||
name|PHYSTS_100BASETX_FD
expr_stmt|;
name|mi
operator|->
name|mi_full_duplex
operator|=
name|PHYSTS_10BASET_FD
operator||
name|PHYSTS_100BASETX_FD
expr_stmt|;
name|mi
operator|->
name|mi_tx_threshold
operator|=
name|PHYSTS_10BASET
operator||
name|PHYSTS_10BASET_FD
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASETX_FD
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASETX
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASET4
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_phyid
operator|=
operator|(
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|mi
operator|->
name|mi_phyaddr
argument_list|,
name|PHYREG_IDLOW
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|mi
operator|->
name|mi_phyaddr
argument_list|,
name|PHYREG_IDHIGH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_2114x_isv_boardsw
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_identify_compex_nic
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"COMPEX "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
condition|)
block|{
name|int
name|root_unit
decl_stmt|;
name|tulip_softc_t
modifier|*
name|root_sc
init|=
name|NULL
decl_stmt|;
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"400TX/PCI "
argument_list|)
expr_stmt|;
comment|/* 	 * All 4 chips on these boards share an interrupt.  This code 	 * copied from tulip_read_macaddr. 	 */
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SHAREDINTR
expr_stmt|;
for|for
control|(
name|root_unit
operator|=
name|sc
operator|->
name|tulip_unit
operator|-
literal|1
init|;
name|root_unit
operator|>=
literal|0
condition|;
name|root_unit
operator|--
control|)
block|{
name|root_sc
operator|=
name|tulips
index|[
name|root_unit
index|]
expr_stmt|;
if|if
condition|(
name|root_sc
operator|==
name|NULL
operator|||
operator|!
operator|(
name|root_sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_SLAVEDINTR
operator|)
condition|)
break|break;
name|root_sc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|root_sc
operator|!=
name|NULL
operator|&&
name|root_sc
operator|->
name|tulip_chipid
operator|==
name|sc
operator|->
name|tulip_chipid
operator|&&
name|root_sc
operator|->
name|tulip_pci_busno
operator|==
name|sc
operator|->
name|tulip_pci_busno
condition|)
block|{
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SLAVEDINTR
expr_stmt|;
name|sc
operator|->
name|tulip_slaves
operator|=
name|root_sc
operator|->
name|tulip_slaves
expr_stmt|;
name|root_sc
operator|->
name|tulip_slaves
operator|=
name|sc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_SLAVEDINTR
condition|)
block|{
name|printf
argument_list|(
literal|"\nCannot find master device for %s interrupts"
argument_list|,
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|strcat
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
literal|"unknown "
argument_list|)
expr_stmt|;
block|}
comment|/*      sc->tulip_boardsw =&tulip_21140_eb_boardsw; */
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_srom_decode
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|idx1
decl_stmt|,
name|idx2
decl_stmt|,
name|idx3
decl_stmt|;
specifier|const
name|tulip_srom_header_t
modifier|*
name|shp
init|=
operator|(
specifier|const
name|tulip_srom_header_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|tulip_srom_adapter_info_t
modifier|*
name|saip
init|=
operator|(
specifier|const
name|tulip_srom_adapter_info_t
operator|*
operator|)
operator|(
name|shp
operator|+
literal|1
operator|)
decl_stmt|;
name|tulip_srom_media_t
name|srom_media
decl_stmt|;
name|tulip_media_info_t
modifier|*
name|mi
init|=
name|sc
operator|->
name|tulip_mediainfo
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|dp
decl_stmt|;
name|u_int32_t
name|leaf_offset
decl_stmt|,
name|blocks
decl_stmt|,
name|data
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|idx1
operator|=
literal|0
init|;
name|idx1
operator|<
name|shp
operator|->
name|sh_adapter_count
condition|;
name|idx1
operator|++
operator|,
name|saip
operator|++
control|)
block|{
if|if
condition|(
name|shp
operator|->
name|sh_adapter_count
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|saip
operator|->
name|sai_device
operator|==
name|sc
operator|->
name|tulip_pci_devno
condition|)
break|break;
block|}
comment|/*      * Didn't find the right media block for this card.      */
if|if
condition|(
name|idx1
operator|==
name|shp
operator|->
name|sh_adapter_count
condition|)
return|return
literal|0
return|;
comment|/*      * Save the hardware address.      */
name|bcopy
argument_list|(
name|shp
operator|->
name|sh_ieee802_address
argument_list|,
name|sc
operator|->
name|tulip_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/*      * If this is a multiple port card, add the adapter index to the last      * byte of the hardware address.  (if it isn't multiport, adding 0      * won't hurt.      */
name|sc
operator|->
name|tulip_enaddr
index|[
literal|5
index|]
operator|+=
name|idx1
expr_stmt|;
name|leaf_offset
operator|=
name|saip
operator|->
name|sai_leaf_offset_lowbyte
operator|+
name|saip
operator|->
name|sai_leaf_offset_highbyte
operator|*
literal|256
expr_stmt|;
name|dp
operator|=
name|sc
operator|->
name|tulip_rombuf
operator|+
name|leaf_offset
expr_stmt|;
name|sc
operator|->
name|tulip_conntype
operator|=
call|(
name|tulip_srom_connection_t
call|)
argument_list|(
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|idx2
operator|=
literal|0
init|;
condition|;
name|idx2
operator|++
control|)
block|{
if|if
condition|(
name|tulip_srom_conninfo
index|[
name|idx2
index|]
operator|.
name|sc_type
operator|==
name|sc
operator|->
name|tulip_conntype
operator|||
name|tulip_srom_conninfo
index|[
name|idx2
index|]
operator|.
name|sc_type
operator|==
name|TULIP_SROM_CONNTYPE_NOT_USED
condition|)
break|break;
block|}
name|sc
operator|->
name|tulip_connidx
operator|=
name|idx2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
block|{
name|blocks
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
for|for
control|(
name|idx2
operator|=
literal|0
init|;
name|idx2
operator|<
name|blocks
condition|;
name|idx2
operator|++
control|)
block|{
name|tulip_media_t
name|media
decl_stmt|;
name|data
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|srom_media
operator|=
call|(
name|tulip_srom_media_t
call|)
argument_list|(
name|data
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|0
init|;
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_type
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|;
name|idx3
operator|++
control|)
block|{
if|if
condition|(
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_srom_type
operator|==
name|srom_media
condition|)
break|break;
block|}
name|media
operator|=
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_type
expr_stmt|;
if|if
condition|(
name|media
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
if|if
condition|(
name|data
operator|&
name|TULIP_SROM_21041_EXTENDED
condition|)
block|{
name|mi
operator|->
name|mi_type
operator|=
name|TULIP_MEDIAINFO_SIA
expr_stmt|;
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|=
name|mi
expr_stmt|;
name|mi
operator|->
name|mi_sia_connectivity
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|mi
operator|->
name|mi_sia_tx_rx
operator|=
name|dp
index|[
literal|2
index|]
operator|+
name|dp
index|[
literal|3
index|]
operator|*
literal|256
expr_stmt|;
name|mi
operator|->
name|mi_sia_general
operator|=
name|dp
index|[
literal|4
index|]
operator|+
name|dp
index|[
literal|5
index|]
operator|*
literal|256
expr_stmt|;
name|mi
operator|++
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|media
condition|)
block|{
case|case
name|TULIP_MEDIA_BNC
case|:
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21041
argument_list|,
name|BNC
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_AUI
case|:
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21041
argument_list|,
name|AUI
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_10BASET
case|:
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21041
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_10BASET_FD
case|:
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21041
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
break|break;
block|}
default|default:
block|{
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|data
operator|&
name|TULIP_SROM_21041_EXTENDED
condition|)
name|dp
operator|+=
literal|6
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|blocks
operator|==
literal|0
condition|)
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21041
argument_list|,
name|BNC
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21041
argument_list|,
name|AUI
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21041
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21041
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|unsigned
name|length
decl_stmt|,
name|type
decl_stmt|;
name|tulip_media_t
name|gp_media
init|=
name|TULIP_MEDIA_UNKNOWN
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_GPR
condition|)
name|sc
operator|->
name|tulip_gpinit
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|blocks
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
for|for
control|(
name|idx2
operator|=
literal|0
init|;
name|idx2
operator|<
name|blocks
condition|;
name|idx2
operator|++
control|)
block|{
specifier|const
name|u_int8_t
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|dp
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|length
operator|=
literal|4
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
operator|(
operator|*
name|dp
operator|++
operator|&
literal|0x7f
operator|)
operator|-
literal|1
expr_stmt|;
name|type
operator|=
operator|*
name|dp
operator|++
operator|&
literal|0x3f
expr_stmt|;
block|}
name|ep
operator|=
name|dp
operator|+
name|length
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
literal|0x3f
condition|)
block|{
case|case
literal|0
case|:
block|{
comment|/* 21140[A] GPR block */
name|tulip_media_t
name|media
decl_stmt|;
name|srom_media
operator|=
call|(
name|tulip_srom_media_t
call|)
argument_list|(
name|dp
index|[
literal|0
index|]
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|0
init|;
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_type
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|;
name|idx3
operator|++
control|)
block|{
if|if
condition|(
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_srom_type
operator|==
name|srom_media
condition|)
break|break;
block|}
name|media
operator|=
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_type
expr_stmt|;
if|if
condition|(
name|media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
break|break;
name|mi
operator|->
name|mi_type
operator|=
name|TULIP_MEDIAINFO_GPR
expr_stmt|;
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|=
name|mi
expr_stmt|;
name|mi
operator|->
name|mi_gpdata
operator|=
name|dp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|media
operator|>
name|gp_media
operator|&&
operator|!
name|TULIP_IS_MEDIA_FD
argument_list|(
name|media
argument_list|)
condition|)
block|{
name|sc
operator|->
name|tulip_gpdata
operator|=
name|mi
operator|->
name|mi_gpdata
expr_stmt|;
name|gp_media
operator|=
name|media
expr_stmt|;
block|}
name|data
operator|=
name|dp
index|[
literal|2
index|]
operator|+
name|dp
index|[
literal|3
index|]
operator|*
literal|256
expr_stmt|;
name|mi
operator|->
name|mi_cmdmode
operator|=
name|TULIP_SROM_2114X_CMDBITS
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|TULIP_SROM_2114X_NOINDICATOR
condition|)
block|{
name|mi
operator|->
name|mi_actmask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|mi->mi_default = (data& TULIP_SROM_2114X_DEFAULT) != 0;
endif|#
directive|endif
name|mi
operator|->
name|mi_actmask
operator|=
name|TULIP_SROM_2114X_BITPOS
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_actdata
operator|=
operator|(
name|data
operator|&
name|TULIP_SROM_2114X_POLARITY
operator|)
condition|?
literal|0
else|:
name|mi
operator|->
name|mi_actmask
expr_stmt|;
block|}
name|mi
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|1
case|:
block|{
comment|/* 21140[A] MII block */
specifier|const
name|unsigned
name|phyno
init|=
operator|*
name|dp
operator|++
decl_stmt|;
name|mi
operator|->
name|mi_type
operator|=
name|TULIP_MEDIAINFO_MII
expr_stmt|;
name|mi
operator|->
name|mi_gpr_length
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|mi
operator|->
name|mi_gpr_offset
operator|=
name|dp
operator|-
name|sc
operator|->
name|tulip_rombuf
expr_stmt|;
name|dp
operator|+=
name|mi
operator|->
name|mi_gpr_length
expr_stmt|;
name|mi
operator|->
name|mi_reset_length
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|mi
operator|->
name|mi_reset_offset
operator|=
name|dp
operator|-
name|sc
operator|->
name|tulip_rombuf
expr_stmt|;
name|dp
operator|+=
name|mi
operator|->
name|mi_reset_length
expr_stmt|;
comment|/* 		     * Before we probe for a PHY, use the GPR information 		     * to select it.  If we don't, it may be inaccessible. 		     */
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|sc
operator|->
name|tulip_gpinit
operator||
name|TULIP_GP_PINSET
argument_list|)
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|0
init|;
name|idx3
operator|<
name|mi
operator|->
name|mi_reset_length
condition|;
name|idx3
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|sc
operator|->
name|tulip_rombuf
index|[
name|mi
operator|->
name|mi_reset_offset
operator|+
name|idx3
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_phyaddr
operator|=
name|mi
operator|->
name|mi_phyaddr
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|0
init|;
name|idx3
operator|<
name|mi
operator|->
name|mi_gpr_length
condition|;
name|idx3
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|sc
operator|->
name|tulip_rombuf
index|[
name|mi
operator|->
name|mi_gpr_offset
operator|+
name|idx3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		     * At least write something! 		     */
if|if
condition|(
name|mi
operator|->
name|mi_reset_length
operator|==
literal|0
operator|&&
name|mi
operator|->
name|mi_gpr_length
operator|==
literal|0
condition|)
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_phyaddr
operator|=
name|TULIP_MII_NOPHY
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|20
init|;
name|idx3
operator|>
literal|0
operator|&&
name|mi
operator|->
name|mi_phyaddr
operator|==
name|TULIP_MII_NOPHY
condition|;
name|idx3
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_phyaddr
operator|=
name|tulip_mii_get_phyaddr
argument_list|(
name|sc
argument_list|,
name|phyno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mi
operator|->
name|mi_phyaddr
operator|==
name|TULIP_MII_NOPHY
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"can't find phy %d\n"
argument_list|,
name|phyno
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_MII
expr_stmt|;
name|mi
operator|->
name|mi_capabilities
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|mi
operator|->
name|mi_advertisement
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|mi
operator|->
name|mi_full_duplex
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|mi
operator|->
name|mi_tx_threshold
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASETX_FD
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASETX
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASET4
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_phyid
operator|=
operator|(
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|mi
operator|->
name|mi_phyaddr
argument_list|,
name|PHYREG_IDLOW
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|mi
operator|->
name|mi_phyaddr
argument_list|,
name|PHYREG_IDHIGH
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
comment|/* 2114[23] SIA block */
name|tulip_media_t
name|media
decl_stmt|;
name|srom_media
operator|=
call|(
name|tulip_srom_media_t
call|)
argument_list|(
name|dp
index|[
literal|0
index|]
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|0
init|;
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_type
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|;
name|idx3
operator|++
control|)
block|{
if|if
condition|(
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_srom_type
operator|==
name|srom_media
condition|)
break|break;
block|}
name|media
operator|=
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_type
expr_stmt|;
if|if
condition|(
name|media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
break|break;
name|mi
operator|->
name|mi_type
operator|=
name|TULIP_MEDIAINFO_SIA
expr_stmt|;
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|=
name|mi
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
block|{
name|mi
operator|->
name|mi_sia_connectivity
operator|=
name|dp
index|[
literal|1
index|]
operator|+
name|dp
index|[
literal|2
index|]
operator|*
literal|256
expr_stmt|;
name|mi
operator|->
name|mi_sia_tx_rx
operator|=
name|dp
index|[
literal|3
index|]
operator|+
name|dp
index|[
literal|4
index|]
operator|*
literal|256
expr_stmt|;
name|mi
operator|->
name|mi_sia_general
operator|=
name|dp
index|[
literal|5
index|]
operator|+
name|dp
index|[
literal|6
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|6
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|media
condition|)
block|{
case|case
name|TULIP_MEDIA_BNC
case|:
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21142
argument_list|,
name|BNC
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_AUI
case|:
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21142
argument_list|,
name|AUI
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_10BASET
case|:
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21142
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_10BASET_FD
case|:
block|{
name|TULIP_MEDIAINFO_SIA_INIT
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|21142
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
expr_stmt|;
break|break;
block|}
default|default:
block|{
goto|goto
name|bad_media
goto|;
block|}
block|}
block|}
name|mi
operator|->
name|mi_sia_gp_control
operator|=
operator|(
name|dp
index|[
literal|1
index|]
operator|+
name|dp
index|[
literal|2
index|]
operator|*
literal|256
operator|)
operator|<<
literal|16
expr_stmt|;
name|mi
operator|->
name|mi_sia_gp_data
operator|=
operator|(
name|dp
index|[
literal|3
index|]
operator|+
name|dp
index|[
literal|4
index|]
operator|*
literal|256
operator|)
operator|<<
literal|16
expr_stmt|;
name|mi
operator|++
expr_stmt|;
name|bad_media
label|:
break|break;
block|}
case|case
literal|3
case|:
block|{
comment|/* 2114[23] MII PHY block */
specifier|const
name|unsigned
name|phyno
init|=
operator|*
name|dp
operator|++
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|dp0
decl_stmt|;
name|mi
operator|->
name|mi_type
operator|=
name|TULIP_MEDIAINFO_MII
expr_stmt|;
name|mi
operator|->
name|mi_gpr_length
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|mi
operator|->
name|mi_gpr_offset
operator|=
name|dp
operator|-
name|sc
operator|->
name|tulip_rombuf
expr_stmt|;
name|dp
operator|+=
literal|2
operator|*
name|mi
operator|->
name|mi_gpr_length
expr_stmt|;
name|mi
operator|->
name|mi_reset_length
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|mi
operator|->
name|mi_reset_offset
operator|=
name|dp
operator|-
name|sc
operator|->
name|tulip_rombuf
expr_stmt|;
name|dp
operator|+=
literal|2
operator|*
name|mi
operator|->
name|mi_reset_length
expr_stmt|;
name|dp0
operator|=
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
name|mi
operator|->
name|mi_reset_offset
index|]
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|0
init|;
name|idx3
operator|<
name|mi
operator|->
name|mi_reset_length
condition|;
name|idx3
operator|++
operator|,
name|dp0
operator|+=
literal|2
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
operator|(
name|dp0
index|[
literal|0
index|]
operator|+
literal|256
operator|*
name|dp0
index|[
literal|1
index|]
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_phyaddr
operator|=
name|mi
operator|->
name|mi_phyaddr
expr_stmt|;
name|dp0
operator|=
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
name|mi
operator|->
name|mi_gpr_offset
index|]
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|0
init|;
name|idx3
operator|<
name|mi
operator|->
name|mi_gpr_length
condition|;
name|idx3
operator|++
operator|,
name|dp0
operator|+=
literal|2
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
operator|(
name|dp0
index|[
literal|0
index|]
operator|+
literal|256
operator|*
name|dp0
index|[
literal|1
index|]
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mi
operator|->
name|mi_reset_length
operator|==
literal|0
operator|&&
name|mi
operator|->
name|mi_gpr_length
operator|==
literal|0
condition|)
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_phyaddr
operator|=
name|TULIP_MII_NOPHY
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|20
init|;
name|idx3
operator|>
literal|0
operator|&&
name|mi
operator|->
name|mi_phyaddr
operator|==
name|TULIP_MII_NOPHY
condition|;
name|idx3
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_phyaddr
operator|=
name|tulip_mii_get_phyaddr
argument_list|(
name|sc
argument_list|,
name|phyno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mi
operator|->
name|mi_phyaddr
operator|==
name|TULIP_MII_NOPHY
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"can't find phy %d\n"
argument_list|,
name|phyno
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_MII
expr_stmt|;
name|mi
operator|->
name|mi_capabilities
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|mi
operator|->
name|mi_advertisement
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|mi
operator|->
name|mi_full_duplex
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|mi
operator|->
name|mi_tx_threshold
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|mi
operator|->
name|mi_mii_interrupt
operator|=
name|dp
index|[
literal|0
index|]
operator|+
name|dp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASETX_FD
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASETX
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|100BASET4
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|10BASET_FD
argument_list|)
expr_stmt|;
name|TULIP_MEDIAINFO_ADD_CAPABILITY
argument_list|(
name|sc
argument_list|,
name|mi
argument_list|,
literal|10BASET
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_phyid
operator|=
operator|(
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|mi
operator|->
name|mi_phyaddr
argument_list|,
name|PHYREG_IDLOW
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|mi
operator|->
name|mi_phyaddr
argument_list|,
name|PHYREG_IDHIGH
argument_list|)
expr_stmt|;
name|mi
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|4
case|:
block|{
comment|/* 21143 SYM block */
name|tulip_media_t
name|media
decl_stmt|;
name|srom_media
operator|=
operator|(
name|tulip_srom_media_t
operator|)
name|dp
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|idx3
operator|=
literal|0
init|;
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_type
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|;
name|idx3
operator|++
control|)
block|{
if|if
condition|(
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_srom_type
operator|==
name|srom_media
condition|)
break|break;
block|}
name|media
operator|=
name|tulip_srom_mediums
index|[
name|idx3
index|]
operator|.
name|sm_type
expr_stmt|;
if|if
condition|(
name|media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
break|break;
name|mi
operator|->
name|mi_type
operator|=
name|TULIP_MEDIAINFO_SYM
expr_stmt|;
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|=
name|mi
expr_stmt|;
name|mi
operator|->
name|mi_gpcontrol
operator|=
operator|(
name|dp
index|[
literal|1
index|]
operator|+
name|dp
index|[
literal|2
index|]
operator|*
literal|256
operator|)
operator|<<
literal|16
expr_stmt|;
name|mi
operator|->
name|mi_gpdata
operator|=
operator|(
name|dp
index|[
literal|3
index|]
operator|+
name|dp
index|[
literal|4
index|]
operator|*
literal|256
operator|)
operator|<<
literal|16
expr_stmt|;
name|data
operator|=
name|dp
index|[
literal|5
index|]
operator|+
name|dp
index|[
literal|6
index|]
operator|*
literal|256
expr_stmt|;
name|mi
operator|->
name|mi_cmdmode
operator|=
name|TULIP_SROM_2114X_CMDBITS
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|TULIP_SROM_2114X_NOINDICATOR
condition|)
block|{
name|mi
operator|->
name|mi_actmask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mi
operator|->
name|mi_default
operator|=
operator|(
name|data
operator|&
name|TULIP_SROM_2114X_DEFAULT
operator|)
operator|!=
literal|0
expr_stmt|;
name|mi
operator|->
name|mi_actmask
operator|=
name|TULIP_SROM_2114X_BITPOS
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_actdata
operator|=
operator|(
name|data
operator|&
name|TULIP_SROM_2114X_POLARITY
operator|)
condition|?
literal|0
else|:
name|mi
operator|->
name|mi_actmask
expr_stmt|;
block|}
if|if
condition|(
name|TULIP_IS_MEDIA_TP
argument_list|(
name|media
argument_list|)
condition|)
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
expr_stmt|;
name|mi
operator|++
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|case 5: {
comment|/* 21143 Reset block */
block|mi->mi_type = TULIP_MEDIAINFO_RESET; 		    mi->mi_reset_length = *dp++; 		    mi->mi_reset_offset = dp - sc->tulip_rombuf; 		    dp += 2 * mi->mi_reset_length; 		    mi++; 		    break; 		}
endif|#
directive|endif
default|default:
block|{ 		}
block|}
name|dp
operator|=
name|ep
expr_stmt|;
block|}
block|}
return|return
name|mi
operator|-
name|sc
operator|->
name|tulip_mediainfo
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|void
function_decl|(
modifier|*
name|vendor_identify_nic
function_decl|)
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
name|unsigned
name|char
name|vendor_oui
index|[
literal|3
index|]
decl_stmt|;
block|}
name|tulip_vendors
index|[]
init|=
block|{
block|{
name|tulip_identify_dec_nic
block|,
block|{
literal|0x08
block|,
literal|0x00
block|,
literal|0x2B
block|}
block|}
block|,
block|{
name|tulip_identify_dec_nic
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xF8
block|}
block|}
block|,
block|{
name|tulip_identify_smc_nic
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xC0
block|}
block|}
block|,
block|{
name|tulip_identify_smc_nic
block|,
block|{
literal|0x00
block|,
literal|0xE0
block|,
literal|0x29
block|}
block|}
block|,
block|{
name|tulip_identify_znyx_nic
block|,
block|{
literal|0x00
block|,
literal|0xC0
block|,
literal|0x95
block|}
block|}
block|,
block|{
name|tulip_identify_cogent_nic
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x92
block|}
block|}
block|,
block|{
name|tulip_identify_asante_nic
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x94
block|}
block|}
block|,
block|{
name|tulip_identify_cogent_nic
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xD1
block|}
block|}
block|,
block|{
name|tulip_identify_accton_nic
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xE8
block|}
block|}
block|,
block|{
name|tulip_identify_compex_nic
block|,
block|{
literal|0x00
block|,
literal|0x80
block|,
literal|0x48
block|}
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * This deals with the vagaries of the address roms and the  * brain-deadness that various vendors commit in using them.  */
end_comment

begin_function
specifier|static
name|int
name|tulip_read_macaddr
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|cksum
decl_stmt|,
name|rom_cksum
decl_stmt|,
name|idx
decl_stmt|;
name|u_int32_t
name|csr
decl_stmt|;
name|unsigned
name|char
name|tmpbuf
index|[
literal|8
index|]
decl_stmt|;
specifier|static
specifier|const
name|u_char
name|testpat
index|[]
init|=
block|{
literal|0xFF
block|,
literal|0
block|,
literal|0x55
block|,
literal|0xAA
block|,
literal|0xFF
block|,
literal|0
block|,
literal|0x55
block|,
literal|0xAA
block|}
decl_stmt|;
name|sc
operator|->
name|tulip_connidx
operator|=
name|TULIP_SROM_LASTCONNIDX
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21040
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_enetrom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|csr
operator|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_enetrom
argument_list|)
operator|)
operator|&
literal|0x80000000L
operator|)
operator|&&
name|cnt
operator|<
literal|10000
condition|)
name|cnt
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|=
name|csr
operator|&
literal|0xFF
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_boardsw
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
block|{
comment|/* 	     * Thankfully all 21041's act the same. 	     */
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21041_boardsw
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Assume all 21140 board are compatible with the 	     * DEC 10/100 evaluation board.  Not really valid but 	     * it's the best we can do until every one switches to 	     * the new SROM format. 	     */
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_eb_boardsw
expr_stmt|;
block|}
name|tulip_srom_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tulip_srom_crcok
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|)
condition|)
block|{
comment|/* 	     * SROM CRC is valid therefore it must be in the 	     * new format. 	     */
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_ISVSROM
operator||
name|TULIP_HAVE_OKSROM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|126
index|]
operator|==
literal|0xff
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|127
index|]
operator|==
literal|0xFF
condition|)
block|{
comment|/* 	     * No checksum is present.  See if the SROM id checks out; 	     * the first 18 bytes should be 0 followed by a 1 followed 	     * by the number of adapters (which we don't deal with yet). 	     */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|18
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|==
literal|18
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|18
index|]
operator|==
literal|1
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|19
index|]
operator|!=
literal|0
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_ISVSROM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|>=
name|TULIP_21142
condition|)
block|{
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_ISVSROM
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_2114x_isv_boardsw
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_ISVSROM
operator|)
operator|&&
name|tulip_srom_decode
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|!=
name|TULIP_21041
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_2114x_isv_boardsw
expr_stmt|;
comment|/* 	     * If the SROM specifies more than one adapter, tag this as a 	     * BASE rom. 	     */
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|19
index|]
operator|>
literal|1
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_BASEROM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|==
name|NULL
condition|)
return|return
operator|-
literal|6
return|;
goto|goto
name|check_oui
goto|;
block|}
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|16
index|]
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * Some folks don't use the standard ethernet rom format 	 * but instead just put the address in the first 6 bytes 	 * of the rom and let the rest be all 0xffs.  (Can we say 	 * ZNYX?) (well sometimes they put in a checksum so we'll 	 * start at 8). 	 */
for|for
control|(
name|idx
operator|=
literal|8
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|!=
literal|0xFF
condition|)
return|return
operator|-
literal|4
return|;
block|}
comment|/* 	 * Make sure the address is not multicast or locally assigned 	 * that the OUI is not 00-00-00. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|2
index|]
operator|==
literal|0
condition|)
return|return
operator|-
literal|4
return|;
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|,
name|sc
operator|->
name|tulip_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_OKROM
expr_stmt|;
goto|goto
name|check_oui
goto|;
block|}
else|else
block|{
comment|/* 	 * A number of makers of multiport boards (ZNYX and Cogent) 	 * only put on one address ROM on their 21040 boards.  So 	 * if the ROM is all zeros (or all 0xFFs), look at the 	 * previous configured boards (as long as they are on the same 	 * PCI bus and the bus number is non-zero) until we find the 	 * master board with address ROM.  We then use its address ROM 	 * as the base for this board.  (we add our relative board 	 * to the last byte of its address). 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|!=
literal|0xFF
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|==
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|)
condition|)
block|{
name|int
name|root_unit
decl_stmt|;
name|tulip_softc_t
modifier|*
name|root_sc
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|root_unit
operator|=
name|sc
operator|->
name|tulip_unit
operator|-
literal|1
init|;
name|root_unit
operator|>=
literal|0
condition|;
name|root_unit
operator|--
control|)
block|{
name|root_sc
operator|=
name|tulips
index|[
name|root_unit
index|]
expr_stmt|;
if|if
condition|(
name|root_sc
operator|==
name|NULL
operator|||
operator|(
name|root_sc
operator|->
name|tulip_features
operator|&
operator|(
name|TULIP_HAVE_OKROM
operator||
name|TULIP_HAVE_SLAVEDROM
operator|)
operator|)
operator|==
name|TULIP_HAVE_OKROM
condition|)
break|break;
name|root_sc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|root_sc
operator|!=
name|NULL
operator|&&
operator|(
name|root_sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_BASEROM
operator|)
operator|&&
name|root_sc
operator|->
name|tulip_chipid
operator|==
name|sc
operator|->
name|tulip_chipid
operator|&&
name|root_sc
operator|->
name|tulip_pci_busno
operator|==
name|sc
operator|->
name|tulip_pci_busno
condition|)
block|{
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SLAVEDROM
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
name|root_sc
operator|->
name|tulip_boardsw
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardid
argument_list|,
name|root_sc
operator|->
name|tulip_boardid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_type
operator|==
name|TULIP_21140_ISV
condition|)
block|{
name|bcopy
argument_list|(
name|root_sc
operator|->
name|tulip_rombuf
argument_list|,
name|sc
operator|->
name|tulip_rombuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tulip_srom_decode
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|-
literal|5
return|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|root_sc
operator|->
name|tulip_enaddr
argument_list|,
name|sc
operator|->
name|tulip_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_enaddr
index|[
literal|5
index|]
operator|+=
name|sc
operator|->
name|tulip_unit
operator|-
name|root_sc
operator|->
name|tulip_unit
expr_stmt|;
block|}
comment|/* 		 * Now for a truly disgusting kludge: all 4 21040s on 		 * the ZX314 share the same INTA line so the mapping 		 * setup by the BIOS on the PCI bridge is worthless. 		 * Rather than reprogramming the value in the config 		 * register, we will handle this internally. 		 */
if|if
condition|(
name|root_sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_SHAREDINTR
condition|)
block|{
name|sc
operator|->
name|tulip_slaves
operator|=
name|root_sc
operator|->
name|tulip_slaves
expr_stmt|;
name|root_sc
operator|->
name|tulip_slaves
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SLAVEDINTR
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/*      * This is the standard DEC address ROM test.      */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|24
index|]
argument_list|,
name|testpat
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|3
return|;
name|tmpbuf
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|15
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|14
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|13
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|3
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|12
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|4
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|11
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|5
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|10
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|6
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|9
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|7
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
argument_list|,
name|tmpbuf
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|2
return|;
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|,
name|sc
operator|->
name|tulip_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cksum
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_enaddr
index|[
literal|0
index|]
expr_stmt|;
name|cksum
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|+=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_enaddr
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|+=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_enaddr
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|>=
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|rom_cksum
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|!=
name|rom_cksum
condition|)
return|return
operator|-
literal|1
return|;
name|check_oui
label|:
comment|/*      * Check for various boards based on OUI.  Did I say braindead?      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|tulip_vendors
index|[
name|idx
index|]
operator|.
name|vendor_identify_nic
operator|!=
name|NULL
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|tulip_enaddr
argument_list|,
name|tulip_vendors
index|[
name|idx
index|]
operator|.
name|vendor_oui
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|tulip_vendors
index|[
name|idx
index|]
operator|.
name|vendor_identify_nic
operator|)
operator|(
name|sc
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_OKROM
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_ifmedia_add
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_media_t
name|media
decl_stmt|;
name|int
name|medias
init|=
literal|0
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|media
operator|=
name|TULIP_MEDIA_UNKNOWN
init|;
name|media
operator|<
name|TULIP_MEDIA_MAX
condition|;
name|media
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|!=
name|NULL
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifmedia
argument_list|,
name|tulip_media_to_ifmedia
index|[
name|media
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|medias
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|medias
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_NOMEDIA
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifmedia
argument_list|,
name|tulip_media_to_ifmedia
index|[
name|sc
operator|->
name|tulip_media
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_media
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_ifmedia_change
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NEEDRESET
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|tulip_ifmedia
operator|.
name|ifm_media
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
block|{
name|tulip_media_t
name|media
decl_stmt|;
for|for
control|(
name|media
operator|=
name|TULIP_MEDIA_UNKNOWN
init|;
name|media
operator|<
name|TULIP_MEDIA_MAX
condition|;
name|media
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_mediums
index|[
name|media
index|]
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|tulip_ifmedia
operator|.
name|ifm_media
operator|==
name|tulip_media_to_ifmedia
index|[
name|media
index|]
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DIDNWAY
expr_stmt|;
name|tulip_linkup
argument_list|(
name|sc
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_TXPROBE_ACTIVE
operator||
name|TULIP_WANTRXACT
operator|)
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Media status callback  */
end_comment

begin_function
specifier|static
name|void
name|tulip_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|req
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_LINKUP
condition|)
name|req
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|req
operator|->
name|ifm_active
operator|=
name|tulip_media_to_ifmedia
index|[
name|sc
operator|->
name|tulip_media
index|]
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_addr_filter
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_char
modifier|*
name|addrp
decl_stmt|;
name|u_int16_t
name|eaddr
index|[
name|ETHER_ADDR_LEN
operator|/
literal|2
index|]
decl_stmt|;
name|int
name|multicnt
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_WANTHASHPERFECT
operator||
name|TULIP_WANTHASHONLY
operator||
name|TULIP_ALLMULTI
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTSETUP
operator||
name|TULIP_WANTTXSTART
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_RXSTOPPED
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IFF_ALLMULTI
argument_list|)
if|if
condition|(
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_ALLMULTI
expr_stmt|;
endif|#
directive|endif
name|multicnt
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|tulip_ifp
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Copy MAC address on stack to align. */
if|if
condition|(
name|ifp
operator|->
name|if_input
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_enaddr
argument_list|,
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|==
name|AF_LINK
condition|)
name|multicnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|multicnt
operator|>
literal|14
condition|)
block|{
name|u_int32_t
modifier|*
name|sp
init|=
name|sc
operator|->
name|tulip_setupdata
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
comment|/* 	 * Some early passes of the 21140 have broken implementations of 	 * hash-perfect mode.  When we get too many multicasts for perfect 	 * filtering with these chips, we need to switch into hash-only 	 * mode (this is better than all-multicast on network with lots 	 * of multicast traffic). 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_BROKEN_HASH
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTHASHONLY
expr_stmt|;
else|else
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTHASHPERFECT
expr_stmt|;
comment|/* 	 * If we have more than 14 multicasts, we have 	 * go into hash perfect mode (512 bit multicast 	 * hash and one perfect hardware). 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|hash
operator|=
name|tulip_mchash
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sp
index|[
name|hash
operator|>>
literal|4
index|]
operator||=
name|htole32
argument_list|(
literal|1
operator|<<
operator|(
name|hash
operator|&
literal|0xF
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No reason to use a hash if we are going to be 	 * receiving every multicast. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALLMULTI
operator|)
operator|==
literal|0
condition|)
block|{
name|hash
operator|=
name|tulip_mchash
argument_list|(
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|sp
index|[
name|hash
operator|>>
literal|4
index|]
operator||=
name|htole32
argument_list|(
literal|1
operator|<<
operator|(
name|hash
operator|&
literal|0xF
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTHASHONLY
condition|)
block|{
name|hash
operator|=
name|tulip_mchash
argument_list|(
operator|(
name|caddr_t
operator|)
name|eaddr
argument_list|)
expr_stmt|;
name|sp
index|[
name|hash
operator|>>
literal|4
index|]
operator||=
name|htole32
argument_list|(
literal|1
operator|<<
operator|(
name|hash
operator|&
literal|0xF
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
index|[
literal|39
index|]
operator|=
name|TULIP_SP_MAC
argument_list|(
name|eaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sp
index|[
literal|40
index|]
operator|=
name|TULIP_SP_MAC
argument_list|(
name|eaddr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sp
index|[
literal|41
index|]
operator|=
name|TULIP_SP_MAC
argument_list|(
name|eaddr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_WANTHASHPERFECT
operator||
name|TULIP_WANTHASHONLY
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int32_t
modifier|*
name|sp
init|=
name|sc
operator|->
name|tulip_setupdata
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALLMULTI
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Else can get perfect filtering for 16 addresses. 	     */
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|addrp
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|addrp
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|addrp
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|addrp
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
comment|/* 	     * Add the broadcast address. 	     */
name|idx
operator|++
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
literal|0xFFFF
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
literal|0xFFFF
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pad the rest with our hardware address 	 */
for|for
control|(
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
block|{
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
name|eaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
name|eaddr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|TULIP_SP_MAC
argument_list|(
name|eaddr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_reset
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_ringinfo_t
modifier|*
name|ri
decl_stmt|;
name|tulip_descinfo_t
modifier|*
name|di
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int32_t
name|inreset
init|=
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_INRESET
operator|)
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_reset: inreset %d"
argument_list|,
name|inreset
argument_list|)
expr_stmt|;
comment|/*      * Brilliant.  Simply brilliant.  When switching modes/speeds      * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS      * bits in CSR6 and then do a software reset to get the 21140      * to properly reset its internal pathways to the right places.      *   Grrrr.      */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DEVICEPROBE
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_preset
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_preset
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
if|if
condition|(
operator|!
name|inreset
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_INRESET
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_NEEDRESET
operator||
name|TULIP_RXBUFSLOW
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txlist
argument_list|,
name|sc
operator|->
name|tulip_txinfo
operator|.
name|ri_dma_addr
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_rxlist
argument_list|,
name|sc
operator|->
name|tulip_rxinfo
operator|.
name|ri_dma_addr
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
operator|(
literal|1
operator|<<
operator|(
literal|3
comment|/*pci_max_burst_len*/
operator|+
literal|8
operator|)
operator|)
operator||
name|TULIP_BUSMODE_CACHE_ALIGN8
operator||
name|TULIP_BUSMODE_READMULTIPLE
operator||
operator|(
name|BYTE_ORDER
operator|!=
name|LITTLE_ENDIAN
condition|?
name|TULIP_BUSMODE_DESC_BIGENDIAN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_txtimer
operator|=
literal|0
expr_stmt|;
comment|/*      * Free all the mbufs that were on the transmit ring.      */
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_reset: drain transmit ring"
argument_list|)
expr_stmt|;
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_txinfo
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
block|{
name|m
operator|=
name|tulip_dequeue_mbuf
argument_list|(
name|ri
argument_list|,
name|di
argument_list|,
name|SYNC_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|di
operator|->
name|di_desc
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
block|}
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|ri
operator|->
name|ri_max
expr_stmt|;
name|TULIP_TXDESC_PRESYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
comment|/*      * We need to collect all the mbufs that were on the       * receive ring before we reinit it either to put      * them back on or to know if we have to allocate      * more.      */
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_reset: drain receive ring"
argument_list|)
expr_stmt|;
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_rxinfo
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|ri
operator|->
name|ri_max
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
block|{
name|di
operator|->
name|di_desc
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|di_desc
operator|->
name|d_length1
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|di_desc
operator|->
name|d_addr1
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|di_desc
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|di_desc
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
block|}
name|TULIP_RXDESC_PRESYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
block|{
name|m
operator|=
name|tulip_dequeue_mbuf
argument_list|(
name|ri
argument_list|,
name|di
argument_list|,
name|SYNC_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/*      * If tulip_reset is being called recursively, exit quickly knowing      * that when the outer tulip_reset returns all the right stuff will      * have happened.      */
if|if
condition|(
name|inreset
condition|)
return|return;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_TXINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_SYSERROR
operator||
name|TULIP_STS_TXSTOPPED
operator||
name|TULIP_STS_TXUNDERFLOW
operator||
name|TULIP_STS_TXBABBLE
operator||
name|TULIP_STS_RXSTOPPED
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DEVICEPROBE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_select
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NEEDRESET
operator|)
operator|==
name|TULIP_NEEDRESET
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"tulip_reset: additional reset needed?!?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|tulip_media_print
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_DUALSENSE
condition|)
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_DOINGSETUP
operator||
name|TULIP_WANTSETUP
operator||
name|TULIP_INRESET
operator||
name|TULIP_RXACT
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_init_locked
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_init_locked"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* initialize the media */
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_init_locked: up but not running, reset chip"
argument_list|)
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|tulip_addr_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PROMISC
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_PROMISCUOUS
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_TXINTR
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_PROMISC
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_PROMISCUOUS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALLMULTI
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_ALLMULTI
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_ALLMULTI
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXRUN
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_TXPROBE_ACTIVE
operator||
name|TULIP_WANTSETUP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_RXSTOPPED
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_RXSTOPPED
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_init_locked: intr mask %08x  cmdmode %08x"
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_init_locked: status %08x\n"
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_WANTSETUP
operator||
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|)
operator|==
name|TULIP_WANTSETUP
condition|)
name|tulip_txput_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_init_locked: not up, reset chip"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_addr_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|DESC_STATUS
parameter_list|(
name|di
parameter_list|)
value|(((volatile tulip_desc_t *)((di)->di_desc))->d_status)
end_define

begin_define
define|#
directive|define
name|DESC_FLAG
parameter_list|(
name|di
parameter_list|)
value|((di)->di_desc->d_flag)
end_define

begin_function
specifier|static
name|void
name|tulip_rx_intr
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_PERFSTART
argument_list|(
argument|rxintr
argument_list|)
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_rxinfo
decl_stmt|;
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
init|=
name|sc
operator|->
name|tulip_ifp
decl_stmt|;
name|int
name|fillok
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|int
name|cnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_rx_intr: start"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|TULIP_PERFSTART
argument_list|(
argument|rxget
argument_list|)
name|tulip_descinfo_t
modifier|*
name|eop
init|=
name|ri
operator|->
name|ri_nextin
decl_stmt|,
modifier|*
name|dip
decl_stmt|;
name|int
name|total_len
init|=
literal|0
decl_stmt|,
name|last_offset
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ms
init|=
name|NULL
decl_stmt|,
modifier|*
name|me
init|=
name|NULL
decl_stmt|;
name|int
name|accept
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|fillok
operator|&&
operator|(
name|ri
operator|->
name|ri_max
operator|-
name|ri
operator|->
name|ri_free
operator|)
operator|<
name|TULIP_RXQ_TARGET
condition|)
goto|goto
name|queue_mbuf
goto|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
name|cnt
operator|==
name|ri
operator|->
name|ri_max
condition|)
break|break;
endif|#
directive|endif
comment|/* 	 * If the TULIP has no descriptors, there can't be any receive 	 * descriptors to process.  	 */
if|if
condition|(
name|eop
operator|==
name|ri
operator|->
name|ri_nextout
condition|)
break|break;
comment|/* 	 * 90% of the packets will fit in one descriptor.  So we optimize 	 * for that case. 	 */
name|TULIP_RXDESC_POSTSYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
operator|(
name|TULIP_DSTS_OWNER
operator||
name|TULIP_DSTS_RxFIRSTDESC
operator||
name|TULIP_DSTS_RxLASTDESC
operator|)
operator|)
operator|==
operator|(
name|TULIP_DSTS_RxFIRSTDESC
operator||
name|TULIP_DSTS_RxLASTDESC
operator|)
condition|)
block|{
name|ms
operator|=
name|tulip_dequeue_mbuf
argument_list|(
name|ri
argument_list|,
name|eop
argument_list|,
name|SYNC_RX
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_rx_intr: single packet mbuf %p from descriptor %td"
argument_list|,
name|ms
argument_list|,
name|eop
operator|-
name|ri
operator|->
name|ri_first
argument_list|)
expr_stmt|;
name|me
operator|=
name|ms
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * If still owned by the TULIP, don't touch it. 	     */
if|if
condition|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
comment|/* 	     * It is possible (though improbable unless MCLBYTES< 1518) for 	     * a received packet to cross more than one receive descriptor. 	     * We first loop through the descriptor ring making sure we have 	     * received a complete packet.  If not, we bail until the next 	     * interrupt. 	     */
name|dip
operator|=
name|eop
expr_stmt|;
while|while
condition|(
operator|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
name|TULIP_DSTS_RxLASTDESC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|TULIP_RXDESC_POSTSYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|eop
operator|==
name|ri
operator|->
name|ri_nextout
operator|||
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
name|TULIP_DSTS_OWNER
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxintrs
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxpktsperintr
index|[
name|cnt
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|TULIP_PERFEND
argument_list|(
name|rxget
argument_list|)
expr_stmt|;
name|TULIP_PERFEND
argument_list|(
name|rxintr
argument_list|)
expr_stmt|;
return|return;
block|}
name|total_len
operator|++
expr_stmt|;
block|}
comment|/* 	     * Dequeue the first buffer for the start of the packet.  Hopefully 	     * this will be the only one we need to dequeue.  However, if the 	     * packet consumed multiple descriptors, then we need to dequeue 	     * those buffers and chain to the starting mbuf.  All buffers but 	     * the last buffer have the same length so we can set that now. 	     * (we add to last_offset instead of multiplying since we normally 	     * won't go into the loop and thereby saving ourselves from 	     * doing a multiplication by 0 in the normal case). 	     */
name|ms
operator|=
name|tulip_dequeue_mbuf
argument_list|(
name|ri
argument_list|,
name|dip
argument_list|,
name|SYNC_RX
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_rx_intr: start packet mbuf %p from descriptor %td"
argument_list|,
name|ms
argument_list|,
name|dip
operator|-
name|ri
operator|->
name|ri_first
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|++
expr_stmt|;
for|for
control|(
name|me
operator|=
name|ms
init|;
name|total_len
operator|>
literal|0
condition|;
name|total_len
operator|--
control|)
block|{
name|me
operator|->
name|m_len
operator|=
name|TULIP_RX_BUFLEN
expr_stmt|;
name|last_offset
operator|+=
name|TULIP_RX_BUFLEN
expr_stmt|;
if|if
condition|(
operator|++
name|dip
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|dip
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|me
operator|->
name|m_next
operator|=
name|tulip_dequeue_mbuf
argument_list|(
name|ri
argument_list|,
name|dip
argument_list|,
name|SYNC_RX
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|++
expr_stmt|;
name|me
operator|=
name|me
operator|->
name|m_next
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_rx_intr: cont packet mbuf %p from descriptor %td"
argument_list|,
name|me
argument_list|,
name|dip
operator|-
name|ri
operator|->
name|ri_first
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|dip
operator|==
name|eop
argument_list|,
operator|(
literal|"mismatched descinfo structs"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Now get the size of received packet (minus the CRC). 	 */
name|total_len
operator|=
operator|(
operator|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0x7FFF
operator|)
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_RXIGNORE
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
name|TULIP_DSTS_ERRSUM
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|me
operator|->
name|m_len
operator|=
name|total_len
operator|-
name|last_offset
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_RXACT
expr_stmt|;
name|accept
operator|=
literal|1
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_rx_intr: good packet; length %d"
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_rx_intr: bad packet; status %08x"
argument_list|,
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
operator|(
name|TULIP_DSTS_RxBADLENGTH
operator||
name|TULIP_DSTS_RxOVERFLOW
operator||
name|TULIP_DSTS_RxWATCHDOG
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_VERBOSE
argument_list|)
specifier|const
name|char
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
name|TULIP_DSTS_RxTOOLONG
condition|)
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsFrameTooLongs
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_VERBOSE
argument_list|)
name|error
operator|=
literal|"frame too long"
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
name|TULIP_DSTS_RxBADCRC
condition|)
block|{
if|if
condition|(
name|DESC_STATUS
argument_list|(
name|eop
argument_list|)
operator|&
name|TULIP_DSTS_RxDRBBLBIT
condition|)
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_VERBOSE
argument_list|)
name|error
operator|=
literal|"alignment error"
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_VERBOSE
argument_list|)
name|error
operator|=
literal|"bad crc"
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_VERBOSE
argument_list|)
if|if
condition|(
name|error
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NOMESSAGES
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"receive: %6D: %s\n"
argument_list|,
name|mtod
argument_list|(
name|ms
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
literal|6
argument_list|,
literal|":"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NOMESSAGES
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|eop
expr_stmt|;
name|queue_mbuf
label|:
comment|/* 	 * We have received a good packet that needs to be passed up the 	 * stack. 	 */
if|if
condition|(
name|accept
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|KASSERT
argument_list|(
name|ms
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no packet to accept"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_COPY_RXDATA
argument_list|)
comment|/* 	     * Copy the data into a new mbuf that is properly aligned.  If 	     * we fail to allocate a new mbuf, then drop the packet.  We will 	     * reuse the same rx buffer ('ms') below for another packet 	     * regardless. 	     */
name|m0
operator|=
name|m_devget
argument_list|(
name|mtod
argument_list|(
name|ms
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|total_len
argument_list|,
name|ETHER_ALIGN
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|skip_input
goto|;
block|}
else|#
directive|else
comment|/* 	     * Update the header for the mbuf referencing this receive 	     * buffer and pass it up the stack.  Allocate a new mbuf cluster 	     * to replace the one we just passed up the stack. 	     * 	     * Note that if this packet crossed multiple descriptors 	     * we don't even try to reallocate all the mbufs here. 	     * Instead we rely on the test at the beginning of 	     * the loop to refill for the extra consumed mbufs. 	     */
name|ms
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|total_len
expr_stmt|;
name|ms
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|=
name|ms
expr_stmt|;
name|ms
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_rx_intr: passing %p to upper layer"
argument_list|,
name|m0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
comment|/* 	     * If we are priming the TULIP with mbufs, then allocate 	     * a new cluster for the next descriptor. 	     */
name|ms
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_COPY_RXDATA
argument_list|)
name|skip_input
label|:
endif|#
directive|endif
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * Couldn't allocate a new buffer.  Don't bother  	     * trying to replenish the receive queue. 	     */
name|fillok
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_RXBUFSLOW
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxlowbufs
operator|++
expr_stmt|;
endif|#
directive|endif
name|TULIP_PERFEND
argument_list|(
name|rxget
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Now give the buffer(s) to the TULIP and save in our 	 * receive queue. 	 */
do|do
block|{
name|tulip_descinfo_t
modifier|*
specifier|const
name|nextout
init|=
name|ri
operator|->
name|ri_nextout
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ms
operator|->
name|m_data
operator|==
name|ms
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
operator|(
literal|"rx mbuf data doesn't point to cluster"
operator|)
argument_list|)
expr_stmt|;
name|ms
operator|->
name|m_len
operator|=
name|ms
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|ri
operator|->
name|ri_data_tag
argument_list|,
operator|*
name|nextout
operator|->
name|di_map
argument_list|,
name|ms
argument_list|,
name|tulip_dma_map_rxbuf
argument_list|,
name|nextout
operator|->
name|di_desc
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"unable to load rx map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"tulip_rx_intr"
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|nextout
operator|->
name|di_desc
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|KASSERT
argument_list|(
name|nextout
operator|->
name|di_mbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"clobbering earlier rx mbuf"
operator|)
argument_list|)
expr_stmt|;
name|nextout
operator|->
name|di_mbuf
operator|=
name|ms
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_rx_intr: enqueued mbuf %p to descriptor %td"
argument_list|,
name|ms
argument_list|,
name|nextout
operator|-
name|ri
operator|->
name|ri_first
argument_list|)
expr_stmt|;
name|TULIP_RXDESC_POSTSYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|--
expr_stmt|;
name|me
operator|=
name|ms
operator|->
name|m_next
expr_stmt|;
name|ms
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ms
operator|=
name|me
operator|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
operator|(
name|ri
operator|->
name|ri_max
operator|-
name|ri
operator|->
name|ri_free
operator|)
operator|>=
name|TULIP_RXQ_TARGET
condition|)
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_RXBUFSLOW
expr_stmt|;
name|TULIP_PERFEND
argument_list|(
name|rxget
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxintrs
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxpktsperintr
index|[
name|cnt
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|TULIP_PERFEND
argument_list|(
name|rxintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_tx_intr
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_PERFSTART
argument_list|(
argument|txintr
argument_list|)
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_txinfo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|xmits
init|=
literal|0
decl_stmt|;
name|int
name|descs
init|=
literal|0
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_tx_intr: start"
argument_list|)
expr_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|ri
operator|->
name|ri_free
operator|<
name|ri
operator|->
name|ri_max
condition|)
block|{
name|u_int32_t
name|d_flag
decl_stmt|;
name|TULIP_TXDESC_POSTSYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|DESC_STATUS
argument_list|(
name|ri
operator|->
name|ri_nextin
argument_list|)
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
name|ri
operator|->
name|ri_free
operator|++
expr_stmt|;
name|descs
operator|++
expr_stmt|;
name|d_flag
operator|=
name|DESC_FLAG
argument_list|(
name|ri
operator|->
name|ri_nextin
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_flag
operator|&
name|TULIP_DFLAG_TxLASTSEG
condition|)
block|{
if|if
condition|(
name|d_flag
operator|&
name|TULIP_DFLAG_TxSETUPPKT
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_tx_intr: setup packet from descriptor %td: %08x"
argument_list|,
name|ri
operator|->
name|ri_nextin
operator|-
name|ri
operator|->
name|ri_first
argument_list|,
name|DESC_STATUS
argument_list|(
name|ri
operator|->
name|ri_nextin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * We've just finished processing a setup packet. 		 * Mark that we finished it.  If there's not 		 * another pending, startup the TULIP receiver. 		 * Make sure we ack the RXSTOPPED so we won't get 		 * an abormal interrupt indication. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tulip_setup_tag
argument_list|,
name|sc
operator|->
name|tulip_setup_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_DOINGSETUP
operator||
name|TULIP_HASHONLY
operator|)
expr_stmt|;
if|if
condition|(
name|DESC_FLAG
argument_list|(
name|ri
operator|->
name|ri_nextin
argument_list|)
operator|&
name|TULIP_DFLAG_TxINVRSFILT
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_HASHONLY
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_WANTSETUP
operator||
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_RXSTOPPED
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_tx_intr: intr mask %08x  cmdmode %08x"
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|TULIP_STS_RXSTOPPED
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|u_int32_t
name|d_status
init|=
name|DESC_STATUS
argument_list|(
name|ri
operator|->
name|ri_nextin
argument_list|)
decl_stmt|;
name|m
operator|=
name|tulip_dequeue_mbuf
argument_list|(
name|ri
argument_list|,
name|ri
operator|->
name|ri_nextin
argument_list|,
name|SYNC_TX
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_tx_intr: data packet %p from descriptor %td"
argument_list|,
name|m
argument_list|,
name|ri
operator|->
name|ri_nextin
operator|-
name|ri
operator|->
name|ri_first
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"tx_intr: failed to dequeue mbuf?!?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
condition|)
block|{
name|tulip_mediapoll_event_t
name|event
init|=
name|TULIP_MEDIAPOLL_TXPROBE_OK
decl_stmt|;
if|if
condition|(
name|d_status
operator|&
operator|(
name|TULIP_DSTS_TxNOCARR
operator||
name|TULIP_DSTS_TxEXCCOLL
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxNOCARR
condition|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txprobe_nocarr
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxEXCCOLL
condition|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txprobe_exccoll
operator|++
expr_stmt|;
endif|#
directive|endif
name|event
operator|=
name|TULIP_MEDIAPOLL_TXPROBE_FAILED
expr_stmt|;
block|}
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_poll
call|)
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
comment|/* 		     * Escape from the loop before media poll has reset the TULIP! 		     */
break|break;
block|}
else|else
block|{
name|xmits
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_ERRSUM
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_tx_intr: output error: %08x"
argument_list|,
name|d_status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxEXCCOLL
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsExcessiveCollisions
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxLATECOLL
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsLateCollisions
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
operator|(
name|TULIP_DSTS_TxNOCARR
operator||
name|TULIP_DSTS_TxCARRLOSS
operator|)
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsCarrierSenseErrors
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
operator|(
name|TULIP_DSTS_TxUNDERFLOW
operator||
name|TULIP_DSTS_TxBABBLE
operator|)
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxUNDERFLOW
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsInternalTransmitUnderflows
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxBABBLE
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsInternalTransmitBabbles
operator|++
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|collisions
init|=
operator|(
name|d_status
operator|&
name|TULIP_DSTS_TxCOLLMASK
operator|)
operator|>>
name|TULIP_DSTS_V_TxCOLLCNT
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_tx_intr: output ok, collisions %d, status %08x"
argument_list|,
name|collisions
argument_list|,
name|d_status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_collisions
operator|+=
name|collisions
expr_stmt|;
if|if
condition|(
name|collisions
operator|==
literal|1
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|collisions
operator|>
literal|1
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxDEFERRED
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsDeferredTransmissions
operator|++
expr_stmt|;
comment|/* 			 * SQE is only valid for 10baseT/BNC/AUI when not 			 * running in full-duplex.  In order to speed up the 			 * test, the corresponding bit in tulip_flags needs to 			 * set as well to get us to count SQE Test Errors. 			 */
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxNOHRTBT
operator|&
name|sc
operator|->
name|tulip_flags
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsSQETestErrors
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextin
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
comment|/*      * If nothing left to transmit, disable the timer.      * Else if progress, reset the timer back to 2 ticks.      */
if|if
condition|(
name|ri
operator|->
name|ri_free
operator|==
name|ri
operator|->
name|ri_max
operator|||
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
condition|)
name|sc
operator|->
name|tulip_txtimer
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|xmits
operator|>
literal|0
condition|)
name|sc
operator|->
name|tulip_txtimer
operator|=
name|TULIP_TXTIMER
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_opackets
operator|+=
name|xmits
expr_stmt|;
name|TULIP_PERFEND
argument_list|(
name|txintr
argument_list|)
expr_stmt|;
return|return
name|descs
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_print_abnormal_interrupt
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|u_int32_t
name|csr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|msgp
init|=
name|tulip_status_bits
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|u_int32_t
name|mask
decl_stmt|;
specifier|const
name|char
name|thrsh
index|[]
init|=
literal|"72|128\0\0\0"
literal|"96|256\0\0\0"
literal|"128|512\0\0"
literal|"160|1024"
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|(
literal|1
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|tulip_status_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tulip_status_bits
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"abnormal interrupt:"
argument_list|)
expr_stmt|;
for|for
control|(
name|sep
operator|=
literal|" "
operator|,
name|mask
operator|=
literal|1
init|;
name|mask
operator|<=
name|csr
condition|;
name|mask
operator|<<=
literal|1
operator|,
name|msgp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|csr
operator|&
name|mask
operator|)
operator|&&
operator|*
name|msgp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
operator|*
name|msgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
name|TULIP_STS_TXUNDERFLOW
operator|&&
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NEWTXTHRESH
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_NEWTXTHRESH
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_STOREFWD
condition|)
block|{
name|printf
argument_list|(
literal|" (switching to store-and-forward mode)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" (raising TX threshold to %s)"
argument_list|,
operator|&
name|thrsh
index|[
literal|9
operator|*
operator|(
operator|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_THRESHOLDCTL
operator|)
operator|>>
literal|14
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_intr_handler
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_PERFSTART
argument_list|(
argument|intr
argument_list|)
name|u_int32_t
name|csr
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_intr_handler invoked"
argument_list|)
expr_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|csr
operator|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
operator|)
operator|&
name|sc
operator|->
name|tulip_intrmask
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_SYSERROR
condition|)
block|{
name|sc
operator|->
name|tulip_last_system_error
operator|=
operator|(
name|csr
operator|&
name|TULIP_STS_ERRORMASK
operator|)
operator|>>
name|TULIP_STS_ERR_SHIFT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NOMESSAGES
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SYSTEMERROR
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"system error: %s\n"
argument_list|,
name|tulip_system_errors
index|[
name|sc
operator|->
name|tulip_last_system_error
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NEEDRESET
expr_stmt|;
name|sc
operator|->
name|tulip_system_errors
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csr
operator|&
operator|(
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
operator|)
operator|&
name|sc
operator|->
name|tulip_intrmask
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_link_intrs
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_poll
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_poll
call|)
argument_list|(
name|sc
argument_list|,
name|csr
operator|&
name|TULIP_STS_LINKFAIL
condition|?
name|TULIP_MEDIAPOLL_LINKFAIL
else|:
name|TULIP_MEDIAPOLL_LINKPASS
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|TULIP_STS_ABNRMLINTR
expr_stmt|;
block|}
name|tulip_media_print
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr
operator|&
operator|(
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_RXNOBUF
operator|)
condition|)
block|{
name|u_int32_t
name|misses
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_missed_frames
argument_list|)
decl_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_RXNOBUF
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsMissedFrames
operator|+=
name|misses
operator|&
literal|0xFFFF
expr_stmt|;
comment|/* 	     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data 	     * on receive overflows. 	     */
if|if
condition|(
operator|(
name|misses
operator|&
literal|0x0FFE0000
operator|)
operator|&&
operator|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_RXBADOVRFLW
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
comment|/* 		 * Stop the receiver process and spin until it's stopped. 		 * Tell rx_intr to drop the packets it dequeues. 		 */
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
operator|&
operator|~
name|TULIP_CMD_RXRUN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
operator|&
name|TULIP_STS_RXSTOPPED
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|TULIP_STS_RXSTOPPED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_RXIGNORE
expr_stmt|;
block|}
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_RXIGNORE
condition|)
block|{
comment|/* 		 * Restart the receiver. 		 */
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_RXIGNORE
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_ABNRMLINTR
condition|)
block|{
name|u_int32_t
name|tmp
init|=
name|csr
operator|&
name|sc
operator|->
name|tulip_intrmask
operator|&
operator|~
operator|(
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator|)
decl_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_TXUNDERFLOW
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_THRESHOLDCTL
operator|)
operator|!=
name|TULIP_CMD_THRSHLD160
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|+=
name|TULIP_CMD_THRSHLD96
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NEWTXTHRESH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_STOREFWD
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_STOREFWD
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NEWTXTHRESH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NOMESSAGES
condition|)
block|{
name|sc
operator|->
name|tulip_statusbits
operator||=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|tulip_print_abnormal_interrupt
argument_list|(
name|sc
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NOMESSAGES
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_WANTTXSTART
operator||
name|TULIP_TXPROBE_ACTIVE
operator||
name|TULIP_DOINGSETUP
operator||
name|TULIP_PROMISC
operator|)
condition|)
block|{
name|tulip_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|tulip_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NEEDRESET
condition|)
block|{
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|TULIP_PERFEND
argument_list|(
name|intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_intr_shared
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
for|for
control|(
init|;
name|sc
operator|!=
name|NULL
condition|;
name|sc
operator|=
name|sc
operator|->
name|tulip_slaves
control|)
block|{
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_intrs
operator|++
expr_stmt|;
endif|#
directive|endif
name|tulip_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_intr_normal
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_intrs
operator|++
expr_stmt|;
endif|#
directive|endif
name|tulip_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|tulip_txput
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|TULIP_PERFSTART
argument_list|(
argument|txput
argument_list|)
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_txinfo
decl_stmt|;
name|tulip_descinfo_t
modifier|*
name|eop
decl_stmt|,
modifier|*
name|nextout
decl_stmt|;
name|int
name|segcnt
decl_stmt|,
name|free
decl_stmt|;
name|u_int32_t
name|d_status
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TULIP_MAX_TXSEG
index|]
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|map
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_TXRUN
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"txput%s: tx not running\n"
argument_list|,
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
condition|?
literal|"(probe)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTTXSTART
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txput_finishes
index|[
literal|0
index|]
operator|++
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
endif|#
directive|endif
comment|/*      * Now we try to fill in our transmit descriptors.  This is      * a bit reminiscent of going on the Ark two by two      * since each descriptor for the TULIP can describe      * two buffers.  So we advance through packet filling      * each of the two entries at a time to to fill each      * descriptor.  Clear the first and last segment bits      * in each descriptor (actually just clear everything      * but the end-of-ring or chain bits) to make sure      * we don't get messed up by previously sent packets.      *      * We may fail to put the entire packet on the ring if      * there is either not enough ring entries free or if the      * packet has more than MAX_TXSEG segments.  In the former      * case we will just wait for the ring to empty.  In the      * latter case we have to recopy.      */
if|#
directive|if
name|defined
argument_list|(
name|KTR
argument_list|)
operator|&&
name|KTR_TULIP
name|segcnt
operator|=
literal|1
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|m0
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|segcnt
operator|++
expr_stmt|;
name|m0
operator|=
name|m0
operator|->
name|m_next
expr_stmt|;
block|}
endif|#
directive|endif
name|CTR2
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_txput: sending packet %p (%d chunks)"
argument_list|,
name|m
argument_list|,
name|segcnt
argument_list|)
expr_stmt|;
name|d_status
operator|=
literal|0
expr_stmt|;
name|eop
operator|=
name|nextout
operator|=
name|ri
operator|->
name|ri_nextout
expr_stmt|;
name|segcnt
operator|=
literal|0
expr_stmt|;
name|free
operator|=
name|ri
operator|->
name|ri_free
expr_stmt|;
comment|/*      * Reclaim some tx descriptors if we are out since we need at least one      * free descriptor so that we have a dma_map to load the mbuf.      */
if|if
condition|(
name|free
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_no_txmaps
operator|++
expr_stmt|;
endif|#
directive|endif
name|free
operator|+=
name|tulip_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|free
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTTXSTART
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txput_finishes
index|[
literal|1
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
goto|goto
name|finish
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ri
operator|->
name|ri_data_tag
argument_list|,
operator|*
name|eop
operator|->
name|di_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* 	     * The packet exceeds the number of transmit buffer 	     * entries that we can use for one packet, so we have 	     * to recopy it into one mbuf and then try again.  If 	     * we can't recopy it, try again later. 	     */
name|m0
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTTXSTART
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txput_finishes
index|[
literal|2
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
goto|goto
name|finish
goto|;
block|}
name|m
operator|=
name|m0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ri
operator|->
name|ri_data_tag
argument_list|,
operator|*
name|eop
operator|->
name|di_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"unable to load tx map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txput_finishes
index|[
literal|3
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
goto|goto
name|finish
goto|;
block|}
block|}
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_txput: nsegs %d"
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
comment|/*      * Each descriptor allows for up to 2 fragments since we don't use      * the descriptor chaining mode in this driver.      */
if|if
condition|(
operator|(
name|free
operator|-=
operator|(
name|nsegs
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|<=
literal|0
comment|/* 	     * See if there's any unclaimed space in the transmit ring. 	     */
operator|&&
operator|(
name|free
operator|+=
name|tulip_tx_intr
argument_list|(
name|sc
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 	 * There's no more room but since nothing 	 * has been committed at this point, just 	 * show output is active, put back the 	 * mbuf and return. 	 */
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTTXSTART
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txput_finishes
index|[
literal|4
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|bus_dmamap_unload
argument_list|(
name|ri
operator|->
name|ri_data_tag
argument_list|,
operator|*
name|eop
operator|->
name|di_map
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
for|for
control|(
init|;
name|nsegs
operator|-
name|segcnt
operator|>
literal|1
condition|;
name|segcnt
operator|+=
literal|2
control|)
block|{
name|eop
operator|=
name|nextout
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
operator||
name|TULIP_DFLAG_CHAIN
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_status
operator|=
name|d_status
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_addr1
operator|=
name|segs
index|[
name|segcnt
index|]
operator|.
name|ds_addr
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_length1
operator|=
name|segs
index|[
name|segcnt
index|]
operator|.
name|ds_len
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_addr2
operator|=
name|segs
index|[
name|segcnt
operator|+
literal|1
index|]
operator|.
name|ds_addr
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_length2
operator|=
name|segs
index|[
name|segcnt
operator|+
literal|1
index|]
operator|.
name|ds_len
expr_stmt|;
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
if|if
condition|(
operator|++
name|nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
block|}
if|if
condition|(
name|segcnt
operator|<
name|nsegs
condition|)
block|{
name|eop
operator|=
name|nextout
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
operator||
name|TULIP_DFLAG_CHAIN
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_status
operator|=
name|d_status
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_addr1
operator|=
name|segs
index|[
name|segcnt
index|]
operator|.
name|ds_addr
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_length1
operator|=
name|segs
index|[
name|segcnt
index|]
operator|.
name|ds_len
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
name|eop
operator|->
name|di_desc
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
block|}
comment|/*      * tulip_tx_intr() harvests the mbuf from the last descriptor in the      * frame.  We just used the dmamap in the first descriptor for the      * load operation however.  Thus, to let the tulip_dequeue_mbuf() call      * in tulip_tx_intr() unload the correct dmamap, we swap the dmamap      * pointers in the two descriptors if this is a multiple-descriptor      * packet.      */
if|if
condition|(
name|eop
operator|!=
name|ri
operator|->
name|ri_nextout
condition|)
block|{
name|map
operator|=
name|eop
operator|->
name|di_map
expr_stmt|;
name|eop
operator|->
name|di_map
operator|=
name|ri
operator|->
name|ri_nextout
operator|->
name|di_map
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|di_map
operator|=
name|map
expr_stmt|;
block|}
comment|/*      * bounce a copy to the bpf listener, if any.      */
name|BPF_MTAP
argument_list|(
name|sc
operator|->
name|tulip_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/*      * The descriptors have been filled in.  Now get ready      * to transmit.      */
name|CTR3
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_txput: enqueued mbuf %p to descriptors %td - %td"
argument_list|,
name|m
argument_list|,
name|ri
operator|->
name|ri_nextout
operator|-
name|ri
operator|->
name|ri_first
argument_list|,
name|eop
operator|-
name|ri
operator|->
name|ri_first
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|eop
operator|->
name|di_mbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"clobbering earlier tx mbuf"
operator|)
argument_list|)
expr_stmt|;
name|eop
operator|->
name|di_mbuf
operator|=
name|m
expr_stmt|;
name|TULIP_TXMAP_PRESYNC
argument_list|(
name|ri
argument_list|,
name|ri
operator|->
name|ri_nextout
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/*      * Make sure the next descriptor after this packet is owned      * by us since it may have been set up above if we ran out      * of room in the ring.      */
name|nextout
operator|->
name|di_desc
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
name|TULIP_TXDESC_PRESYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
comment|/*      * Mark the last and first segments, indicate we want a transmit      * complete interrupt, and tell it to transmit!      */
name|eop
operator|->
name|di_desc
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxLASTSEG
operator||
name|TULIP_DFLAG_TxWANTINTR
expr_stmt|;
comment|/*      * Note that ri->ri_nextout is still the start of the packet      * and until we set the OWNER bit, we can still back out of      * everything we have done.      */
name|ri
operator|->
name|ri_nextout
operator|->
name|di_desc
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxFIRSTSEG
expr_stmt|;
name|TULIP_TXDESC_PRESYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|di_desc
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|TULIP_TXDESC_PRESYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
comment|/*      * This advances the ring for us.      */
name|ri
operator|->
name|ri_nextout
operator|=
name|nextout
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|free
expr_stmt|;
name|TULIP_PERFEND
argument_list|(
name|txput
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|TULIP_PERFEND
argument_list|(
name|txput
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * switch back to the single queueing ifstart.      */
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_WANTTXSTART
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_txtimer
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_txtimer
operator|=
name|TULIP_TXTIMER
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txput_finishes
index|[
literal|5
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*      * If we want a txstart, there must be not enough space in the      * transmit ring.  So we want to enable transmit done interrupts      * so we can immediately reclaim some space.  When the transmit      * interrupt is posted, the interrupt handler will call tx_intr      * to reclaim space and then txstart (since WANTTXSTART is set).      * txstart will move the packet into the transmit ring and clear      * WANTTXSTART thereby causing TXINTR to be cleared.      */
name|finish
label|:
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_txput_finishes
index|[
literal|6
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_WANTTXSTART
operator||
name|TULIP_DOINGSETUP
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_intrmask
operator|&
name|TULIP_STS_TXINTR
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_TXINTR
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_PROMISC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_intrmask
operator|&
name|TULIP_STS_TXINTR
condition|)
block|{
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_TXINTR
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
block|}
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TULIP_PERFEND
argument_list|(
name|txput
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_txput_setup
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_txinfo
decl_stmt|;
name|tulip_desc_t
modifier|*
name|nextout
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * We will transmit, at most, one setup packet per call to ifstart.      */
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_TXRUN
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"txput_setup: tx not running\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTTXSTART
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/*      * Try to reclaim some free descriptors..      */
if|if
condition|(
name|ri
operator|->
name|ri_free
operator|<
literal|2
condition|)
name|tulip_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DOINGSETUP
operator|)
operator|||
name|ri
operator|->
name|ri_free
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTTXSTART
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|,
name|sc
operator|->
name|tulip_setupbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Clear WANTSETUP and set DOINGSETUP.  Since we know that WANTSETUP is      * set and DOINGSETUP is clear doing an XOR of the two will DTRT.      */
name|sc
operator|->
name|tulip_flags
operator|^=
name|TULIP_WANTSETUP
operator||
name|TULIP_DOINGSETUP
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|--
expr_stmt|;
name|nextout
operator|=
name|ri
operator|->
name|ri_nextout
operator|->
name|di_desc
expr_stmt|;
name|nextout
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
operator||
name|TULIP_DFLAG_CHAIN
expr_stmt|;
name|nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxFIRSTSEG
operator||
name|TULIP_DFLAG_TxLASTSEG
operator||
name|TULIP_DFLAG_TxSETUPPKT
operator||
name|TULIP_DFLAG_TxWANTINTR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTHASHPERFECT
condition|)
name|nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxHASHFILT
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTHASHONLY
condition|)
name|nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxHASHFILT
operator||
name|TULIP_DFLAG_TxINVRSFILT
expr_stmt|;
name|nextout
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
name|nextout
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
name|nextout
operator|->
name|d_length1
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|)
expr_stmt|;
name|nextout
operator|->
name|d_addr1
operator|=
name|sc
operator|->
name|tulip_setup_dma_addr
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tulip_setup_tag
argument_list|,
name|sc
operator|->
name|tulip_setup_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|TULIP_TXDESC_PRESYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_txput_setup: using descriptor %td"
argument_list|,
name|ri
operator|->
name|ri_nextout
operator|-
name|ri
operator|->
name|ri_first
argument_list|)
expr_stmt|;
comment|/*      * Advance the ring for the next transmit packet.      */
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
comment|/*      * Make sure the next descriptor is owned by us since it      * may have been set up above if we ran out of room in the      * ring.      */
name|ri
operator|->
name|ri_nextout
operator|->
name|di_desc
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
name|TULIP_TXDESC_PRESYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
name|nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
comment|/*      * Flush the ownwership of the current descriptor      */
name|TULIP_TXDESC_PRESYNC
argument_list|(
name|ri
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_intrmask
operator|&
name|TULIP_STS_TXINTR
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_TXINTR
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_ifioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|TULIP_PERFSTART
argument_list|(
argument|ifioctl
argument_list|)
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
block|{
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
block|{
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ifmedia
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
block|{
comment|/* 	     * Update multicast listeners 	     */
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SIOCGADDRROM
case|case
name|SIOCGADDRROM
case|:
block|{
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIOCGCHIPID
case|case
name|SIOCGCHIPID
case|:
block|{
name|ifr
operator|->
name|ifr_metric
operator|=
operator|(
name|int
operator|)
name|sc
operator|->
name|tulip_chipid
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
block|{
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|TULIP_PERFEND
argument_list|(
name|ifioctl
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_start
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|TULIP_PERFSTART
argument_list|(
argument|ifstart
argument_list|)
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_PERFEND
argument_list|(
name|ifstart
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_start_locked
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|TULIP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_start_locked invoked"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_WANTSETUP
operator||
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|)
operator|==
name|TULIP_WANTSETUP
condition|)
name|tulip_txput_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TULIP
argument_list|,
literal|"tulip_start_locked: %d tx packets pending"
argument_list|,
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_snd
operator|.
name|ifq_len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|=
name|tulip_txput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Even though this routine runs at device spl, it does not break  * our use of splnet (splsoftnet under NetBSD) for the majority  * of this driver since   * if_watcbog is called from if_watchdog which is called from  * splsoftclock which is below spl[soft]net.  */
end_comment

begin_function
specifier|static
name|void
name|tulip_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|TULIP_PERFSTART
argument_list|(
argument|ifwatchdog
argument_list|)
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|u_int32_t
name|rxintrs
decl_stmt|;
endif|#
directive|endif
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|rxintrs
operator|=
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxintrs
operator|-
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_last_rxintrs
expr_stmt|;
if|if
condition|(
name|rxintrs
operator|>
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_high_rxintrs_hz
condition|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_high_rxintrs_hz
operator|=
name|rxintrs
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_last_rxintrs
operator|=
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxintrs
expr_stmt|;
endif|#
directive|endif
comment|/* TULIP_DEBUG */
name|sc
operator|->
name|tulip_ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
comment|/*      * These should be rare so do a bulk test up front so we can just skip      * them if needed.      */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_SYSTEMERROR
operator||
name|TULIP_RXBUFSLOW
operator||
name|TULIP_NOMESSAGES
operator|)
condition|)
block|{
comment|/* 	 * If the number of receive buffer is low, try to refill 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_RXBUFSLOW
condition|)
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_SYSTEMERROR
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|tulip_ifp
argument_list|,
literal|"%d system errors: last was %s\n"
argument_list|,
name|sc
operator|->
name|tulip_system_errors
argument_list|,
name|tulip_system_errors
index|[
name|sc
operator|->
name|tulip_last_system_error
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_statusbits
condition|)
block|{
name|tulip_print_abnormal_interrupt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_statusbits
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_statusbits
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_NOMESSAGES
operator||
name|TULIP_SYSTEMERROR
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_txtimer
condition|)
name|tulip_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_txtimer
operator|&&
operator|--
name|sc
operator|->
name|tulip_txtimer
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|tulip_ifp
argument_list|,
literal|"transmission timeout\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TULIP_DO_AUTOSENSE
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_WANTRXACT
operator||
name|TULIP_LINKUP
operator|)
expr_stmt|;
block|}
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|TULIP_PERFEND
argument_list|(
name|ifwatchdog
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_intr_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_ifstart_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_ifioctl_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_ifwatchdog_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_timeout_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_ifstart_one_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_txput_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_txintr_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_rxintr_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_rxget_cycles
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_intr
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_ifstart
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_ifioctl
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_ifwatchdog
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_timeout
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_ifstart_one
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_txput
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_txintr
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_rxintr
argument_list|)
expr_stmt|;
name|TULIP_PERFMERGE
argument_list|(
name|sc
argument_list|,
name|perf_rxget
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_attach
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|tulip_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
comment|/* XXX: driver name/unit should be set some other way */
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"de"
argument_list|,
name|sc
operator|->
name|tulip_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|tulip_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|tulip_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|tulip_ifwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|tulip_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|tulip_dev
argument_list|,
literal|"%s%s pass %d.%d%s\n"
argument_list|,
name|sc
operator|->
name|tulip_boardid
argument_list|,
name|tulip_chipdescs
index|[
name|sc
operator|->
name|tulip_chipid
index|]
argument_list|,
operator|(
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0x0F
argument_list|,
operator|(
name|sc
operator|->
name|tulip_features
operator|&
operator|(
name|TULIP_HAVE_ISVSROM
operator||
name|TULIP_HAVE_OKSROM
operator|)
operator|)
operator|==
name|TULIP_HAVE_ISVSROM
condition|?
literal|" (invalid EESPROM checksum)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_probe
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ifmedia
argument_list|,
literal|0
argument_list|,
name|tulip_ifmedia_change
argument_list|,
name|tulip_ifmedia_status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DEVICEPROBE
expr_stmt|;
name|tulip_ifmedia_add
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|sc
operator|->
name|tulip_ifp
argument_list|,
name|sc
operator|->
name|tulip_enaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release memory for a single descriptor ring. */
end_comment

begin_function
specifier|static
name|void
name|tulip_busdma_freering
parameter_list|(
name|tulip_ringinfo_t
modifier|*
name|ri
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Release the DMA maps and tag for data buffers. */
if|if
condition|(
name|ri
operator|->
name|ri_data_maps
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ri
operator|->
name|ri_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ri
operator|->
name|ri_data_maps
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ri
operator|->
name|ri_data_tag
argument_list|,
name|ri
operator|->
name|ri_data_maps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_data_maps
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ri
operator|->
name|ri_data_maps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_data_maps
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ri
operator|->
name|ri_data_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ri
operator|->
name|ri_data_tag
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_data_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Release the DMA memory and tag for the ring descriptors. */
if|if
condition|(
name|ri
operator|->
name|ri_dma_addr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ri
operator|->
name|ri_ring_tag
argument_list|,
name|ri
operator|->
name|ri_ring_map
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_dma_addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ri
operator|->
name|ri_descs
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ri
operator|->
name|ri_ring_tag
argument_list|,
name|ri
operator|->
name|ri_descs
argument_list|,
name|ri
operator|->
name|ri_ring_map
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_ring_map
operator|=
name|NULL
expr_stmt|;
name|ri
operator|->
name|ri_descs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ri
operator|->
name|ri_ring_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ri
operator|->
name|ri_ring_tag
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate memory for a single descriptor ring. */
end_comment

begin_function
specifier|static
name|int
name|tulip_busdma_allocring
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|size_t
name|count
parameter_list|,
name|bus_size_t
name|maxsize
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|tulip_ringinfo_t
modifier|*
name|ri
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* First, setup a tag. */
name|ri
operator|->
name|ri_max
operator|=
name|count
expr_stmt|;
name|size
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|tulip_desc_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ri
operator|->
name|ri_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate %s descriptor ring dma tag\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Next, allocate memory for the descriptors. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|ri
operator|->
name|ri_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ri
operator|->
name|ri_descs
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|ri
operator|->
name|ri_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate memory for %s descriptor ring\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Map the descriptors. */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ri
operator|->
name|ri_ring_tag
argument_list|,
name|ri
operator|->
name|ri_ring_map
argument_list|,
name|ri
operator|->
name|ri_descs
argument_list|,
name|size
argument_list|,
name|tulip_dma_map_addr
argument_list|,
operator|&
name|ri
operator|->
name|ri_dma_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to get dma address for %s descriptor ring\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Allocate a tag for the data buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|maxsize
argument_list|,
name|nsegs
argument_list|,
name|TULIP_DATA_PER_DESC
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ri
operator|->
name|ri_data_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate %s buffer dma tag\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Allocate maps for the data buffers. */
name|ri
operator|->
name|ri_data_maps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dmamap_t
argument_list|)
operator|*
name|count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ri
operator|->
name|ri_data_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|ri
operator|->
name|ri_data_maps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create map for %s buffer %d\n"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Release busdma maps, tags, and memory. */
end_comment

begin_function
specifier|static
name|void
name|tulip_busdma_cleanup
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
comment|/* Release resources for the setup descriptor. */
if|if
condition|(
name|sc
operator|->
name|tulip_setup_dma_addr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tulip_setup_tag
argument_list|,
name|sc
operator|->
name|tulip_setup_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_setup_dma_addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_setupbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|tulip_setup_tag
argument_list|,
name|sc
operator|->
name|tulip_setupdata
argument_list|,
name|sc
operator|->
name|tulip_setup_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_setup_map
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|tulip_setupbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_setup_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tulip_setup_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_setup_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Release the transmit ring. */
name|tulip_busdma_freering
argument_list|(
operator|&
name|sc
operator|->
name|tulip_txinfo
argument_list|)
expr_stmt|;
comment|/* Release the receive ring. */
name|tulip_busdma_freering
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rxinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_busdma_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/*      * Allocate space and dmamap for transmit ring.      */
name|error
operator|=
name|tulip_busdma_allocring
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|TULIP_TXDESCS
argument_list|,
name|TULIP_DATA_PER_DESC
argument_list|,
name|TULIP_MAX_TXSEG
argument_list|,
operator|&
name|sc
operator|->
name|tulip_txinfo
argument_list|,
literal|"transmit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*      * Allocate space and dmamap for receive ring.  We tell bus_dma that      * we can map MCLBYTES so that it will accept a full MCLBYTES cluster,      * but we will only map the first TULIP_RX_BUFLEN bytes.  This is not      * a waste in practice though as an ethernet frame can easily fit      * in TULIP_RX_BUFLEN bytes.      */
name|error
operator|=
name|tulip_busdma_allocring
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|TULIP_RXDESCS
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
operator|&
name|sc
operator|->
name|tulip_rxinfo
argument_list|,
literal|"receive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*      * Allocate a DMA tag, memory, and map for setup descriptor      */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tulip_setup_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate setup descriptor dma tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|tulip_setup_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_setupbuf
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|tulip_setup_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate memory for setup descriptor\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|tulip_setup_tag
argument_list|,
name|sc
operator|->
name|tulip_setup_map
argument_list|,
name|sc
operator|->
name|tulip_setupbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|)
argument_list|,
name|tulip_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|tulip_setup_dma_addr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to get dma address for setup descriptor\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_initcsrs
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_csrptr_t
name|csr_base
parameter_list|,
name|size_t
name|csr_size
parameter_list|)
block|{
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_busmode
operator|=
name|csr_base
operator|+
literal|0
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txpoll
operator|=
name|csr_base
operator|+
literal|1
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_rxpoll
operator|=
name|csr_base
operator|+
literal|2
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_rxlist
operator|=
name|csr_base
operator|+
literal|3
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txlist
operator|=
name|csr_base
operator|+
literal|4
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_status
operator|=
name|csr_base
operator|+
literal|5
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_command
operator|=
name|csr_base
operator|+
literal|6
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_intr
operator|=
name|csr_base
operator|+
literal|7
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_missed_frames
operator|=
name|csr_base
operator|+
literal|8
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_9
operator|=
name|csr_base
operator|+
literal|9
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_10
operator|=
name|csr_base
operator|+
literal|10
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_11
operator|=
name|csr_base
operator|+
literal|11
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_12
operator|=
name|csr_base
operator|+
literal|12
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_13
operator|=
name|csr_base
operator|+
literal|13
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_14
operator|=
name|csr_base
operator|+
literal|14
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_15
operator|=
name|csr_base
operator|+
literal|15
operator|*
name|csr_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_initring
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
parameter_list|,
name|int
name|ndescs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ri
operator|->
name|ri_descinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tulip_descinfo_t
argument_list|)
operator|*
name|ndescs
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndescs
condition|;
name|i
operator|++
control|)
block|{
name|ri
operator|->
name|ri_descinfo
index|[
name|i
index|]
operator|.
name|di_desc
operator|=
operator|&
name|ri
operator|->
name|ri_descs
index|[
name|i
index|]
expr_stmt|;
name|ri
operator|->
name|ri_descinfo
index|[
name|i
index|]
operator|.
name|di_map
operator|=
operator|&
name|ri
operator|->
name|ri_data_maps
index|[
name|i
index|]
expr_stmt|;
block|}
name|ri
operator|->
name|ri_first
operator|=
name|ri
operator|->
name|ri_descinfo
expr_stmt|;
name|ri
operator|->
name|ri_max
operator|=
name|ndescs
expr_stmt|;
name|ri
operator|->
name|ri_last
operator|=
name|ri
operator|->
name|ri_first
operator|+
name|ri
operator|->
name|ri_max
expr_stmt|;
name|bzero
argument_list|(
name|ri
operator|->
name|ri_descs
argument_list|,
sizeof|sizeof
argument_list|(
name|tulip_desc_t
argument_list|)
operator|*
name|ri
operator|->
name|ri_max
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_last
index|[
operator|-
literal|1
index|]
operator|.
name|di_desc
operator|->
name|d_flag
operator|=
name|TULIP_DFLAG_ENDRING
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the PCI configuration support.  */
end_comment

begin_define
define|#
directive|define
name|PCI_CBIO
value|PCIR_BAR(0)
end_define

begin_comment
comment|/* Configuration Base IO Address */
end_comment

begin_define
define|#
directive|define
name|PCI_CBMA
value|PCIR_BAR(1)
end_define

begin_comment
comment|/* Configuration Base Memory Address */
end_comment

begin_define
define|#
directive|define
name|PCI_CFDA
value|0x40
end_define

begin_comment
comment|/* Configuration Driver Area */
end_comment

begin_function
specifier|static
name|int
name|tulip_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|!=
name|DEC_VENDORID
condition|)
return|return
name|ENXIO
return|;
comment|/*      * Some LanMedia WAN cards use the Tulip chip, but they have      * their own driver, and we should not recognize them      */
if|if
condition|(
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
operator|==
literal|0x1376
condition|)
return|return
name|ENXIO
return|;
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|CHIPID_21040
case|:
name|name
operator|=
literal|"Digital 21040 Ethernet"
expr_stmt|;
break|break;
case|case
name|CHIPID_21041
case|:
name|name
operator|=
literal|"Digital 21041 Ethernet"
expr_stmt|;
break|break;
case|case
name|CHIPID_21140
case|:
if|if
condition|(
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
operator|>=
literal|0x20
condition|)
name|name
operator|=
literal|"Digital 21140A Fast Ethernet"
expr_stmt|;
else|else
name|name
operator|=
literal|"Digital 21140 Fast Ethernet"
expr_stmt|;
break|break;
case|case
name|CHIPID_21142
case|:
if|if
condition|(
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
operator|>=
literal|0x20
condition|)
name|name
operator|=
literal|"Digital 21143 Fast Ethernet"
expr_stmt|;
else|else
name|name
operator|=
literal|"Digital 21142 Fast Ethernet"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_LOW_PRIORITY
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|idx
decl_stmt|;
name|u_int32_t
name|revinfo
decl_stmt|,
name|cfdainfo
decl_stmt|;
name|unsigned
name|csroffset
init|=
name|TULIP_PCI_CSROFFSET
decl_stmt|;
name|unsigned
name|csrsize
init|=
name|TULIP_PCI_CSRSIZE
decl_stmt|;
name|tulip_csrptr_t
name|csr_base
decl_stmt|;
name|tulip_chipid_t
name|chipid
init|=
name|TULIP_CHIPID_UNKNOWN
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|unit
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|TULIP_MAX_DEVICES
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"not configured; limit of %d reached or exceeded\n"
argument_list|,
name|TULIP_MAX_DEVICES
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|revinfo
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cfdainfo
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCI_CFDA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* turn busmaster on in case BIOS doesn't set it */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|DEC_VENDORID
condition|)
block|{
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|CHIPID_21040
condition|)
name|chipid
operator|=
name|TULIP_21040
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|CHIPID_21041
condition|)
name|chipid
operator|=
name|TULIP_21041
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|CHIPID_21140
condition|)
name|chipid
operator|=
operator|(
name|revinfo
operator|>=
literal|0x20
operator|)
condition|?
name|TULIP_21140A
else|:
name|TULIP_21140
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|CHIPID_21142
condition|)
name|chipid
operator|=
operator|(
name|revinfo
operator|>=
literal|0x20
operator|)
condition|?
name|TULIP_21143
else|:
name|TULIP_21142
expr_stmt|;
block|}
if|if
condition|(
name|chipid
operator|==
name|TULIP_CHIPID_UNKNOWN
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|chipid
operator|==
name|TULIP_21040
operator|&&
name|revinfo
operator|<
literal|0x20
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"not configured; 21040 pass 2.0 required (%d.%d found)\n"
argument_list|,
name|revinfo
operator|>>
literal|4
argument_list|,
name|revinfo
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
elseif|else
if|if
condition|(
name|chipid
operator|==
name|TULIP_21140
operator|&&
name|revinfo
operator|<
literal|0x11
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"not configured; 21140 pass 1.1 required (%d.%d found)\n"
argument_list|,
name|revinfo
operator|>>
literal|4
argument_list|,
name|revinfo
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|tulip_pci_busno
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_pci_devno
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_chipid
operator|=
name|chipid
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_DEVICEPROBE
expr_stmt|;
if|if
condition|(
name|chipid
operator|==
name|TULIP_21140
operator|||
name|chipid
operator|==
name|TULIP_21140A
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_GPR
operator||
name|TULIP_HAVE_STOREFWD
expr_stmt|;
if|if
condition|(
name|chipid
operator|==
name|TULIP_21140A
operator|&&
name|revinfo
operator|<=
literal|0x22
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_RXBADOVRFLW
expr_stmt|;
if|if
condition|(
name|chipid
operator|==
name|TULIP_21140
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_BROKEN_HASH
expr_stmt|;
if|if
condition|(
name|chipid
operator|!=
name|TULIP_21040
operator|&&
name|chipid
operator|!=
name|TULIP_21140
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_POWERMGMT
expr_stmt|;
if|if
condition|(
name|chipid
operator|==
name|TULIP_21041
operator|||
name|chipid
operator|==
name|TULIP_21142
operator|||
name|chipid
operator|==
name|TULIP_21143
condition|)
block|{
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_DUALSENSE
expr_stmt|;
if|if
condition|(
name|chipid
operator|!=
name|TULIP_21041
operator|||
name|revinfo
operator|>=
literal|0x20
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SIANWAY
expr_stmt|;
if|if
condition|(
name|chipid
operator|!=
name|TULIP_21041
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SIAGP
operator||
name|TULIP_HAVE_RXBADOVRFLW
operator||
name|TULIP_HAVE_STOREFWD
expr_stmt|;
if|if
condition|(
name|chipid
operator|!=
name|TULIP_21041
operator|&&
name|revinfo
operator|>=
literal|0x20
condition|)
name|sc
operator|->
name|tulip_features
operator||=
name|TULIP_HAVE_SIA100
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_POWERMGMT
operator|&&
operator|(
name|cfdainfo
operator|&
operator|(
name|TULIP_CFDA_SLEEP
operator||
name|TULIP_CFDA_SNOOZE
operator|)
operator|)
condition|)
block|{
name|cfdainfo
operator|&=
operator|~
operator|(
name|TULIP_CFDA_SLEEP
operator||
name|TULIP_CFDA_SNOOZE
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCI_CFDA
argument_list|,
name|cfdainfo
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|11
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|tulip_revinfo
operator|=
name|revinfo
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_IOMAPPED
argument_list|)
name|rid
operator|=
name|PCI_CBIO
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
else|#
directive|else
name|rid
operator|=
name|PCI_CBMA
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|res
condition|)
return|return
name|ENXIO
return|;
name|sc
operator|->
name|tulip_csrs_bst
operator|=
name|rman_get_bustag
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_csrs_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|csr_base
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
name|TULIP_MUTEX
argument_list|(
name|sc
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|tulip_callout
argument_list|,
name|TULIP_MUTEX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tulips
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|tulip_initcsrs
argument_list|(
name|sc
argument_list|,
name|csr_base
operator|+
name|csroffset
argument_list|,
name|csrsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|tulip_busdma_init
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error initing bus_dma: %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|tulip_busdma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
name|TULIP_MUTEX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|retval
operator|=
name|tulip_initring
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_rxinfo
argument_list|,
name|TULIP_RXDESCS
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
name|tulip_initring
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_txinfo
argument_list|,
name|TULIP_TXDESCS
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|tulip_busdma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
name|TULIP_MUTEX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/*      * Make sure there won't be any interrupts or such...      */
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
name|TULIP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|retval
operator|=
name|tulip_read_macaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't read ENET ROM (why=%d) ("
argument_list|,
name|retval
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%s pass %d.%d\n"
argument_list|,
name|sc
operator|->
name|tulip_boardid
argument_list|,
name|tulip_chipdescs
index|[
name|sc
operator|->
name|tulip_chipid
index|]
argument_list|,
operator|(
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"address unknown\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|void
function_decl|(
modifier|*
name|intr_rtn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
name|tulip_intr_normal
function_decl|;
if|if
condition|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_SHAREDINTR
condition|)
name|intr_rtn
operator|=
name|tulip_intr_shared
expr_stmt|;
name|tulip_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Setup interrupt last. */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_features
operator|&
name|TULIP_HAVE_SLAVEDINTR
operator|)
operator|==
literal|0
condition|)
block|{
name|void
modifier|*
name|ih
decl_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
operator|||
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|intr_rtn
argument_list|,
name|sc
argument_list|,
operator|&
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't map interrupt\n"
argument_list|)
expr_stmt|;
name|tulip_busdma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|tulip_ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|tulip_ifp
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
name|TULIP_MUTEX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|tulip_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|tulip_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|tulip_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|tulip_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|tulip_pci_driver
init|=
block|{
literal|"de"
block|,
name|tulip_pci_methods
block|,
sizeof|sizeof
argument_list|(
name|tulip_softc_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|tulip_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|de
argument_list|,
name|pci
argument_list|,
name|tulip_pci_driver
argument_list|,
name|tulip_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function_decl
name|void
name|tulip_dumpring
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|ring
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tulip_dumpdesc
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|ring
parameter_list|,
name|int
name|desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tulip_status
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|tulip_dumpring
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|ring
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
decl_stmt|;
name|tulip_ringinfo_t
modifier|*
name|ri
decl_stmt|;
name|tulip_descinfo_t
modifier|*
name|di
decl_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
name|TULIP_MAX_DEVICES
condition|)
block|{
name|db_printf
argument_list|(
literal|"invalid unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|tulips
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|db_printf
argument_list|(
literal|"unit %d not present\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ring
condition|)
block|{
case|case
literal|0
case|:
name|db_printf
argument_list|(
literal|"receive ring:\n"
argument_list|)
expr_stmt|;
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_rxinfo
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|db_printf
argument_list|(
literal|"transmit ring:\n"
argument_list|)
expr_stmt|;
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_txinfo
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"invalid ring %d\n"
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_printf
argument_list|(
literal|" nextin: %td, nextout: %td, max: %d, free: %d\n"
argument_list|,
name|ri
operator|->
name|ri_nextin
operator|-
name|ri
operator|->
name|ri_first
argument_list|,
name|ri
operator|->
name|ri_nextout
operator|-
name|ri
operator|->
name|ri_first
argument_list|,
name|ri
operator|->
name|ri_max
argument_list|,
name|ri
operator|->
name|ri_free
argument_list|)
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|!=
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
block|{
if|if
condition|(
name|di
operator|->
name|di_mbuf
operator|!=
name|NULL
condition|)
name|db_printf
argument_list|(
literal|" descriptor %td: mbuf %p\n"
argument_list|,
name|di
operator|-
name|ri
operator|->
name|ri_first
argument_list|,
name|di
operator|->
name|di_mbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|di
operator|->
name|di_desc
operator|->
name|d_flag
operator|&
name|TULIP_DFLAG_TxSETUPPKT
condition|)
name|db_printf
argument_list|(
literal|" descriptor %td: setup packet\n"
argument_list|,
name|di
operator|-
name|ri
operator|->
name|ri_first
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tulip_dumpdesc
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|ring
parameter_list|,
name|int
name|desc
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
decl_stmt|;
name|tulip_ringinfo_t
modifier|*
name|ri
decl_stmt|;
name|tulip_descinfo_t
modifier|*
name|di
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
name|TULIP_MAX_DEVICES
condition|)
block|{
name|db_printf
argument_list|(
literal|"invalid unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|tulips
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|db_printf
argument_list|(
literal|"unit %d not present\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ring
condition|)
block|{
case|case
literal|0
case|:
name|s
operator|=
literal|"receive"
expr_stmt|;
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_rxinfo
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|s
operator|=
literal|"transmit"
expr_stmt|;
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_txinfo
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"invalid ring %d\n"
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|desc
operator|<
literal|0
operator|||
name|desc
operator|>=
name|ri
operator|->
name|ri_max
condition|)
block|{
name|db_printf
argument_list|(
literal|"invalid descriptor %d\n"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_printf
argument_list|(
literal|"%s descriptor %d:\n"
argument_list|,
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|di
operator|=
operator|&
name|ri
operator|->
name|ri_first
index|[
name|desc
index|]
expr_stmt|;
name|db_printf
argument_list|(
literal|" mbuf: %p\n"
argument_list|,
name|di
operator|->
name|di_mbuf
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|" status: %08x  flag: %03x\n"
argument_list|,
name|di
operator|->
name|di_desc
operator|->
name|d_status
argument_list|,
name|di
operator|->
name|di_desc
operator|->
name|d_flag
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  addr1: %08x  len1: %03x\n"
argument_list|,
name|di
operator|->
name|di_desc
operator|->
name|d_addr1
argument_list|,
name|di
operator|->
name|di_desc
operator|->
name|d_length1
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  addr2: %08x  len2: %03x\n"
argument_list|,
name|di
operator|->
name|di_desc
operator|->
name|d_addr2
argument_list|,
name|di
operator|->
name|di_desc
operator|->
name|d_length2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

