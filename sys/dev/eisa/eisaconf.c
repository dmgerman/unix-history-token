begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Billie Alsup (balsup@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5)and OSF/1 operating  * systems.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * $Id: eisaconf.c,v 1.1 1995/03/13 09:10:17 root Exp root $  */
end_comment

begin_comment
comment|/*  * Ported to run under FreeBSD by Julian Elischer (julian@tfs.com) Sept 1992  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_comment
comment|/* isn't it a joy */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* to have three of these */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_comment
comment|/*we're a superset, so we need this */
end_comment

begin_include
include|#
directive|include
file|"eisaconf.h"
end_include

begin_decl_stmt
name|struct
name|isa_device
name|eisaSlot
index|[
name|EISA_SLOTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_device
name|isa_devtab_eisa
index|[
name|EISA_SLOTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nexttab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|eisa_dev
name|eisa_dev
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EISA_MAKEID
parameter_list|(
name|p
parameter_list|)
value|((((p)[0]&0x1F)<<10)|(((p)[1]&0x1F)<<5)|(((p)[2]&0x1F)))
end_define

begin_define
define|#
directive|define
name|EISA_ID0
parameter_list|(
name|i
parameter_list|)
value|((((i)>>10)&0x1F)+0x40)
end_define

begin_define
define|#
directive|define
name|EISA_ID1
parameter_list|(
name|i
parameter_list|)
value|((((i)>>5)&0x1F)+0x40)
end_define

begin_define
define|#
directive|define
name|EISA_ID2
parameter_list|(
name|i
parameter_list|)
value|(((i)&0x1F)+0x40)
end_define

begin_comment
comment|/* ** probe for EISA devices */
end_comment

begin_function
name|void
name|eisa_configure
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|slot
decl_stmt|,
name|found
decl_stmt|,
name|numports
decl_stmt|;
name|unsigned
name|int
name|checkthese
decl_stmt|;
name|struct
name|eisa_dev
modifier|*
name|edev_p
decl_stmt|;
name|int
name|eisaBase
init|=
literal|0xC80
decl_stmt|;
name|unsigned
name|short
name|productID
decl_stmt|,
name|productType
decl_stmt|;
name|unsigned
name|char
name|productRevision
decl_stmt|,
name|controlBits
decl_stmt|;
specifier|static
name|char
name|hexdigit
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
define|#
directive|define
name|HEXDIGIT
parameter_list|(
name|i
parameter_list|)
value|hexdigit[(i)&0x0f]
name|outb
argument_list|(
name|eisaBase
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|productID
operator|=
name|inb
argument_list|(
name|eisaBase
argument_list|)
expr_stmt|;
if|if
condition|(
name|productID
operator|&
literal|0x80
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: running EISA kernel on non-EISA system board\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Probing for devices on EISA bus\n"
argument_list|)
expr_stmt|;
name|productID
operator|=
operator|(
name|productID
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|eisaBase
operator|+
literal|1
argument_list|)
expr_stmt|;
name|productRevision
operator|=
name|inb
argument_list|(
name|eisaBase
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"EISA0: %c%c%c v%d (System Board)\n"
argument_list|,
name|EISA_ID0
argument_list|(
name|productID
argument_list|)
argument_list|,
name|EISA_ID1
argument_list|(
name|productID
argument_list|)
argument_list|,
name|EISA_ID2
argument_list|(
name|productID
argument_list|)
argument_list|,
operator|(
name|productRevision
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|1
init|;
name|eisaBase
operator|+=
literal|0x1000
operator|,
name|slot
operator|<
name|EISA_SLOTS
condition|;
name|slot
operator|++
control|)
block|{
name|outb
argument_list|(
name|eisaBase
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|productID
operator|=
name|inb
argument_list|(
name|eisaBase
argument_list|)
expr_stmt|;
if|if
condition|(
name|productID
operator|&
literal|0x80
condition|)
continue|continue;
comment|/* no EISA card in slot */
name|productID
operator|=
operator|(
name|productID
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|eisaBase
operator|+
literal|1
argument_list|)
expr_stmt|;
name|productType
operator|=
name|inb
argument_list|(
name|eisaBase
operator|+
literal|2
argument_list|)
expr_stmt|;
name|productRevision
operator|=
name|inb
argument_list|(
name|eisaBase
operator|+
literal|3
argument_list|)
expr_stmt|;
name|productType
operator|=
operator|(
name|productType
operator|<<
literal|4
operator|)
operator||
operator|(
name|productRevision
operator|>>
literal|4
operator|)
expr_stmt|;
name|productRevision
operator|&=
literal|15
expr_stmt|;
name|controlBits
operator|=
name|inb
argument_list|(
name|eisaBase
operator|+
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"EISA%d: %c%c%c-%c%c%c.%x\n"
argument_list|,
name|slot
argument_list|,
name|EISA_ID0
argument_list|(
name|productID
argument_list|)
argument_list|,
name|EISA_ID1
argument_list|(
name|productID
argument_list|)
argument_list|,
name|EISA_ID2
argument_list|(
name|productID
argument_list|)
argument_list|,
name|HEXDIGIT
argument_list|(
name|productType
operator|>>
literal|8
argument_list|)
argument_list|,
name|HEXDIGIT
argument_list|(
name|productType
operator|>>
literal|4
argument_list|)
argument_list|,
name|HEXDIGIT
argument_list|(
name|productType
argument_list|)
argument_list|,
name|productRevision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|controlBits
operator|&
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"...Card is disabled\n"
argument_list|)
expr_stmt|;
comment|/* continue;*/
block|}
comment|/*       ** See if we recognize this product       */
for|for
control|(
name|edev_p
operator|=
name|eisa_dev
operator|,
name|found
operator|=
literal|0
init|;
name|edev_p
operator|->
name|productID
index|[
literal|0
index|]
condition|;
name|edev_p
operator|++
control|)
block|{
name|struct
name|isa_device
modifier|*
name|dev_p
decl_stmt|;
name|struct
name|isa_driver
modifier|*
name|drv_p
decl_stmt|;
name|unsigned
name|short
name|configuredID
decl_stmt|;
name|configuredID
operator|=
name|EISA_MAKEID
argument_list|(
name|edev_p
operator|->
name|productID
argument_list|)
expr_stmt|;
if|if
condition|(
name|configuredID
operator|!=
name|productID
condition|)
continue|continue;
if|if
condition|(
name|edev_p
operator|->
name|productType
operator|!=
name|productType
condition|)
continue|continue;
if|if
condition|(
name|edev_p
operator|->
name|productRevision
operator|>
name|productRevision
condition|)
continue|continue;
comment|/*         ** we're assuming:         **      if different drivers for the same board exist         **      (due to some revision incompatibility), that the         **      drivers will be listed in descending revision         **      order.  The revision in the eisaDevs structure         **      should indicate the lowest revision supported         **      by the code.         **         */
name|dev_p
operator|=
operator|&
name|eisaSlot
index|[
name|slot
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|dev_p
argument_list|,
operator|&
name|edev_p
operator|->
name|isa_dev
argument_list|,
sizeof|sizeof
argument_list|(
name|edev_p
operator|->
name|isa_dev
argument_list|)
argument_list|)
expr_stmt|;
name|drv_p
operator|=
name|dev_p
operator|->
name|id_driver
expr_stmt|;
name|dev_p
operator|->
name|id_iobase
operator|=
name|eisaBase
expr_stmt|;
comment|/* may get ammended by driver */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|printf
argument_list|(
literal|"eisaProbe: probing %s%d\n"
argument_list|,
name|drv_p
operator|->
name|driver_name
argument_list|,
name|dev_p
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG) */
if|if
condition|(
operator|!
operator|(
name|numports
operator|=
name|drv_p
operator|->
name|probe
argument_list|(
name|dev_p
argument_list|)
operator|)
condition|)
block|{
continue|continue;
comment|/* try another eisa device */
block|}
name|edev_p
operator|->
name|isa_dev
operator|.
name|id_unit
operator|++
expr_stmt|;
comment|/*dubious*/
comment|/** this should all be put in some common routine **/
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|drv_p
operator|->
name|name
argument_list|,
name|dev_p
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|numports
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|" at 0x%x"
argument_list|,
name|dev_p
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev_p
operator|->
name|id_iobase
operator|+
name|numports
operator|-
literal|1
operator|)
operator|!=
name|dev_p
operator|->
name|id_iobase
condition|)
block|{
name|printf
argument_list|(
literal|"-0x%x"
argument_list|,
name|dev_p
operator|->
name|id_iobase
operator|+
name|numports
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dev_p
operator|->
name|id_irq
condition|)
name|printf
argument_list|(
literal|" irq %d"
argument_list|,
name|ffs
argument_list|(
name|dev_p
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_drq
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|" drq %d"
argument_list|,
name|dev_p
operator|->
name|id_drq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_maddr
condition|)
name|printf
argument_list|(
literal|" maddr 0x%lx"
argument_list|,
name|kvtop
argument_list|(
name|dev_p
operator|->
name|id_maddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_msize
condition|)
name|printf
argument_list|(
literal|" msize %d"
argument_list|,
name|dev_p
operator|->
name|id_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_flags
condition|)
name|printf
argument_list|(
literal|" flags 0x%x"
argument_list|,
name|dev_p
operator|->
name|id_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_iobase
condition|)
block|{
if|if
condition|(
name|dev_p
operator|->
name|id_iobase
operator|<
literal|0x100
condition|)
block|{
name|printf
argument_list|(
literal|" on motherboard\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev_p
operator|->
name|id_iobase
operator|>=
literal|0x1000
condition|)
block|{
name|printf
argument_list|(
literal|" on EISA\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" on ISA emulation\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*         ** Now look for any live devices with the same starting I/O port and 	** give up if we clash         **         ** what i'd really like is to set is how many i/o ports are in use.         ** but that isn't in this structure...         **         */
name|checkthese
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_iobase
condition|)
name|checkthese
operator||=
name|CC_IOADDR
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_drq
operator|!=
operator|-
literal|1
condition|)
name|checkthese
operator||=
name|CC_DRQ
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_irq
condition|)
name|checkthese
operator||=
name|CC_IRQ
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_maddr
condition|)
name|checkthese
operator||=
name|CC_MEMADDR
expr_stmt|;
comment|/* this may be stupid, it's probably too late if we clash here */
if|if
condition|(
name|haveseen_isadev
argument_list|(
name|dev_p
argument_list|,
name|checkthese
argument_list|)
condition|)
break|break;
comment|/* we can't proceed due to collision. bail */
comment|/* mark ourselves in existence and then put us in the eisa list */
comment|/* so that other things check against US for a clash */
name|dev_p
operator|->
name|id_alive
operator|=
operator|(
name|numports
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|numports
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|isa_devtab_eisa
index|[
name|nexttab
index|]
operator|)
argument_list|,
name|dev_p
argument_list|,
sizeof|sizeof
argument_list|(
name|edev_p
operator|->
name|isa_dev
argument_list|)
argument_list|)
expr_stmt|;
name|drv_p
operator|->
name|attach
argument_list|(
name|dev_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_p
operator|->
name|id_irq
condition|)
block|{
if|if
condition|(
name|edev_p
operator|->
name|imask
condition|)
name|INTRMASK
argument_list|(
operator|*
operator|(
name|edev_p
operator|->
name|imask
operator|)
argument_list|,
name|dev_p
operator|->
name|id_irq
argument_list|)
expr_stmt|;
name|register_intr
argument_list|(
name|ffs
argument_list|(
name|dev_p
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|dev_p
operator|->
name|id_id
argument_list|,
name|dev_p
operator|->
name|id_ri_flags
argument_list|,
name|dev_p
operator|->
name|id_intr
argument_list|,
name|edev_p
operator|->
name|imask
argument_list|,
name|dev_p
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|INTREN
argument_list|(
name|dev_p
operator|->
name|id_irq
argument_list|)
expr_stmt|;
block|}
name|found
operator|=
literal|1
expr_stmt|;
name|nexttab
operator|++
expr_stmt|;
break|break;
comment|/* go look at next slot*/
block|}
comment|/* end of loop on known devices */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|printf
argument_list|(
literal|"...No driver installed for board\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of loop on slots */
block|}
end_function

begin_comment
comment|/* end of routine */
end_comment

end_unit

