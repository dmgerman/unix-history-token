begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* release_6_5_99 */
end_comment

begin_comment
comment|/*  * Platform (FreeBSD 2.X) dependent common attachment code for Qlogic adapters.  *  *---------------------------------------  * Copyright (c) 1997, 1998 by Matthew Jacob  * NASA/Ames Research Center  * All rights reserved.  *---------------------------------------  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isp/isp_freebsd.h>
end_include

begin_define
define|#
directive|define
name|WATCH_INTERVAL
value|30
end_define

begin_decl_stmt
specifier|static
name|void
name|ispminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|isp_adapter_info
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ispcmd
name|__P
argument_list|(
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_watch
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|isp_switch
init|=
block|{
name|ispcmd
block|,
name|ispminphys
block|,
literal|0
block|,
literal|0
block|,
name|isp_adapter_info
block|,
literal|"isp"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|isp_dev
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"isp"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_poll
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ISP_SCSI_XFER_T
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Complete attachment of hardware, include subdevices.  */
end_comment

begin_function
name|void
name|isp_attach
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|==
name|ISP_INITSTATE
condition|)
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RUNSTATE
expr_stmt|;
name|timeout
argument_list|(
name|isp_watch
argument_list|,
name|isp
argument_list|,
name|WATCH_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_dogactive
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter_unit
operator|=
name|isp
operator|->
name|isp_osinfo
operator|.
name|unit
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter_softc
operator|=
name|isp
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter
operator|=
operator|&
name|isp_switch
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|device
operator|=
operator|&
name|isp_dev
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter_targ
operator|=
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopid
expr_stmt|;
name|scbus
operator|->
name|maxtarg
operator|=
name|MAX_FC_TARG
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|tmp
init|=
literal|0
decl_stmt|;
comment|/* XXXX: Which Bus? */
name|isp
operator|->
name|isp_osinfo
operator|.
name|delay_throttle_count
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter_targ
operator|=
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_initiator_id
expr_stmt|;
name|scbus
operator|->
name|maxtarg
operator|=
name|MAX_TARGETS
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_RESET_BUS
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Prepare the scsibus_data area for the upperlevel scsi code. 	 */
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * minphys our xfers  *  * Unfortunately, the buffer pointer describes the target device- not the  * adapter device, so we can't use the pointer to find out what kind of  * adapter we are and adjust accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|ispminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * Only the 1020/1040 has a 24 bit limit. 	 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>=
operator|(
literal|1
operator|<<
literal|24
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|isp_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
comment|/*  	 * XXX: FIND ISP BASED UPON UNIT AND GET REAL QUEUE LIMIT FROM THAT 	 */
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ispcmd
parameter_list|(
name|ISP_SCSI_XFER_T
modifier|*
name|xs
parameter_list|)
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|r
decl_stmt|,
name|s
decl_stmt|;
name|isp
operator|=
name|XS_ISP
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|isp_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_INITSTATE
condition|)
block|{
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RUNSTATE
expr_stmt|;
block|}
name|r
operator|=
name|ispscsicmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|CMD_QUEUED
operator|||
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* 	 * If we can't use interrupts, poll on completion. 	 */
if|if
condition|(
name|isp_poll
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|XS_TIME
argument_list|(
name|xs
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		 * If no other error occurred but we didn't finish, 		 * something bad happened. 		 */
if|if
condition|(
name|XS_IS_CMD_DONE
argument_list|(
name|xs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_nactive
operator|<
literal|0
condition|)
name|isp
operator|->
name|isp_nactive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|isp_lostcmd
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_poll
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|ISP_SCSI_XFER_T
modifier|*
name|xs
parameter_list|,
name|int
name|mswait
parameter_list|)
block|{
while|while
condition|(
name|mswait
condition|)
block|{
comment|/* Try the interrupt handling routine */
operator|(
name|void
operator|)
name|isp_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|isp
argument_list|)
expr_stmt|;
comment|/* See if the xs is now done */
if|if
condition|(
name|XS_IS_CMD_DONE
argument_list|(
name|xs
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|SYS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* wait one millisecond */
name|mswait
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_watch
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|arg
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Look for completely dead commands (but not polled ones). 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|xs
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|-=
operator|(
name|WATCH_INTERVAL
operator|*
literal|1000
operator|)
expr_stmt|;
comment|/* 		 * Avoid later thinking that this 		 * transaction is not being timed. 		 * Then give ourselves to watchdog 		 * periods of grace. 		 */
if|if
condition|(
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|==
literal|0
condition|)
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|>
operator|-
operator|(
literal|2
operator|*
name|WATCH_INTERVAL
operator|*
literal|1000
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp
operator|->
name|isp_osinfo
operator|.
name|delay_throttle_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_ABORT_CMD
argument_list|,
name|xs
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: isp_watch failed to abort command\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp_restart
argument_list|(
name|isp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|isp
operator|->
name|isp_osinfo
operator|.
name|delay_throttle_count
condition|)
block|{
if|if
condition|(
operator|--
name|isp
operator|->
name|isp_osinfo
operator|.
name|delay_throttle_count
operator|==
literal|0
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_WIDE
operator||
name|DPARM_SYNC
operator||
name|DPARM_TQING
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
block|}
name|isp
operator|->
name|isp_update
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|timeout
argument_list|(
name|isp_watch
argument_list|,
name|isp
argument_list|,
name|WATCH_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_dogactive
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|isp_async
parameter_list|(
name|isp
parameter_list|,
name|cmd
parameter_list|,
name|arg
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispasync_t
name|cmd
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ISPASYNC_NEW_TGT_PARAMS
case|:
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|char
modifier|*
name|wt
decl_stmt|;
name|int
name|mhz
decl_stmt|,
name|flags
decl_stmt|,
name|tgt
decl_stmt|,
name|period
decl_stmt|;
name|tgt
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
name|flags
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
expr_stmt|;
name|period
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DPARM_SYNC
operator|)
operator|&&
name|period
operator|&&
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_lvdmode
condition|)
block|{
switch|switch
condition|(
name|period
condition|)
block|{
case|case
literal|0xa
case|:
name|mhz
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
name|mhz
operator|=
literal|33
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
name|mhz
operator|=
literal|25
expr_stmt|;
break|break;
default|default:
name|mhz
operator|=
literal|1000
operator|/
operator|(
name|period
operator|*
literal|4
operator|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|mhz
operator|=
literal|1000
operator|/
operator|(
name|period
operator|*
literal|4
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mhz
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|flags
operator|&
operator|(
name|DPARM_WIDE
operator||
name|DPARM_TQING
operator|)
condition|)
block|{
case|case
name|DPARM_WIDE
case|:
name|wt
operator|=
literal|", 16 bit wide\n"
expr_stmt|;
break|break;
case|case
name|DPARM_TQING
case|:
name|wt
operator|=
literal|", Tagged Queueing Enabled\n"
expr_stmt|;
break|break;
case|case
name|DPARM_WIDE
operator||
name|DPARM_TQING
case|:
name|wt
operator|=
literal|", 16 bit wide, Tagged Queueing Enabled\n"
expr_stmt|;
break|break;
default|default:
name|wt
operator|=
literal|"\n"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mhz
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Target %d at %dMHz Max Offset %d%s"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|,
name|mhz
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
argument_list|,
name|wt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Target %d Async Mode%s"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|,
name|wt
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ISPASYNC_BUS_RESET
case|:
name|printf
argument_list|(
literal|"%s: SCSI bus reset detected\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPASYNC_LOOP_DOWN
case|:
name|printf
argument_list|(
literal|"%s: Loop DOWN\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPASYNC_LOOP_UP
case|:
name|printf
argument_list|(
literal|"%s: Loop UP\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPASYNC_PDB_CHANGED
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"%s: Target %d (Loop 0x%x) Port ID 0x%x "
literal|"role %s %s\n Port WWN 0x%08x%08x\n Node WWN 0x%08x%08x\n"
decl_stmt|;
specifier|const
specifier|static
name|char
modifier|*
name|roles
index|[
literal|4
index|]
init|=
block|{
literal|"No"
block|,
literal|"Target"
block|,
literal|"Initiator"
block|,
literal|"Target/Initiator"
block|}
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|tgt
init|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
name|struct
name|lportdb
modifier|*
name|lp
init|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|tgt
index|]
decl_stmt|;
if|if
condition|(
name|lp
operator|->
name|valid
condition|)
block|{
name|ptr
operator|=
literal|"arrived"
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
literal|"disappeared"
expr_stmt|;
block|}
name|printf
argument_list|(
name|fmt
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|,
name|lp
operator|->
name|loopid
argument_list|,
name|lp
operator|->
name|portid
argument_list|,
name|roles
index|[
name|lp
operator|->
name|roles
operator|&
literal|0x3
index|]
argument_list|,
name|ptr
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|lp
operator|->
name|port_wwn
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|lp
operator|->
name|port_wwn
operator|&
literal|0xffffffffLL
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|lp
operator|->
name|node_wwn
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|lp
operator|->
name|node_wwn
operator|&
literal|0xffffffffLL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|ISP2100_FABRIC
case|case
name|ISPASYNC_CHANGE_NOTIFY
case|:
name|printf
argument_list|(
literal|"%s: Name Server Database Changed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPASYNC_FABRIC_DEV
case|:
block|{
name|int
name|target
decl_stmt|;
name|struct
name|lportdb
modifier|*
name|lp
decl_stmt|;
name|sns_scrsp_t
modifier|*
name|resp
init|=
operator|(
name|sns_scrsp_t
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int32_t
name|portid
decl_stmt|;
name|u_int64_t
name|wwn
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|portid
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|0
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|2
index|]
operator|)
operator|)
expr_stmt|;
name|wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: type 0x%x@portid 0x%x 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|resp
operator|->
name|snscb_port_type
argument_list|,
name|portid
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|wwn
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|wwn
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|snscb_port_type
operator|!=
literal|2
condition|)
break|break;
for|for
control|(
name|target
operator|=
name|FC_SNS_ID
operator|+
literal|1
init|;
name|target
operator|<
name|MAX_FC_TARG
condition|;
name|target
operator|++
control|)
block|{
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|port_wwn
operator|==
name|wwn
condition|)
break|break;
block|}
if|if
condition|(
name|target
operator|<
name|MAX_FC_TARG
condition|)
block|{
break|break;
block|}
for|for
control|(
name|target
operator|=
name|FC_SNS_ID
operator|+
literal|1
init|;
name|target
operator|<
name|MAX_FC_TARG
condition|;
name|target
operator|++
control|)
block|{
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|port_wwn
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|target
operator|==
name|MAX_FC_TARG
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no more space for fabric devices\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lp
operator|->
name|port_wwn
operator|=
name|lp
operator|->
name|node_wwn
operator|=
name|wwn
expr_stmt|;
name|lp
operator|->
name|portid
operator|=
name|portid
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free any associated resources prior to decommissioning and  * set the card to a known state (so it doesn't wake up and kick  * us when we aren't expecting it to).  *  * Locks are held before coming here.  */
end_comment

begin_function
name|void
name|isp_uninit
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
comment|/* 	 * Leave with interrupts disabled. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RESET
argument_list|)
expr_stmt|;
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off the watchdog (if active). 	 */
if|if
condition|(
name|isp
operator|->
name|isp_dogactive
condition|)
block|{
name|untimeout
argument_list|(
name|isp_watch
argument_list|,
name|isp
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_dogactive
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * And out... 	 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

