begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Platform (FreeBSD 2.X) dependent common attachment code for Qlogic adapters.  *  *---------------------------------------  * Copyright (c) 1997, 1998 by Matthew Jacob  * NASA/Ames Research Center  * All rights reserved.  *---------------------------------------  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isp/isp_freebsd.h>
end_include

begin_function_decl
specifier|static
name|void
name|ispminphys
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|isp_adapter_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ispcmd_slow
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ispcmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|isp_switch
init|=
block|{
name|ispcmd_slow
block|,
name|ispminphys
block|,
literal|0
block|,
literal|0
block|,
name|isp_adapter_info
block|,
literal|"isp"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|isp_dev
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"isp"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|isp_poll
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|struct
name|scsi_xfer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_watch
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_command_requeue
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_internal_restart
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Complete attachment of hardware, include subdevices.  */
end_comment

begin_function
name|void
name|isp_attach
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|,
modifier|*
name|scbusb
init|=
name|NULL
decl_stmt|;
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
block|{
return|return;
block|}
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RUNSTATE
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter_unit
operator|=
name|isp
operator|->
name|isp_osinfo
operator|.
name|unit
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter_softc
operator|=
name|isp
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|device
operator|=
operator|&
name|isp_dev
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|opennings
operator|=
name|isp
operator|->
name|isp_maxcmds
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter
operator|=
operator|&
name|isp_switch
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|wqf
operator|=
name|isp
operator|->
name|isp_osinfo
operator|.
name|wqt
operator|=
name|NULL
expr_stmt|;
comment|/* XXX 2nd Bus? */
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter_targ
operator|=
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopid
expr_stmt|;
name|scbus
operator|->
name|maxtarg
operator|=
name|MAX_FC_TARG
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|discovered
index|[
literal|0
index|]
operator|=
literal|1
operator|<<
name|sdp
operator|->
name|isp_initiator_id
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
operator|.
name|adapter_targ
operator|=
name|sdp
operator|->
name|isp_initiator_id
expr_stmt|;
name|scbus
operator|->
name|maxtarg
operator|=
name|MAX_TARGETS
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
operator|&&
operator|(
name|scbusb
operator|=
name|scsi_alloc_bus
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sdp
operator|++
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link_b
operator|=
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link_b
operator|.
name|adapter_targ
operator|=
name|sdp
operator|->
name|isp_initiator_id
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|discovered
index|[
literal|1
index|]
operator|=
literal|1
operator|<<
name|sdp
operator|->
name|isp_initiator_id
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link_b
operator|.
name|adapter_bus
operator|=
literal|1
expr_stmt|;
name|scbusb
operator|->
name|maxtarg
operator|=
name|MAX_TARGETS
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Send a SCSI Bus Reset (used to be done as part of attach, 	 * but now left to the OS outer layers). 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|int
name|bus
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_RESET_BUS
argument_list|,
operator|&
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|bus
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_RESET_BUS
argument_list|,
operator|&
name|bus
argument_list|)
expr_stmt|;
block|}
name|SYS_DELAY
argument_list|(
literal|2
operator|*
literal|1000000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Start the watchdog. 	 */
name|timeout
argument_list|(
name|isp_watch
argument_list|,
name|isp
argument_list|,
name|WATCH_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_dogactive
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel scsi code. 	 */
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
comment|/* 	 * Attach second bus if there. 	 */
if|if
condition|(
name|scbusb
condition|)
block|{
name|scbusb
operator|->
name|adapter_link
operator|=
operator|&
name|isp
operator|->
name|isp_osinfo
operator|.
name|_link_b
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbusb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * minphys our xfers  *  * Unfortunately, the buffer pointer describes the target device- not the  * adapter device, so we can't use the pointer to find out what kind of  * adapter we are and adjust accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|ispminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * Only the 1020/1040 has a 24 bit limit. 	 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>=
operator|(
literal|1
operator|<<
literal|24
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|isp_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ispcmd_slow
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|XS_ISP
argument_list|(
name|xs
argument_list|)
decl_stmt|;
comment|/* 	 * Have we completed discovery for this adapter? 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
operator|&&
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
operator|==
literal|0
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|int
name|chan
init|=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
decl_stmt|,
name|chmax
init|=
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|u_int16_t
name|f
init|=
name|DPARM_DEFAULT
decl_stmt|;
name|sdp
operator|+=
name|chan
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|quirks
operator|&
name|SCSI_Q_NO_SYNC
condition|)
block|{
name|f
operator|^=
name|DPARM_SYNC
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|quirks
operator|&
name|SCSI_Q_NO_WIDE
condition|)
block|{
name|f
operator|^=
name|DPARM_WIDE
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|quirks
operator|&
name|SD_Q_NO_TAGS
condition|)
block|{
name|f
operator|^=
name|DPARM_TQING
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_flags
operator|=
name|f
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|discovered
index|[
name|chan
index|]
operator||=
operator|(
literal|1
operator|<<
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
name|f
operator|=
literal|0xffff
operator|^
operator|(
literal|1
operator|<<
name|sdp
operator|->
name|isp_initiator_id
operator|)
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|chmax
condition|;
name|chan
operator|++
control|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_osinfo
operator|.
name|discovered
index|[
name|chan
index|]
operator|==
name|f
condition|)
break|break;
block|}
if|if
condition|(
name|chan
operator|==
name|chmax
condition|)
block|{
name|isp_switch
operator|.
name|scsi_cmd
operator|=
name|ispcmd
expr_stmt|;
name|isp
operator|->
name|isp_update
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
name|isp
operator|->
name|isp_update
operator||=
literal|2
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ispcmd
argument_list|(
name|xs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ispcmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|result
decl_stmt|,
name|s
decl_stmt|;
name|isp
operator|=
name|XS_ISP
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|<
name|ISP_RUNSTATE
condition|)
block|{
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_INITSTATE
condition|)
block|{
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RUNSTATE
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for queue blockage... 	 */
if|if
condition|(
name|isp
operator|->
name|isp_osinfo
operator|.
name|blocked
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_osinfo
operator|.
name|wqf
operator|!=
name|NULL
condition|)
block|{
name|isp
operator|->
name|isp_osinfo
operator|.
name|wqt
operator|->
name|next
operator|=
name|xs
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_osinfo
operator|.
name|wqf
operator|=
name|xs
expr_stmt|;
block|}
name|isp
operator|->
name|isp_osinfo
operator|.
name|wqt
operator|=
name|xs
expr_stmt|;
name|xs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|result
operator|=
name|ispscsicmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|CMD_QUEUED
case|:
name|result
operator|=
name|SUCCESSFULLY_QUEUED
expr_stmt|;
break|break;
case|case
name|CMD_EAGAIN
case|:
name|result
operator|=
name|TRY_AGAIN_LATER
expr_stmt|;
break|break;
case|case
name|CMD_RQLATER
case|:
name|result
operator|=
name|SUCCESSFULLY_QUEUED
expr_stmt|;
name|timeout
argument_list|(
name|isp_command_requeue
argument_list|,
name|xs
argument_list|,
name|hz
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_COMPLETE
case|:
name|result
operator|=
name|COMPLETE
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|CMD_QUEUED
case|:
name|result
operator|=
name|SUCCESSFULLY_QUEUED
expr_stmt|;
break|break;
case|case
name|CMD_RQLATER
case|:
case|case
name|CMD_EAGAIN
case|:
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
name|result
operator|=
name|TRY_AGAIN_LATER
expr_stmt|;
break|break;
case|case
name|CMD_COMPLETE
case|:
name|result
operator|=
name|COMPLETE
expr_stmt|;
break|break;
block|}
comment|/* 	 * We can't use interrupts so poll on completion. 	 */
if|if
condition|(
name|result
operator|==
name|SUCCESSFULLY_QUEUED
condition|)
block|{
if|if
condition|(
name|isp_poll
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
comment|/* 			 * If no other error occurred but we didn't finish, 			 * something bad happened. 			 */
if|if
condition|(
name|XS_IS_CMD_DONE
argument_list|(
name|xs
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_ABORT_CMD
argument_list|,
name|xs
argument_list|)
condition|)
block|{
name|isp_restart
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|result
operator|=
name|COMPLETE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_poll
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|,
name|int
name|mswait
parameter_list|)
block|{
while|while
condition|(
name|mswait
condition|)
block|{
comment|/* Try the interrupt handling routine */
operator|(
name|void
operator|)
name|isp_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|isp
argument_list|)
expr_stmt|;
comment|/* See if the xs is now done */
if|if
condition|(
name|XS_IS_CMD_DONE
argument_list|(
name|xs
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|SYS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* wait one millisecond */
name|mswait
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_watch
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|arg
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Look for completely dead commands (but not polled ones). 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isp
operator|->
name|isp_maxcmds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|xs
operator|=
operator|(
expr|struct
name|scsi_xfer
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|xs
operator|->
name|timeout
operator|==
literal|0
operator|||
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
continue|continue;
block|}
name|xs
operator|->
name|timeout
operator|-=
operator|(
name|WATCH_INTERVAL
operator|*
literal|1000
operator|)
expr_stmt|;
comment|/* 		 * Avoid later thinking that this 		 * transaction is not being timed. 		 * Then give ourselves to watchdog 		 * periods of grace. 		 */
if|if
condition|(
name|xs
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
name|xs
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xs
operator|->
name|timeout
operator|>
operator|-
operator|(
literal|2
operator|*
name|WATCH_INTERVAL
operator|*
literal|1000
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_ABORT_CMD
argument_list|,
name|xs
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: isp_watch failed to abort command\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp_restart
argument_list|(
name|isp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|timeout
argument_list|(
name|isp_watch
argument_list|,
name|isp
argument_list|,
name|WATCH_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_dogactive
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free any associated resources prior to decommissioning and  * set the card to a known state (so it doesn't wake up and kick  * us when we aren't expecting it to).  *  * Locks are held before coming here.  */
end_comment

begin_function
name|void
name|isp_uninit
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
comment|/* 	 * Leave with interrupts disabled. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RESET
argument_list|)
expr_stmt|;
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off the watchdog (if active). 	 */
if|if
condition|(
name|isp
operator|->
name|isp_dogactive
condition|)
block|{
name|untimeout
argument_list|(
name|isp_watch
argument_list|,
name|isp
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_dogactive
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * And out... 	 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restart function for a command to be requeued later.  */
end_comment

begin_function
specifier|static
name|void
name|isp_command_requeue
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|arg
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|XS_ISP
argument_list|(
name|xs
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|ispcmd_slow
argument_list|(
name|xs
argument_list|)
condition|)
block|{
case|case
name|SUCCESSFULLY_QUEUED
case|:
name|printf
argument_list|(
literal|"%s: isp_command_reque: queued %d.%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN_LATER
case|:
name|printf
argument_list|(
literal|"%s: EAGAIN for %d.%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|COMPLETE
case|:
comment|/* can only be an error */
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|XS_DRIVER_STUFFUP
argument_list|)
expr_stmt|;
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restart function after a LOOP UP event (e.g.),  * done as a timeout for some hysteresis.  */
end_comment

begin_function
specifier|static
name|void
name|isp_internal_restart
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|arg
decl_stmt|;
name|int
name|result
decl_stmt|,
name|nrestarted
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_osinfo
operator|.
name|blocked
operator|==
literal|0
condition|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
while|while
condition|(
operator|(
name|xs
operator|=
name|isp
operator|->
name|isp_osinfo
operator|.
name|wqf
operator|)
operator|!=
name|NULL
condition|)
block|{
name|isp
operator|->
name|isp_osinfo
operator|.
name|wqf
operator|=
name|xs
operator|->
name|next
expr_stmt|;
name|xs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|result
operator|=
name|ispscsicmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|CMD_QUEUED
condition|)
block|{
name|printf
argument_list|(
literal|"%s: botched command restart (0x%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|XS_DRIVER_STUFFUP
argument_list|)
expr_stmt|;
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|nrestarted
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: requeued %d commands\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|nrestarted
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|isp_async
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|ispasync_t
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|tgt
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ISPASYNC_NEW_TGT_PARAMS
case|:
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
operator|&&
name|isp
operator|->
name|isp_dblev
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|char
modifier|*
name|wt
decl_stmt|;
name|int
name|mhz
decl_stmt|,
name|flags
decl_stmt|,
name|period
decl_stmt|;
name|tgt
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
name|bus
operator|=
operator|(
name|tgt
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|tgt
operator|&=
literal|0xffff
expr_stmt|;
name|flags
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
expr_stmt|;
name|period
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DPARM_SYNC
operator|)
operator|&&
name|period
operator|&&
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_lvdmode
condition|)
block|{
switch|switch
condition|(
name|period
condition|)
block|{
case|case
literal|0xa
case|:
name|mhz
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
name|mhz
operator|=
literal|33
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
name|mhz
operator|=
literal|25
expr_stmt|;
break|break;
default|default:
name|mhz
operator|=
literal|1000
operator|/
operator|(
name|period
operator|*
literal|4
operator|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|mhz
operator|=
literal|1000
operator|/
operator|(
name|period
operator|*
literal|4
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mhz
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|flags
operator|&
operator|(
name|DPARM_WIDE
operator||
name|DPARM_TQING
operator|)
condition|)
block|{
case|case
name|DPARM_WIDE
case|:
name|wt
operator|=
literal|", 16 bit wide\n"
expr_stmt|;
break|break;
case|case
name|DPARM_TQING
case|:
name|wt
operator|=
literal|", Tagged Queueing Enabled\n"
expr_stmt|;
break|break;
case|case
name|DPARM_WIDE
operator||
name|DPARM_TQING
case|:
name|wt
operator|=
literal|", 16 bit wide, Tagged Queueing Enabled\n"
expr_stmt|;
break|break;
default|default:
name|wt
operator|=
literal|"\n"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mhz
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bus %d Target %d at %dMHz Max "
literal|"Offset %d%s"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|bus
argument_list|,
name|tgt
argument_list|,
name|mhz
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
argument_list|,
name|wt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Bus %d Target %d Async Mode%s"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|bus
argument_list|,
name|tgt
argument_list|,
name|wt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ISPASYNC_BUS_RESET
case|:
if|if
condition|(
name|arg
condition|)
name|bus
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
else|else
name|bus
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s: SCSI bus %d reset detected\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|bus
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPASYNC_LOOP_DOWN
case|:
comment|/* 		 * Hopefully we get here in time to minimize the number 		 * of commands we are firing off that are sure to die. 		 */
name|isp
operator|->
name|isp_osinfo
operator|.
name|blocked
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Loop DOWN\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPASYNC_LOOP_UP
case|:
name|isp
operator|->
name|isp_osinfo
operator|.
name|blocked
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|isp_internal_restart
argument_list|,
name|isp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Loop UP\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPASYNC_PDB_CHANGED
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
operator|&&
name|isp
operator|->
name|isp_dblev
condition|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"%s: Target %d (Loop 0x%x) Port ID 0x%x "
literal|"role %s %s\n Port WWN 0x%08x%08x\n Node WWN 0x%08x%08x\n"
decl_stmt|;
specifier|const
specifier|static
name|char
modifier|*
name|roles
index|[
literal|4
index|]
init|=
block|{
literal|"No"
block|,
literal|"Target"
block|,
literal|"Initiator"
block|,
literal|"Target/Initiator"
block|}
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|tgt
init|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
name|struct
name|lportdb
modifier|*
name|lp
init|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|tgt
index|]
decl_stmt|;
if|if
condition|(
name|lp
operator|->
name|valid
condition|)
block|{
name|ptr
operator|=
literal|"arrived"
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
literal|"disappeared"
expr_stmt|;
block|}
name|printf
argument_list|(
name|fmt
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|,
name|lp
operator|->
name|loopid
argument_list|,
name|lp
operator|->
name|portid
argument_list|,
name|roles
index|[
name|lp
operator|->
name|roles
operator|&
literal|0x3
index|]
argument_list|,
name|ptr
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|lp
operator|->
name|port_wwn
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|lp
operator|->
name|port_wwn
operator|&
literal|0xffffffffLL
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|lp
operator|->
name|node_wwn
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|lp
operator|->
name|node_wwn
operator|&
literal|0xffffffffLL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|ISP2100_FABRIC
case|case
name|ISPASYNC_CHANGE_NOTIFY
case|:
name|printf
argument_list|(
literal|"%s: Name Server Database Changed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPASYNC_FABRIC_DEV
case|:
block|{
name|int
name|target
decl_stmt|;
name|struct
name|lportdb
modifier|*
name|lp
decl_stmt|;
name|sns_scrsp_t
modifier|*
name|resp
init|=
operator|(
name|sns_scrsp_t
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int32_t
name|portid
decl_stmt|;
name|u_int64_t
name|wwn
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|portid
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|0
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|2
index|]
operator|)
operator|)
expr_stmt|;
name|wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|resp
operator|->
name|snscb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Fabric Device (Type 0x%x)@PortID 0x%x WWN "
literal|"0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|resp
operator|->
name|snscb_port_type
argument_list|,
name|portid
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|wwn
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|wwn
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|snscb_port_type
operator|!=
literal|2
condition|)
break|break;
for|for
control|(
name|target
operator|=
name|FC_SNS_ID
operator|+
literal|1
init|;
name|target
operator|<
name|MAX_FC_TARG
condition|;
name|target
operator|++
control|)
block|{
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|port_wwn
operator|==
name|wwn
condition|)
break|break;
block|}
if|if
condition|(
name|target
operator|<
name|MAX_FC_TARG
condition|)
block|{
break|break;
block|}
for|for
control|(
name|target
operator|=
name|FC_SNS_ID
operator|+
literal|1
init|;
name|target
operator|<
name|MAX_FC_TARG
condition|;
name|target
operator|++
control|)
block|{
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|port_wwn
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|target
operator|==
name|MAX_FC_TARG
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no more space for fabric devices\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lp
operator|->
name|port_wwn
operator|=
name|lp
operator|->
name|node_wwn
operator|=
name|wwn
expr_stmt|;
name|lp
operator|->
name|portid
operator|=
name|portid
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

