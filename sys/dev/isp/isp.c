begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Machine and OS Independent (well, as best as possible)  * code for the Qlogic ISP SCSI adapters.  *  * Copyright (c) 1997, 1998, 1999, 2000, 2001 by Matthew Jacob  * Feral Software  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Inspiration and ideas about this driver are from Erik Moe's Linux driver  * (qlogicisp.c) and Dave Miller's SBus version of same (qlogicisp.c). Some  * ideas dredged from the Solaris driver.  */
end_comment

begin_comment
comment|/*  * Include header file appropriate for platform we're building on.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/isp_netbsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/isp/isp_freebsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/isp_openbsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|"isp_linux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__svr4__
end_ifdef

begin_include
include|#
directive|include
file|"isp_solaris.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * General defines  */
end_comment

begin_define
define|#
directive|define
name|MBOX_DELAY_COUNT
value|1000000 / 100
end_define

begin_comment
comment|/*  * Local static data  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|portshift
index|[]
init|=
literal|"Target %d Loop ID 0x%x (Port 0x%x) => Loop 0x%x (Port 0x%x)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|portdup
index|[]
init|=
literal|"Target %d duplicates Target %d- killing off both"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|retained
index|[]
init|=
literal|"Retaining Loop ID 0x%x for Target %d (Port 0x%x)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|lretained
index|[]
init|=
literal|"Retained login of Target %d (Loop ID 0x%x) Port 0x%x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|plogout
index|[]
init|=
literal|"Logging out Target %d at Loop ID 0x%x (Port 0x%x)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|plogierr
index|[]
init|=
literal|"Command Error in PLOGI for Port 0x%x (0x%x)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|nopdb
index|[]
init|=
literal|"Could not get PDB for Device @ Port 0x%x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pdbmfail1
index|[]
init|=
literal|"PDB Loop ID info for Device @ Port 0x%x does not match up (0x%x)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pdbmfail2
index|[]
init|=
literal|"PDB Port info for Device @ Port 0x%x does not match up (0x%x)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|ldumped
index|[]
init|=
literal|"Target %d (Loop ID 0x%x) Port 0x%x dumped after login info mismatch"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|notresp
index|[]
init|=
literal|"Not RESPONSE in RESPONSE Queue (type 0x%x) @ idx %d (next %d) nlooked %d"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|xact1
index|[]
init|=
literal|"HBA attempted queued transaction with disconnect not set for %d.%d.%d"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|xact2
index|[]
init|=
literal|"HBA attempted queued transaction to target routine %d on target %d bus %d"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|xact3
index|[]
init|=
literal|"HBA attempted queued cmd for %d.%d.%d when queueing disabled"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pskip
index|[]
init|=
literal|"SCSI phase skipped for target %d.%d.%d"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|topology
index|[]
init|=
literal|"Loop ID %d, AL_PA 0x%x, Port ID 0x%x, Loop State 0x%x, Topology '%s'"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|swrej
index|[]
init|=
literal|"Fabric Nameserver rejected %s (Reason=0x%x Expl=0x%x) for Port ID 0x%x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|finmsg
index|[]
init|=
literal|"(%d.%d.%d): FIN dl%d resid %d STS 0x%x SKEY %c XS_ERR=0x%x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sc0
index|[]
init|=
literal|"%s CHAN %d FTHRSH %d IID %d RESETD %d RETRYC %d RETRYD %d ASD 0x%x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sc1
index|[]
init|=
literal|"%s RAAN 0x%x DLAN 0x%x DDMAB 0x%x CDMAB 0x%x SELTIME %d MQD %d"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sc2
index|[]
init|=
literal|"%s CHAN %d TGT %d FLAGS 0x%x 0x%x/0x%x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sc3
index|[]
init|=
literal|"Generated"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sc4
index|[]
init|=
literal|"NVRAM"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|bun
index|[]
init|=
literal|"bad underrun for %d.%d (count %d, resid %d, status %s)"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|int
name|isp_parse_async
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_handle_other_response
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|isphdr_t
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_parse_status
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|ispstatusreq_t
modifier|*
parameter_list|,
name|XS_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_fastpost_complete
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_mbox_continue
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_scsi_init
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_scsi_channel_init
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_fibre_init
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_mark_getpdb_all
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_getmap
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|fcpos_map_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_getpdb
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|isp_pdb_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int64_t
name|isp_get_portname
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_fclink_test
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|isp2100_fw_statename
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_pdb_sync
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_scan_loop
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_fabric_mbox_cmd
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|mbreg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_scan_fabric
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_register_fc4_type
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_fw_state
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_mboxcmd_qnw
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|mbreg_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_mboxcmd
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|mbreg_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_update
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_update_bus
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_setdfltparm
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_read_nvram
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_rdnvram_word
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_parse_nvram_1020
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_parse_nvram_1080
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_parse_nvram_12160
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp_parse_nvram_2100
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Reset Hardware.  *  * Hit the chip over the head, download new f/w if available and set it running.  *  * Locking done elsewhere.  */
end_comment

begin_function
name|void
name|isp_reset
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|u_int16_t
name|code_org
decl_stmt|;
name|int
name|loops
decl_stmt|,
name|i
decl_stmt|,
name|dodnld
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|btype
init|=
literal|"????"
decl_stmt|;
name|isp
operator|->
name|isp_state
operator|=
name|ISP_NILSTATE
expr_stmt|;
comment|/* 	 * Basic types (SCSI, FibreChannel and PCI or SBus) 	 * have been set in the MD code. We figure out more 	 * here. Possibly more refined types based upon PCI 	 * identification. Chip revision has been gathered. 	 * 	 * After we've fired this chip up, zero out the conf1 register 	 * for SCSI adapters and do other settings for the 2100. 	 */
comment|/* 	 * Get the current running firmware revision out of the 	 * chip before we hit it over the head (if this is our 	 * first time through). Note that we store this as the 	 * 'ROM' firmware revision- which it may not be. In any 	 * case, we don't really use this yet, but we may in 	 * the future. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_touched
operator|==
literal|0
condition|)
block|{
comment|/* 		 * First see whether or not we're sitting in the ISP PROM. 		 * If we've just been reset, we'll have the string "ISP   " 		 * spread through outgoing mailbox registers 1-3. We do 		 * this for PCI cards because otherwise we really don't 		 * know what state the card is in and we could hang if 		 * we try this command otherwise. 		 * 		 * For SBus cards, we just do this because they almost 		 * certainly will be running firmware by now. 		 */
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
operator|!=
literal|0x4953
operator|||
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
operator|!=
literal|0x5020
operator|||
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX3
argument_list|)
operator|!=
literal|0x2020
condition|)
block|{
comment|/* 			 * Just in case it was paused... 			 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABOUT_FIRMWARE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
expr_stmt|;
block|}
block|}
name|isp
operator|->
name|isp_touched
operator|=
literal|1
expr_stmt|;
block|}
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Set up default request/response queue in-pointer/out-pointer 	 * register indices. 	 */
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp
operator|->
name|isp_rqstinrp
operator|=
name|BIU_REQINP
expr_stmt|;
name|isp
operator|->
name|isp_rqstoutrp
operator|=
name|BIU_REQOUTP
expr_stmt|;
name|isp
operator|->
name|isp_respinrp
operator|=
name|BIU_RSPINP
expr_stmt|;
name|isp
operator|->
name|isp_respoutrp
operator|=
name|BIU_RSPOUTP
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_rqstinrp
operator|=
name|INMAILBOX4
expr_stmt|;
name|isp
operator|->
name|isp_rqstoutrp
operator|=
name|OUTMAILBOX4
expr_stmt|;
name|isp
operator|->
name|isp_respinrp
operator|=
name|OUTMAILBOX5
expr_stmt|;
name|isp
operator|->
name|isp_respoutrp
operator|=
name|INMAILBOX5
expr_stmt|;
block|}
comment|/* 	 * Put the board into PAUSE mode (so we can read the SXP registers 	 * or write FPM/FBM registers). 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|isp
operator|->
name|isp_type
condition|)
block|{
case|case
name|ISP_HA_FC_2100
case|:
name|btype
operator|=
literal|"2100"
expr_stmt|;
break|break;
case|case
name|ISP_HA_FC_2200
case|:
name|btype
operator|=
literal|"2200"
expr_stmt|;
break|break;
case|case
name|ISP_HA_FC_2300
case|:
name|btype
operator|=
literal|"2300"
expr_stmt|;
break|break;
case|case
name|ISP_HA_FC_2312
case|:
name|btype
operator|=
literal|"2312"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 		 * While we're paused, reset the FPM module and FBM fifos. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_FPM0_REGS
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|FPM_DIAG_CONFIG
argument_list|,
name|FPM_SOFT_RESET
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_FB_REGS
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|FBM_CMD
argument_list|,
name|FBMCMD_FIFO_RESET_ALL
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_RISC_REGS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1240
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|btype
operator|=
literal|"1240"
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
name|sdp
operator|++
expr_stmt|;
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
comment|/* 		 * XXX: Should probably do some bus sensing. 		 */
block|}
elseif|else
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
condition|)
block|{
specifier|static
specifier|const
name|char
name|m
index|[]
init|=
literal|"bus %d is in %s Mode"
decl_stmt|;
name|u_int16_t
name|l
decl_stmt|;
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|IS_1280
argument_list|(
name|isp
argument_list|)
condition|)
name|btype
operator|=
literal|"1280"
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|)
name|btype
operator|=
literal|"1080"
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_10160
argument_list|(
name|isp
argument_list|)
condition|)
name|btype
operator|=
literal|"10160"
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_12160
argument_list|(
name|isp
argument_list|)
condition|)
name|btype
operator|=
literal|"12160"
expr_stmt|;
else|else
name|btype
operator|=
literal|"<UNKLVD>"
expr_stmt|;
name|l
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_DIFF
argument_list|)
operator|&
name|ISP1080_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|l
condition|)
block|{
case|case
name|ISP1080_LVD_MODE
case|:
name|sdp
operator|->
name|isp_lvdmode
operator|=
literal|1
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
literal|"LVD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP1080_HVD_MODE
case|:
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
literal|"Differential"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP1080_SE_MODE
case|:
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
literal|"Single-Ended"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"unknown mode on bus %d (0x%x)"
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_DUALBUS
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdp
operator|++
expr_stmt|;
name|l
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_DIFF
operator||
name|SXP_BANK1_SELECT
argument_list|)
expr_stmt|;
name|l
operator|&=
name|ISP1080_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|l
condition|)
block|{
case|case
name|ISP1080_LVD_MODE
case|:
name|sdp
operator|->
name|isp_lvdmode
operator|=
literal|1
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
literal|"LVD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP1080_HVD_MODE
case|:
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
literal|"Differential"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP1080_SE_MODE
case|:
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
literal|"Single-Ended"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"unknown mode on bus %d (0x%x)"
argument_list|,
literal|1
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|i
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_CONF0
argument_list|)
operator|&
name|BIU_CONF0_HW_MASK
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGALL
argument_list|,
literal|"Unknown Chip Type 0x%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|btype
operator|=
literal|"1020"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1020
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * Some 1020A chips are Ultra Capable, but don't 			 * run the clock rate up for that unless told to 			 * do so by the Ultra Capable bits being set. 			 */
name|btype
operator|=
literal|"1020A"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1020A
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|btype
operator|=
literal|"1040"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|btype
operator|=
literal|"1040A"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040A
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|btype
operator|=
literal|"1040B"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040B
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|btype
operator|=
literal|"1040C"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040C
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
block|}
comment|/* 		 * Now, while we're at it, gather info about ultra 		 * and/or differential mode. 		 */
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_DIFF
argument_list|)
operator|&
name|SXP_PINS_DIFF_MODE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"Differential Mode"
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|RISC_PSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|==
name|ISP_BT_SBUS
condition|)
block|{
name|i
operator|&=
name|RISC_PSR_SBUS_ULTRA
expr_stmt|;
block|}
else|else
block|{
name|i
operator|&=
name|RISC_PSR_PCI_ULTRA
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"Ultra Mode Capable"
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If we're in Ultra Mode, we have to be 60MHz clock- 			 * even for the SBus version. 			 */
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Clock is known. Gronk. 			 */
block|}
comment|/* 		 * Machine dependent clock (if set) overrides 		 * our generic determinations. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
operator|<
name|isp
operator|->
name|isp_clock
condition|)
block|{
name|isp
operator|->
name|isp_clock
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Clear instrumentation 	 */
name|isp
operator|->
name|isp_intcnt
operator|=
name|isp
operator|->
name|isp_intbogus
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Do MD specific pre initialization 	 */
name|ISP_RESET0
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* 	 * Hit the chip over the head with hammer, 	 * and give the ISP a chance to recover. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|,
name|BIU_ICR_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 		 * A slight delay... 		 */
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Clear data&& control DMA engines. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|CDMA_CONTROL
argument_list|,
name|DMA_CNTRL_CLEAR_CHAN
operator||
name|DMA_CNTRL_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|DDMA_CONTROL
argument_list|,
name|DMA_CNTRL_CLEAR_CHAN
operator||
name|DMA_CNTRL_RESET_INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 		 * A slight delay... 		 */
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Clear data&& control DMA engines. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|CDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|TDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for ISP to be ready to go... 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|)
operator|&
name|BIU_ICR_SOFT_RESET
operator|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
operator|&
name|BIU2100_SOFT_RESET
operator|)
condition|)
break|break;
block|}
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|ISP_DUMPREGS
argument_list|(
name|isp
argument_list|,
literal|"chip reset timed out"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * After we've fired this chip up, zero out the conf1 register 	 * for SCSI adapters and other settings for the 2100. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset RISC Processor 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RESET
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Clear semaphore register (just to be sure) */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Establish some initial burst rate stuff. 	 * (only for the 1XX0 boards). This really should 	 * be done later after fetching from NVRAM. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|u_int16_t
name|tmp
init|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_conf1
decl_stmt|;
comment|/* 		 * Busted FIFO. Turn off all but burst enables. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|==
name|ISP_HA_SCSI_1040A
condition|)
block|{
name|tmp
operator|&=
name|BIU_BURST_ENABLE
expr_stmt|;
block|}
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|BIU_BURST_ENABLE
condition|)
block|{
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|CDMA_CONF
argument_list|,
name|DMA_ENABLE_BURST
argument_list|)
expr_stmt|;
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|DDMA_CONF
argument_list|,
name|DMA_ENABLE_BURST
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PTI_CARDS
if|if
condition|(
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
condition|)
block|{
while|while
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|)
operator|!=
literal|0x1313
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1313
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_STEP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * PTI specific register 		 */
name|ISP_WRITE
argument_list|(
argument|isp
argument_list|,
argument|RISC_EMB
argument_list|,
argument|DUAL_BANK
argument_list|)
else|#
directive|else
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR2100
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_2200
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_2X00_DISABLE_PARITY_PAUSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
comment|/* release paused processor */
comment|/* 	 * Do MD specific post initialization 	 */
name|ISP_RESET1
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for everything to finish firing up. 	 * 	 * Avoid doing this on the 2312 because you can generate a PCI 	 * parity error (chip breakage). 	 */
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|USEC_DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|==
name|MBOX_BUSY
condition|)
block|{
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"MBOX_BUSY never cleared on reset"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 	 * Up until this point we've done everything by just reading or 	 * setting registers. From this point on we rely on at least *some* 	 * kind of firmware running in the card. 	 */
comment|/* 	 * Do some sanity checking. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_NO_OP
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_MAILBOX_REG_TEST
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0xdead
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0xbeef
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0x1111
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0xa5a5
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0xdead
operator|||
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|!=
literal|0xbeef
operator|||
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|!=
literal|0xffff
operator|||
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|!=
literal|0x1111
operator|||
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|!=
literal|0xa5a5
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Register Test Failed (0x%x 0x%x 0x%x 0x%x 0x%x)"
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|4
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Download new Firmware, unless requested not to do so. 	 * This is made slightly trickier in some cases where the 	 * firmware of the ROM revision is newer than the revision 	 * compiled into the driver. So, where we used to compare 	 * versions of our f/w and the ROM f/w, now we just see 	 * whether we have f/w at all and whether a config flag 	 * has disabled our download. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_ispfw
operator|==
name|NULL
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NORELOAD
operator|)
condition|)
block|{
name|dodnld
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
name|code_org
operator|=
name|ISP_CODE_ORG_2300
expr_stmt|;
else|else
name|code_org
operator|=
name|ISP_CODE_ORG
expr_stmt|;
if|if
condition|(
name|dodnld
condition|)
block|{
name|isp
operator|->
name|isp_mbxworkp
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_ispfw
index|[
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_mbxwrk0
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_ispfw
index|[
literal|3
index|]
operator|-
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_mbxwrk1
operator|=
name|code_org
operator|+
literal|1
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_WRITE_RAM_WORD
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|code_org
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_ispfw
index|[
literal|0
index|]
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"F/W download failed at word %d"
argument_list|,
name|isp
operator|->
name|isp_mbxwrk1
operator|-
name|code_org
argument_list|)
expr_stmt|;
name|dodnld
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 		 * Verify that it downloaded correctly. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_VERIFY_CHECKSUM
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|code_org
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Ram Checksum Failure"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_loaded_fw
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_loaded_fw
operator|=
literal|0
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG2
argument_list|,
literal|"skipping f/w download"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now start it rolling. 	 * 	 * If we didn't actually download f/w, 	 * we still need to (re)start it. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_EXEC_FIRMWARE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|code_org
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
comment|/* 	 * Give it a chance to start. 	 */
name|USEC_DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
comment|/* 		 * Set CLOCK RATE, but only if asked to. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_clock
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_CLOCK_RATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_clock
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
comment|/* we will try not to care if this fails */
block|}
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABOUT_FIRMWARE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
comment|/* 	 * The SBus firmware that we are using apparently does not return 	 * major, minor, micro revisions in the mailbox registers, which 	 * is really, really, annoying. 	 */
if|if
condition|(
name|ISP_SBUS_SUPPORTED
operator|&&
name|isp
operator|->
name|isp_bustype
operator|==
name|ISP_BT_SBUS
condition|)
block|{
if|if
condition|(
name|dodnld
condition|)
block|{
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp
operator|->
name|isp_fwrev
index|[
literal|0
index|]
operator|=
literal|7
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
index|[
literal|1
index|]
operator|=
literal|55
expr_stmt|;
else|#
directive|else
name|isp
operator|->
name|isp_fwrev
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
index|[
literal|1
index|]
operator|=
literal|37
expr_stmt|;
endif|#
directive|endif
name|isp
operator|->
name|isp_fwrev
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|isp
operator|->
name|isp_fwrev
index|[
literal|0
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
index|[
literal|1
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
index|[
literal|2
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
expr_stmt|;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"Board Type %s, Chip Revision 0x%x, %s F/W Revision %d.%d.%d"
argument_list|,
name|btype
argument_list|,
name|isp
operator|->
name|isp_revision
argument_list|,
name|dodnld
condition|?
literal|"loaded"
else|:
literal|"resident"
argument_list|,
name|isp
operator|->
name|isp_fwrev
index|[
literal|0
index|]
argument_list|,
name|isp
operator|->
name|isp_fwrev
index|[
literal|1
index|]
argument_list|,
name|isp
operator|->
name|isp_fwrev
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
comment|/* 		 * We do not believe firmware attributes for 2100 code less 		 * than 1.17.0, unless it's the firmware we specifically 		 * are loading. 		 * 		 * Note that all 22XX and 23XX f/w is greater than 1.X.0. 		 */
if|if
condition|(
operator|!
operator|(
name|ISP_FW_NEWER_THAN
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|,
literal|17
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_SMALLER_2100_FIRMWARE
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwattr
operator|=
name|ISP_FW_ATTR_SCCLUN
expr_stmt|;
else|#
directive|else
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwattr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwattr
operator|=
name|mbs
operator|.
name|param
index|[
literal|6
index|]
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"Firmware Attributes = 0x%x"
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
operator|&
name|BIU2100_PCI64
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"Installed in 64-Bit PCI slot"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
operator|||
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
operator|||
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"Last F/W revision was %d.%d.%d"
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FIRMWARE_STATUS
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
name|isp
operator|->
name|isp_maxcmds
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"%d max I/O commands supported"
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|isp_fw_state
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Set up DMA for the request and result mailboxes. 	 */
if|if
condition|(
name|ISP_MBOXDMASETUP
argument_list|(
name|isp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Cannot setup DMA"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RESETSTATE
expr_stmt|;
comment|/* 	 * Okay- now that we have new firmware running, we now (re)set our 	 * notion of how many luns we support. This is somewhat tricky because 	 * if we haven't loaded firmware, we sometimes do not have an easy way 	 * of knowing how many luns we support. 	 * 	 * Expanded lun firmware gives you 32 luns for SCSI cards and 	 * 16384 luns for Fibre Channel cards. 	 * 	 * It turns out that even for QLogic 2100s with ROM 1.10 and above 	 * we do get a firmware attributes word returned in mailbox register 6. 	 * 	 * Because the lun is in a different position in the Request Queue 	 * Entry structure for Fibre Channel with expanded lun firmware, we 	 * can only support one lun (lun zero) when we don't know what kind 	 * of firmware we're running. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dodnld
condition|)
block|{
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_ULTRA3
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp
operator|->
name|isp_maxluns
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_maxluns
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|isp
operator|->
name|isp_maxluns
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwattr
operator|&
name|ISP_FW_ATTR_SCCLUN
condition|)
block|{
name|isp
operator|->
name|isp_maxluns
operator|=
literal|16384
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_maxluns
operator|=
literal|16
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize Parameters of Hardware to a known state.  *  * Locks are held before coming here.  */
end_comment

begin_function
name|void
name|isp_init
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
comment|/* 	 * Must do this first to get defaults established. 	 */
name|isp_setdfltparm
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DUALBUS
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_setdfltparm
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_fibre_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isp_scsi_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_scsi_init
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|sdparam
modifier|*
name|sdp_chan0
decl_stmt|,
modifier|*
name|sdp_chan1
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdp_chan0
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
name|sdp_chan1
operator|=
name|sdp_chan0
expr_stmt|;
if|if
condition|(
name|IS_DUALBUS
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdp_chan1
operator|++
expr_stmt|;
block|}
comment|/* 	 * If we have no role (neither target nor initiator), return. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_role
operator|==
name|ISP_ROLE_NONE
condition|)
block|{
return|return;
block|}
comment|/* First do overall per-card settings. */
comment|/* 	 * If we have fast memory timing enabled, turn it on. 	 */
if|if
condition|(
name|sdp_chan0
operator|->
name|isp_fast_mttr
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1313
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set Retry Delay and Count. 	 * You set both channels at the same time. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_RETRY_COUNT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_retry_count
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_retry_delay
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_retry_count
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_retry_delay
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
comment|/* 	 * Set ASYNC DATA SETUP time. This is very important. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_ASYNC_DATA_SETUP_TIME
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_async_data_setup
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_async_data_setup
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
comment|/* 	 * Set ACTIVE Negation State. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_ACT_NEG_STATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|sdp_chan0
operator|->
name|isp_req_ack_active_neg
operator|<<
literal|4
operator|)
operator||
operator|(
name|sdp_chan0
operator|->
name|isp_data_line_active_neg
operator|<<
literal|5
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
operator|(
name|sdp_chan1
operator|->
name|isp_req_ack_active_neg
operator|<<
literal|4
operator|)
operator||
operator|(
name|sdp_chan1
operator|->
name|isp_data_line_active_neg
operator|<<
literal|5
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"failed to set active negation state (%d,%d), (%d,%d)"
argument_list|,
name|sdp_chan0
operator|->
name|isp_req_ack_active_neg
argument_list|,
name|sdp_chan0
operator|->
name|isp_data_line_active_neg
argument_list|,
name|sdp_chan1
operator|->
name|isp_req_ack_active_neg
argument_list|,
name|sdp_chan1
operator|->
name|isp_data_line_active_neg
argument_list|)
expr_stmt|;
comment|/* 		 * But don't return. 		 */
block|}
comment|/* 	 * Set the Tag Aging limit 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TAG_AGE_LIMIT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_tag_aging
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_tag_aging
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"failed to set tag age limit (%d,%d)"
argument_list|,
name|sdp_chan0
operator|->
name|isp_tag_aging
argument_list|,
name|sdp_chan1
operator|->
name|isp_tag_aging
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set selection timeout. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_SELECT_TIMEOUT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_selection_timeout
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_selection_timeout
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
comment|/* now do per-channel settings */
name|isp_scsi_channel_init
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DUALBUS
argument_list|(
name|isp
argument_list|)
condition|)
name|isp_scsi_channel_init
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Now enable request/response queues 	 */
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_1240
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_RES_QUEUE_A64
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RESULT_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
name|isp
operator|->
name|isp_residx
operator|=
name|mbs
operator|.
name|param
index|[
literal|5
index|]
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_REQ_QUEUE_A64
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|mbs
operator|.
name|param
index|[
literal|4
index|]
expr_stmt|;
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_RES_QUEUE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RESULT_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
name|isp
operator|->
name|isp_residx
operator|=
name|mbs
operator|.
name|param
index|[
literal|5
index|]
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_REQ_QUEUE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|mbs
operator|.
name|param
index|[
literal|4
index|]
expr_stmt|;
block|}
comment|/* 	 * Turn on Fast Posting, LVD transitions 	 * 	 * Ultra2 F/W always has had fast posting (and LVD transitions) 	 * 	 * Ultra and older (i.e., SBus) cards may not. It's just safer 	 * to assume not for them. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_FW_FEATURES
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
name|FW_FEATURE_LVD_NOTIFY
expr_stmt|;
ifndef|#
directive|ifndef
name|ISP_NO_RIO
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_1240
argument_list|(
name|isp
argument_list|)
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
name|FW_FEATURE_RIO_16BIT
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|ISP_NO_FASTPOST
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_1240
argument_list|(
name|isp
argument_list|)
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
name|FW_FEATURE_FAST_POST
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|u_int16_t
name|sfeat
init|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
decl_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Enabled FW features (0x%x)"
argument_list|,
name|sfeat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Let the outer layers decide whether to issue a SCSI bus reset. 	 */
name|isp
operator|->
name|isp_state
operator|=
name|ISP_INITSTATE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_scsi_channel_init
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|sdparam
modifier|*
name|sdp
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|tgt
decl_stmt|;
name|sdp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
name|sdp
operator|+=
name|channel
expr_stmt|;
comment|/* 	 * Set (possibly new) Initiator ID. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_INIT_SCSI_ID
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|channel
operator|<<
literal|7
operator|)
operator||
name|sdp
operator|->
name|isp_initiator_id
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Initiator ID is %d on Channel %d"
argument_list|,
name|sdp
operator|->
name|isp_initiator_id
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* 	 * Set current per-target parameters to an initial safe minimum. 	 */
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|int
name|lun
decl_stmt|;
name|u_int16_t
name|sdf
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
ifndef|#
directive|ifndef
name|ISP_TARGET_MODE
name|sdf
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
expr_stmt|;
name|sdf
operator|&=
name|DPARM_SAFE_DFLT
expr_stmt|;
comment|/* 		 * It is not quite clear when this changed over so that 		 * we could force narrow and async for 1000/1020 cards, 		 * but assume that this is only the case for loaded 		 * firmware. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_loaded_fw
condition|)
block|{
name|sdf
operator||=
name|DPARM_NARROW
operator||
name|DPARM_ASYNC
expr_stmt|;
block|}
else|#
directive|else
comment|/* 		 * The !$*!)$!$)* f/w uses the same index into some 		 * internal table to decide how to respond to negotiations, 		 * so if we've said "let's be safe" for ID X, and ID X 		 * selects *us*, the negotiations will back to 'safe' 		 * (as in narrow/async). What the f/w *should* do is 		 * use the initiator id settings to decide how to respond. 		 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
operator|=
name|sdf
operator|=
name|DPARM_DEFAULT
expr_stmt|;
endif|#
directive|endif
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|channel
operator|<<
literal|15
operator|)
operator||
operator|(
name|tgt
operator|<<
literal|8
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdf
expr_stmt|;
if|if
condition|(
operator|(
name|sdf
operator|&
name|DPARM_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_period
operator|)
expr_stmt|;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"Initial Settings bus%d tgt%d flags 0x%x off 0x%x per 0x%x"
argument_list|,
name|channel
argument_list|,
name|tgt
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|sdf
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
operator|(
name|channel
operator|<<
literal|15
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdf
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
continue|continue;
block|}
block|}
comment|/* 		 * We don't update any information directly from the f/w 		 * because we need to run at least one command to cause a 		 * new state to be latched up. So, we just assume that we 		 * converge to the values we just had set. 		 * 		 * Ensure that we don't believe tagged queuing is enabled yet. 		 * It turns out that sometimes the ISP just ignores our 		 * attempts to set parameters for devices that it hasn't 		 * seen yet. 		 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_flags
operator|=
name|sdf
operator|&
operator|~
name|DPARM_TQING
expr_stmt|;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
operator|(
name|int
operator|)
name|isp
operator|->
name|isp_maxluns
condition|;
name|lun
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_DEV_QUEUE_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|channel
operator|<<
literal|15
operator|)
operator||
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
name|lun
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_max_queue_depth
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
break|break;
block|}
block|}
block|}
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
condition|)
block|{
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|channel
operator|)
expr_stmt|;
name|isp
operator|->
name|isp_update
operator||=
operator|(
literal|1
operator|<<
name|channel
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Fibre Channel specific initialization.  *  * Locks are held before coming here.  */
end_comment

begin_function
specifier|static
name|void
name|isp_fibre_init
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|fcparam
modifier|*
name|fcp
decl_stmt|;
name|isp_icb_t
name|local
decl_stmt|,
modifier|*
name|icbp
init|=
operator|&
name|local
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|loopid
decl_stmt|;
name|u_int64_t
name|nwwn
decl_stmt|,
name|pwwn
decl_stmt|;
name|fcp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
comment|/* 	 * Do this *before* initializing the firmware. 	 */
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_NIL
expr_stmt|;
comment|/* 	 * If we have no role (neither target nor initiator), return. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_role
operator|==
name|ISP_ROLE_NONE
condition|)
block|{
return|return;
block|}
name|loopid
operator|=
name|fcp
operator|->
name|isp_loopid
expr_stmt|;
name|MEMZERO
argument_list|(
name|icbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|icbp
argument_list|)
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_version
operator|=
name|ICB_VERSION1
expr_stmt|;
comment|/* 	 * Firmware Options are either retrieved from NVRAM or 	 * are patched elsewhere. We check them for sanity here 	 * and make changes based on board revision, but otherwise 	 * let others decide policy. 	 */
comment|/* 	 * If this is a 2100< revision 5, we have to turn off FAIRNESS. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_type
operator|==
name|ISP_HA_FC_2100
operator|)
operator|&&
name|isp
operator|->
name|isp_revision
operator|<
literal|5
condition|)
block|{
name|fcp
operator|->
name|isp_fwoptions
operator|&=
operator|~
name|ICBOPT_FAIRNESS
expr_stmt|;
block|}
comment|/* 	 * We have to use FULL LOGIN even though it resets the loop too much 	 * because otherwise port database entries don't get updated after 	 * a LIP- this is a known f/w bug for 2100 f/w less than 1.17.0. 	 */
if|if
condition|(
operator|!
name|ISP_FW_NEWER_THAN
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|,
literal|17
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FULL_LOGIN
expr_stmt|;
block|}
comment|/* 	 * Insist on Port Database Update Async notifications 	 */
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_PDBCHANGE_AE
expr_stmt|;
comment|/* 	 * Make sure that target role reflects into fwoptions. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_role
operator|&
name|ISP_ROLE_TARGET
condition|)
block|{
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_TGT_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|fcp
operator|->
name|isp_fwoptions
operator|&=
operator|~
name|ICBOPT_TGT_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_role
operator|&
name|ISP_ROLE_INITIATOR
condition|)
block|{
name|fcp
operator|->
name|isp_fwoptions
operator|&=
operator|~
name|ICBOPT_INI_DISABLE
expr_stmt|;
block|}
else|else
block|{
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_INI_DISABLE
expr_stmt|;
block|}
comment|/* 	 * Propagate all of this into the ICB structure. 	 */
name|icbp
operator|->
name|icb_fwoptions
operator|=
name|fcp
operator|->
name|isp_fwoptions
expr_stmt|;
name|icbp
operator|->
name|icb_maxfrmlen
operator|=
name|fcp
operator|->
name|isp_maxfrmlen
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_maxfrmlen
operator|<
name|ICB_MIN_FRMLEN
operator|||
name|icbp
operator|->
name|icb_maxfrmlen
operator|>
name|ICB_MAX_FRMLEN
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad frame length (%d) from NVRAM- using %d"
argument_list|,
name|fcp
operator|->
name|isp_maxfrmlen
argument_list|,
name|ICB_DFLT_FRMLEN
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_maxfrmlen
operator|=
name|ICB_DFLT_FRMLEN
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_maxalloc
operator|=
name|fcp
operator|->
name|isp_maxalloc
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_maxalloc
operator|<
literal|1
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad maximum allocation (%d)- using 16"
argument_list|,
name|fcp
operator|->
name|isp_maxalloc
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_maxalloc
operator|=
literal|16
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_execthrottle
operator|=
name|fcp
operator|->
name|isp_execthrottle
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_execthrottle
operator|<
literal|1
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad execution throttle of %d- using 16"
argument_list|,
name|fcp
operator|->
name|isp_execthrottle
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_execthrottle
operator|=
name|ICB_DFLT_THROTTLE
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_retry_delay
operator|=
name|fcp
operator|->
name|isp_retry_delay
expr_stmt|;
name|icbp
operator|->
name|icb_retry_count
operator|=
name|fcp
operator|->
name|isp_retry_count
expr_stmt|;
name|icbp
operator|->
name|icb_hardaddr
operator|=
name|loopid
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_hardaddr
operator|>=
literal|125
condition|)
block|{
comment|/* 		 * We end up with a Loop ID of 255 for F-Port topologies 		 */
if|if
condition|(
name|icbp
operator|->
name|icb_hardaddr
operator|!=
literal|255
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad hard address %u- resetting to zero"
argument_list|,
name|icbp
operator|->
name|icb_hardaddr
argument_list|)
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_hardaddr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Right now we just set extended options to prefer point-to-point 	 * over loop based upon some soft config options. 	 *  	 * NB: for the 2300, ICBOPT_EXTENDED is required. 	 */
if|if
condition|(
name|IS_2200
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|icbp
operator|->
name|icb_fwoptions
operator||=
name|ICBOPT_EXTENDED
expr_stmt|;
comment|/* 		 * Prefer or force Point-To-Point instead Loop? 		 */
switch|switch
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_PORT_PREF
condition|)
block|{
case|case
name|ISP_CFG_NPORT
case|:
name|icbp
operator|->
name|icb_xfwoptions
operator||=
name|ICBXOPT_PTP_2_LOOP
expr_stmt|;
break|break;
case|case
name|ISP_CFG_NPORT_ONLY
case|:
name|icbp
operator|->
name|icb_xfwoptions
operator||=
name|ICBXOPT_PTP_ONLY
expr_stmt|;
break|break;
case|case
name|ISP_CFG_LPORT_ONLY
case|:
name|icbp
operator|->
name|icb_xfwoptions
operator||=
name|ICBXOPT_LOOP_ONLY
expr_stmt|;
break|break;
default|default:
name|icbp
operator|->
name|icb_xfwoptions
operator||=
name|ICBXOPT_LOOP_2_PTP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
comment|/* 			 * QLogic recommends that FAST Posting be turned 			 * off for 23XX cards and instead allow the HBA 			 * to write response queue entries and interrupt 			 * after a delay (ZIO). 			 * 			 * If we set ZIO, it will disable fast posting, 			 * so we don't need to clear it in fwoptions. 			 * 			 * Depending on the role we're selecting, we 			 * chose fast posting or not as it still is 			 * a win for target mode. 			 */
ifndef|#
directive|ifndef
name|ISP_NO_ZIO
if|if
condition|(
name|isp
operator|->
name|isp_role
operator|==
name|ISP_ROLE_TARGET
condition|)
block|{
name|icbp
operator|->
name|icb_fwoptions
operator||=
name|ICBOPT_FAST_POST
expr_stmt|;
block|}
else|else
block|{
name|icbp
operator|->
name|icb_xfwoptions
operator||=
name|ICBXOPT_ZIO
expr_stmt|;
block|}
else|#
directive|else
name|icbp
operator|->
name|icb_fwoptions
operator||=
name|ICBOPT_FAST_POST
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 			 * Values, in 100us increments. The default 			 * is 2 (200us) if a value 0 (default) is 			 * selected. 			 */
block|icbp->icb_idelaytimer = 2;
endif|#
directive|endif
if|if
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_ONEGB
condition|)
block|{
name|icbp
operator|->
name|icb_zfwoptions
operator||=
name|ICBZOPT_RATE_ONEGB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_TWOGB
condition|)
block|{
name|icbp
operator|->
name|icb_zfwoptions
operator||=
name|ICBZOPT_RATE_TWOGB
expr_stmt|;
block|}
else|else
block|{
name|icbp
operator|->
name|icb_zfwoptions
operator||=
name|ICBZOPT_RATE_AUTO
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|ISP_NO_RIO_FC
comment|/* 	 * RIO seems to be enabled in 2100s for fw>= 1.17.0. 	 * 	 * I've had some questionable problems with RIO on 2200. 	 * More specifically, on a 2204 I had problems with RIO 	 * on a Linux system where I was dropping commands right 	 * and left. It's not clear to me what the actual problem 	 * was. 	 * 	 * 23XX Cards do not support RIO. Instead they support ZIO. 	 */
if|#
directive|if
literal|0
block|if (!IS_23XX(isp)&& ISP_FW_NEWER_THAN(isp, 1, 17, 0)) { 		icbp->icb_xfwoptions |= ICBXOPT_RIO_16BIT; 		icbp->icb_racctimer = 4; 		icbp->icb_idelaytimer = 8; 	}
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * For 22XX> 2.1.26&& 23XX, set someoptions. 	 * XXX: Probably okay for newer 2100 f/w too. 	 */
if|if
condition|(
name|ISP_FW_NEWER_THAN
argument_list|(
name|isp
argument_list|,
literal|2
argument_list|,
literal|26
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * Turn on LIP F8 async event (1) 		 * Turn on generate AE 8013 on all LIP Resets (2) 		 * Disable LIP F7 switching (8) 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_FIRMWARE_OPTIONS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0xb
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_logintime
operator|=
literal|30
expr_stmt|;
comment|/* 30 second login timeout */
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|isp
operator|->
name|isp_rqstinrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|isp
operator|->
name|isp_rqstoutrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|isp
operator|->
name|isp_respinrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|isp
operator|->
name|isp_respoutrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|nwwn
operator|=
name|ISP_NODEWWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|pwwn
operator|=
name|ISP_PORTWWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwwn
operator|&&
name|pwwn
condition|)
block|{
name|icbp
operator|->
name|icb_fwoptions
operator||=
name|ICBOPT_BOTH_WWNS
expr_stmt|;
name|MAKE_NODE_NAME_FROM_WWN
argument_list|(
name|icbp
operator|->
name|icb_nodename
argument_list|,
name|nwwn
argument_list|)
expr_stmt|;
name|MAKE_NODE_NAME_FROM_WWN
argument_list|(
name|icbp
operator|->
name|icb_portname
argument_list|,
name|pwwn
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG1
argument_list|,
literal|"Setting ICB Node 0x%08x%08x Port 0x%08x%08x"
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|nwwn
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|nwwn
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|pwwn
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|pwwn
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG1
argument_list|,
literal|"Not using any WWNs"
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_fwoptions
operator|&=
operator|~
operator|(
name|ICBOPT_BOTH_WWNS
operator||
name|ICBOPT_FULL_LOGIN
operator|)
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_rqstqlen
operator|=
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_rqstqlen
operator|<
literal|1
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad request queue length"
argument_list|)
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_rsltqlen
operator|=
name|RESULT_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_rsltqlen
operator|<
literal|1
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad result queue length"
argument_list|)
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_WD0
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_WD1
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR3247
index|]
operator|=
name|DMA_WD2
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR4863
index|]
operator|=
name|DMA_WD3
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_WD0
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_WD1
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR3247
index|]
operator|=
name|DMA_WD2
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR4863
index|]
operator|=
name|DMA_WD3
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"isp_fibre_init: fwopt 0x%x xfwopt 0x%x zfwopt 0x%x"
argument_list|,
name|icbp
operator|->
name|icb_fwoptions
argument_list|,
name|icbp
operator|->
name|icb_xfwoptions
argument_list|,
name|icbp
operator|->
name|icb_zfwoptions
argument_list|)
expr_stmt|;
name|FC_SCRATCH_ACQUIRE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_put_icb
argument_list|(
name|isp
argument_list|,
name|icbp
argument_list|,
operator|(
name|isp_icb_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
argument_list|)
expr_stmt|;
comment|/* 	 * Init the firmware 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_FIRMWARE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return;
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_residx
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Whatever happens, we're now committed to being here. 	 */
name|isp
operator|->
name|isp_state
operator|=
name|ISP_INITSTATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fibre Channel Support- get the port database for the id.  *  * Locks are held before coming here. Return 0 if success,  * else failure.  */
end_comment

begin_function
specifier|static
name|int
name|isp_getmap
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|fcpos_map_t
modifier|*
name|map
parameter_list|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FC_AL_POSITION_MAP
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 	 * Unneeded. For the 2100, except for initializing f/w, registers 	 * 4/5 have to not be written to. 	 *	mbs.param[4] = 0; 	 *	mbs.param[5] = 0; 	 * 	 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|FC_SCRATCH_ACQUIRE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
operator|&
operator|~
name|MBOX_COMMAND_PARAM_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|MEMCPY
argument_list|(
name|map
argument_list|,
name|fcp
operator|->
name|isp_scratch
argument_list|,
sizeof|sizeof
argument_list|(
name|fcpos_map_t
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|fwmap
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0
expr_stmt|;
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_mark_getpdb_all
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_FC_TARG
condition|;
name|i
operator|++
control|)
block|{
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|valid
operator|=
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|fabric_dev
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|isp_getpdb
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|id
parameter_list|,
name|isp_pdb_t
modifier|*
name|pdbp
parameter_list|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_PORT_DB
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|id
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 	 * Unneeded. For the 2100, except for initializing f/w, registers 	 * 4/5 have to not be written to. 	 *	mbs.param[4] = 0; 	 *	mbs.param[5] = 0; 	 * 	 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|FC_SCRATCH_ACQUIRE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
operator|&
operator|~
name|MBOX_COMMAND_PARAM_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_get_pdb
argument_list|(
name|isp
argument_list|,
operator|(
name|isp_pdb_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
argument_list|,
name|pdbp
argument_list|)
expr_stmt|;
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int64_t
name|isp_get_portname
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|loopid
parameter_list|,
name|int
name|nodename
parameter_list|)
block|{
name|u_int64_t
name|wwn
init|=
literal|0
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_PORT_NAME
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|loopid
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|nodename
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
literal|1
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
operator|&
operator|~
name|MBOX_COMMAND_PARAM_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|wwn
operator|=
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|>>
literal|8
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|>>
literal|8
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|>>
literal|8
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|wwn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure we have good FC link and know our Loop ID.  */
end_comment

begin_function
specifier|static
name|int
name|isp_fclink_test
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|usdelay
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|toponames
index|[]
init|=
block|{
literal|"Private Loop"
block|,
literal|"FL Port"
block|,
literal|"N-Port to N-Port"
block|,
literal|"F Port"
block|,
literal|"F Port (no FLOGI_ACC response)"
block|}
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|count
decl_stmt|,
name|check_for_fabric
decl_stmt|;
name|u_int8_t
name|lwfs
decl_stmt|;
name|fcparam
modifier|*
name|fcp
decl_stmt|;
name|struct
name|lportdb
modifier|*
name|lp
decl_stmt|;
name|isp_pdb_t
name|pdb
decl_stmt|;
name|fcp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
comment|/* 	 * XXX: Here is where we would start a 'loop dead' timeout 	 */
comment|/* 	 * Wait up to N microseconds for F/W to go to a ready state. 	 */
name|lwfs
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|usdelay
condition|)
block|{
name|u_int64_t
name|enano
decl_stmt|;
name|u_int32_t
name|wrk
decl_stmt|;
name|NANOTIME_T
name|hra
decl_stmt|,
name|hrb
decl_stmt|;
name|GET_NANOTIME
argument_list|(
operator|&
name|hra
argument_list|)
expr_stmt|;
name|isp_fw_state
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwfs
operator|!=
name|fcp
operator|->
name|isp_fwstate
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Firmware State<%s->%s>"
argument_list|,
name|isp2100_fw_statename
argument_list|(
operator|(
name|int
operator|)
name|lwfs
argument_list|)
argument_list|,
name|isp2100_fw_statename
argument_list|(
operator|(
name|int
operator|)
name|fcp
operator|->
name|isp_fwstate
argument_list|)
argument_list|)
expr_stmt|;
name|lwfs
operator|=
name|fcp
operator|->
name|isp_fwstate
expr_stmt|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|==
name|FW_READY
condition|)
block|{
break|break;
block|}
name|GET_NANOTIME
argument_list|(
operator|&
name|hrb
argument_list|)
expr_stmt|;
comment|/* 		 * Get the elapsed time in nanoseconds. 		 * Always guaranteed to be non-zero. 		 */
name|enano
operator|=
name|NANOTIME_SUB
argument_list|(
operator|&
name|hrb
argument_list|,
operator|&
name|hra
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG1
argument_list|,
literal|"usec%d: 0x%lx->0x%lx enano 0x%x%08x"
argument_list|,
name|count
argument_list|,
operator|(
name|long
operator|)
name|GET_NANOSEC
argument_list|(
operator|&
name|hra
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|GET_NANOSEC
argument_list|(
operator|&
name|hrb
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|enano
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|enano
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the elapsed time is less than 1 millisecond, 		 * delay a period of time up to that millisecond of 		 * waiting. 		 * 		 * This peculiar code is an attempt to try and avoid 		 * invoking u_int64_t math support functions for some 		 * platforms where linkage is a problem. 		 */
if|if
condition|(
name|enano
operator|<
operator|(
literal|1000
operator|*
literal|1000
operator|)
condition|)
block|{
name|count
operator|+=
literal|1000
expr_stmt|;
name|enano
operator|=
operator|(
literal|1000
operator|*
literal|1000
operator|)
operator|-
name|enano
expr_stmt|;
while|while
condition|(
name|enano
operator|>
operator|(
name|u_int64_t
operator|)
literal|4000000000U
condition|)
block|{
name|USEC_SLEEP
argument_list|(
name|isp
argument_list|,
literal|4000000
argument_list|)
expr_stmt|;
name|enano
operator|-=
operator|(
name|u_int64_t
operator|)
literal|4000000000U
expr_stmt|;
block|}
name|wrk
operator|=
name|enano
expr_stmt|;
name|wrk
operator|/=
literal|1000
expr_stmt|;
name|USEC_SLEEP
argument_list|(
name|isp
argument_list|,
name|wrk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|enano
operator|>
operator|(
name|u_int64_t
operator|)
literal|4000000000U
condition|)
block|{
name|count
operator|+=
literal|4000000
expr_stmt|;
name|enano
operator|-=
operator|(
name|u_int64_t
operator|)
literal|4000000000U
expr_stmt|;
block|}
name|wrk
operator|=
name|enano
expr_stmt|;
name|count
operator|+=
operator|(
name|wrk
operator|/
literal|1000
operator|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we haven't gone to 'ready' state, return. 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get our Loop ID (if possible). We really need to have it. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_LOOP_ID
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fcp
operator|->
name|isp_loopid
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|IS_2200
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|int
name|topo
init|=
operator|(
name|int
operator|)
name|mbs
operator|.
name|param
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|topo
operator|<
name|TOPO_NL_PORT
operator|||
name|topo
operator|>
name|TOPO_PTP_STUB
condition|)
name|topo
operator|=
name|TOPO_PTP_STUB
expr_stmt|;
name|fcp
operator|->
name|isp_topo
operator|=
name|topo
expr_stmt|;
block|}
else|else
block|{
name|fcp
operator|->
name|isp_topo
operator|=
name|TOPO_NL_PORT
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_portid
operator|=
name|fcp
operator|->
name|isp_alpa
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|&
literal|0xff
expr_stmt|;
comment|/* 	 * Check to see if we're on a fabric by trying to see if we 	 * can talk to the fabric name server. This can be a bit 	 * tricky because if we're a 2100, we should check always 	 * (in case we're connected to a server doing aliasing). 	 */
name|fcp
operator|->
name|isp_onfabric
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_2100
argument_list|(
name|isp
argument_list|)
condition|)
block|{
comment|/* 		 * Don't bother with fabric if we are using really old 		 * 2100 firmware. It's just not worth it. 		 */
if|if
condition|(
name|ISP_FW_NEWER_THAN
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|,
literal|15
argument_list|,
literal|37
argument_list|)
condition|)
block|{
name|check_for_fabric
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|check_for_fabric
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fcp
operator|->
name|isp_topo
operator|==
name|TOPO_FL_PORT
operator|||
name|fcp
operator|->
name|isp_topo
operator|==
name|TOPO_F_PORT
condition|)
block|{
name|check_for_fabric
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|check_for_fabric
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|check_for_fabric
operator|&&
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|FL_PORT_ID
argument_list|,
operator|&
name|pdb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|loopid
init|=
name|FL_PORT_ID
decl_stmt|;
if|if
condition|(
name|IS_2100
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|fcp
operator|->
name|isp_topo
operator|=
name|TOPO_FL_PORT
expr_stmt|;
block|}
if|if
condition|(
name|BITS2WORD
argument_list|(
name|pdb
operator|.
name|pdb_portid_bits
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Crock. 			 */
name|fcp
operator|->
name|isp_topo
operator|=
name|TOPO_NL_PORT
expr_stmt|;
goto|goto
name|not_on_fabric
goto|;
block|}
name|fcp
operator|->
name|isp_portid
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator||
operator|(
operator|(
name|int
operator|)
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* 		 * Save the Fabric controller's port database entry. 		 */
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|loopid
index|]
expr_stmt|;
name|lp
operator|->
name|node_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lp
operator|->
name|port_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lp
operator|->
name|roles
operator|=
operator|(
name|pdb
operator|.
name|pdb_prli_svc3
operator|&
name|SVC3_ROLE_MASK
operator|)
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
name|lp
operator|->
name|portid
operator|=
name|BITS2WORD
argument_list|(
name|pdb
operator|.
name|pdb_portid_bits
argument_list|)
expr_stmt|;
name|lp
operator|->
name|loopid
operator|=
name|pdb
operator|.
name|pdb_loopid
expr_stmt|;
name|lp
operator|->
name|loggedin
operator|=
name|lp
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|fcp
operator|->
name|isp_onfabric
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PROMENADE
argument_list|,
operator|&
name|loopid
argument_list|)
expr_stmt|;
name|isp_register_fc4_type
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|not_on_fabric
label|:
name|fcp
operator|->
name|isp_onfabric
operator|=
literal|0
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|FL_PORT_ID
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_gbspeed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_SET_DATA_RATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|MBGSD_GET_RATE
expr_stmt|;
comment|/* mbs.param[2] undefined if we're just getting rate */
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|==
name|MBGSD_TWOGB
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"2Gb link speed/s"
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_gbspeed
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
name|topology
argument_list|,
name|fcp
operator|->
name|isp_loopid
argument_list|,
name|fcp
operator|->
name|isp_alpa
argument_list|,
name|fcp
operator|->
name|isp_portid
argument_list|,
name|fcp
operator|->
name|isp_loopstate
argument_list|,
name|toponames
index|[
name|fcp
operator|->
name|isp_topo
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Announce ourselves, too. This involves synthesizing an entry. 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_iid_set
operator|==
literal|0
condition|)
block|{
name|fcp
operator|->
name|isp_iid_set
operator|=
literal|1
expr_stmt|;
name|fcp
operator|->
name|isp_iid
operator|=
name|fcp
operator|->
name|isp_loopid
expr_stmt|;
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|fcp
operator|->
name|isp_iid
index|]
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|fcp
operator|->
name|isp_iid
index|]
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_portid
operator|!=
name|lp
operator|->
name|portid
operator|||
name|fcp
operator|->
name|isp_loopid
operator|!=
name|lp
operator|->
name|loopid
operator|||
name|fcp
operator|->
name|isp_nodewwn
operator|!=
name|ISP_NODEWWN
argument_list|(
name|isp
argument_list|)
operator|||
name|fcp
operator|->
name|isp_portwwn
operator|!=
name|ISP_PORTWWN
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|lp
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|fcp
operator|->
name|isp_iid
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PROMENADE
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|lp
operator|->
name|loopid
operator|=
name|fcp
operator|->
name|isp_loopid
expr_stmt|;
name|lp
operator|->
name|portid
operator|=
name|fcp
operator|->
name|isp_portid
expr_stmt|;
name|lp
operator|->
name|node_wwn
operator|=
name|ISP_NODEWWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|lp
operator|->
name|port_wwn
operator|=
name|ISP_PORTWWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|isp
operator|->
name|isp_role
condition|)
block|{
case|case
name|ISP_ROLE_NONE
case|:
name|lp
operator|->
name|roles
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ISP_ROLE_TARGET
case|:
name|lp
operator|->
name|roles
operator|=
name|SVC3_TGT_ROLE
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
break|break;
case|case
name|ISP_ROLE_INITIATOR
case|:
name|lp
operator|->
name|roles
operator|=
name|SVC3_INI_ROLE
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
break|break;
case|case
name|ISP_ROLE_BOTH
case|:
name|lp
operator|->
name|roles
operator|=
operator|(
name|SVC3_INI_ROLE
operator||
name|SVC3_TGT_ROLE
operator|)
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
break|break;
block|}
name|lp
operator|->
name|loggedin
operator|=
name|lp
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|fcp
operator|->
name|isp_iid
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PROMENADE
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|isp2100_fw_statename
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|FW_CONFIG_WAIT
case|:
return|return
literal|"Config Wait"
return|;
case|case
name|FW_WAIT_AL_PA
case|:
return|return
literal|"Waiting for AL_PA"
return|;
case|case
name|FW_WAIT_LOGIN
case|:
return|return
literal|"Wait Login"
return|;
case|case
name|FW_READY
case|:
return|return
literal|"Ready"
return|;
case|case
name|FW_LOSS_OF_SYNC
case|:
return|return
literal|"Loss Of Sync"
return|;
case|case
name|FW_ERROR
case|:
return|return
literal|"Error"
return|;
case|case
name|FW_REINIT
case|:
return|return
literal|"Re-Init"
return|;
case|case
name|FW_NON_PART
case|:
return|return
literal|"Nonparticipating"
return|;
default|default:
return|return
literal|"?????"
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Synchronize our soft copy of the port database with what the f/w thinks  * (with a view toward possibly for a specific target....)  */
end_comment

begin_function
specifier|static
name|int
name|isp_pdb_sync
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|struct
name|lportdb
modifier|*
name|lp
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp_pdb_t
name|pdb
decl_stmt|;
name|int
name|loopid
decl_stmt|,
name|base
decl_stmt|,
name|lim
decl_stmt|;
comment|/* 	 * Make sure we're okay for doing this right now. 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_PDB_RCVD
operator|&&
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_FSCAN_DONE
operator|&&
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_LSCAN_DONE
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_topo
operator|==
name|TOPO_FL_PORT
operator|||
name|fcp
operator|->
name|isp_topo
operator|==
name|TOPO_NL_PORT
operator|||
name|fcp
operator|->
name|isp_topo
operator|==
name|TOPO_N_PORT
condition|)
block|{
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_LSCAN_DONE
condition|)
block|{
if|if
condition|(
name|isp_scan_loop
argument_list|(
name|isp
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_SYNCING_PDB
expr_stmt|;
comment|/* 	 * If we get this far, we've settled our differences with the f/w 	 * (for local loop device) and we can say that the loop state is ready. 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_topo
operator|==
name|TOPO_NL_PORT
condition|)
block|{
name|fcp
operator|->
name|loop_seen_once
operator|=
literal|1
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_READY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Find all Fabric Entities that didn't make it from one scan to the 	 * next and let the world know they went away. Scan the whole database. 	 */
for|for
control|(
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
literal|0
index|]
init|;
name|lp
operator|<
operator|&
name|fcp
operator|->
name|portdb
index|[
name|MAX_FC_TARG
index|]
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|was_fabric_dev
operator|&&
name|lp
operator|->
name|fabric_dev
operator|==
literal|0
condition|)
block|{
name|loopid
operator|=
name|lp
operator|-
name|fcp
operator|->
name|portdb
expr_stmt|;
name|lp
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
comment|/* should already be set */
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PROMENADE
argument_list|,
operator|&
name|loopid
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lp
operator|->
name|was_fabric_dev
operator|=
name|lp
operator|->
name|fabric_dev
expr_stmt|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_topo
operator|==
name|TOPO_FL_PORT
condition|)
name|base
operator|=
name|FC_SNS_ID
operator|+
literal|1
expr_stmt|;
else|else
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_topo
operator|==
name|TOPO_N_PORT
condition|)
name|lim
operator|=
literal|1
expr_stmt|;
else|else
name|lim
operator|=
name|MAX_FC_TARG
expr_stmt|;
comment|/* 	 * Now log in any fabric devices that the outer layer has 	 * left for us to see. This seems the most sane policy 	 * for the moment. 	 */
for|for
control|(
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|base
index|]
init|;
name|lp
operator|<
operator|&
name|fcp
operator|->
name|portdb
index|[
name|lim
index|]
condition|;
name|lp
operator|++
control|)
block|{
name|u_int32_t
name|portid
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|loopid
operator|=
name|lp
operator|-
name|fcp
operator|->
name|portdb
expr_stmt|;
if|if
condition|(
name|loopid
operator|>=
name|FL_PORT_ID
operator|&&
name|loopid
operator|<=
name|FC_SNS_ID
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Anything here? 		 */
if|if
condition|(
name|lp
operator|->
name|port_wwn
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Don't try to log into yourself. 		 */
if|if
condition|(
operator|(
name|portid
operator|=
name|lp
operator|->
name|portid
operator|)
operator|==
name|fcp
operator|->
name|isp_portid
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * If we'd been logged in- see if we still are and we haven't 		 * changed. If so, no need to log ourselves out, etc.. 		 * 		 * Unfortunately, our charming Qlogic f/w has decided to 		 * return a valid port database entry for a fabric device 		 * that has, in fact, gone away. And it hangs trying to 		 * log it out. 		 */
if|if
condition|(
name|lp
operator|->
name|loggedin
operator|&&
name|lp
operator|->
name|force_logout
operator|==
literal|0
operator|&&
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|lp
operator|->
name|loopid
argument_list|,
operator|&
name|pdb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|nrole
decl_stmt|;
name|u_int64_t
name|nwwnn
decl_stmt|,
name|nwwpn
decl_stmt|;
name|nwwnn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|nwwpn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|nrole
operator|=
operator|(
name|pdb
operator|.
name|pdb_prli_svc3
operator|&
name|SVC3_ROLE_MASK
operator|)
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
if|if
condition|(
name|pdb
operator|.
name|pdb_loopid
operator|==
name|lp
operator|->
name|loopid
operator|&&
name|lp
operator|->
name|portid
operator|==
operator|(
name|u_int32_t
operator|)
name|BITS2WORD
argument_list|(
name|pdb
operator|.
name|pdb_portid_bits
argument_list|)
operator|&&
name|nwwnn
operator|==
name|lp
operator|->
name|node_wwn
operator|&&
name|nwwpn
operator|==
name|lp
operator|->
name|port_wwn
operator|&&
name|lp
operator|->
name|roles
operator|==
name|nrole
operator|&&
name|lp
operator|->
name|force_logout
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|loggedin
operator|=
name|lp
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
name|lretained
argument_list|,
call|(
name|int
call|)
argument_list|(
name|lp
operator|-
name|fcp
operator|->
name|portdb
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|lp
operator|->
name|loopid
argument_list|,
name|lp
operator|->
name|portid
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SYNCING_PDB
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Force a logout if we were logged in. 		 */
if|if
condition|(
name|lp
operator|->
name|loggedin
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|force_logout
operator|||
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|lp
operator|->
name|loopid
argument_list|,
operator|&
name|pdb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_FABRIC_LOGOUT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|lp
operator|->
name|loopid
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
name|plogout
argument_list|,
call|(
name|int
call|)
argument_list|(
name|lp
operator|-
name|fcp
operator|->
name|portdb
argument_list|)
argument_list|,
name|lp
operator|->
name|loopid
argument_list|,
name|lp
operator|->
name|portid
argument_list|)
expr_stmt|;
block|}
name|lp
operator|->
name|force_logout
operator|=
name|lp
operator|->
name|loggedin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SYNCING_PDB
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 		 * And log in.... 		 */
name|loopid
operator|=
name|lp
operator|-
name|fcp
operator|->
name|portdb
expr_stmt|;
name|lp
operator|->
name|loopid
operator|=
name|FL_PORT_ID
expr_stmt|;
do|do
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_FABRIC_LOGIN
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|loopid
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|portid
operator|>>
literal|16
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|portid
operator|&
literal|0xffff
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
operator|&
operator|~
operator|(
name|MBOX_LOOP_ID_USED
operator||
name|MBOX_PORT_ID_USED
operator||
name|MBOX_COMMAND_ERROR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SYNCING_PDB
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_LOOP_ID_USED
case|:
comment|/* 				 * Try the next available loop id. 				 */
name|loopid
operator|++
expr_stmt|;
break|break;
case|case
name|MBOX_PORT_ID_USED
case|:
comment|/* 				 * This port is already logged in. 				 * Snaffle the loop id it's using if it's 				 * nonzero, otherwise we're hosed. 				 */
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|loopid
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
name|retained
argument_list|,
name|loopid
argument_list|,
call|(
name|int
call|)
argument_list|(
name|lp
operator|-
name|fcp
operator|->
name|portdb
argument_list|)
argument_list|,
name|lp
operator|->
name|portid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loopid
operator|=
name|MAX_FC_TARG
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|MBOX_COMMAND_COMPLETE
case|:
name|lp
operator|->
name|loggedin
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|loopid
operator|=
name|loopid
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_ERROR
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
name|plogierr
argument_list|,
name|portid
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MBOX_ALL_IDS_USED
case|:
comment|/* We're outta IDs */
default|default:
name|loopid
operator|=
name|MAX_FC_TARG
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|lp
operator|->
name|loopid
operator|==
name|FL_PORT_ID
operator|&&
name|loopid
operator|<
name|MAX_FC_TARG
condition|)
do|;
comment|/* 		 * If we get here and we haven't set a Loop ID, 		 * we failed to log into this device. 		 */
if|if
condition|(
name|lp
operator|->
name|loopid
operator|==
name|FL_PORT_ID
condition|)
block|{
name|lp
operator|->
name|loopid
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Make sure we can get the approriate port information. 		 */
if|if
condition|(
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|lp
operator|->
name|loopid
argument_list|,
operator|&
name|pdb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
name|nopdb
argument_list|,
name|lp
operator|->
name|portid
argument_list|)
expr_stmt|;
goto|goto
name|dump_em
goto|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SYNCING_PDB
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pdb
operator|.
name|pdb_loopid
operator|!=
name|lp
operator|->
name|loopid
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
name|pdbmfail1
argument_list|,
name|lp
operator|->
name|portid
argument_list|,
name|pdb
operator|.
name|pdb_loopid
argument_list|)
expr_stmt|;
goto|goto
name|dump_em
goto|;
block|}
if|if
condition|(
name|lp
operator|->
name|portid
operator|!=
operator|(
name|u_int32_t
operator|)
name|BITS2WORD
argument_list|(
name|pdb
operator|.
name|pdb_portid_bits
argument_list|)
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
name|pdbmfail2
argument_list|,
name|lp
operator|->
name|portid
argument_list|,
name|BITS2WORD
argument_list|(
name|pdb
operator|.
name|pdb_portid_bits
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|dump_em
goto|;
block|}
name|lp
operator|->
name|roles
operator|=
operator|(
name|pdb
operator|.
name|pdb_prli_svc3
operator|&
name|SVC3_ROLE_MASK
operator|)
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
name|lp
operator|->
name|node_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lp
operator|->
name|port_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
comment|/* 		 * Check to make sure this all makes sense. 		 */
if|if
condition|(
name|lp
operator|->
name|node_wwn
operator|&&
name|lp
operator|->
name|port_wwn
condition|)
block|{
name|lp
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|loopid
operator|=
name|lp
operator|-
name|fcp
operator|->
name|portdb
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PROMENADE
argument_list|,
operator|&
name|loopid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dump_em
label|:
name|lp
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
name|ldumped
argument_list|,
name|loopid
argument_list|,
name|lp
operator|->
name|loopid
argument_list|,
name|lp
operator|->
name|portid
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_FABRIC_LOGOUT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|lp
operator|->
name|loopid
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SYNCING_PDB
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * If we get here, we've for sure seen not only a valid loop 	 * but know what is or isn't on it, so mark this for usage 	 * in isp_start. 	 */
name|fcp
operator|->
name|loop_seen_once
operator|=
literal|1
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_READY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_scan_loop
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|struct
name|lportdb
modifier|*
name|lp
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp_pdb_t
name|pdb
decl_stmt|;
name|int
name|loopid
decl_stmt|,
name|lim
decl_stmt|,
name|hival
decl_stmt|;
switch|switch
condition|(
name|fcp
operator|->
name|isp_topo
condition|)
block|{
case|case
name|TOPO_NL_PORT
case|:
name|hival
operator|=
name|FL_PORT_ID
expr_stmt|;
break|break;
case|case
name|TOPO_N_PORT
case|:
name|hival
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TOPO_FL_PORT
case|:
name|hival
operator|=
name|FC_PORT_ID
expr_stmt|;
break|break;
default|default:
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_LSCAN_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_SCANNING_LOOP
expr_stmt|;
comment|/* 	 * make sure the temp port database is clean... 	 */
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fcp
operator|->
name|tport
argument_list|,
sizeof|sizeof
argument_list|(
name|fcp
operator|->
name|tport
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Run through the local loop ports and get port database info 	 * for each loop ID. 	 * 	 * There's a somewhat unexplained situation where the f/w passes back 	 * the wrong database entity- if that happens, just restart (up to 	 * FL_PORT_ID times). 	 */
for|for
control|(
name|lim
operator|=
name|loopid
operator|=
literal|0
init|;
name|loopid
operator|<
name|hival
condition|;
name|loopid
operator|++
control|)
block|{
name|lp
operator|=
operator|&
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
expr_stmt|;
comment|/* 		 * Don't even try for ourselves... 	 	 */
if|if
condition|(
name|loopid
operator|==
name|fcp
operator|->
name|isp_loopid
condition|)
continue|continue;
name|lp
operator|->
name|node_wwn
operator|=
name|isp_get_portname
argument_list|(
name|isp
argument_list|,
name|loopid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_SCANNING_LOOP
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|lp
operator|->
name|node_wwn
operator|==
literal|0
condition|)
continue|continue;
name|lp
operator|->
name|port_wwn
operator|=
name|isp_get_portname
argument_list|(
name|isp
argument_list|,
name|loopid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_SCANNING_LOOP
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|lp
operator|->
name|port_wwn
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|node_wwn
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Get an entry.... 		 */
if|if
condition|(
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|loopid
argument_list|,
operator|&
name|pdb
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_SCANNING_LOOP
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
continue|continue;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_SCANNING_LOOP
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * If the returned database element doesn't match what we 		 * asked for, restart the process entirely (up to a point...). 		 */
if|if
condition|(
name|pdb
operator|.
name|pdb_loopid
operator|!=
name|loopid
condition|)
block|{
name|loopid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lim
operator|++
operator|<
name|hival
condition|)
block|{
continue|continue;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"giving up on synchronizing the port database"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Save the pertinent info locally. 		 */
name|lp
operator|->
name|node_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lp
operator|->
name|port_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lp
operator|->
name|roles
operator|=
operator|(
name|pdb
operator|.
name|pdb_prli_svc3
operator|&
name|SVC3_ROLE_MASK
operator|)
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
name|lp
operator|->
name|portid
operator|=
name|BITS2WORD
argument_list|(
name|pdb
operator|.
name|pdb_portid_bits
argument_list|)
expr_stmt|;
name|lp
operator|->
name|loopid
operator|=
name|pdb
operator|.
name|pdb_loopid
expr_stmt|;
block|}
comment|/* 	 * Mark all of the permanent local loop database entries as invalid 	 * (except our own entry). 	 */
for|for
control|(
name|loopid
operator|=
literal|0
init|;
name|loopid
operator|<
name|hival
condition|;
name|loopid
operator|++
control|)
block|{
if|if
condition|(
name|loopid
operator|==
name|fcp
operator|->
name|isp_iid
condition|)
block|{
name|fcp
operator|->
name|portdb
index|[
name|loopid
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|loopid
index|]
operator|.
name|loopid
operator|=
name|fcp
operator|->
name|isp_loopid
expr_stmt|;
continue|continue;
block|}
name|fcp
operator|->
name|portdb
index|[
name|loopid
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Now merge our local copy of the port database into our saved copy. 	 * Notify the outer layers of new devices arriving. 	 */
for|for
control|(
name|loopid
operator|=
literal|0
init|;
name|loopid
operator|<
name|hival
condition|;
name|loopid
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * If we don't have a non-zero Port WWN, we're not here. 		 */
if|if
condition|(
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|port_wwn
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Skip ourselves. 		 */
if|if
condition|(
name|loopid
operator|==
name|fcp
operator|->
name|isp_iid
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * For the purposes of deciding whether this is the 		 * 'same' device or not, we only search for an identical 		 * Port WWN. Node WWNs may or may not be the same as 		 * the Port WWN, and there may be multiple different 		 * Port WWNs with the same Node WWN. It would be chaos 		 * to have multiple identical Port WWNs, so we don't 		 * allow that. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hival
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|port_wwn
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|port_wwn
operator|!=
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|port_wwn
condition|)
continue|continue;
comment|/* 			 * We found this WWN elsewhere- it's changed 			 * loopids then. We don't change it's actual 			 * position in our cached port database- we 			 * just change the actual loop ID we'd use. 			 */
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
operator|!=
name|loopid
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
name|portshift
argument_list|,
name|i
argument_list|,
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
argument_list|,
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|portid
argument_list|,
name|loopid
argument_list|,
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|portid
argument_list|)
expr_stmt|;
block|}
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|portid
operator|=
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|portid
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
operator|=
name|loopid
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|roles
operator|=
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|roles
expr_stmt|;
comment|/* 			 * Now make sure this Port WWN doesn't exist elsewhere 			 * in the port database. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|hival
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|port_wwn
operator|!=
name|fcp
operator|->
name|portdb
index|[
name|j
index|]
operator|.
name|port_wwn
condition|)
block|{
continue|continue;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
name|portdup
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 				 * Invalidate the 'old' *and* 'new' ones. 				 * This is really harsh and not quite right, 				 * but if this happens, we really don't know 				 * who is what at this point. 				 */
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|j
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * If we didn't traverse the entire port database, 		 * then we found (and remapped) an existing entry. 		 * No need to notify anyone- go for the next one. 		 */
if|if
condition|(
name|i
operator|<
name|hival
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
name|retained
argument_list|,
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
argument_list|,
name|i
argument_list|,
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|portid
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We've not found this Port WWN anywhere. It's a new entry. 		 * See if we can leave it where it is (with target == loopid). 		 */
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|loopid
index|]
operator|.
name|port_wwn
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|lim
operator|=
literal|0
init|;
name|lim
operator|<
name|hival
condition|;
name|lim
operator|++
control|)
block|{
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|lim
index|]
operator|.
name|port_wwn
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* "Cannot Happen" */
if|if
condition|(
name|lim
operator|==
name|hival
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Remap Overflow"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|lim
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|loopid
expr_stmt|;
block|}
comment|/* 		 * NB:	The actual loopid we use here is loopid- we may 		 *	in fact be at a completely different index (target). 		 */
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
operator|=
name|loopid
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|port_wwn
operator|=
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|port_wwn
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|node_wwn
operator|=
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|node_wwn
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|roles
operator|=
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|roles
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|portid
operator|=
name|fcp
operator|->
name|tport
index|[
name|loopid
index|]
operator|.
name|portid
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Tell the outside world we've arrived. 		 */
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PROMENADE
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now find all previously used targets that are now invalid and 	 * notify the outer layers that they're gone. 	 */
for|for
control|(
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
literal|0
index|]
init|;
name|lp
operator|<
operator|&
name|fcp
operator|->
name|portdb
index|[
name|hival
index|]
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|valid
operator|||
name|lp
operator|->
name|port_wwn
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Tell the outside world we've gone 		 * away and erase our pdb entry. 		 * 		 */
name|loopid
operator|=
name|lp
operator|-
name|fcp
operator|->
name|portdb
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PROMENADE
argument_list|,
operator|&
name|loopid
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_LSCAN_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_fabric_mbox_cmd
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|mbreg_t
modifier|*
name|mbp
parameter_list|)
block|{
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
name|mbp
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
if|if
condition|(
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|==
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
block|}
if|if
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_ERROR
condition|)
block|{
name|char
name|tbuf
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
switch|switch
condition|(
name|mbp
operator|->
name|param
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|1
case|:
name|m
operator|=
literal|"No Loop"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|m
operator|=
literal|"Failed to allocate IOCB buffer"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|m
operator|=
literal|"Failed to allocate XCB buffer"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|m
operator|=
literal|"timeout or transmit failed"
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|m
operator|=
literal|"no fabric loop"
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|m
operator|=
literal|"remote device not a target"
expr_stmt|;
break|break;
default|default:
name|SNPRINTF
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
name|tbuf
argument_list|,
literal|"%x"
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|m
operator|=
name|tbuf
expr_stmt|;
break|break;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"SNS Failed- %s"
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|<
name|LOOP_SCANNING_FABRIC
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISP_USE_GA_NXT
end_ifdef

begin_function
specifier|static
name|int
name|isp_scan_fabric
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|ftype
parameter_list|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|u_int32_t
name|portid
decl_stmt|,
name|first_portid
decl_stmt|,
name|last_portid
decl_stmt|;
name|int
name|hicap
decl_stmt|,
name|last_port_same
decl_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_onfabric
operator|==
literal|0
condition|)
block|{
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_FSCAN_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|FC_SCRATCH_ACQUIRE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Since Port IDs are 24 bits, we can check against having seen 	 * anything yet with this value. 	 */
name|last_port_same
operator|=
literal|0
expr_stmt|;
name|last_portid
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* not a port */
name|first_portid
operator|=
name|portid
operator|=
name|fcp
operator|->
name|isp_portid
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_SCANNING_FABRIC
expr_stmt|;
for|for
control|(
name|hicap
operator|=
literal|0
init|;
name|hicap
operator|<
name|GA_NXT_MAX
condition|;
name|hicap
operator|++
control|)
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|sns_screq_t
modifier|*
name|rq
decl_stmt|;
name|sns_ga_nxt_rsp_t
modifier|*
name|rs0
decl_stmt|,
modifier|*
name|rs1
decl_stmt|;
name|struct
name|lportdb
name|lcl
decl_stmt|;
name|u_int8_t
name|sc
index|[
name|SNS_GA_NXT_RESP_SIZE
index|]
decl_stmt|;
name|rq
operator|=
operator|(
name|sns_screq_t
operator|*
operator|)
name|sc
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rq
argument_list|,
name|SNS_GA_NXT_REQ_SIZE
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_rblen
operator|=
name|SNS_GA_NXT_RESP_SIZE
operator|>>
literal|1
expr_stmt|;
name|rq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR3247
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR4863
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_sblen
operator|=
literal|6
expr_stmt|;
name|rq
operator|->
name|snscb_data
index|[
literal|0
index|]
operator|=
name|SNS_GA_NXT
expr_stmt|;
name|rq
operator|->
name|snscb_data
index|[
literal|4
index|]
operator|=
name|portid
operator|&
literal|0xffff
expr_stmt|;
name|rq
operator|->
name|snscb_data
index|[
literal|5
index|]
operator|=
operator|(
name|portid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|isp_put_sns_request
argument_list|(
name|isp
argument_list|,
name|rq
argument_list|,
operator|(
name|sns_screq_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
argument_list|)
expr_stmt|;
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_SFORDEV
argument_list|,
literal|0
argument_list|,
name|SNS_GA_NXT_REQ_SIZE
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SEND_SNS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|SNS_GA_NXT_REQ_SIZE
operator|>>
literal|1
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 		 * Leave 4 and 5 alone 		 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp_fabric_mbox_cmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
condition|)
block|{
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|>=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
block|}
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_SFORCPU
argument_list|,
literal|0x100
argument_list|,
name|SNS_GA_NXT_RESP_SIZE
argument_list|)
expr_stmt|;
name|rs1
operator|=
operator|(
name|sns_ga_nxt_rsp_t
operator|*
operator|)
name|sc
expr_stmt|;
name|rs0
operator|=
operator|(
name|sns_ga_nxt_rsp_t
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
operator|+
literal|0x100
operator|)
expr_stmt|;
name|isp_get_ga_nxt_response
argument_list|(
name|isp
argument_list|,
name|rs0
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_response
operator|!=
name|FS_ACC
condition|)
block|{
name|int
name|level
decl_stmt|;
if|if
condition|(
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_reason
operator|==
literal|9
operator|&&
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_explanation
operator|==
literal|7
condition|)
name|level
operator|=
name|ISP_LOGDEBUG0
expr_stmt|;
else|else
name|level
operator|=
name|ISP_LOGWARN
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|level
argument_list|,
name|swrej
argument_list|,
literal|"GA_NXT"
argument_list|,
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_reason
argument_list|,
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_explanation
argument_list|,
name|portid
argument_list|)
expr_stmt|;
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_FSCAN_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|portid
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|rs1
operator|->
name|snscb_port_id
index|[
literal|0
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|rs1
operator|->
name|snscb_port_id
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|rs1
operator|->
name|snscb_port_id
index|[
literal|2
index|]
operator|)
operator|)
expr_stmt|;
comment|/* 		 * XXX: We should check to make sure that this entry 		 * XXX: supports the type(s) we are interested in. 		 */
comment|/* 		 * Okay, we now have information about a fabric object. 		 * If it is the type we're interested in, tell the outer layers 		 * about it. The outer layer needs to  know: Port ID, WWNN, 		 * WWPN, FC4 type, and port type. 		 * 		 * The lportdb structure is adequate for this. 		 */
name|MEMZERO
argument_list|(
operator|&
name|lcl
argument_list|,
sizeof|sizeof
argument_list|(
name|lcl
argument_list|)
argument_list|)
expr_stmt|;
name|lcl
operator|.
name|port_type
operator|=
name|rs1
operator|->
name|snscb_port_type
expr_stmt|;
name|lcl
operator|.
name|fc4_type
operator|=
name|ftype
expr_stmt|;
name|lcl
operator|.
name|portid
operator|=
name|portid
expr_stmt|;
name|lcl
operator|.
name|node_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_nodename
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_nodename
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_nodename
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_nodename
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_nodename
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_nodename
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_nodename
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_nodename
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lcl
operator|.
name|port_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|rs1
operator|->
name|snscb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
comment|/* 		 * Does this fabric object support the type we want? 		 * If not, skip it. 		 */
if|if
condition|(
name|rs1
operator|->
name|snscb_fc4_types
index|[
name|ftype
operator|>>
literal|5
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|ftype
operator|&
literal|0x1f
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|first_portid
operator|==
name|portid
condition|)
block|{
name|lcl
operator|.
name|last_fabric_dev
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lcl
operator|.
name|last_fabric_dev
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FABRIC_DEV
argument_list|,
operator|&
name|lcl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"PortID 0x%x doesn't support FC4 type 0x%x"
argument_list|,
name|portid
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_portid
operator|==
name|portid
condition|)
block|{
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_FSCAN_DONE
expr_stmt|;
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|portid
operator|==
name|last_portid
condition|)
block|{
if|if
condition|(
name|last_port_same
operator|++
operator|>
literal|20
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"tangled fabric database detected"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|last_port_same
operator|=
literal|0
expr_stmt|;
name|last_portid
operator|=
name|portid
expr_stmt|;
block|}
block|}
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hicap
operator|>=
name|GA_NXT_MAX
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"fabric too big (> %d)"
argument_list|,
name|GA_NXT_MAX
argument_list|)
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_FSCAN_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GIDLEN
value|((ISP2100_SCRLEN>> 1) + 16)
end_define

begin_define
define|#
directive|define
name|NGENT
value|((GIDLEN - 16)>> 2)
end_define

begin_define
define|#
directive|define
name|IGPOFF
value|(ISP2100_SCRLEN - GIDLEN)
end_define

begin_define
define|#
directive|define
name|GXOFF
value|(256)
end_define

begin_function
specifier|static
name|int
name|isp_scan_fabric
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|ftype
parameter_list|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|FCPARAM
argument_list|(
name|isp
argument_list|)
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sns_gid_ft_req_t
modifier|*
name|rq
decl_stmt|;
name|sns_gid_ft_rsp_t
modifier|*
name|rs0
decl_stmt|,
modifier|*
name|rs1
decl_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_onfabric
operator|==
literal|0
condition|)
block|{
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_FSCAN_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|FC_SCRATCH_ACQUIRE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_SCANNING_FABRIC
expr_stmt|;
name|rq
operator|=
operator|(
name|sns_gid_ft_req_t
operator|*
operator|)
name|fcp
operator|->
name|tport
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rq
argument_list|,
name|SNS_GID_FT_REQ_SIZE
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_rblen
operator|=
name|GIDLEN
operator|>>
literal|1
expr_stmt|;
name|rq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|IGPOFF
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|IGPOFF
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR3247
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|IGPOFF
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR4863
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|IGPOFF
argument_list|)
expr_stmt|;
name|rq
operator|->
name|snscb_sblen
operator|=
literal|6
expr_stmt|;
name|rq
operator|->
name|snscb_cmd
operator|=
name|SNS_GID_FT
expr_stmt|;
name|rq
operator|->
name|snscb_mword_div_2
operator|=
name|NGENT
expr_stmt|;
name|rq
operator|->
name|snscb_fc4_type
operator|=
name|ftype
expr_stmt|;
name|isp_put_gid_ft_request
argument_list|(
name|isp
argument_list|,
name|rq
argument_list|,
operator|(
name|sns_gid_ft_req_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
argument_list|)
expr_stmt|;
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_SFORDEV
argument_list|,
literal|0
argument_list|,
name|SNS_GID_FT_REQ_SIZE
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SEND_SNS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|SNS_GID_FT_REQ_SIZE
operator|>>
literal|1
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 	 * Leave 4 and 5 alone 	 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp_fabric_mbox_cmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
condition|)
block|{
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|>=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
block|}
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_SFORCPU
argument_list|,
name|IGPOFF
argument_list|,
name|GIDLEN
argument_list|)
expr_stmt|;
name|rs1
operator|=
operator|(
name|sns_gid_ft_rsp_t
operator|*
operator|)
name|fcp
operator|->
name|tport
expr_stmt|;
name|rs0
operator|=
operator|(
name|sns_gid_ft_rsp_t
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
operator|+
name|IGPOFF
operator|)
expr_stmt|;
name|isp_get_gid_ft_response
argument_list|(
name|isp
argument_list|,
name|rs0
argument_list|,
name|rs1
argument_list|,
name|NGENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_response
operator|!=
name|FS_ACC
condition|)
block|{
name|int
name|level
decl_stmt|;
if|if
condition|(
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_reason
operator|==
literal|9
operator|&&
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_explanation
operator|==
literal|7
condition|)
name|level
operator|=
name|ISP_LOGDEBUG0
expr_stmt|;
else|else
name|level
operator|=
name|ISP_LOGWARN
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|level
argument_list|,
name|swrej
argument_list|,
literal|"GID_FT"
argument_list|,
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_reason
argument_list|,
name|rs1
operator|->
name|snscb_cthdr
operator|.
name|ct_explanation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_FSCAN_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Okay, we now have a list of Port IDs for this class of device. 	 * Go through the list and for each one get the WWPN/WWNN for it 	 * and tell the outer layers about it. The outer layer needs to 	 * know: Port ID, WWNN, WWPN, FC4 type, and (possibly) port type. 	 * 	 * The lportdb structure is adequate for this. 	 */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|sns_gxn_id_req_t
name|grqbuf
decl_stmt|,
modifier|*
name|gq
init|=
operator|&
name|grqbuf
decl_stmt|;
name|sns_gxn_id_rsp_t
modifier|*
name|gs0
decl_stmt|,
name|grsbuf
decl_stmt|,
modifier|*
name|gs1
init|=
operator|&
name|grsbuf
decl_stmt|;
name|struct
name|lportdb
name|lcl
decl_stmt|;
if|#
directive|if
literal|0
block|sns_gff_id_rsp_t *fs0, ffsbuf, *fs1 =&ffsbuf;
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|lcl
argument_list|,
sizeof|sizeof
argument_list|(
name|lcl
argument_list|)
argument_list|)
expr_stmt|;
name|lcl
operator|.
name|fc4_type
operator|=
name|ftype
expr_stmt|;
name|lcl
operator|.
name|portid
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|rs1
operator|->
name|snscb_ports
index|[
name|i
index|]
operator|.
name|portid
index|[
literal|0
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|rs1
operator|->
name|snscb_ports
index|[
name|i
index|]
operator|.
name|portid
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|rs1
operator|->
name|snscb_ports
index|[
name|i
index|]
operator|.
name|portid
index|[
literal|2
index|]
operator|)
operator|)
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|gq
argument_list|,
sizeof|sizeof
argument_list|(
name|sns_gxn_id_req_t
argument_list|)
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_rblen
operator|=
name|SNS_GXN_ID_RESP_SIZE
operator|>>
literal|1
expr_stmt|;
name|gq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|GXOFF
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|GXOFF
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR3247
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|GXOFF
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR4863
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|GXOFF
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_sblen
operator|=
literal|6
expr_stmt|;
name|gq
operator|->
name|snscb_cmd
operator|=
name|SNS_GPN_ID
expr_stmt|;
name|gq
operator|->
name|snscb_portid
operator|=
name|lcl
operator|.
name|portid
expr_stmt|;
name|isp_put_gxn_id_request
argument_list|(
name|isp
argument_list|,
name|gq
argument_list|,
operator|(
name|sns_gxn_id_req_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
argument_list|)
expr_stmt|;
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_SFORDEV
argument_list|,
literal|0
argument_list|,
name|SNS_GXN_ID_REQ_SIZE
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SEND_SNS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|SNS_GXN_ID_REQ_SIZE
operator|>>
literal|1
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 		 * Leave 4 and 5 alone 		 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp_fabric_mbox_cmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
condition|)
block|{
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|>=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
block|}
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_SFORCPU
argument_list|,
name|GXOFF
argument_list|,
name|SNS_GXN_ID_RESP_SIZE
argument_list|)
expr_stmt|;
name|gs0
operator|=
operator|(
name|sns_gxn_id_rsp_t
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
operator|+
name|GXOFF
operator|)
expr_stmt|;
name|isp_get_gxn_id_response
argument_list|(
name|isp
argument_list|,
name|gs0
argument_list|,
name|gs1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs1
operator|->
name|snscb_cthdr
operator|.
name|ct_response
operator|!=
name|FS_ACC
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
name|swrej
argument_list|,
literal|"GPN_ID"
argument_list|,
name|gs1
operator|->
name|snscb_cthdr
operator|.
name|ct_reason
argument_list|,
name|gs1
operator|->
name|snscb_cthdr
operator|.
name|ct_explanation
argument_list|,
name|lcl
operator|.
name|portid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
continue|continue;
block|}
name|lcl
operator|.
name|port_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|gq
argument_list|,
sizeof|sizeof
argument_list|(
name|sns_gxn_id_req_t
argument_list|)
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_rblen
operator|=
name|SNS_GXN_ID_RESP_SIZE
operator|>>
literal|1
expr_stmt|;
name|gq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|GXOFF
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|GXOFF
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR3247
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|GXOFF
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR4863
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
name|GXOFF
argument_list|)
expr_stmt|;
name|gq
operator|->
name|snscb_sblen
operator|=
literal|6
expr_stmt|;
name|gq
operator|->
name|snscb_cmd
operator|=
name|SNS_GNN_ID
expr_stmt|;
name|gq
operator|->
name|snscb_portid
operator|=
name|lcl
operator|.
name|portid
expr_stmt|;
name|isp_put_gxn_id_request
argument_list|(
name|isp
argument_list|,
name|gq
argument_list|,
operator|(
name|sns_gxn_id_req_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
argument_list|)
expr_stmt|;
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_SFORDEV
argument_list|,
literal|0
argument_list|,
name|SNS_GXN_ID_REQ_SIZE
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SEND_SNS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|SNS_GXN_ID_REQ_SIZE
operator|>>
literal|1
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 		 * Leave 4 and 5 alone 		 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp_fabric_mbox_cmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
condition|)
block|{
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|>=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
block|}
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_SFORCPU
argument_list|,
name|GXOFF
argument_list|,
name|SNS_GXN_ID_RESP_SIZE
argument_list|)
expr_stmt|;
name|gs0
operator|=
operator|(
name|sns_gxn_id_rsp_t
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
operator|+
name|GXOFF
operator|)
expr_stmt|;
name|isp_get_gxn_id_response
argument_list|(
name|isp
argument_list|,
name|gs0
argument_list|,
name|gs1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs1
operator|->
name|snscb_cthdr
operator|.
name|ct_response
operator|!=
name|FS_ACC
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
name|swrej
argument_list|,
literal|"GNN_ID"
argument_list|,
name|gs1
operator|->
name|snscb_cthdr
operator|.
name|ct_reason
argument_list|,
name|gs1
operator|->
name|snscb_cthdr
operator|.
name|ct_explanation
argument_list|,
name|lcl
operator|.
name|portid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_SCANNING_FABRIC
condition|)
block|{
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
continue|continue;
block|}
name|lcl
operator|.
name|node_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gs1
operator|->
name|snscb_wwn
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
comment|/* 		 * The QLogic f/w is bouncing this with a parameter error. 		 */
if|#
directive|if
literal|0
comment|/* 		 * Try and get FC4 Features (FC-GS-3 only). 		 * We can use the sns_gxn_id_req_t for this request. 		 */
block|MEMZERO((void *) gq, sizeof (sns_gxn_id_req_t)); 		gq->snscb_rblen = SNS_GFF_ID_RESP_SIZE>> 1; 		gq->snscb_addr[RQRSP_ADDR0015] = DMA_WD0(fcp->isp_scdma+GXOFF); 		gq->snscb_addr[RQRSP_ADDR1631] = DMA_WD1(fcp->isp_scdma+GXOFF); 		gq->snscb_addr[RQRSP_ADDR3247] = DMA_WD2(fcp->isp_scdma+GXOFF); 		gq->snscb_addr[RQRSP_ADDR4863] = DMA_WD3(fcp->isp_scdma+GXOFF); 		gq->snscb_sblen = 6; 		gq->snscb_cmd = SNS_GFF_ID; 		gq->snscb_portid = lcl.portid; 		isp_put_gxn_id_request(isp, gq, 		    (sns_gxn_id_req_t *) fcp->isp_scratch); 		MEMORYBARRIER(isp, SYNC_SFORDEV, 0, SNS_GXN_ID_REQ_SIZE); 		mbs.param[0] = MBOX_SEND_SNS; 		mbs.param[1] = SNS_GXN_ID_REQ_SIZE>> 1; 		mbs.param[2] = DMA_WD1(fcp->isp_scdma); 		mbs.param[3] = DMA_WD0(fcp->isp_scdma);
comment|/* 		 * Leave 4 and 5 alone 		 */
block|mbs.param[6] = DMA_WD3(fcp->isp_scdma); 		mbs.param[7] = DMA_WD2(fcp->isp_scdma); 		if (isp_fabric_mbox_cmd(isp,&mbs)) { 			if (fcp->isp_loopstate>= LOOP_SCANNING_FABRIC) { 				fcp->isp_loopstate = LOOP_PDB_RCVD; 			} 			FC_SCRATCH_RELEASE(isp); 			return (-1); 		} 		if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) { 			FC_SCRATCH_RELEASE(isp); 			return (-1); 		} 		MEMORYBARRIER(isp, SYNC_SFORCPU, GXOFF, SNS_GFF_ID_RESP_SIZE); 		fs0 = (sns_gff_id_rsp_t *) ((u_int8_t *)fcp->isp_scratch+GXOFF); 		isp_get_gff_id_response(isp, fs0, fs1); 		if (fs1->snscb_cthdr.ct_response != FS_ACC) { 			isp_prt(isp,
comment|/* ISP_LOGDEBUG0 */
block|ISP_LOGWARN, 			    swrej, "GFF_ID", 			    fs1->snscb_cthdr.ct_reason, 			    fs1->snscb_cthdr.ct_explanation, lcl.portid); 			if (fcp->isp_loopstate != LOOP_SCANNING_FABRIC) { 				FC_SCRATCH_RELEASE(isp); 				return (-1); 			} 		} else { 			int index = (ftype>> 3); 			int bshft = (ftype& 0x7) * 4; 			int fc4_fval = 			    (fs1->snscb_fc4_features[index]>> bshft)& 0xf; 			if (fc4_fval& 0x1) { 				lcl.roles |= 				    (SVC3_INI_ROLE>> SVC3_ROLE_SHIFT); 			} 			if (fc4_fval& 0x2) { 				lcl.roles |= 				    (SVC3_TGT_ROLE>> SVC3_ROLE_SHIFT); 			} 		}
endif|#
directive|endif
comment|/* 		 * If we really want to know what kind of port type this is, 		 * we have to run another CT command. Otherwise, we'll leave 		 * it as undefined. 		 * 		lcl.port_type = 0; 		 */
if|if
condition|(
name|rs1
operator|->
name|snscb_ports
index|[
name|i
index|]
operator|.
name|control
operator|&
literal|0x80
condition|)
block|{
name|lcl
operator|.
name|last_fabric_dev
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lcl
operator|.
name|last_fabric_dev
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FABRIC_DEV
argument_list|,
operator|&
name|lcl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rs1
operator|->
name|snscb_ports
index|[
name|i
index|]
operator|.
name|control
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|i
operator|<
name|NGENT
operator|-
literal|1
condition|)
do|;
comment|/* 	 * If we're not at the last entry, our list isn't big enough. 	 */
if|if
condition|(
operator|(
name|rs1
operator|->
name|snscb_ports
index|[
name|i
index|]
operator|.
name|control
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"fabric too big for scratch area"
argument_list|)
expr_stmt|;
block|}
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_FSCAN_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|isp_register_fc4_type
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|u_int8_t
name|local
index|[
name|SNS_RFT_ID_REQ_SIZE
index|]
decl_stmt|;
name|sns_screq_t
modifier|*
name|reqp
init|=
operator|(
name|sns_screq_t
operator|*
operator|)
name|local
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
name|SNS_RFT_ID_REQ_SIZE
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|snscb_rblen
operator|=
name|SNS_RFT_ID_RESP_SIZE
operator|>>
literal|1
expr_stmt|;
name|reqp
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR3247
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR4863
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|snscb_sblen
operator|=
literal|22
expr_stmt|;
name|reqp
operator|->
name|snscb_data
index|[
literal|0
index|]
operator|=
name|SNS_RFT_ID
expr_stmt|;
name|reqp
operator|->
name|snscb_data
index|[
literal|4
index|]
operator|=
name|fcp
operator|->
name|isp_portid
operator|&
literal|0xffff
expr_stmt|;
name|reqp
operator|->
name|snscb_data
index|[
literal|5
index|]
operator|=
operator|(
name|fcp
operator|->
name|isp_portid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|reqp
operator|->
name|snscb_data
index|[
literal|6
index|]
operator|=
operator|(
literal|1
operator|<<
name|FC4_SCSI
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|reqp->snscb_data[6] |= (1<< FC4_IP);
comment|/* ISO/IEC 8802-2 LLC/SNAP */
endif|#
directive|endif
name|FC_SCRATCH_ACQUIRE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_put_sns_request
argument_list|(
name|isp
argument_list|,
name|reqp
argument_list|,
operator|(
name|sns_screq_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SEND_SNS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|SNS_RFT_ID_REQ_SIZE
operator|>>
literal|1
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_WD1
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_WD0
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 	 * Leave 4 and 5 alone 	 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|DMA_WD3
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|DMA_WD2
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
name|FC_SCRATCH_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"Register FC4 types succeeded"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start a command. Locking is assumed done in the caller.  */
end_comment

begin_function
name|int
name|isp_start
parameter_list|(
name|XS_T
modifier|*
name|xs
parameter_list|)
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|u_int16_t
name|nxti
decl_stmt|,
name|optr
decl_stmt|,
name|handle
decl_stmt|;
name|u_int8_t
name|local
index|[
name|QENTRY_LEN
index|]
decl_stmt|;
name|ispreq_t
modifier|*
name|reqp
decl_stmt|,
modifier|*
name|qep
decl_stmt|;
name|int
name|target
decl_stmt|,
name|i
decl_stmt|;
name|XS_INITERR
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|isp
operator|=
name|XS_ISP
argument_list|(
name|xs
argument_list|)
expr_stmt|;
comment|/* 	 * Check to make sure we're supporting initiator role. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_role
operator|&
name|ISP_ROLE_INITIATOR
operator|)
operator|==
literal|0
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Now make sure we're running. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Adapter not at RUNSTATE"
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Check command CDB length, etc.. We really are limited to 16 bytes 	 * for Fibre Channel, but can do up to 44 bytes in parallel SCSI, 	 * but probably only if we're running fairly new firmware (we'll 	 * let the old f/w choke on an extended command queue entry). 	 */
if|if
condition|(
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
operator|>
operator|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|?
literal|16
else|:
literal|44
operator|)
operator|||
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"unsupported cdb length (%d, CDB[0]=0x%x)"
argument_list|,
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CDBP
argument_list|(
name|xs
argument_list|)
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Check to see whether we have good firmware state still or 	 * need to refresh our port database for this target. 	 */
name|target
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|struct
name|lportdb
modifier|*
name|lp
decl_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_LOOPSTATE_IN_OUTER_LAYERS
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_READY
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
comment|/* 		 * If we're not on a Fabric, we can't have a target 		 * above FL_PORT_ID-1. 		 * 		 * If we're on a fabric and *not* connected as an F-port, 		 * we can't have a target less than FC_SNS_ID+1. This 		 * keeps us from having to sort out the difference between 		 * local public loop devices and those which we might get 		 * from a switch's database. 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_onfabric
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|target
operator|>=
name|FL_PORT_ID
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|target
operator|>=
name|FL_PORT_ID
operator|&&
name|target
operator|<=
name|FC_SNS_ID
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 			 * We used to exclude having local loop ports 			 * at the same time that we have fabric ports. 			 * That is, we used to exclude having ports 			 * at< FL_PORT_ID if we're FL-port. 			 * 			 * That's wrong. The only thing that could be 			 * dicey is if the switch you're connected to 			 * has these local loop ports appear on the 			 * fabric and we somehow attach them twice. 			 */
block|}
else|#
directive|else
comment|/* 		 * Check for f/w being in ready state. If the f/w 		 * isn't in ready state, then we don't know our 		 * loop ID and the f/w hasn't completed logging 		 * into all targets on the loop. If this is the 		 * case, then bounce the command. We pretend this is 		 * a SELECTION TIMEOUT error if we've never gone to 		 * FW_READY state at all- in this case we may not 		 * be hooked to a loop at all and we shouldn't hang 		 * the machine for this. Otherwise, defer this command 		 * until later. 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
condition|)
block|{
comment|/* 			 * Give ourselves at most a 250ms delay. 			 */
if|if
condition|(
name|isp_fclink_test
argument_list|(
name|isp
argument_list|,
literal|250000
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|loop_seen_once
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
block|}
comment|/* 		 * If we're not on a Fabric, we can't have a target 		 * above FL_PORT_ID-1. 		 * 		 * If we're on a fabric and *not* connected as an F-port, 		 * we can't have a target less than FC_SNS_ID+1. This 		 * keeps us from having to sort out the difference between 		 * local public loop devices and those which we might get 		 * from a switch's database. 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_onfabric
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|target
operator|>=
name|FL_PORT_ID
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|target
operator|>=
name|FL_PORT_ID
operator|&&
name|target
operator|<=
name|FC_SNS_ID
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_topo
operator|!=
name|TOPO_F_PORT
operator|&&
name|target
operator|<
name|FL_PORT_ID
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
comment|/* 		 * If our loop state is such that we haven't yet received 		 * a "Port Database Changed" notification (after a LIP or 		 * a Loop Reset or firmware initialization), then defer 		 * sending commands for a little while, but only if we've 		 * seen a valid loop at one point (otherwise we can get 		 * stuck at initialization time). 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_PDB_RCVD
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|loop_seen_once
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
comment|/* 		 * If we're in the middle of loop or fabric scanning 		 * or merging the port databases, retry this command later. 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|==
name|LOOP_SCANNING_FABRIC
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|==
name|LOOP_SCANNING_LOOP
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|==
name|LOOP_SYNCING_PDB
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
comment|/* 		 * If our loop state is now such that we've just now 		 * received a Port Database Change notification, then 		 * we have to go off and (re)scan the fabric. We back 		 * out and try again later if this doesn't work. 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|==
name|LOOP_PDB_RCVD
operator|&&
name|fcp
operator|->
name|isp_onfabric
condition|)
block|{
if|if
condition|(
name|isp_scan_fabric
argument_list|(
name|isp
argument_list|,
name|FC4_SCSI
argument_list|)
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_FSCAN_DONE
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
block|}
comment|/* 		 * If our loop state is now such that we've just now 		 * received a Port Database Change notification, then 		 * we have to go off and (re)synchronize our port 		 * database. 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_READY
condition|)
block|{
if|if
condition|(
name|isp_pdb_sync
argument_list|(
name|isp
argument_list|)
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
operator|||
name|fcp
operator|->
name|isp_loopstate
operator|!=
name|LOOP_READY
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
block|}
comment|/* 		 * XXX: Here's were we would cancel any loop_dead flag 		 * XXX: also cancel in dead_loop timeout that's running 		 */
endif|#
directive|endif
comment|/* 		 * Now check whether we should even think about pursuing this. 		 */
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|valid
operator|==
literal|0
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lp
operator|->
name|roles
operator|&
operator|(
name|SVC3_TGT_ROLE
operator|>>
name|SVC3_ROLE_SHIFT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG2
argument_list|,
literal|"Target %d does not have target service"
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 		 * Now turn target into what the actual Loop ID is. 		 */
name|target
operator|=
name|lp
operator|->
name|loopid
expr_stmt|;
block|}
comment|/* 	 * Next check to see if any HBA or Device 	 * parameters need to be updated. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_update
operator|!=
literal|0
condition|)
block|{
name|isp_update
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp_getrqentry
argument_list|(
name|isp
argument_list|,
operator|&
name|nxti
argument_list|,
operator|&
name|optr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|qep
argument_list|)
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"Request Queue Overflow"
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
comment|/* 	 * Now see if we need to synchronize the ISP with respect to anything. 	 * We do dual duty here (cough) for synchronizing for busses other 	 * than which we got here to send a command to. 	 */
name|reqp
operator|=
operator|(
name|ispreq_t
operator|*
operator|)
name|local
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_sendmarker
condition|)
block|{
name|u_int8_t
name|n
init|=
operator|(
name|IS_DUALBUS
argument_list|(
name|isp
argument_list|)
condition|?
literal|2
else|:
literal|1
operator|)
decl_stmt|;
comment|/* 		 * Check ports to send markers for... 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_sendmarker
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_MARKER
expr_stmt|;
name|reqp
operator|->
name|req_modifier
operator|=
name|SYNC_ALL
expr_stmt|;
name|reqp
operator|->
name|req_target
operator|=
name|i
operator|<<
literal|7
expr_stmt|;
comment|/* insert bus number */
name|isp_put_request
argument_list|(
name|isp
argument_list|,
name|reqp
argument_list|,
name|qep
argument_list|)
expr_stmt|;
name|ISP_ADD_REQUEST
argument_list|(
name|isp
argument_list|,
name|nxti
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|isp_getrqentry
argument_list|(
name|isp
argument_list|,
operator|&
name|nxti
argument_list|,
operator|&
name|optr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|qep
argument_list|)
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"Request Queue Overflow+"
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
block|}
block|}
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_T2RQS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
operator|>
literal|12
condition|)
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_CMDONLY
expr_stmt|;
else|else
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_REQUEST
expr_stmt|;
block|}
comment|/* reqp->req_header.rqs_flags = 0; */
comment|/* reqp->req_header.rqs_seqno = 0; */
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
comment|/* 		 * See comment in isp_intr 		 */
comment|/* XS_RESID(xs) = 0; */
comment|/* 		 * Fibre Channel always requires some kind of tag. 		 * The Qlogic drivers seem be happy not to use a tag, 		 * but this breaks for some devices (IBM drives). 		 */
if|if
condition|(
name|XS_TAG_P
argument_list|(
name|xs
argument_list|)
condition|)
block|{
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|reqp
operator|)
operator|->
name|req_flags
operator|=
name|XS_TAG_TYPE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If we don't know what tag to use, use HEAD OF QUEUE 			 * for Request Sense or Simple. 			 */
if|if
condition|(
name|XS_CDBP
argument_list|(
name|xs
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0x3
condition|)
comment|/* REQUEST SENSE */
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|reqp
operator|)
operator|->
name|req_flags
operator|=
name|REQFLAG_HTAG
expr_stmt|;
else|else
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|reqp
operator|)
operator|->
name|req_flags
operator|=
name|REQFLAG_STAG
expr_stmt|;
block|}
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|+=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|target
index|]
operator|.
name|actv_flags
operator|&
name|DPARM_TQING
operator|)
operator|&&
name|XS_TAG_P
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_flags
operator|=
name|XS_TAG_TYPE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
name|reqp
operator|->
name|req_target
operator|=
name|target
operator||
operator|(
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|<<
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_lun_trn
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_cdblen
operator|=
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwattr
operator|&
name|ISP_FW_ATTR_SCCLUN
condition|)
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|reqp
operator|)
operator|->
name|req_scclun
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
else|else
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|reqp
operator|)
operator|->
name|req_lun_trn
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|MEMCPY
argument_list|(
name|reqp
operator|->
name|req_cdb
argument_list|,
name|XS_CDBP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_time
operator|=
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|req_time
operator|==
literal|0
operator|&&
name|XS_TIME
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_time
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isp_save_xs
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
operator|&
name|handle
argument_list|)
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"out of xflist pointers"
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
name|reqp
operator|->
name|req_handle
operator|=
name|handle
expr_stmt|;
comment|/* 	 * Set up DMA and/or do any bus swizzling of the request entry 	 * so that the Qlogic F/W understands what is being asked of it. 	 */
name|i
operator|=
name|ISP_DMASETUP
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|reqp
argument_list|,
operator|&
name|nxti
argument_list|,
name|optr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|CMD_QUEUED
condition|)
block|{
name|isp_destroy_handle
argument_list|(
name|isp
argument_list|,
name|handle
argument_list|)
expr_stmt|;
comment|/* 		 * dmasetup sets actual error in packet, and 		 * return what we were given to return. 		 */
return|return
operator|(
name|i
operator|)
return|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG2
argument_list|,
literal|"START cmd for %d.%d.%d cmd 0x%x datalen %ld"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CDBP
argument_list|(
name|xs
argument_list|)
index|[
literal|0
index|]
argument_list|,
operator|(
name|long
operator|)
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_ADD_REQUEST
argument_list|(
name|isp
argument_list|,
name|nxti
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_nactive
operator|++
expr_stmt|;
return|return
operator|(
name|CMD_QUEUED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * isp control  * Locks (ints blocked) assumed held.  */
end_comment

begin_function
name|int
name|isp_control
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|ispctl_t
name|ctl
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|XS_T
modifier|*
name|xs
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|tgt
decl_stmt|;
name|u_int16_t
name|handle
decl_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Unknown Control Opcode 0x%x"
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPCTL_RESET_BUS
case|:
comment|/* 		 * Issue a bus reset. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_BUS_RESET
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_bus_reset_delay
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|<
literal|2
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|bus
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
if|if
condition|(
name|IS_DUALBUS
argument_list|(
name|isp
argument_list|)
condition|)
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|bus
expr_stmt|;
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|10
expr_stmt|;
name|bus
operator|=
literal|0
expr_stmt|;
block|}
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
break|break;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"driver initiated bus reset of bus %d"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_RESET_DEV
case|:
name|tgt
operator|=
operator|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|bus
operator|=
operator|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABORT_TARGET
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
operator|(
name|bus
operator|<<
literal|15
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
comment|/* 'delay', in seconds */
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
break|break;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Target %d on Bus %d Reset Succeeded"
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_ABORT_CMD
case|:
name|xs
operator|=
operator|(
name|XS_T
operator|*
operator|)
name|arg
expr_stmt|;
name|tgt
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|handle
operator|=
name|isp_find_handle
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"cannot find handle for command to abort"
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus
operator|=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABORT
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
if|if
condition|(
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwattr
operator|&
name|ISP_FW_ATTR_SCCLUN
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|bus
operator|<<
literal|15
operator|)
operator||
operator|(
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|handle
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
operator|&
operator|~
name|MBOX_COMMAND_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * XXX: Look for command in the REQUEST QUEUE. That is, 		 * XXX: It hasen't been picked up by firmware yet. 		 */
break|break;
case|case
name|ISPCTL_UPDATE_PARAMS
case|:
name|isp_update
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_FCLINK_TEST
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|int
name|usdelay
init|=
operator|(
name|arg
operator|)
condition|?
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
else|:
literal|250000
decl_stmt|;
return|return
operator|(
name|isp_fclink_test
argument_list|(
name|isp
argument_list|,
name|usdelay
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|ISPCTL_SCAN_FABRIC
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|int
name|ftype
init|=
operator|(
name|arg
operator|)
condition|?
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
else|:
name|FC4_SCSI
decl_stmt|;
return|return
operator|(
name|isp_scan_fabric
argument_list|(
name|isp
argument_list|,
name|ftype
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|ISPCTL_SCAN_LOOP
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
return|return
operator|(
name|isp_scan_loop
argument_list|(
name|isp
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|ISPCTL_PDB_SYNC
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
return|return
operator|(
name|isp_pdb_sync
argument_list|(
name|isp
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|ISPCTL_SEND_LIP
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_LIP
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
break|break;
case|case
name|ISPCTL_GET_POSMAP
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
operator|&&
name|arg
condition|)
block|{
return|return
operator|(
name|isp_getmap
argument_list|(
name|isp
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|ISPCTL_GET_PDB
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
operator|&&
name|arg
condition|)
block|{
name|int
name|id
init|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
name|isp_pdb_t
modifier|*
name|pdb
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|id
argument_list|,
name|pdb
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|ISPCTL_RUN_MBOXCMD
case|:
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
name|arg
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
case|case
name|ISPCTL_TOGGLE_TMODE
case|:
block|{
comment|/* 		 * We don't check/set against role here- that's the 		 * responsibility for the outer layer to coordinate. 		 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|int
name|param
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ENABLE_TARGET_MODE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|param
operator|&
literal|0xffff
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|param
operator|>>
literal|16
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt Service Routine(s).  *  * External (OS) framework has done the appropriate locking,  * and the locking will be held throughout this function.  */
end_comment

begin_comment
comment|/*  * Limit our stack depth by sticking with the max likely number  * of completions on a request queue at any one time.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_REQUESTQ_COMPLETIONS
end_ifndef

begin_define
define|#
directive|define
name|MAX_REQUESTQ_COMPLETIONS
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|isp_intr
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|u_int16_t
name|isr
parameter_list|,
name|u_int16_t
name|sema
parameter_list|,
name|u_int16_t
name|mbox
parameter_list|)
block|{
name|XS_T
modifier|*
name|complist
index|[
name|MAX_REQUESTQ_COMPLETIONS
index|]
decl_stmt|,
modifier|*
name|xs
decl_stmt|;
name|u_int16_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|,
name|junk
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nlooked
init|=
literal|0
decl_stmt|,
name|ndone
init|=
literal|0
decl_stmt|;
name|again
label|:
comment|/* 	 * Is this a mailbox related interrupt? 	 * The mailbox semaphore will be nonzero if so. 	 */
if|if
condition|(
name|sema
condition|)
block|{
if|if
condition|(
name|mbox
operator|&
literal|0x4000
condition|)
block|{
name|isp
operator|->
name|isp_intmboxc
operator|++
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_mboxbsy
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|obits
init|=
name|isp
operator|->
name|isp_obits
decl_stmt|;
name|isp
operator|->
name|isp_mboxtmp
index|[
name|i
operator|++
index|]
operator|=
name|mbox
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_MAILBOX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|obits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|isp
operator|->
name|isp_mboxtmp
index|[
name|i
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|MBOX_OFF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_mbxwrk0
condition|)
block|{
if|if
condition|(
name|isp_mbox_continue
argument_list|(
name|isp
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
name|MBOX_NOTIFY_COMPLETE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Mbox Command Async (0x%x) with no waiters"
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
name|mbox
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
operator|&&
name|mbox
operator|!=
name|ASYNC_RIO_RESP
operator|)
operator|||
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * We can't be getting this now. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"interrupt (ISR=%x SEMA=%x) when not ready"
argument_list|,
name|isr
argument_list|,
name|sema
argument_list|)
expr_stmt|;
comment|/* 		 * Thank you very much!  *Burrrp*! 		 */
name|WRITE_RESPONSE_QUEUE_OUT_POINTER
argument_list|(
name|isp
argument_list|,
name|READ_RESPONSE_QUEUE_IN_POINTER
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the current Response Queue Out Pointer. 	 * 	 * If we're a 2300, we can ask what hardware what it thinks. 	 */
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|optr
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|isp
operator|->
name|isp_respoutrp
argument_list|)
expr_stmt|;
comment|/* 		 * Debug: to be taken out eventually 		 */
if|if
condition|(
name|isp
operator|->
name|isp_residx
operator|!=
name|optr
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"optr %x soft optr %x"
argument_list|,
name|optr
argument_list|,
name|isp
operator|->
name|isp_residx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|optr
operator|=
name|isp
operator|->
name|isp_residx
expr_stmt|;
block|}
comment|/* 	 * You *must* read the Response Queue In Pointer 	 * prior to clearing the RISC interrupt. 	 * 	 * Debounce the 2300 if revision less than 2. 	 */
if|if
condition|(
name|IS_2100
argument_list|(
name|isp
argument_list|)
operator|||
operator|(
name|IS_2300
argument_list|(
name|isp
argument_list|)
operator|&&
name|isp
operator|->
name|isp_revision
operator|<
literal|2
operator|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|iptr
operator|=
name|READ_RESPONSE_QUEUE_IN_POINTER
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|junk
operator|=
name|READ_RESPONSE_QUEUE_IN_POINTER
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|junk
operator|!=
name|iptr
operator|&&
operator|++
name|i
operator|<
literal|1000
condition|)
do|;
if|if
condition|(
name|iptr
operator|!=
name|junk
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Response Queue Out Pointer Unstable (%x, %x)"
argument_list|,
name|iptr
argument_list|,
name|junk
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|iptr
operator|=
name|READ_RESPONSE_QUEUE_IN_POINTER
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
name|isp
operator|->
name|isp_resodx
operator|=
name|iptr
expr_stmt|;
if|if
condition|(
name|optr
operator|==
name|iptr
operator|&&
name|sema
operator|==
literal|0
condition|)
block|{
comment|/* 		 * There are a lot of these- reasons unknown- mostly on 		 * faster Alpha machines. 		 * 		 * I tried delaying after writing HCCR_CMD_CLEAR_RISC_INT to 		 * make sure the old interrupt went away (to avoid 'ringing' 		 * effects), but that didn't stop this from occurring. 		 */
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|READ_RESPONSE_QUEUE_IN_POINTER
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|junk
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_R2HSTSLO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|junk
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optr
operator|==
name|iptr
condition|)
block|{
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|sema
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
expr_stmt|;
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sema
operator|&
literal|0x3
operator|)
operator|&&
operator|(
name|mbox
operator|&
literal|0x8000
operator|)
condition|)
block|{
goto|goto
name|again
goto|;
block|}
block|}
name|isp
operator|->
name|isp_intbogus
operator|++
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG1
argument_list|,
literal|"bogus intr- isr %x (%x) iptr %x optr %x"
argument_list|,
name|isr
argument_list|,
name|junk
argument_list|,
name|iptr
argument_list|,
name|optr
argument_list|)
expr_stmt|;
block|}
block|}
name|isp
operator|->
name|isp_resodx
operator|=
name|iptr
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_rspbsy
condition|)
block|{
return|return;
block|}
name|isp
operator|->
name|isp_rspbsy
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|optr
operator|!=
name|iptr
condition|)
block|{
name|ispstatusreq_t
name|local
decl_stmt|,
modifier|*
name|sp
init|=
operator|&
name|local
decl_stmt|;
name|isphdr_t
modifier|*
name|hp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|u_int16_t
name|oop
decl_stmt|;
name|int
name|buddaboom
init|=
literal|0
decl_stmt|;
name|hp
operator|=
operator|(
name|isphdr_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_result
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|oop
operator|=
name|optr
expr_stmt|;
name|optr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|optr
argument_list|,
name|RESULT_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
name|nlooked
operator|++
expr_stmt|;
name|read_again
label|:
comment|/* 		 * Synchronize our view of this response queue entry. 		 */
name|MEMORYBARRIER
argument_list|(
name|isp
argument_list|,
name|SYNC_RESULT
argument_list|,
name|oop
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
name|type
operator|=
name|isp_get_response_type
argument_list|(
name|isp
argument_list|,
name|hp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RQSTYPE_RESPONSE
condition|)
block|{
name|isp_get_response
argument_list|(
name|isp
argument_list|,
operator|(
name|ispstatusreq_t
operator|*
operator|)
name|hp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|RQSTYPE_RIO2
condition|)
block|{
name|isp_rio2_t
name|rio
decl_stmt|;
name|isp_get_rio2
argument_list|(
name|isp
argument_list|,
operator|(
name|isp_rio2_t
operator|*
operator|)
name|hp
argument_list|,
operator|&
name|rio
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rio
operator|.
name|req_header
operator|.
name|rqs_seqno
condition|;
name|i
operator|++
control|)
block|{
name|isp_fastpost_complete
argument_list|(
name|isp
argument_list|,
name|rio
operator|.
name|req_handles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_fpcchiwater
operator|<
name|rio
operator|.
name|req_header
operator|.
name|rqs_seqno
condition|)
name|isp
operator|->
name|isp_fpcchiwater
operator|=
name|rio
operator|.
name|req_header
operator|.
name|rqs_seqno
expr_stmt|;
name|MEMZERO
argument_list|(
name|hp
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
comment|/* PERF */
continue|continue;
block|}
else|else
block|{
comment|/* 			 * Somebody reachable via isp_handle_other_response 			 * may have updated the response queue pointers for 			 * us, so we reload our goal index. 			 */
name|int
name|i
init|=
name|isp_handle_other_response
argument_list|(
name|isp
argument_list|,
name|type
argument_list|,
name|hp
argument_list|,
operator|&
name|optr
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
goto|goto
name|read_again
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|iptr
operator|=
name|isp
operator|->
name|isp_resodx
expr_stmt|;
name|MEMZERO
argument_list|(
name|hp
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
comment|/* PERF */
continue|continue;
block|}
comment|/* 			 * After this point, we'll just look at the header as 			 * we don't know how to deal with the rest of the 			 * response. 			 */
name|isp_get_response
argument_list|(
name|isp
argument_list|,
operator|(
name|ispstatusreq_t
operator|*
operator|)
name|hp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* 			 * It really has to be a bounced request just copied 			 * from the request queue to the response queue. If 			 * not, something bad has happened. 			 */
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|!=
name|RQSTYPE_REQUEST
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
name|notresp
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|,
name|oop
argument_list|,
name|optr
argument_list|,
name|nlooked
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|&
name|ISP_LOGDEBUG0
condition|)
block|{
name|isp_print_bytes
argument_list|(
name|isp
argument_list|,
literal|"Queue Entry"
argument_list|,
name|QENTRY_LEN
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|MEMZERO
argument_list|(
name|hp
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
comment|/* PERF */
continue|continue;
block|}
name|buddaboom
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
literal|0xf
condition|)
block|{
define|#
directive|define
name|_RQS_OFLAGS
define|\
value|~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_CONTINUATION
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"continuation segment"
argument_list|)
expr_stmt|;
name|WRITE_RESPONSE_QUEUE_OUT_POINTER
argument_list|(
name|isp
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_FULL
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG1
argument_list|,
literal|"internal queues full"
argument_list|)
expr_stmt|;
comment|/* 				 * We'll synthesize a QUEUE FULL message below. 				 */
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_BADHEADER
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad header flag"
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_BADPACKET
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad request packet"
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|_RQS_OFLAGS
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"unknown flags (0x%x) in response"
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
undef|#
directive|undef
name|_RQS_OFLAGS
block|}
if|if
condition|(
name|sp
operator|->
name|req_handle
operator|>
name|isp
operator|->
name|isp_maxcmds
operator|||
name|sp
operator|->
name|req_handle
operator|<
literal|1
condition|)
block|{
name|MEMZERO
argument_list|(
name|hp
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
comment|/* PERF */
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"bad request handle %d (type 0x%x, flags 0x%x)"
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
argument_list|)
expr_stmt|;
name|WRITE_RESPONSE_QUEUE_OUT_POINTER
argument_list|(
name|isp
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|xs
operator|=
name|isp_find_xs
argument_list|(
name|isp
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
name|u_int8_t
name|ts
init|=
name|sp
operator|->
name|req_completion_status
operator|&
literal|0xff
decl_stmt|;
name|MEMZERO
argument_list|(
name|hp
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
comment|/* PERF */
comment|/* 			 * Only whine if this isn't the expected fallout of 			 * aborting the command. 			 */
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|!=
name|RQSTYPE_RESPONSE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"cannot find handle 0x%x (type 0x%x)"
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ts
operator|!=
name|RQCS_ABORTED
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"cannot find handle 0x%x (status 0x%x)"
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
name|WRITE_RESPONSE_QUEUE_OUT_POINTER
argument_list|(
name|isp
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|isp_destroy_handle
argument_list|(
name|isp
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_BUS_RESET
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|buddaboom
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
operator|&&
operator|(
name|sp
operator|->
name|req_scsi_status
operator|&
name|RQCS_SV
operator|)
condition|)
block|{
comment|/* 			 * Fibre Channel F/W doesn't say we got status 			 * if there's Sense Data instead. I guess they 			 * think it goes w/o saying. 			 */
name|sp
operator|->
name|req_state_flags
operator||=
name|RQSF_GOT_STATUS
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_STATUS
condition|)
block|{
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_scsi_status
operator|&
literal|0xff
expr_stmt|;
block|}
switch|switch
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
condition|)
block|{
case|case
name|RQSTYPE_RESPONSE
case|:
name|XS_SET_STATE_STAT
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|isp_parse_status
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|,
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
operator|||
name|XS_ERR
argument_list|(
name|xs
argument_list|)
operator|==
name|HBA_NOERROR
operator|)
operator|&&
operator|(
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_BUSY
operator|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_TGTBSY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_STATUS
operator|)
operator|&&
operator|(
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
operator|)
operator|&&
operator|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
operator|)
condition|)
block|{
name|XS_SAVE_SENSE
argument_list|(
name|xs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * A new synchronous rate was negotiated for 				 * this target. Mark state such that we'll go 				 * look up that which has changed later. 				 */
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_NEGOTIATION
condition|)
block|{
name|int
name|t
init|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
decl_stmt|;
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|+=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|t
index|]
operator|.
name|dev_refresh
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_update
operator||=
operator|(
literal|1
operator|<<
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSF_XFER_COMPLETE
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|req_scsi_status
operator|&
name|RQCS_RESID
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
block|}
else|else
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_STATUS
operator|)
operator|&&
operator|(
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
operator|)
operator|&&
operator|(
name|sp
operator|->
name|req_scsi_status
operator|&
name|RQCS_SV
operator|)
condition|)
block|{
name|XS_SAVE_SENSE
argument_list|(
name|xs
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* solely for the benefit of debug */
name|sp
operator|->
name|req_state_flags
operator||=
name|RQSF_GOT_SENSE
expr_stmt|;
block|}
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG2
argument_list|,
literal|"asked for %ld got resid %ld"
argument_list|,
operator|(
name|long
operator|)
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|sp
operator|->
name|req_resid
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQSTYPE_REQUEST
case|:
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_FULL
condition|)
block|{
comment|/* 				 * Force Queue Full status. 				 */
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|=
name|SCSI_QFULL
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
comment|/* 				 * ???? 				 */
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"Request Queue Entry bounced back"
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
break|break;
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"unhandled response queue type 0x%x"
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Free any DMA resources. As a side effect, this may 		 * also do any cache flushing necessary for data coherence.			 */
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|isp
operator|->
name|isp_dblev
operator|&
operator|(
name|ISP_LOGDEBUG2
operator||
name|ISP_LOGDEBUG3
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|isp
operator|->
name|isp_dblev
operator|&
name|ISP_LOGDEBUG1
operator|)
operator|&&
operator|(
operator|(
operator|!
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|!=
name|SCSI_GOOD
operator|)
operator|)
operator|)
condition|)
block|{
name|char
name|skey
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
block|{
name|skey
operator|=
name|XS_SNSKEY
argument_list|(
name|xs
argument_list|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|skey
operator|<
literal|10
condition|)
name|skey
operator|+=
literal|'0'
expr_stmt|;
else|else
name|skey
operator|+=
literal|'a'
operator|-
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
condition|)
block|{
name|skey
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
name|skey
operator|=
literal|'.'
expr_stmt|;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGALL
argument_list|,
name|finmsg
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_RESID
argument_list|(
name|xs
argument_list|)
argument_list|,
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|skey
argument_list|,
name|XS_ERR
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_nactive
operator|>
literal|0
condition|)
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
name|complist
index|[
name|ndone
operator|++
index|]
operator|=
name|xs
expr_stmt|;
comment|/* defer completion call until later */
name|MEMZERO
argument_list|(
name|hp
argument_list|,
name|QENTRY_LEN
argument_list|)
expr_stmt|;
comment|/* PERF */
if|if
condition|(
name|ndone
operator|==
name|MAX_REQUESTQ_COMPLETIONS
condition|)
block|{
break|break;
block|}
block|}
comment|/* 	 * If we looked at any commands, then it's valid to find out 	 * what the outpointer is. It also is a trigger to update the 	 * ISP's notion of what we've seen so far. 	 */
if|if
condition|(
name|nlooked
condition|)
block|{
name|WRITE_RESPONSE_QUEUE_OUT_POINTER
argument_list|(
name|isp
argument_list|,
name|optr
argument_list|)
expr_stmt|;
comment|/* 		 * While we're at it, read the requst queue out pointer. 		 */
name|isp
operator|->
name|isp_reqodx
operator|=
name|READ_REQUEST_QUEUE_OUT_POINTER
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_rscchiwater
operator|<
name|ndone
condition|)
name|isp
operator|->
name|isp_rscchiwater
operator|=
name|ndone
expr_stmt|;
block|}
name|isp
operator|->
name|isp_residx
operator|=
name|optr
expr_stmt|;
name|isp
operator|->
name|isp_rspbsy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndone
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
name|complist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xs
condition|)
block|{
name|isp
operator|->
name|isp_rsltccmplt
operator|++
expr_stmt|;
name|isp_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Support routines.  */
end_comment

begin_function
specifier|static
name|int
name|isp_parse_async
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|u_int16_t
name|mbox
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|int
name|bus
decl_stmt|;
if|if
condition|(
name|IS_DUALBUS
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|bus
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus
operator|=
literal|0
expr_stmt|;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG2
argument_list|,
literal|"Async Mbox 0x%x"
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbox
condition|)
block|{
case|case
name|ASYNC_BUS_RESET
case|:
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|,
name|mbox
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_BUS_RESET
argument_list|,
operator|&
name|bus
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_SYSTEM_ERROR
case|:
ifdef|#
directive|ifdef
name|ISP_FW_CRASH_DUMP
comment|/* 		 * If we have crash dumps enabled, it's up to the handler 		 * for isp_async to reinit stuff and restart the firmware 		 * after performing the crash dump. The reason we do things 		 * this way is that we may need to activate a kernel thread 		 * to do all the crash dump goop. 		 */
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FW_CRASH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FW_CRASH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isp_reinit
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FW_RESTARTED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ASYNC_RQS_XFER_ERR
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Request Queue Transfer Error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_RSP_XFER_ERR
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Response Queue Transfer Error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_QWAKEUP
case|:
comment|/* 		 * We've just been notified that the Queue has woken up. 		 * We don't need to be chatty about this- just unlatch things 		 * and move on. 		 */
name|mbox
operator|=
name|READ_REQUEST_QUEUE_OUT_POINTER
argument_list|(
name|isp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_TIMEOUT_RESET
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"timeout initiated SCSI bus reset of bus %d"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|,
name|mbox
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_DEVICE_RESET
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"device reset on bus %d"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|,
name|mbox
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_EXTMSG_UNDERRUN
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"extended message underrun"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_SCAM_INT
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"SCAM interrupt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_HUNG_SCSI
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"stalled SCSI Bus after DATA Overrun"
argument_list|)
expr_stmt|;
comment|/* XXX: Need to issue SCSI reset at this point */
break|break;
case|case
name|ASYNC_KILLED_BUS
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"SCSI Bus reset after DATA Overrun"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_BUS_TRANSIT
case|:
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbox
operator|&
literal|0x1c00
condition|)
block|{
case|case
name|SXP_PINS_LVD_MODE
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Transition to LVD mode"
argument_list|)
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_lvdmode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SXP_PINS_HVD_MODE
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Transition to Differential mode"
argument_list|)
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_lvdmode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SXP_PINS_SE_MODE
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Transition to Single Ended mode"
argument_list|)
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
name|SDPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_lvdmode
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Transition to Unknown Mode 0x%x"
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * XXX: Set up to renegotiate again! 		 */
comment|/* Can only be for a 1080... */
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
break|break;
comment|/* 	 * We can use bus, which will always be zero for FC cards, 	 * as a mailbox pattern accumulator to be checked below. 	 */
case|case
name|ASYNC_RIO5
case|:
name|bus
operator|=
literal|0x1ce
expr_stmt|;
comment|/* outgoing mailbox regs 1-3, 6-7 */
break|break;
case|case
name|ASYNC_RIO4
case|:
name|bus
operator|=
literal|0x14e
expr_stmt|;
comment|/* outgoing mailbox regs 1-3, 6 */
break|break;
case|case
name|ASYNC_RIO3
case|:
name|bus
operator|=
literal|0x10e
expr_stmt|;
comment|/* outgoing mailbox regs 1-3 */
break|break;
case|case
name|ASYNC_RIO2
case|:
name|bus
operator|=
literal|0x106
expr_stmt|;
comment|/* outgoing mailbox regs 1-2 */
break|break;
case|case
name|ASYNC_RIO1
case|:
case|case
name|ASYNC_CMD_CMPLT
case|:
name|bus
operator|=
literal|0x102
expr_stmt|;
comment|/* outgoing mailbox regs 1 */
break|break;
case|case
name|ASYNC_RIO_RESP
case|:
return|return
operator|(
name|rval
operator|)
return|;
case|case
name|ASYNC_CTIO_DONE
case|:
block|{
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|int
name|handle
init|=
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|handle
argument_list|,
name|mbox
argument_list|)
condition|)
block|{
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* count it as a fast posting intr */
name|isp
operator|->
name|isp_fphccmplt
operator|++
expr_stmt|;
block|}
else|#
directive|else
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Fast Posting CTIO done"
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_fphccmplt
operator|++
expr_stmt|;
comment|/* count it as a fast posting intr */
endif|#
directive|endif
break|break;
block|}
case|case
name|ASYNC_LIP_F8
case|:
case|case
name|ASYNC_LIP_OCCURRED
case|:
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_lipseq
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_LIP_RCVD
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_LIP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|,
name|mbox
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * We've had problems with data corruption occuring on 		 * commands that complete (with no apparent error) after 		 * we receive a LIP. This has been observed mostly on 		 * Local Loop topologies. To be safe, let's just mark 		 * all active commands as dead. 		 */
if|if
condition|(
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_topo
operator|==
name|TOPO_NL_PORT
operator|||
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_topo
operator|==
name|TOPO_FL_PORT
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|isp
operator|->
name|isp_maxcmds
condition|;
name|i
operator|++
control|)
block|{
name|XS_T
modifier|*
name|xs
decl_stmt|;
name|xs
operator|=
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"LIP destroyed %d active commands"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ASYNC_LOOP_UP
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_LIP_RCVD
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_LOOP_UP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|,
name|mbox
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_LOOP_DOWN
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_NIL
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_LOOP_DOWN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|,
name|mbox
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_LOOP_RESET
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_NIL
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_LOOP_RESET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|,
name|mbox
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_PDB_CHANGED
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_CHANGE_NOTIFY
argument_list|,
name|ISPASYNC_CHANGE_PDB
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
comment|/* 		 * Not correct, but it will force us to rescan the loop. 		 */
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_CHANGE_NOTIFY
argument_list|,
name|ISPASYNC_CHANGE_SNS
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_PTPMODE
case|:
if|if
condition|(
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_onfabric
condition|)
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_topo
operator|=
name|TOPO_F_PORT
expr_stmt|;
else|else
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_topo
operator|=
name|TOPO_N_PORT
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_LIP_RCVD
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_CHANGE_NOTIFY
argument_list|,
name|ISPASYNC_CHANGE_OTHER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_async
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|,
name|mbox
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Point-to-Point mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CONNMODE
case|:
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbox
condition|)
block|{
case|case
name|ISP_CONN_LOOP
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Point-to-Point -> Loop mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP_CONN_PTP
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Loop -> Point-to-Point mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP_CONN_BADLIP
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Point-to-Point -> Loop mode (BAD LIP)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP_CONN_FATAL
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"FATAL CONNECTION ERROR"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_FW_CRASH_DUMP
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FW_CRASH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FW_CRASH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isp_reinit
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FW_RESTARTED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|ISP_CONN_LOOPBACK
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Looped Back in Point-to-Point mode"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Unknown connection mode (0x%x)"
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
break|break;
block|}
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_CHANGE_NOTIFY
argument_list|,
name|ISPASYNC_CHANGE_OTHER
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_LIP_RCVD
expr_stmt|;
break|break;
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Unknown Async Code 0x%x"
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bus
operator|&
literal|0x100
condition|)
block|{
name|int
name|i
decl_stmt|,
name|nh
decl_stmt|;
name|u_int16_t
name|handles
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|nh
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_MAILBOX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bus
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|handles
index|[
name|nh
operator|++
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|MBOX_OFF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nh
condition|;
name|i
operator|++
control|)
block|{
name|isp_fastpost_complete
argument_list|(
name|isp
argument_list|,
name|handles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG3
argument_list|,
literal|"fast post completion of %u"
argument_list|,
name|handles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_fpcchiwater
operator|<
name|nh
condition|)
name|isp
operator|->
name|isp_fpcchiwater
operator|=
name|nh
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_intoasync
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle other response entries. A pointer to the request queue output  * index is here in case we want to eat several entries at once, although  * this is not used currently.  */
end_comment

begin_function
specifier|static
name|int
name|isp_handle_other_response
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|type
parameter_list|,
name|isphdr_t
modifier|*
name|hp
parameter_list|,
name|u_int16_t
modifier|*
name|optrp
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RQSTYPE_STATUS_CONT
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"Ignored Continuation Response"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|RQSTYPE_ATIO
case|:
case|case
name|RQSTYPE_CTIO
case|:
case|case
name|RQSTYPE_ENABLE_LUN
case|:
case|case
name|RQSTYPE_MODIFY_LUN
case|:
case|case
name|RQSTYPE_NOTIFY
case|:
case|case
name|RQSTYPE_NOTIFY_ACK
case|:
case|case
name|RQSTYPE_CTIO1
case|:
case|case
name|RQSTYPE_ATIO2
case|:
case|case
name|RQSTYPE_CTIO2
case|:
case|case
name|RQSTYPE_CTIO3
case|:
name|isp
operator|->
name|isp_rsltccmplt
operator|++
expr_stmt|;
comment|/* count as a response completion */
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_target_notify
argument_list|(
name|isp
argument_list|,
operator|(
name|ispstatusreq_t
operator|*
operator|)
name|hp
argument_list|,
name|optrp
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
name|RQSTYPE_REQUEST
case|:
default|default:
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|isp_get_response_type
argument_list|(
name|isp
argument_list|,
name|hp
argument_list|)
condition|)
block|{
comment|/* 			 * This is questionable- we're just papering over 			 * something we've seen on SMP linux in target 			 * mode- we don't really know what's happening 			 * here that causes us to think we've gotten 			 * an entry, but that either the entry isn't 			 * filled out yet or our CPU read data is stale. 			 */
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"unstable type in response queue"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Unhandled Response Type 0x%x"
argument_list|,
name|isp_get_response_type
argument_list|(
name|isp
argument_list|,
name|hp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_UNHANDLED_RESPONSE
argument_list|,
name|hp
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_parse_status
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|ispstatusreq_t
modifier|*
name|sp
parameter_list|,
name|XS_T
modifier|*
name|xs
parameter_list|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|req_completion_status
operator|&
literal|0xff
condition|)
block|{
case|case
name|RQCS_COMPLETE
case|:
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_INCOMPLETE
case|:
if|if
condition|(
operator|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_TARGET
operator|)
operator|==
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG1
argument_list|,
literal|"Selection Timeout for %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"command incomplete for %d.%d.%d, state 0x%x"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_state_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DMA_ERROR
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"DMA error for command on %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_TRANSPORT_ERROR
case|:
block|{
name|char
name|buf
index|[
literal|172
index|]
decl_stmt|;
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"states=>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_BUS
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s GOT_BUS"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_TARGET
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s GOT_TGT"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_SENT_CDB
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s SENT_CDB"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_XFRD_DATA
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s XFRD_DATA"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_STATUS
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s GOT_STS"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s GOT_SNS"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_XFER_COMPLETE
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s XFR_CMPLT"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s\nstatus=>"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_DISCONNECT
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s Disconnect"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_SYNCHRONOUS
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s Sync_xfr"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_PARITY_ERROR
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s Parity"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_BUS_RESET
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s Bus_Reset"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_DEVICE_RESET
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s Device_Reset"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_ABORTED
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s Aborted"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_TIMEOUT
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s Timeout"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_NEGOTIATION
condition|)
block|{
name|SNPRINTF
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s Negotiation"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"transport error for %d.%d.%d:\n%s"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RQCS_RESET_OCCURRED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"bus reset destroyed command for %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_ABORTED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"command aborted for %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ABORTED
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_TIMEOUT
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"command timed out for %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 	 * Check to see if we logged out the device. 		 */
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|req_completion_status
operator|&
name|RQSTF_LOGOUT
operator|)
operator|&&
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|portdb
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|valid
operator|&&
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|portdb
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|fabric_dev
condition|)
block|{
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|portdb
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|relogin
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_CMDTIMEOUT
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_DATA_OVERRUN
case|:
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"data overrun for command on %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_DATAOVR
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_COMMAND_OVERRUN
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"command overrun for command on %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_STATUS_OVERRUN
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"status overrun for command on %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_BAD_MESSAGE
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"msg not COMMAND COMPLETE after status %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_NO_MESSAGE_OUT
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"No MESSAGE OUT phase after selection on %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_EXT_ID_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"EXTENDED IDENTIFY failed %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_IDE_MSG_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"INITIATOR DETECTED ERROR rejected by %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ABORT_MSG_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"ABORT OPERATION rejected by %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_REJECT_MSG_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"MESSAGE REJECT rejected by %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_NOP_MSG_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"NOP rejected by %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PARITY_ERROR_MSG_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"MESSAGE PARITY ERROR rejected by %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DEVICE_RESET_MSG_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"BUS DEVICE RESET rejected by %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ID_MSG_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"IDENTIFY rejected by %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_UNEXP_BUS_FREE
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"%d.%d.%d had an unexpected bus free"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DATA_UNDERRUN
case|:
block|{
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|int
name|ru_marked
init|=
operator|(
name|sp
operator|->
name|req_scsi_status
operator|&
name|RQCS_RU
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ru_marked
operator|||
name|sp
operator|->
name|req_resid
operator|>
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
name|bun
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_resid
argument_list|,
operator|(
name|ru_marked
operator|)
condition|?
literal|"marked"
else|:
literal|"not marked"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|RQCS_XACT_ERR1
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
name|xact1
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_XACT_ERR2
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
name|xact2
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_XACT_ERR3
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
name|xact3
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_BAD_ENTRY
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Invalid IOCB entry type detected"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_QUEUE_FULL
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"internal queues full for %d.%d.%d status 0x%x"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If QFULL or some other status byte is set, then this 		 * isn't an error, per se. 		 * 		 * Unfortunately, some QLogic f/w writers have, in 		 * some cases, ommitted to *set* status to QFULL. 		 *  		if (*XS_STSP(xs) != SCSI_GOOD&& XS_NOERR(xs)) { 			XS_SETERR(xs, HBA_NOERROR); 			return; 		}  		 * 		 * 		 */
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|=
name|SCSI_QFULL
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_PHASE_SKIPPED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
name|pskip
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ARQS_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Auto Request Sense failed for %d.%d.%d"
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ARQFAIL
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_WIDE_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Wide Negotiation failed for %d.%d.%d"
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|+=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|goal_flags
operator|&=
operator|~
name|DPARM_WIDE
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_update
operator||=
operator|(
literal|1
operator|<<
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_SYNCXFER_FAILED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"SDTR Message failed for target %d.%d.%d"
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|+=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|goal_flags
operator|&=
operator|~
name|DPARM_SYNC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_update
operator||=
operator|(
literal|1
operator|<<
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|RQCS_LVD_BUSERR
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Bad LVD condition while talking to %d.%d.%d"
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PORT_UNAVAILABLE
case|:
comment|/* 		 * No such port on the loop. Moral equivalent of SELTIMEO 		 */
case|case
name|RQCS_PORT_LOGGED_OUT
case|:
comment|/* 		 * It was there (maybe)- treat as a selection timeout. 		 */
if|if
condition|(
operator|(
name|sp
operator|->
name|req_completion_status
operator|&
literal|0xff
operator|)
operator|==
name|RQCS_PORT_UNAVAILABLE
condition|)
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"port unavailable for target %d"
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGINFO
argument_list|,
literal|"port logout for target %d"
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If we're on a local loop, force a LIP (which is overkill) 		 * to force a re-login of this unit. If we're on fabric, 		 * then we'll have to relogin as a matter of course. 		 */
if|if
condition|(
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_topo
operator|==
name|TOPO_NL_PORT
operator|||
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_topo
operator|==
name|TOPO_FL_PORT
condition|)
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_LIP
expr_stmt|;
name|isp_mboxcmd_qnw
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Probably overkill. 		 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_CHANGE_NOTIFY
argument_list|,
name|ISPASYNC_CHANGE_OTHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_PORT_CHANGED
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"port changed for target %d"
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RQCS_PORT_BUSY
case|:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"port busy for target %d"
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_TGTBSY
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Unknown Completion Status 0x%x"
argument_list|,
name|sp
operator|->
name|req_completion_status
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_fastpost_complete
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|u_int16_t
name|fph
parameter_list|)
block|{
name|XS_T
modifier|*
name|xs
decl_stmt|;
if|if
condition|(
name|fph
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|xs
operator|=
name|isp_find_xs
argument_list|(
name|isp
argument_list|,
name|fph
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"Command for fast post handle 0x%x not found"
argument_list|,
name|fph
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp_destroy_handle
argument_list|(
name|isp
argument_list|,
name|fph
argument_list|)
expr_stmt|;
comment|/* 	 * Since we don't have a result queue entry item, 	 * we must believe that SCSI status is zero and 	 * that all data transferred. 	 */
name|XS_SET_STATE_STAT
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|XS_STSP
argument_list|(
name|xs
argument_list|)
operator|=
name|SCSI_GOOD
expr_stmt|;
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|fph
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_nactive
condition|)
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
name|isp
operator|->
name|isp_fphccmplt
operator|++
expr_stmt|;
name|isp_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_mbox_continue
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
switch|switch
condition|(
name|isp
operator|->
name|isp_lastmbxcmd
condition|)
block|{
case|case
name|MBOX_WRITE_RAM_WORD
case|:
case|case
name|MBOX_READ_RAM_WORD
case|:
case|case
name|MBOX_READ_RAM_WORD_EXTENDED
case|:
break|break;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_mboxtmp
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp
operator|->
name|isp_mbxwrk0
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Clear the previous interrupt. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Continue with next word. 	 */
name|ptr
operator|=
name|isp
operator|->
name|isp_mbxworkp
expr_stmt|;
switch|switch
condition|(
name|isp
operator|->
name|isp_lastmbxcmd
condition|)
block|{
case|case
name|MBOX_WRITE_RAM_WORD
case|:
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mbxwrk1
operator|++
expr_stmt|;
break|break;
case|case
name|MBOX_READ_RAM_WORD
case|:
case|case
name|MBOX_READ_RAM_WORD_EXTENDED
case|:
operator|*
name|ptr
operator|++
operator|=
name|isp
operator|->
name|isp_mboxtmp
index|[
literal|2
index|]
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mbxwrk1
operator|++
expr_stmt|;
break|break;
block|}
name|isp
operator|->
name|isp_mbxworkp
operator|=
name|ptr
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|isp
operator|->
name|isp_lastmbxcmd
expr_stmt|;
name|isp
operator|->
name|isp_mbxwrk0
operator|-=
literal|1
expr_stmt|;
name|isp_mboxcmd_qnw
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HIBYT
parameter_list|(
name|x
parameter_list|)
value|((x)>> 0x8)
end_define

begin_define
define|#
directive|define
name|LOBYT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xff)
end_define

begin_define
define|#
directive|define
name|ISPOPMAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<< 8) | (b))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|u_int16_t
name|mbpscsi
index|[]
init|=
block|{
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x00: MBOX_NO_OP */
name|ISPOPMAP
argument_list|(
literal|0x1f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x01: MBOX_LOAD_RAM */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x02: MBOX_EXEC_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0x1f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x03: MBOX_DUMP_RAM */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x04: MBOX_WRITE_RAM_WORD */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x05: MBOX_READ_RAM_WORD */
name|ISPOPMAP
argument_list|(
literal|0x3f
argument_list|,
literal|0x3f
argument_list|)
block|,
comment|/* 0x06: MBOX_MAILBOX_REG_TEST */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x07: MBOX_VERIFY_CHECKSUM	*/
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x0f
argument_list|)
block|,
comment|/* 0x08: MBOX_ABOUT_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x09: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x0a: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x0b: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x0c: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x0d: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x05
argument_list|)
block|,
comment|/* 0x0e: MBOX_CHECK_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x0f: */
name|ISPOPMAP
argument_list|(
literal|0x1f
argument_list|,
literal|0x1f
argument_list|)
block|,
comment|/* 0x10: MBOX_INIT_REQ_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x3f
argument_list|,
literal|0x3f
argument_list|)
block|,
comment|/* 0x11: MBOX_INIT_RES_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x0f
argument_list|)
block|,
comment|/* 0x12: MBOX_EXECUTE_IOCB */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x13: MBOX_WAKE_UP	*/
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x3f
argument_list|)
block|,
comment|/* 0x14: MBOX_STOP_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x0f
argument_list|)
block|,
comment|/* 0x15: MBOX_ABORT */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x16: MBOX_ABORT_DEVICE */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x17: MBOX_ABORT_TARGET */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x18: MBOX_BUS_RESET */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x19: MBOX_STOP_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x1a: MBOX_START_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x1c: MBOX_ABORT_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x4f
argument_list|)
block|,
comment|/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x1e: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x20: MBOX_GET_INIT_SCSI_ID */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x21: MBOX_GET_SELECT_TIMEOUT */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0xc7
argument_list|)
block|,
comment|/* 0x22: MBOX_GET_RETRY_COUNT	*/
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x23: MBOX_GET_TAG_AGE_LIMIT */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x24: MBOX_GET_CLOCK_RATE */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x25: MBOX_GET_ACT_NEG_STATE */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x27: MBOX_GET_PCI_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x4f
argument_list|)
block|,
comment|/* 0x28: MBOX_GET_TARGET_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x0f
argument_list|)
block|,
comment|/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2b: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2c: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2d: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2e: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2f: */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x30: MBOX_SET_INIT_SCSI_ID */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x31: MBOX_SET_SELECT_TIMEOUT */
name|ISPOPMAP
argument_list|(
literal|0xc7
argument_list|,
literal|0xc7
argument_list|)
block|,
comment|/* 0x32: MBOX_SET_RETRY_COUNT	*/
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x33: MBOX_SET_TAG_AGE_LIMIT */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x34: MBOX_SET_CLOCK_RATE */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x35: MBOX_SET_ACT_NEG_STATE */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x4f
argument_list|,
literal|0x4f
argument_list|)
block|,
comment|/* 0x38: MBOX_SET_TARGET_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x0f
argument_list|)
block|,
comment|/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3b: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3c: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3d: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3e: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3f: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */
name|ISPOPMAP
argument_list|(
literal|0x3f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x42: MBOX_EXEC_BIOS_IOCB */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x43: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x44: */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x45: SET SYSTEM PARAMETER */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x46: GET SYSTEM PARAMETER */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x47: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0xcf
argument_list|)
block|,
comment|/* 0x48: GET SCAM CONFIGURATION */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0xcf
argument_list|)
block|,
comment|/* 0x49: SET SCAM CONFIGURATION */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4c: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4d: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4e: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4f: */
name|ISPOPMAP
argument_list|(
literal|0xdf
argument_list|,
literal|0xdf
argument_list|)
block|,
comment|/* 0x50: LOAD RAM A64 */
name|ISPOPMAP
argument_list|(
literal|0xdf
argument_list|,
literal|0xdf
argument_list|)
block|,
comment|/* 0x51: DUMP RAM A64 */
name|ISPOPMAP
argument_list|(
literal|0xdf
argument_list|,
literal|0xff
argument_list|)
block|,
comment|/* 0x52: INITIALIZE REQUEST QUEUE A64 */
name|ISPOPMAP
argument_list|(
literal|0xef
argument_list|,
literal|0xff
argument_list|)
block|,
comment|/* 0x53: INITIALIZE RESPONSE QUEUE A64 */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x54: EXECUTE IOCB A64 */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x55: ENABLE TARGET MODE */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x0f
argument_list|)
block|,
comment|/* 0x56: GET TARGET STATUS */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x57: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x58: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x59: */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x5a: SET DATA OVERRUN RECOVERY MODE */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x5b: GET DATA OVERRUN RECOVERY MODE */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x0f
argument_list|)
block|,
comment|/* 0x5c: SET HOST DATA */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x01
argument_list|)
comment|/* 0x5d: GET NOST DATA */
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ISP_STRIPPED
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scsi_mbcmd_names
index|[]
init|=
block|{
literal|"NO-OP"
block|,
literal|"LOAD RAM"
block|,
literal|"EXEC FIRMWARE"
block|,
literal|"DUMP RAM"
block|,
literal|"WRITE RAM WORD"
block|,
literal|"READ RAM WORD"
block|,
literal|"MAILBOX REG TEST"
block|,
literal|"VERIFY CHECKSUM"
block|,
literal|"ABOUT FIRMWARE"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"CHECK FIRMWARE"
block|,
name|NULL
block|,
literal|"INIT REQUEST QUEUE"
block|,
literal|"INIT RESULT QUEUE"
block|,
literal|"EXECUTE IOCB"
block|,
literal|"WAKE UP"
block|,
literal|"STOP FIRMWARE"
block|,
literal|"ABORT"
block|,
literal|"ABORT DEVICE"
block|,
literal|"ABORT TARGET"
block|,
literal|"BUS RESET"
block|,
literal|"STOP QUEUE"
block|,
literal|"START QUEUE"
block|,
literal|"SINGLE STEP QUEUE"
block|,
literal|"ABORT QUEUE"
block|,
literal|"GET DEV QUEUE STATUS"
block|,
name|NULL
block|,
literal|"GET FIRMWARE STATUS"
block|,
literal|"GET INIT SCSI ID"
block|,
literal|"GET SELECT TIMEOUT"
block|,
literal|"GET RETRY COUNT"
block|,
literal|"GET TAG AGE LIMIT"
block|,
literal|"GET CLOCK RATE"
block|,
literal|"GET ACT NEG STATE"
block|,
literal|"GET ASYNC DATA SETUP TIME"
block|,
literal|"GET PCI PARAMS"
block|,
literal|"GET TARGET PARAMS"
block|,
literal|"GET DEV QUEUE PARAMS"
block|,
literal|"GET RESET DELAY PARAMS"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"SET INIT SCSI ID"
block|,
literal|"SET SELECT TIMEOUT"
block|,
literal|"SET RETRY COUNT"
block|,
literal|"SET TAG AGE LIMIT"
block|,
literal|"SET CLOCK RATE"
block|,
literal|"SET ACT NEG STATE"
block|,
literal|"SET ASYNC DATA SETUP TIME"
block|,
literal|"SET PCI CONTROL PARAMS"
block|,
literal|"SET TARGET PARAMS"
block|,
literal|"SET DEV QUEUE PARAMS"
block|,
literal|"SET RESET DELAY PARAMS"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"RETURN BIOS BLOCK ADDR"
block|,
literal|"WRITE FOUR RAM WORDS"
block|,
literal|"EXEC BIOS IOCB"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"SET SYSTEM PARAMETER"
block|,
literal|"GET SYSTEM PARAMETER"
block|,
name|NULL
block|,
literal|"GET SCAM CONFIGURATION"
block|,
literal|"SET SCAM CONFIGURATION"
block|,
literal|"SET FIRMWARE FEATURES"
block|,
literal|"GET FIRMWARE FEATURES"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"LOAD RAM A64"
block|,
literal|"DUMP RAM A64"
block|,
literal|"INITIALIZE REQUEST QUEUE A64"
block|,
literal|"INITIALIZE RESPONSE QUEUE A64"
block|,
literal|"EXECUTE IOCB A64"
block|,
literal|"ENABLE TARGET MODE"
block|,
literal|"GET TARGET MODE STATE"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"SET DATA OVERRUN RECOVERY MODE"
block|,
literal|"GET DATA OVERRUN RECOVERY MODE"
block|,
literal|"SET HOST DATA"
block|,
literal|"GET NOST DATA"
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|u_int16_t
name|mbpfc
index|[]
init|=
block|{
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x00: MBOX_NO_OP */
name|ISPOPMAP
argument_list|(
literal|0x1f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x01: MBOX_LOAD_RAM */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x02: MBOX_EXEC_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0xdf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x03: MBOX_DUMP_RAM */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x04: MBOX_WRITE_RAM_WORD */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x05: MBOX_READ_RAM_WORD */
name|ISPOPMAP
argument_list|(
literal|0xff
argument_list|,
literal|0xff
argument_list|)
block|,
comment|/* 0x06: MBOX_MAILBOX_REG_TEST */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x05
argument_list|)
block|,
comment|/* 0x07: MBOX_VERIFY_CHECKSUM	*/
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x4f
argument_list|)
block|,
comment|/* 0x08: MBOX_ABOUT_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0xdf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x09: LOAD RAM */
name|ISPOPMAP
argument_list|(
literal|0xdf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x0a: DUMP RAM */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x0b: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x0c: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x0d: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x05
argument_list|)
block|,
comment|/* 0x0e: MBOX_CHECK_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x0f: MBOX_READ_RAM_WORD_EXTENDED(1) */
name|ISPOPMAP
argument_list|(
literal|0x1f
argument_list|,
literal|0x11
argument_list|)
block|,
comment|/* 0x10: MBOX_INIT_REQ_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x2f
argument_list|,
literal|0x21
argument_list|)
block|,
comment|/* 0x11: MBOX_INIT_RES_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x12: MBOX_EXECUTE_IOCB */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x13: MBOX_WAKE_UP	*/
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0xff
argument_list|)
block|,
comment|/* 0x14: MBOX_STOP_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0x4f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x15: MBOX_ABORT */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x16: MBOX_ABORT_DEVICE */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x17: MBOX_ABORT_TARGET */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x18: MBOX_BUS_RESET */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x05
argument_list|)
block|,
comment|/* 0x19: MBOX_STOP_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x05
argument_list|)
block|,
comment|/* 0x1a: MBOX_START_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x05
argument_list|)
block|,
comment|/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x05
argument_list|)
block|,
comment|/* 0x1c: MBOX_ABORT_QUEUE */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x1e: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x4f
argument_list|)
block|,
comment|/* 0x20: MBOX_GET_LOOP_ID */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x21: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x22: MBOX_GET_RETRY_COUNT	*/
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x23: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x24: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x25: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x26: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x27: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x28: MBOX_GET_FIRMWARE_OPTIONS */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x29: MBOX_GET_PORT_QUEUE_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2a: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2b: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2c: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2d: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2e: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x2f: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x30: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x31: */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x32: MBOX_SET_RETRY_COUNT	*/
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x33: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x34: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x35: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x36: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x37: */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x38: MBOX_SET_FIRMWARE_OPTIONS */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x39: MBOX_SET_PORT_QUEUE_PARAMS */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3a: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3b: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3c: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3d: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3e: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x3f: */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x40: MBOX_LOOP_PORT_BYPASS */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x41: MBOX_LOOP_PORT_ENABLE */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x42: MBOX_GET_RESOURCE_COUNTS */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x43: MBOX_REQUEST_NON_PARTICIPATING_MODE */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x44: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x45: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x46: */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x47: GET PORT_DATABASE ENHANCED */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x48: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x49: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4a: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4b: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4c: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4d: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4e: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x4f: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x50: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x51: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x52: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x53: */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x54: EXECUTE IOCB A64 */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x55: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x56: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x57: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x58: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x59: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x5a: */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x5b: MBOX_DRIVER_HEARTBEAT */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x5c: MBOX_FW_HEARTBEAT */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x5d: MBOX_GET_SET_DATA_RATE */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x5e: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x5f: */
name|ISPOPMAP
argument_list|(
literal|0xfd
argument_list|,
literal|0x31
argument_list|)
block|,
comment|/* 0x60: MBOX_INIT_FIRMWARE */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x61: */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x62: MBOX_INIT_LIP */
name|ISPOPMAP
argument_list|(
literal|0xcd
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x64: MBOX_GET_PORT_DB */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x65: MBOX_CLEAR_ACA */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x66: MBOX_TARGET_RESET */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x67: MBOX_CLEAR_TASK_SET */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x68: MBOX_ABORT_TASK_SET */
name|ISPOPMAP
argument_list|(
literal|0x01
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x69: MBOX_GET_FW_STATE */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0xcf
argument_list|)
block|,
comment|/* 0x6a: MBOX_GET_PORT_NAME */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x6b: MBOX_GET_LINK_STATUS */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x6c: MBOX_INIT_LIP_RESET */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x6d: */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x6e: MBOX_SEND_SNS */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x07
argument_list|)
block|,
comment|/* 0x6f: MBOX_FABRIC_LOGIN */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x70: MBOX_SEND_CHANGE_REQUEST */
name|ISPOPMAP
argument_list|(
literal|0x03
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x71: MBOX_FABRIC_LOGOUT */
name|ISPOPMAP
argument_list|(
literal|0x0f
argument_list|,
literal|0x0f
argument_list|)
block|,
comment|/* 0x72: MBOX_INIT_LIP_LOGIN */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x73: */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x74: LOGIN LOOP PORT */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x75: GET PORT/NODE NAME LIST */
name|ISPOPMAP
argument_list|(
literal|0x4f
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x76: SET VENDOR ID */
name|ISPOPMAP
argument_list|(
literal|0xcd
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x77: INITIALIZE IP MAILBOX */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x78: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x79: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x7a: */
name|ISPOPMAP
argument_list|(
literal|0x00
argument_list|,
literal|0x00
argument_list|)
block|,
comment|/* 0x7b: */
name|ISPOPMAP
argument_list|(
literal|0x4f
argument_list|,
literal|0x03
argument_list|)
block|,
comment|/* 0x7c: Get ID List */
name|ISPOPMAP
argument_list|(
literal|0xcf
argument_list|,
literal|0x01
argument_list|)
block|,
comment|/* 0x7d: SEND LFA */
name|ISPOPMAP
argument_list|(
literal|0x07
argument_list|,
literal|0x01
argument_list|)
comment|/* 0x7e: Lun RESET */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Footnotes  *  * (1): this sets bits 21..16 in mailbox register #8, which we nominally   *	do not access at this time in the core driver. The caller is  *	responsible for setting this register first (Gross!).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISP_STRIPPED
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fc_mbcmd_names
index|[]
init|=
block|{
literal|"NO-OP"
block|,
literal|"LOAD RAM"
block|,
literal|"EXEC FIRMWARE"
block|,
literal|"DUMP RAM"
block|,
literal|"WRITE RAM WORD"
block|,
literal|"READ RAM WORD"
block|,
literal|"MAILBOX REG TEST"
block|,
literal|"VERIFY CHECKSUM"
block|,
literal|"ABOUT FIRMWARE"
block|,
literal|"LOAD RAM"
block|,
literal|"DUMP RAM"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"READ RAM WORD EXTENDED"
block|,
literal|"CHECK FIRMWARE"
block|,
name|NULL
block|,
literal|"INIT REQUEST QUEUE"
block|,
literal|"INIT RESULT QUEUE"
block|,
literal|"EXECUTE IOCB"
block|,
literal|"WAKE UP"
block|,
literal|"STOP FIRMWARE"
block|,
literal|"ABORT"
block|,
literal|"ABORT DEVICE"
block|,
literal|"ABORT TARGET"
block|,
literal|"BUS RESET"
block|,
literal|"STOP QUEUE"
block|,
literal|"START QUEUE"
block|,
literal|"SINGLE STEP QUEUE"
block|,
literal|"ABORT QUEUE"
block|,
literal|"GET DEV QUEUE STATUS"
block|,
name|NULL
block|,
literal|"GET FIRMWARE STATUS"
block|,
literal|"GET LOOP ID"
block|,
name|NULL
block|,
literal|"GET RETRY COUNT"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"GET FIRMWARE OPTIONS"
block|,
literal|"GET PORT QUEUE PARAMS"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"SET RETRY COUNT"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"SET FIRMWARE OPTIONS"
block|,
literal|"SET PORT QUEUE PARAMS"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"LOOP PORT BYPASS"
block|,
literal|"LOOP PORT ENABLE"
block|,
literal|"GET RESOURCE COUNTS"
block|,
literal|"REQUEST NON PARTICIPATING MODE"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"GET PORT DATABASE,, ENHANCED"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"EXECUTE IOCB A64"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"DRIVER HEARTBEAT"
block|,
name|NULL
block|,
literal|"GET/SET DATA RATE"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"INIT FIRMWARE"
block|,
name|NULL
block|,
literal|"INIT LIP"
block|,
literal|"GET FC-AL POSITION MAP"
block|,
literal|"GET PORT DATABASE"
block|,
literal|"CLEAR ACA"
block|,
literal|"TARGET RESET"
block|,
literal|"CLEAR TASK SET"
block|,
literal|"ABORT TASK SET"
block|,
literal|"GET FW STATE"
block|,
literal|"GET PORT NAME"
block|,
literal|"GET LINK STATUS"
block|,
literal|"INIT LIP RESET"
block|,
name|NULL
block|,
literal|"SEND SNS"
block|,
literal|"FABRIC LOGIN"
block|,
literal|"SEND CHANGE REQUEST"
block|,
literal|"FABRIC LOGOUT"
block|,
literal|"INIT LIP LOGIN"
block|,
name|NULL
block|,
literal|"LOGIN LOOP PORT"
block|,
literal|"GET PORT/NODE NAME LIST"
block|,
literal|"SET VENDOR ID"
block|,
literal|"INITIALIZE IP MAILBOX"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"Get ID List"
block|,
literal|"SEND LFA"
block|,
literal|"Lun RESET"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|isp_mboxcmd_qnw
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|mbreg_t
modifier|*
name|mbp
parameter_list|,
name|int
name|nodelay
parameter_list|)
block|{
name|unsigned
name|int
name|ibits
decl_stmt|,
name|obits
decl_stmt|,
name|box
decl_stmt|,
name|opcode
decl_stmt|;
specifier|const
name|u_int16_t
modifier|*
name|mcp
decl_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mcp
operator|=
name|mbpfc
expr_stmt|;
block|}
else|else
block|{
name|mcp
operator|=
name|mbpscsi
expr_stmt|;
block|}
name|opcode
operator|=
name|mbp
operator|->
name|param
index|[
literal|0
index|]
expr_stmt|;
name|ibits
operator|=
name|HIBYT
argument_list|(
name|mcp
index|[
name|opcode
index|]
argument_list|)
operator|&
name|NMBOX_BMASK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|obits
operator|=
name|LOBYT
argument_list|(
name|mcp
index|[
name|opcode
index|]
argument_list|)
operator|&
name|NMBOX_BMASK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
for|for
control|(
name|box
operator|=
literal|0
init|;
name|box
operator|<
name|MAX_MAILBOX
condition|;
name|box
operator|++
control|)
block|{
if|if
condition|(
name|ibits
operator|&
operator|(
literal|1
operator|<<
name|box
operator|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|MBOX_OFF
argument_list|(
name|box
argument_list|)
argument_list|,
name|mbp
operator|->
name|param
index|[
name|box
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nodelay
operator|==
literal|0
condition|)
block|{
name|isp
operator|->
name|isp_mboxtmp
index|[
name|box
index|]
operator|=
name|mbp
operator|->
name|param
index|[
name|box
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nodelay
operator|==
literal|0
condition|)
block|{
name|isp
operator|->
name|isp_lastmbxcmd
operator|=
name|opcode
expr_stmt|;
name|isp
operator|->
name|isp_obits
operator|=
name|obits
expr_stmt|;
name|isp
operator|->
name|isp_mboxbsy
operator|=
literal|1
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_SET_HOST_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Oddly enough, if we're not delaying for an answer, 	 * delay a bit to give the f/w a chance to pick up the 	 * command. 	 */
if|if
condition|(
name|nodelay
condition|)
block|{
name|USEC_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_mboxcmd
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|mbreg_t
modifier|*
name|mbp
parameter_list|,
name|int
name|logmask
parameter_list|)
block|{
name|char
modifier|*
name|cname
decl_stmt|,
modifier|*
name|xname
decl_stmt|,
name|tname
index|[
literal|16
index|]
decl_stmt|,
name|mname
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|int
name|lim
decl_stmt|,
name|ibits
decl_stmt|,
name|obits
decl_stmt|,
name|box
decl_stmt|,
name|opcode
decl_stmt|;
specifier|const
name|u_int16_t
modifier|*
name|mcp
decl_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mcp
operator|=
name|mbpfc
expr_stmt|;
name|lim
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|mbpfc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mbpfc
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mcp
operator|=
name|mbpscsi
expr_stmt|;
name|lim
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|mbpscsi
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mbpscsi
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opcode
operator|=
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|)
operator|>=
name|lim
condition|)
block|{
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INVALID_COMMAND
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Unknown Command 0x%x"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return;
block|}
name|ibits
operator|=
name|HIBYT
argument_list|(
name|mcp
index|[
name|opcode
index|]
argument_list|)
operator|&
name|NMBOX_BMASK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|obits
operator|=
name|LOBYT
argument_list|(
name|mcp
index|[
name|opcode
index|]
argument_list|)
operator|&
name|NMBOX_BMASK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibits
operator|==
literal|0
operator|&&
name|obits
operator|==
literal|0
condition|)
block|{
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_COMMAND_PARAM_ERROR
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"no parameters for 0x%x"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get exclusive usage of mailbox registers. 	 */
name|MBOX_ACQUIRE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
for|for
control|(
name|box
operator|=
literal|0
init|;
name|box
operator|<
name|MAX_MAILBOX
condition|;
name|box
operator|++
control|)
block|{
if|if
condition|(
name|ibits
operator|&
operator|(
literal|1
operator|<<
name|box
operator|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|MBOX_OFF
argument_list|(
name|box
argument_list|)
argument_list|,
name|mbp
operator|->
name|param
index|[
name|box
index|]
argument_list|)
expr_stmt|;
block|}
name|isp
operator|->
name|isp_mboxtmp
index|[
name|box
index|]
operator|=
name|mbp
operator|->
name|param
index|[
name|box
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|isp
operator|->
name|isp_lastmbxcmd
operator|=
name|opcode
expr_stmt|;
comment|/* 	 * We assume that we can't overwrite a previous command. 	 */
name|isp
operator|->
name|isp_obits
operator|=
name|obits
expr_stmt|;
name|isp
operator|->
name|isp_mboxbsy
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Set Host Interrupt condition so that RISC will pick up mailbox regs. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_SET_HOST_INT
argument_list|)
expr_stmt|;
comment|/* 	 * While we haven't finished the command, spin our wheels here. 	 */
name|MBOX_WAIT_COMPLETE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_mboxbsy
condition|)
block|{
comment|/* 		 * Command timed out. 		 */
name|isp
operator|->
name|isp_mboxbsy
operator|=
literal|0
expr_stmt|;
name|MBOX_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Copy back output registers. 	 */
for|for
control|(
name|box
operator|=
literal|0
init|;
name|box
operator|<
name|MAX_MAILBOX
condition|;
name|box
operator|++
control|)
block|{
if|if
condition|(
name|obits
operator|&
operator|(
literal|1
operator|<<
name|box
operator|)
condition|)
block|{
name|mbp
operator|->
name|param
index|[
name|box
index|]
operator|=
name|isp
operator|->
name|isp_mboxtmp
index|[
name|box
index|]
expr_stmt|;
block|}
block|}
name|MBOX_RELEASE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|logmask
operator|==
literal|0
operator|||
name|opcode
operator|==
name|MBOX_EXEC_FIRMWARE
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|ISP_STRIPPED
name|cname
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|cname
operator|=
operator|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
operator|)
condition|?
name|fc_mbcmd_names
index|[
name|opcode
index|]
else|:
name|scsi_mbcmd_names
index|[
name|opcode
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cname
operator|==
name|NULL
condition|)
block|{
name|cname
operator|=
name|tname
expr_stmt|;
name|SNPRINTF
argument_list|(
name|tname
argument_list|,
sizeof|sizeof
name|tname
argument_list|,
literal|"opcode %x"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Just to be chatty here... 	 */
name|xname
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
break|break;
case|case
name|MBOX_INVALID_COMMAND
case|:
if|if
condition|(
name|logmask
operator|&
name|MBLOGMASK
argument_list|(
name|MBOX_COMMAND_COMPLETE
argument_list|)
condition|)
name|xname
operator|=
literal|"INVALID COMMAND"
expr_stmt|;
break|break;
case|case
name|MBOX_HOST_INTERFACE_ERROR
case|:
if|if
condition|(
name|logmask
operator|&
name|MBLOGMASK
argument_list|(
name|MBOX_HOST_INTERFACE_ERROR
argument_list|)
condition|)
name|xname
operator|=
literal|"HOST INTERFACE ERROR"
expr_stmt|;
break|break;
case|case
name|MBOX_TEST_FAILED
case|:
if|if
condition|(
name|logmask
operator|&
name|MBLOGMASK
argument_list|(
name|MBOX_TEST_FAILED
argument_list|)
condition|)
name|xname
operator|=
literal|"TEST FAILED"
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_ERROR
case|:
if|if
condition|(
name|logmask
operator|&
name|MBLOGMASK
argument_list|(
name|MBOX_COMMAND_ERROR
argument_list|)
condition|)
name|xname
operator|=
literal|"COMMAND ERROR"
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_PARAM_ERROR
case|:
if|if
condition|(
name|logmask
operator|&
name|MBLOGMASK
argument_list|(
name|MBOX_COMMAND_PARAM_ERROR
argument_list|)
condition|)
name|xname
operator|=
literal|"COMMAND PARAMETER ERROR"
expr_stmt|;
break|break;
case|case
name|MBOX_LOOP_ID_USED
case|:
if|if
condition|(
name|logmask
operator|&
name|MBLOGMASK
argument_list|(
name|MBOX_LOOP_ID_USED
argument_list|)
condition|)
name|xname
operator|=
literal|"LOOP ID ALREADY IN USE"
expr_stmt|;
break|break;
case|case
name|MBOX_PORT_ID_USED
case|:
if|if
condition|(
name|logmask
operator|&
name|MBLOGMASK
argument_list|(
name|MBOX_PORT_ID_USED
argument_list|)
condition|)
name|xname
operator|=
literal|"PORT ID ALREADY IN USE"
expr_stmt|;
break|break;
case|case
name|MBOX_ALL_IDS_USED
case|:
if|if
condition|(
name|logmask
operator|&
name|MBLOGMASK
argument_list|(
name|MBOX_ALL_IDS_USED
argument_list|)
condition|)
name|xname
operator|=
literal|"ALL LOOP IDS IN USE"
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* special case */
name|xname
operator|=
literal|"TIMEOUT"
expr_stmt|;
break|break;
default|default:
name|SNPRINTF
argument_list|(
name|mname
argument_list|,
sizeof|sizeof
name|mname
argument_list|,
literal|"error 0x%x"
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|xname
operator|=
name|mname
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xname
condition|)
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGALL
argument_list|,
literal|"Mailbox Command '%s' failed (%s)"
argument_list|,
name|cname
argument_list|,
name|xname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_fw_state
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FW_STATE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|fcp
operator|->
name|isp_fwstate
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_update
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|upmask
decl_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
operator|,
name|upmask
operator|=
name|isp
operator|->
name|isp_update
init|;
name|upmask
operator|!=
literal|0
condition|;
name|bus
operator|++
control|)
block|{
if|if
condition|(
name|upmask
operator|&
operator|(
literal|1
operator|<<
name|bus
operator|)
condition|)
block|{
name|isp_update_bus
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
name|upmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_update_bus
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|bus
parameter_list|)
block|{
name|int
name|tgt
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdparam
modifier|*
name|sdp
decl_stmt|;
name|isp
operator|->
name|isp_update
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
comment|/* 		 * There are no 'per-bus' settings for Fibre Channel. 		 */
return|return;
block|}
name|sdp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
name|sdp
operator|+=
name|bus
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|u_int16_t
name|flags
decl_stmt|,
name|period
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|get
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|==
literal|0
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
operator|=
literal|0
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"skipping target %d bus %d update"
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If the goal is to update the status of the device, 		 * take what's in goal_flags and try and set the device 		 * toward that. Otherwise, if we're just refreshing the 		 * current device state, get the current parameters. 		 */
comment|/* 		 * Refresh overrides set 		 */
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_TARGET_PARAMS
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
operator|=
literal|0
expr_stmt|;
name|get
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
comment|/* 			 * Make sure goal_flags has "Renegotiate on Error" 			 * on and "Freeze Queue on Error" off. 			 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
operator||=
name|DPARM_RENEG
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
operator|&=
operator|~
name|DPARM_QFRZ
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
expr_stmt|;
comment|/* 			 * Insist that PARITY must be enabled 			 * if SYNC or WIDE is enabled. 			 */
if|if
condition|(
operator|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|&
operator|(
name|DPARM_SYNC
operator||
name|DPARM_WIDE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator||=
name|DPARM_PARITY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|&
name|DPARM_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_period
operator|)
expr_stmt|;
block|}
comment|/* 			 * A command completion later that has 			 * RQSTF_NEGOTIATION set can cause 			 * the dev_refresh/announce cycle also. 			 * 			 * Note: It is really important to update our current 			 * flags with at least the state of TAG capabilities- 			 * otherwise we might try and send a tagged command 			 * when we have it all turned off. So change it here 			 * to say that current already matches goal. 			 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_flags
operator|&=
operator|~
name|DPARM_TQING
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_flags
operator||=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
operator|&
name|DPARM_TQING
operator|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"bus %d set tgt %d flags 0x%x off 0x%x period 0x%x"
argument_list|,
name|bus
argument_list|,
name|tgt
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
operator|=
literal|1
expr_stmt|;
name|get
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|bus
operator|<<
literal|15
operator|)
operator||
operator|(
name|tgt
operator|<<
literal|8
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|get
operator|==
literal|0
condition|)
block|{
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
continue|continue;
block|}
name|flags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_flags
operator|=
name|flags
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_period
operator|=
name|period
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_offset
operator|=
name|offset
expr_stmt|;
name|get
operator|=
operator|(
name|bus
operator|<<
literal|16
operator|)
operator||
name|tgt
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_NEW_TGT_PARAMS
argument_list|,
operator|&
name|get
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
operator|||
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
condition|)
block|{
name|isp
operator|->
name|isp_update
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_FRAMESIZE
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_FRAMESIZE
parameter_list|(
name|isp
parameter_list|)
value|ICB_DFLT_FRMLEN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_EXEC_THROTTLE
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_EXEC_THROTTLE
parameter_list|(
name|isp
parameter_list|)
value|ISP_EXEC_THROTTLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|isp_setdfltparm
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|tgt
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdparam
modifier|*
name|sdp
decl_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|nvfail
decl_stmt|;
name|fcp
operator|+=
name|channel
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_gotdparms
condition|)
block|{
return|return;
block|}
name|fcp
operator|->
name|isp_gotdparms
operator|=
literal|1
expr_stmt|;
name|fcp
operator|->
name|isp_maxfrmlen
operator|=
name|DEFAULT_FRAMESIZE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_maxalloc
operator|=
name|ICB_DFLT_ALLOC
expr_stmt|;
name|fcp
operator|->
name|isp_execthrottle
operator|=
name|DEFAULT_EXEC_THROTTLE
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_delay
operator|=
name|ICB_DFLT_RDELAY
expr_stmt|;
name|fcp
operator|->
name|isp_retry_count
operator|=
name|ICB_DFLT_RCOUNT
expr_stmt|;
comment|/* Platform specific.... */
name|fcp
operator|->
name|isp_loopid
operator|=
name|DEFAULT_LOOPID
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_nodewwn
operator|=
name|DEFAULT_NODEWWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_portwwn
operator|=
name|DEFAULT_PORTWWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator|=
literal|0
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FAIRNESS
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_PDBCHANGE_AE
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_HARD_ADDRESS
expr_stmt|;
ifndef|#
directive|ifndef
name|ISP_NO_FASTPOST_FC
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FAST_POST
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_FULL_DUPLEX
condition|)
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FULL_DUPLEX
expr_stmt|;
comment|/* 		 * Make sure this is turned off now until we get 		 * extended options from NVRAM 		 */
name|fcp
operator|->
name|isp_fwoptions
operator|&=
operator|~
name|ICBOPT_EXTENDED
expr_stmt|;
comment|/* 		 * Now try and read NVRAM unless told to not do so. 		 * This will set fcparam's isp_nodewwn&& isp_portwwn. 		 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NONVRAM
operator|)
operator|==
literal|0
condition|)
block|{
name|nvfail
operator|=
name|isp_read_nvram
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvfail
condition|)
name|isp
operator|->
name|isp_confopts
operator||=
name|ISP_CFG_NONVRAM
expr_stmt|;
block|}
else|else
block|{
name|nvfail
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Set node&& port to override platform set defaults 		 * unless the nvram read failed (or none was done), 		 * or the platform code wants to use what had been 		 * set in the defaults. 		 */
if|if
condition|(
name|nvfail
condition|)
block|{
name|isp
operator|->
name|isp_confopts
operator||=
name|ISP_CFG_OWNWWPN
operator||
name|ISP_CFG_OWNWWNN
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_OWNWWNN
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"Using Node WWN 0x%08x%08x"
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|DEFAULT_NODEWWN
argument_list|(
name|isp
argument_list|)
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|DEFAULT_NODEWWN
argument_list|(
name|isp
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_NODEWWN
argument_list|(
name|isp
argument_list|)
operator|=
name|DEFAULT_NODEWWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We always start out with values derived 			 * from NVRAM or our platform default. 			 */
name|ISP_NODEWWN
argument_list|(
name|isp
argument_list|)
operator|=
name|fcp
operator|->
name|isp_nodewwn
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_OWNWWPN
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"Using Port WWN 0x%08x%08x"
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|DEFAULT_PORTWWN
argument_list|(
name|isp
argument_list|)
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|DEFAULT_PORTWWN
argument_list|(
name|isp
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_PORTWWN
argument_list|(
name|isp
argument_list|)
operator|=
name|DEFAULT_PORTWWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We always start out with values derived 			 * from NVRAM or our platform default. 			 */
name|ISP_PORTWWN
argument_list|(
name|isp
argument_list|)
operator|=
name|fcp
operator|->
name|isp_portwwn
expr_stmt|;
block|}
return|return;
block|}
name|sdp
operator|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
expr_stmt|;
name|sdp
operator|+=
name|channel
expr_stmt|;
comment|/* 	 * Been there, done that, got the T-shirt... 	 */
if|if
condition|(
name|sdp
operator|->
name|isp_gotdparms
condition|)
block|{
return|return;
block|}
name|sdp
operator|->
name|isp_gotdparms
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Establish some default parameters. 	 */
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_initiator_id
operator|=
name|DEFAULT_IID
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|>=
name|ISP_HA_SCSI_1040
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|6
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_selection_timeout
operator|=
literal|250
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|MAXISPREQUEST
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_tag_aging
operator|=
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
literal|5
expr_stmt|;
comment|/* 	 * Don't retry selection, busy or queue full automatically- reflect 	 * these back to us. 	 */
name|sdp
operator|->
name|isp_retry_count
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
operator|=
name|ISP_EXEC_THROTTLE
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we've not been told to avoid reading NVRAM, try and read it. 	 * If we're successful reading it, we can then return because NVRAM 	 * will tell us what the desired settings are. Otherwise, we establish 	 * some reasonable 'fake' nvram and goal defaults. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NONVRAM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isp_read_nvram
argument_list|(
name|isp
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
comment|/* 	 * Now try and see whether we have specific values for them. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NONVRAM
operator|)
operator|==
literal|0
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_ACT_NEG_STATE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|,
name|MBLOGNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|1
operator|+
name|channel
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x1
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|1
operator|+
name|channel
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x1
expr_stmt|;
block|}
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc0
argument_list|,
name|sc3
argument_list|,
literal|0
argument_list|,
name|sdp
operator|->
name|isp_fifo_threshold
argument_list|,
name|sdp
operator|->
name|isp_initiator_id
argument_list|,
name|sdp
operator|->
name|isp_bus_reset_delay
argument_list|,
name|sdp
operator|->
name|isp_retry_count
argument_list|,
name|sdp
operator|->
name|isp_retry_delay
argument_list|,
name|sdp
operator|->
name|isp_async_data_setup
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc1
argument_list|,
name|sc3
argument_list|,
name|sdp
operator|->
name|isp_req_ack_active_neg
argument_list|,
name|sdp
operator|->
name|isp_data_line_active_neg
argument_list|,
name|sdp
operator|->
name|isp_data_dma_burst_enabl
argument_list|,
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
argument_list|,
name|sdp
operator|->
name|isp_selection_timeout
argument_list|,
name|sdp
operator|->
name|isp_max_queue_depth
argument_list|)
expr_stmt|;
comment|/* 	 * The trick here is to establish a default for the default (honk!) 	 * state (goal_flags). Then try and get the current status from 	 * the card to fill in the current state. We don't, in fact, set 	 * the default to the SAFE default state- that's not the goal state. 	 */
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|u_int8_t
name|off
decl_stmt|,
name|per
decl_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_offset
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_period
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_flags
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator|=
name|DPARM_DEFAULT
expr_stmt|;
comment|/* 		 * We default to Wide/Fast for versions less than a 1040 		 * (unless it's SBus). 		 */
if|if
condition|(
name|IS_ULTRA3
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|off
operator|=
name|ISP_80M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|per
operator|=
name|ISP_80M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|off
operator|=
name|ISP_40M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|per
operator|=
name|ISP_40M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1240
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|off
operator|=
name|ISP_20M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|per
operator|=
name|ISP_20M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_bustype
operator|==
name|ISP_BT_SBUS
operator|&&
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1020A
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_bustype
operator|==
name|ISP_BT_PCI
operator|&&
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1040
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_clock
operator|&&
name|isp
operator|->
name|isp_clock
operator|<
literal|60
operator|)
operator|||
operator|(
name|sdp
operator|->
name|isp_ultramode
operator|==
literal|0
operator|)
condition|)
block|{
name|off
operator|=
name|ISP_10M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|per
operator|=
name|ISP_10M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
name|ISP_20M_SYNCPARMS_1040
operator|>>
literal|8
expr_stmt|;
name|per
operator|=
name|ISP_20M_SYNCPARMS_1040
operator|&
literal|0xff
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_offset
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
operator|=
name|off
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_period
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
operator|=
name|per
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc2
argument_list|,
name|sc3
argument_list|,
name|channel
argument_list|,
name|tgt
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Re-initialize the ISP and complete all orphaned commands  * with a 'botched' notice. The reset/init routines should  * not disturb an already active list of commands.  *  * Locks held prior to coming here.  */
end_comment

begin_function
name|void
name|isp_reinit
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|XS_T
modifier|*
name|xs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
name|isp_reset
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RESETSTATE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"isp_reinit cannot reset card"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isp
operator|->
name|isp_role
operator|!=
name|ISP_ROLE_NONE
condition|)
block|{
name|isp_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|==
name|ISP_INITSTATE
condition|)
block|{
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RUNSTATE
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"isp_reinit cannot restart card"
argument_list|)
expr_stmt|;
block|}
block|}
name|isp
operator|->
name|isp_nactive
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isp
operator|->
name|isp_maxcmds
condition|;
name|i
operator|++
control|)
block|{
name|u_int16_t
name|handle
decl_stmt|;
name|xs
operator|=
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|handle
operator|=
name|isp_index_handle
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|isp_destroy_handle
argument_list|(
name|isp
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
name|isp_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * NVRAM Routines  */
end_comment

begin_function
specifier|static
name|int
name|isp_read_nvram
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|amt
decl_stmt|;
name|u_int8_t
name|csum
decl_stmt|,
name|minversion
decl_stmt|;
union|union
block|{
name|u_int8_t
name|_x
index|[
name|ISP2100_NVRAM_SIZE
index|]
decl_stmt|;
name|u_int16_t
name|_s
index|[
name|ISP2100_NVRAM_SIZE
operator|>>
literal|1
index|]
expr_stmt|;
block|}
name|_n
union|;
define|#
directive|define
name|nvram_data
value|_n._x
define|#
directive|define
name|nvram_words
value|_n._s
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|amt
operator|=
name|ISP2100_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|amt
operator|=
name|ISP1080_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|amt
operator|=
name|ISP_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Just read the first two words first to see if we have a valid 	 * NVRAM to continue reading the rest with. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|isp_rdnvram_word
argument_list|(
name|isp
argument_list|,
name|i
argument_list|,
operator|&
name|nvram_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvram_data
index|[
literal|0
index|]
operator|!=
literal|'I'
operator|||
name|nvram_data
index|[
literal|1
index|]
operator|!=
literal|'S'
operator|||
name|nvram_data
index|[
literal|2
index|]
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|!=
name|ISP_BT_SBUS
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"invalid NVRAM header"
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"%x %x %x"
argument_list|,
name|nvram_data
index|[
literal|0
index|]
argument_list|,
name|nvram_data
index|[
literal|1
index|]
argument_list|,
name|nvram_data
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|amt
operator|>>
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|isp_rdnvram_word
argument_list|(
name|isp
argument_list|,
name|i
argument_list|,
operator|&
name|nvram_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|amt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|nvram_data
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|csum
operator|!=
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"invalid NVRAM checksum"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ISP_NVRAM_VERSION
argument_list|(
name|nvram_data
argument_list|)
operator|<
name|minversion
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"version %d NVRAM not understood"
argument_list|,
name|ISP_NVRAM_VERSION
argument_list|(
name|nvram_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|IS_ULTRA3
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_parse_nvram_12160
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|,
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_12160
argument_list|(
name|isp
argument_list|)
condition|)
name|isp_parse_nvram_12160
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|,
name|nvram_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_parse_nvram_1080
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|,
name|nvram_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1280
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_1240
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_parse_nvram_1080
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|,
name|nvram_data
argument_list|)
expr_stmt|;
name|isp_parse_nvram_1080
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|,
name|nvram_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_parse_nvram_1020
argument_list|(
name|isp
argument_list|,
name|nvram_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isp_parse_nvram_2100
argument_list|(
name|isp
argument_list|,
name|nvram_data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|nvram_data
undef|#
directive|undef
name|nvram_words
block|}
end_function

begin_function
specifier|static
name|void
name|isp_rdnvram_word
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|wo
parameter_list|,
name|u_int16_t
modifier|*
name|rp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cbits
decl_stmt|;
name|u_int16_t
name|bit
decl_stmt|,
name|rqst
decl_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP2100_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|IS_2312
argument_list|(
name|isp
argument_list|)
operator|&&
name|isp
operator|->
name|isp_port
condition|)
block|{
name|wo
operator|+=
literal|128
expr_stmt|;
block|}
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|8
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP1080_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|8
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|6
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|8
expr_stmt|;
block|}
comment|/* 	 * Clock the word select request out... 	 */
for|for
control|(
name|i
operator|=
name|cbits
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|rqst
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|bit
operator|=
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_DATAOUT
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
name|BIU_NVRAM_SELECT
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now read the result back in (bits come back in MSB format). 	 */
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|u_int16_t
name|rv
decl_stmt|;
operator|*
name|rp
operator|<<=
literal|1
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&
name|BIU_NVRAM_DATAIN
condition|)
block|{
operator|*
name|rp
operator||=
literal|1
expr_stmt|;
block|}
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USEC_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_SWIZZLE_NVRAM_WORD
argument_list|(
name|isp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_parse_nvram_1020
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|u_int8_t
modifier|*
name|nvram_data
parameter_list|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|tgt
decl_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
name|ISP_NVRAM_FIFO_THRESHOLD
argument_list|(
name|nvram_data
argument_list|)
operator||
operator|(
name|ISP_NVRAM_FIFO_THRESHOLD_128
argument_list|(
name|nvram_data
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_OWNLOOPID
operator|)
operator|==
literal|0
condition|)
name|sdp
operator|->
name|isp_initiator_id
operator|=
name|ISP_NVRAM_INITIATOR_ID
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
name|ISP_NVRAM_BUS_RESET_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
name|ISP_NVRAM_BUS_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
name|ISP_NVRAM_BUS_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_async_data_setup
operator|=
name|ISP_NVRAM_ASYNC_DATA_SETUP_TIME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|>=
name|ISP_HA_SCSI_1040
condition|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_async_data_setup
operator|<
literal|9
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|9
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_async_data_setup
operator|!=
literal|6
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|6
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
name|ISP_NVRAM_REQ_ACK_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
name|ISP_NVRAM_DATA_LINE_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
name|ISP_NVRAM_DATA_DMA_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
name|ISP_NVRAM_CMD_DMA_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_tag_aging
operator|=
name|ISP_NVRAM_TAG_AGE_LIMIT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_selection_timeout
operator|=
name|ISP_NVRAM_SELECTION_TIMEOUT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|ISP_NVRAM_MAX_QUEUE_DEPTH
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_fast_mttr
operator|=
name|ISP_NVRAM_FAST_MTTR_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc0
argument_list|,
name|sc4
argument_list|,
literal|0
argument_list|,
name|sdp
operator|->
name|isp_fifo_threshold
argument_list|,
name|sdp
operator|->
name|isp_initiator_id
argument_list|,
name|sdp
operator|->
name|isp_bus_reset_delay
argument_list|,
name|sdp
operator|->
name|isp_retry_count
argument_list|,
name|sdp
operator|->
name|isp_retry_delay
argument_list|,
name|sdp
operator|->
name|isp_async_data_setup
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc1
argument_list|,
name|sc4
argument_list|,
name|sdp
operator|->
name|isp_req_ack_active_neg
argument_list|,
name|sdp
operator|->
name|isp_data_line_active_neg
argument_list|,
name|sdp
operator|->
name|isp_data_dma_burst_enabl
argument_list|,
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
argument_list|,
name|sdp
operator|->
name|isp_selection_timeout
argument_list|,
name|sdp
operator|->
name|isp_max_queue_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|=
name|ISP_NVRAM_TGT_DEVICE_ENABLE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
operator|=
name|ISP_NVRAM_TGT_EXEC_THROTTLE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
operator|=
name|ISP_NVRAM_TGT_SYNC_OFFSET
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
operator|=
name|ISP_NVRAM_TGT_SYNC_PERIOD
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
comment|/* 		 * We probably shouldn't lie about this, but it 		 * it makes it much safer if we limit NVRAM values 		 * to sanity. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1040
condition|)
block|{
comment|/* 			 * If we're not ultra, we can't possibly 			 * be a shorter period than this. 			 */
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
operator|<
literal|0x19
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
operator|=
literal|0x19
expr_stmt|;
block|}
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
operator|>
literal|0xc
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
operator|=
literal|0x0c
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
operator|>
literal|0x8
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
operator|=
literal|0x8
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_RENEG
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_RENEG
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_ARQ
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_TQING
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_SYNC
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_SYNC
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_WIDE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_WIDE
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_PARITY
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_PARITY
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_DISC
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_DISC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_flags
operator|=
literal|0
expr_stmt|;
comment|/* we don't know */
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc2
argument_list|,
name|sc4
argument_list|,
literal|0
argument_list|,
name|tgt
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_offset
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_period
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_parse_nvram_1080
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|bus
parameter_list|,
name|u_int8_t
modifier|*
name|nvram_data
parameter_list|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|tgt
decl_stmt|;
name|sdp
operator|+=
name|bus
expr_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
name|ISP1080_NVRAM_FIFO_THRESHOLD
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_OWNLOOPID
operator|)
operator|==
literal|0
condition|)
name|sdp
operator|->
name|isp_initiator_id
operator|=
name|ISP1080_NVRAM_INITIATOR_ID
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
name|ISP1080_NVRAM_BUS_RESET_DELAY
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
name|ISP1080_NVRAM_BUS_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
name|ISP1080_NVRAM_BUS_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_async_data_setup
operator|=
name|ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
name|ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
name|ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
name|ISP1080_NVRAM_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
name|ISP1080_NVRAM_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_selection_timeout
operator|=
name|ISP1080_NVRAM_SELECTION_TIMEOUT
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|ISP1080_NVRAM_MAX_QUEUE_DEPTH
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc0
argument_list|,
name|sc4
argument_list|,
name|bus
argument_list|,
name|sdp
operator|->
name|isp_fifo_threshold
argument_list|,
name|sdp
operator|->
name|isp_initiator_id
argument_list|,
name|sdp
operator|->
name|isp_bus_reset_delay
argument_list|,
name|sdp
operator|->
name|isp_retry_count
argument_list|,
name|sdp
operator|->
name|isp_retry_delay
argument_list|,
name|sdp
operator|->
name|isp_async_data_setup
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc1
argument_list|,
name|sc4
argument_list|,
name|sdp
operator|->
name|isp_req_ack_active_neg
argument_list|,
name|sdp
operator|->
name|isp_data_line_active_neg
argument_list|,
name|sdp
operator|->
name|isp_data_dma_burst_enabl
argument_list|,
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
argument_list|,
name|sdp
operator|->
name|isp_selection_timeout
argument_list|,
name|sdp
operator|->
name|isp_max_queue_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|=
name|ISP1080_NVRAM_TGT_DEVICE_ENABLE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
operator|=
name|ISP1080_NVRAM_TGT_EXEC_THROTTLE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
operator|=
name|ISP1080_NVRAM_TGT_SYNC_OFFSET
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
operator|=
name|ISP1080_NVRAM_TGT_SYNC_PERIOD
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_RENEG
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_RENEG
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_ARQ
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_TQING
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_SYNC
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_SYNC
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_WIDE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_WIDE
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_PARITY
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_PARITY
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_DISC
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_DISC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_flags
operator|=
literal|0
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc2
argument_list|,
name|sc4
argument_list|,
name|bus
argument_list|,
name|tgt
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_offset
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_period
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_parse_nvram_12160
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|int
name|bus
parameter_list|,
name|u_int8_t
modifier|*
name|nvram_data
parameter_list|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|tgt
decl_stmt|;
name|sdp
operator|+=
name|bus
expr_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
name|ISP12160_NVRAM_FIFO_THRESHOLD
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_OWNLOOPID
operator|)
operator|==
literal|0
condition|)
name|sdp
operator|->
name|isp_initiator_id
operator|=
name|ISP12160_NVRAM_INITIATOR_ID
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
name|ISP12160_NVRAM_BUS_RESET_DELAY
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
name|ISP12160_NVRAM_BUS_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
name|ISP12160_NVRAM_BUS_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_async_data_setup
operator|=
name|ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
name|ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
name|ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
name|ISP12160_NVRAM_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
name|ISP12160_NVRAM_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_selection_timeout
operator|=
name|ISP12160_NVRAM_SELECTION_TIMEOUT
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|ISP12160_NVRAM_MAX_QUEUE_DEPTH
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc0
argument_list|,
name|sc4
argument_list|,
name|bus
argument_list|,
name|sdp
operator|->
name|isp_fifo_threshold
argument_list|,
name|sdp
operator|->
name|isp_initiator_id
argument_list|,
name|sdp
operator|->
name|isp_bus_reset_delay
argument_list|,
name|sdp
operator|->
name|isp_retry_count
argument_list|,
name|sdp
operator|->
name|isp_retry_delay
argument_list|,
name|sdp
operator|->
name|isp_async_data_setup
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc1
argument_list|,
name|sc4
argument_list|,
name|sdp
operator|->
name|isp_req_ack_active_neg
argument_list|,
name|sdp
operator|->
name|isp_data_line_active_neg
argument_list|,
name|sdp
operator|->
name|isp_data_dma_burst_enabl
argument_list|,
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
argument_list|,
name|sdp
operator|->
name|isp_selection_timeout
argument_list|,
name|sdp
operator|->
name|isp_max_queue_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|=
name|ISP12160_NVRAM_TGT_DEVICE_ENABLE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
operator|=
name|ISP12160_NVRAM_TGT_EXEC_THROTTLE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
operator|=
name|ISP12160_NVRAM_TGT_SYNC_OFFSET
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
operator|=
name|ISP12160_NVRAM_TGT_SYNC_PERIOD
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISP12160_NVRAM_TGT_RENEG
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_RENEG
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_ARQ
expr_stmt|;
if|if
condition|(
name|ISP12160_NVRAM_TGT_TQING
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP12160_NVRAM_TGT_SYNC
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_SYNC
expr_stmt|;
if|if
condition|(
name|ISP12160_NVRAM_TGT_WIDE
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_WIDE
expr_stmt|;
if|if
condition|(
name|ISP12160_NVRAM_TGT_PARITY
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_PARITY
expr_stmt|;
if|if
condition|(
name|ISP12160_NVRAM_TGT_DISC
argument_list|(
name|nvram_data
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
operator||=
name|DPARM_DISC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|actv_flags
operator|=
literal|0
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
name|sc2
argument_list|,
name|sc4
argument_list|,
name|bus
argument_list|,
name|tgt
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_offset
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_offset
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_period
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_period
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|goal_flags
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|nvrm_flags
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_parse_nvram_2100
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|u_int8_t
modifier|*
name|nvram_data
parameter_list|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|u_int64_t
name|wwn
decl_stmt|;
comment|/* 	 * There is NVRAM storage for both Port and Node entities- 	 * but the Node entity appears to be unused on all the cards 	 * I can find. However, we should account for this being set 	 * at some point in the future. 	 * 	 * Qlogic WWNs have an NAA of 2, but usually nothing shows up in 	 * bits 48..60. In the case of the 2202, it appears that they do 	 * use bit 48 to distinguish between the two instances on the card. 	 * The 2204, which I've never seen, *probably* extends this method. 	 */
name|wwn
operator|=
name|ISP2100_NVRAM_PORT_NAME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|wwn
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"NVRAM Port WWN 0x%08x%08x"
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|wwn
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|wwn
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wwn
operator|>>
literal|60
operator|)
operator|==
literal|0
condition|)
block|{
name|wwn
operator||=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
literal|2
operator|)
operator|<<
literal|60
operator|)
expr_stmt|;
block|}
block|}
name|fcp
operator|->
name|isp_portwwn
operator|=
name|wwn
expr_stmt|;
if|if
condition|(
name|IS_2200
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|wwn
operator|=
name|ISP2200_NVRAM_NODE_NAME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|wwn
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"NVRAM Node WWN 0x%08x%08x"
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|wwn
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|wwn
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wwn
operator|>>
literal|60
operator|)
operator|==
literal|0
condition|)
block|{
name|wwn
operator||=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
literal|2
operator|)
operator|<<
literal|60
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|wwn
operator|&=
operator|~
operator|(
operator|(
name|u_int64_t
operator|)
literal|0xfff
operator|<<
literal|48
operator|)
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_nodewwn
operator|=
name|wwn
expr_stmt|;
comment|/* 	 * Make sure we have both Node and Port as non-zero values. 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_nodewwn
operator|!=
literal|0
operator|&&
name|fcp
operator|->
name|isp_portwwn
operator|==
literal|0
condition|)
block|{
name|fcp
operator|->
name|isp_portwwn
operator|=
name|fcp
operator|->
name|isp_nodewwn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fcp
operator|->
name|isp_nodewwn
operator|==
literal|0
operator|&&
name|fcp
operator|->
name|isp_portwwn
operator|!=
literal|0
condition|)
block|{
name|fcp
operator|->
name|isp_nodewwn
operator|=
name|fcp
operator|->
name|isp_portwwn
expr_stmt|;
block|}
comment|/* 	 * Make the Node and Port values sane if they're NAA == 2. 	 * This means to clear bits 48..56 for the Node WWN and 	 * make sure that there's some non-zero value in 48..56 	 * for the Port WWN. 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_nodewwn
operator|&&
name|fcp
operator|->
name|isp_portwwn
condition|)
block|{
if|if
condition|(
operator|(
name|fcp
operator|->
name|isp_nodewwn
operator|&
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
literal|0xfff
operator|)
operator|<<
literal|48
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|fcp
operator|->
name|isp_nodewwn
operator|>>
literal|60
operator|)
operator|==
literal|2
condition|)
block|{
name|fcp
operator|->
name|isp_nodewwn
operator|&=
operator|~
operator|(
operator|(
name|u_int64_t
operator|)
literal|0xfff
operator|<<
literal|48
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fcp
operator|->
name|isp_portwwn
operator|&
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
literal|0xfff
operator|)
operator|<<
literal|48
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|fcp
operator|->
name|isp_portwwn
operator|>>
literal|60
operator|)
operator|==
literal|2
condition|)
block|{
name|fcp
operator|->
name|isp_portwwn
operator||=
operator|(
operator|(
name|u_int64_t
operator|)
literal|1
operator|<<
literal|56
operator|)
expr_stmt|;
block|}
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGDEBUG0
argument_list|,
literal|"NVRAM: maxfrmlen %d execthrottle %d fwoptions 0x%x loopid %x"
argument_list|,
name|ISP2100_NVRAM_MAXFRAMELENGTH
argument_list|(
name|nvram_data
argument_list|)
argument_list|,
name|ISP2100_NVRAM_EXECUTION_THROTTLE
argument_list|(
name|nvram_data
argument_list|)
argument_list|,
name|ISP2100_NVRAM_OPTIONS
argument_list|(
name|nvram_data
argument_list|)
argument_list|,
name|ISP2100_NVRAM_HARDLOOPID
argument_list|(
name|nvram_data
argument_list|)
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_maxalloc
operator|=
name|ISP2100_NVRAM_MAXIOCBALLOCATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_OWNFSZ
operator|)
operator|==
literal|0
condition|)
name|fcp
operator|->
name|isp_maxfrmlen
operator|=
name|ISP2100_NVRAM_MAXFRAMELENGTH
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_delay
operator|=
name|ISP2100_NVRAM_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_count
operator|=
name|ISP2100_NVRAM_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_OWNLOOPID
operator|)
operator|==
literal|0
condition|)
name|fcp
operator|->
name|isp_loopid
operator|=
name|ISP2100_NVRAM_HARDLOOPID
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_OWNEXCTHROTTLE
operator|)
operator|==
literal|0
condition|)
name|fcp
operator|->
name|isp_execthrottle
operator|=
name|ISP2100_NVRAM_EXECUTION_THROTTLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator|=
name|ISP2100_NVRAM_OPTIONS
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISP_FW_CRASH_DUMP
end_ifdef

begin_function_decl
specifier|static
name|void
name|isp2200_fw_dump
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isp2300_fw_dump
parameter_list|(
name|struct
name|ispsoftc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|isp2200_fw_dump
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_dump_data
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"No place to dump RISC registers and SRAM"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"dump area for RISC registers and SRAM already used"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_PAUSE
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_PAUSE
condition|)
block|{
comment|/* 		 * PBIU Registers 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Mailbox Registers 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|MBOX_BLOCK
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * DMA Registers 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|48
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DMA_BLOCK
operator|+
literal|0x20
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * RISC H/W Registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0xA0
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * RISC GP Registers 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0xA4
argument_list|,
literal|0x2000
operator|+
operator|(
name|j
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Frame Buffer Hardware Registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Fibre Protocol Module 0 Hardware Registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Fibre Protocol Module 1 Hardware Registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"RISC Would Not Pause"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGALL
argument_list|,
literal|"isp_fw_dump: RISC registers dumped successfully"
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_SOFT_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Board Would Not Reset"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_PAUSE
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_PAUSE
operator|)
operator|==
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"RISC Would Not Pause After Reset"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_EMB
argument_list|,
literal|0xf2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_PAUSE
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_READ_RAM_WORD
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0x1000
expr_stmt|;
name|isp
operator|->
name|isp_mbxworkp
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|isp
operator|->
name|isp_mbxwrk0
operator|=
literal|0xefff
expr_stmt|;
comment|/* continuation count */
name|isp
operator|->
name|isp_mbxwrk1
operator|=
literal|0x1001
expr_stmt|;
comment|/* next SRAM address */
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_RUN_MBOXCMD
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"RAM DUMP FAILED @ WORD %x"
argument_list|,
name|isp
operator|->
name|isp_mbxwrk1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|isp
operator|->
name|isp_mbxworkp
expr_stmt|;
comment|/* finish fetch of final word */
operator|*
name|ptr
operator|++
operator|=
name|isp
operator|->
name|isp_mboxtmp
index|[
literal|2
index|]
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGALL
argument_list|,
literal|"isp_fw_dump: SRAM dumped successfully"
argument_list|)
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_dump_data
index|[
literal|0
index|]
operator|=
name|isp
operator|->
name|isp_type
expr_stmt|;
comment|/* now used */
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FW_DUMPED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp2300_fw_dump
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_dump_data
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"No place to dump RISC registers and SRAM"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"dump area for RISC registers and SRAM already used"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_PAUSE
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_PAUSE
condition|)
block|{
comment|/* 		 * PBIU registers 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * ReqQ-RspQ-Risc2Host Status registers 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x10
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Mailbox Registers 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|PCI_MBOX_REGS2300_OFF
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Auto Request Response DMA registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * DMA registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|48
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * RISC hardware registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0xA0
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * RISC GP? registers 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0xA4
argument_list|,
literal|0x2000
operator|+
operator|(
name|j
operator|<<
literal|9
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * frame buffer hardware registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * FPM B0 hardware registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * FPM B1 hardware registers 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_BLOCK
operator|+
literal|0x80
operator|+
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"RISC Would Not Pause"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGALL
argument_list|,
literal|"isp_fw_dump: RISC registers dumped successfully"
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_SOFT_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|USEC_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"Board Would Not Reset"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_READ_RAM_WORD
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0x800
expr_stmt|;
name|isp
operator|->
name|isp_mbxworkp
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|isp
operator|->
name|isp_mbxwrk0
operator|=
literal|0xf7ff
expr_stmt|;
comment|/* continuation count */
name|isp
operator|->
name|isp_mbxwrk1
operator|=
literal|0x801
expr_stmt|;
comment|/* next SRAM address */
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_RUN_MBOXCMD
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"RAM DUMP FAILED @ WORD %x"
argument_list|,
name|isp
operator|->
name|isp_mbxwrk1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|isp
operator|->
name|isp_mbxworkp
expr_stmt|;
comment|/* finish fetch of final word */
operator|*
name|ptr
operator|++
operator|=
name|isp
operator|->
name|isp_mboxtmp
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * We don't have access to mailbox registers 8.. onward 	 * in our 'common' device model- so we have to set it 	 * here and hope it stays the same! 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|PCI_MBOX_REGS2300_OFF
operator|+
operator|(
literal|8
operator|<<
literal|1
operator|)
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_READ_RAM_WORD_EXTENDED
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_mbxworkp
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|isp
operator|->
name|isp_mbxwrk0
operator|=
literal|0xffff
expr_stmt|;
comment|/* continuation count */
name|isp
operator|->
name|isp_mbxwrk1
operator|=
literal|0x1
expr_stmt|;
comment|/* next SRAM address */
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_RUN_MBOXCMD
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGWARN
argument_list|,
literal|"RAM DUMP FAILED @ WORD %x"
argument_list|,
literal|0x10000
operator|+
name|isp
operator|->
name|isp_mbxwrk1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|isp
operator|->
name|isp_mbxworkp
expr_stmt|;
comment|/* finish final word */
operator|*
name|ptr
operator|++
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGALL
argument_list|,
literal|"isp_fw_dump: SRAM dumped successfully"
argument_list|)
expr_stmt|;
name|FCPARAM
argument_list|(
name|isp
argument_list|)
operator|->
name|isp_dump_data
index|[
literal|0
index|]
operator|=
name|isp
operator|->
name|isp_type
expr_stmt|;
comment|/* now used */
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FW_DUMPED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isp_fw_dump
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
if|if
condition|(
name|IS_2200
argument_list|(
name|isp
argument_list|)
condition|)
name|isp2200_fw_dump
argument_list|(
name|isp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_23XX
argument_list|(
name|isp
argument_list|)
condition|)
name|isp2300_fw_dump
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

