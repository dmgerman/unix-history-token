begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: isp.c,v 1.17 1999/04/04 02:28:29 mjacob Exp $ */
end_comment

begin_comment
comment|/* release_4_3_99+ */
end_comment

begin_comment
comment|/*  * Machine and OS Independent (well, as best as possible)  * code for the Qlogic ISP SCSI adapters.  *  * Copyright (c) 1997, 1998 by Matthew Jacob  * NASA/Ames Research Center  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Inspiration and ideas about this driver are from Erik Moe's Linux driver  * (qlogicisp.c) and Dave Miller's SBus version of same (qlogicisp.c). Some  * ideas dredged from the Solaris driver.  */
end_comment

begin_comment
comment|/*  * Include header file appropriate for platform we're building on.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/isp_netbsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/isp/isp_freebsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/isp_openbsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|"isp_linux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * General defines  */
end_comment

begin_define
define|#
directive|define
name|MBOX_DELAY_COUNT
value|1000000 / 100
end_define

begin_comment
comment|/*  * Local static data  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|tgtiqd
index|[
literal|36
index|]
init|=
block|{
literal|0x03
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x51
block|,
literal|0x4C
block|,
literal|0x4F
block|,
literal|0x47
block|,
literal|0x49
block|,
literal|0x43
block|,
literal|0x20
block|,
literal|0x20
block|,
ifdef|#
directive|ifdef
name|__NetBSD__
literal|0x4E
block|,
literal|0x45
block|,
literal|0x54
block|,
literal|0x42
block|,
literal|0x53
block|,
literal|0x44
block|,
literal|0x20
block|,
literal|0x20
block|,
else|#
directive|else
ifdef|#
directive|ifdef
name|__FreeBSD__
literal|0x46
block|,
literal|0x52
block|,
literal|0x45
block|,
literal|0x45
block|,
literal|0x42
block|,
literal|0x52
block|,
literal|0x44
block|,
literal|0x20
block|,
else|#
directive|else
ifdef|#
directive|ifdef
name|__OpenBSD__
literal|0x4F
block|,
literal|0x50
block|,
literal|0x45
block|,
literal|0x4E
block|,
literal|0x42
block|,
literal|0x52
block|,
literal|0x44
block|,
literal|0x20
block|,
else|#
directive|else
ifdef|#
directive|ifdef
name|linux
literal|0x4C
block|,
literal|0x49
block|,
literal|0x4E
block|,
literal|0x55
block|,
literal|0x58
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
else|#
directive|else
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
literal|0x54
block|,
literal|0x41
block|,
literal|0x52
block|,
literal|0x47
block|,
literal|0x45
block|,
literal|0x54
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x31
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local function prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|isp_parse_async
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_handle_other_response
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ispstatusreq_t
operator|*
operator|,
name|u_int8_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|isp_modify_lun
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_notify_ack
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_handle_atio
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_handle_atio2
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_handle_ctio
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_handle_ctio2
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|isp_parse_status
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ispstatusreq_t
operator|*
operator|,
name|ISP_SCSI_XFER_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_fastpost_complete
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_fibre_init
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_mark_getpdb_all
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_getpdb
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|isp_pdb_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_fclink_test
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_fw_state
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_dumpregs
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_dumpxflist
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_mboxcmd
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|mbreg_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_update
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_setdfltparm
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_read_nvram
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_rdnvram_word
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|u_int16_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reset Hardware.  *  * Hit the chip over the head, download new f/w and set it running.  *  * Locking done elsewhere.  */
end_comment

begin_function
name|void
name|isp_reset
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|loops
decl_stmt|,
name|i
decl_stmt|,
name|dodnld
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|revname
decl_stmt|;
name|isp
operator|->
name|isp_state
operator|=
name|ISP_NILSTATE
expr_stmt|;
comment|/* 	 * Basic types (SCSI, FibreChannel and PCI or SBus) 	 * have been set in the MD code. We figure out more 	 * here. 	 */
name|isp
operator|->
name|isp_dblev
operator|=
name|DFLT_DBLEVEL
expr_stmt|;
comment|/* 	 * After we've fired this chip up, zero out the conf1 register 	 * for SCSI adapters and other settings for the 2100. 	 */
comment|/* 	 * Get the current running firmware revision out of the 	 * chip before we hit it over the head (if this is our 	 * first time through). Note that we store this as the 	 * 'ROM' firmware revision- which it may not be. In any 	 * case, we don't really use this yet, but we may in 	 * the future. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_used
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Just in case it was paused... 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABOUT_FIRMWARE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
comment|/* 		 * If this fails, it probably means we're running 		 * an old prom, if anything at all... 		 */
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
expr_stmt|;
block|}
name|isp
operator|->
name|isp_used
operator|=
literal|1
expr_stmt|;
block|}
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Put it into PAUSE mode. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Do a little register testing. 	 */
block|ISP_WRITE(isp, CDMA_COUNT, 0); 	ISP_WRITE(isp, CDMA_ADDR0, 0xdead); 	ISP_WRITE(isp, CDMA_ADDR1, 0xbeef); 	ISP_WRITE(isp, CDMA_ADDR2, 0xffff); 	ISP_WRITE(isp, CDMA_ADDR3, 0x1111); 	PRINTF("%s: (0,dead,beef,ffff,1111):\n", isp->isp_name); 	PRINTF("0x%x 0x%x 0x%x 0x%x 0x%x\n", ISP_READ(isp, CDMA_COUNT), 	    ISP_READ(isp, CDMA_ADDR0), ISP_READ(isp, CDMA_ADDR1), 	    ISP_READ(isp, CDMA_ADDR2), ISP_READ(isp, CDMA_ADDR3));
endif|#
directive|endif
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|revname
operator|=
literal|"2100"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|u_int16_t
name|l
decl_stmt|;
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|revname
operator|=
literal|"1080"
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|100
expr_stmt|;
name|l
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_DIFF
argument_list|)
operator|&
name|ISP1080_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|l
condition|)
block|{
case|case
name|ISP1080_LVD_MODE
case|:
name|sdp
operator|->
name|isp_lvdmode
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: LVD Mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP1080_HVD_MODE
case|:
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Differential Mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP1080_SE_MODE
case|:
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Single-Ended Mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Hmm. Up in a wierd mode. This means all SCSI I/O 			 * buffer lines are tristated, so we're in a lot of 			 * trouble if we don't set things up right. 			 */
name|PRINTF
argument_list|(
literal|"%s: Illegal Mode 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|i
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_CONF0
argument_list|)
operator|&
name|BIU_CONF0_HW_MASK
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|PRINTF
argument_list|(
literal|"%s: unknown chip rev. 0x%x- assuming a 1020\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|revname
operator|=
literal|"1020"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1020
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * Some 1020A chips are Ultra Capable, but don't 			 * run the clock rate up for that unless told to 			 * do so by the Ultra Capable bits being set. 			 */
name|revname
operator|=
literal|"1020A"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1020A
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|revname
operator|=
literal|"1040"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|revname
operator|=
literal|"1040A"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040A
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|revname
operator|=
literal|"1040B"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040B
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|revname
operator|=
literal|"1040C(?)"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040C
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
block|}
comment|/* 		 * Now, while we're at it, gather info about ultra 		 * and/or differential mode. 		 */
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_DIFF
argument_list|)
operator|&
name|SXP_PINS_DIFF_MODE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Differential Mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|RISC_PSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|==
name|ISP_BT_SBUS
condition|)
block|{
name|i
operator|&=
name|RISC_PSR_SBUS_ULTRA
expr_stmt|;
block|}
else|else
block|{
name|i
operator|&=
name|RISC_PSR_PCI_ULTRA
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Ultra Mode Capable\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If we're in Ultra Mode, we have to be 60Mhz clock- 			 * even for the SBus version. 			 */
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Clock is known. Gronk. 			 */
block|}
comment|/* 		 * Machine dependent clock (if set) overrides 		 * our generic determinations. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
operator|<
name|sdp
operator|->
name|isp_clock
condition|)
block|{
name|sdp
operator|->
name|isp_clock
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Do MD specific pre initialization 	 */
name|ISP_RESET0
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* 	 * Hit the chip over the head with hammer, 	 * and give the ISP a chance to recover. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|,
name|BIU_ICR_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 		 * A slight delay... 		 */
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|PRINTF("%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 		    isp->isp_name, ISP_READ(isp, OUTMAILBOX0), 		    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2), 		    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4), 		    ISP_READ(isp, OUTMAILBOX5));
endif|#
directive|endif
comment|/* 		 * Clear data&& control DMA engines. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|CDMA_CONTROL
argument_list|,
name|DMA_CNTRL_CLEAR_CHAN
operator||
name|DMA_CNTRL_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|DDMA_CONTROL
argument_list|,
name|DMA_CNTRL_CLEAR_CHAN
operator||
name|DMA_CNTRL_RESET_INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 		 * A slight delay... 		 */
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Clear data&& control DMA engines. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|CDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|TDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for ISP to be ready to go... 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|)
operator|&
name|BIU_ICR_SOFT_RESET
operator|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
operator|&
name|BIU2100_SOFT_RESET
operator|)
condition|)
break|break;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"chip reset timed out"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * After we've fired this chip up, zero out the conf1 register 	 * for SCSI adapters and other settings for the 2100. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset RISC Processor 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RESET
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 	 * Establish some initial burst rate stuff. 	 * (only for the 1XX0 boards). This really should 	 * be done later after fetching from NVRAM. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|u_int16_t
name|tmp
init|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_conf1
decl_stmt|;
comment|/* 		 * Busted FIFO. Turn off all but burst enables. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|==
name|ISP_HA_SCSI_1040A
condition|)
block|{
name|tmp
operator|&=
name|BIU_BURST_ENABLE
expr_stmt|;
block|}
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|BIU_BURST_ENABLE
condition|)
block|{
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|CDMA_CONF
argument_list|,
name|DMA_ENABLE_BURST
argument_list|)
expr_stmt|;
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|DDMA_CONF
argument_list|,
name|DMA_ENABLE_BURST
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PTI_CARDS
if|if
condition|(
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
condition|)
block|{
while|while
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|)
operator|!=
literal|0x1313
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1313
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_STEP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * PTI specific register 		 */
name|ISP_WRITE
argument_list|(
argument|isp
argument_list|,
argument|RISC_EMB
argument_list|,
argument|DUAL_BANK
argument_list|)
else|#
directive|else
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR2100
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
comment|/* release paused processor */
comment|/* 	 * Do MD specific post initialization 	 */
name|ISP_RESET1
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Enable interrupts 	 */
block|ENABLE_INTS(isp);
endif|#
directive|endif
comment|/* 	 * Wait for everything to finish firing up... 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|==
name|MBOX_BUSY
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: MBOX_BUSY never cleared on reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Up until this point we've done everything by just reading or 	 * setting registers. From this point on we rely on at least *some* 	 * kind of firmware running in the card. 	 */
comment|/* 	 * Do some sanity checking. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_NO_OP
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"NOP test failed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_MAILBOX_REG_TEST
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0xdead
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0xbeef
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0x1111
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0xa5a5
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"Mailbox Register test didn't complete"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0xdead
operator|||
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|!=
literal|0xbeef
operator|||
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|!=
literal|0xffff
operator|||
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|!=
literal|0x1111
operator|||
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|!=
literal|0xa5a5
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"Register Test Failed"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Download new Firmware, unless requested not to do so. 	 * This is made slightly trickier in some cases where the 	 * firmware of the ROM revision is newer than the revision 	 * compiled into the driver. So, where we used to compare 	 * versions of our f/w and the ROM f/w, now we just see 	 * whether we have f/w at all and whether a config flag 	 * has disabled our download. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NORELOAD
operator|)
condition|)
block|{
name|dodnld
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dodnld
operator|&&
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
condition|;
name|i
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_WRITE_RAM_WORD
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
operator|+
name|i
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_ispfw
index|[
name|i
index|]
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: F/W download failed at word %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dodnld
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* 		 * Verify that it downloaded correctly. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_VERIFY_CHECKSUM
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"ram checksum failure"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: skipping f/w download\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now start it rolling. 	 * 	 * If we didn't actually download f/w, 	 * we still need to (re)start it. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_EXEC_FIRMWARE
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
expr_stmt|;
else|else
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0x1000
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
comment|/* 		 * Set CLOCK RATE, but only if asked to. 		 */
if|if
condition|(
name|sdp
operator|->
name|isp_clock
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_CLOCK_RATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_clock
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set CLOCKRATE"
argument_list|)
expr_stmt|;
comment|/* but continue */
block|}
else|else
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: setting input clock to %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|sdp
operator|->
name|isp_clock
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABOUT_FIRMWARE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"ABOUT FIRMWARE command failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: Board Revision %s, %s F/W Revision %d.%d.%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|revname
argument_list|,
name|dodnld
condition|?
literal|"loaded"
else|:
literal|"resident"
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
operator|&
name|BIU2100_PCI64
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: in 64-Bit PCI slot\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
block|}
name|isp
operator|->
name|isp_fwrev
index|[
literal|0
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
index|[
literal|1
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
index|[
literal|2
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
operator|||
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
operator|||
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Last F/W revision was %d.%d.%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|isp_fw_state
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RESETSTATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize Parameters of Hardware to a known state.  *  * Locks are held before coming here.  */
end_comment

begin_function
name|void
name|isp_init
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|sdparam
modifier|*
name|sdp
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|tgt
decl_stmt|;
comment|/* 	 * Must do first. 	 */
name|isp_setdfltparm
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Set up DMA for the request and result mailboxes. 	 */
if|if
condition|(
name|ISP_MBOXDMASETUP
argument_list|(
name|isp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: can't setup dma mailboxes\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're fibre, we have a completely different 	 * initialization method. 	 */
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_fibre_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return;
block|}
name|sdp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
comment|/* 	 * If we have fast memory timing enabled, turn it on. 	 */
if|if
condition|(
name|sdp
operator|->
name|isp_fast_mttr
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1313
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set (possibly new) Initiator ID. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_INIT_SCSI_ID
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_initiator_id
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set initiator id"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set Retry Delay and Count 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_RETRY_COUNT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_retry_count
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_retry_delay
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set retry count and delay"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set ASYNC DATA SETUP time. This is very important. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_ASYNC_DATA_SETUP_TIME
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_async_data_setup
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set async data setup time"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set ACTIVE Negation State. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_ACTIVE_NEG_STATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|<<
literal|4
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_data_line_active_neg
operator|<<
literal|5
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set active neg state"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set the Tag Aging limit 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TAG_AGE_LIMIT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_tag_aging
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set tag age limit"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set selection timeout. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_SELECT_TIMEOUT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_selection_timeout
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set selection timeout"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set current per-target parameters to a safe minimum. 	 */
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|int
name|maxlun
decl_stmt|,
name|lun
decl_stmt|;
name|u_int16_t
name|sdf
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|&&
name|sdp
operator|->
name|isp_lvdmode
condition|)
block|{
name|sdf
operator|=
name|DPARM_DEFAULT
operator|&
operator|~
name|DPARM_TQING
expr_stmt|;
block|}
else|else
block|{
name|sdf
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
comment|/* 			 * It is not quite clear when this changed over so that 			 * we could force narrow and async, so assume>= 7.55. 			 */
if|if
condition|(
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|>=
name|ISP_FW_REV
argument_list|(
literal|7
argument_list|,
literal|55
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|sdf
operator||=
name|DPARM_NARROW
operator||
name|DPARM_ASYNC
expr_stmt|;
block|}
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdf
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|sdf
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdf
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed even to set defaults for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * We don't update dev_flags with what we've set 		 * because that's not the ultimate goal setting. 		 * If we succeed with the command, we *do* update 		 * cur_dflags by getting target parameters. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|tgt
operator|<<
literal|8
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
comment|/* 			 * Urrr.... We'll set cur_dflags to DPARM_SAFE_DFLT so 			 * we don't try and do tags if tags aren't enabled. 			 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: set flags 0x%x got 0x%x back for target %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|sdf
operator|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|,
name|tgt
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that we don't believe tagged queuing is enabled yet. 		 * It turns out that sometimes the ISP just ignores our 		 * attempts to set parameters for devices that it hasn't 		 * seen yet. 		 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|&=
operator|~
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|>=
name|ISP_FW_REV
argument_list|(
literal|7
argument_list|,
literal|55
argument_list|,
literal|0
argument_list|)
condition|)
name|maxlun
operator|=
literal|32
expr_stmt|;
else|else
name|maxlun
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|maxlun
condition|;
name|lun
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_DEV_QUEUE_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
name|lun
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_max_queue_depth
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set device queue "
literal|"parameters for target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|,
name|lun
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * And mark this as an unannounced device 		 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_announced
operator|=
literal|0
expr_stmt|;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_RES_QUEUE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RESULT_QUEUE_LEN
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"set of response queue failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_residx
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_REQ_QUEUE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RQUEST_QUEUE_LEN
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"set of request queue failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Turn on Fast Posting, LVD transitions 	 */
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|||
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|>=
name|ISP_FW_REV
argument_list|(
literal|7
argument_list|,
literal|55
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_FW_FEATURES
expr_stmt|;
ifndef|#
directive|ifndef
name|ISP_NO_FASTPOST_SCSI
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
name|FW_FEATURE_FAST_POST
expr_stmt|;
else|#
directive|else
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
name|FW_FEATURE_LVD_NOTIFY
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: unable enable FW features\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Let the outer layers decide whether to issue a SCSI bus reset. 	 */
if|#
directive|if
literal|0
comment|/* 	 * XXX: See whether or not for 7.55 F/W or later we 	 * XXX: can do without this, and see whether we should 	 * XXX: honor the NVRAM SCSI_RESET_DISABLE token. 	 */
block|mbs.param[0] = MBOX_BUS_RESET; 	mbs.param[1] = 3; 	isp_mboxcmd(isp,&mbs); 	if (mbs.param[0] != MBOX_COMMAND_COMPLETE) { 		isp_dumpregs(isp, "SCSI bus reset failed"); 	}
comment|/* 	 * This is really important to have set after a bus reset. 	 */
block|isp->isp_sendmarker = 1;
endif|#
directive|endif
name|isp
operator|->
name|isp_state
operator|=
name|ISP_INITSTATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fibre Channel specific initialization.  *  * Locks are held before coming here.  */
end_comment

begin_function
specifier|static
name|void
name|isp_fibre_init
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|fcparam
modifier|*
name|fcp
decl_stmt|;
name|isp_icb_t
modifier|*
name|icbp
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|count
decl_stmt|,
name|loopid
decl_stmt|;
name|fcp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
comment|/* 	 * For systems that don't have BIOS methods for which 	 * we can easily change the NVRAM based loopid, we'll 	 * override that here. Note that when we initialize 	 * the firmware we may get back a different loopid than 	 * we asked for anyway. XXX This is probably not the 	 * best way to figure this out XXX 	 */
ifndef|#
directive|ifndef
name|__i386__
name|loopid
operator|=
name|DEFAULT_LOOPID
expr_stmt|;
else|#
directive|else
name|loopid
operator|=
name|fcp
operator|->
name|isp_loopid
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_FABRIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISP2100_SCCLUN
argument_list|)
name|PRINTF
argument_list|(
literal|"%s: Fabric Support, Expanded Lun Support\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_FABRIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ISP2100_SCCLUN
argument_list|)
name|PRINTF
argument_list|(
literal|"%s: Fabric Support\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ISP2100_FABRIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISP2100_SCCLUN
argument_list|)
name|PRINTF
argument_list|(
literal|"%s: Expanded Lun Support\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|icbp
operator|=
operator|(
name|isp_icb_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
expr_stmt|;
name|MEMZERO
argument_list|(
name|icbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|icbp
argument_list|)
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_version
operator|=
name|ICB_VERSION1
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|fcp
operator|->
name|isp_fwoptions
operator|=
name|ICBOPT_TGT_ENABLE
operator||
name|ICBOPT_INI_TGTTYPE
expr_stmt|;
else|#
directive|else
name|fcp
operator|->
name|isp_fwoptions
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_INI_ADISC
operator||
name|ICBOPT_FAIRNESS
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_PDBCHANGE_AE
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_HARD_ADDRESS
expr_stmt|;
ifndef|#
directive|ifndef
name|ISP_NO_FASTPOST_FC
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FAST_POST
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CHECKME
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_USE_PORTNAME
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISP2100_FABRIC
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FULL_LOGIN
expr_stmt|;
endif|#
directive|endif
name|icbp
operator|->
name|icb_fwoptions
operator|=
name|fcp
operator|->
name|isp_fwoptions
expr_stmt|;
name|icbp
operator|->
name|icb_maxfrmlen
operator|=
name|fcp
operator|->
name|isp_maxfrmlen
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_maxfrmlen
operator|<
name|ICB_MIN_FRMLEN
operator|||
name|icbp
operator|->
name|icb_maxfrmlen
operator|>
name|ICB_MAX_FRMLEN
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad frame length (%d) from NVRAM- using %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_maxfrmlen
argument_list|,
name|ICB_DFLT_FRMLEN
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_maxfrmlen
operator|=
name|ICB_DFLT_FRMLEN
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_maxalloc
operator|=
name|fcp
operator|->
name|isp_maxalloc
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_maxalloc
operator|<
literal|16
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad maximum allocation (%d)- using 16\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_maxalloc
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_maxalloc
operator|=
literal|16
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_execthrottle
operator|=
name|fcp
operator|->
name|isp_execthrottle
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_execthrottle
operator|<
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad execution throttle of %d- using 16\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_execthrottle
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_execthrottle
operator|=
literal|16
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_retry_delay
operator|=
name|fcp
operator|->
name|isp_retry_delay
expr_stmt|;
name|icbp
operator|->
name|icb_retry_count
operator|=
name|fcp
operator|->
name|isp_retry_count
expr_stmt|;
name|icbp
operator|->
name|icb_hardaddr
operator|=
name|loopid
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_wwn
condition|)
block|{
name|MAKE_NODE_NAME_FROM_WWN
argument_list|(
name|icbp
operator|->
name|icb_nodename
argument_list|,
name|fcp
operator|->
name|isp_wwn
argument_list|)
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_fwoptions
operator|&
name|ICBOPT_USE_PORTNAME
condition|)
block|{
name|u_int64_t
name|portname
init|=
name|fcp
operator|->
name|isp_wwn
operator||
operator|(
literal|2LL
operator|<<
literal|56
operator|)
decl_stmt|;
name|MAKE_NODE_NAME_FROM_WWN
argument_list|(
name|icbp
operator|->
name|icb_nodename
argument_list|,
name|portname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fcp
operator|->
name|isp_fwoptions
operator|&=
operator|~
operator|(
name|ICBOPT_USE_PORTNAME
operator||
name|ICBOPT_FULL_LOGIN
operator|)
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_rqstqlen
operator|=
name|RQUEST_QUEUE_LEN
expr_stmt|;
name|icbp
operator|->
name|icb_rsltqlen
operator|=
name|RESULT_QUEUE_LEN
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_LSW
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_MSW
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_LSW
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_MSW
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|MemoryBarrier
argument_list|()
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|10
condition|;
name|count
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_FIRMWARE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
name|count
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|ASYNC_PDB_CHANGED
case|:
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ASYNC_LIP_OCCURRED
case|:
case|case
name|ASYNC_LOOP_UP
case|:
case|case
name|ASYNC_LOOP_DOWN
case|:
case|case
name|ASYNC_LOOP_RESET
case|:
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
if|if
condition|(
name|count
operator|>
literal|9
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: too many retries to get going- "
literal|"giving up\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"INIT FIRMWARE failed"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_residx
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Whatever happens, we're now committed to being here. 	 */
name|isp
operator|->
name|isp_state
operator|=
name|ISP_INITSTATE
expr_stmt|;
name|fcp
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_modify_lun
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to enable target mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Fibre Channel Support- get the port database for the id.  *  * Locks are held before coming here. Return 0 if success,  * else failure.  */
end_comment

begin_function
specifier|static
name|void
name|isp_mark_getpdb_all
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|isp_pdb_t
modifier|*
name|p
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|fcp
operator|->
name|isp_pdb
index|[
literal|0
index|]
init|;
name|p
operator|<
operator|&
name|fcp
operator|->
name|isp_pdb
index|[
name|MAX_FC_TARG
index|]
condition|;
name|p
operator|++
control|)
block|{
name|p
operator|->
name|pdb_options
operator|=
name|INVALID_PDB_OPTIONS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|isp_getpdb
parameter_list|(
name|isp
parameter_list|,
name|id
parameter_list|,
name|pdbp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|id
decl_stmt|;
name|isp_pdb_t
modifier|*
name|pdbp
decl_stmt|;
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_PORT_DB
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|id
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 	 * Unneeded. For the 2100, except for initializing f/w, registers 	 * 4/5 have to not be written to. 	 *	mbs.param[4] = 0; 	 *	mbs.param[5] = 0; 	 * 	 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
name|MemoryBarrier
argument_list|()
expr_stmt|;
name|MEMCPY
argument_list|(
name|pdbp
argument_list|,
name|fcp
operator|->
name|isp_scratch
argument_list|,
sizeof|sizeof
argument_list|(
name|isp_pdb_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_HOST_INTERFACE_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: DMA error getting port database\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|MBOX_COMMAND_PARAM_ERROR
case|:
comment|/* Not Logged In */
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Comand Param Error on Get Port Database\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
name|PRINTF
argument_list|(
literal|"%s: error 0x%x getting port database for ID %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure we have good FC link and know our Loop ID.  */
end_comment

begin_function
specifier|static
name|int
name|isp_fclink_test
parameter_list|(
name|isp
parameter_list|,
name|waitdelay
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|waitdelay
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_int8_t
name|lwfs
decl_stmt|;
name|fcparam
modifier|*
name|fcp
decl_stmt|;
name|fcp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
comment|/* 	 * Wait up to N microseconds for F/W to go to a ready state. 	 */
name|lwfs
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|waitdelay
condition|;
name|count
operator|+=
literal|100
control|)
block|{
name|isp_fw_state
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwfs
operator|!=
name|fcp
operator|->
name|isp_fwstate
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Firmware State %s -> %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|isp2100_fw_statename
argument_list|(
operator|(
name|int
operator|)
name|lwfs
argument_list|)
argument_list|,
name|isp2100_fw_statename
argument_list|(
operator|(
name|int
operator|)
name|fcp
operator|->
name|isp_fwstate
argument_list|)
argument_list|)
expr_stmt|;
name|lwfs
operator|=
name|fcp
operator|->
name|isp_fwstate
expr_stmt|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|==
name|FW_READY
condition|)
block|{
break|break;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* wait 100 microseconds */
block|}
comment|/* 	 * If we haven't gone to 'ready' state, return. 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get our Loop ID (if possible). We really need to have it. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_LOOP_ID
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: GET LOOP ID failed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fcp
operator|->
name|isp_loopid
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|fcp
operator|->
name|isp_alpa
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Loop ID %d, ALPA 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_loopid
argument_list|,
name|fcp
operator|->
name|isp_alpa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a command. Locking is assumed done in the caller.  */
end_comment

begin_function
name|int32_t
name|ispscsicmd
parameter_list|(
name|xs
parameter_list|)
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
union|union
block|{
name|ispreq_t
modifier|*
name|_reqp
decl_stmt|;
name|ispreqt2_t
modifier|*
name|_t2reqp
decl_stmt|;
block|}
name|_u
union|;
define|#
directive|define
name|reqp
value|_u._reqp
define|#
directive|define
name|t2reqp
value|_u._t2reqp
define|#
directive|define
name|UZSIZE
value|max(sizeof (ispreq_t), sizeof (ispreqt2_t))
name|int
name|i
decl_stmt|,
name|rqidx
decl_stmt|;
name|XS_INITERR
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|isp
operator|=
name|XS_ISP
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: adapter not ready\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * We *could* do the different sequence type that has close 	 * to the whole Queue Entry for the command... 	 */
if|if
condition|(
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
operator|>
operator|(
operator|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
operator|)
condition|?
literal|16
else|:
literal|12
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: unsupported cdb length (%d)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Check to see whether we have good firmware state still or 	 * need to refresh our port database for this target. 	 */
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp_pdb_t
modifier|*
name|pdbp
init|=
operator|&
name|fcp
operator|->
name|isp_pdb
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
decl_stmt|;
comment|/* 		 * Check for f/w being in ready state. Well, okay, 		 * our cached copy of it... 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
condition|)
block|{
if|if
condition|(
name|isp_fclink_test
argument_list|(
name|isp
argument_list|,
name|FC_FW_READY_DELAY
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
comment|/* 		 * Refresh our port database if needed. 		 */
if|if
condition|(
name|pdbp
operator|->
name|pdb_options
operator|==
name|INVALID_PDB_OPTIONS
condition|)
block|{
if|if
condition|(
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|pdbp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PDB_CHANGE_COMPLETE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Next check to see if any HBA or Device 	 * parameters need to be updated. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_update
condition|)
block|{
name|isp_update
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
name|optr
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|isp
operator|->
name|isp_reqidx
expr_stmt|;
name|reqp
operator|=
operator|(
name|ispreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptr
operator|==
name|optr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: Request Queue Overflow\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_sendmarker
condition|)
block|{
name|u_int8_t
name|niptr
decl_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reqp
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_MARKER
expr_stmt|;
name|reqp
operator|->
name|req_modifier
operator|=
name|SYNC_ALL
expr_stmt|;
name|ISP_SBUSIFY_ISPHDR
argument_list|(
name|isp
argument_list|,
operator|&
name|reqp
operator|->
name|req_header
argument_list|)
expr_stmt|;
comment|/* 		 * Unconditionally update the input pointer anyway. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
name|niptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|niptr
operator|==
name|optr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: Request Queue Overflow+\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
name|reqp
operator|=
operator|(
name|ispreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|niptr
expr_stmt|;
block|}
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
name|UZSIZE
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_T2RQS
expr_stmt|;
block|}
else|else
block|{
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_REQUEST
expr_stmt|;
block|}
name|reqp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
name|ISP_SBUSIFY_ISPHDR
argument_list|(
name|isp
argument_list|,
operator|&
name|reqp
operator|->
name|req_header
argument_list|)
expr_stmt|;
for|for
control|(
name|rqidx
operator|=
literal|0
init|;
name|rqidx
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|rqidx
operator|++
control|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_xflist
index|[
name|rqidx
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|rqidx
operator|==
name|RQUEST_QUEUE_LEN
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: out of xflist pointers\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Never have a handle that is zero, so 		 * set req_handle off by one. 		 */
name|isp
operator|->
name|isp_xflist
index|[
name|rqidx
index|]
operator|=
name|xs
expr_stmt|;
name|reqp
operator|->
name|req_handle
operator|=
name|rqidx
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
comment|/* 		 * See comment in isp_intr 		 */
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Fibre Channel always requires some kind of tag. 		 * If we're marked as "Can't Tag", just do simple 		 * instead of ordered tags. It's pretty clear to me 		 * that we shouldn't do head of queue tagging in 		 * this case. 		 */
if|if
condition|(
name|XS_CANTAG
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|t2reqp
operator|->
name|req_flags
operator|=
name|XS_KINDOF_TAG
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t2reqp
operator|->
name|req_flags
operator|=
name|REQFLAG_STAG
expr_stmt|;
block|}
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
if|if
condition|(
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|cur_dflags
operator|&
name|DPARM_TQING
operator|)
operator|&&
name|XS_CANTAG
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_flags
operator|=
name|XS_KINDOF_TAG
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reqp
operator|->
name|req_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|reqp
operator|->
name|req_target
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|reqp
operator|->
name|req_lun_trn
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_cdblen
operator|=
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ISP2100_SCCLUN
name|reqp
operator|->
name|req_scclun
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
else|#
directive|else
name|reqp
operator|->
name|req_lun_trn
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|MEMCPY
argument_list|(
name|reqp
operator|->
name|req_cdb
argument_list|,
name|XS_CDBP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s(%d.%d): START%d cmd 0x%x datalen %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|,
name|reqp
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|,
name|reqp
operator|->
name|req_cdb
index|[
literal|0
index|]
operator|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_time
operator|=
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|req_time
operator|==
literal|0
operator|&&
name|XS_TIME
argument_list|(
name|xs
argument_list|)
condition|)
name|reqp
operator|->
name|req_time
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Always give a bit more leeway to commands after a bus reset. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_sendmarker
operator|&&
name|reqp
operator|->
name|req_time
operator|<
literal|5
condition|)
name|reqp
operator|->
name|req_time
operator|=
literal|5
expr_stmt|;
name|i
operator|=
name|ISP_DMASETUP
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|reqp
argument_list|,
operator|&
name|iptr
argument_list|,
name|optr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|CMD_QUEUED
condition|)
block|{
comment|/* 		 * Take memory of it away... 		 */
name|isp
operator|->
name|isp_xflist
index|[
name|rqidx
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * dmasetup sets actual error in packet, and 		 * return what we were given to return. 		 */
return|return
operator|(
name|i
operator|)
return|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
name|ISP_SBUSIFY_ISPREQ
argument_list|(
name|isp
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|MemoryBarrier
argument_list|()
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
name|isp
operator|->
name|isp_nactive
operator|++
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_sendmarker
condition|)
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|CMD_QUEUED
operator|)
return|;
undef|#
directive|undef
name|reqp
undef|#
directive|undef
name|t2reqp
block|}
end_function

begin_comment
comment|/*  * isp control  * Locks (ints blocked) assumed held.  */
end_comment

begin_function
name|int
name|isp_control
parameter_list|(
name|isp
parameter_list|,
name|ctl
parameter_list|,
name|arg
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispctl_t
name|ctl
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
default|default:
name|PRINTF
argument_list|(
literal|"%s: isp_control unknown control op %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPCTL_RESET_BUS
case|:
comment|/* 		 * This is really important to have set after a bus reset. 		 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Issue a bus reset. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_BUS_RESET
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_bus_reset_delay
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|<
literal|2
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Unparameterized. 			 */
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|5
expr_stmt|;
block|}
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"isp_control SCSI bus reset failed"
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: driver initiated bus reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_RESET_DEV
case|:
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABORT_TARGET
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|long
operator|)
name|arg
operator|)
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
comment|/* 'delay', in seconds */
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"Target Reset Failed"
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: Target %d Reset Succeeded\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|long
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_ABORT_CMD
case|:
name|xs
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xs
operator|==
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|RQUEST_QUEUE_LEN
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_control- cannot find command to abort "
literal|"in active list\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABORT
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP2100_SCCLUN
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|>>
literal|16
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_control MBOX_ABORT failure (code %x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: command for target %d lun %d was aborted\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_UPDATE_PARAMS
case|:
name|isp_update
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_FCLINK_TEST
case|:
return|return
operator|(
name|isp_fclink_test
argument_list|(
name|isp
argument_list|,
name|FC_FW_READY_DELAY
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt Service Routine(s).  *  * External (OS) framework has done the appropriate locking,  * and the locking will be held throughout this function.  */
end_comment

begin_function
name|int
name|isp_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|complist
index|[
name|RESULT_QUEUE_LEN
index|]
decl_stmt|,
modifier|*
name|xs
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|arg
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
name|u_int16_t
name|isr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nlooked
init|=
literal|0
decl_stmt|,
name|ndone
init|=
literal|0
decl_stmt|;
name|isr
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s: isp_intr isr %x sema 0x%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|isr
operator|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
if|if
condition|(
name|isr
operator|==
literal|0
operator|||
operator|(
name|isr
operator|&
name|BIU2100_ISR_RISC_INT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s: isp_intr isr=%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|isr
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isr
operator|==
literal|0
operator|||
operator|(
name|isr
operator|&
name|BIU_ISR_RISC_INT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s: isp_intr isr=%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|isr
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: interrupt (isr=0x%x,sema=0x%x) when not ready\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|isr
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX5
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|1
condition|)
block|{
name|u_int16_t
name|mbox
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mbox
operator|&
literal|0x4000
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: isp_intr sees 0x%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|mbox
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|fhandle
init|=
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
operator|(
name|int
operator|)
name|mbox
argument_list|)
decl_stmt|;
if|if
condition|(
name|fhandle
operator|>
literal|0
condition|)
block|{
name|xs
operator|=
operator|(
name|void
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|fhandle
operator|-
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_xflist
index|[
name|fhandle
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * Since we don't have a result queue entry 				 * item, we must believe that SCSI status is 				 * zero and that all data transferred. 				 */
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|fhandle
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_nactive
operator|>
literal|0
condition|)
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt. 	 */
name|optr
operator|=
name|isp
operator|->
name|isp_residx
expr_stmt|;
name|iptr
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX5
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|optr
operator|==
name|iptr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"why intr? isr %x iptr %x optr %x\n"
operator|,
name|isr
operator|,
name|optr
operator|,
name|iptr
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|optr
operator|!=
name|iptr
condition|)
block|{
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|u_int8_t
name|oop
decl_stmt|;
name|int
name|buddaboom
init|=
literal|0
decl_stmt|;
name|sp
operator|=
operator|(
name|ispstatusreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_result
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|oop
operator|=
name|optr
expr_stmt|;
name|optr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|optr
argument_list|,
name|RESULT_QUEUE_LEN
argument_list|)
expr_stmt|;
name|nlooked
operator|++
expr_stmt|;
name|MemoryBarrier
argument_list|()
expr_stmt|;
name|ISP_SBUSIFY_ISPHDR
argument_list|(
name|isp
argument_list|,
operator|&
name|sp
operator|->
name|req_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|!=
name|RQSTYPE_RESPONSE
condition|)
block|{
if|if
condition|(
name|isp_handle_other_response
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|,
operator|&
name|optr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * It really has to be a bounced request just copied 			 * from the request queue to the response queue. If 			 * not, something bad has happened. 			 */
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|!=
name|RQSTYPE_REQUEST
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: not RESPONSE in RESPONSE Queue "
literal|"(type 0x%x) @ idx %d (next %d)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|,
name|oop
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|buddaboom
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
literal|0xf
condition|)
block|{
define|#
directive|define
name|_RQS_OFLAGS
define|\
value|~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_CONTINUATION
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: continuation segment\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_FULL
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: internal queues full\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * We'll synthesize a QUEUE FULL message below. 				 */
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_BADHEADER
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad header\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_BADPACKET
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad request packet\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|_RQS_OFLAGS
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: unknown flags in response (0x%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
undef|#
directive|undef
name|_RQS_OFLAGS
block|}
if|if
condition|(
name|sp
operator|->
name|req_handle
operator|>
name|RQUEST_QUEUE_LEN
operator|||
name|sp
operator|->
name|req_handle
operator|<
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad request handle %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|xs
operator|=
operator|(
name|void
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|sp
operator|->
name|req_handle
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: NULL xs in xflist (handle %x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
name|isp_dumpxflist
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|isp
operator|->
name|isp_xflist
index|[
name|sp
operator|->
name|req_handle
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_BUS_RESET
condition|)
block|{
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|buddaboom
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_scsi_status
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
block|{
name|MEMCPY
argument_list|(
name|XS_SNSP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_sense_data
argument_list|,
name|XS_SNSLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SNS_IS_VALID
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * A new synchronous rate was negotiated for this 			 * target. Mark state such that we'll go look up 			 * that which has changed later. 			 */
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_NEGOTIATION
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp
operator|->
name|isp_update
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_refresh
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|==
name|RQSTYPE_REQUEST
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_FULL
condition|)
block|{
comment|/* 				 * Force Queue Full status. 				 */
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|=
literal|0x28
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
condition|)
block|{
name|XS_SNS_IS_VALID
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|XS_SNSP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_sense_data
argument_list|,
name|XS_SNSLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|req_state_flags
operator||=
name|RQSF_GOT_SENSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
operator|&&
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_BUSY
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_TGTBSY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|==
name|RQSTYPE_RESPONSE
condition|)
block|{
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_completion_status
operator|!=
name|RQCS_COMPLETE
condition|)
block|{
name|isp_parse_status
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|,
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|PRINTF
argument_list|(
literal|"%s: unknown return %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|req_scsi_status
operator|&
name|RQCS_RU
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s: cnt %d rsd %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
operator|,
name|sp
operator|->
name|req_resid
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|sp
operator|->
name|req_handle
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * XXX: If we have a check condition, but no Sense Data, 		 * XXX: mark it as an error (ARQ failed). We need to 		 * XXX: to do a more distinct job because there may 		 * XXX: cases where ARQ is disabled. 		 */
if|if
condition|(
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
operator|&&
operator|!
operator|(
name|XS_IS_SNS_VALID
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: ARQ failure for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ARQFAIL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_dblev
operator|>=
literal|5
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
operator|&&
operator|!
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s(%d.%d): FIN%d dl%d resid%d STS %x"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_seqno
argument_list|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_RESID
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_STS
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
block|{
name|PRINTF
argument_list|(
literal|" Skey: %x"
argument_list|,
name|XS_SNSKEY
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XS_IS_SNS_VALID
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|" BUT NOT SET"
argument_list|)
expr_stmt|;
block|}
block|}
name|PRINTF
argument_list|(
literal|" XS_ERR=0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|XS_ERR
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_nactive
operator|>
literal|0
condition|)
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
name|complist
index|[
name|ndone
operator|++
index|]
operator|=
name|xs
expr_stmt|;
comment|/* defer completion call until later */
block|}
comment|/* 	 * If we looked at any commands, then it's valid to find out 	 * what the outpointer is. It also is a trigger to update the 	 * ISP's notion of what we've seen so far. 	 */
if|if
condition|(
name|nlooked
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
block|}
name|isp
operator|->
name|isp_residx
operator|=
name|optr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndone
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
name|complist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xs
condition|)
block|{
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support routines.  */
end_comment

begin_function
specifier|static
name|int
name|isp_parse_async
parameter_list|(
name|isp
parameter_list|,
name|mbox
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|mbox
decl_stmt|;
block|{
name|u_int32_t
name|fast_post_handle
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mbox
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
comment|/* sometimes these show up */
break|break;
case|case
name|ASYNC_BUS_RESET
case|:
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_BUS_RESET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_SYSTEM_ERROR
case|:
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Internal FW Error @ RISC Addr 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
name|isp_restart
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* no point continuing after this */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|ASYNC_RQS_XFER_ERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Request Queue Transfer Error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_RSP_XFER_ERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Response Queue Transfer Error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_QWAKEUP
case|:
comment|/* don't need to be chatty */
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_TIMEOUT_RESET
case|:
name|PRINTF
argument_list|(
literal|"%s: timeout initiated SCSI bus reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_DEVICE_RESET
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: device reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_EXTMSG_UNDERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: extended message underrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_SCAM_INT
case|:
name|PRINTF
argument_list|(
literal|"%s: SCAM interrupt\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_HUNG_SCSI
case|:
name|PRINTF
argument_list|(
literal|"%s: stalled SCSI Bus after DATA Overrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
comment|/* XXX: Need to issue SCSI reset at this point */
break|break;
case|case
name|ASYNC_KILLED_BUS
case|:
name|PRINTF
argument_list|(
literal|"%s: SCSI Bus reset after DATA Overrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_BUS_TRANSIT
case|:
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbox
operator|&
literal|0x1c00
condition|)
block|{
case|case
name|SXP_PINS_LVD_MODE
case|:
name|PRINTF
argument_list|(
literal|"%s: Transition to LVD mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_lvdmode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SXP_PINS_HVD_MODE
case|:
name|PRINTF
argument_list|(
literal|"%s: Transition to Differential mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_lvdmode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SXP_PINS_SE_MODE
case|:
name|PRINTF
argument_list|(
literal|"%s: Transition to Single Ended mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_lvdmode
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: Transition to unknown mode 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * XXX: Set up to renegotiate again! 		 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ASYNC_CMD_CMPLT
case|:
name|fast_post_handle
operator|=
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: fast post completion of %u\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|fast_post_handle
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CTIO_DONE
case|:
comment|/* Should only occur when Fast Posting Set for 2100s */
name|PRINTF
argument_list|(
literal|"%s: CTIO done\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LIP_OCCURRED
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: LIP occurred\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_UP
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_LOOP_UP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_DOWN
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_LOOP_DOWN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_RESET
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Loop RESET\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_PDB_CHANGED
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Port Database Changed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: unknown async code 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|fast_post_handle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_handle_other_response
parameter_list|(
name|isp
parameter_list|,
name|sp
parameter_list|,
name|optrp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|u_int8_t
modifier|*
name|optrp
decl_stmt|;
block|{
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
name|int
name|reqsize
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ireqp
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
union|union
block|{
name|at_entry_t
modifier|*
name|atio
decl_stmt|;
name|at2_entry_t
modifier|*
name|at2io
decl_stmt|;
name|ct_entry_t
modifier|*
name|ctio
decl_stmt|;
name|ct2_entry_t
modifier|*
name|ct2io
decl_stmt|;
name|lun_entry_t
modifier|*
name|lunen
decl_stmt|;
name|in_entry_t
modifier|*
name|inot
decl_stmt|;
name|in_fcentry_t
modifier|*
name|inot_fc
decl_stmt|;
name|na_entry_t
modifier|*
name|nack
decl_stmt|;
name|na_fcentry_t
modifier|*
name|nack_fc
decl_stmt|;
name|void
modifier|*
name|voidp
decl_stmt|;
define|#
directive|define
name|atio
value|un.atio
define|#
directive|define
name|at2io
value|un.at2io
define|#
directive|define
name|ctio
value|un.ctio
define|#
directive|define
name|ct2io
value|un.ct2io
define|#
directive|define
name|lunen
value|un.lunen
define|#
directive|define
name|inot
value|un.inot
define|#
directive|define
name|inot_fc
value|un.inot_fc
define|#
directive|define
name|nack
value|un.nack
define|#
directive|define
name|nack_fc
value|un.nack_fc
block|}
name|un
union|;
name|un
operator|.
name|voidp
operator|=
name|sp
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
condition|)
block|{
case|case
name|RQSTYPE_REQUEST
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
case|case
name|RQSTYPE_NOTIFY_ACK
case|:
block|{
specifier|static
specifier|const
name|char
modifier|*
name|f
init|=
literal|"%s: Notify Ack Status 0x%x Sequence Id 0x%x\n"
comment|/* 		 * The ISP is acknowleding our ack of an Immediate Notify. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|PRINTF
argument_list|(
name|f
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|nack_fc
operator|->
name|na
operator|-
name|status
argument_list|,
name|nack_fc
operator|->
name|na_seqid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRINTF
argument_list|(
name|f
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|nack
operator|->
name|na_status
argument_list|,
name|nack
operator|->
name|na_seqid
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|RQSTYPE_NOTIFY
case|:
block|{
name|u_int16_t
name|seqid
decl_stmt|,
name|status
decl_stmt|;
comment|/* 		 * Either the ISP received a SCSI message it cannot handle 		 * or some other out of band condition (e.g., Port Logout) 		 * or it is returning an Immediate Notify entry we sent. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|status
operator|=
name|inot_fc
operator|->
name|status
expr_stmt|;
name|seqid
operator|=
name|inot_fc
operator|->
name|in_seqid
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|inot
operator|->
name|status
expr_stmt|;
name|seqid
operator|=
name|inot
operator|->
name|seqid
operator|&
literal|0xff
expr_stmt|;
block|}
name|PRINTF
argument_list|(
literal|"%s: Immediate Notify Status 0x%x Sequence Id 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|status
argument_list|,
name|seqid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|IN_MSG_RECEIVED
case|:
case|case
name|IN_IDE_RECEIVED
case|:
name|ptisp_got_msg
argument_list|(
name|ptp
argument_list|,
operator|&
name|inot
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN_RSRC_UNAVAIL
case|:
name|PRINTF
argument_list|(
literal|"%s: Firmware out of ATIOs\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN_ABORT_TASK
case|:
name|PRINTF
argument_list|(
literal|"%s: Abort Task iid %d rx_id 0x%x\n"
argument_list|,
name|inot_fc
operator|->
name|in_iid
argument_list|,
name|seqid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN_PORT_LOGOUT
case|:
name|PRINTF
argument_list|(
literal|"%s: Port Logout for Initiator %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|inot_fc
operator|->
name|in_iid
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: bad status (0x%x) in Immediate Notify\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|un
operator|.
name|voidp
argument_list|)
expr_stmt|;
name|reqsize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|RQSTYPE_ENABLE_LUN
case|:
case|case
name|RQSTYPE_MODIFY_LUN
case|:
if|if
condition|(
name|lunen
operator|->
name|req_status
operator|!=
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: ENABLE/MODIFY LUN returned status 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|lunen
operator|->
name|req_status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RQSTYPE_ATIO2
case|:
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|ispctiot2_t
name|local
decl_stmt|,
modifier|*
name|ct2
init|=
name|NULL
decl_stmt|;
name|ispatiot2_t
modifier|*
name|at2
init|=
operator|(
name|ispatiot2_t
operator|*
operator|)
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|lun
decl_stmt|;
ifdef|#
directive|ifdef
name|ISP2100_SCCLUN
name|lun
operator|=
name|at2
operator|->
name|req_scclun
expr_stmt|;
else|#
directive|else
name|lun
operator|=
name|at2
operator|->
name|req_lun
expr_stmt|;
endif|#
directive|endif
name|PRINTF
argument_list|(
literal|"%s: atio2 loopid %d for lun %d rxid 0x%x flags0x%x "
literal|"tflags0x%x ecodes0x%x rqstatus0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|at2
operator|->
name|req_initiator
argument_list|,
name|lun
argument_list|,
name|at2
operator|->
name|req_rxid
argument_list|,
name|at2
operator|->
name|req_flags
argument_list|,
name|at2
operator|->
name|req_taskflags
argument_list|,
name|at2
operator|->
name|req_execodes
argument_list|,
name|at2
operator|->
name|req_status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|at2
operator|->
name|req_status
operator|&
operator|~
name|ATIO_SENSEVALID
condition|)
block|{
case|case
name|ATIO_PATH_INVALID
case|:
name|PRINTF
argument_list|(
literal|"%s: ATIO2 Path Invalid\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATIO_NOCAP
case|:
name|PRINTF
argument_list|(
literal|"%s: ATIO2 No Cap\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATIO_BDR_MSG
case|:
name|PRINTF
argument_list|(
literal|"%s: ATIO2 BDR Received\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATIO_CDB_RECEIVED
case|:
name|ct2
operator|=
operator|&
name|local
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: unknown req_status 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|at2
operator|->
name|req_status
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ct2
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Just do an ACCEPT on this fellow. 			 */
name|at2
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_ATIO2
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|at2
operator|->
name|req_flags
operator|=
literal|1
expr_stmt|;
name|ireqp
operator|=
name|at2
expr_stmt|;
name|reqsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|at2
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: datalen %d cdb0=0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|at2
operator|->
name|req_datalen
argument_list|,
name|at2
operator|->
name|req_cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ct2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ct2
argument_list|)
argument_list|)
expr_stmt|;
name|ct2
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_CTIO2
expr_stmt|;
name|ct2
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|ct2
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|ct2
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
name|ct2
operator|->
name|req_handle
operator|=
operator|(
name|at2
operator|->
name|req_initiator
operator|<<
literal|16
operator|)
operator||
name|lun
expr_stmt|;
ifndef|#
directive|ifndef
name|ISP2100_SCCLUN
name|ct2
operator|->
name|req_lun
operator|=
name|lun
expr_stmt|;
endif|#
directive|endif
name|ct2
operator|->
name|req_initiator
operator|=
name|at2
operator|->
name|req_initiator
expr_stmt|;
name|ct2
operator|->
name|req_rxid
operator|=
name|at2
operator|->
name|req_rxid
expr_stmt|;
name|ct2
operator|->
name|req_flags
operator|=
name|CTIO_SEND_STATUS
expr_stmt|;
switch|switch
condition|(
name|at2
operator|->
name|req_cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* TUR */
name|ct2
operator|->
name|req_flags
operator||=
name|CTIO_NODATA
operator||
name|CTIO2_SMODE0
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_scsi_status
operator|=
name|CTIO2_STATUS_VALID
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/* REQUEST SENSE */
case|case
literal|0x12
case|:
comment|/* INQUIRE */
name|ct2
operator|->
name|req_flags
operator||=
name|CTIO_SEND_DATA
operator||
name|CTIO2_SMODE0
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_scsi_status
operator|=
name|CTIO2_STATUS_VALID
expr_stmt|;
name|ct2
operator|->
name|req_seg_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|at2
operator|->
name|req_cdb
index|[
literal|0
index|]
operator|==
literal|0x12
condition|)
block|{
name|s
operator|=
sizeof|sizeof
argument_list|(
name|tgtiqd
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|fcp
operator|->
name|isp_scratch
argument_list|,
name|tgtiqd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|at2
operator|->
name|req_datalen
expr_stmt|;
name|MEMZERO
argument_list|(
name|fcp
operator|->
name|isp_scratch
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_dataseg
index|[
literal|0
index|]
operator|.
name|ds_base
operator|=
name|fcp
operator|->
name|isp_scdma
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_dataseg
index|[
literal|0
index|]
operator|.
name|ds_count
operator|=
name|s
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_datalen
operator|=
name|s
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|at2
operator|->
name|req_datalen
operator|<
name|s
condition|)
block|{
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator||=
name|CTIO2_RESP_VALID
operator||
name|CTIO2_RSPOVERUN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at2
operator|->
name|req_datalen
operator|>
name|s
condition|)
block|{
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator||=
name|CTIO2_RESP_VALID
operator||
name|CTIO2_RSPUNDERUN
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
comment|/* ALL OTHERS */
name|ct2
operator|->
name|req_flags
operator||=
name|CTIO_NODATA
operator||
name|CTIO2_SMODE1
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|at2
operator|->
name|req_datalen
condition|)
block|{
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator||=
name|CTIO2_RSPUNDERUN
expr_stmt|;
name|ct2
operator|->
name|req_resid
index|[
literal|0
index|]
operator|=
name|at2
operator|->
name|req_datalen
operator|&
literal|0xff
expr_stmt|;
name|ct2
operator|->
name|req_resid
index|[
literal|1
index|]
operator|=
operator|(
name|at2
operator|->
name|req_datalen
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ct2
operator|->
name|req_resid
index|[
literal|2
index|]
operator|=
operator|(
name|at2
operator|->
name|req_datalen
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ct2
operator|->
name|req_resid
index|[
literal|3
index|]
operator|=
operator|(
name|at2
operator|->
name|req_datalen
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|at2
operator|->
name|req_status
operator|&
name|ATIO_SENSEVALID
operator|)
operator|==
literal|0
condition|)
block|{
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_sense_len
operator|=
literal|18
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator||=
literal|2
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_response
index|[
literal|0
index|]
operator|=
literal|0x70
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_response
index|[
literal|2
index|]
operator|=
literal|0x2
expr_stmt|;
block|}
else|else
block|{
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_sense_len
operator|=
literal|18
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator||=
name|at2
operator|->
name|req_scsi_status
expr_stmt|;
name|MEMCPY
argument_list|(
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_response
argument_list|,
name|at2
operator|->
name|req_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|at2
operator|->
name|req_sense
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|reqsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ct2
argument_list|)
expr_stmt|;
name|ireqp
operator|=
name|ct2
expr_stmt|;
break|break;
block|}
case|case
name|RQSTYPE_CTIO2
case|:
block|{
name|ispatiot2_t
modifier|*
name|at2
decl_stmt|;
name|ispctiot2_t
modifier|*
name|ct2
init|=
operator|(
name|ispctiot2_t
operator|*
operator|)
name|sp
decl_stmt|;
name|PRINTF
argument_list|(
literal|"%s: CTIO2 returned status 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ct2
operator|->
name|req_status
argument_list|)
expr_stmt|;
comment|/* 		 * Return the ATIO to the board. 		 */
name|at2
operator|=
operator|(
name|ispatiot2_t
operator|*
operator|)
name|sp
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_ATIO2
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
name|at2
operator|->
name|req_status
operator|=
literal|1
expr_stmt|;
name|reqsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|at2
argument_list|)
expr_stmt|;
name|ireqp
operator|=
name|at2
expr_stmt|;
break|break;
block|}
undef|#
directive|undef
name|atio
undef|#
directive|undef
name|at2io
undef|#
directive|undef
name|ctio
undef|#
directive|undef
name|ct2io
undef|#
directive|undef
name|lunen
undef|#
directive|undef
name|inot
undef|#
directive|undef
name|inot_fc
undef|#
directive|undef
name|nack
undef|#
directive|undef
name|nack_fc
endif|#
directive|endif
default|default:
name|PRINTF
argument_list|(
literal|"%s: other response type %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reqsize
condition|)
block|{
name|void
modifier|*
name|reqp
decl_stmt|;
name|optr
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|isp
operator|->
name|isp_reqidx
expr_stmt|;
name|reqp
operator|=
operator|(
name|void
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptr
operator|==
name|optr
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Request Queue Overflow other response\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MEMCPY
argument_list|(
name|reqp
argument_list|,
name|ireqp
argument_list|,
name|reqsize
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|isp_tmd_newcmd_dflt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|tmd_cmd_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_tmd_event_dflt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_tmd_notify_dflt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|tmd_notify_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_tgt_data_xfer
name|__P
argument_list|(
operator|(
name|tmd_cmd_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_tgt_endcmd
name|__P
argument_list|(
operator|(
name|tmd_cmd_t
operator|*
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_tgt_done
name|__P
argument_list|(
operator|(
name|tmd_cmd_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|isp_tmd_newcmd_dflt
parameter_list|(
name|arg0
parameter_list|,
name|cmdp
parameter_list|)
name|void
modifier|*
name|arg0
decl_stmt|;
name|tmd_cmd_t
modifier|*
name|cmdp
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|isp_tmd_event_dflt
parameter_list|(
name|arg0
parameter_list|,
name|event
parameter_list|)
name|void
modifier|*
name|arg0
decl_stmt|;
name|int
name|event
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|isp_tmd_notify_dflt
parameter_list|(
name|arg0
parameter_list|,
name|npt
parameter_list|)
name|void
modifier|*
name|arg0
decl_stmt|;
name|tmd_notify_t
modifier|*
name|npt
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*  * Locks held, and ints disabled (if FC).  *  * XXX: SETUP ONLY FOR INITIAL ENABLING RIGHT NOW  */
end_comment

begin_function
specifier|static
name|int
name|isp_modify_lun
parameter_list|(
name|isp
parameter_list|,
name|lun
parameter_list|,
name|icnt
parameter_list|,
name|ccnt
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|lun
decl_stmt|;
comment|/* logical unit to enable, modify, or disable */
name|int
name|icnt
decl_stmt|;
comment|/* immediate notify count */
name|int
name|ccnt
decl_stmt|;
comment|/* command count */
block|{
name|isplun_t
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
name|optr
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|isp
operator|->
name|isp_reqidx
expr_stmt|;
name|ip
operator|=
operator|(
name|isplun_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptr
operator|==
name|optr
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Request Queue Overflow in isp_modify_lun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_ENABLE_LUN
expr_stmt|;
name|ip
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
name|ip
operator|->
name|req_handle
operator|=
name|RQSTYPE_ENABLE_LUN
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|ip
operator|->
name|req_lun
operator|=
name|lun
expr_stmt|;
block|}
name|ip
operator|->
name|req_cmdcount
operator|=
name|ccnt
expr_stmt|;
name|ip
operator|->
name|req_imcount
operator|=
name|icnt
expr_stmt|;
name|ip
operator|->
name|req_timeout
operator|=
literal|0
expr_stmt|;
comment|/* default 30 seconds */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_notify_ack
parameter_list|(
name|isp
parameter_list|,
name|ptrp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|void
modifier|*
name|ptrp
decl_stmt|;
block|{
name|void
modifier|*
name|reqp
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
union|union
block|{
name|na_fcentry_t
name|_naf
decl_stmt|;
name|na_entry_t
name|_nas
decl_stmt|;
block|}
name|un
union|;
name|MEMZERO
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|un
argument_list|,
sizeof|sizeof
argument_list|(
name|un
argument_list|)
argument_list|)
expr_stmt|;
name|un
operator|.
name|_nas
operator|.
name|na_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_NOTIFY_ACK
expr_stmt|;
name|un
operator|.
name|_nas
operator|.
name|na_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|na_fcentry_t
modifier|*
name|na
init|=
operator|&
name|un
operator|.
name|_nas
decl_stmt|;
if|if
condition|(
name|ptrp
condition|)
block|{
name|in_fcentry_t
modifier|*
name|inp
init|=
name|ptrp
decl_stmt|;
name|na
operator|->
name|na_iid
operator|=
name|inp
operator|->
name|in_iid
expr_stmt|;
name|na
operator|->
name|na_lun
operator|=
name|inp
operator|->
name|in_lun
expr_stmt|;
name|na
operator|->
name|na_task_flags
operator|=
name|inp
operator|->
name|in_task_flags
expr_stmt|;
name|na
operator|->
name|na_seqid
operator|=
name|inp
operator|->
name|in_seqid
expr_stmt|;
name|na
operator|->
name|na_status
operator|=
name|inp
operator|->
name|in_status
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|na_flags
operator|=
name|NAFC_RST_CLRD
expr_stmt|;
block|}
block|}
else|else
block|{
name|na_entry_t
modifier|*
name|na
init|=
operator|&
name|un
operator|.
name|_nas
decl_stmt|;
if|if
condition|(
name|ptrp
condition|)
block|{
name|in_entry_t
modifier|*
name|inp
init|=
name|ptrp
decl_stmt|;
name|na
operator|->
name|na_iid
operator|=
name|inp
operator|->
name|in_iid
expr_stmt|;
name|na
operator|->
name|na_lun
operator|=
name|inp
operator|->
name|in_lun
expr_stmt|;
name|na
operator|->
name|na_tgt
operator|=
name|inp
operator|->
name|in_tgt
expr_stmt|;
name|na
operator|->
name|na_seqid
operator|=
name|inp
operator|->
name|in_seqid
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|na_flags
operator|=
name|NA_RST_CLRD
expr_stmt|;
block|}
block|}
name|optr
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|isp
operator|->
name|isp_reqidx
expr_stmt|;
name|reqp
operator|=
operator|(
name|void
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptr
operator|==
name|optr
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Request Queue Overflow For isp_notify_ack\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MEMCPY
argument_list|(
name|reqp
argument_list|,
name|ireqp
argument_list|,
sizeof|sizeof
argument_list|(
name|un
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * These are dummy stubs for now until the outside framework is plugged in.  */
end_comment

begin_function
specifier|static
name|void
name|isp_handle_atio
parameter_list|(
name|isp
parameter_list|,
name|aep
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|at_entry_t
modifier|*
name|aep
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|connected
decl_stmt|;
name|tmd_cmd_t
name|local
decl_stmt|,
modifier|*
name|cdp
init|=
operator|&
name|local
decl_stmt|;
comment|/* 	 * Get the ATIO status and see if we're still connected. 	 */
name|status
operator|=
name|aep
operator|->
name|at_status
expr_stmt|;
name|connected
operator|=
operator|(
operator|(
name|aep
operator|->
name|at_flags
operator|&
name|AT_NODISC
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: ATIO status=0x%x, connected=%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|status
argument_list|,
name|connected
argument_list|)
expr_stmt|;
comment|/* 	 * The firmware status (except for the SenseValid bit) indicates 	 * why this ATIO was sent to us. 	 * If SenseValid is set, the firware has recommended Sense Data. 	 * If the Disconnects Disabled bit is set in the flags field, 	 * we're still connected on the SCSI bus - i.e. the initiator 	 * did not set DiscPriv in the identify message. We don't care 	 * about this so it's ignored. 	 */
switch|switch
condition|(
name|status
operator|&
operator|~
name|TGTSVALID
condition|)
block|{
case|case
name|AT_PATH_INVALID
case|:
comment|/* 		 * ATIO rejected by the firmware due to disabled lun. 		 */
name|PRINTF
argument_list|(
literal|"%s: Firmware rejected ATIO for disabled lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|aep
operator|->
name|at_lun
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_PHASE_ERROR
case|:
comment|/* 		 * Bus Pase Sequence error. 		 * 		 * The firmware should have filled in the correct 		 * sense data. 		 */
if|if
condition|(
name|status
operator|&
name|TGTSVALID
condition|)
block|{
name|MEMCPY
argument_list|(
operator|&
name|cdp
operator|->
name|cd_sensedata
argument_list|,
name|aep
operator|->
name|at_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|cdp
operator|->
name|cd_sensedata
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Bus Phase Sequence error key 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|cdp
operator|->
name|cd_sensedata
index|[
literal|2
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRINTF
argument_list|(
literal|"%s: Bus Phase Sequence With No Sense\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|isp
operator|->
name|isp_tmd_newcmd
call|)
argument_list|(
name|isp
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_NOCAP
case|:
comment|/* 		 * Requested Capability not available 		 * We sent an ATIO that overflowed the firmware's 		 * command resource count. 		 */
name|PRINTF
argument_list|(
literal|"%s: Firmware rejected ATIO, command count overflow\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_BDR_MSG
case|:
comment|/* 		 * If we send an ATIO to the firmware to increment 		 * its command resource count, and the firmware is 		 * recovering from a Bus Device Reset, it returns 		 * the ATIO with this status. 		 */
name|PRINTF
argument_list|(
literal|"%s: ATIO returned with BDR received\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_CDB
case|:
comment|/* 		 * New CDB 		 */
name|cdp
operator|->
name|cd_hba
operator|=
name|isp
expr_stmt|;
name|cdp
operator|->
name|cd_iid
operator|=
name|aep
operator|->
name|at_iid
expr_stmt|;
name|cdp
operator|->
name|cd_tgt
operator|=
name|aep
operator|->
name|at_tgt
expr_stmt|;
name|cdp
operator|->
name|cd_lun
operator|=
name|aep
operator|->
name|at_lun
expr_stmt|;
name|cdp
operator|->
name|cd_tagtype
operator|=
name|aep
operator|->
name|at_tag_type
expr_stmt|;
name|cdp
operator|->
name|cd_tagval
operator|=
name|aep
operator|->
name|at_tag_val
expr_stmt|;
name|MEMCPY
argument_list|(
name|cdp
operator|->
name|cd_cdb
argument_list|,
name|aep
operator|->
name|at_cdb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: CDB 0x%x itl %d/%d/%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|cdp
operator|->
name|cd_cdb
index|[
literal|0
index|]
argument_list|,
name|cdp
operator|->
name|cd_iid
argument_list|,
name|cdp
operator|->
name|cd_tgt
argument_list|,
name|cdp
operator|->
name|cd_lun
argument_list|)
expr_stmt|;
call|(
modifier|*
name|isp
operator|->
name|isp_tmd_newcmd
call|)
argument_list|(
name|isp
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: Unknown status (0x%x) in ATIO\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|cd_hba
operator|=
name|isp
expr_stmt|;
name|cdp
operator|->
name|cd_iid
operator|=
name|aep
operator|->
name|at_iid
expr_stmt|;
name|cdp
operator|->
name|cd_tgt
operator|=
name|aep
operator|->
name|at_tgt
expr_stmt|;
name|cdp
operator|->
name|cd_lun
operator|=
name|aep
operator|->
name|at_lun
expr_stmt|;
name|cdp
operator|->
name|cd_tagtype
operator|=
name|aep
operator|->
name|at_tag_type
expr_stmt|;
name|cdp
operator|->
name|cd_tagval
operator|=
name|aep
operator|->
name|at_tag_val
expr_stmt|;
name|isp_tgtcmd_done
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_handle_atio2
parameter_list|(
name|isp
parameter_list|,
name|aep
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|at2_entry_t
modifier|*
name|aep
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|tmd_cmd_t
name|local
decl_stmt|,
modifier|*
name|cdp
init|=
operator|&
name|local
decl_stmt|;
comment|/* 	 * Get the ATIO2 status. 	 */
name|status
operator|=
name|aep
operator|->
name|at_status
expr_stmt|;
name|PRINTD
argument_list|(
literal|"%s: ATIO2 status=0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * The firmware status (except for the SenseValid bit) indicates 	 * why this ATIO was sent to us. 	 * If SenseValid is set, the firware has recommended Sense Data. 	 */
switch|switch
condition|(
name|status
operator|&
operator|~
name|TGTSVALID
condition|)
block|{
case|case
name|AT_PATH_INVALID
case|:
comment|/* 		 * ATIO rejected by the firmware due to disabled lun. 		 */
name|PRINTF
argument_list|(
literal|"%s: Firmware rejected ATIO2 for disabled lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|aep
operator|->
name|at_lun
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_NOCAP
case|:
comment|/* 		 * Requested Capability not available 		 * We sent an ATIO that overflowed the firmware's 		 * command resource count. 		 */
name|PRINTF
argument_list|(
literal|"%s: Firmware rejected ATIO2, command count overflow\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_BDR_MSG
case|:
comment|/* 		 * If we send an ATIO to the firmware to increment 		 * its command resource count, and the firmware is 		 * recovering from a Bus Device Reset, it returns 		 * the ATIO with this status. 		 */
name|PRINTF
argument_list|(
literal|"%s: ATIO2 returned with BDR rcvd\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_CDB
case|:
comment|/* 		 * New CDB 		 */
name|cdp
operator|->
name|cd_hba
operator|=
name|isp
expr_stmt|;
name|cdp
operator|->
name|cd_iid
operator|=
name|aep
operator|->
name|at_iid
expr_stmt|;
name|cdp
operator|->
name|cd_tgt
operator|=
literal|0
expr_stmt|;
name|cdp
operator|->
name|cd_lun
operator|=
name|aep
operator|->
name|at_lun
expr_stmt|;
name|MEMCPY
argument_list|(
name|cdp
operator|->
name|cd_cdb
argument_list|,
name|aep
operator|->
name|at_cdb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|cd_rxid
operator|=
name|aep
operator|->
name|at_rxid
expr_stmt|;
name|cdp
operator|->
name|cp_origdlen
operator|=
name|aep
operator|->
name|at_datalen
expr_stmt|;
name|cdp
operator|->
name|cp_totbytes
operator|=
literal|0
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: CDB 0x%x rx_id 0x%x itl %d/%d/%d dlen %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|cdp
operator|->
name|cd_cdb
index|[
literal|0
index|]
argument_list|,
name|cdp
operator|->
name|cd_tagval
argument_list|,
name|cdp
operator|->
name|cd_iid
argument_list|,
name|cdp
operator|->
name|cd_tgt
argument_list|,
name|cdp
operator|->
name|cd_lun
argument_list|,
name|aep
operator|->
name|at_datalen
argument_list|)
expr_stmt|;
call|(
modifier|*
name|isp
operator|->
name|isp_tmd_newcmd
call|)
argument_list|(
name|isp
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: Unknown status (0x%x) in ATIO2\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|cd_hba
operator|=
name|isp
expr_stmt|;
name|cdp
operator|->
name|cd_iid
operator|=
name|aep
operator|->
name|at_iid
expr_stmt|;
name|cdp
operator|->
name|cd_tgt
operator|=
name|aep
operator|->
name|at_tgt
expr_stmt|;
name|cdp
operator|->
name|cd_lun
operator|=
name|aep
operator|->
name|at_lun
expr_stmt|;
name|cdp
operator|->
name|cp_rxid
operator|=
name|aep
operator|->
name|at_rxid
expr_stmt|;
name|isp_tgtcmd_done
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_handle_ctio
parameter_list|(
name|isp
parameter_list|,
name|cep
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ct_entry_t
modifier|*
name|aep
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|isp_handle_ctio2
parameter_list|(
name|isp
parameter_list|,
name|cep
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|at2_entry_t
modifier|*
name|aep
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|isp_parse_status
parameter_list|(
name|isp
parameter_list|,
name|sp
parameter_list|,
name|xs
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
switch|switch
condition|(
name|sp
operator|->
name|req_completion_status
condition|)
block|{
case|case
name|RQCS_COMPLETE
case|:
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_INCOMPLETE
case|:
if|if
condition|(
operator|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_TARGET
operator|)
operator|==
literal|0
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Selection Timeout for target %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: command incomplete for target %d lun %d, state "
literal|"0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_state_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DMA_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: DMA error for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_TRANSPORT_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: transport error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp_prtstst
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_RESET_OCCURRED
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: bus reset destroyed command for target %d "
literal|"lun %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_ABORTED
case|:
name|PRINTF
argument_list|(
literal|"%s: command aborted for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ABORTED
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_TIMEOUT
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: command timed out for target %d lun %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_CMDTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_DATA_OVERRUN
case|:
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
break|break;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_DATAOVR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_COMMAND_OVERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: command overrun for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_STATUS_OVERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: status overrun for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_BAD_MESSAGE
case|:
name|PRINTF
argument_list|(
literal|"%s: message not COMMAND COMPLETE after status on "
literal|"target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_NO_MESSAGE_OUT
case|:
name|PRINTF
argument_list|(
literal|"%s: No MESSAGE OUT phase after selection on "
literal|"target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_EXT_ID_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: EXTENDED IDENTIFY failed on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_IDE_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected INITIATOR DETECTED "
literal|"ERROR message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ABORT_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected ABORT message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_REJECT_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected MESSAGE REJECT message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_NOP_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected NOP message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PARITY_ERROR_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected MESSAGE PARITY ERROR "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DEVICE_RESET_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected BUS DEVICE RESET "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ID_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected IDENTIFY "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_UNEXP_BUS_FREE
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d had an unexpected bus free\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DATA_UNDERRUN
case|:
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
comment|/* an UNDERRUN is not a botch ??? */
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_XACT_ERR1
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction with disconnect "
literal|"not set for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_XACT_ERR2
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction to target "
literal|"routine %d on target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_XACT_ERR3
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction for target %d lun "
literal|"%d when queueing disabled\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_BAD_ENTRY
case|:
name|PRINTF
argument_list|(
literal|"%s: invalid IOCB entry type detected\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_QUEUE_FULL
case|:
name|PRINTF
argument_list|(
literal|"%s: internal queues full for target %d lun %d "
literal|"status 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_STS
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If QFULL or some other status byte is set, then this 		 * isn't an error, per se. 		 */
if|if
condition|(
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|RQCS_PHASE_SKIPPED
case|:
name|PRINTF
argument_list|(
literal|"%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o "
literal|"STATUS phase) for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ARQS_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: Auto Request Sense failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ARQFAIL
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_WIDE_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: Wide Negotiation failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp
operator|->
name|isp_update
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_flags
operator|&=
operator|~
name|DPARM_WIDE
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_SYNCXFER_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: SDTR Message failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp
operator|->
name|isp_update
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_flags
operator|&=
operator|~
name|DPARM_SYNC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RQCS_LVD_BUSERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Bad LVD Bus condition while talking to target %d "
literal|"lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PORT_UNAVAILABLE
case|:
comment|/* 		 * No such port on the loop. Moral equivalent of SELTIMEO 		 */
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Port Unavailable for target %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_PORT_LOGGED_OUT
case|:
comment|/* 		 * It was there (maybe)- treat as a selection timeout. 		 */
name|PRINTF
argument_list|(
literal|"%s: port logout for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_PORT_CHANGED
case|:
name|PRINTF
argument_list|(
literal|"%s: port changed for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PORT_BUSY
case|:
name|PRINTF
argument_list|(
literal|"%s: port busy for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_TGTBSY
argument_list|)
expr_stmt|;
return|return;
default|default:
name|PRINTF
argument_list|(
literal|"%s: comp status %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_completion_status
argument_list|)
expr_stmt|;
break|break;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_fastpost_complete
parameter_list|(
name|isp
parameter_list|,
name|fph
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|fph
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
if|if
condition|(
name|fph
operator|<
literal|1
condition|)
return|return;
name|xs
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|fph
operator|-
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_xflist
index|[
name|fph
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: fast posting handle 0x%x not found\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fph
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Since we don't have a result queue entry item, 	 * we must believe that SCSI status is zero and 	 * that all data transferred. 	 */
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|fph
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|HINIB
parameter_list|(
name|x
parameter_list|)
value|((x)>> 0x4)
end_define

begin_define
define|#
directive|define
name|LONIB
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xf)
end_define

begin_define
define|#
directive|define
name|MAKNIB
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<< 4) | (b))
end_define

begin_decl_stmt
specifier|static
name|u_int8_t
name|mbpcnt
index|[]
init|=
block|{
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x00: MBOX_NO_OP */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x01: MBOX_LOAD_RAM */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x02: MBOX_EXEC_FIRMWARE */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x03: MBOX_DUMP_RAM */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x04: MBOX_WRITE_RAM_WORD */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x05: MBOX_READ_RAM_WORD */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x06: MBOX_MAILBOX_REG_TEST */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x07: MBOX_VERIFY_CHECKSUM	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x08: MBOX_ABOUT_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x09: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0d: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x0e: MBOX_CHECK_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0f: */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x10: MBOX_INIT_REQ_QUEUE */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x11: MBOX_INIT_RES_QUEUE */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x12: MBOX_EXECUTE_IOCB */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x13: MBOX_WAKE_UP	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x14: MBOX_STOP_FIRMWARE */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x15: MBOX_ABORT */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x16: MBOX_ABORT_DEVICE */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x17: MBOX_ABORT_TARGET */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x18: MBOX_BUS_RESET */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x19: MBOX_STOP_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1a: MBOX_START_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1c: MBOX_ABORT_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x1e: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x21: MBOX_GET_SELECT_TIMEOUT */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x22: MBOX_GET_RETRY_COUNT	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x23: MBOX_GET_TAG_AGE_LIMIT */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x24: MBOX_GET_CLOCK_RATE */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x25: MBOX_GET_ACT_NEG_STATE */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x27: MBOX_GET_PCI_PARAMS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x28: MBOX_GET_TARGET_PARAMS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2f: */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x30: MBOX_SET_INIT_SCSI_ID */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x31: MBOX_SET_SELECT_TIMEOUT */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x32: MBOX_SET_RETRY_COUNT	*/
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x33: MBOX_SET_TAG_AGE_LIMIT */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x34: MBOX_SET_CLOCK_RATE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x35: MBOX_SET_ACTIVE_NEG_STATE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x38: MBOX_SET_TARGET_PARAMS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3f: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x42: MBOX_EXEC_BIOS_IOCB */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x43: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x44: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x45: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x46: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x47: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x48: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x49: */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4f: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x50: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x51: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x52: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x53: */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x55: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x56: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x57: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x58: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x59: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5f: */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x60: MBOX_INIT_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x60: MBOX_GET_INIT_CONTROL_BLOCK  (FORMAT?) */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x62: MBOX_INIT_LIP */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x64: MBOX_GET_PORT_DB */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x65: MBOX_CLEAR_ACA */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x66: MBOX_TARGET_RESET */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x67: MBOX_CLEAR_TASK_SET */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x68: MBOX_ABORT_TASK_SET */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x69: MBOX_GET_FW_STATE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|8
argument_list|)
block|,
comment|/* 0x6a: MBOX_GET_PORT_NAME */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x6b: MBOX_GET_LINK_STATUS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x6c: MBOX_INIT_LIP_RESET */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x6d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x6e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x6f: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x70: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x71: */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
comment|/* 0x72: MBOX_INIT_LIP_LOGIN */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMBCOM
value|(sizeof (mbpcnt) / sizeof (mbpcnt[0]))
end_define

begin_function
specifier|static
name|void
name|isp_mboxcmd
parameter_list|(
name|isp
parameter_list|,
name|mbp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|mbreg_t
modifier|*
name|mbp
decl_stmt|;
block|{
name|int
name|outparam
decl_stmt|,
name|inparam
decl_stmt|;
name|int
name|loops
decl_stmt|,
name|dld
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|opcode
decl_stmt|;
if|if
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|==
name|ISP2100_SET_PCI_PARAM
condition|)
block|{
name|opcode
operator|=
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_PCI_PARAMETERS
expr_stmt|;
name|inparam
operator|=
literal|4
expr_stmt|;
name|outparam
operator|=
literal|4
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
elseif|else
if|if
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|>
name|NMBCOM
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad command %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcode
operator|=
name|mbp
operator|->
name|param
index|[
literal|0
index|]
expr_stmt|;
name|inparam
operator|=
name|HINIB
argument_list|(
name|mbpcnt
index|[
name|mbp
operator|->
name|param
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|outparam
operator|=
name|LONIB
argument_list|(
name|mbpcnt
index|[
name|mbp
operator|->
name|param
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|inparam
operator|==
literal|0
operator|&&
name|outparam
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: no parameters for %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check for variants 	 */
ifdef|#
directive|ifdef
name|ISP2100_SCCLUN
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
switch|switch
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_ABORT
case|:
name|inparam
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|MBOX_ABORT_DEVICE
case|:
case|case
name|MBOX_START_QUEUE
case|:
case|case
name|MBOX_STOP_QUEUE
case|:
case|case
name|MBOX_SINGLE_STEP_QUEUE
case|:
case|case
name|MBOX_ABORT_QUEUE
case|:
case|case
name|MBOX_GET_DEV_QUEUE_STATUS
case|:
name|inparam
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
name|command_known
label|:
comment|/* 	 * Set semaphore on mailbox registers to win any races to acquire them. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we can send some words. Check to see id there's 	 * an async mbox event pending. 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_HOST_INT
operator|)
operator|!=
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|1
condition|)
block|{
name|int
name|fph
decl_stmt|;
name|u_int16_t
name|mbox
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
decl_stmt|;
comment|/* 			 * We have a pending MBOX async event. 			 */
if|if
condition|(
name|mbox
operator|&
literal|0x8000
condition|)
block|{
name|fph
operator|=
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
operator|(
name|int
operator|)
name|mbox
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fph
operator|<
literal|0
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|fph
operator|>
literal|0
condition|)
block|{
name|isp_fastpost_complete
argument_list|(
name|isp
argument_list|,
name|fph
argument_list|)
expr_stmt|;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
comment|/* 			 * We have a pending MBOX completion? Might be 			 * from a previous command. We can't (sometimes) 			 * just clear HOST INTERRUPT, so we'll just silently 			 * eat this here. 			 */
if|if
condition|(
name|mbox
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
block|}
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dld
operator|++
operator|>
literal|10
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd could not get command "
literal|"started\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
block|}
comment|/* 	 * If we're a 1080 or a 1240, make sure that for a couple of commands 	 * the port parameter is set. This is sort of a temporary solution 	 * to do it here rather than every place a mailbox command is formed. 	 */
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_BUS_RESET
case|:
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
name|isp
operator|->
name|isp_port
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * Write input parameters. 	 */
switch|switch
condition|(
name|inparam
condition|)
block|{
case|case
literal|8
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX7
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|7
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX6
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|6
case|:
comment|/* 		 * The Qlogic 2100 cannot have registers 4 and 5 written to 		 * after initialization or BAD THINGS HAPPEN (tm). 		 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
operator|||
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_INIT_FIRMWARE
condition|)
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|5
case|:
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
operator|||
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_INIT_FIRMWARE
condition|)
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|4
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX3
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|3
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX2
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|2
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX1
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|1
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX0
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Clear RISC int condition. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Clear semaphore on mailbox registers so that the Qlogic 	 * may update outgoing registers. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Set Host Interrupt condition so that RISC will pick up mailbox regs. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_SET_HOST_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until HOST INT has gone away (meaning that the Qlogic 	 * has picked up the mailbox command. Wait a long time. 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
operator|*
literal|5
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_CMD_CLEAR_RISC_INT
operator|)
operator|!=
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #2\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * While the Semaphore registers isn't set, wait for the Qlogic 	 * to process the mailbox command. Again- wait a long time. 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
operator|*
literal|5
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Wierd- I've seen the case where the semaphore register 		 * isn't getting set- sort of a violation of the protocol.. 		 */
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|&
literal|0x4000
condition|)
break|break;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #3\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Make sure that the MBOX_BUSY has gone away 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|u_int16_t
name|mbox
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mbox
operator|==
name|MBOX_BUSY
condition|)
block|{
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #4\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We have a pending MBOX async event. 		 */
if|if
condition|(
name|mbox
operator|&
literal|0x8000
condition|)
block|{
name|int
name|fph
init|=
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
operator|(
name|int
operator|)
name|mbox
argument_list|)
decl_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fph
operator|<
literal|0
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|fph
operator|>
literal|0
condition|)
block|{
name|isp_fastpost_complete
argument_list|(
name|isp
argument_list|,
name|fph
argument_list|)
expr_stmt|;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* 	 * Pick up output parameters. 	 */
switch|switch
condition|(
name|outparam
condition|)
block|{
case|case
literal|8
case|:
name|mbp
operator|->
name|param
index|[
literal|7
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX7
argument_list|)
expr_stmt|;
case|case
literal|7
case|:
name|mbp
operator|->
name|param
index|[
literal|6
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX6
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|mbp
operator|->
name|param
index|[
literal|5
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX5
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|mbp
operator|->
name|param
index|[
literal|4
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|mbp
operator|->
name|param
index|[
literal|3
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX3
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|mbp
operator|->
name|param
index|[
literal|1
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear RISC int. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Release semaphore on mailbox registers 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Just to be chatty here... 	 */
switch|switch
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
break|break;
case|case
name|MBOX_INVALID_COMMAND
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: mbox cmd %x failed with INVALID_COMMAND\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_HOST_INTERFACE_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_TEST_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with TEST_FAILED\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with COMMAND_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_PARAM_ERROR
case|:
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MBOX_GET_PORT_DB
case|:
case|case
name|MBOX_GET_PORT_NAME
case|:
case|case
name|MBOX_GET_DEV_QUEUE_PARAMS
case|:
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with "
literal|"COMMAND_PARAM_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Be silent about these... 	 */
case|case
name|ASYNC_LIP_OCCURRED
case|:
case|case
name|ASYNC_LOOP_UP
case|:
case|case
name|ASYNC_LOOP_DOWN
case|:
case|case
name|ASYNC_LOOP_RESET
case|:
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
break|break;
case|case
name|ASYNC_PDB_CHANGED
case|:
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * The expected return of EXEC_FIRMWARE is zero. 		 */
if|if
condition|(
operator|(
name|opcode
operator|==
name|MBOX_EXEC_FIRMWARE
operator|&&
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|opcode
operator|!=
name|MBOX_EXEC_FIRMWARE
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with error %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
name|isp_lostcmd
parameter_list|(
name|isp
parameter_list|,
name|xs
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FIRMWARE_STATUS
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"couldn't GET FIRMWARE STATUS"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: %d commands on completion queue\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XS_NULL
argument_list|(
name|xs
argument_list|)
condition|)
return|return;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_DEV_QUEUE_STATUS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"couldn't GET DEVICE QUEUE STATUS"
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: lost command for target %d lun %d, %d active of %d, "
literal|"Queue State: %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"lost command"
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Need to try and do something to recover. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|isp_dumpregs
parameter_list|(
name|isp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|PRINTF
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
name|PRINTF
argument_list|(
literal|"    biu_conf1=%x"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PRINTF
argument_list|(
literal|"    biu_csr=%x"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|" biu_icr=%x biu_isr=%x biu_sema=%x "
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"risc_hccr=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_CONF
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_STATUS
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_FIFO_STS
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_CONF
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_STATUS
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_FIFO_STS
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_INTERRUPT
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_GROSS_ERR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
block|}
name|PRINTF
argument_list|(
literal|"    mbox regs: %x %x %x %x %x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX3
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_DUMPREGS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_dumpxflist
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
specifier|volatile
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hdp
decl_stmt|;
for|for
control|(
name|hdp
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|hdp
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: active requests\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|hdp
operator|++
expr_stmt|;
block|}
name|PRINTF
argument_list|(
literal|" Active Handle %d: tgt %d lun %d dlen %d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_fw_state
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|int
name|once
init|=
literal|0
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|again
label|:
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FW_STATE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
switch|switch
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|ASYNC_PDB_CHANGED
case|:
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ASYNC_LIP_OCCURRED
case|:
case|case
name|ASYNC_LOOP_UP
case|:
case|case
name|ASYNC_LOOP_DOWN
case|:
case|case
name|ASYNC_LOOP_RESET
case|:
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
if|if
condition|(
name|once
operator|++
operator|<
literal|2
condition|)
block|{
goto|goto
name|again
goto|;
block|}
break|break;
block|}
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"GET FIRMWARE STATE failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fcp
operator|->
name|isp_fwstate
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_update
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|tgt
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdparam
modifier|*
name|sdp
decl_stmt|;
name|isp
operator|->
name|isp_update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
return|return;
block|}
name|sdp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|u_int16_t
name|flags
decl_stmt|,
name|period
decl_stmt|,
name|offset
decl_stmt|,
name|changed
decl_stmt|;
name|int
name|get
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * If the goal is to update the status of the device, 		 * take what's in dev_flags and try and set the device 		 * toward that. Otherwise, if we're just refreshing the 		 * current device state, get the current parameters. 		 */
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
operator|=
literal|0
expr_stmt|;
comment|/* 			 * A command completion later that has 			 * RQSTF_NEGOTIATION set will cause 			 * the dev_refresh/announce cycle. 			 * 			 * Note: It is really important to update our current 			 * flags with at least the state of TAG capabilities- 			 * otherwise we might try and send a tagged command 			 * when we have it all turned off. So change it here 			 * to say that current already matches goal. 			 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|&=
operator|~
name|DPARM_TQING
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator||=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
operator|&
name|DPARM_TQING
operator|)
expr_stmt|;
name|get
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_TARGET_PARAMS
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
operator|=
literal|0
expr_stmt|;
name|get
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to %cet SCSI parameters for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
operator|(
name|get
operator|)
condition|?
literal|'g'
else|:
literal|'s'
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|get
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXX: Need a SYNC_TARGET for efficiency... 			 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|flags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|!=
name|flags
operator|||
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
operator|!=
name|period
operator|||
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|!=
name|offset
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: tgt %d flags 0x%x period %d "
literal|"off %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|tgt
operator|,
name|flags
operator|,
name|period
operator|,
name|offset
operator|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|changed
operator|=
literal|0
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
name|flags
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
operator|=
name|period
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_announced
operator|==
literal|0
operator|||
name|changed
condition|)
block|{
if|if
condition|(
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_NEW_TGT_PARAMS
argument_list|,
operator|&
name|tgt
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_announced
operator|=
literal|0
expr_stmt|;
else|else
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_announced
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_setdfltparm
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|tgt
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdparam
modifier|*
name|sdp
decl_stmt|;
comment|/* 	 * Been there, done that, got the T-shirt... 	 */
if|if
condition|(
name|isp
operator|->
name|isp_gotdparms
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: already have dparms\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_gotdparms
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If we've not been told to avoid reading NVRAM, try and read it. 	 * If we're successful reading it, we can return since NVRAM will 	 * tell us the right thing to do. Otherwise, establish some reasonable 	 * defaults. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NONVRAM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isp_read_nvram
argument_list|(
name|isp
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|fcp
operator|->
name|isp_maxfrmlen
operator|=
name|ICB_DFLT_FRMLEN
expr_stmt|;
name|fcp
operator|->
name|isp_maxalloc
operator|=
literal|256
expr_stmt|;
name|fcp
operator|->
name|isp_execthrottle
operator|=
literal|16
expr_stmt|;
name|fcp
operator|->
name|isp_retry_delay
operator|=
literal|5
expr_stmt|;
name|fcp
operator|->
name|isp_retry_count
operator|=
literal|3
expr_stmt|;
name|fcp
operator|->
name|isp_loopid
operator|=
name|DEFAULT_LOOPID
expr_stmt|;
comment|/* 		 * It would be nice to fake up a WWN in case we don't 		 * get one out of NVRAM. Solaris does this for SOCAL 		 * cards that don't have SBus properties- it sets up 		 * a WWN based upon the system MAC Address. 		 */
name|fcp
operator|->
name|isp_wwn
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sdp
operator|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_ACT_NEG_STATE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"could not GET ACT NEG STATE\n"
operator|)
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x1
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x1
expr_stmt|;
block|}
comment|/* 	 * The trick here is to establish a default for the default (honk!) 	 * state (dev_flags). Then try and get the current status from 	 * the card to fill in the current state. We don't, in fact, set 	 * the default to the SAFE default state- that's not the goal state. 	 */
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
operator|=
name|DPARM_DEFAULT
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1040
operator|||
operator|(
name|sdp
operator|->
name|isp_clock
operator|&&
name|sdp
operator|->
name|isp_clock
operator|<
literal|60
operator|)
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|ISP_10M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|ISP_10M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|ISP_40M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|ISP_40M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|ISP_20M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|ISP_20M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* 		 * Don't get current target parameters if we've been 		 * told not to use NVRAM- it's really the same thing. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NONVRAM
condition|)
block|{
continue|continue;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
continue|continue;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
comment|/* 		 * The maximum period we can really see 		 * here is 100 (decimal), or 400 ns. 		 * For some unknown reason we sometimes 		 * get back wildass numbers from the 		 * boot device's parameters (alpha only). 		 */
if|if
condition|(
operator|(
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|<=
literal|0x64
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
block|}
comment|/* 		 * It is not safe to run Ultra Mode with a clock< 60. 		 */
if|if
condition|(
operator|(
operator|(
name|sdp
operator|->
name|isp_clock
operator|&&
name|sdp
operator|->
name|isp_clock
operator|<
literal|60
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1020A
operator|)
operator|)
operator|&&
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|<=
operator|(
name|ISP_20M_SYNCPARMS
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|ISP_10M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|ISP_10M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
comment|/* 	 * Set Default Host Adapter Parameters 	 */
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_initiator_id
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|>=
name|ISP_HA_SCSI_1040
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|6
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_selection_timeout
operator|=
literal|250
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|MAXISPREQUEST
expr_stmt|;
name|sdp
operator|->
name|isp_tag_aging
operator|=
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
literal|3
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
operator|=
literal|16
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Re-initialize the ISP and complete all orphaned commands  * with a 'botched' notice.  *  * Locks held prior to coming here.  */
end_comment

begin_function
name|void
name|isp_restart
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|tlist
index|[
name|RQUEST_QUEUE_LEN
index|]
decl_stmt|,
modifier|*
name|xs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|tlist
index|[
name|i
index|]
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
expr_stmt|;
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|isp
operator|->
name|isp_gotdparms
operator|=
literal|0
expr_stmt|;
name|isp_reset
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|==
name|ISP_RESETSTATE
condition|)
block|{
name|isp_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|==
name|ISP_INITSTATE
condition|)
block|{
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RUNSTATE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_restart cannot restart ISP\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
name|tlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|XS_NULL
argument_list|(
name|xs
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_nactive
operator|>
literal|0
condition|)
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * NVRAM Routines  */
end_comment

begin_function
specifier|static
name|int
name|isp_read_nvram
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|amt
decl_stmt|;
name|u_int8_t
name|csum
decl_stmt|,
name|minversion
decl_stmt|;
union|union
block|{
name|u_int8_t
name|_x
index|[
name|ISP2100_NVRAM_SIZE
index|]
decl_stmt|;
name|u_int16_t
name|_s
index|[
name|ISP2100_NVRAM_SIZE
operator|>>
literal|1
index|]
expr_stmt|;
block|}
name|_n
union|;
define|#
directive|define
name|nvram_data
value|_n._x
define|#
directive|define
name|nvram_words
value|_n._s
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|amt
operator|=
name|ISP2100_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|amt
operator|=
name|ISP_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Just read the first two words first to see if we have a valid 	 * NVRAM to continue reading the rest with. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|isp_rdnvram_word
argument_list|(
name|isp
argument_list|,
name|i
argument_list|,
operator|&
name|nvram_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvram_data
index|[
literal|0
index|]
operator|!=
literal|'I'
operator|||
name|nvram_data
index|[
literal|1
index|]
operator|!=
literal|'S'
operator|||
name|nvram_data
index|[
literal|2
index|]
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|!=
name|ISP_BT_SBUS
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: invalid NVRAM header\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|amt
operator|>>
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|isp_rdnvram_word
argument_list|(
name|isp
argument_list|,
name|i
argument_list|,
operator|&
name|nvram_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|amt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|nvram_data
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|csum
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: invalid NVRAM checksum\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ISP_NVRAM_VERSION
argument_list|(
name|nvram_data
argument_list|)
operator|<
name|minversion
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: version %d NVRAM not understood\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ISP_NVRAM_VERSION
argument_list|(
name|nvram_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
name|ISP_NVRAM_FIFO_THRESHOLD
argument_list|(
name|nvram_data
argument_list|)
operator||
operator|(
name|ISP_NVRAM_FIFO_THRESHOLD_128
argument_list|(
name|nvram_data
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|sdp
operator|->
name|isp_initiator_id
operator|=
name|ISP_NVRAM_INITIATOR_ID
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
name|ISP_NVRAM_BUS_RESET_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
name|ISP_NVRAM_BUS_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
name|ISP_NVRAM_BUS_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_async_data_setup
operator|=
name|ISP_NVRAM_ASYNC_DATA_SETUP_TIME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|>=
name|ISP_HA_SCSI_1040
condition|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_async_data_setup
operator|<
literal|9
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|9
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_async_data_setup
operator|!=
literal|6
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|6
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
name|ISP_NVRAM_REQ_ACK_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
name|ISP_NVRAM_DATA_LINE_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
name|ISP_NVRAM_DATA_DMA_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
name|ISP_NVRAM_CMD_DMA_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_tag_aging
operator|=
name|ISP_NVRAM_TAG_AGE_LIMIT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_selection_timeout
operator|=
name|ISP_NVRAM_SELECTION_TIMEOUT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|ISP_NVRAM_MAX_QUEUE_DEPTH
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_fast_mttr
operator|=
name|ISP_NVRAM_FAST_MTTR_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
condition|)
block|{
specifier|static
name|char
modifier|*
name|true
init|=
literal|"true"
decl_stmt|;
specifier|static
name|char
modifier|*
name|false
init|=
literal|"false"
decl_stmt|;
name|PRINTF
argument_list|(
literal|"%s: NVRAM values:\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"             Fifo Threshold = 0x%x\n"
argument_list|,
name|sdp
operator|->
name|isp_fifo_threshold
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"            Bus Reset Delay = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_bus_reset_delay
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"                Retry Count = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_retry_count
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"                Retry Delay = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_retry_delay
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"              Tag Age Limit = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_tag_aging
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          Selection Timeout = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_selection_timeout
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"            Max Queue Depth = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_max_queue_depth
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"           Async Data Setup = 0x%x\n"
argument_list|,
name|sdp
operator|->
name|isp_async_data_setup
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    REQ/ACK Active Negation = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_req_ack_active_neg
condition|?
name|true
else|:
name|false
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"  Data Line Active Negation = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_data_line_active_neg
condition|?
name|true
else|:
name|false
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"      Data DMA Burst Enable = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_data_dma_burst_enabl
condition|?
name|true
else|:
name|false
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"       Cmd DMA Burst Enable = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
condition|?
name|true
else|:
name|false
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"                  Fast MTTR = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_fast_mttr
condition|?
name|true
else|:
name|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_enable
operator|=
name|ISP_NVRAM_TGT_DEVICE_ENABLE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|exc_throttle
operator|=
name|ISP_NVRAM_TGT_EXEC_THROTTLE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
name|ISP_NVRAM_TGT_SYNC_OFFSET
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
name|ISP_NVRAM_TGT_SYNC_PERIOD
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1040
condition|)
block|{
comment|/* 				 * If we're not ultra, we can't possibly 				 * be a shorter period than this. 				 */
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|<
literal|0x19
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
literal|0x19
expr_stmt|;
block|}
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|>
literal|0xc
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
literal|0x0c
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|>
literal|0x8
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
literal|0x8
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_RENEG
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_RENEG
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_QFRZ
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: not supporting QFRZ option for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_ARQ
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_ARQ
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: not disabling ARQ option for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISP_NVRAM_TGT_TQING
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_SYNC
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_SYNC
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_WIDE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_WIDE
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_PARITY
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_PARITY
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_DISC
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_DISC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|cur_dflags
operator|=
literal|0
expr_stmt|;
comment|/* we don't know */
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
condition|)
block|{
name|PRINTF
argument_list|(
literal|"   Target %d: Enabled %d Throttle %d "
literal|"Offset %d Period %d Flags 0x%x\n"
argument_list|,
name|i
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_enable
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|exc_throttle
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
union|union
block|{
struct|struct
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|u_int32_t
name|hi32
decl_stmt|;
name|u_int32_t
name|lo32
decl_stmt|;
else|#
directive|else
name|u_int32_t
name|lo32
decl_stmt|;
name|u_int32_t
name|hi32
decl_stmt|;
endif|#
directive|endif
block|}
name|wds
struct|;
name|u_int64_t
name|full64
decl_stmt|;
block|}
name|wwnstore
union|;
name|wwnstore
operator|.
name|full64
operator|=
name|ISP2100_NVRAM_NODE_NAME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Adapter WWN 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|wwnstore
operator|.
name|wds
operator|.
name|hi32
argument_list|,
name|wwnstore
operator|.
name|wds
operator|.
name|lo32
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_wwn
operator|=
name|wwnstore
operator|.
name|full64
expr_stmt|;
name|wwnstore
operator|.
name|full64
operator|=
name|ISP2100_NVRAM_BOOT_NODE_NAME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|wwnstore
operator|.
name|full64
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: BOOT DEVICE WWN 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|wwnstore
operator|.
name|wds
operator|.
name|hi32
argument_list|,
name|wwnstore
operator|.
name|wds
operator|.
name|lo32
argument_list|)
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_maxalloc
operator|=
name|ISP2100_NVRAM_MAXIOCBALLOCATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_maxfrmlen
operator|=
name|ISP2100_NVRAM_MAXFRAMELENGTH
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_delay
operator|=
name|ISP2100_NVRAM_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_count
operator|=
name|ISP2100_NVRAM_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_loopid
operator|=
name|ISP2100_NVRAM_HARDLOOPID
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_execthrottle
operator|=
name|ISP2100_NVRAM_EXECUTION_THROTTLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator|=
name|ISP2100_NVRAM_OPTIONS
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: NVRAM values:\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"  Max IOCB Allocation = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_maxalloc
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"     Max Frame Length = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_maxfrmlen
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"   Execution Throttle = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_execthrottle
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          Retry Count = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_retry_count
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          Retry Delay = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_retry_delay
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"         Hard Loop ID = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_loopid
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"              Options = 0x%x\n"
argument_list|,
name|fcp
operator|->
name|isp_fwoptions
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          HBA Options = 0x%x\n"
argument_list|,
name|ISP2100_NVRAM_HBA_OPTIONS
argument_list|(
name|nvram_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: NVRAM is valid\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_rdnvram_word
parameter_list|(
name|isp
parameter_list|,
name|wo
parameter_list|,
name|rp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|wo
decl_stmt|;
name|u_int16_t
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|cbits
decl_stmt|;
name|u_int16_t
name|bit
decl_stmt|,
name|rqst
decl_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP2100_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|8
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|6
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|8
expr_stmt|;
block|}
comment|/* 	 * Clock the word select request out... 	 */
for|for
control|(
name|i
operator|=
name|cbits
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|rqst
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|bit
operator|=
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_DATAOUT
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
name|BIU_NVRAM_SELECT
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now read the result back in (bits come back in MSB format). 	 */
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|u_int16_t
name|rv
decl_stmt|;
operator|*
name|rp
operator|<<=
literal|1
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&
name|BIU_NVRAM_DATAIN
condition|)
block|{
operator|*
name|rp
operator||=
literal|1
expr_stmt|;
block|}
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|*
name|rp
operator|=
operator|(
operator|(
operator|*
name|rp
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
name|rp
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

