begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Machine and OS Independent (well, as best as possible)  * code for the Qlogic ISP SCSI adapters.  *  *---------------------------------------  * Copyright (c) 1997, 1998, 1999 by Matthew Jacob  * NASA/Ames Research Center  * All rights reserved.  *---------------------------------------  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Inspiration and ideas about this driver are from Erik Moe's Linux driver  * (qlogicisp.c) and Dave Miller's SBus version of same (qlogicisp.c). Some  * ideas dredged from the Solaris driver.  */
end_comment

begin_comment
comment|/*  * Include header file appropriate for platform we're building on.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/isp_netbsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/isp/isp_freebsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/isp_openbsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|"isp_linux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * General defines  */
end_comment

begin_define
define|#
directive|define
name|MBOX_DELAY_COUNT
value|1000000 / 100
end_define

begin_comment
comment|/*  * Local static data  */
end_comment

begin_comment
comment|/*  * Local function prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|isp_parse_async
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_handle_other_response
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ispstatusreq_t
operator|*
operator|,
name|u_int8_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_parse_status
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ispstatusreq_t
operator|*
operator|,
name|ISP_SCSI_XFER_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_fastpost_complete
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_scsi_init
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_scsi_channel_init
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_fibre_init
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_mark_getpdb_all
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_getpdb
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|isp_pdb_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int64_t
name|isp_get_portname
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_fclink_test
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_same_lportdb
name|__P
argument_list|(
operator|(
expr|struct
name|lportdb
operator|*
operator|,
expr|struct
name|lportdb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_pdb_sync
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ISP2100_FABRIC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|isp_scan_fabric
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|isp_fw_state
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_dumpregs
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_mboxcmd
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|mbreg_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_update
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_update_bus
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_setdfltparm
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_read_nvram
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_rdnvram_word
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|u_int16_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reset Hardware.  *  * Hit the chip over the head, download new f/w and set it running.  *  * Locking done elsewhere.  */
end_comment

begin_function
name|void
name|isp_reset
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|loops
decl_stmt|,
name|i
decl_stmt|,
name|dodnld
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|revname
decl_stmt|;
name|isp
operator|->
name|isp_state
operator|=
name|ISP_NILSTATE
expr_stmt|;
comment|/* 	 * Basic types (SCSI, FibreChannel and PCI or SBus) 	 * have been set in the MD code. We figure out more 	 * here. 	 */
name|isp
operator|->
name|isp_dblev
operator|=
name|DFLT_DBLEVEL
expr_stmt|;
comment|/* 	 * After we've fired this chip up, zero out the conf1 register 	 * for SCSI adapters and other settings for the 2100. 	 */
comment|/* 	 * Get the current running firmware revision out of the 	 * chip before we hit it over the head (if this is our 	 * first time through). Note that we store this as the 	 * 'ROM' firmware revision- which it may not be. In any 	 * case, we don't really use this yet, but we may in 	 * the future. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_used
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Just in case it was paused... 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABOUT_FIRMWARE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
comment|/* 		 * If this fails, it probably means we're running 		 * an old prom, if anything at all... 		 */
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
expr_stmt|;
block|}
name|isp
operator|->
name|isp_used
operator|=
literal|1
expr_stmt|;
block|}
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Put the board into PAUSE mode. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|revname
operator|=
literal|"2X00"
expr_stmt|;
switch|switch
condition|(
name|isp
operator|->
name|isp_type
condition|)
block|{
case|case
name|ISP_HA_FC_2100
case|:
name|revname
index|[
literal|1
index|]
operator|=
literal|'1'
expr_stmt|;
break|break;
case|case
name|ISP_HA_FC_2200
case|:
name|revname
index|[
literal|1
index|]
operator|=
literal|'2'
expr_stmt|;
comment|/* 			 * Resident firmware for the 2200 appears 			 * to have SCCLUN enabled. 			 */
ifndef|#
directive|ifndef
name|ISP2100_SCCLUN
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: WARNING- using resident f/w without"
literal|" SCCLUN support defined\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|revname
operator|=
literal|"12X0"
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|u_int16_t
name|l
decl_stmt|;
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|revname
operator|=
literal|"1080"
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|100
expr_stmt|;
name|l
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_DIFF
argument_list|)
operator|&
name|ISP1080_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|l
condition|)
block|{
case|case
name|ISP1080_LVD_MODE
case|:
name|sdp
operator|->
name|isp_lvdmode
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: LVD Mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP1080_HVD_MODE
case|:
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Differential Mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISP1080_SE_MODE
case|:
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Single-Ended Mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Hmm. Up in a wierd mode. This means all SCSI I/O 			 * buffer lines are tristated, so we're in a lot of 			 * trouble if we don't set things up right. 			 */
name|PRINTF
argument_list|(
literal|"%s: Illegal Mode 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|i
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_CONF0
argument_list|)
operator|&
name|BIU_CONF0_HW_MASK
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|PRINTF
argument_list|(
literal|"%s: unknown chip rev. 0x%x- assuming a 1020\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|revname
operator|=
literal|"1020"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1020
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * Some 1020A chips are Ultra Capable, but don't 			 * run the clock rate up for that unless told to 			 * do so by the Ultra Capable bits being set. 			 */
name|revname
operator|=
literal|"1020A"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1020A
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|revname
operator|=
literal|"1040"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|revname
operator|=
literal|"1040A"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040A
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|revname
operator|=
literal|"1040B"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040B
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|revname
operator|=
literal|"1040C(?)"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040C
expr_stmt|;
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
block|}
comment|/* 		 * Now, while we're at it, gather info about ultra 		 * and/or differential mode. 		 */
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_DIFF
argument_list|)
operator|&
name|SXP_PINS_DIFF_MODE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Differential Mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|RISC_PSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|==
name|ISP_BT_SBUS
condition|)
block|{
name|i
operator|&=
name|RISC_PSR_SBUS_ULTRA
expr_stmt|;
block|}
else|else
block|{
name|i
operator|&=
name|RISC_PSR_PCI_ULTRA
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Ultra Mode Capable\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If we're in Ultra Mode, we have to be 60Mhz clock- 			 * even for the SBus version. 			 */
name|isp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Clock is known. Gronk. 			 */
block|}
comment|/* 		 * Machine dependent clock (if set) overrides 		 * our generic determinations. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
operator|<
name|isp
operator|->
name|isp_clock
condition|)
block|{
name|isp
operator|->
name|isp_clock
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Do MD specific pre initialization 	 */
name|ISP_RESET0
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* 	 * Hit the chip over the head with hammer, 	 * and give the ISP a chance to recover. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|,
name|BIU_ICR_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 		 * A slight delay... 		 */
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|PRINTF("%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 		    isp->isp_name, ISP_READ(isp, OUTMAILBOX0), 		    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2), 		    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4), 		    ISP_READ(isp, OUTMAILBOX5));
endif|#
directive|endif
comment|/* 		 * Clear data&& control DMA engines. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|CDMA_CONTROL
argument_list|,
name|DMA_CNTRL_CLEAR_CHAN
operator||
name|DMA_CNTRL_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|DDMA_CONTROL
argument_list|,
name|DMA_CNTRL_CLEAR_CHAN
operator||
name|DMA_CNTRL_RESET_INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 		 * A slight delay... 		 */
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Clear data&& control DMA engines. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|CDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|TDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for ISP to be ready to go... 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|)
operator|&
name|BIU_ICR_SOFT_RESET
operator|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
operator|&
name|BIU2100_SOFT_RESET
operator|)
condition|)
break|break;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"chip reset timed out"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * After we've fired this chip up, zero out the conf1 register 	 * for SCSI adapters and other settings for the 2100. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset RISC Processor 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RESET
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 	 * Establish some initial burst rate stuff. 	 * (only for the 1XX0 boards). This really should 	 * be done later after fetching from NVRAM. 	 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|u_int16_t
name|tmp
init|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_conf1
decl_stmt|;
comment|/* 		 * Busted FIFO. Turn off all but burst enables. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|==
name|ISP_HA_SCSI_1040A
condition|)
block|{
name|tmp
operator|&=
name|BIU_BURST_ENABLE
expr_stmt|;
block|}
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|BIU_BURST_ENABLE
condition|)
block|{
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|CDMA_CONF
argument_list|,
name|DMA_ENABLE_BURST
argument_list|)
expr_stmt|;
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|DDMA_CONF
argument_list|,
name|DMA_ENABLE_BURST
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PTI_CARDS
if|if
condition|(
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
condition|)
block|{
while|while
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|)
operator|!=
literal|0x1313
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1313
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_STEP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * PTI specific register 		 */
name|ISP_WRITE
argument_list|(
argument|isp
argument_list|,
argument|RISC_EMB
argument_list|,
argument|DUAL_BANK
argument_list|)
else|#
directive|else
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR2100
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
comment|/* release paused processor */
comment|/* 	 * Do MD specific post initialization 	 */
name|ISP_RESET1
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for everything to finish firing up... 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|==
name|MBOX_BUSY
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: MBOX_BUSY never cleared on reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Up until this point we've done everything by just reading or 	 * setting registers. From this point on we rely on at least *some* 	 * kind of firmware running in the card. 	 */
comment|/* 	 * Do some sanity checking. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_NO_OP
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"NOP test failed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_MAILBOX_REG_TEST
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0xdead
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0xbeef
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0x1111
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0xa5a5
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"Mailbox Register test didn't complete"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0xdead
operator|||
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|!=
literal|0xbeef
operator|||
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|!=
literal|0xffff
operator|||
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|!=
literal|0x1111
operator|||
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|!=
literal|0xa5a5
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"Register Test Failed"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Download new Firmware, unless requested not to do so. 	 * This is made slightly trickier in some cases where the 	 * firmware of the ROM revision is newer than the revision 	 * compiled into the driver. So, where we used to compare 	 * versions of our f/w and the ROM f/w, now we just see 	 * whether we have f/w at all and whether a config flag 	 * has disabled our download. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NORELOAD
operator|)
condition|)
block|{
name|dodnld
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dodnld
operator|&&
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
condition|;
name|i
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_WRITE_RAM_WORD
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
operator|+
name|i
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_ispfw
index|[
name|i
index|]
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: F/W download failed at word %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dodnld
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* 		 * Verify that it downloaded correctly. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_VERIFY_CHECKSUM
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"ram checksum failure"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: skipping f/w download\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now start it rolling. 	 * 	 * If we didn't actually download f/w, 	 * we still need to (re)start it. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_EXEC_FIRMWARE
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
expr_stmt|;
else|else
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0x1000
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
comment|/* 		 * Set CLOCK RATE, but only if asked to. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_clock
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_CLOCK_RATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_clock
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"failed to set clockrate (0x%x)\n"
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* but continue */
block|}
block|}
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABOUT_FIRMWARE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"could not get f/w started (0x%x)\n"
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|CFGPRINTF
argument_list|(
literal|"%s: Board Revision %s, %s F/W Revision %d.%d.%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|revname
argument_list|,
name|dodnld
condition|?
literal|"loaded"
else|:
literal|"resident"
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
operator|&
name|BIU2100_PCI64
condition|)
block|{
name|CFGPRINTF
argument_list|(
literal|"%s: in 64-Bit PCI slot\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
block|}
name|isp
operator|->
name|isp_fwrev
index|[
literal|0
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
index|[
literal|1
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
index|[
literal|2
index|]
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
operator|||
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
operator|||
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
condition|)
block|{
name|CFGPRINTF
argument_list|(
literal|"%s: Last F/W revision was %d.%d.%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|0
index|]
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|1
index|]
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FIRMWARE_STATUS
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: could not GET FIRMWARE STATUS\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_maxcmds
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|CFGPRINTF
argument_list|(
literal|"%s: %d max I/O commands supported\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|isp_fw_state
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Set up DMA for the request and result mailboxes. 	 */
if|if
condition|(
name|ISP_MBOXDMASETUP
argument_list|(
name|isp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: can't setup dma mailboxes\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RESETSTATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize Parameters of Hardware to a known state.  *  * Locks are held before coming here.  */
end_comment

begin_function
name|void
name|isp_init
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
comment|/* 	 * Must do this first to get defaults established. 	 */
name|isp_setdfltparm
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_setdfltparm
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_fibre_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isp_scsi_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_scsi_init
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|sdparam
modifier|*
name|sdp_chan0
decl_stmt|,
modifier|*
name|sdp_chan1
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdp_chan0
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
name|sdp_chan1
operator|=
name|sdp_chan0
expr_stmt|;
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdp_chan1
operator|++
expr_stmt|;
block|}
comment|/* First do overall per-card settings. */
comment|/* 	 * If we have fast memory timing enabled, turn it on. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_fast_mttr
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR
argument_list|,
literal|0x1313
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set Retry Delay and Count. 	 * You set both channels at the same time. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_RETRY_COUNT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_retry_count
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_retry_delay
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_retry_count
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_retry_delay
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set retry count and retry delay\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set ASYNC DATA SETUP time. This is very important. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_ASYNC_DATA_SETUP_TIME
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_async_data_setup
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_async_data_setup
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set asynchronous data setup time\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set ACTIVE Negation State. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_ACT_NEG_STATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|sdp_chan0
operator|->
name|isp_req_ack_active_neg
operator|<<
literal|4
operator|)
operator||
operator|(
name|sdp_chan0
operator|->
name|isp_data_line_active_neg
operator|<<
literal|5
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
operator|(
name|sdp_chan1
operator|->
name|isp_req_ack_active_neg
operator|<<
literal|4
operator|)
operator||
operator|(
name|sdp_chan1
operator|->
name|isp_data_line_active_neg
operator|<<
literal|5
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set active negation state "
literal|"(%d,%d),(%d,%d)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sdp_chan0
operator|->
name|isp_req_ack_active_neg
argument_list|,
name|sdp_chan0
operator|->
name|isp_data_line_active_neg
argument_list|,
name|sdp_chan1
operator|->
name|isp_req_ack_active_neg
argument_list|,
name|sdp_chan1
operator|->
name|isp_data_line_active_neg
argument_list|)
expr_stmt|;
comment|/* 		 * But don't return. 		 */
block|}
comment|/* 	 * Set the Tag Aging limit 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TAG_AGE_LIMIT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_tag_aging
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_tag_aging
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set tag age limit (%d,%d)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sdp_chan0
operator|->
name|isp_tag_aging
argument_list|,
name|sdp_chan1
operator|->
name|isp_tag_aging
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set selection timeout. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_SELECT_TIMEOUT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp_chan0
operator|->
name|isp_selection_timeout
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp_chan1
operator|->
name|isp_selection_timeout
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set selection timeout\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* now do per-channel settings */
name|isp_scsi_channel_init
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
name|isp_scsi_channel_init
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Now enable request/response queues 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_RES_QUEUE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RESULT_QUEUE_LEN
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: set of response queue failed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_residx
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_REQ_QUEUE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RQUEST_QUEUE_LEN
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: set of request queue failed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Turn on Fast Posting, LVD transitions 	 */
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|||
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|>=
name|ISP_FW_REV
argument_list|(
literal|7
argument_list|,
literal|55
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_FW_FEATURES
expr_stmt|;
ifndef|#
directive|ifndef
name|ISP_NO_FASTPOST_SCSI
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
name|FW_FEATURE_FAST_POST
expr_stmt|;
else|#
directive|else
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
name|FW_FEATURE_LVD_NOTIFY
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: unable enable FW features\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Let the outer layers decide whether to issue a SCSI bus reset. 	 */
name|isp
operator|->
name|isp_state
operator|=
name|ISP_INITSTATE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_scsi_channel_init
parameter_list|(
name|isp
parameter_list|,
name|channel
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|channel
decl_stmt|;
block|{
name|sdparam
modifier|*
name|sdp
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|tgt
decl_stmt|;
name|sdp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
name|sdp
operator|+=
name|channel
expr_stmt|;
comment|/* 	 * Set (possibly new) Initiator ID. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_INIT_SCSI_ID
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|channel
operator|<<
literal|7
operator|)
operator||
name|sdp
operator|->
name|isp_initiator_id
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: cannot set initiator id on bus %d to %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|channel
argument_list|,
name|sdp
operator|->
name|isp_initiator_id
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set current per-target parameters to a safe minimum. 	 */
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|int
name|maxlun
decl_stmt|,
name|lun
decl_stmt|;
name|u_int16_t
name|sdf
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|==
literal|0
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: skipping target %d bus %d settings\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|tgt
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we're in LVD mode, then we pretty much should 		 * only disable tagged queuing. 		 */
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|&&
name|sdp
operator|->
name|isp_lvdmode
condition|)
block|{
name|sdf
operator|=
name|DPARM_DEFAULT
operator|&
operator|~
name|DPARM_TQING
expr_stmt|;
block|}
else|else
block|{
name|sdf
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
comment|/* 			 * It is not quite clear when this changed over so that 			 * we could force narrow and async, so assume>= 7.55. 			 */
if|if
condition|(
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|>=
name|ISP_FW_REV
argument_list|(
literal|7
argument_list|,
literal|55
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|sdf
operator||=
name|DPARM_NARROW
operator||
name|DPARM_ASYNC
expr_stmt|;
block|}
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
operator|(
name|channel
operator|<<
literal|15
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdf
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|sdf
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
operator|(
name|channel
operator|<<
literal|15
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdf
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed even to set defaults for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|#
directive|if
literal|0
comment|/* 		 * We don't update dev_flags with what we've set 		 * because that's not the ultimate goal setting. 		 * If we succeed with the command, we *do* update 		 * cur_dflags by getting target parameters. 		 */
block|mbs.param[0] = MBOX_GET_TARGET_PARAMS; 		mbs.param[1] = (tgt<< 8) | (channel<< 15); 		isp_mboxcmd(isp,&mbs); 		if (mbs.param[0] != MBOX_COMMAND_COMPLETE) {
comment|/* 			 * Urrr.... We'll set cur_dflags to DPARM_SAFE_DFLT so 			 * we don't try and do tags if tags aren't enabled. 			 */
block|sdp->isp_devparam[tgt].cur_dflags = DPARM_SAFE_DFLT; 		} else { 			sdp->isp_devparam[tgt].cur_dflags = mbs.param[2]; 			sdp->isp_devparam[tgt].cur_offset = mbs.param[3]>> 8; 			sdp->isp_devparam[tgt].cur_period = mbs.param[3]& 0xff; 		} 		IDPRINTF(3, ("%s: set flags 0x%x got 0x%x back for target %d\n", 		    isp->isp_name, sdf, mbs.param[2], tgt));
else|#
directive|else
comment|/* 		 * We don't update any information because we need to run 		 * at least one command per target to cause a new state 		 * to be latched. 		 */
endif|#
directive|endif
comment|/* 		 * Ensure that we don't believe tagged queuing is enabled yet. 		 * It turns out that sometimes the ISP just ignores our 		 * attempts to set parameters for devices that it hasn't 		 * seen yet. 		 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|&=
operator|~
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|>=
name|ISP_FW_REV
argument_list|(
literal|7
argument_list|,
literal|55
argument_list|,
literal|0
argument_list|)
condition|)
name|maxlun
operator|=
literal|32
expr_stmt|;
else|else
name|maxlun
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|maxlun
condition|;
name|lun
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_DEV_QUEUE_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|channel
operator|<<
literal|15
operator|)
operator||
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
name|lun
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_max_queue_depth
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set device queue "
literal|"parameters for target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|,
name|lun
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Fibre Channel specific initialization.  *  * Locks are held before coming here.  */
end_comment

begin_function
specifier|static
name|void
name|isp_fibre_init
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|fcparam
modifier|*
name|fcp
decl_stmt|;
name|isp_icb_t
modifier|*
name|icbp
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|loopid
decl_stmt|;
name|fcp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
comment|/* 	 * For systems that don't have BIOS methods for which 	 * we can easily change the NVRAM based loopid, we'll 	 * override that here. Note that when we initialize 	 * the firmware we may get back a different loopid than 	 * we asked for anyway. XXX This is probably not the 	 * best way to figure this out XXX 	 */
ifndef|#
directive|ifndef
name|__i386__
name|loopid
operator|=
name|DEFAULT_LOOPID
argument_list|(
name|isp
argument_list|)
expr_stmt|;
else|#
directive|else
name|loopid
operator|=
name|fcp
operator|->
name|isp_loopid
expr_stmt|;
endif|#
directive|endif
name|icbp
operator|=
operator|(
name|isp_icb_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
expr_stmt|;
name|MEMZERO
argument_list|(
name|icbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|icbp
argument_list|)
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_version
operator|=
name|ICB_VERSION1
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|fcp
operator|->
name|isp_fwoptions
operator|=
name|ICBOPT_TGT_ENABLE
expr_stmt|;
else|#
directive|else
name|fcp
operator|->
name|isp_fwoptions
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FAIRNESS
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_PDBCHANGE_AE
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_HARD_ADDRESS
expr_stmt|;
comment|/* 	 * We have to use FULL LOGIN even though it resets the loop too much 	 * because otherwise port database entries don't get updated after 	 * a LIP- this is a known f/w bug. 	 */
if|if
condition|(
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|<
name|ISP_FW_REV
argument_list|(
literal|1
argument_list|,
literal|17
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FULL_LOGIN
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ISP_NO_FASTPOST_FC
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FAST_POST
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_FULL_DUPLEX
condition|)
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_FULL_DUPLEX
expr_stmt|;
comment|/* 	 * We don't set ICBOPT_PORTNAME because we want our 	 * Node Name&& Port Names to be distinct. 	 */
name|icbp
operator|->
name|icb_fwoptions
operator|=
name|fcp
operator|->
name|isp_fwoptions
expr_stmt|;
name|icbp
operator|->
name|icb_maxfrmlen
operator|=
name|fcp
operator|->
name|isp_maxfrmlen
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_maxfrmlen
operator|<
name|ICB_MIN_FRMLEN
operator|||
name|icbp
operator|->
name|icb_maxfrmlen
operator|>
name|ICB_MAX_FRMLEN
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad frame length (%d) from NVRAM- using %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_maxfrmlen
argument_list|,
name|ICB_DFLT_FRMLEN
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_maxfrmlen
operator|=
name|ICB_DFLT_FRMLEN
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_maxalloc
operator|=
name|fcp
operator|->
name|isp_maxalloc
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_maxalloc
operator|<
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad maximum allocation (%d)- using 16\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_maxalloc
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_maxalloc
operator|=
literal|16
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_execthrottle
operator|=
name|fcp
operator|->
name|isp_execthrottle
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_execthrottle
operator|<
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad execution throttle of %d- using 16\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_execthrottle
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_execthrottle
operator|=
name|ICB_DFLT_THROTTLE
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_retry_delay
operator|=
name|fcp
operator|->
name|isp_retry_delay
expr_stmt|;
name|icbp
operator|->
name|icb_retry_count
operator|=
name|fcp
operator|->
name|isp_retry_count
expr_stmt|;
name|icbp
operator|->
name|icb_hardaddr
operator|=
name|loopid
expr_stmt|;
name|icbp
operator|->
name|icb_logintime
operator|=
literal|30
expr_stmt|;
comment|/* 30 second login timeout */
if|if
condition|(
name|fcp
operator|->
name|isp_nodewwn
condition|)
block|{
name|u_int64_t
name|pn
decl_stmt|;
name|MAKE_NODE_NAME_FROM_WWN
argument_list|(
name|icbp
operator|->
name|icb_nodename
argument_list|,
name|fcp
operator|->
name|isp_nodewwn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_portwwn
condition|)
block|{
name|pn
operator|=
name|fcp
operator|->
name|isp_portwwn
expr_stmt|;
block|}
else|else
block|{
name|pn
operator|=
name|fcp
operator|->
name|isp_nodewwn
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|isp
operator|->
name|isp_unit
operator|+
literal|1
argument_list|)
operator|)
operator|<<
literal|56
operator|)
expr_stmt|;
block|}
comment|/* 		 * If the top nibble is 2, we can construct a port name 		 * from the node name by setting a nonzero instance in 		 * bits 56..59. Otherwise, we need to make it identical 		 * to Node name... 		 */
if|if
condition|(
operator|(
name|fcp
operator|->
name|isp_nodewwn
operator|>>
literal|60
operator|)
operator|==
literal|2
condition|)
block|{
name|MAKE_NODE_NAME_FROM_WWN
argument_list|(
name|icbp
operator|->
name|icb_portname
argument_list|,
name|pn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MAKE_NODE_NAME_FROM_WWN
argument_list|(
name|icbp
operator|->
name|icb_portname
argument_list|,
name|fcp
operator|->
name|isp_nodewwn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fcp
operator|->
name|isp_fwoptions
operator|&=
operator|~
operator|(
name|ICBOPT_USE_PORTNAME
operator||
name|ICBOPT_FULL_LOGIN
operator|)
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_rqstqlen
operator|=
name|RQUEST_QUEUE_LEN
expr_stmt|;
name|icbp
operator|->
name|icb_rsltqlen
operator|=
name|RESULT_QUEUE_LEN
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_LSW
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_MSW
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_LSW
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_MSW
argument_list|(
name|isp
operator|->
name|isp_result_dma
argument_list|)
expr_stmt|;
name|ISP_SWIZZLE_ICB
argument_list|(
name|isp
argument_list|,
name|icbp
argument_list|)
expr_stmt|;
comment|/* 	 * Do this *before* initializing the firmware. 	 */
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_NIL
expr_stmt|;
name|MemoryBarrier
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_FIRMWARE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: INIT FIRMWARE failed (code 0x%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x8000
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return;
block|}
break|break;
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_residx
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Whatever happens, we're now committed to being here. 	 */
name|isp
operator|->
name|isp_state
operator|=
name|ISP_INITSTATE
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|isp_modify_lun
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to enable target mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Fibre Channel Support- get the port database for the id.  *  * Locks are held before coming here. Return 0 if success,  * else failure.  */
end_comment

begin_function
specifier|static
name|void
name|isp_mark_getpdb_all
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_FC_TARG
condition|;
name|i
operator|++
control|)
block|{
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|isp_getpdb
parameter_list|(
name|isp
parameter_list|,
name|id
parameter_list|,
name|pdbp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|id
decl_stmt|;
name|isp_pdb_t
modifier|*
name|pdbp
decl_stmt|;
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_PORT_DB
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|id
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
comment|/* 	 * Unneeded. For the 2100, except for initializing f/w, registers 	 * 4/5 have to not be written to. 	 *	mbs.param[4] = 0; 	 *	mbs.param[5] = 0; 	 * 	 */
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
name|MemoryBarrier
argument_list|()
expr_stmt|;
name|ISP_UNSWIZZLE_AND_COPY_PDBP
argument_list|(
name|isp
argument_list|,
name|pdbp
argument_list|,
name|fcp
operator|->
name|isp_scratch
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_HOST_INTERFACE_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: DMA error getting port database\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|MBOX_COMMAND_PARAM_ERROR
case|:
comment|/* Not Logged In */
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Param Error on Get Port Database for id %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
name|PRINTF
argument_list|(
literal|"%s: error 0x%x getting port database for ID %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int64_t
name|isp_get_portname
parameter_list|(
name|isp
parameter_list|,
name|loopid
parameter_list|,
name|nodename
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|loopid
decl_stmt|;
name|int
name|nodename
decl_stmt|;
block|{
name|u_int64_t
name|wwn
init|=
literal|0
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_PORT_NAME
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|loopid
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|nodename
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator||=
literal|1
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|wwn
operator|=
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|>>
literal|8
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|>>
literal|8
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|>>
literal|8
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|wwn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure we have good FC link and know our Loop ID.  */
end_comment

begin_function
specifier|static
name|int
name|isp_fclink_test
parameter_list|(
name|isp
parameter_list|,
name|waitdelay
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|waitdelay
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|toponames
index|[]
init|=
block|{
literal|"Private Loop"
block|,
literal|"FL Port"
block|,
literal|"N-Port to N-Port"
block|,
literal|"F Port"
block|}
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|count
decl_stmt|,
name|topo
init|=
operator|-
literal|1
decl_stmt|;
name|u_int8_t
name|lwfs
decl_stmt|;
name|fcparam
modifier|*
name|fcp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_FABRIC
argument_list|)
name|isp_pdb_t
name|pdb
decl_stmt|;
endif|#
directive|endif
name|fcp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
comment|/* 	 * Wait up to N microseconds for F/W to go to a ready state. 	 */
name|lwfs
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|waitdelay
condition|;
name|count
operator|+=
literal|100
control|)
block|{
name|isp_fw_state
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwfs
operator|!=
name|fcp
operator|->
name|isp_fwstate
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Firmware State %s -> %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|isp2100_fw_statename
argument_list|(
operator|(
name|int
operator|)
name|lwfs
argument_list|)
argument_list|,
name|isp2100_fw_statename
argument_list|(
operator|(
name|int
operator|)
name|fcp
operator|->
name|isp_fwstate
argument_list|)
argument_list|)
expr_stmt|;
name|lwfs
operator|=
name|fcp
operator|->
name|isp_fwstate
expr_stmt|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|==
name|FW_READY
condition|)
block|{
break|break;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* wait 100 microseconds */
block|}
comment|/* 	 * If we haven't gone to 'ready' state, return. 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get our Loop ID (if possible). We really need to have it. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_LOOP_ID
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: GET LOOP ID failed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fcp
operator|->
name|isp_loopid
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|==
name|ISP_HA_FC_2100
condition|)
block|{
if|if
condition|(
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|>=
name|ISP_FW_REV
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|topo
operator|=
operator|(
name|int
operator|)
name|mbs
operator|.
name|param
index|[
literal|6
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|==
name|ISP_HA_FC_2100
condition|)
block|{
if|if
condition|(
name|ISP_FW_REVX
argument_list|(
name|isp
operator|->
name|isp_fwrev
argument_list|)
operator|>=
name|ISP_FW_REV
argument_list|(
literal|1
argument_list|,
literal|17
argument_list|,
literal|26
argument_list|)
condition|)
block|{
name|topo
operator|=
operator|(
name|int
operator|)
name|mbs
operator|.
name|param
index|[
literal|6
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|topo
operator|<
literal|0
operator|||
name|topo
operator|>
literal|3
condition|)
name|tname
operator|=
literal|"unknown"
expr_stmt|;
else|else
name|tname
operator|=
name|toponames
index|[
name|topo
index|]
expr_stmt|;
comment|/* 	 * If we're not on a fabric, the low 8 bits will be our AL_PA. 	 * If we're on a fabric, the low 8 bits will still be our AL_PA. 	 */
name|fcp
operator|->
name|isp_alpa
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_FABRIC
argument_list|)
name|fcp
operator|->
name|isp_onfabric
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|FL_PORT_ID
argument_list|,
operator|&
name|pdb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fcp
operator|->
name|isp_portid
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|fcp
operator|->
name|isp_onfabric
operator|=
literal|1
expr_stmt|;
name|CFGPRINTF
argument_list|(
literal|"%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State "
literal|"0x%x topology %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_loopid
argument_list|,
name|fcp
operator|->
name|isp_alpa
argument_list|,
name|fcp
operator|->
name|isp_portid
argument_list|,
name|fcp
operator|->
name|isp_loopstate
argument_list|,
name|tname
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure we're logged out of all fabric devices. 		 */
for|for
control|(
name|count
operator|=
name|FC_SNS_ID
operator|+
literal|1
init|;
name|count
operator|<
name|MAX_FC_TARG
condition|;
name|count
operator|++
control|)
block|{
name|struct
name|lportdb
modifier|*
name|lp
init|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|count
index|]
decl_stmt|;
if|if
condition|(
name|lp
operator|->
name|valid
operator|==
literal|0
operator|||
name|lp
operator|->
name|fabdev
operator|==
literal|0
condition|)
continue|continue;
name|PRINTF
argument_list|(
literal|"%s: logging out target %d at Loop ID %d "
literal|"(port id 0x%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|count
argument_list|,
name|lp
operator|->
name|loopid
argument_list|,
name|lp
operator|->
name|portid
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_FABRIC_LOGOUT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|lp
operator|->
name|loopid
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|CFGPRINTF
argument_list|(
literal|"%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_loopid
argument_list|,
name|fcp
operator|->
name|isp_alpa
argument_list|,
name|fcp
operator|->
name|isp_loopstate
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|loop_seen_once
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two local port db entities and return 1 if they're the same, else 0.  */
end_comment

begin_function
specifier|static
name|int
name|isp_same_lportdb
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|lportdb
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
comment|/* 	 * We decide two lports are the same if they have non-zero and 	 * identical port WWNs and identical loop IDs. 	 */
if|if
condition|(
name|a
operator|->
name|port_wwn
operator|==
literal|0
operator|||
name|a
operator|->
name|port_wwn
operator|!=
name|b
operator|->
name|port_wwn
operator|||
name|a
operator|->
name|loopid
operator|!=
name|b
operator|->
name|loopid
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * Synchronize our soft copy of the port database with what the f/w thinks  * (with a view toward possibly for a specific target....)  */
end_comment

begin_function
specifier|static
name|int
name|isp_pdb_sync
parameter_list|(
name|isp
parameter_list|,
name|target
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|struct
name|lportdb
modifier|*
name|lp
decl_stmt|,
modifier|*
name|tport
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp_pdb_t
name|pdb
decl_stmt|;
name|int
name|loopid
decl_stmt|,
name|lim
decl_stmt|;
ifdef|#
directive|ifdef
name|ISP2100_FABRIC
comment|/* 	 * XXX: If we do this *after* building up our local port database, 	 * XXX: the commands simply don't work. 	 */
comment|/* 	 * (Re)discover all fabric devices 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_onfabric
condition|)
operator|(
name|void
operator|)
name|isp_scan_fabric
argument_list|(
name|isp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Run through the local loop ports and get port database info 	 * for each loop ID. 	 * 	 * There's a somewhat unexplained situation where the f/w passes back 	 * the wrong database entity- if that happens, just restart (up to 	 * FL_PORT_ID times). 	 */
name|tport
operator|=
name|fcp
operator|->
name|tport
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tport
argument_list|,
sizeof|sizeof
argument_list|(
name|tport
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lim
operator|=
name|loopid
operator|=
literal|0
init|;
name|loopid
operator|<
name|FL_PORT_ID
condition|;
name|loopid
operator|++
control|)
block|{
comment|/* 		 * make sure the temp port database is clean... 		 */
name|lp
operator|=
operator|&
name|tport
index|[
name|loopid
index|]
expr_stmt|;
name|lp
operator|->
name|node_wwn
operator|=
name|isp_get_portname
argument_list|(
name|isp
argument_list|,
name|loopid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|node_wwn
operator|==
literal|0
condition|)
continue|continue;
name|lp
operator|->
name|port_wwn
operator|=
name|isp_get_portname
argument_list|(
name|isp
argument_list|,
name|loopid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|port_wwn
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|node_wwn
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Get an entry.... 		 */
if|if
condition|(
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|loopid
argument_list|,
operator|&
name|pdb
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * If the returned database element doesn't match what we 		 * asked for, restart the process entirely (up to a point...). 		 */
if|if
condition|(
name|pdb
operator|.
name|pdb_loopid
operator|!=
name|loopid
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: wankage (%d != %d)\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|pdb
operator|.
name|pdb_loopid
operator|,
name|loopid
operator|)
argument_list|)
expr_stmt|;
name|loopid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lim
operator|++
operator|<
name|FL_PORT_ID
condition|)
block|{
continue|continue;
block|}
name|PRINTF
argument_list|(
literal|"%s: giving up on synchronizing the port "
literal|"database\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Save the pertinent info locally. 		 */
name|lp
operator|->
name|node_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lp
operator|->
name|port_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lp
operator|->
name|roles
operator|=
operator|(
name|pdb
operator|.
name|pdb_prli_svc3
operator|&
name|SVC3_ROLE_MASK
operator|)
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
name|lp
operator|->
name|portid
operator|=
name|BITS2WORD
argument_list|(
name|pdb
operator|.
name|pdb_portid_bits
argument_list|)
expr_stmt|;
name|lp
operator|->
name|loopid
operator|=
name|pdb
operator|.
name|pdb_loopid
expr_stmt|;
comment|/* 		 * Do a quick check to see whether this matches the saved port 		 * database for the same loopid. We do this here to save 		 * searching later (if possible). Note that this fails over 		 * time as things shuffle on the loop- we get the current 		 * loop state (where loop id as an index matches loop id in 		 * use) and then compare it to our saved database which 		 * never shifts. 		 */
if|if
condition|(
name|isp_same_lportdb
argument_list|(
name|lp
argument_list|,
operator|&
name|fcp
operator|->
name|portdb
index|[
name|target
index|]
argument_list|)
condition|)
block|{
name|lp
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If we get this far, we've settled our differences with the f/w 	 * and we can say that the loop state is ready. 	 */
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_READY
expr_stmt|;
comment|/* 	 * Mark all of the permanent local loop database entries as invalid. 	 */
for|for
control|(
name|loopid
operator|=
literal|0
init|;
name|loopid
operator|<
name|FL_PORT_ID
condition|;
name|loopid
operator|++
control|)
block|{
name|fcp
operator|->
name|portdb
index|[
name|loopid
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Now merge our local copy of the port database into our saved copy. 	 * Notify the outer layers of new devices arriving. 	 */
for|for
control|(
name|loopid
operator|=
literal|0
init|;
name|loopid
operator|<
name|FL_PORT_ID
condition|;
name|loopid
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * If we don't have a non-zero Port WWN, we're not here. 		 */
if|if
condition|(
name|tport
index|[
name|loopid
index|]
operator|.
name|port_wwn
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * If we've already marked our tmp copy as valid, 		 * this means that we've decided that it's the 		 * same as our saved data base. This didn't include 		 * the 'valid' marking so we have set that here. 		 */
if|if
condition|(
name|tport
index|[
name|loopid
index|]
operator|.
name|valid
condition|)
block|{
name|fcp
operator|->
name|portdb
index|[
name|loopid
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * For the purposes of deciding whether this is the 		 * 'same' device or not, we only search for an identical 		 * Port WWN. Node WWNs may or may not be the same as 		 * the Port WWN, and there may be multiple different 		 * Port WWNs with the same Node WWN. It would be chaos 		 * to have multiple identical Port WWNs, so we don't 		 * allow that. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FL_PORT_ID
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|port_wwn
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|port_wwn
operator|!=
name|tport
index|[
name|loopid
index|]
operator|.
name|port_wwn
condition|)
continue|continue;
comment|/* 			 * We found this WWN elsewhere- it's changed 			 * loopids then. We don't change it's actual 			 * position in our cached port database- we 			 * just change the actual loop ID we'd use. 			 */
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
operator|!=
name|loopid
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Target ID %d Loop 0x%x (Port 0x%x) "
literal|"=> Loop 0x%x (Port 0x%x) \n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|,
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
argument_list|,
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|portid
argument_list|,
name|loopid
argument_list|,
name|tport
index|[
name|loopid
index|]
operator|.
name|portid
argument_list|)
expr_stmt|;
block|}
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|portid
operator|=
name|tport
index|[
name|loopid
index|]
operator|.
name|portid
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
operator|=
name|loopid
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* 			 * XXX: Should we also propagate roles in case they 			 * XXX: changed? 			 */
comment|/* 			 * Now make sure this Port WWN doesn't exist elsewhere 			 * in the port database. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|FL_PORT_ID
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|port_wwn
operator|!=
name|fcp
operator|->
name|portdb
index|[
name|j
index|]
operator|.
name|port_wwn
condition|)
block|{
continue|continue;
block|}
name|PRINTF
argument_list|(
literal|"%s: Target ID %d Duplicates Target ID "
literal|"%d- killing off both\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 				 * Invalidate the 'old' *and* 'new' ones. 				 * This is really harsh and not quite right, 				 * but if this happens, we really don't know 				 * who is what at this point. 				 */
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|j
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * If we didn't traverse the entire port database, 		 * then we found (and remapped) an existing entry. 		 * No need to notify anyone- go for the next one. 		 */
if|if
condition|(
name|i
operator|<
name|FL_PORT_ID
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * We've not found this Port WWN anywhere. It's a new entry. 		 * See if we can leave it where it is (with target == loopid). 		 */
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|loopid
index|]
operator|.
name|port_wwn
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|lim
operator|=
literal|0
init|;
name|lim
operator|<
name|FL_PORT_ID
condition|;
name|lim
operator|++
control|)
block|{
if|if
condition|(
name|fcp
operator|->
name|portdb
index|[
name|lim
index|]
operator|.
name|port_wwn
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* "Cannot Happen" */
if|if
condition|(
name|lim
operator|==
name|FL_PORT_ID
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: remap overflow?\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|lim
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|loopid
expr_stmt|;
block|}
comment|/* 		 * NB:	The actual loopid we use here is loopid- we may 		 *	in fact be at a completely different index (target). 		 */
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|loopid
operator|=
name|loopid
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|port_wwn
operator|=
name|tport
index|[
name|loopid
index|]
operator|.
name|port_wwn
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|node_wwn
operator|=
name|tport
index|[
name|loopid
index|]
operator|.
name|node_wwn
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|roles
operator|=
name|tport
index|[
name|loopid
index|]
operator|.
name|roles
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|portid
operator|=
name|tport
index|[
name|loopid
index|]
operator|.
name|portid
expr_stmt|;
name|fcp
operator|->
name|portdb
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Tell the outside world we've arrived. 		 */
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PDB_CHANGED
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now find all previously used targets that are now invalid and 	 * notify the outer layers that they're gone. 	 */
for|for
control|(
name|lp
operator|=
name|fcp
operator|->
name|portdb
init|;
name|lp
operator|<
operator|&
name|fcp
operator|->
name|portdb
index|[
name|FL_PORT_ID
index|]
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|valid
operator|||
name|lp
operator|->
name|port_wwn
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Tell the outside world we've gone away; 		 */
name|loopid
operator|=
name|lp
operator|-
name|fcp
operator|->
name|portdb
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PDB_CHANGED
argument_list|,
operator|&
name|loopid
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISP2100_FABRIC
comment|/* 	 * Now log in any fabric devices 	 */
for|for
control|(
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|FC_SNS_ID
operator|+
literal|1
index|]
init|;
name|lp
operator|<
operator|&
name|fcp
operator|->
name|portdb
index|[
name|MAX_FC_TARG
index|]
condition|;
name|lp
operator|++
control|)
block|{
name|mbreg_t
name|mbs
decl_stmt|;
comment|/* 		 * Nothing here? 		 */
if|if
condition|(
name|lp
operator|->
name|port_wwn
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Don't try to log into yourself. 		 */
if|if
condition|(
name|lp
operator|->
name|portid
operator|==
name|fcp
operator|->
name|isp_portid
condition|)
continue|continue;
comment|/* 		 * Force a logout. 		 */
name|lp
operator|->
name|loopid
operator|=
name|loopid
operator|=
name|lp
operator|-
name|fcp
operator|->
name|portdb
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_FABRIC_LOGOUT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|lp
operator|->
name|loopid
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
comment|/* 		 * And log in.... 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_FABRIC_LOGIN
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|lp
operator|->
name|loopid
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|lp
operator|->
name|portid
operator|>>
literal|16
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|lp
operator|->
name|portid
operator|&
literal|0xffff
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|lp
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|fabdev
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isp_getpdb
argument_list|(
name|isp
argument_list|,
name|loopid
argument_list|,
operator|&
name|pdb
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Be kind... 				 */
name|lp
operator|->
name|roles
operator|=
operator|(
name|SVC3_TGT_ROLE
operator|>>
name|SVC3_ROLE_SHIFT
operator|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Faked PortID 0x%x into LoopID %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|lp
operator|->
name|portid
argument_list|,
name|lp
operator|->
name|loopid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdb
operator|.
name|pdb_loopid
operator|!=
name|lp
operator|->
name|loopid
condition|)
block|{
name|lp
operator|->
name|roles
operator|=
operator|(
name|SVC3_TGT_ROLE
operator|>>
name|SVC3_ROLE_SHIFT
operator|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Wanked PortID 0x%x to LoopID %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|lp
operator|->
name|portid
argument_list|,
name|lp
operator|->
name|loopid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|->
name|roles
operator|=
operator|(
name|pdb
operator|.
name|pdb_prli_svc3
operator|&
name|SVC3_ROLE_MASK
operator|)
operator|>>
name|SVC3_ROLE_SHIFT
expr_stmt|;
name|lp
operator|->
name|portid
operator|=
name|BITS2WORD
argument_list|(
name|pdb
operator|.
name|pdb_portid_bits
argument_list|)
expr_stmt|;
name|lp
operator|->
name|loopid
operator|=
name|pdb
operator|.
name|pdb_loopid
expr_stmt|;
name|lp
operator|->
name|node_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_nodename
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
name|lp
operator|->
name|port_wwn
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|pdb
operator|.
name|pdb_portname
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_PDB_CHANGED
argument_list|,
operator|&
name|loopid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISP2100_FABRIC
end_ifdef

begin_function
specifier|static
name|int
name|isp_scan_fabric
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|u_int32_t
name|portid
decl_stmt|,
name|first_nz_portid
decl_stmt|;
name|sns_screq_t
modifier|*
name|reqp
decl_stmt|;
name|sns_scrsp_t
modifier|*
name|resp
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|hicap
decl_stmt|;
name|reqp
operator|=
operator|(
name|sns_screq_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
expr_stmt|;
name|resp
operator|=
operator|(
name|sns_scrsp_t
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
operator|)
index|[
literal|0x100
index|]
operator|)
expr_stmt|;
name|first_nz_portid
operator|=
name|portid
operator|=
name|fcp
operator|->
name|isp_portid
expr_stmt|;
for|for
control|(
name|hicap
operator|=
literal|0
init|;
name|hicap
operator|<
literal|1024
condition|;
name|hicap
operator|++
control|)
block|{
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
name|SNS_GAN_REQ_SIZE
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|snscb_rblen
operator|=
name|SNS_GAN_RESP_SIZE
operator|>>
literal|1
expr_stmt|;
name|reqp
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
name|DMA_LSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|snscb_addr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
name|DMA_MSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|+
literal|0x100
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|snscb_sblen
operator|=
literal|6
expr_stmt|;
name|reqp
operator|->
name|snscb_data
index|[
literal|0
index|]
operator|=
name|SNS_GAN
expr_stmt|;
name|reqp
operator|->
name|snscb_data
index|[
literal|4
index|]
operator|=
name|portid
operator|&
literal|0xffff
expr_stmt|;
name|reqp
operator|->
name|snscb_data
index|[
literal|5
index|]
operator|=
operator|(
name|portid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ISP_SWIZZLE_SNS_REQ
argument_list|(
name|isp
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SEND_SNS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|SNS_GAN_REQ_SIZE
operator|>>
literal|1
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DMA_MSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|DMA_LSW
argument_list|(
name|fcp
operator|->
name|isp_scdma
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|MemoryBarrier
argument_list|()
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ISP_UNSWIZZLE_SNS_RSP
argument_list|(
name|isp
argument_list|,
name|resp
argument_list|,
name|SNS_GAN_RESP_SIZE
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|portid
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|0
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|resp
operator|->
name|snscb_port_id
index|[
literal|2
index|]
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_FABRIC_DEV
argument_list|,
name|resp
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|first_nz_portid
operator|==
literal|0
operator|&&
name|portid
condition|)
block|{
name|first_nz_portid
operator|=
name|portid
expr_stmt|;
block|}
if|if
condition|(
name|first_nz_portid
operator|==
name|portid
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * We either have a broken name server or a huge fabric if we get here. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Start a command. Locking is assumed done in the caller.  */
end_comment

begin_function
name|int32_t
name|ispscsicmd
parameter_list|(
name|xs
parameter_list|)
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
union|union
block|{
name|ispreq_t
modifier|*
name|_reqp
decl_stmt|;
name|ispreqt2_t
modifier|*
name|_t2reqp
decl_stmt|;
block|}
name|_u
union|;
define|#
directive|define
name|reqp
value|_u._reqp
define|#
directive|define
name|t2reqp
value|_u._t2reqp
define|#
directive|define
name|UZSIZE
value|max(sizeof (ispreq_t), sizeof (ispreqt2_t))
name|int
name|target
decl_stmt|,
name|i
decl_stmt|;
name|XS_INITERR
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|isp
operator|=
name|XS_ISP
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: adapter not ready\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * We *could* do the different sequence type that has close 	 * to the whole Queue Entry for the command... 	 */
if|if
condition|(
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
operator|>
operator|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|?
literal|16
else|:
literal|12
operator|)
operator|||
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: unsupported cdb length (%d, CDB[0]=0x%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CDBP
argument_list|(
name|xs
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * Check to see whether we have good firmware state still or 	 * need to refresh our port database for this target. 	 */
name|target
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|struct
name|lportdb
modifier|*
name|lp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_FABRIC
argument_list|)
if|if
condition|(
name|target
operator|>=
name|FL_PORT_ID
condition|)
block|{
comment|/* 			 * If we're not on a Fabric, we can't have a target 			 * above FL_PORT_ID-1. If we're on a fabric, we 			 * can't have a target less than FC_SNS_ID+1. 			 */
if|if
condition|(
name|fcp
operator|->
name|isp_onfabric
operator|==
literal|0
operator|||
name|target
operator|<=
name|FC_SNS_ID
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * Check for f/w being in ready state. If the f/w 		 * isn't in ready state, then we don't know our 		 * loop ID and the f/w hasn't completed logging 		 * into all targets on the loop. If this is the 		 * case, then bounce the command. We pretend this is 		 * a SELECTION TIMEOUT error if we've never gone to 		 * FW_READY state at all- in this case we may not 		 * be hooked to a loop at all and we shouldn't hang 		 * the machine for this. Otherwise, defer this command 		 * until later. 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|!=
name|FW_READY
condition|)
block|{
if|if
condition|(
name|isp_fclink_test
argument_list|(
name|isp
argument_list|,
name|FC_FW_READY_DELAY
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|loop_seen_once
condition|)
block|{
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
block|}
comment|/* 		 * If our loop state is such that we haven't yet received 		 * a "Port Database Changed" notification (after a LIP or 		 * a Loop Reset or firmware initialization), then defer 		 * sending commands for a little while. 		 */
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|<
name|LOOP_PDB_RCVD
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_RQLATER
operator|)
return|;
block|}
comment|/* 		 * If our loop state is now such that we've just now 		 * received a Port Database Change notification, then 		 * we have to go off and (re)synchronize our  		 */
if|if
condition|(
name|fcp
operator|->
name|isp_loopstate
operator|==
name|LOOP_PDB_RCVD
condition|)
block|{
if|if
condition|(
name|isp_pdb_sync
argument_list|(
name|isp
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
block|}
comment|/* 		 * Now check whether we should even think about pursuing this. 		 */
name|lp
operator|=
operator|&
name|fcp
operator|->
name|portdb
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|valid
operator|==
literal|0
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lp
operator|->
name|roles
operator|&
operator|(
name|SVC3_TGT_ROLE
operator|>>
name|SVC3_ROLE_SHIFT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: target %d is not a target\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|target
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 		 * Now turn target into what the actual loop ID is. 		 */
name|target
operator|=
name|lp
operator|->
name|loopid
expr_stmt|;
block|}
comment|/* 	 * Next check to see if any HBA or Device 	 * parameters need to be updated. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_update
operator|!=
literal|0
condition|)
block|{
name|isp_update
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
name|optr
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|isp
operator|->
name|isp_reqidx
expr_stmt|;
name|reqp
operator|=
operator|(
name|ispreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptr
operator|==
name|optr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: Request Queue Overflow\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
comment|/* 	 * Now see if we need to synchronize the ISP with respect to anything. 	 * We do dual duty here (cough) for synchronizing for busses other 	 * than which we got here to send a command to. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_sendmarker
condition|)
block|{
name|u_int8_t
name|niptr
decl_stmt|,
name|n
init|=
operator|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|?
literal|2
else|:
literal|1
operator|)
decl_stmt|;
comment|/* 		 * Check ports to send markers for... 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_sendmarker
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reqp
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_MARKER
expr_stmt|;
name|reqp
operator|->
name|req_modifier
operator|=
name|SYNC_ALL
expr_stmt|;
name|reqp
operator|->
name|req_target
operator|=
name|i
operator|<<
literal|7
expr_stmt|;
comment|/* insert bus number */
name|ISP_SWIZZLE_REQUEST
argument_list|(
name|isp
argument_list|,
name|reqp
argument_list|)
expr_stmt|;
comment|/* 			 * Unconditionally update the input pointer anyway. 			 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
name|niptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|niptr
operator|==
name|optr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: Request Queue Overflow+\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
name|reqp
operator|=
operator|(
name|ispreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|niptr
expr_stmt|;
block|}
block|}
name|MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
name|UZSIZE
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_T2RQS
expr_stmt|;
block|}
else|else
block|{
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_REQUEST
expr_stmt|;
block|}
name|reqp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
comment|/* 		 * See comment in isp_intr 		 */
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Fibre Channel always requires some kind of tag, but 		 * the firmware seems to be happy if we don't use a tag. 		 */
if|if
condition|(
name|XS_CANTAG
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|t2reqp
operator|->
name|req_flags
operator|=
name|XS_KINDOF_TAG
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
if|if
condition|(
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|target
index|]
operator|.
name|cur_dflags
operator|&
name|DPARM_TQING
operator|)
operator|&&
name|XS_CANTAG
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_flags
operator|=
name|XS_KINDOF_TAG
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
name|reqp
operator|->
name|req_target
operator|=
name|target
operator||
operator|(
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|<<
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_lun_trn
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_cdblen
operator|=
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ISP2100_SCCLUN
name|t2reqp
operator|->
name|req_scclun
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
else|#
directive|else
name|t2reqp
operator|->
name|req_lun_trn
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|MEMCPY
argument_list|(
name|reqp
operator|->
name|req_cdb
argument_list|,
name|XS_CDBP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_time
operator|=
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|req_time
operator|==
literal|0
operator|&&
name|XS_TIME
argument_list|(
name|xs
argument_list|)
condition|)
name|reqp
operator|->
name|req_time
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Always give a bit more leeway to commands after a bus reset. 	 * XXX: DOES NOT DISTINGUISH WHICH PORT MAY HAVE BEEN SYNCED 	 */
if|if
condition|(
name|isp
operator|->
name|isp_sendmarker
operator|&&
name|reqp
operator|->
name|req_time
operator|<
literal|5
condition|)
block|{
name|reqp
operator|->
name|req_time
operator|=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|isp_save_xs
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
operator|&
name|reqp
operator|->
name|req_handle
argument_list|)
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: out of xflist pointers\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
comment|/* 	 * Set up DMA and/or do any bus swizzling of the request entry 	 * so that the Qlogic F/W understands what is being asked of it.  	*/
name|i
operator|=
name|ISP_DMASETUP
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|reqp
argument_list|,
operator|&
name|iptr
argument_list|,
name|optr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|CMD_QUEUED
condition|)
block|{
name|isp_destroy_handle
argument_list|(
name|isp
argument_list|,
name|reqp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
comment|/* 		 * dmasetup sets actual error in packet, and 		 * return what we were given to return. 		 */
return|return
operator|(
name|i
operator|)
return|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s(%d.%d.%d): START cmd 0x%x datalen %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|,
name|target
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|,
name|reqp
operator|->
name|req_cdb
index|[
literal|0
index|]
operator|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|MemoryBarrier
argument_list|()
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
name|isp
operator|->
name|isp_nactive
operator|++
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_sendmarker
condition|)
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|CMD_QUEUED
operator|)
return|;
undef|#
directive|undef
name|reqp
undef|#
directive|undef
name|t2reqp
block|}
end_function

begin_comment
comment|/*  * isp control  * Locks (ints blocked) assumed held.  */
end_comment

begin_function
name|int
name|isp_control
parameter_list|(
name|isp
parameter_list|,
name|ctl
parameter_list|,
name|arg
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispctl_t
name|ctl
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|tgt
decl_stmt|;
name|u_int32_t
name|handle
decl_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
default|default:
name|PRINTF
argument_list|(
literal|"%s: isp_control unknown control op %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPCTL_RESET_BUS
case|:
comment|/* 		 * Issue a bus reset. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_BUS_RESET
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_bus_reset_delay
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|<
literal|2
condition|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|bus
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|bus
expr_stmt|;
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|10
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|bus
operator|=
literal|0
expr_stmt|;
block|}
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
operator|<<
name|bus
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"isp_control SCSI bus reset failed"
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: driver initiated bus reset of bus %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_RESET_DEV
case|:
name|tgt
operator|=
operator|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|bus
operator|=
operator|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABORT_TARGET
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
operator|(
name|bus
operator|<<
literal|15
operator|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
comment|/* 'delay', in seconds */
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_control MBOX_RESET_DEV failure (code "
literal|"%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: Target %d on Bus %d Reset Succeeded\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
operator|<<
name|bus
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_ABORT_CMD
case|:
name|xs
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|arg
expr_stmt|;
name|handle
operator|=
name|isp_find_handle
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_control- cannot find command to abort "
literal|"in active list\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus
operator|=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABORT
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ISP2100_SCCLUN
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
else|#
directive|else
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|bus
operator|<<
literal|15
operator|)
operator||
operator|(
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|handle
operator|>>
literal|16
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|handle
operator|&
literal|0xffff
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_control MBOX_ABORT failure (code %x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: command for target %d lun %d was aborted\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_UPDATE_PARAMS
case|:
name|isp_update
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_FCLINK_TEST
case|:
return|return
operator|(
name|isp_fclink_test
argument_list|(
name|isp
argument_list|,
name|FC_FW_READY_DELAY
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt Service Routine(s).  *  * External (OS) framework has done the appropriate locking,  * and the locking will be held throughout this function.  */
end_comment

begin_function
name|int
name|isp_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|complist
index|[
name|RESULT_QUEUE_LEN
index|]
decl_stmt|,
modifier|*
name|xs
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|arg
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
name|u_int16_t
name|isr
decl_stmt|,
name|isrb
decl_stmt|,
name|sema
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nlooked
init|=
literal|0
decl_stmt|,
name|ndone
init|=
literal|0
decl_stmt|;
comment|/* 	 * Well, if we've disabled interrupts, we may get a case where 	 * isr isn't set, but sema is. In any case, debounce isr reads. 	 */
do|do
block|{
name|isr
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
expr_stmt|;
name|isrb
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|isr
operator|!=
name|isrb
condition|)
do|;
name|sema
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|0x1
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s: isp_intr isr %x sem %x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|isr
operator|,
name|sema
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|INT_PENDING
argument_list|(
name|isp
argument_list|,
name|isr
argument_list|)
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s: isp_intr isr=%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|isr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: interrupt (isr=%x,sema=%x) when not ready\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|isr
operator|,
name|sema
operator|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX5
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sema
condition|)
block|{
name|u_int16_t
name|mbox
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mbox
operator|&
literal|0x4000
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Command Mbox 0x%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|mbox
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|fhandle
init|=
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
operator|(
name|int
operator|)
name|mbox
argument_list|)
decl_stmt|;
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Async Mbox 0x%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|mbox
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhandle
operator|>
literal|0
condition|)
block|{
name|isp_fastpost_complete
argument_list|(
name|isp
argument_list|,
name|fhandle
argument_list|)
expr_stmt|;
block|}
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt. 	 */
name|optr
operator|=
name|isp
operator|->
name|isp_residx
expr_stmt|;
name|iptr
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX5
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|optr
operator|==
name|iptr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"why intr? isr %x iptr %x optr %x\n"
operator|,
name|isr
operator|,
name|optr
operator|,
name|iptr
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|optr
operator|!=
name|iptr
condition|)
block|{
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|u_int8_t
name|oop
decl_stmt|;
name|int
name|buddaboom
init|=
literal|0
decl_stmt|;
name|sp
operator|=
operator|(
name|ispstatusreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_result
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|oop
operator|=
name|optr
expr_stmt|;
name|optr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|optr
argument_list|,
name|RESULT_QUEUE_LEN
argument_list|)
expr_stmt|;
name|nlooked
operator|++
expr_stmt|;
name|MemoryBarrier
argument_list|()
expr_stmt|;
comment|/* 		 * Do any appropriate unswizzling of what the Qlogic f/w has 		 * written into memory so it makes sense to us. 		 */
name|ISP_UNSWIZZLE_RESPONSE
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|!=
name|RQSTYPE_RESPONSE
condition|)
block|{
if|if
condition|(
name|isp_handle_other_response
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|,
operator|&
name|optr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * It really has to be a bounced request just copied 			 * from the request queue to the response queue. If 			 * not, something bad has happened. 			 */
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|!=
name|RQSTYPE_REQUEST
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: not RESPONSE in RESPONSE Queue "
literal|"(type 0x%x) @ idx %d (next %d)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|,
name|oop
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|buddaboom
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
literal|0xf
condition|)
block|{
define|#
directive|define
name|_RQS_OFLAGS
define|\
value|~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_CONTINUATION
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: continuation segment\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_FULL
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: internal queues full\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * We'll synthesize a QUEUE FULL message below. 				 */
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_BADHEADER
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad header\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_BADPACKET
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad request packet\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|_RQS_OFLAGS
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: unknown flags in response (0x%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
undef|#
directive|undef
name|_RQS_OFLAGS
block|}
if|if
condition|(
name|sp
operator|->
name|req_handle
operator|>
name|isp
operator|->
name|isp_maxcmds
operator|||
name|sp
operator|->
name|req_handle
operator|<
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad request handle %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|xs
operator|=
name|isp_find_xs
argument_list|(
name|isp
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: NULL xs in xflist (handle 0x%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|isp_destroy_handle
argument_list|(
name|isp
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_BUS_RESET
condition|)
block|{
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|buddaboom
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_scsi_status
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
block|{
name|MEMCPY
argument_list|(
name|XS_SNSP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_sense_data
argument_list|,
name|XS_SNSLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SNS_IS_VALID
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * A new synchronous rate was negotiated for this 			 * target. Mark state such that we'll go look up 			 * that which has changed later. 			 */
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_NEGOTIATION
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|+=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_refresh
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_update
operator||=
operator|(
literal|1
operator|<<
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
condition|)
block|{
name|XS_SNS_IS_VALID
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|XS_SNSP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_sense_data
argument_list|,
name|XS_SNSLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|req_state_flags
operator||=
name|RQSF_GOT_SENSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
operator|&&
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_BUSY
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_TGTBSY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|==
name|RQSTYPE_RESPONSE
condition|)
block|{
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_completion_status
operator|!=
name|RQCS_COMPLETE
condition|)
block|{
name|isp_parse_status
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|,
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|==
name|RQSTYPE_REQUEST
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_FULL
condition|)
block|{
comment|/* 				 * Force Queue Full status. 				 */
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|=
name|SCSI_QFULL
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|PRINTF
argument_list|(
literal|"%s: unhandled respose queue type 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|req_scsi_status
operator|&
name|RQCS_RU
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s: cnt %d rsd %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
operator|,
name|sp
operator|->
name|req_resid
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * XXX: If we have a check condition, but no Sense Data, 		 * XXX: mark it as an error (ARQ failed). We need to 		 * XXX: to do a more distinct job because there may 		 * XXX: cases where ARQ is disabled. 		 */
if|if
condition|(
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
operator|&&
operator|!
operator|(
name|XS_IS_SNS_VALID
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: ARQ failure for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ARQFAIL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_dblev
operator|>=
literal|5
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
operator|&&
operator|!
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s(%d.%d): FIN dl%d resid%d STS %x"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_RESID
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_STS
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
block|{
name|PRINTF
argument_list|(
literal|" Skey: %x"
argument_list|,
name|XS_SNSKEY
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XS_IS_SNS_VALID
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|" BUT NOT SET"
argument_list|)
expr_stmt|;
block|}
block|}
name|PRINTF
argument_list|(
literal|" XS_ERR=0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|XS_ERR
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_nactive
operator|>
literal|0
condition|)
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
name|complist
index|[
name|ndone
operator|++
index|]
operator|=
name|xs
expr_stmt|;
comment|/* defer completion call until later */
block|}
comment|/* 	 * If we looked at any commands, then it's valid to find out 	 * what the outpointer is. It also is a trigger to update the 	 * ISP's notion of what we've seen so far. 	 */
if|if
condition|(
name|nlooked
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
block|}
name|isp
operator|->
name|isp_residx
operator|=
name|optr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndone
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
name|complist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xs
condition|)
block|{
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support routines.  */
end_comment

begin_function
specifier|static
name|int
name|isp_parse_async
parameter_list|(
name|isp
parameter_list|,
name|mbox
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|mbox
decl_stmt|;
block|{
name|u_int32_t
name|fast_post_handle
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mbox
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
comment|/* sometimes these show up */
break|break;
case|case
name|ASYNC_BUS_RESET
case|:
block|{
name|int
name|bus
decl_stmt|;
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|bus
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus
operator|=
literal|0
expr_stmt|;
block|}
name|isp
operator|->
name|isp_sendmarker
operator|=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_BUS_RESET
argument_list|,
operator|&
name|bus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|ASYNC_SYSTEM_ERROR
case|:
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Internal FW Error @ RISC Addr 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
name|isp_restart
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* no point continuing after this */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|ASYNC_RQS_XFER_ERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Request Queue Transfer Error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_RSP_XFER_ERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Response Queue Transfer Error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_QWAKEUP
case|:
comment|/* don't need to be chatty */
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_TIMEOUT_RESET
case|:
name|PRINTF
argument_list|(
literal|"%s: timeout initiated SCSI bus reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_DEVICE_RESET
case|:
comment|/* 		 * XXX: WHICH BUS? 		 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: device reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_EXTMSG_UNDERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: extended message underrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_SCAM_INT
case|:
name|PRINTF
argument_list|(
literal|"%s: SCAM interrupt\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_HUNG_SCSI
case|:
name|PRINTF
argument_list|(
literal|"%s: stalled SCSI Bus after DATA Overrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
comment|/* XXX: Need to issue SCSI reset at this point */
break|break;
case|case
name|ASYNC_KILLED_BUS
case|:
name|PRINTF
argument_list|(
literal|"%s: SCSI Bus reset after DATA Overrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_BUS_TRANSIT
case|:
comment|/* 		 * XXX: WHICH BUS? 		 */
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbox
operator|&
literal|0x1c00
condition|)
block|{
case|case
name|SXP_PINS_LVD_MODE
case|:
name|PRINTF
argument_list|(
literal|"%s: Transition to LVD mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_lvdmode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SXP_PINS_HVD_MODE
case|:
name|PRINTF
argument_list|(
literal|"%s: Transition to Differential mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_lvdmode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SXP_PINS_SE_MODE
case|:
name|PRINTF
argument_list|(
literal|"%s: Transition to Single Ended mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_ultramode
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_lvdmode
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: Transition to unknown mode 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * XXX: Set up to renegotiate again! 		 */
comment|/* Can only be for a 1080... */
name|isp
operator|->
name|isp_sendmarker
operator|=
operator|(
literal|1
operator|<<
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX6
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CMD_CMPLT
case|:
name|fast_post_handle
operator|=
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: fast post completion of %u\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|fast_post_handle
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CTIO_DONE
case|:
comment|/* Should only occur when Fast Posting Set for 2100s */
name|PRINTF
argument_list|(
literal|"%s: CTIO done\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LIP_OCCURRED
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_lipseq
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_LIP_RCVD
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: LIP occurred\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_UP
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_LIP_RCVD
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_LOOP_UP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_DOWN
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_NIL
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_LOOP_DOWN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_RESET
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_NIL
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Loop RESET\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|isp_notify_ack
argument_list|(
name|isp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ASYNC_PDB_CHANGED
case|:
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: Port Database Changed\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
name|isp_mark_getpdb_all
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 		 * Not correct, but it will force us to rescan the loop. 		 */
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_CHANGE_NOTIFY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: unknown async code 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|fast_post_handle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_handle_other_response
parameter_list|(
name|isp
parameter_list|,
name|sp
parameter_list|,
name|optrp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|u_int8_t
modifier|*
name|optrp
decl_stmt|;
block|{
switch|switch
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
condition|)
block|{
case|case
name|RQSTYPE_ATIO
case|:
case|case
name|RQSTYPE_CTIO0
case|:
case|case
name|RQSTYPE_ENABLE_LUN
case|:
case|case
name|RQSTYPE_MODIFY_LUN
case|:
case|case
name|RQSTYPE_NOTIFY
case|:
case|case
name|RQSTYPE_NOTIFY_ACK
case|:
case|case
name|RQSTYPE_CTIO1
case|:
case|case
name|RQSTYPE_ATIO2
case|:
case|case
name|RQSTYPE_CTIO2
case|:
case|case
name|RQSTYPE_CTIO3
case|:
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
return|return
operator|(
name|isp_target_notify
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|,
name|optrp
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|RQSTYPE_REQUEST
case|:
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_parse_status
parameter_list|(
name|isp
parameter_list|,
name|sp
parameter_list|,
name|xs
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
switch|switch
condition|(
name|sp
operator|->
name|req_completion_status
condition|)
block|{
case|case
name|RQCS_COMPLETE
case|:
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_INCOMPLETE
case|:
if|if
condition|(
operator|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_TARGET
operator|)
operator|==
literal|0
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Selection Timeout for target %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: command incomplete for target %d lun %d, state "
literal|"0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_state_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DMA_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: DMA error for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_TRANSPORT_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: transport error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp_prtstst
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_RESET_OCCURRED
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: bus reset destroyed command for target %d "
literal|"lun %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: Get port number for bus 		 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|3
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_ABORTED
case|:
name|PRINTF
argument_list|(
literal|"%s: command aborted for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: Get port number for bus 		 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|3
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ABORTED
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_TIMEOUT
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: command timed out for target %d lun %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_CMDTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_DATA_OVERRUN
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
break|break;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_DATAOVR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_COMMAND_OVERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: command overrun for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_STATUS_OVERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: status overrun for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_BAD_MESSAGE
case|:
name|PRINTF
argument_list|(
literal|"%s: message not COMMAND COMPLETE after status on "
literal|"target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_NO_MESSAGE_OUT
case|:
name|PRINTF
argument_list|(
literal|"%s: No MESSAGE OUT phase after selection on "
literal|"target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_EXT_ID_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: EXTENDED IDENTIFY failed on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_IDE_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected INITIATOR DETECTED "
literal|"ERROR message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ABORT_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected ABORT message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_REJECT_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected MESSAGE REJECT message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_NOP_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected NOP message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PARITY_ERROR_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected MESSAGE PARITY ERROR "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DEVICE_RESET_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected BUS DEVICE RESET "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ID_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected IDENTIFY "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_UNEXP_BUS_FREE
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d had an unexpected bus free\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DATA_UNDERRUN
case|:
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
comment|/* an UNDERRUN is not a botch ??? */
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_XACT_ERR1
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction with disconnect "
literal|"not set for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_XACT_ERR2
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction to target "
literal|"routine %d on target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_XACT_ERR3
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction for target %d lun "
literal|"%d when queueing disabled\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_BAD_ENTRY
case|:
name|PRINTF
argument_list|(
literal|"%s: invalid IOCB entry type detected\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_QUEUE_FULL
case|:
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: internal queues full for target %d lun %d "
literal|"status 0x%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If QFULL or some other status byte is set, then this 		 * isn't an error, per se. 		 */
if|if
condition|(
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|RQCS_PHASE_SKIPPED
case|:
name|PRINTF
argument_list|(
literal|"%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o "
literal|"STATUS phase) for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ARQS_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: Auto Request Sense failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ARQFAIL
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_WIDE_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: Wide Negotiation failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|+=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_flags
operator|&=
operator|~
name|DPARM_WIDE
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_update
operator|=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_SYNCXFER_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: SDTR Message failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|+=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_flags
operator|&=
operator|~
name|DPARM_SYNC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_update
operator|=
name|XS_CHANNEL
argument_list|(
name|xs
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RQCS_LVD_BUSERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Bad LVD Bus condition while talking to target %d "
literal|"lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PORT_UNAVAILABLE
case|:
comment|/* 		 * No such port on the loop. Moral equivalent of SELTIMEO 		 */
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Port Unavailable for target %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_PORT_LOGGED_OUT
case|:
comment|/* 		 * It was there (maybe)- treat as a selection timeout. 		 */
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: port logout for target %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_PORT_CHANGED
case|:
name|PRINTF
argument_list|(
literal|"%s: port changed for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PORT_BUSY
case|:
name|PRINTF
argument_list|(
literal|"%s: port busy for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_TGTBSY
argument_list|)
expr_stmt|;
return|return;
default|default:
name|PRINTF
argument_list|(
literal|"%s: comp status %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_completion_status
argument_list|)
expr_stmt|;
break|break;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_fastpost_complete
parameter_list|(
name|isp
parameter_list|,
name|fph
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|u_int32_t
name|fph
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
if|if
condition|(
name|fph
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|xs
operator|=
name|isp_find_xs
argument_list|(
name|isp
argument_list|,
name|fph
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: command for fast posting handle 0x%x not found\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fph
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp_destroy_handle
argument_list|(
name|isp
argument_list|,
name|fph
argument_list|)
expr_stmt|;
comment|/* 	 * Since we don't have a result queue entry item, 	 * we must believe that SCSI status is zero and 	 * that all data transferred. 	 */
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|fph
argument_list|)
expr_stmt|;
block|}
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_nactive
condition|)
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|HINIB
parameter_list|(
name|x
parameter_list|)
value|((x)>> 0x4)
end_define

begin_define
define|#
directive|define
name|LONIB
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xf)
end_define

begin_define
define|#
directive|define
name|MAKNIB
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<< 4) | (b))
end_define

begin_decl_stmt
specifier|static
name|u_int8_t
name|mbpcnt
index|[]
init|=
block|{
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x00: MBOX_NO_OP */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x01: MBOX_LOAD_RAM */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x02: MBOX_EXEC_FIRMWARE */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x03: MBOX_DUMP_RAM */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x04: MBOX_WRITE_RAM_WORD */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x05: MBOX_READ_RAM_WORD */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x06: MBOX_MAILBOX_REG_TEST */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x07: MBOX_VERIFY_CHECKSUM	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x08: MBOX_ABOUT_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x09: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0d: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x0e: MBOX_CHECK_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0f: */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x10: MBOX_INIT_REQ_QUEUE */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x11: MBOX_INIT_RES_QUEUE */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x12: MBOX_EXECUTE_IOCB */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x13: MBOX_WAKE_UP	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x14: MBOX_STOP_FIRMWARE */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x15: MBOX_ABORT */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x16: MBOX_ABORT_DEVICE */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x17: MBOX_ABORT_TARGET */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x18: MBOX_BUS_RESET */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x19: MBOX_STOP_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1a: MBOX_START_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1c: MBOX_ABORT_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x1e: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x21: MBOX_GET_SELECT_TIMEOUT */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x22: MBOX_GET_RETRY_COUNT	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x23: MBOX_GET_TAG_AGE_LIMIT */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x24: MBOX_GET_CLOCK_RATE */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x25: MBOX_GET_ACT_NEG_STATE */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x27: MBOX_GET_PCI_PARAMS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x28: MBOX_GET_TARGET_PARAMS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2f: */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x30: MBOX_SET_INIT_SCSI_ID */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x31: MBOX_SET_SELECT_TIMEOUT */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x32: MBOX_SET_RETRY_COUNT	*/
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x33: MBOX_SET_TAG_AGE_LIMIT */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x34: MBOX_SET_CLOCK_RATE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x35: MBOX_SET_ACT_NEG_STATE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x38: MBOX_SET_TARGET_PARAMS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3f: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x42: MBOX_EXEC_BIOS_IOCB */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x43: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x44: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x45: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x46: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x47: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x48: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x49: */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4f: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x50: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x51: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x52: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x53: */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x55: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x56: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x57: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x58: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x59: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5f: */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x60: MBOX_INIT_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x61: */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x62: MBOX_INIT_LIP */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x64: MBOX_GET_PORT_DB */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x65: MBOX_CLEAR_ACA */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x66: MBOX_TARGET_RESET */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x67: MBOX_CLEAR_TASK_SET */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x68: MBOX_ABORT_TASK_SET */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x69: MBOX_GET_FW_STATE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|8
argument_list|)
block|,
comment|/* 0x6a: MBOX_GET_PORT_NAME */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x6b: MBOX_GET_LINK_STATUS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x6c: MBOX_INIT_LIP_RESET */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x6d: */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x6e: MBOX_SEND_SNS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x6f: MBOX_FABRIC_LOGIN */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x70: MBOX_SEND_CHANGE_REQUEST */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x71: MBOX_FABRIC_LOGOUT */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
comment|/* 0x72: MBOX_INIT_LIP_LOGIN */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMBCOM
value|(sizeof (mbpcnt) / sizeof (mbpcnt[0]))
end_define

begin_function
specifier|static
name|void
name|isp_mboxcmd
parameter_list|(
name|isp
parameter_list|,
name|mbp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|mbreg_t
modifier|*
name|mbp
decl_stmt|;
block|{
name|int
name|outparam
decl_stmt|,
name|inparam
decl_stmt|;
name|int
name|loops
decl_stmt|,
name|dld
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|opcode
decl_stmt|;
if|if
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|==
name|ISP2100_SET_PCI_PARAM
condition|)
block|{
name|opcode
operator|=
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_PCI_PARAMETERS
expr_stmt|;
name|inparam
operator|=
literal|4
expr_stmt|;
name|outparam
operator|=
literal|4
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
elseif|else
if|if
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|>
name|NMBCOM
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad command %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcode
operator|=
name|mbp
operator|->
name|param
index|[
literal|0
index|]
expr_stmt|;
name|inparam
operator|=
name|HINIB
argument_list|(
name|mbpcnt
index|[
name|mbp
operator|->
name|param
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|outparam
operator|=
name|LONIB
argument_list|(
name|mbpcnt
index|[
name|mbp
operator|->
name|param
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|inparam
operator|==
literal|0
operator|&&
name|outparam
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: no parameters for %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check for variants 	 */
ifdef|#
directive|ifdef
name|ISP2100_SCCLUN
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_ABORT
case|:
name|inparam
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|MBOX_ABORT_DEVICE
case|:
case|case
name|MBOX_START_QUEUE
case|:
case|case
name|MBOX_STOP_QUEUE
case|:
case|case
name|MBOX_SINGLE_STEP_QUEUE
case|:
case|case
name|MBOX_ABORT_QUEUE
case|:
case|case
name|MBOX_GET_DEV_QUEUE_STATUS
case|:
name|inparam
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|MBOX_BUS_RESET
case|:
name|inparam
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
name|command_known
label|:
comment|/* 	 * Set semaphore on mailbox registers to win any races to acquire them. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Qlogic Errata for the ISP2100 says that there is a necessary 	 * debounce between between writing the semaphore register 	 * and reading a mailbox register. I believe we're okay here. 	 */
comment|/* 	 * Make sure we can send some words. 	 * Check to see if there's an async mbox event pending. 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_HOST_INT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|1
condition|)
block|{
name|int
name|fph
decl_stmt|;
name|u_int16_t
name|mbox
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
decl_stmt|;
comment|/* 			 * We have a pending MBOX async event. 			 */
if|if
condition|(
name|mbox
operator|&
literal|0x8000
condition|)
block|{
name|fph
operator|=
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
operator|(
name|int
operator|)
name|mbox
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s: line %d, fph %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|__LINE__
operator|,
name|fph
operator|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fph
operator|<
literal|0
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|fph
operator|>
literal|0
condition|)
block|{
name|isp_fastpost_complete
argument_list|(
name|isp
argument_list|,
name|fph
argument_list|)
expr_stmt|;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
comment|/* 			 * We have a pending MBOX completion? Might be 			 * from a previous command. We can't (sometimes) 			 * just clear HOST INTERRUPT, so we'll just silently 			 * eat this here. 			 */
if|if
condition|(
name|mbox
operator|&
literal|0x4000
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s: line %d, mbox 0x%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|__LINE__
operator|,
name|mbox
operator|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dld
operator|++
operator|>
literal|10
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd could not get command "
literal|"started\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
block|}
comment|/* 	 * Write input parameters. 	 * 	 * Special case some of the setups for the dual port SCSI cards. 	 * XXX Eventually will be fixed by converting register write/read 	 * XXX counts to bitmasks. 	 */
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MBOX_GET_RETRY_COUNT
case|:
case|case
name|MBOX_SET_RETRY_COUNT
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX7
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX6
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MBOX_SET_ASYNC_DATA_SETUP_TIME
case|:
case|case
name|MBOX_SET_ACT_NEG_STATE
case|:
case|case
name|MBOX_SET_TAG_AGE_LIMIT
case|:
case|case
name|MBOX_SET_SELECT_TIMEOUT
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX2
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|inparam
condition|)
block|{
case|case
literal|8
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX7
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|7
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX6
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|6
case|:
comment|/* 		 * The Qlogic 2100 cannot have registers 4 and 5 written to 		 * after initialization or BAD THINGS HAPPEN (tm). 		 */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
operator|||
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_INIT_FIRMWARE
condition|)
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|5
case|:
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
operator|||
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|==
name|MBOX_INIT_FIRMWARE
condition|)
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|4
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX3
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|3
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX2
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|2
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX1
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|1
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX0
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Clear RISC int condition. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Clear semaphore on mailbox registers so that the Qlogic 	 * may update outgoing registers. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set Host Interrupt condition so that RISC will pick up mailbox regs. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_SET_HOST_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until HOST INT has gone away (meaning that the Qlogic 	 * has picked up the mailbox command. Wait a long time. 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
operator|*
literal|5
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_CMD_CLEAR_RISC_INT
operator|)
operator|!=
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #2\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * While the Semaphore registers isn't set, wait for the Qlogic 	 * to process the mailbox command. Again- wait a long time. 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
operator|*
literal|5
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Wierd- I've seen the case where the semaphore register 		 * isn't getting set- sort of a violation of the protocol.. 		 */
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|&
literal|0x4000
condition|)
break|break;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #3\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Make sure that the MBOX_BUSY has gone away 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|u_int16_t
name|mbox
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mbox
operator|==
name|MBOX_BUSY
condition|)
block|{
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #4\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We have a pending MBOX async event. 		 */
if|if
condition|(
name|mbox
operator|&
literal|0x8000
condition|)
block|{
name|int
name|fph
init|=
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
operator|(
name|int
operator|)
name|mbox
argument_list|)
decl_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fph
operator|<
literal|0
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|fph
operator|>
literal|0
condition|)
block|{
name|isp_fastpost_complete
argument_list|(
name|isp
argument_list|,
name|fph
argument_list|)
expr_stmt|;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* 	 * Pick up output parameters. Special case some of the readbacks 	 * for the dual port SCSI cards. 	 */
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MBOX_GET_RETRY_COUNT
case|:
case|case
name|MBOX_SET_RETRY_COUNT
case|:
name|mbp
operator|->
name|param
index|[
literal|7
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX7
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|6
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX6
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_GET_TAG_AGE_LIMIT
case|:
case|case
name|MBOX_SET_TAG_AGE_LIMIT
case|:
case|case
name|MBOX_GET_ACT_NEG_STATE
case|:
case|case
name|MBOX_SET_ACT_NEG_STATE
case|:
case|case
name|MBOX_SET_ASYNC_DATA_SETUP_TIME
case|:
case|case
name|MBOX_GET_ASYNC_DATA_SETUP_TIME
case|:
case|case
name|MBOX_GET_RESET_DELAY_PARAMS
case|:
case|case
name|MBOX_SET_RESET_DELAY_PARAMS
case|:
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|outparam
condition|)
block|{
case|case
literal|8
case|:
name|mbp
operator|->
name|param
index|[
literal|7
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX7
argument_list|)
expr_stmt|;
case|case
literal|7
case|:
name|mbp
operator|->
name|param
index|[
literal|6
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX6
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|mbp
operator|->
name|param
index|[
literal|5
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX5
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|mbp
operator|->
name|param
index|[
literal|4
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|mbp
operator|->
name|param
index|[
literal|3
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX3
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|mbp
operator|->
name|param
index|[
literal|1
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear RISC int. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Release semaphore on mailbox registers 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Just to be chatty here... 	 */
switch|switch
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
break|break;
case|case
name|MBOX_INVALID_COMMAND
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: mbox cmd %x failed with INVALID_COMMAND\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_HOST_INTERFACE_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_TEST_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with TEST_FAILED\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_ERROR
case|:
if|if
condition|(
name|opcode
operator|!=
name|MBOX_ABOUT_FIRMWARE
condition|)
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with COMMAND_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_PARAM_ERROR
case|:
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MBOX_GET_PORT_DB
case|:
case|case
name|MBOX_GET_PORT_NAME
case|:
case|case
name|MBOX_GET_DEV_QUEUE_PARAMS
case|:
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with "
literal|"COMMAND_PARAM_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Be silent about these... 	 */
case|case
name|ASYNC_PDB_CHANGED
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
break|break;
case|case
name|ASYNC_LIP_OCCURRED
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_lipseq
operator|=
name|mbp
operator|->
name|param
index|[
literal|1
index|]
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ASYNC_LOOP_UP
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_LIP_RCVD
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_DOWN
case|:
case|case
name|ASYNC_LOOP_RESET
case|:
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
operator|(
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
operator|)
operator|->
name|isp_loopstate
operator|=
name|LOOP_NIL
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
break|break;
default|default:
comment|/* 		 * The expected return of EXEC_FIRMWARE is zero. 		 */
if|if
condition|(
operator|(
name|opcode
operator|==
name|MBOX_EXEC_FIRMWARE
operator|&&
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|opcode
operator|!=
name|MBOX_EXEC_FIRMWARE
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with error %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
name|isp_lostcmd
parameter_list|(
name|isp
parameter_list|,
name|xs
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FIRMWARE_STATUS
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"couldn't GET FIRMWARE STATUS"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: %d commands on completion queue\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XS_NULL
argument_list|(
name|xs
argument_list|)
condition|)
return|return;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_DEV_QUEUE_STATUS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
comment|/* XXX: WHICH BUS? */
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"couldn't GET DEVICE QUEUE STATUS"
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: lost command for target %d lun %d, %d active of %d, "
literal|"Queue State: %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"lost command"
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Need to try and do something to recover. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|isp_dumpregs
parameter_list|(
name|isp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|PRINTF
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
name|PRINTF
argument_list|(
literal|"    biu_conf1=%x"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PRINTF
argument_list|(
literal|"    biu_csr=%x"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|" biu_icr=%x biu_isr=%x biu_sema=%x "
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"risc_hccr=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_CONF
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_STATUS
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_FIFO_STS
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_CONF
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_STATUS
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_FIFO_STS
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_INTERRUPT
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_GROSS_ERR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
block|}
name|PRINTF
argument_list|(
literal|"    mbox regs: %x %x %x %x %x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX3
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_DUMPREGS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_fw_state
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|int
name|once
init|=
literal|0
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|again
label|:
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FW_STATE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: isp_fw_state 0x%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|ASYNC_PDB_CHANGED
case|:
if|if
condition|(
name|once
operator|++
operator|<
literal|10
condition|)
block|{
goto|goto
name|again
goto|;
block|}
name|fcp
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_PDB_RCVD
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|ASYNC_LIP_OCCURRED
case|:
name|fcp
operator|->
name|isp_lipseq
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ASYNC_LOOP_UP
case|:
name|fcp
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_LIP_RCVD
expr_stmt|;
if|if
condition|(
name|once
operator|++
operator|<
literal|10
condition|)
block|{
goto|goto
name|again
goto|;
block|}
break|break;
case|case
name|ASYNC_LOOP_RESET
case|:
case|case
name|ASYNC_LOOP_DOWN
case|:
name|fcp
operator|->
name|isp_fwstate
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
name|fcp
operator|->
name|isp_loopstate
operator|=
name|LOOP_NIL
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
if|if
condition|(
name|once
operator|++
operator|<
literal|10
condition|)
block|{
goto|goto
name|again
goto|;
block|}
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: GET FIRMWARE STATE failed (0x%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|fcp
operator|->
name|isp_fwstate
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_update
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|bus
decl_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|isp
operator|->
name|isp_update
operator|!=
literal|0
condition|;
name|bus
operator|++
control|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_update
operator|&
operator|(
literal|1
operator|<<
name|bus
operator|)
condition|)
block|{
name|isp_update_bus
argument_list|(
name|isp
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_update
operator|^=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_update_bus
parameter_list|(
name|isp
parameter_list|,
name|bus
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|bus
decl_stmt|;
block|{
name|int
name|tgt
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdparam
modifier|*
name|sdp
decl_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
return|return;
block|}
name|sdp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
name|sdp
operator|+=
name|bus
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|u_int16_t
name|flags
decl_stmt|,
name|period
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|get
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|==
literal|0
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: skipping target %d bus %d update\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|tgt
operator|,
name|bus
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If the goal is to update the status of the device, 		 * take what's in dev_flags and try and set the device 		 * toward that. Otherwise, if we're just refreshing the 		 * current device state, get the current parameters. 		 */
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
expr_stmt|;
comment|/* 			 * Insist that PARITY must be enabled if SYNC 			 * is enabled. 			 */
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|&
name|DPARM_SYNC
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator||=
name|DPARM_PARITY
expr_stmt|;
block|}
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
operator|=
literal|0
expr_stmt|;
comment|/* 			 * A command completion later that has 			 * RQSTF_NEGOTIATION set will cause 			 * the dev_refresh/announce cycle. 			 * 			 * Note: It is really important to update our current 			 * flags with at least the state of TAG capabilities- 			 * otherwise we might try and send a tagged command 			 * when we have it all turned off. So change it here 			 * to say that current already matches goal. 			 */
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|&=
operator|~
name|DPARM_TQING
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator||=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
operator|&
name|DPARM_TQING
operator|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
operator|=
literal|1
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: bus %d set tgt %d flags 0x%x off 0x%x"
literal|" period 0x%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|bus
operator|,
name|tgt
operator|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
operator|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|get
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_TARGET_PARAMS
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_refresh
operator|=
literal|0
expr_stmt|;
name|get
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|bus
operator|<<
literal|15
operator|)
operator||
operator|(
name|tgt
operator|<<
literal|8
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to %cet SCSI parameters for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
operator|(
name|get
operator|)
condition|?
literal|'g'
else|:
literal|'s'
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|get
operator|==
literal|0
condition|)
block|{
name|isp
operator|->
name|isp_sendmarker
operator||=
operator|(
literal|1
operator|<<
name|bus
operator|)
expr_stmt|;
continue|continue;
block|}
name|flags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
name|flags
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
operator|=
name|period
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|=
name|offset
expr_stmt|;
name|get
operator|=
operator|(
name|bus
operator|<<
literal|16
operator|)
operator||
name|tgt
expr_stmt|;
operator|(
name|void
operator|)
name|isp_async
argument_list|(
name|isp
argument_list|,
name|ISPASYNC_NEW_TGT_PARAMS
argument_list|,
operator|&
name|get
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_setdfltparm
parameter_list|(
name|isp
parameter_list|,
name|channel
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|channel
decl_stmt|;
block|{
name|int
name|tgt
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdparam
modifier|*
name|sdp
decl_stmt|,
modifier|*
name|sdp_chan0
decl_stmt|,
modifier|*
name|sdp_chan1
decl_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|fcp
operator|+=
name|channel
expr_stmt|;
if|if
condition|(
name|fcp
operator|->
name|isp_gotdparms
condition|)
block|{
return|return;
block|}
name|fcp
operator|->
name|isp_gotdparms
operator|=
literal|1
expr_stmt|;
name|fcp
operator|->
name|isp_maxfrmlen
operator|=
name|ICB_DFLT_FRMLEN
expr_stmt|;
name|fcp
operator|->
name|isp_maxalloc
operator|=
name|ICB_DFLT_ALLOC
expr_stmt|;
name|fcp
operator|->
name|isp_execthrottle
operator|=
name|ICB_DFLT_THROTTLE
expr_stmt|;
name|fcp
operator|->
name|isp_retry_delay
operator|=
name|ICB_DFLT_RDELAY
expr_stmt|;
name|fcp
operator|->
name|isp_retry_count
operator|=
name|ICB_DFLT_RCOUNT
expr_stmt|;
comment|/* Platform specific.... */
name|fcp
operator|->
name|isp_loopid
operator|=
name|DEFAULT_LOOPID
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_nodewwn
operator|=
name|DEFAULT_WWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_portwwn
operator|=
name|DEFAULT_WWN
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 		 * Now try and read NVRAM 		 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NONVRAM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isp_read_nvram
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: using default WWN 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|fcp
operator|->
name|isp_portwwn
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|fcp
operator|->
name|isp_portwwn
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
name|sdp_chan0
operator|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
expr_stmt|;
name|sdp_chan1
operator|=
name|sdp_chan0
operator|+
literal|1
expr_stmt|;
name|sdp
operator|=
name|sdp_chan0
operator|+
name|channel
expr_stmt|;
comment|/* 	 * Been there, done that, got the T-shirt... 	 */
if|if
condition|(
name|sdp
operator|->
name|isp_gotdparms
condition|)
block|{
return|return;
block|}
name|sdp
operator|->
name|isp_gotdparms
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If we've not been told to avoid reading NVRAM, try and read it. 	 * If we're successful reading it, we can return since NVRAM will 	 * tell us the right thing to do. Otherwise, establish some reasonable 	 * defaults. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NONVRAM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isp_read_nvram
argument_list|(
name|isp
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
comment|/* 	 * Now try and see whether we have specific values for them. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_ACT_NEG_STATE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"could not GET ACT NEG STATE\n"
operator|)
argument_list|)
expr_stmt|;
name|sdp_chan0
operator|->
name|isp_req_ack_active_neg
operator|=
literal|1
expr_stmt|;
name|sdp_chan0
operator|->
name|isp_data_line_active_neg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdp_chan1
operator|->
name|isp_req_ack_active_neg
operator|=
literal|1
expr_stmt|;
name|sdp_chan1
operator|->
name|isp_data_line_active_neg
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|sdp_chan0
operator|->
name|isp_req_ack_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x1
expr_stmt|;
name|sdp_chan0
operator|->
name|isp_data_line_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdp_chan1
operator|->
name|isp_req_ack_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x1
expr_stmt|;
name|sdp_chan1
operator|->
name|isp_data_line_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x1
expr_stmt|;
block|}
block|}
comment|/* 	 * The trick here is to establish a default for the default (honk!) 	 * state (dev_flags). Then try and get the current status from 	 * the card to fill in the current state. We don't, in fact, set 	 * the default to the SAFE default state- that's not the goal state. 	 */
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
operator|=
name|DPARM_DEFAULT
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1040
operator|||
operator|(
name|isp
operator|->
name|isp_clock
operator|&&
name|isp
operator|->
name|isp_clock
operator|<
literal|60
operator|)
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|ISP_10M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|ISP_10M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|ISP_40M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|ISP_40M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|ISP_20M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|ISP_20M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* 		 * Don't get current target parameters if we've been 		 * told not to use NVRAM- it's really the same thing. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NONVRAM
condition|)
block|{
continue|continue;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
continue|continue;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
comment|/* 		 * The maximum period we can really see 		 * here is 100 (decimal), or 400 ns. 		 * For some unknown reason we sometimes 		 * get back wildass numbers from the 		 * boot device's parameters (alpha only). 		 */
if|if
condition|(
operator|(
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|<=
literal|0x64
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
block|}
comment|/* 		 * It is not safe to run Ultra Mode with a clock< 60. 		 */
if|if
condition|(
operator|(
operator|(
name|isp
operator|->
name|isp_clock
operator|&&
name|isp
operator|->
name|isp_clock
operator|<
literal|60
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1020A
operator|)
operator|)
operator|&&
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|<=
operator|(
name|ISP_20M_SYNCPARMS
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|=
name|ISP_10M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|=
name|ISP_10M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
comment|/* 	 * Establish default some more default parameters. 	 */
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_initiator_id
operator|=
literal|7
expr_stmt|;
comment|/* XXXX This is probably based upon clock XXXX */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|>=
name|ISP_HA_SCSI_1040
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|6
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_selection_timeout
operator|=
literal|250
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|MAXISPREQUEST
expr_stmt|;
name|sdp
operator|->
name|isp_tag_aging
operator|=
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
literal|3
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
literal|2
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
operator|=
literal|16
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Re-initialize the ISP and complete all orphaned commands  * with a 'botched' notice. The reset/init routines should  * not disturb an already active list of commands.  *  * Locks held prior to coming here.  */
end_comment

begin_function
name|void
name|isp_restart
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|u_int32_t
name|handle
decl_stmt|;
if|#
directive|if
literal|0
block|isp->isp_gotdparms = 0;
endif|#
directive|endif
name|isp_reset
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|==
name|ISP_RESETSTATE
condition|)
block|{
name|isp_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|==
name|ISP_INITSTATE
condition|)
block|{
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RUNSTATE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_restart cannot restart ISP\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
name|isp
operator|->
name|isp_nactive
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|handle
operator|=
literal|1
init|;
name|handle
operator|<=
operator|(
name|int
operator|)
name|isp
operator|->
name|isp_maxcmds
condition|;
name|handle
operator|++
control|)
block|{
name|xs
operator|=
name|isp_find_xs
argument_list|(
name|isp
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|isp_destroy_handle
argument_list|(
name|isp
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * NVRAM Routines  */
end_comment

begin_function
specifier|static
name|int
name|isp_read_nvram
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|tru
init|=
literal|"true"
decl_stmt|;
specifier|static
name|char
modifier|*
name|not
init|=
literal|"false"
decl_stmt|;
name|int
name|i
decl_stmt|,
name|amt
decl_stmt|;
name|u_int8_t
name|csum
decl_stmt|,
name|minversion
decl_stmt|;
union|union
block|{
name|u_int8_t
name|_x
index|[
name|ISP2100_NVRAM_SIZE
index|]
decl_stmt|;
name|u_int16_t
name|_s
index|[
name|ISP2100_NVRAM_SIZE
operator|>>
literal|1
index|]
expr_stmt|;
block|}
name|_n
union|;
define|#
directive|define
name|nvram_data
value|_n._x
define|#
directive|define
name|nvram_words
value|_n._s
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|amt
operator|=
name|ISP2100_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|amt
operator|=
name|ISP1080_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|amt
operator|=
name|ISP_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Just read the first two words first to see if we have a valid 	 * NVRAM to continue reading the rest with. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|isp_rdnvram_word
argument_list|(
name|isp
argument_list|,
name|i
argument_list|,
operator|&
name|nvram_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvram_data
index|[
literal|0
index|]
operator|!=
literal|'I'
operator|||
name|nvram_data
index|[
literal|1
index|]
operator|!=
literal|'S'
operator|||
name|nvram_data
index|[
literal|2
index|]
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|!=
name|ISP_BT_SBUS
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: invalid NVRAM header (%x,%x,%x,%x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|nvram_data
index|[
literal|0
index|]
argument_list|,
name|nvram_data
index|[
literal|1
index|]
argument_list|,
name|nvram_data
index|[
literal|2
index|]
argument_list|,
name|nvram_data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|amt
operator|>>
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|isp_rdnvram_word
argument_list|(
name|isp
argument_list|,
name|i
argument_list|,
operator|&
name|nvram_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|amt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|nvram_data
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|csum
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: invalid NVRAM checksum\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ISP_NVRAM_VERSION
argument_list|(
name|nvram_data
argument_list|)
operator|<
name|minversion
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: version %d NVRAM not understood\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ISP_NVRAM_VERSION
argument_list|(
name|nvram_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|int
name|bus
decl_stmt|;
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
operator|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
condition|?
literal|1
else|:
literal|2
operator|)
condition|;
name|bus
operator|++
operator|,
name|sdp
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
name|ISP1080_NVRAM_FIFO_THRESHOLD
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_initiator_id
operator|=
name|ISP1080_NVRAM_INITIATOR_ID
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
name|ISP1080_NVRAM_BUS_RESET_DELAY
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
name|ISP1080_NVRAM_BUS_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
name|ISP1080_NVRAM_BUS_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_async_data_setup
operator|=
name|ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
name|ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
name|ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
name|ISP1080_NVRAM_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
name|ISP1080_NVRAM_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_selection_timeout
operator|=
name|ISP1080_NVRAM_SELECTION_TIMEOUT
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|ISP1080_NVRAM_MAX_QUEUE_DEPTH
argument_list|(
name|nvram_data
argument_list|,
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|>=
literal|3
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: ISP1080 bus %d NVRAM values:\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"               Initiator ID = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_initiator_id
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"             Fifo Threshold = 0x%x\n"
argument_list|,
name|sdp
operator|->
name|isp_fifo_threshold
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"            Bus Reset Delay = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_bus_reset_delay
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"                Retry Count = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_retry_count
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"                Retry Delay = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_retry_delay
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"              Tag Age Limit = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_tag_aging
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          Selection Timeout = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_selection_timeout
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"            Max Queue Depth = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_max_queue_depth
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"           Async Data Setup = 0x%x\n"
argument_list|,
name|sdp
operator|->
name|isp_async_data_setup
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    REQ/ACK Active Negation = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_req_ack_active_neg
condition|?
name|tru
else|:
name|not
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"  Data Line Active Negation = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_data_line_active_neg
condition|?
name|tru
else|:
name|not
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"       Cmd DMA Burst Enable = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
condition|?
name|tru
else|:
name|not
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_enable
operator|=
name|ISP1080_NVRAM_TGT_DEVICE_ENABLE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|exc_throttle
operator|=
name|ISP1080_NVRAM_TGT_EXEC_THROTTLE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
name|ISP1080_NVRAM_TGT_SYNC_OFFSET
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
name|ISP1080_NVRAM_TGT_SYNC_PERIOD
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_RENEG
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_RENEG
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_QFRZ
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: not supporting QFRZ option "
literal|"for target %d bus %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_ARQ
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_ARQ
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: not disabling ARQ option "
literal|"for target %d bus %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISP1080_NVRAM_TGT_TQING
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_SYNC
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_SYNC
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_WIDE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_WIDE
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_PARITY
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_PARITY
expr_stmt|;
if|if
condition|(
name|ISP1080_NVRAM_TGT_DISC
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|,
name|bus
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_DISC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|cur_dflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|>=
literal|3
condition|)
block|{
name|PRINTF
argument_list|(
literal|"   Target %d: Ena %d Throttle "
literal|"%d Offset %d Period %d Flags "
literal|"0x%x\n"
argument_list|,
name|i
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_enable
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|exc_throttle
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
name|ISP_NVRAM_FIFO_THRESHOLD
argument_list|(
name|nvram_data
argument_list|)
operator||
operator|(
name|ISP_NVRAM_FIFO_THRESHOLD_128
argument_list|(
name|nvram_data
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|sdp
operator|->
name|isp_initiator_id
operator|=
name|ISP_NVRAM_INITIATOR_ID
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
name|ISP_NVRAM_BUS_RESET_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
name|ISP_NVRAM_BUS_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
name|ISP_NVRAM_BUS_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_async_data_setup
operator|=
name|ISP_NVRAM_ASYNC_DATA_SETUP_TIME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|>=
name|ISP_HA_SCSI_1040
condition|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_async_data_setup
operator|<
literal|9
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|9
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_async_data_setup
operator|!=
literal|6
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|6
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
name|ISP_NVRAM_REQ_ACK_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
name|ISP_NVRAM_DATA_LINE_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
name|ISP_NVRAM_DATA_DMA_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
name|ISP_NVRAM_CMD_DMA_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_tag_aging
operator|=
name|ISP_NVRAM_TAG_AGE_LIMIT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_selection_timeout
operator|=
name|ISP_NVRAM_SELECTION_TIMEOUT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|ISP_NVRAM_MAX_QUEUE_DEPTH
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_fast_mttr
operator|=
name|ISP_NVRAM_FAST_MTTR_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: NVRAM values:\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"             Fifo Threshold = 0x%x\n"
argument_list|,
name|sdp
operator|->
name|isp_fifo_threshold
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"            Bus Reset Delay = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_bus_reset_delay
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"                Retry Count = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_retry_count
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"                Retry Delay = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_retry_delay
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"              Tag Age Limit = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_tag_aging
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          Selection Timeout = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_selection_timeout
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"            Max Queue Depth = %d\n"
argument_list|,
name|sdp
operator|->
name|isp_max_queue_depth
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"           Async Data Setup = 0x%x\n"
argument_list|,
name|sdp
operator|->
name|isp_async_data_setup
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    REQ/ACK Active Negation = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_req_ack_active_neg
condition|?
name|tru
else|:
name|not
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"  Data Line Active Negation = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_data_line_active_neg
condition|?
name|tru
else|:
name|not
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"      Data DMA Burst Enable = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_data_dma_burst_enabl
condition|?
name|tru
else|:
name|not
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"       Cmd DMA Burst Enable = %s\n"
argument_list|,
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
condition|?
name|tru
else|:
name|not
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"                  Fast MTTR = %s\n"
argument_list|,
name|isp
operator|->
name|isp_fast_mttr
condition|?
name|tru
else|:
name|not
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_enable
operator|=
name|ISP_NVRAM_TGT_DEVICE_ENABLE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|exc_throttle
operator|=
name|ISP_NVRAM_TGT_EXEC_THROTTLE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
name|ISP_NVRAM_TGT_SYNC_OFFSET
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
name|ISP_NVRAM_TGT_SYNC_PERIOD
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1040
condition|)
block|{
comment|/* 				 * If we're not ultra, we can't possibly 				 * be a shorter period than this. 				 */
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|<
literal|0x19
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
literal|0x19
expr_stmt|;
block|}
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|>
literal|0xc
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
literal|0x0c
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|>
literal|0x8
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
literal|0x8
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_RENEG
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_RENEG
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_QFRZ
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: not supporting QFRZ option for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_ARQ
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_ARQ
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: not disabling ARQ option for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISP_NVRAM_TGT_TQING
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_SYNC
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_SYNC
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_WIDE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_WIDE
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_PARITY
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_PARITY
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_DISC
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_DISC
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|cur_dflags
operator|=
literal|0
expr_stmt|;
comment|/* we don't know */
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
condition|)
block|{
name|PRINTF
argument_list|(
literal|"   Target %d: Enabled %d Throttle %d "
literal|"Offset %d Period %d Flags 0x%x\n"
argument_list|,
name|i
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_enable
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|exc_throttle
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
union|union
block|{
struct|struct
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|u_int32_t
name|hi32
decl_stmt|;
name|u_int32_t
name|lo32
decl_stmt|;
else|#
directive|else
name|u_int32_t
name|lo32
decl_stmt|;
name|u_int32_t
name|hi32
decl_stmt|;
endif|#
directive|endif
block|}
name|wd
struct|;
name|u_int64_t
name|full64
decl_stmt|;
block|}
name|wwnstore
union|;
name|wwnstore
operator|.
name|full64
operator|=
name|ISP2100_NVRAM_NODE_NAME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
comment|/* 		 * Broken PTI cards with nothing in the top nibble. Pah. 		 */
if|if
condition|(
operator|(
name|wwnstore
operator|.
name|wd
operator|.
name|hi32
operator|>>
literal|28
operator|)
operator|==
literal|0
condition|)
block|{
name|wwnstore
operator|.
name|wd
operator|.
name|hi32
operator||=
operator|(
literal|2
operator|<<
literal|28
operator|)
expr_stmt|;
name|CFGPRINTF
argument_list|(
literal|"%s: (corrected) Adapter WWN 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|wwnstore
operator|.
name|wd
operator|.
name|hi32
argument_list|,
name|wwnstore
operator|.
name|wd
operator|.
name|lo32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CFGPRINTF
argument_list|(
literal|"%s: Adapter WWN 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|wwnstore
operator|.
name|wd
operator|.
name|hi32
argument_list|,
name|wwnstore
operator|.
name|wd
operator|.
name|lo32
argument_list|)
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_nodewwn
operator|=
name|wwnstore
operator|.
name|full64
expr_stmt|;
comment|/* 		 * If the Node WWN has 2 in the top nibble, we can 		 * authoritatively construct a Port WWN by adding 		 * our unit number (plus one to make it nonzero) and 		 * putting it into bits 59..56. If the top nibble isn't 		 * 2, then we just set them identically. 		 */
if|if
condition|(
operator|(
name|fcp
operator|->
name|isp_nodewwn
operator|>>
literal|60
operator|)
operator|==
literal|2
condition|)
block|{
name|fcp
operator|->
name|isp_portwwn
operator|=
name|fcp
operator|->
name|isp_nodewwn
operator||
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|isp
operator|->
name|isp_unit
operator|+
literal|1
argument_list|)
operator|)
operator|<<
literal|56
operator|)
expr_stmt|;
block|}
else|else
block|{
name|fcp
operator|->
name|isp_portwwn
operator|=
name|fcp
operator|->
name|isp_nodewwn
expr_stmt|;
block|}
name|wwnstore
operator|.
name|full64
operator|=
name|ISP2100_NVRAM_BOOT_NODE_NAME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|wwnstore
operator|.
name|full64
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: BOOT DEVICE WWN 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|wwnstore
operator|.
name|wd
operator|.
name|hi32
argument_list|,
name|wwnstore
operator|.
name|wd
operator|.
name|lo32
argument_list|)
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_maxalloc
operator|=
name|ISP2100_NVRAM_MAXIOCBALLOCATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_maxfrmlen
operator|=
name|ISP2100_NVRAM_MAXFRAMELENGTH
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_delay
operator|=
name|ISP2100_NVRAM_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_count
operator|=
name|ISP2100_NVRAM_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_loopid
operator|=
name|ISP2100_NVRAM_HARDLOOPID
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_execthrottle
operator|=
name|ISP2100_NVRAM_EXECUTION_THROTTLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator|=
name|ISP2100_NVRAM_OPTIONS
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: NVRAM values:\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"  Max IOCB Allocation = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_maxalloc
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"     Max Frame Length = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_maxfrmlen
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"   Execution Throttle = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_execthrottle
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          Retry Count = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_retry_count
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          Retry Delay = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_retry_delay
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"         Hard Loop ID = %d\n"
argument_list|,
name|fcp
operator|->
name|isp_loopid
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"              Options = 0x%x\n"
argument_list|,
name|fcp
operator|->
name|isp_fwoptions
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"          HBA Options = 0x%x\n"
argument_list|,
name|ISP2100_NVRAM_HBA_OPTIONS
argument_list|(
name|nvram_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: NVRAM is valid\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_rdnvram_word
parameter_list|(
name|isp
parameter_list|,
name|wo
parameter_list|,
name|rp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|wo
decl_stmt|;
name|u_int16_t
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|cbits
decl_stmt|;
name|u_int16_t
name|bit
decl_stmt|,
name|rqst
decl_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP2100_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|8
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_1080
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_12X0
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP1080_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|8
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|6
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|8
expr_stmt|;
block|}
comment|/* 	 * Clock the word select request out... 	 */
for|for
control|(
name|i
operator|=
name|cbits
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|rqst
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|bit
operator|=
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_DATAOUT
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
name|BIU_NVRAM_SELECT
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now read the result back in (bits come back in MSB format). 	 */
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|u_int16_t
name|rv
decl_stmt|;
operator|*
name|rp
operator|<<=
literal|1
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&
name|BIU_NVRAM_DATAIN
condition|)
block|{
operator|*
name|rp
operator||=
literal|1
expr_stmt|;
block|}
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|*
name|rp
operator|=
operator|(
operator|(
operator|*
name|rp
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
name|rp
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

