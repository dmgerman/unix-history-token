begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: isp.c,v 1.2 1998/09/15 08:42:55 gibbs Exp $ */
end_comment

begin_comment
comment|/*  * Machine and OS Independent (well, as best as possible)  * code for the Qlogic ISP SCSI adapters.  *  *---------------------------------------  * Copyright (c) 1997, 1998 by Matthew Jacob  * NASA/Ames Research Center  * All rights reserved.  *---------------------------------------  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Inspiration and ideas about this driver are from Erik Moe's Linux driver  * (qlogicisp.c) and Dave Miller's SBus version of same (qlogicisp.c). Some  * ideas dredged from the Solaris driver.  */
end_comment

begin_comment
comment|/*  * Include header file appropriate for platform we're building on.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ic/isp_netbsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/isp/isp_freebsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|<isp_linux.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * General defines  */
end_comment

begin_define
define|#
directive|define
name|MBOX_DELAY_COUNT
value|1000000 / 100
end_define

begin_comment
comment|/*  * Local static data  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|tgtiqd
index|[
literal|36
index|]
init|=
block|{
literal|0x03
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x51
block|,
literal|0x4C
block|,
literal|0x4F
block|,
literal|0x47
block|,
literal|0x49
block|,
literal|0x43
block|,
literal|0x20
block|,
literal|0x20
block|,
ifdef|#
directive|ifdef
name|__NetBSD__
literal|0x4E
block|,
literal|0x45
block|,
literal|0x54
block|,
literal|0x42
block|,
literal|0x53
block|,
literal|0x44
block|,
literal|0x20
block|,
literal|0x20
block|,
else|#
directive|else
ifdef|#
directive|ifdef
name|__FreeBSD__
literal|0x46
block|,
literal|0x52
block|,
literal|0x45
block|,
literal|0x45
block|,
literal|0x42
block|,
literal|0x52
block|,
literal|0x44
block|,
literal|0x20
block|,
else|#
directive|else
ifdef|#
directive|ifdef
name|linux
literal|0x4C
block|,
literal|0x49
block|,
literal|0x4E
block|,
literal|0x55
block|,
literal|0x58
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
else|#
directive|else
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
literal|0x54
block|,
literal|0x41
block|,
literal|0x52
block|,
literal|0x47
block|,
literal|0x45
block|,
literal|0x54
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x31
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local function prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|isp_parse_async
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_handle_other_response
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ispstatusreq_t
operator|*
operator|,
name|u_int8_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_TARGET_MODE
argument_list|)
operator|||
name|defined
argument_list|(
name|ISP_TARGET_MODE
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|isp_modify_lun
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|isp_parse_status
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ispstatusreq_t
operator|*
operator|,
name|ISP_SCSI_XFER_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_fibre_init
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_fw_state
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_dumpregs
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_dumpxflist
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_prtstst
name|__P
argument_list|(
operator|(
name|ispstatusreq_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_mboxcmd
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|mbreg_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_update
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_setdfltparm
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_read_nvram
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_rdnvram_word
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|u_int16_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reset Hardware.  *  * Hit the chip over the head, download new f/w.  *  * Locking done elsewhere.  */
end_comment

begin_function
name|void
name|isp_reset
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
specifier|static
name|char
name|once
init|=
literal|1
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|loops
decl_stmt|,
name|i
decl_stmt|,
name|dodnld
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|revname
decl_stmt|;
name|isp
operator|->
name|isp_state
operator|=
name|ISP_NILSTATE
expr_stmt|;
comment|/* 	 * Basic types (SCSI, FibreChannel and PCI or SBus) 	 * have been set in the MD code. We figure out more 	 * here. 	 */
name|isp
operator|->
name|isp_dblev
operator|=
name|DFLT_DBLEVEL
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|revname
operator|=
literal|"2100"
expr_stmt|;
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|int
name|rev
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_CONF0
argument_list|)
operator|&
name|BIU_CONF0_HW_MASK
decl_stmt|;
switch|switch
condition|(
name|rev
condition|)
block|{
default|default:
name|PRINTF
argument_list|(
literal|"%s: unknown chip rev. 0x%x- assuming a 1020\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|rev
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|revname
operator|=
literal|"1020"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1020
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * Some 1020A chips are Ultra Capable, but don't 			 * run the clock rate up for that unless told to 			 * do so by the Ultra Capable bits being set. 			 */
name|revname
operator|=
literal|"1020A"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1020A
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|revname
operator|=
literal|"1040"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|revname
operator|=
literal|"1040A"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040A
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|revname
operator|=
literal|"1040B"
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_1040B
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
break|break;
block|}
comment|/* 		 * Try and figure out if we're connected to a differential bus. 		 * You have to pause the RISC processor to read SXP registers. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
name|i
operator|=
literal|100
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_PAUSE
operator|)
operator|==
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: unable to pause RISC processor\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|!=
name|ISP_BT_SBUS
condition|)
block|{
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|BIU_PCI_CONF1_SXP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_DIFF
argument_list|)
operator|&
name|SXP_PINS_DIFF_MODE
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: Differential Mode Set\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_diffmode
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|!=
name|ISP_BT_SBUS
condition|)
block|{
name|ISP_CLRBITS
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|BIU_PCI_CONF1_SXP
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Figure out whether we're ultra capable. 			 */
name|i
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|RISC_PSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|!=
name|ISP_BT_SBUS
condition|)
block|{
name|i
operator|&=
name|RISC_PSR_PCI_ULTRA
expr_stmt|;
block|}
else|else
block|{
name|i
operator|&=
name|RISC_PSR_SBUS_ULTRA
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: Ultra Mode Capable\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_clock
operator|=
literal|60
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_clock
operator|=
literal|40
expr_stmt|;
block|}
comment|/* 			 * Restart processor 			 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Machine dependent clock (if set) overrides 		 * our generic determinations. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
operator|<
name|sdp
operator|->
name|isp_clock
condition|)
block|{
name|sdp
operator|->
name|isp_clock
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_clock
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Do MD specific pre initialization 	 */
name|ISP_RESET0
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|once
operator|==
literal|1
condition|)
block|{
name|once
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Get the current running firmware revision out of the 		 * chip before we hit it over the head (if this is our 		 * first time through). Note that we store this as the 		 * 'ROM' firmware revision- which it may not be. In any 		 * case, we don't really use this yet, but we may in 		 * the future. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABOUT_FIRMWARE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: initial ABOUT FIRMWARE command "
literal|"failed\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_romfw_rev
operator|=
operator|(
operator|(
operator|(
name|u_int16_t
operator|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|<<
literal|10
operator|)
operator|+
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
comment|/* 	 * Hit the chip over the head with hammer, 	 * and give the ISP a chance to recover. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|,
name|BIU_ICR_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 		 * A slight delay... 		 */
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Clear data&& control DMA engines. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|CDMA_CONTROL
argument_list|,
name|DMA_CNTRL_CLEAR_CHAN
operator||
name|DMA_CNTRL_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|DDMA_CONTROL
argument_list|,
name|DMA_CNTRL_CLEAR_CHAN
operator||
name|DMA_CNTRL_RESET_INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
name|BIU2100_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 		 * A slight delay... 		 */
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|CDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|TDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RDMA2100_CONTROL
argument_list|,
name|DMA_CNTRL2100_CLEAR_CHAN
operator||
name|DMA_CNTRL2100_RESET_INT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for ISP to be ready to go... 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|)
operator|&
name|BIU_ICR_SOFT_RESET
operator|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
operator|&
name|BIU2100_SOFT_RESET
operator|)
condition|)
break|break;
block|}
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"chip reset timed out"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * More initialization 	 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * All 2100's are 60Mhz with fast rams onboard. 		 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|RISC_MTR2100
argument_list|,
literal|0x1212
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RESET
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_conf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_conf1
operator|&
name|BIU_BURST_ENABLE
condition|)
block|{
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|CDMA_CONF
argument_list|,
name|DMA_ENABLE_BURST
argument_list|)
expr_stmt|;
name|ISP_SETBITS
argument_list|(
name|isp
argument_list|,
name|DDMA_CONF
argument_list|,
name|DMA_ENABLE_BURST
argument_list|)
expr_stmt|;
block|}
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
comment|/* release paused processor */
comment|/* 	 * Do MD specific post initialization 	 */
name|ISP_RESET1
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Enable interrupts 	 */
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Do some sanity checking. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_NO_OP
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"NOP test failed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_MAILBOX_REG_TEST
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0xdead
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|0xbeef
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0x1111
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0xa5a5
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"Mailbox Register test didn't complete"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|!=
literal|0xdead
operator|||
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|!=
literal|0xbeef
operator|||
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|!=
literal|0xffff
operator|||
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|!=
literal|0x1111
operator|||
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|!=
literal|0xa5a5
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"Register Test Failed"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Download new Firmware, unless requested not to do so. 	 * This is made slightly trickier in some cases where the 	 * firmware of the ROM revision is newer than the revision 	 * compiled into the driver. So, where we used to compare 	 * versions of our f/w and the ROM f/w, now we just see 	 * whether we have f/w at all and whether a config flag 	 * has disabled our download. 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_confopts
operator|&
name|ISP_CFG_NORELOAD
operator|)
condition|)
block|{
name|dodnld
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dodnld
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
condition|;
name|i
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_WRITE_RAM_WORD
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
operator|+
name|i
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_ispfw
index|[
name|i
index|]
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"f/w download failed"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_fwlen
condition|)
block|{
comment|/* 			 * Verify that it downloaded correctly. 			 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_VERIFY_CHECKSUM
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"ram checksum failure"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: skipping f/w download\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now start it rolling. 	 * 	 * If we didn't actually download f/w, 	 * we still need to (re)start it. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_EXEC_FIRMWARE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|isp
operator|->
name|isp_mdvec
operator|->
name|dv_codeorg
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
comment|/* 		 * Set CLOCK RATE, but only if asked to. 		 */
if|if
condition|(
name|sdp
operator|->
name|isp_clock
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_CLOCK_RATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_clock
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set CLOCKRATE"
argument_list|)
expr_stmt|;
comment|/* but continue */
block|}
else|else
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: setting input clock to %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|sdp
operator|->
name|isp_clock
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABOUT_FIRMWARE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"ABOUT FIRMWARE command failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: Board Revision %s, %s F/W Revision %d.%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|revname
argument_list|,
name|dodnld
condition|?
literal|"loaded"
else|:
literal|"resident"
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_fwrev
operator|=
operator|(
operator|(
operator|(
name|u_int16_t
operator|)
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|<<
literal|10
operator|)
operator|+
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_romfw_rev
operator|&&
name|dodnld
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Last F/W revision was %d.%d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
operator|>>
literal|10
argument_list|,
name|isp
operator|->
name|isp_romfw_rev
operator|&
literal|0x3ff
argument_list|)
expr_stmt|;
block|}
name|isp_fw_state
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RESETSTATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize Hardware to known state  *  * Locks are held before coming here.  */
end_comment

begin_function
name|void
name|isp_init
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|sdparam
modifier|*
name|sdp
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|tgt
decl_stmt|;
comment|/* 	 * Must do first. 	 */
name|isp_setdfltparm
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * If we're fibre, we have a completely different 	 * initialization method. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|isp_fibre_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return;
block|}
name|sdp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
comment|/* 	 * Set (possibly new) Initiator ID. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_INIT_SCSI_ID
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_initiator_id
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set initiator id"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set Retry Delay and Count 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_RETRY_COUNT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_retry_count
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_retry_delay
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set retry count and delay"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set ASYNC DATA SETUP time. This is very important. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_ASYNC_DATA_SETUP_TIME
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_async_data_setup
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set async data setup time"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set ACTIVE Negation State. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_ACTIVE_NEG_STATE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|<<
literal|4
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_data_line_active_neg
operator|<<
literal|5
operator|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set active neg state"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set the Tag Aging limit 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TAG_AGE_LIMIT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_tag_aging
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set tag age limit"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set selection timeout. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_SELECT_TIMEOUT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|sdp
operator|->
name|isp_selection_timeout
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"failed to set selection timeout"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set per-target parameters to a safe minimum. 	 */
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
name|int
name|maxlun
decl_stmt|,
name|lun
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|==
literal|0
condition|)
continue|continue;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * It is not quite clear when this changed over so that 		 * we could force narrow and async, so assume>= 7.55. 		 * 		 * Otherwise, a SCSI bus reset issued below will force 		 * the back to the narrow, async state (but see note 		 * below also). Technically we should also do without 		 * Parity. 		 */
if|if
condition|(
name|isp
operator|->
name|isp_fwrev
operator|>=
name|ISP_FW_REV
argument_list|(
literal|7
argument_list|,
literal|55
argument_list|)
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator||=
name|DPARM_NARROW
operator||
name|DPARM_ASYNC
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|>>
literal|8
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"\n%s: tgt %d cflags %x offset %x period %x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|tgt
operator|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
operator|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set parameters for tgt %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: flags %x offset %x period %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
argument_list|,
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed even to set defaults for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|maxlun
operator|=
operator|(
name|isp
operator|->
name|isp_fwrev
operator|>=
name|ISP_FW_REV
argument_list|(
literal|7
argument_list|,
literal|55
argument_list|)
operator|)
condition|?
literal|32
else|:
literal|8
expr_stmt|;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|maxlun
condition|;
name|lun
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_DEV_QUEUE_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|tgt
operator|<<
literal|8
operator|)
operator||
name|lun
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_max_queue_depth
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|exc_throttle
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to set device queue "
literal|"parameters for target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|,
name|lun
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * Set up DMA for the request and result mailboxes. 	 */
if|if
condition|(
name|ISP_MBOXDMASETUP
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: can't setup dma mailboxes\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_RES_QUEUE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RESULT_QUEUE_LEN
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|isp
operator|->
name|isp_result_dma
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|isp
operator|->
name|isp_result_dma
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"set of response queue failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_residx
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_REQ_QUEUE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|RQUEST_QUEUE_LEN
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"set of request queue failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
literal|0
expr_stmt|;
comment|/*	 	 * XXX: See whether or not for 7.55 F/W or later we 	 * XXX: can do without this, and see whether we should 	 * XXX: honor the NVRAM SCSI_RESET_DISABLE token. 	 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_BUS_RESET
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"SCSI bus reset failed"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This is really important to have set after a bus reset. 	 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|isp
operator|->
name|isp_state
operator|=
name|ISP_INITSTATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fibre Channel specific initialization.  *  * Locks are held before coming here.  */
end_comment

begin_function
specifier|static
name|void
name|isp_fibre_init
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|fcparam
modifier|*
name|fcp
decl_stmt|;
name|isp_icb_t
modifier|*
name|icbp
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_int8_t
name|lwfs
decl_stmt|;
name|fcp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
if|if
condition|(
name|ISP_MBOXDMASETUP
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: can't setup DMA for mailboxes\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|icbp
operator|=
operator|(
name|isp_icb_t
operator|*
operator|)
name|fcp
operator|->
name|isp_scratch
expr_stmt|;
name|bzero
argument_list|(
name|icbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|icbp
argument_list|)
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_version
operator|=
name|ICB_VERSION1
expr_stmt|;
name|fcp
operator|->
name|isp_fwoptions
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP2100_TARGET_MODE
name|fcp
operator|->
name|isp_fwoptions
operator||=
name|ICBOPT_TGT_ENABLE
operator||
name|ICBOPT_INI_TGTTYPE
expr_stmt|;
name|icbp
operator|->
name|icb_iqdevtype
operator|=
literal|0x23
expr_stmt|;
comment|/* DPQ_SUPPORTED/PROCESSOR */
endif|#
directive|endif
name|icbp
operator|->
name|icb_fwoptions
operator|=
name|fcp
operator|->
name|isp_fwoptions
expr_stmt|;
name|icbp
operator|->
name|icb_maxfrmlen
operator|=
name|fcp
operator|->
name|isp_maxfrmlen
expr_stmt|;
if|if
condition|(
name|icbp
operator|->
name|icb_maxfrmlen
operator|<
name|ICB_MIN_FRMLEN
operator|||
name|icbp
operator|->
name|icb_maxfrmlen
operator|>
name|ICB_MAX_FRMLEN
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad frame length (%d) from NVRAM- using %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_maxfrmlen
argument_list|,
name|ICB_DFLT_FRMLEN
argument_list|)
expr_stmt|;
block|}
name|icbp
operator|->
name|icb_maxalloc
operator|=
name|fcp
operator|->
name|isp_maxalloc
expr_stmt|;
name|icbp
operator|->
name|icb_execthrottle
operator|=
name|fcp
operator|->
name|isp_execthrottle
expr_stmt|;
name|icbp
operator|->
name|icb_retry_delay
operator|=
name|fcp
operator|->
name|isp_retry_delay
expr_stmt|;
name|icbp
operator|->
name|icb_retry_count
operator|=
name|fcp
operator|->
name|isp_retry_count
expr_stmt|;
name|MAKE_NODE_NAME_FROM_WWN
argument_list|(
name|icbp
operator|->
name|icb_nodename
argument_list|,
name|fcp
operator|->
name|isp_wwn
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_rqstqlen
operator|=
name|RQUEST_QUEUE_LEN
expr_stmt|;
name|icbp
operator|->
name|icb_rsltqlen
operator|=
name|RESULT_QUEUE_LEN
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_rqstaddr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|isp
operator|->
name|isp_rquest_dma
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR0015
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|isp
operator|->
name|isp_result_dma
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|icbp
operator|->
name|icb_respaddr
index|[
name|RQRSP_ADDR1631
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|isp
operator|->
name|isp_result_dma
operator|>>
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|10
condition|;
name|count
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_INIT_FIRMWARE
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|fcp
operator|->
name|isp_scdma
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
name|count
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|ASYNC_LIP_OCCURRED
case|:
case|case
name|ASYNC_LOOP_UP
case|:
case|case
name|ASYNC_LOOP_DOWN
case|:
case|case
name|ASYNC_LOOP_RESET
case|:
case|case
name|ASYNC_PDB_CHANGED
case|:
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
if|if
condition|(
name|count
operator|>
literal|9
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: too many retries to get going- "
literal|"giving up\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"INIT FIRMWARE failed"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|isp
operator|->
name|isp_reqidx
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
literal|0
expr_stmt|;
name|isp
operator|->
name|isp_residx
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Wait up to 12 seconds for FW to go to READY state. 	 * This used to be 3 seconds, but that lost. 	 * 	 * This is all very much not right. The problem here 	 * is that the cable may not be plugged in, or there 	 * may be many many members of the loop that haven't 	 * been logged into. 	 * 	 * This model of doing things doesn't support dynamic 	 * attachment, so we just plain lose (for now). 	 */
name|lwfs
operator|=
name|FW_CONFIG_WAIT
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|12000
condition|;
name|count
operator|++
control|)
block|{
name|isp_fw_state
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwfs
operator|!=
name|fcp
operator|->
name|isp_fwstate
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Firmware State %s -> %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fw_statename
argument_list|(
name|lwfs
argument_list|)
argument_list|,
name|fw_statename
argument_list|(
name|fcp
operator|->
name|isp_fwstate
argument_list|)
argument_list|)
expr_stmt|;
name|lwfs
operator|=
name|fcp
operator|->
name|isp_fwstate
expr_stmt|;
block|}
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|==
name|FW_READY
condition|)
block|{
break|break;
block|}
name|SYS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* wait one millisecond */
block|}
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get our Loop ID 	 * (if possible) 	 */
if|if
condition|(
name|fcp
operator|->
name|isp_fwstate
operator|==
name|FW_READY
condition|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_LOOP_ID
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"GET LOOP ID failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fcp
operator|->
name|isp_loopid
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
name|fcp
operator|->
name|isp_alpa
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Loop ID 0x%x, ALPA 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|fcp
operator|->
name|isp_loopid
argument_list|,
name|fcp
operator|->
name|isp_alpa
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_state
operator|=
name|ISP_INITSTATE
expr_stmt|;
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_fwrev
operator|>=
name|ISP_FW_REV
argument_list|(
literal|1
argument_list|,
literal|13
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_TARGET_MODE
argument_list|)
operator|||
name|defined
argument_list|(
name|ISP_TARGET_MODE
argument_list|)
if|if
condition|(
name|isp_modify_lun
argument_list|(
name|isp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to establish target mode\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to go to FW READY state- will not attach\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free any associated resources prior to decommissioning and  * set the card to a known state (so it doesn't wake up and kick  * us when we aren't expecting it to).  *  * Locks are held before coming here.  */
end_comment

begin_function
name|void
name|isp_uninit
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
comment|/* 	 * Leave with interrupts disabled. 	 */
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the watchdog timer (if started). 	 */
name|STOP_WATCHDOG
argument_list|(
name|isp_watch
argument_list|,
name|isp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a command. Locking is assumed done in the caller.  */
end_comment

begin_function
name|int32_t
name|ispscsicmd
parameter_list|(
name|xs
parameter_list|)
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
union|union
block|{
name|ispreq_t
modifier|*
name|_reqp
decl_stmt|;
name|ispreqt2_t
modifier|*
name|_t2reqp
decl_stmt|;
block|}
name|_u
union|;
define|#
directive|define
name|reqp
value|_u._reqp
define|#
directive|define
name|t2reqp
value|_u._t2reqp
define|#
directive|define
name|UZSIZE
value|max(sizeof (ispreq_t), sizeof (ispreqt2_t))
name|int
name|i
decl_stmt|;
name|XS_INITERR
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|isp
operator|=
name|XS_ISP
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: adapter not ready\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * We *could* do the different sequence type that has clos 	 * to the whole Queue Entry for the command,. 	 */
if|if
condition|(
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
operator|>
operator|(
operator|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
operator|)
condition|?
literal|16
else|:
literal|12
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: unsupported cdb length (%d)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
comment|/* 	 * First check to see if any HBA or Device 	 * parameters need to be updated. 	 */
if|if
condition|(
name|isp
operator|->
name|isp_update
condition|)
block|{
name|isp_update
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
name|optr
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|isp
operator|->
name|isp_reqidx
expr_stmt|;
name|reqp
operator|=
operator|(
name|ispreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptr
operator|==
name|optr
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Request Queue Overflow\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|DISABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_sendmarker
condition|)
block|{
name|u_int8_t
name|niptr
decl_stmt|;
name|ispmarkreq_t
modifier|*
name|marker
init|=
operator|(
name|ispmarkreq_t
operator|*
operator|)
name|reqp
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|marker
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|marker
argument_list|)
argument_list|)
expr_stmt|;
name|marker
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|marker
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_MARKER
expr_stmt|;
name|marker
operator|->
name|req_modifier
operator|=
name|SYNC_ALL
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|0
expr_stmt|;
name|niptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|niptr
operator|==
name|optr
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
name|PRINTF
argument_list|(
literal|"%s: Request Queue Overflow+\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
name|reqp
operator|=
operator|(
name|ispreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|niptr
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|reqp
argument_list|,
name|UZSIZE
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_T2RQS
expr_stmt|;
block|}
else|else
block|{
name|reqp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_REQUEST
expr_stmt|;
block|}
name|reqp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|reqp
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|RQUEST_QUEUE_LEN
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: ran out of xflist pointers?????\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_EAGAIN
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Never have a handle that is zero, so 		 * set req_handle off by one. 		 */
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
operator|=
name|xs
expr_stmt|;
name|reqp
operator|->
name|req_handle
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
comment|/* 		 * See comment in isp_intr 		 */
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Fibre Channel always requires some kind of tag. 		 * If we're marked as "Can't Tag", just do simple 		 * instead of ordered tags. It's pretty clear to me 		 * that we shouldn't do head of queue tagging in 		 * this case. 		 */
if|if
condition|(
name|XS_CANTAG
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|t2reqp
operator|->
name|req_flags
operator|=
name|XS_KINDOF_TAG
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t2reqp
operator|->
name|req_flags
operator|=
name|REQFLAG_STAG
expr_stmt|;
block|}
block|}
else|else
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
if|if
condition|(
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|cur_dflags
operator|&
name|DPARM_TQING
operator|)
operator|&&
name|XS_CANTAG
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|reqp
operator|->
name|req_flags
operator|=
name|XS_KINDOF_TAG
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reqp
operator|->
name|req_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|reqp
operator|->
name|req_lun_trn
operator|=
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_target
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|reqp
operator|->
name|req_cdblen
operator|=
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|XS_CDBP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|reqp
operator|->
name|req_cdb
argument_list|,
name|XS_CDBLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s(%d.%d): START%d cmd 0x%x datalen %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|,
name|reqp
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|,
name|reqp
operator|->
name|req_cdb
index|[
literal|0
index|]
operator|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|reqp
operator|->
name|req_time
operator|=
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|reqp
operator|->
name|req_time
operator|==
literal|0
operator|&&
name|XS_TIME
argument_list|(
name|xs
argument_list|)
condition|)
name|reqp
operator|->
name|req_time
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ISP_DMASETUP
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|reqp
argument_list|,
operator|&
name|iptr
argument_list|,
name|optr
argument_list|)
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* dmasetup sets actual error */
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
name|isp
operator|->
name|isp_nactive
operator|++
expr_stmt|;
return|return
operator|(
name|CMD_QUEUED
operator|)
return|;
undef|#
directive|undef
name|reqp
undef|#
directive|undef
name|t2reqp
block|}
end_function

begin_comment
comment|/*  * isp control  * Locks (ints blocked) assumed held.  */
end_comment

begin_function
name|int
name|isp_control
parameter_list|(
name|isp
parameter_list|,
name|ctl
parameter_list|,
name|arg
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispctl_t
name|ctl
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
default|default:
name|PRINTF
argument_list|(
literal|"%s: isp_control unknown control op %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPCTL_RESET_BUS
case|:
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_BUS_RESET
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
operator|)
condition|?
literal|5
else|:
literal|2
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"isp_control SCSI bus reset failed"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * This is really important to have set after a bus reset. 		 */
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: driver initiated bus reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_RESET_DEV
case|:
comment|/* 		 * Note that under parallel SCSI, this issues a BDR message. 		 * Under FC, we could probably be using ABORT TASK SET 		 * command. 		 */
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABORT_TARGET
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|long
operator|)
name|arg
operator|)
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
literal|2
expr_stmt|;
comment|/* 'delay', in seconds */
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"SCSI Target  reset failed"
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: Target %d Reset Succeeded\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|long
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_ABORT_CMD
case|:
name|xs
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xs
operator|==
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|RQUEST_QUEUE_LEN
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_control- cannot find command to abort "
literal|"in active list\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_ABORT
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|>>
literal|16
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_control MBOX_ABORT failure (code %x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: command for target %d lun %d was aborted\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ISPCTL_UPDATE_PARAMS
case|:
name|isp_update
argument_list|(
name|isp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt Service Routine(s).  *  * External (OS) framework has done the appropriate locking,  * and the locking will be held throughout this function.  */
end_comment

begin_function
name|int
name|isp_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|complist
index|[
name|RESULT_QUEUE_LEN
index|]
decl_stmt|,
modifier|*
name|xs
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|arg
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
name|u_int16_t
name|isr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ndone
init|=
literal|0
decl_stmt|;
name|isr
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
if|if
condition|(
name|isr
operator|==
literal|0
operator|||
operator|(
name|isr
operator|&
name|BIU2100_ISR_RISC_INT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s: isp_intr isr=%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|isr
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isr
operator|==
literal|0
operator|||
operator|(
name|isr
operator|&
name|BIU_ISR_RISC_INT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s: isp_intr isr=%x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|isr
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|1
condition|)
block|{
name|u_int16_t
name|mbox
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
decl_stmt|;
if|if
condition|(
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
name|mbox
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
name|optr
operator|=
name|isp
operator|->
name|isp_residx
expr_stmt|;
name|iptr
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX5
argument_list|)
expr_stmt|;
if|if
condition|(
name|optr
operator|==
name|iptr
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"why intr? isr %x iptr %x optr %x\n"
operator|,
name|isr
operator|,
name|optr
operator|,
name|iptr
operator|)
argument_list|)
expr_stmt|;
block|}
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
while|while
condition|(
name|optr
operator|!=
name|iptr
condition|)
block|{
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|u_int8_t
name|oop
decl_stmt|;
name|int
name|buddaboom
init|=
literal|0
decl_stmt|;
name|sp
operator|=
operator|(
name|ispstatusreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_result
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|oop
operator|=
name|optr
expr_stmt|;
name|optr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|optr
argument_list|,
name|RESULT_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|!=
name|RQSTYPE_RESPONSE
condition|)
block|{
if|if
condition|(
name|isp_handle_other_response
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|,
operator|&
name|optr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * It really has to be a bounced request just copied 			 * from the request queue to the response queue. 			 */
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|!=
name|RQSTYPE_REQUEST
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|PRINTF
argument_list|(
literal|"%s: not RESPONSE in RESPONSE Queue "
literal|"(type 0x%x) @ idx %d (next %d)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|,
name|oop
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|buddaboom
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
literal|0xf
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_CONTINUATION
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|PRINTF
argument_list|(
literal|"%s: rqs_flags=%x"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_FULL
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: internal queues full\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
comment|/* XXXX: this command *could* get restarted */
name|buddaboom
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_BADHEADER
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad header\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_flags
operator|&
name|RQSFLAG_BADPACKET
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad request packet\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|buddaboom
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|req_handle
operator|>
name|RQUEST_QUEUE_LEN
operator|||
name|sp
operator|->
name|req_handle
operator|<
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad request handle %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|xs
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|sp
operator|->
name|req_handle
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: NULL xs in xflist (handle %x)\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_handle
argument_list|)
expr_stmt|;
name|isp_dumpxflist
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|isp
operator|->
name|isp_xflist
index|[
name|sp
operator|->
name|req_handle
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_BUS_RESET
condition|)
block|{
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|buddaboom
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_scsi_status
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
block|{
name|bcopy
argument_list|(
name|sp
operator|->
name|req_sense_data
argument_list|,
name|XS_SNSP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_SNSLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SNS_IS_VALID
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
condition|)
block|{
name|XS_SNS_IS_VALID
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sp
operator|->
name|req_sense_data
argument_list|,
name|XS_SNSP
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_SNSLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|req_state_flags
operator||=
name|RQSF_GOT_SENSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
operator|&&
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_BUSY
condition|)
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_TGTBSY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|==
name|RQSTYPE_RESPONSE
condition|)
block|{
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|req_completion_status
operator|!=
name|RQCS_COMPLETE
condition|)
block|{
name|isp_parse_status
argument_list|(
name|isp
argument_list|,
name|sp
argument_list|,
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|PRINTF
argument_list|(
literal|"%s: unknown return %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|req_scsi_status
operator|&
name|RQCS_RU
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s: cnt %d rsd %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
operator|,
name|sp
operator|->
name|req_resid
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|ISP_DMAFREE
argument_list|(
name|isp
argument_list|,
name|xs
argument_list|,
name|sp
operator|->
name|req_handle
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * XXX: If we have a check condition, but no Sense Data, 		 * XXX: mark it as an error (ARQ failed). We need to 		 * XXX: to do a more distinct job because there may 		 * XXX: cases where ARQ is disabled. 		 */
if|if
condition|(
name|XS_STS
argument_list|(
name|xs
argument_list|)
operator|==
name|SCSI_CHECK
operator|&&
operator|!
operator|(
name|XS_IS_SNS_VALID
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: ARQ Failure\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ARQFAIL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_dblev
operator|>=
literal|5
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_dblev
operator|>
literal|2
operator|&&
operator|!
name|XS_NOERR
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s(%d.%d): FIN%d dl%d resid%d STS %x"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_seqno
argument_list|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_RESID
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_STS
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
block|{
name|PRINTF
argument_list|(
literal|" Skey: %x"
argument_list|,
name|XS_SNSKEY
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XS_IS_SNS_VALID
argument_list|(
name|xs
argument_list|)
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|" BUT NOT SET"
argument_list|)
expr_stmt|;
block|}
block|}
name|PRINTF
argument_list|(
literal|" XS_ERR=0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|XS_ERR
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_nactive
operator|<
literal|0
condition|)
name|isp
operator|->
name|isp_nactive
operator|=
literal|0
expr_stmt|;
name|complist
index|[
name|ndone
operator|++
index|]
operator|=
name|xs
expr_stmt|;
comment|/* defer completion call until later */
block|}
comment|/* 	 * If we completed any commands, then it's valid to find out 	 * what the outpointer is. 	 */
if|if
condition|(
name|ndone
condition|)
block|{
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
block|}
name|isp
operator|->
name|isp_residx
operator|=
name|optr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndone
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
name|complist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xs
condition|)
block|{
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support routines.  */
end_comment

begin_function
specifier|static
name|int
name|isp_parse_async
parameter_list|(
name|isp
parameter_list|,
name|mbox
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|u_int16_t
name|mbox
decl_stmt|;
block|{
switch|switch
condition|(
name|mbox
condition|)
block|{
case|case
name|ASYNC_BUS_RESET
case|:
name|PRINTF
argument_list|(
literal|"%s: SCSI bus reset detected\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ASYNC_SYSTEM_ERROR
case|:
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Internal FW Error @ RISC Addr 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
name|isp_restart
argument_list|(
name|isp
argument_list|)
expr_stmt|;
comment|/* no point continuing after this */
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|ASYNC_RQS_XFER_ERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Request Queue Transfer Error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_RSP_XFER_ERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Response Queue Transfer Error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_QWAKEUP
case|:
comment|/* don't need to be chatty */
name|mbox
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_TIMEOUT_RESET
case|:
name|PRINTF
argument_list|(
literal|"%s: timeout initiated SCSI bus reset\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ASYNC_UNSPEC_TMODE
case|:
name|PRINTF
argument_list|(
literal|"%s: mystery async target completion\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_EXTMSG_UNDERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: extended message underrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_SCAM_INT
case|:
name|PRINTF
argument_list|(
literal|"%s: SCAM interrupt\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_HUNG_SCSI
case|:
name|PRINTF
argument_list|(
literal|"%s: stalled SCSI Bus after DATA Overrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
comment|/* XXX: Need to issue SCSI reset at this point */
break|break;
case|case
name|ASYNC_KILLED_BUS
case|:
name|PRINTF
argument_list|(
literal|"%s: SCSI Bus reset after DATA Overrun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_BUS_TRANSIT
case|:
name|PRINTF
argument_list|(
literal|"%s: LBD->HVD Transition 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CMD_CMPLT
case|:
name|PRINTF
argument_list|(
literal|"%s: fast post completion\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fast_post_handle = (ISP_READ(isp, OUTMAILBOX1)<< 16) | 		    ISP_READ(isp, OUTMAILBOX2);
endif|#
directive|endif
break|break;
case|case
name|ASYNC_CTIO_DONE
case|:
name|PRINTF
argument_list|(
literal|"%s: CTIO done\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LIP_OCCURRED
case|:
name|PRINTF
argument_list|(
literal|"%s: LIP occurred\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_UP
case|:
name|PRINTF
argument_list|(
literal|"%s: Loop UP\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_DOWN
case|:
name|PRINTF
argument_list|(
literal|"%s: Loop DOWN\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_RESET
case|:
name|PRINTF
argument_list|(
literal|"%s: Loop RESET\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_PDB_CHANGED
case|:
name|PRINTF
argument_list|(
literal|"%s: Port Database Changed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_CHANGE_NOTIFY
case|:
name|PRINTF
argument_list|(
literal|"%s: Name Server Database Changed\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: async %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_handle_other_response
parameter_list|(
name|isp
parameter_list|,
name|sp
parameter_list|,
name|optrp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|u_int8_t
modifier|*
name|optrp
decl_stmt|;
block|{
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
name|int
name|reqsize
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ireqp
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
condition|)
block|{
case|case
name|RQSTYPE_REQUEST
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_TARGET_MODE
argument_list|)
operator|||
name|defined
argument_list|(
name|ISP_TARGET_MODE
argument_list|)
case|case
name|RQSTYPE_NOTIFY_ACK
case|:
block|{
name|ispnotify_t
modifier|*
name|spx
init|=
operator|(
name|ispnotify_t
operator|*
operator|)
name|sp
decl_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Immediate Notify Ack %d.%d Status 0x%x Sequence "
literal|"0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|spx
operator|->
name|req_initiator
argument_list|,
name|spx
operator|->
name|req_lun
argument_list|,
name|spx
operator|->
name|req_status
argument_list|,
name|spx
operator|->
name|req_sequence
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RQSTYPE_NOTIFY
case|:
block|{
name|ispnotify_t
modifier|*
name|spx
init|=
operator|(
name|ispnotify_t
operator|*
operator|)
name|sp
decl_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Notify loopid %d to lun %d req_status 0x%x "
literal|"req_task_flags 0x%x seq 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|spx
operator|->
name|req_initiator
argument_list|,
name|spx
operator|->
name|req_lun
argument_list|,
name|spx
operator|->
name|req_status
argument_list|,
name|spx
operator|->
name|req_task_flags
argument_list|,
name|spx
operator|->
name|req_sequence
argument_list|)
expr_stmt|;
name|reqsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|spx
argument_list|)
expr_stmt|;
name|spx
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_NOTIFY_ACK
expr_stmt|;
name|spx
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|spx
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|spx
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
name|spx
operator|->
name|req_handle
operator|=
operator|(
name|spx
operator|->
name|req_initiator
operator|<<
literal|16
operator|)
operator||
name|RQSTYPE_NOTIFY_ACK
expr_stmt|;
if|if
condition|(
name|spx
operator|->
name|req_status
operator|==
name|IN_RSRC_UNAVAIL
condition|)
name|spx
operator|->
name|req_flags
operator|=
name|LUN_INCR_CMD
expr_stmt|;
elseif|else
if|if
condition|(
name|spx
operator|->
name|req_status
operator|==
name|IN_NOCAP
condition|)
name|spx
operator|->
name|req_flags
operator|=
name|LUN_INCR_IMMED
expr_stmt|;
else|else
block|{
name|reqsize
operator|=
literal|0
expr_stmt|;
block|}
name|ireqp
operator|=
name|spx
expr_stmt|;
break|break;
block|}
case|case
name|RQSTYPE_ENABLE_LUN
case|:
block|{
name|isplun_t
modifier|*
name|ip
init|=
operator|(
name|isplun_t
operator|*
operator|)
name|sp
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|req_status
operator|!=
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: ENABLE LUN returned status 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ip
operator|->
name|req_status
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|RQSTYPE_ATIO2
case|:
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|ispctiot2_t
name|local
decl_stmt|,
modifier|*
name|ct2
init|=
name|NULL
decl_stmt|;
name|ispatiot2_t
modifier|*
name|at2
init|=
operator|(
name|ispatiot2_t
operator|*
operator|)
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|PRINTF
argument_list|(
literal|"%s: atio2 loopid %d for lun %d rxid 0x%x flags 0x%x "
literal|"task flags 0x%x exec codes 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|at2
operator|->
name|req_initiator
argument_list|,
name|at2
operator|->
name|req_lun
argument_list|,
name|at2
operator|->
name|req_rxid
argument_list|,
name|at2
operator|->
name|req_flags
argument_list|,
name|at2
operator|->
name|req_taskflags
argument_list|,
name|at2
operator|->
name|req_execodes
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|at2
operator|->
name|req_status
operator|&
operator|~
name|ATIO_SENSEVALID
condition|)
block|{
case|case
name|ATIO_PATH_INVALID
case|:
name|PRINTF
argument_list|(
literal|"%s: ATIO2 Path Invalid\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATIO_NOCAP
case|:
name|PRINTF
argument_list|(
literal|"%s: ATIO2 No Cap\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATIO_BDR_MSG
case|:
name|PRINTF
argument_list|(
literal|"%s: ATIO2 BDR Received\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATIO_CDB_RECEIVED
case|:
name|ct2
operator|=
operator|&
name|local
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%s: unknown req_status 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|at2
operator|->
name|req_status
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ct2
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Just do an ACCEPT on this fellow. 			 */
name|at2
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_ATIO2
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|at2
operator|->
name|req_flags
operator|=
literal|1
expr_stmt|;
name|ireqp
operator|=
name|at2
expr_stmt|;
name|reqsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|at2
argument_list|)
expr_stmt|;
break|break;
block|}
name|PRINTF
argument_list|(
literal|"%s: datalen %d cdb0=0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|at2
operator|->
name|req_datalen
argument_list|,
name|at2
operator|->
name|req_cdb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ct2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ct2
argument_list|)
argument_list|)
expr_stmt|;
name|ct2
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_CTIO2
expr_stmt|;
name|ct2
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|ct2
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|ct2
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
name|ct2
operator|->
name|req_handle
operator|=
operator|(
name|at2
operator|->
name|req_initiator
operator|<<
literal|16
operator|)
operator||
name|at2
operator|->
name|req_lun
expr_stmt|;
name|ct2
operator|->
name|req_lun
operator|=
name|at2
operator|->
name|req_lun
expr_stmt|;
name|ct2
operator|->
name|req_initiator
operator|=
name|at2
operator|->
name|req_initiator
expr_stmt|;
name|ct2
operator|->
name|req_rxid
operator|=
name|at2
operator|->
name|req_rxid
expr_stmt|;
name|ct2
operator|->
name|req_flags
operator|=
name|CTIO_SEND_STATUS
expr_stmt|;
switch|switch
condition|(
name|at2
operator|->
name|req_cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* TUR */
name|ct2
operator|->
name|req_flags
operator||=
name|CTIO_NODATA
operator||
name|CTIO2_SMODE0
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_scsi_status
operator|=
name|CTIO2_STATUS_VALID
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/* REQUEST SENSE */
case|case
literal|0x12
case|:
comment|/* INQUIRE */
name|ct2
operator|->
name|req_flags
operator||=
name|CTIO_SEND_DATA
operator||
name|CTIO2_SMODE0
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_scsi_status
operator|=
name|CTIO2_STATUS_VALID
expr_stmt|;
name|ct2
operator|->
name|req_seg_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|at2
operator|->
name|req_cdb
index|[
literal|0
index|]
operator|==
literal|0x12
condition|)
block|{
name|s
operator|=
sizeof|sizeof
argument_list|(
name|tgtiqd
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tgtiqd
argument_list|,
name|fcp
operator|->
name|isp_scratch
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|at2
operator|->
name|req_datalen
expr_stmt|;
name|bzero
argument_list|(
name|fcp
operator|->
name|isp_scratch
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_dataseg
index|[
literal|0
index|]
operator|.
name|ds_base
operator|=
name|fcp
operator|->
name|isp_scdma
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_dataseg
index|[
literal|0
index|]
operator|.
name|ds_count
operator|=
name|s
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode0
operator|.
name|req_datalen
operator|=
name|s
expr_stmt|;
if|#
directive|if
literal|0
block|if (at2->req_datalen< s) { 				ct2->req_m.mode1.req_scsi_status |= 				    CTIO2_RESP_VALID|CTIO2_RSPOVERUN; 			} else if (at2->req_datalen> s) { 				ct2->req_m.mode1.req_scsi_status |= 				    CTIO2_RESP_VALID|CTIO2_RSPUNDERUN; 			}
endif|#
directive|endif
break|break;
default|default:
comment|/* ALL OTHERS */
name|ct2
operator|->
name|req_flags
operator||=
name|CTIO_NODATA
operator||
name|CTIO2_SMODE1
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (at2->req_datalen) { 				ct2->req_m.mode1.req_scsi_status |= 				    CTIO2_RSPUNDERUN;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
block|ct2->req_resid[1] = at2->req_datalen& 0xff; 				ct2->req_resid[0] = 					(at2->req_datalen>> 8)& 0xff; 				ct2->req_resid[3] = 					(at2->req_datalen>> 16)& 0xff; 				ct2->req_resid[2] = 					(at2->req_datalen>> 24)& 0xff;
else|#
directive|else
block|ct2->req_resid[0] = at2->req_datalen& 0xff; 				ct2->req_resid[1] = 					(at2->req_datalen>> 8)& 0xff; 				ct2->req_resid[2] = 					(at2->req_datalen>> 16)& 0xff; 				ct2->req_resid[3] = 					(at2->req_datalen>> 24)& 0xff;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|at2
operator|->
name|req_status
operator|&
name|ATIO_SENSEVALID
operator|)
operator|==
literal|0
condition|)
block|{
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_sense_len
operator|=
literal|18
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator||=
literal|2
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_response
index|[
literal|0
index|]
operator|=
literal|0x70
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_response
index|[
literal|2
index|]
operator|=
literal|0x2
expr_stmt|;
block|}
else|else
block|{
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_sense_len
operator|=
literal|18
expr_stmt|;
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_scsi_status
operator||=
name|at2
operator|->
name|req_scsi_status
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|at2
operator|->
name|req_sense
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ct2
operator|->
name|req_m
operator|.
name|mode1
operator|.
name|req_response
argument_list|,
sizeof|sizeof
argument_list|(
name|at2
operator|->
name|req_sense
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|reqsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ct2
argument_list|)
expr_stmt|;
name|ireqp
operator|=
name|ct2
expr_stmt|;
break|break;
block|}
case|case
name|RQSTYPE_CTIO2
case|:
block|{
name|ispatiot2_t
modifier|*
name|at2
decl_stmt|;
name|ispctiot2_t
modifier|*
name|ct2
init|=
operator|(
name|ispctiot2_t
operator|*
operator|)
name|sp
decl_stmt|;
name|PRINTF
argument_list|(
literal|"%s: CTIO2 returned status 0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ct2
operator|->
name|req_status
argument_list|)
expr_stmt|;
comment|/* 	 	 * Return the ATIO to the board. 		 */
name|at2
operator|=
operator|(
name|ispatiot2_t
operator|*
operator|)
name|sp
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_ATIO2
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|at2
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
name|at2
operator|->
name|req_status
operator|=
literal|1
expr_stmt|;
name|reqsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|at2
argument_list|)
expr_stmt|;
name|ireqp
operator|=
name|at2
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|PRINTF
argument_list|(
literal|"%s: other response type %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_header
operator|.
name|rqs_entry_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reqsize
condition|)
block|{
name|void
modifier|*
name|reqp
decl_stmt|;
name|optr
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|isp
operator|->
name|isp_reqidx
expr_stmt|;
name|reqp
operator|=
operator|(
name|void
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptr
operator|==
name|optr
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Request Queue Overflow other response\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|ireqp
argument_list|,
name|reqp
argument_list|,
name|reqsize
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISP2100_TARGET_MODE
argument_list|)
operator|||
name|defined
argument_list|(
name|ISP_TARGET_MODE
argument_list|)
end_if

begin_comment
comment|/*  * Locks held, and ints disabled (if FC).  *  * XXX: SETUP ONLY FOR INITIAL ENABLING RIGHT NOW  */
end_comment

begin_function
specifier|static
name|int
name|isp_modify_lun
parameter_list|(
name|isp
parameter_list|,
name|lun
parameter_list|,
name|icnt
parameter_list|,
name|ccnt
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|lun
decl_stmt|;
comment|/* logical unit to enable, modify, or disable */
name|int
name|icnt
decl_stmt|;
comment|/* immediate notify count */
name|int
name|ccnt
decl_stmt|;
comment|/* command count */
block|{
name|isplun_t
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|iptr
decl_stmt|,
name|optr
decl_stmt|;
name|optr
operator|=
name|isp
operator|->
name|isp_reqodx
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|isp
operator|->
name|isp_reqidx
expr_stmt|;
name|ip
operator|=
operator|(
name|isplun_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|ISP_NXT_QENTRY
argument_list|(
name|iptr
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptr
operator|==
name|optr
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: Request Queue Overflow in isp_modify_lun\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_ENABLE_LUN
expr_stmt|;
name|ip
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|req_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|req_header
operator|.
name|rqs_seqno
operator|=
name|isp
operator|->
name|isp_seqno
operator|++
expr_stmt|;
name|ip
operator|->
name|req_handle
operator|=
name|RQSTYPE_ENABLE_LUN
expr_stmt|;
name|ip
operator|->
name|req_lun
operator|=
name|lun
expr_stmt|;
name|ip
operator|->
name|req_cmdcount
operator|=
name|ccnt
expr_stmt|;
name|ip
operator|->
name|req_imcount
operator|=
name|icnt
expr_stmt|;
name|ip
operator|->
name|req_timeout
operator|=
literal|0
expr_stmt|;
comment|/* default 30 seconds */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_reqidx
operator|=
name|iptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|isp_parse_status
parameter_list|(
name|isp
parameter_list|,
name|sp
parameter_list|,
name|xs
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
switch|switch
condition|(
name|sp
operator|->
name|req_completion_status
condition|)
block|{
case|case
name|RQCS_COMPLETE
case|:
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_INCOMPLETE
case|:
if|if
condition|(
operator|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_TARGET
operator|)
operator|==
literal|0
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Selection Timeout for target %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: command incomplete for target %d lun %d, state "
literal|"0x%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|sp
operator|->
name|req_state_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DMA_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: DMA error for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_TRANSPORT_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: transport error\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp_prtstst
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_RESET_OCCURRED
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: bus reset destroyed command for target %d "
literal|"lun %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_ABORTED
case|:
name|PRINTF
argument_list|(
literal|"%s: command aborted for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_sendmarker
operator|=
literal|1
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ABORTED
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_TIMEOUT
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: command timed out for target %d lun %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_CMDTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_DATA_OVERRUN
case|:
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
break|break;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_DATAOVR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_COMMAND_OVERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: command overrun for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_STATUS_OVERRUN
case|:
name|PRINTF
argument_list|(
literal|"%s: status overrun for command on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_BAD_MESSAGE
case|:
name|PRINTF
argument_list|(
literal|"%s: message not COMMAND COMPLETE after status on "
literal|"target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_NO_MESSAGE_OUT
case|:
name|PRINTF
argument_list|(
literal|"%s: No MESSAGE OUT phase after selection on "
literal|"target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_EXT_ID_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: EXTENDED IDENTIFY failed on target %d, lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_IDE_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected INITIATOR DETECTED "
literal|"ERROR message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ABORT_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected ABORT message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_REJECT_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected MESSAGE REJECT message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_NOP_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected NOP message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PARITY_ERROR_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected MESSAGE PARITY ERROR "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DEVICE_RESET_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected BUS DEVICE RESET "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ID_MSG_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d rejected IDENTIFY "
literal|"message\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_UNEXP_BUS_FREE
case|:
name|PRINTF
argument_list|(
literal|"%s: target %d lun %d had unexeptected bus free\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_DATA_UNDERRUN
case|:
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|sp
operator|->
name|req_resid
expr_stmt|;
comment|/* an UNDERRUN is not a botch ??? */
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_XACT_ERR1
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction with disconnect "
literal|"not set for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_XACT_ERR2
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction to target "
literal|"routine %d on target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_XACT_ERR3
case|:
name|PRINTF
argument_list|(
literal|"%s: HBA attempted queued transaction for target %d lun "
literal|"%d when queueing disabled\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_BAD_ENTRY
case|:
name|PRINTF
argument_list|(
literal|"%s: invalid IOCB entry type detected\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_QUEUE_FULL
case|:
name|PRINTF
argument_list|(
literal|"%s: internal queues full for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PHASE_SKIPPED
case|:
name|PRINTF
argument_list|(
literal|"%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o "
literal|"STATUS phase) for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_ARQS_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: Auto Request Sense failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_ARQFAIL
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_WIDE_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: Wide Negotiation failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp
operator|->
name|isp_update
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_flags
operator|&=
operator|~
name|DPARM_WIDE
expr_stmt|;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_NOERROR
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_SYNCXFER_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: SDTR Message failed for target %d lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|isp
operator|->
name|isp_update
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_update
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|XS_TGT
argument_list|(
name|xs
argument_list|)
index|]
operator|.
name|dev_flags
operator|&=
operator|~
name|DPARM_SYNC
expr_stmt|;
block|}
break|break;
case|case
name|RQCS_LVD_BUSERR
case|:
name|PRINTF
argument_list|(
literal|"%s: Bad LVD Bus condition while talking to target %d "
literal|"lun %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PORT_UNAVAILABLE
case|:
comment|/* 		 * No such port on the loop. Moral equivalent of SELTIMEO 		 */
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Port Unavailable for target %d\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_PORT_LOGGED_OUT
case|:
comment|/* 		 * It was there (maybe)- treat as a selection timeout. 		 */
name|PRINTF
argument_list|(
literal|"%s: port logout for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_SELTIMEOUT
argument_list|)
expr_stmt|;
return|return;
case|case
name|RQCS_PORT_CHANGED
case|:
name|PRINTF
argument_list|(
literal|"%s: port changed for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQCS_PORT_BUSY
case|:
name|PRINTF
argument_list|(
literal|"%s: port busy for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_TGTBSY
argument_list|)
expr_stmt|;
return|return;
default|default:
name|PRINTF
argument_list|(
literal|"%s: comp status %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|sp
operator|->
name|req_completion_status
argument_list|)
expr_stmt|;
break|break;
block|}
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|HINIB
parameter_list|(
name|x
parameter_list|)
value|((x)>> 0x4)
end_define

begin_define
define|#
directive|define
name|LONIB
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xf)
end_define

begin_define
define|#
directive|define
name|MAKNIB
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<< 4) | (b))
end_define

begin_decl_stmt
specifier|static
name|u_int8_t
name|mbpcnt
index|[]
init|=
block|{
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x00: MBOX_NO_OP */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x01: MBOX_LOAD_RAM */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x02: MBOX_EXEC_FIRMWARE */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x03: MBOX_DUMP_RAM */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x04: MBOX_WRITE_RAM_WORD */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x05: MBOX_READ_RAM_WORD */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x06: MBOX_MAILBOX_REG_TEST */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x07: MBOX_VERIFY_CHECKSUM	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x08: MBOX_ABOUT_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x09: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0d: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x0e: MBOX_CHECK_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x0f: */
name|MAKNIB
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
block|,
comment|/* 0x10: MBOX_INIT_REQ_QUEUE */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x11: MBOX_INIT_RES_QUEUE */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x12: MBOX_EXECUTE_IOCB */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x13: MBOX_WAKE_UP	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x14: MBOX_STOP_FIRMWARE */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x15: MBOX_ABORT */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x16: MBOX_ABORT_DEVICE */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x17: MBOX_ABORT_TARGET */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x18: MBOX_BUS_RESET */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x19: MBOX_STOP_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1a: MBOX_START_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1b: MBOX_SINGLE_STEP_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1c: MBOX_ABORT_QUEUE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x1e: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x1f: MBOX_GET_FIRMWARE_STATUS */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x21: MBOX_GET_SELECT_TIMEOUT */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x22: MBOX_GET_RETRY_COUNT	*/
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x23: MBOX_GET_TAG_AGE_LIMIT */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x24: MBOX_GET_CLOCK_RATE */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x25: MBOX_GET_ACT_NEG_STATE */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x27: MBOX_GET_PCI_PARAMS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x28: MBOX_GET_TARGET_PARAMS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x2f: */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x30: MBOX_SET_INIT_SCSI_ID */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x31: MBOX_SET_SELECT_TIMEOUT */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x32: MBOX_SET_RETRY_COUNT	*/
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x33: MBOX_SET_TAG_AGE_LIMIT */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x34: MBOX_SET_CLOCK_RATE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x35: MBOX_SET_ACTIVE_NEG_STATE */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x38: MBOX_SET_TARGET_PARAMS */
name|MAKNIB
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
block|,
comment|/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x3f: */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */
name|MAKNIB
argument_list|(
literal|6
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
comment|/* 0x42: MBOX_EXEC_BIOS_IOCB */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x43: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x44: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x45: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x46: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x47: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x48: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x49: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x4f: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x50: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x51: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x52: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x53: */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x55: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x56: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x57: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x58: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x59: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5a: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5b: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5c: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5d: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5e: */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x5f: */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|6
argument_list|)
block|,
comment|/* 0x60: MBOX_INIT_FIRMWARE */
name|MAKNIB
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* 0x60: MBOX_GET_INIT_CONTROL_BLOCK  (FORMAT?) */
name|MAKNIB
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x62: MBOX_INIT_LIP */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */
name|MAKNIB
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x64: MBOX_GET_PORT_DB */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x65: MBOX_CLEAR_ACA */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x66: MBOX_TARGET_RESET */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x67: MBOX_CLEAR_TASK_SET */
name|MAKNIB
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 0x69: MBOX_ABORT_TASK_SET */
name|MAKNIB
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
comment|/* 0x69: MBOX_GET_FW_STATE */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMBCOM
value|(sizeof (mbpcnt) / sizeof (mbpcnt[0]))
end_define

begin_function
specifier|static
name|void
name|isp_mboxcmd
parameter_list|(
name|isp
parameter_list|,
name|mbp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|mbreg_t
modifier|*
name|mbp
decl_stmt|;
block|{
name|int
name|outparam
decl_stmt|,
name|inparam
decl_stmt|;
name|int
name|loops
decl_stmt|,
name|dld
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|opcode
decl_stmt|;
if|if
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|==
name|ISP2100_SET_PCI_PARAM
condition|)
block|{
name|opcode
operator|=
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_PCI_PARAMETERS
expr_stmt|;
name|inparam
operator|=
literal|4
expr_stmt|;
name|outparam
operator|=
literal|4
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
elseif|else
if|if
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|>
name|NMBCOM
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: bad command %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcode
operator|=
name|mbp
operator|->
name|param
index|[
literal|0
index|]
expr_stmt|;
name|inparam
operator|=
name|HINIB
argument_list|(
name|mbpcnt
index|[
name|mbp
operator|->
name|param
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|outparam
operator|=
name|LONIB
argument_list|(
name|mbpcnt
index|[
name|mbp
operator|->
name|param
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|inparam
operator|==
literal|0
operator|&&
name|outparam
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: no parameters for %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|command_known
label|:
comment|/* 	 * Make sure we can send some words.. 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
operator|&
name|HCCR_HOST_INT
operator|)
operator|!=
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #1\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dld
operator|++
condition|)
block|{
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: but we'll try again, isr=%x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|1
condition|)
block|{
name|u_int16_t
name|mbox
init|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
decl_stmt|;
if|if
condition|(
name|isp_parse_async
argument_list|(
name|isp
argument_list|,
name|mbox
argument_list|)
condition|)
return|return;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
goto|goto
name|command_known
goto|;
block|}
block|}
comment|/* 	 * Write input parameters 	 */
switch|switch
condition|(
name|inparam
condition|)
block|{
case|case
literal|8
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX7
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|7
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX6
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|6
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX5
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|5
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX4
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|4
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX3
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|3
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX2
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|2
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX1
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
case|case
literal|1
case|:
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|INMAILBOX0
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Clear semaphore on mailbox registers 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Clear RISC int condition. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Set Host Interrupt condition so that RISC will pick up mailbox regs. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_SET_HOST_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until RISC int is set, except 2100 	 */
if|if
condition|(
operator|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
operator|)
operator|==
literal|0
condition|)
block|{
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
operator|&
name|BIU_ISR_RISC_INT
operator|)
operator|==
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #2\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 	 * Check to make sure that the semaphore has been set. 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
operator|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #3\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Make sure that the MBOX_BUSY has gone away 	 */
name|loops
operator|=
name|MBOX_DELAY_COUNT
expr_stmt|;
while|while
condition|(
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
operator|==
name|MBOX_BUSY
condition|)
block|{
name|SYS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|loops
operator|<
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_mboxcmd timeout #4\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Pick up output parameters. 	 */
switch|switch
condition|(
name|outparam
condition|)
block|{
case|case
literal|8
case|:
name|mbp
operator|->
name|param
index|[
literal|7
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX7
argument_list|)
expr_stmt|;
case|case
literal|7
case|:
name|mbp
operator|->
name|param
index|[
literal|6
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX6
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|mbp
operator|->
name|param
index|[
literal|5
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX5
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|mbp
operator|->
name|param
index|[
literal|4
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|mbp
operator|->
name|param
index|[
literal|3
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX3
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|mbp
operator|->
name|param
index|[
literal|2
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|mbp
operator|->
name|param
index|[
literal|1
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear RISC int. 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_CLEAR_RISC_INT
argument_list|)
expr_stmt|;
comment|/* 	 * Release semaphore on mailbox registers 	 */
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Just to be chatty here... 	 */
switch|switch
condition|(
name|mbp
operator|->
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MBOX_COMMAND_COMPLETE
case|:
break|break;
case|case
name|MBOX_INVALID_COMMAND
case|:
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: mbox cmd %x failed with INVALID_COMMAND\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_HOST_INTERFACE_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_TEST_FAILED
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with TEST_FAILED\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with COMMAND_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBOX_COMMAND_PARAM_ERROR
case|:
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with COMMAND_PARAM_ERROR\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASYNC_LOOP_UP
case|:
case|case
name|ASYNC_LIP_OCCURRED
case|:
break|break;
default|default:
comment|/* 		 * The expected return of EXEC_FIRMWARE is zero. 		 */
if|if
condition|(
operator|(
name|opcode
operator|==
name|MBOX_EXEC_FIRMWARE
operator|&&
name|mbp
operator|->
name|param
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|opcode
operator|!=
name|MBOX_EXEC_FIRMWARE
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: mbox cmd %x failed with error %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|opcode
argument_list|,
name|mbp
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
name|isp_lostcmd
parameter_list|(
name|isp
parameter_list|,
name|xs
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FIRMWARE_STATUS
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"couldn't GET FIRMWARE STATUS"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: %d commands on completion queue\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XS_NULL
argument_list|(
name|xs
argument_list|)
condition|)
return|return;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_DEV_QUEUE_STATUS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
operator|(
name|XS_TGT
argument_list|(
name|xs
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|XS_LUN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"couldn't GET DEVICE QUEUE STATUS"
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINTF
argument_list|(
literal|"%s: lost command for target %d lun %d, %d active of %d, "
literal|"Queue State: %x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
argument_list|,
name|mbs
operator|.
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"lost command"
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Need to try and do something to recover. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|isp_dumpregs
parameter_list|(
name|isp
parameter_list|,
name|msg
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|PRINTF
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
name|PRINTF
argument_list|(
literal|"    biu_conf1=%x"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PRINTF
argument_list|(
literal|"    biu_csr=%x"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|" biu_icr=%x biu_isr=%x biu_sema=%x "
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"risc_hccr=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_CONF
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_STATUS
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_FIFO_STS
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_CONF
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_STATUS
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_FIFO_STS
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_INTERRUPT
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_GROSS_ERR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
block|}
name|ISP_DUMPREGS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_dumpxflist
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
specifier|volatile
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hdp
decl_stmt|;
for|for
control|(
name|hdp
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|hdp
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: active requests\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|hdp
operator|++
expr_stmt|;
block|}
name|PRINTF
argument_list|(
literal|" Active Handle %d: tgt %d lun %d dlen %d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|XS_TGT
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_LUN
argument_list|(
name|xs
argument_list|)
argument_list|,
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_fw_state
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|mbreg_t
name|mbs
decl_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|int
name|once
init|=
literal|0
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|again
label|:
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_FW_STATE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|ASYNC_LIP_OCCURRED
operator|||
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|==
name|ASYNC_LOOP_UP
condition|)
block|{
if|if
condition|(
name|once
operator|++
operator|<
literal|2
condition|)
block|{
goto|goto
name|again
goto|;
block|}
block|}
name|isp_dumpregs
argument_list|(
name|isp
argument_list|,
literal|"GET FIRMWARE STATE failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fcp
operator|->
name|isp_fwstate
operator|=
name|mbs
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_update
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|tgt
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdparam
modifier|*
name|sdp
decl_stmt|;
name|isp
operator|->
name|isp_update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
return|return;
block|}
name|sdp
operator|=
name|isp
operator|->
name|isp_param
expr_stmt|;
for|for
control|(
name|tgt
operator|=
literal|0
init|;
name|tgt
operator|<
name|MAX_TARGETS
condition|;
name|tgt
operator|++
control|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_enable
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_SET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|tgt
operator|<<
literal|8
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|=
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_offset
operator|<<
literal|8
operator|)
operator||
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|)
expr_stmt|;
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"\n%s: tgt %d cflags %x offset %x period %x\n"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|tgt
operator|,
name|mbs
operator|.
name|param
index|[
literal|2
index|]
operator|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
operator|,
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: failed to change SCSI parameters for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|wt
decl_stmt|;
name|int
name|x
decl_stmt|,
name|flags
decl_stmt|;
name|flags
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|cur_dflags
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_flags
expr_stmt|;
name|x
operator|=
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|sync_period
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DPARM_SYNC
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|(
name|ISP_20M_SYNCPARMS
operator|&
literal|0xff
operator|)
condition|)
block|{
name|x
operator|=
literal|20
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
operator|(
name|ISP_10M_SYNCPARMS
operator|&
literal|0xff
operator|)
condition|)
block|{
name|x
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
operator|(
name|ISP_08M_SYNCPARMS
operator|&
literal|0xff
operator|)
condition|)
block|{
name|x
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
operator|(
name|ISP_05M_SYNCPARMS
operator|&
literal|0xff
operator|)
condition|)
block|{
name|x
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
operator|(
name|ISP_04M_SYNCPARMS
operator|&
literal|0xff
operator|)
condition|)
block|{
name|x
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|flags
operator|&
operator|(
name|DPARM_WIDE
operator||
name|DPARM_TQING
operator|)
condition|)
block|{
case|case
name|DPARM_WIDE
case|:
name|wt
operator|=
literal|", 16 bit wide\n"
expr_stmt|;
break|break;
case|case
name|DPARM_TQING
case|:
name|wt
operator|=
literal|", Tagged Queueing Enabled\n"
expr_stmt|;
break|break;
case|case
name|DPARM_WIDE
operator||
name|DPARM_TQING
case|:
name|wt
operator|=
literal|", 16 bit wide, Tagged Queueing Enabled\n"
expr_stmt|;
break|break;
default|default:
name|wt
operator|=
literal|"\n"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|x
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Target %d maximum Sync Mode "
literal|"at %dMHz%s"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|tgt
operator|,
name|x
operator|,
name|wt
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: Target %d Async Mode%s"
operator|,
name|isp
operator|->
name|isp_name
operator|,
name|tgt
operator|,
name|wt
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|tgt
index|]
operator|.
name|dev_update
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_setdfltparm
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|use_nvram
decl_stmt|;
name|mbreg_t
name|mbs
decl_stmt|;
name|sdparam
modifier|*
name|sdp
decl_stmt|;
comment|/* 	 * Been there, done that, got the T-shirt... 	 */
if|if
condition|(
name|isp
operator|->
name|isp_gotdparms
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s: already have dparms\n"
operator|,
name|isp
operator|->
name|isp_name
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp
operator|->
name|isp_gotdparms
operator|=
literal|1
expr_stmt|;
name|use_nvram
operator|=
operator|(
name|isp_read_nvram
argument_list|(
name|isp
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|use_nvram
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|fcp
operator|->
name|isp_maxfrmlen
operator|=
name|ICB_DFLT_FRMLEN
expr_stmt|;
name|fcp
operator|->
name|isp_maxalloc
operator|=
literal|256
expr_stmt|;
name|fcp
operator|->
name|isp_execthrottle
operator|=
literal|16
expr_stmt|;
name|fcp
operator|->
name|isp_retry_delay
operator|=
literal|5
expr_stmt|;
name|fcp
operator|->
name|isp_retry_count
operator|=
literal|0
expr_stmt|;
comment|/* 		 * It would be nice to fake up a WWN in case we don't 		 * get one out of NVRAM. Solaris does this for SOCAL 		 * cards that don't have SBus properties- it sets up 		 * a WWN based upon the system MAC Address. 		 */
name|fcp
operator|->
name|isp_wwn
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sdp
operator|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_ACT_NEG_STATE
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|IDPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"could not GET ACT NEG STATE\n"
operator|)
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x1
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
operator|(
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|=
name|MBOX_GET_TARGET_PARAMS
expr_stmt|;
name|mbs
operator|.
name|param
index|[
literal|1
index|]
operator|=
name|i
operator|<<
literal|8
expr_stmt|;
name|isp_mboxcmd
argument_list|(
name|isp
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|.
name|param
index|[
literal|0
index|]
operator|!=
name|MBOX_COMMAND_COMPLETE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: can't get SCSI parameters for target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator|=
name|DPARM_SAFE_DFLT
expr_stmt|;
continue|continue;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator|=
name|mbs
operator|.
name|param
index|[
literal|2
index|]
expr_stmt|;
comment|/* 		 * The maximum period we can really see 		 * here is 100 (decimal), or 400 ns. 		 * For some unknown reason we sometimes 		 * get back wildass numbers from the 		 * boot device's parameters. 		 * 		 * XXX: Hmm- this may be based on a different 		 * XXX: clock rate. 		 */
if|if
condition|(
operator|(
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|<=
literal|0x64
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
name|mbs
operator|.
name|param
index|[
literal|3
index|]
operator|>>
literal|8
expr_stmt|;
block|}
comment|/* 		 * It is not safe to run Ultra Mode with a clock< 60. 		 */
if|if
condition|(
operator|(
operator|(
name|sdp
operator|->
name|isp_clock
operator|&&
name|sdp
operator|->
name|isp_clock
operator|<
literal|60
operator|)
operator|||
operator|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1020A
operator|)
operator|)
operator|&&
operator|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|==
operator|(
name|ISP_20M_SYNCPARMS
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
name|ISP_10M_SYNCPARMS
operator|>>
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
name|ISP_10M_SYNCPARMS
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
comment|/* 	 * Set Default Host Adapter Parameters 	 */
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
literal|1
expr_stmt|;
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_initiator_id
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|>=
name|ISP_HA_SCSI_1040
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|6
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_selection_timeout
operator|=
literal|250
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
literal|128
expr_stmt|;
name|sdp
operator|->
name|isp_tag_aging
operator|=
literal|8
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
literal|3
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
literal|0
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|exc_throttle
operator|=
literal|16
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_enable
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * Re-initialize the ISP and complete all orphaned commands  * with a 'botched' notice.  *  * Locks held prior to coming here.  */
end_comment

begin_function
name|void
name|isp_restart
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|ISP_SCSI_XFER_T
modifier|*
name|tlist
index|[
name|RQUEST_QUEUE_LEN
index|]
decl_stmt|,
modifier|*
name|xs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|tlist
index|[
name|i
index|]
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
expr_stmt|;
block|}
name|isp_reset
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|==
name|ISP_RESETSTATE
condition|)
block|{
name|isp_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|==
name|ISP_INITSTATE
condition|)
block|{
name|isp
operator|->
name|isp_state
operator|=
name|ISP_RUNSTATE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_restart cannot restart ISP\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
name|tlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|XS_NULL
argument_list|(
name|xs
argument_list|)
condition|)
continue|continue;
name|isp
operator|->
name|isp_nactive
operator|--
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_nactive
operator|<
literal|0
condition|)
name|isp
operator|->
name|isp_nactive
operator|=
literal|0
expr_stmt|;
name|XS_RESID
argument_list|(
name|xs
argument_list|)
operator|=
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BUSRESET
argument_list|)
expr_stmt|;
name|XS_CMD_DONE
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|isp_watch
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
name|arg
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|ISP_LOCKVAL_DECL
expr_stmt|;
comment|/* 	 * Look for completely dead commands (but not polled ones). 	 */
name|ISP_ILOCK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQUEST_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|xs
operator|=
operator|(
name|ISP_SCSI_XFER_T
operator|*
operator|)
name|isp
operator|->
name|isp_xflist
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|-=
operator|(
name|WATCH_INTERVAL
operator|*
literal|1000
operator|)
expr_stmt|;
comment|/* 		 * Avoid later thinking that this 		 * transaction is not being timed. 		 * Then give ourselves to watchdog 		 * periods of grace. 		 */
if|if
condition|(
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|==
literal|0
condition|)
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XS_TIME
argument_list|(
name|xs
argument_list|)
operator|>
operator|-
operator|(
literal|2
operator|*
name|WATCH_INTERVAL
operator|*
literal|1000
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|isp_control
argument_list|(
name|isp
argument_list|,
name|ISPCTL_ABORT_CMD
argument_list|,
name|xs
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: isp_watch failed to abort command\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|isp_restart
argument_list|(
name|isp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ISP_IUNLOCK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|RESTART_WATCHDOG
argument_list|(
name|isp_watch
argument_list|,
name|isp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_prtstst
parameter_list|(
name|sp
parameter_list|)
name|ispstatusreq_t
modifier|*
name|sp
decl_stmt|;
block|{
name|PRINTF
argument_list|(
literal|"states->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_BUS
condition|)
name|PRINTF
argument_list|(
literal|"GOT_BUS "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_TARGET
condition|)
name|PRINTF
argument_list|(
literal|"GOT_TGT "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_SENT_CDB
condition|)
name|PRINTF
argument_list|(
literal|"SENT_CDB "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_XFRD_DATA
condition|)
name|PRINTF
argument_list|(
literal|"XFRD_DATA "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_STATUS
condition|)
name|PRINTF
argument_list|(
literal|"GOT_STS "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_GOT_SENSE
condition|)
name|PRINTF
argument_list|(
literal|"GOT_SNS "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_state_flags
operator|&
name|RQSF_XFER_COMPLETE
condition|)
name|PRINTF
argument_list|(
literal|"XFR_CMPLT "
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"status->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_DISCONNECT
condition|)
name|PRINTF
argument_list|(
literal|"Disconnect "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_SYNCHRONOUS
condition|)
name|PRINTF
argument_list|(
literal|"Sync_xfr "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_PARITY_ERROR
condition|)
name|PRINTF
argument_list|(
literal|"Parity "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_BUS_RESET
condition|)
name|PRINTF
argument_list|(
literal|"Bus_Reset "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_DEVICE_RESET
condition|)
name|PRINTF
argument_list|(
literal|"Device_Reset "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_ABORTED
condition|)
name|PRINTF
argument_list|(
literal|"Aborted "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_TIMEOUT
condition|)
name|PRINTF
argument_list|(
literal|"Timeout "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req_status_flags
operator|&
name|RQSTF_NEGOTIATION
condition|)
name|PRINTF
argument_list|(
literal|"Negotiation "
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NVRAM Routines  */
end_comment

begin_function
specifier|static
name|int
name|isp_read_nvram
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|amt
decl_stmt|;
name|u_int8_t
name|csum
decl_stmt|,
name|minversion
decl_stmt|;
union|union
block|{
name|u_int8_t
name|_x
index|[
name|ISP2100_NVRAM_SIZE
index|]
decl_stmt|;
name|u_int16_t
name|_s
index|[
name|ISP2100_NVRAM_SIZE
operator|>>
literal|1
index|]
expr_stmt|;
block|}
name|_n
union|;
define|#
directive|define
name|nvram_data
value|_n._x
define|#
directive|define
name|nvram_words
value|_n._s
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|amt
operator|=
name|ISP2100_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|amt
operator|=
name|ISP_NVRAM_SIZE
expr_stmt|;
name|minversion
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Just read the first two words first to see if we have a valid 	 * NVRAM to continue reading the rest with. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|isp_rdnvram_word
argument_list|(
name|isp
argument_list|,
name|i
argument_list|,
operator|&
name|nvram_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvram_data
index|[
literal|0
index|]
operator|!=
literal|'I'
operator|||
name|nvram_data
index|[
literal|1
index|]
operator|!=
literal|'S'
operator|||
name|nvram_data
index|[
literal|2
index|]
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_bustype
operator|!=
name|ISP_BT_SBUS
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: invalid NVRAM header\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|amt
operator|>>
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|isp_rdnvram_word
argument_list|(
name|isp
argument_list|,
name|i
argument_list|,
operator|&
name|nvram_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|amt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|nvram_data
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|csum
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: invalid NVRAM checksum\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ISP_NVRAM_VERSION
argument_list|(
name|nvram_data
argument_list|)
operator|<
name|minversion
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: version %d NVRAM not understood\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|ISP_NVRAM_VERSION
argument_list|(
name|nvram_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
block|{
name|sdparam
modifier|*
name|sdp
init|=
operator|(
name|sdparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
comment|/* XXX CHECK THIS FOR SANITY XXX */
name|sdp
operator|->
name|isp_fifo_threshold
operator|=
name|ISP_NVRAM_FIFO_THRESHOLD
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_initiator_id
operator|=
name|ISP_NVRAM_INITIATOR_ID
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_bus_reset_delay
operator|=
name|ISP_NVRAM_BUS_RESET_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_count
operator|=
name|ISP_NVRAM_BUS_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_retry_delay
operator|=
name|ISP_NVRAM_BUS_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_async_data_setup
operator|=
name|ISP_NVRAM_ASYNC_DATA_SETUP_TIME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|>=
name|ISP_HA_SCSI_1040
condition|)
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_async_data_setup
operator|<
literal|9
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|9
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_async_data_setup
operator|!=
literal|6
condition|)
block|{
name|sdp
operator|->
name|isp_async_data_setup
operator|=
literal|6
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_req_ack_active_neg
operator|=
name|ISP_NVRAM_REQ_ACK_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_line_active_neg
operator|=
name|ISP_NVRAM_DATA_LINE_ACTIVE_NEGATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_data_dma_burst_enabl
operator|=
name|ISP_NVRAM_DATA_DMA_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_cmd_dma_burst_enable
operator|=
name|ISP_NVRAM_CMD_DMA_BURST_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_tag_aging
operator|=
name|ISP_NVRAM_TAG_AGE_LIMIT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
comment|/* XXX ISP_NVRAM_FIFO_THRESHOLD_128 XXX */
name|sdp
operator|->
name|isp_selection_timeout
operator|=
name|ISP_NVRAM_SELECTION_TIMEOUT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_max_queue_depth
operator|=
name|ISP_NVRAM_MAX_QUEUE_DEPTH
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_fast_mttr
operator|=
name|ISP_NVRAM_FAST_MTTR_ENABLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_enable
operator|=
name|ISP_NVRAM_TGT_DEVICE_ENABLE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|exc_throttle
operator|=
name|ISP_NVRAM_TGT_EXEC_THROTTLE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
name|ISP_NVRAM_TGT_SYNC_OFFSET
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
name|ISP_NVRAM_TGT_SYNC_PERIOD
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|<
name|ISP_HA_SCSI_1040
condition|)
block|{
comment|/* 				 * If we're not ultra, we can't possibly 				 * be a shorter period than this. 				 */
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|<
literal|0x19
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_period
operator|=
literal|0x19
expr_stmt|;
block|}
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|>
literal|0xc
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
literal|0x0c
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|>
literal|0x8
condition|)
block|{
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|sync_offset
operator|=
literal|0x8
expr_stmt|;
block|}
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_RENEG
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_RENEG
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_QFRZ
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: not supporting QFRZ option for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_ARQ
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_ARQ
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: not disabling ARQ option for "
literal|"target %d\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISP_NVRAM_TGT_TQING
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_TQING
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_SYNC
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_SYNC
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_WIDE
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_WIDE
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_PARITY
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_PARITY
expr_stmt|;
if|if
condition|(
name|ISP_NVRAM_TGT_DISC
argument_list|(
name|nvram_data
argument_list|,
name|i
argument_list|)
condition|)
name|sdp
operator|->
name|isp_devparam
index|[
name|i
index|]
operator|.
name|dev_flags
operator||=
name|DPARM_DISC
expr_stmt|;
block|}
block|}
else|else
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
union|union
block|{
struct|struct
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|u_int32_t
name|hi32
decl_stmt|;
name|u_int32_t
name|lo32
decl_stmt|;
else|#
directive|else
name|u_int32_t
name|lo32
decl_stmt|;
name|u_int32_t
name|hi32
decl_stmt|;
endif|#
directive|endif
block|}
name|wds
struct|;
name|u_int64_t
name|full64
decl_stmt|;
block|}
name|wwnstore
union|;
name|wwnstore
operator|.
name|full64
operator|=
name|ISP2100_NVRAM_NODE_NAME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%s: Adapter WWN 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|wwnstore
operator|.
name|wds
operator|.
name|hi32
argument_list|,
name|wwnstore
operator|.
name|wds
operator|.
name|lo32
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_wwn
operator|=
name|wwnstore
operator|.
name|full64
expr_stmt|;
name|wwnstore
operator|.
name|full64
operator|=
name|ISP2100_NVRAM_BOOT_NODE_NAME
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|wwnstore
operator|.
name|full64
operator|!=
literal|0
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%s: BOOT DEVICE WWN 0x%08x%08x\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|wwnstore
operator|.
name|wds
operator|.
name|hi32
argument_list|,
name|wwnstore
operator|.
name|wds
operator|.
name|lo32
argument_list|)
expr_stmt|;
block|}
name|fcp
operator|->
name|isp_maxalloc
operator|=
name|ISP2100_NVRAM_MAXIOCBALLOCATION
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_maxfrmlen
operator|=
name|ISP2100_NVRAM_MAXFRAMELENGTH
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_delay
operator|=
name|ISP2100_NVRAM_RETRY_DELAY
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_retry_count
operator|=
name|ISP2100_NVRAM_RETRY_COUNT
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_loopid
operator|=
name|ISP2100_NVRAM_HARDLOOPID
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
name|fcp
operator|->
name|isp_execthrottle
operator|=
name|ISP2100_NVRAM_EXECUTION_THROTTLE
argument_list|(
name|nvram_data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_rdnvram_word
parameter_list|(
name|isp
parameter_list|,
name|wo
parameter_list|,
name|rp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|wo
decl_stmt|;
name|u_int16_t
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|cbits
decl_stmt|;
name|u_int16_t
name|bit
decl_stmt|,
name|rqst
decl_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP2100_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|8
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|wo
operator|&=
operator|(
operator|(
name|ISP_NVRAM_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rqst
operator|=
operator|(
name|ISP_NVRAM_READ
operator|<<
literal|6
operator|)
operator||
name|wo
expr_stmt|;
name|cbits
operator|=
literal|8
expr_stmt|;
block|}
comment|/* 	 * Clock the word select request out... 	 */
for|for
control|(
name|i
operator|=
name|cbits
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|rqst
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|bit
operator|=
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_DATAOUT
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
name|BIU_NVRAM_SELECT
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now read the result back in (bits come back in MSB format). 	 */
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|u_int16_t
name|rv
decl_stmt|;
operator|*
name|rp
operator|<<=
literal|1
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
operator||
name|BIU_NVRAM_CLOCK
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&
name|BIU_NVRAM_DATAIN
condition|)
block|{
operator|*
name|rp
operator||=
literal|1
expr_stmt|;
block|}
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
name|BIU_NVRAM_SELECT
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|BIU_NVRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SYS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|*
name|rp
operator|=
operator|(
operator|(
operator|*
name|rp
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
name|rp
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

