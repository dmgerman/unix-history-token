begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$OpenBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2002 Jason L. Wright (jason@thought.net)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jason L. Wright  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/rndtest/rndtest.h>
end_include

begin_function_decl
specifier|static
name|void
name|rndtest_test
parameter_list|(
name|struct
name|rndtest_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rndtest_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The tests themselves */
end_comment

begin_function_decl
specifier|static
name|int
name|rndtest_monobit
parameter_list|(
name|struct
name|rndtest_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rndtest_runs
parameter_list|(
name|struct
name|rndtest_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rndtest_longruns
parameter_list|(
name|struct
name|rndtest_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rndtest_chi_4
parameter_list|(
name|struct
name|rndtest_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rndtest_runs_check
parameter_list|(
name|struct
name|rndtest_state
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rndtest_runs_record
parameter_list|(
name|struct
name|rndtest_state
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
specifier|const
struct|struct
name|rndtest_testfunc
block|{
name|int
function_decl|(
modifier|*
name|test
function_decl|)
parameter_list|(
name|struct
name|rndtest_state
modifier|*
parameter_list|)
function_decl|;
block|}
name|rndtest_funcs
index|[]
init|=
block|{
block|{
name|rndtest_monobit
block|}
block|,
block|{
name|rndtest_runs
block|}
block|,
block|{
name|rndtest_chi_4
block|}
block|,
block|{
name|rndtest_longruns
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|RNDTEST_NTESTS
value|(sizeof(rndtest_funcs)/sizeof(rndtest_funcs[0]))
end_define

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|rndtest
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"RNG test parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|rndtest_retest
init|=
literal|120
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interval in seconds */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_rndtest
argument_list|,
name|OID_AUTO
argument_list|,
name|retest
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rndtest_retest
argument_list|,
literal|0
argument_list|,
literal|"retest interval (seconds)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|rndtest_stats
name|rndstats
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_kern_rndtest
argument_list|,
name|OID_AUTO
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rndstats
argument_list|,
name|rndtest_stats
argument_list|,
literal|"RNG test statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|rndtest_verbose
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report only failures */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_rndtest
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rndtest_verbose
argument_list|,
literal|0
argument_list|,
literal|"display results on console"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|struct
name|rndtest_state
modifier|*
name|rndtest_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|rndtest_state
modifier|*
name|rsp
decl_stmt|;
name|rsp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rsp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|!=
name|NULL
condition|)
block|{
name|rsp
operator|->
name|rs_begin
operator|=
name|rsp
operator|->
name|rs_buf
expr_stmt|;
name|rsp
operator|->
name|rs_end
operator|=
name|rsp
operator|->
name|rs_buf
operator|+
sizeof|sizeof
argument_list|(
name|rsp
operator|->
name|rs_buf
argument_list|)
expr_stmt|;
name|rsp
operator|->
name|rs_current
operator|=
name|rsp
operator|->
name|rs_begin
expr_stmt|;
name|rsp
operator|->
name|rs_discard
operator|=
literal|1
expr_stmt|;
name|rsp
operator|->
name|rs_collect
operator|=
literal|1
expr_stmt|;
name|rsp
operator|->
name|rs_parent
operator|=
name|dev
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|callout_init
argument_list|(
operator|&
name|rsp
operator|->
name|rs_to
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_init
argument_list|(
operator|&
name|rsp
operator|->
name|rs_to
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"rndtest_init: no memory for state block\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rsp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rndtest_detach
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|)
block|{
name|callout_stop
argument_list|(
operator|&
name|rsp
operator|->
name|rs_to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rsp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rndtest_harvest
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* 	 * If enabled, collect data and run tests when we have enough. 	 */
if|if
condition|(
name|rsp
operator|->
name|rs_collect
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rsp
operator|->
name|rs_current
operator|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|rsp
operator|->
name|rs_current
operator|==
name|rsp
operator|->
name|rs_end
condition|)
block|{
name|rndtest_test
argument_list|(
name|rsp
argument_list|)
expr_stmt|;
name|rsp
operator|->
name|rs_current
operator|=
name|rsp
operator|->
name|rs_begin
expr_stmt|;
comment|/* 				 * If tests passed, turn off collection and 				 * schedule another test. Otherwise we keep 				 * testing until the data looks ok. 				 */
if|if
condition|(
operator|!
name|rsp
operator|->
name|rs_discard
operator|&&
name|rndtest_retest
operator|!=
literal|0
condition|)
block|{
name|rsp
operator|->
name|rs_collect
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|rsp
operator|->
name|rs_to
argument_list|,
name|hz
operator|*
name|rndtest_retest
argument_list|,
name|rndtest_timeout
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* 	 * Only stir entropy that passes muster into the pool. 	 */
if|if
condition|(
name|rsp
operator|->
name|rs_discard
condition|)
name|rndstats
operator|.
name|rst_discard
operator|+=
name|len
expr_stmt|;
else|else
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
comment|/* XXX verify buffer is word aligned */
name|u_int32_t
modifier|*
name|p
init|=
name|buf
decl_stmt|;
for|for
control|(
name|len
operator|/=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
init|;
name|len
condition|;
name|len
operator|--
control|)
name|add_true_randomness
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
else|#
directive|else
name|random_harvest
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|len
operator|*
name|NBBY
argument_list|,
literal|0
argument_list|,
name|RANDOM_PURE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rndtest_test
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
name|rndstats
operator|.
name|rst_tests
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RNDTEST_NTESTS
condition|;
name|i
operator|++
control|)
name|rv
operator||=
operator|(
operator|*
name|rndtest_funcs
index|[
name|i
index|]
operator|.
name|test
operator|)
operator|(
name|rsp
operator|)
expr_stmt|;
name|rsp
operator|->
name|rs_discard
operator|=
operator|(
name|rv
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rndtest_report
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|,
name|int
name|failure
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|rndtest_verbose
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|failure
operator|&&
name|rndtest_verbose
operator|==
literal|1
condition|)
comment|/* don't report successes */
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|rsp
operator|->
name|rs_parent
argument_list|,
literal|"rndtest: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RNDTEST_MONOBIT_MINONES
value|9725
end_define

begin_define
define|#
directive|define
name|RNDTEST_MONOBIT_MAXONES
value|10275
end_define

begin_function
specifier|static
name|int
name|rndtest_monobit
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ones
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|u_int8_t
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RNDTEST_NBYTES
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|rsp
operator|->
name|rs_buf
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
operator|,
name|r
operator|<<=
literal|1
control|)
if|if
condition|(
name|r
operator|&
literal|0x80
condition|)
name|ones
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ones
operator|>
name|RNDTEST_MONOBIT_MINONES
operator|&&
name|ones
operator|<
name|RNDTEST_MONOBIT_MAXONES
condition|)
block|{
if|if
condition|(
name|rndtest_verbose
operator|>
literal|1
condition|)
name|rndtest_report
argument_list|(
name|rsp
argument_list|,
literal|0
argument_list|,
literal|"monobit pass (%d< %d< %d)"
argument_list|,
name|RNDTEST_MONOBIT_MINONES
argument_list|,
name|ones
argument_list|,
name|RNDTEST_MONOBIT_MAXONES
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|rndtest_verbose
condition|)
name|rndtest_report
argument_list|(
name|rsp
argument_list|,
literal|1
argument_list|,
literal|"monobit failed (%d ones)"
argument_list|,
name|ones
argument_list|)
expr_stmt|;
name|rndstats
operator|.
name|rst_monobit
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|RNDTEST_RUNS_NINTERVAL
value|6
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|rndtest_runs_tabs
block|{
name|u_int16_t
name|min
decl_stmt|,
name|max
decl_stmt|;
block|}
name|rndtest_runs_tab
index|[]
init|=
block|{
block|{
literal|2343
block|,
literal|2657
block|}
block|,
block|{
literal|1135
block|,
literal|1365
block|}
block|,
block|{
literal|542
block|,
literal|708
block|}
block|,
block|{
literal|251
block|,
literal|373
block|}
block|,
block|{
literal|111
block|,
literal|201
block|}
block|,
block|{
literal|111
block|,
literal|201
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|rndtest_runs
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ones
decl_stmt|,
name|zeros
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|onei
index|[
name|RNDTEST_RUNS_NINTERVAL
index|]
decl_stmt|,
name|zeroi
index|[
name|RNDTEST_RUNS_NINTERVAL
index|]
decl_stmt|;
name|u_int8_t
name|c
decl_stmt|;
name|bzero
argument_list|(
name|onei
argument_list|,
sizeof|sizeof
argument_list|(
name|onei
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zeroi
argument_list|,
sizeof|sizeof
argument_list|(
name|zeroi
argument_list|)
argument_list|)
expr_stmt|;
name|ones
operator|=
name|zeros
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RNDTEST_NBYTES
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|rsp
operator|->
name|rs_buf
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
operator|,
name|c
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
name|ones
operator|++
expr_stmt|;
name|rndtest_runs_record
argument_list|(
name|rsp
argument_list|,
name|zeros
argument_list|,
name|zeroi
argument_list|)
expr_stmt|;
name|zeros
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|zeros
operator|++
expr_stmt|;
name|rndtest_runs_record
argument_list|(
name|rsp
argument_list|,
name|ones
argument_list|,
name|onei
argument_list|)
expr_stmt|;
name|ones
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|rndtest_runs_record
argument_list|(
name|rsp
argument_list|,
name|ones
argument_list|,
name|onei
argument_list|)
expr_stmt|;
name|rndtest_runs_record
argument_list|(
name|rsp
argument_list|,
name|zeros
argument_list|,
name|zeroi
argument_list|)
expr_stmt|;
name|rv
operator||=
name|rndtest_runs_check
argument_list|(
name|rsp
argument_list|,
literal|0
argument_list|,
name|zeroi
argument_list|)
expr_stmt|;
name|rv
operator||=
name|rndtest_runs_check
argument_list|(
name|rsp
argument_list|,
literal|1
argument_list|,
name|onei
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
name|rndstats
operator|.
name|rst_runs
operator|++
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rndtest_runs_record
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|intrv
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|len
operator|>
name|RNDTEST_RUNS_NINTERVAL
condition|)
name|len
operator|=
name|RNDTEST_RUNS_NINTERVAL
expr_stmt|;
name|len
operator|-=
literal|1
expr_stmt|;
name|intrv
index|[
name|len
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rndtest_runs_check
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|,
name|int
name|val
parameter_list|,
name|int
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RNDTEST_RUNS_NINTERVAL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|src
index|[
name|i
index|]
operator|<
name|rndtest_runs_tab
index|[
name|i
index|]
operator|.
name|min
operator|||
name|src
index|[
name|i
index|]
operator|>
name|rndtest_runs_tab
index|[
name|i
index|]
operator|.
name|max
condition|)
block|{
name|rndtest_report
argument_list|(
name|rsp
argument_list|,
literal|1
argument_list|,
literal|"%s interval %d failed (%d, %d-%d)"
argument_list|,
name|val
condition|?
literal|"ones"
else|:
literal|"zeros"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|src
index|[
name|i
index|]
argument_list|,
name|rndtest_runs_tab
index|[
name|i
index|]
operator|.
name|min
argument_list|,
name|rndtest_runs_tab
index|[
name|i
index|]
operator|.
name|max
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rndtest_report
argument_list|(
name|rsp
argument_list|,
literal|0
argument_list|,
literal|"runs pass %s interval %d (%d< %d< %d)"
argument_list|,
name|val
condition|?
literal|"ones"
else|:
literal|"zeros"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|rndtest_runs_tab
index|[
name|i
index|]
operator|.
name|min
argument_list|,
name|src
index|[
name|i
index|]
argument_list|,
name|rndtest_runs_tab
index|[
name|i
index|]
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rndtest_longruns
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ones
init|=
literal|0
decl_stmt|,
name|zeros
init|=
literal|0
decl_stmt|,
name|maxones
init|=
literal|0
decl_stmt|,
name|maxzeros
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RNDTEST_NBYTES
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|rsp
operator|->
name|rs_buf
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
operator|,
name|c
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
name|zeros
operator|=
literal|0
expr_stmt|;
name|ones
operator|++
expr_stmt|;
if|if
condition|(
name|ones
operator|>
name|maxones
condition|)
name|maxones
operator|=
name|ones
expr_stmt|;
block|}
else|else
block|{
name|ones
operator|=
literal|0
expr_stmt|;
name|zeros
operator|++
expr_stmt|;
if|if
condition|(
name|zeros
operator|>
name|maxzeros
condition|)
name|maxzeros
operator|=
name|zeros
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|maxones
operator|<
literal|26
operator|&&
name|maxzeros
operator|<
literal|26
condition|)
block|{
name|rndtest_report
argument_list|(
name|rsp
argument_list|,
literal|0
argument_list|,
literal|"longruns pass (%d ones, %d zeros)"
argument_list|,
name|maxones
argument_list|,
name|maxzeros
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|rndtest_report
argument_list|(
name|rsp
argument_list|,
literal|1
argument_list|,
literal|"longruns fail (%d ones, %d zeros)"
argument_list|,
name|maxones
argument_list|,
name|maxzeros
argument_list|)
expr_stmt|;
name|rndstats
operator|.
name|rst_longruns
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * chi^2 test over 4 bits: (this is called the poker test in FIPS 140-2,  * but it is really the chi^2 test over 4 bits (the poker test as described  * by Knuth vol 2 is something different, and I take him as authoritative  * on nomenclature over NIST).  */
end_comment

begin_define
define|#
directive|define
name|RNDTEST_CHI4_K
value|16
end_define

begin_define
define|#
directive|define
name|RNDTEST_CHI4_K_MASK
value|(RNDTEST_CHI4_K - 1)
end_define

begin_comment
comment|/*  * The unnormalized values are used so that we don't have to worry about  * fractional precision.  The "real" value is found by:  *	(V - 1562500) * (16 / 5000) = Vn   (where V is the unnormalized value)  */
end_comment

begin_define
define|#
directive|define
name|RNDTEST_CHI4_VMIN
value|1563181
end_define

begin_comment
comment|/* 2.1792 */
end_comment

begin_define
define|#
directive|define
name|RNDTEST_CHI4_VMAX
value|1576929
end_define

begin_comment
comment|/* 46.1728 */
end_comment

begin_function
specifier|static
name|int
name|rndtest_chi_4
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|)
block|{
name|unsigned
name|int
name|freq
index|[
name|RNDTEST_CHI4_K
index|]
decl_stmt|,
name|i
decl_stmt|,
name|sum
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RNDTEST_CHI4_K
condition|;
name|i
operator|++
control|)
name|freq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Get number of occurances of each 4 bit pattern */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RNDTEST_NBYTES
condition|;
name|i
operator|++
control|)
block|{
name|freq
index|[
operator|(
name|rsp
operator|->
name|rs_buf
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
name|RNDTEST_CHI4_K_MASK
index|]
operator|++
expr_stmt|;
name|freq
index|[
operator|(
name|rsp
operator|->
name|rs_buf
index|[
name|i
index|]
operator|>>
literal|0
operator|)
operator|&
name|RNDTEST_CHI4_K_MASK
index|]
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sum
operator|=
literal|0
init|;
name|i
operator|<
name|RNDTEST_CHI4_K
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|freq
index|[
name|i
index|]
operator|*
name|freq
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|>=
literal|1563181
operator|&&
name|sum
operator|<=
literal|1576929
condition|)
block|{
name|rndtest_report
argument_list|(
name|rsp
argument_list|,
literal|0
argument_list|,
literal|"chi^2(4): pass (sum %u)"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|rndtest_report
argument_list|(
name|rsp
argument_list|,
literal|1
argument_list|,
literal|"chi^2(4): failed (sum %u)"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|rndstats
operator|.
name|rst_chi
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rndtest_timeout
parameter_list|(
name|void
modifier|*
name|xrsp
parameter_list|)
block|{
name|struct
name|rndtest_state
modifier|*
name|rsp
init|=
name|xrsp
decl_stmt|;
name|rsp
operator|->
name|rs_collect
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rndtest_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
return|return
literal|0
return|;
case|case
name|MOD_UNLOAD
case|:
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|rndtest_mod
init|=
block|{
literal|"rndtest"
block|,
name|rndtest_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|rndtest
argument_list|,
name|rndtest_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|rndtest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

