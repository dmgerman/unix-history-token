begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006-2010 Broadcom Corporation  *	David Christensen<davidch@broadcom.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of Broadcom Corporation nor the name of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written consent.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The following controllers are supported by this driver:  *   BCM5706C A2, A3  *   BCM5706S A2, A3  *   BCM5708C B1, B2  *   BCM5708S B1, B2  *   BCM5709C A1, C0  *   BCM5709S A1, C0  *   BCM5716C C0  *   BCM5716S C0  *  * The following controllers are not supported by this driver:  *   BCM5706C A0, A1 (pre-production)  *   BCM5706S A0, A1 (pre-production)  *   BCM5708C A0, B0 (pre-production)  *   BCM5708S A0, B0 (pre-production)  *   BCM5709C A0  B0, B1, B2 (pre-production)  *   BCM5709S A0, B0, B1, B2 (pre-production)  */
end_comment

begin_include
include|#
directive|include
file|"opt_bce.h"
end_include

begin_include
include|#
directive|include
file|<dev/bce/if_bcereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bce/if_bcefw.h>
end_include

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Debug Options                                                        */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_decl_stmt
name|u32
name|bce_debug
init|=
name|BCE_WARN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*          0 = Never              */
end_comment

begin_comment
comment|/*          1 = 1 in 2,147,483,648 */
end_comment

begin_comment
comment|/*        256 = 1 in     8,388,608 */
end_comment

begin_comment
comment|/*       2048 = 1 in     1,048,576 */
end_comment

begin_comment
comment|/*      65536 = 1 in        32,768 */
end_comment

begin_comment
comment|/*    1048576 = 1 in         2,048 */
end_comment

begin_comment
comment|/*  268435456 =	1 in             8 */
end_comment

begin_comment
comment|/*  536870912 = 1 in             4 */
end_comment

begin_comment
comment|/* 1073741824 = 1 in             2 */
end_comment

begin_comment
comment|/* Controls how often the l2_fhdr frame error check will fail. */
end_comment

begin_decl_stmt
name|int
name|l2fhdr_error_sim_control
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often the unexpected attention check will fail. */
end_comment

begin_decl_stmt
name|int
name|unexpected_attention_sim_control
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often to simulate an mbuf allocation failure. */
end_comment

begin_decl_stmt
name|int
name|mbuf_alloc_failed_sim_control
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often to simulate a DMA mapping failure. */
end_comment

begin_decl_stmt
name|int
name|dma_map_addr_failed_sim_control
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often to simulate a bootcode failure. */
end_comment

begin_decl_stmt
name|int
name|bootcode_running_failure_sim_control
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Build Time Options                                                   */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* #define BCE_NVRAM_WRITE_SUPPORT 1 */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* PCI Device ID Table                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Used by bce_probe() to identify the devices supported by this driver.    */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|BCE_DEVDESC_MAX
value|64
end_define

begin_decl_stmt
specifier|static
name|struct
name|bce_type
name|bce_devs
index|[]
init|=
block|{
comment|/* BCM5706C Controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706
block|,
name|HP_VENDORID
block|,
literal|0x3101
block|,
literal|"HP NC370T Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706
block|,
name|HP_VENDORID
block|,
literal|0x3106
block|,
literal|"HP NC370i Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706
block|,
name|HP_VENDORID
block|,
literal|0x3070
block|,
literal|"HP NC380T PCIe DP Multifunc Gig Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706
block|,
name|HP_VENDORID
block|,
literal|0x1709
block|,
literal|"HP NC371i Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5706 1000Base-T"
block|}
block|,
comment|/* BCM5706S controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706S
block|,
name|HP_VENDORID
block|,
literal|0x3102
block|,
literal|"HP NC370F Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706S
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5706 1000Base-SX"
block|}
block|,
comment|/* BCM5708C controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708
block|,
name|HP_VENDORID
block|,
literal|0x7037
block|,
literal|"HP NC373T PCIe Multifunction Gig Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708
block|,
name|HP_VENDORID
block|,
literal|0x7038
block|,
literal|"HP NC373i Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708
block|,
name|HP_VENDORID
block|,
literal|0x7045
block|,
literal|"HP NC374m PCIe Multifunction Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5708 1000Base-T"
block|}
block|,
comment|/* BCM5708S controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708S
block|,
name|HP_VENDORID
block|,
literal|0x1706
block|,
literal|"HP NC373m Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708S
block|,
name|HP_VENDORID
block|,
literal|0x703b
block|,
literal|"HP NC373i Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708S
block|,
name|HP_VENDORID
block|,
literal|0x703d
block|,
literal|"HP NC373F PCIe Multifunc Giga Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708S
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5708 1000Base-SX"
block|}
block|,
comment|/* BCM5709C controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5709
block|,
name|HP_VENDORID
block|,
literal|0x7055
block|,
literal|"HP NC382i DP Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5709
block|,
name|HP_VENDORID
block|,
literal|0x7059
block|,
literal|"HP NC382T PCIe DP Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5709
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5709 1000Base-T"
block|}
block|,
comment|/* BCM5709S controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5709S
block|,
name|HP_VENDORID
block|,
literal|0x171d
block|,
literal|"HP NC382m DP 1GbE Multifunction BL-c Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5709S
block|,
name|HP_VENDORID
block|,
literal|0x7056
block|,
literal|"HP NC382i DP Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5709S
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5709 1000Base-SX"
block|}
block|,
comment|/* BCM5716 controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5716
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5716 1000Base-T"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Supported Flash NVRAM device data.                                       */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|flash_spec
name|flash_table
index|[]
init|=
block|{
define|#
directive|define
name|BUFFERED_FLAGS
value|(BCE_NV_BUFFERED | BCE_NV_TRANSLATE)
define|#
directive|define
name|NONBUFFERED_FLAGS
value|(BCE_NV_WREN)
comment|/* Slow EEPROM */
block|{
literal|0x00000000
block|,
literal|0x40830380
block|,
literal|0x009f0081
block|,
literal|0xa184a053
block|,
literal|0xaf000400
block|,
name|BUFFERED_FLAGS
block|,
name|SEEPROM_PAGE_BITS
block|,
name|SEEPROM_PAGE_SIZE
block|,
name|SEEPROM_BYTE_ADDR_MASK
block|,
name|SEEPROM_TOTAL_SIZE
block|,
literal|"EEPROM - slow"
block|}
block|,
comment|/* Expansion entry 0001 */
block|{
literal|0x08000002
block|,
literal|0x4b808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 0001"
block|}
block|,
comment|/* Saifun SA25F010 (non-buffered flash) */
comment|/* strap, cfg1,& write1 need updates */
block|{
literal|0x04000001
block|,
literal|0x47808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
name|SAIFUN_FLASH_BASE_TOTAL_SIZE
operator|*
literal|2
block|,
literal|"Non-buffered flash (128kB)"
block|}
block|,
comment|/* Saifun SA25F020 (non-buffered flash) */
comment|/* strap, cfg1,& write1 need updates */
block|{
literal|0x0c000003
block|,
literal|0x4f808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
name|SAIFUN_FLASH_BASE_TOTAL_SIZE
operator|*
literal|4
block|,
literal|"Non-buffered flash (256kB)"
block|}
block|,
comment|/* Expansion entry 0100 */
block|{
literal|0x11000000
block|,
literal|0x53808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 0100"
block|}
block|,
comment|/* Entry 0101: ST M45PE10 (non-buffered flash, TetonII B0) */
block|{
literal|0x19000002
block|,
literal|0x5b808201
block|,
literal|0x000500db
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|ST_MICRO_FLASH_PAGE_BITS
block|,
name|ST_MICRO_FLASH_PAGE_SIZE
block|,
name|ST_MICRO_FLASH_BYTE_ADDR_MASK
block|,
name|ST_MICRO_FLASH_BASE_TOTAL_SIZE
operator|*
literal|2
block|,
literal|"Entry 0101: ST M45PE10 (128kB non-bufferred)"
block|}
block|,
comment|/* Entry 0110: ST M45PE20 (non-buffered flash)*/
block|{
literal|0x15000001
block|,
literal|0x57808201
block|,
literal|0x000500db
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|ST_MICRO_FLASH_PAGE_BITS
block|,
name|ST_MICRO_FLASH_PAGE_SIZE
block|,
name|ST_MICRO_FLASH_BYTE_ADDR_MASK
block|,
name|ST_MICRO_FLASH_BASE_TOTAL_SIZE
operator|*
literal|4
block|,
literal|"Entry 0110: ST M45PE20 (256kB non-bufferred)"
block|}
block|,
comment|/* Saifun SA25F005 (non-buffered flash) */
comment|/* strap, cfg1,& write1 need updates */
block|{
literal|0x1d000003
block|,
literal|0x5f808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
name|SAIFUN_FLASH_BASE_TOTAL_SIZE
block|,
literal|"Non-buffered flash (64kB)"
block|}
block|,
comment|/* Fast EEPROM */
block|{
literal|0x22000000
block|,
literal|0x62808380
block|,
literal|0x009f0081
block|,
literal|0xa184a053
block|,
literal|0xaf000400
block|,
name|BUFFERED_FLAGS
block|,
name|SEEPROM_PAGE_BITS
block|,
name|SEEPROM_PAGE_SIZE
block|,
name|SEEPROM_BYTE_ADDR_MASK
block|,
name|SEEPROM_TOTAL_SIZE
block|,
literal|"EEPROM - fast"
block|}
block|,
comment|/* Expansion entry 1001 */
block|{
literal|0x2a000002
block|,
literal|0x6b808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1001"
block|}
block|,
comment|/* Expansion entry 1010 */
block|{
literal|0x26000001
block|,
literal|0x67808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1010"
block|}
block|,
comment|/* ATMEL AT45DB011B (buffered flash) */
block|{
literal|0x2e000003
block|,
literal|0x6e808273
block|,
literal|0x00570081
block|,
literal|0x68848353
block|,
literal|0xaf000400
block|,
name|BUFFERED_FLAGS
block|,
name|BUFFERED_FLASH_PAGE_BITS
block|,
name|BUFFERED_FLASH_PAGE_SIZE
block|,
name|BUFFERED_FLASH_BYTE_ADDR_MASK
block|,
name|BUFFERED_FLASH_TOTAL_SIZE
block|,
literal|"Buffered flash (128kB)"
block|}
block|,
comment|/* Expansion entry 1100 */
block|{
literal|0x33000000
block|,
literal|0x73808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1100"
block|}
block|,
comment|/* Expansion entry 1101 */
block|{
literal|0x3b000002
block|,
literal|0x7b808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
name|NONBUFFERED_FLAGS
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1101"
block|}
block|,
comment|/* Ateml Expansion entry 1110 */
block|{
literal|0x37000001
block|,
literal|0x76808273
block|,
literal|0x00570081
block|,
literal|0x68848353
block|,
literal|0xaf000400
block|,
name|BUFFERED_FLAGS
block|,
name|BUFFERED_FLASH_PAGE_BITS
block|,
name|BUFFERED_FLASH_PAGE_SIZE
block|,
name|BUFFERED_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1110 (Atmel)"
block|}
block|,
comment|/* ATMEL AT45DB021B (buffered flash) */
block|{
literal|0x3f000003
block|,
literal|0x7e808273
block|,
literal|0x00570081
block|,
literal|0x68848353
block|,
literal|0xaf000400
block|,
name|BUFFERED_FLAGS
block|,
name|BUFFERED_FLASH_PAGE_BITS
block|,
name|BUFFERED_FLASH_PAGE_SIZE
block|,
name|BUFFERED_FLASH_BYTE_ADDR_MASK
block|,
name|BUFFERED_FLASH_TOTAL_SIZE
operator|*
literal|2
block|,
literal|"Buffered flash (256kB)"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The BCM5709 controllers transparently handle the  * differences between Atmel 264 byte pages and all  * flash devices which use 256 byte pages, so no  * logical-to-physical mapping is required in the  * driver.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|flash_spec
name|flash_5709
init|=
block|{
operator|.
name|flags
operator|=
name|BCE_NV_BUFFERED
block|,
operator|.
name|page_bits
operator|=
name|BCM5709_FLASH_PAGE_BITS
block|,
operator|.
name|page_size
operator|=
name|BCM5709_FLASH_PAGE_SIZE
block|,
operator|.
name|addr_mask
operator|=
name|BCM5709_FLASH_BYTE_ADDR_MASK
block|,
operator|.
name|total_size
operator|=
name|BUFFERED_FLASH_TOTAL_SIZE
operator|*
literal|2
block|,
operator|.
name|name
operator|=
literal|"5709/5716 buffered flash (256kB)"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* FreeBSD device entry points.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|bce_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Debug Data Structure Dump Routines                                   */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|u32
name|bce_reg_rd
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_reg_wr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_reg_wr16
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u32
name|bce_ctx_rd
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_enet
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_mbuf
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_tx_mbuf_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u16
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_rx_mbuf_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u16
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_function_decl
specifier|static
name|void
name|bce_dump_pg_mbuf_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u16
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|bce_dump_txbd
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|tx_bd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_rxbd
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|rx_bd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_function_decl
specifier|static
name|void
name|bce_dump_pgbd
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|rx_bd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|bce_dump_l2fhdr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|l2_fhdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_ctx
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_ftqs
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u16
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_rx_bd_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u16
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_function_decl
specifier|static
name|void
name|bce_dump_pg_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u16
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|bce_dump_status_block
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_stats_block
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_driver_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_hw_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_mq_regs
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_bc_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_txp_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_rxp_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_tpat_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_cp_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_com_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_rv2p_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_breakpoint
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Register/Memory Access Routines                                      */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|u32
name|bce_reg_rd_ind
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_reg_wr_ind
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_shmem_wr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u32
name|bce_shmem_rd
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_ctx_wr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_miibus_read_reg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_miibus_write_reg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE NVRAM Access Routines                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|bce_acquire_nvram_lock
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_release_nvram_lock
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_enable_nvram_access
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_disable_nvram_access
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_read_dword
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_init_nvram
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_read
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_test
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_function_decl
specifier|static
name|int
name|bce_enable_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_disable_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_erase_page
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_write_dword
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|bce_get_media
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_media
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dma_map_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_dma_alloc
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dma_free
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_release_resources
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Firmware Synchronization and Load                                    */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|bce_fw_sync
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_load_rv2p_fw
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_load_cpu_fw
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|cpu_reg
modifier|*
parameter_list|,
name|struct
name|fw_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_start_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|cpu_reg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_halt_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|cpu_reg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_start_rxp_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_rxp_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_txp_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_tpat_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_cp_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_com_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_cpus
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_print_adapter_info
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_probe_pci_caps
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_stop
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_reset
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_chipinit
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_blockinit
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_init_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_free_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_get_rx_buf
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_init_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_fill_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_free_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_function_decl
specifier|static
name|int
name|bce_get_pg_buf
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_init_pg_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_fill_pg_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_free_pg_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|bce_tso_setup
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_tx_encap
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_watchdog
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_ifmedia_upd_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_mgmt_init_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_init_ctx
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_get_mac_addr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_set_mac_addr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_phy_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u16
name|bce_get_hw_rx_cons
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_rx_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_tx_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_disable_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_enable_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_set_rx_mode
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_stats_update
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_pulse
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_add_sysctls
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* FreeBSD device dispatch table.                                           */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|bce_methods
index|[]
init|=
block|{
comment|/* Device interface (device_if.h) */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bce_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bce_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bce_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bce_shutdown
argument_list|)
block|,
comment|/* Supported by device interface but not used here. */
comment|/*	DEVMETHOD(device_identify,	bce_identify),      */
comment|/*	DEVMETHOD(device_suspend,	bce_suspend),       */
comment|/*	DEVMETHOD(device_resume,	bce_resume),        */
comment|/*	DEVMETHOD(device_quiesce,	bce_quiesce),       */
comment|/* Bus interface (bus_if.h) */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* MII interface (miibus_if.h) */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|bce_miibus_read_reg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|bce_miibus_write_reg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|bce_miibus_statchg
argument_list|)
block|,
comment|/* Supported by MII interface but not used here.       */
comment|/*	DEVMETHOD(miibus_linkchg,	bce_miibus_linkchg),   */
comment|/*	DEVMETHOD(miibus_mediainit,	bce_miibus_mediainit), */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|bce_driver
init|=
block|{
literal|"bce"
block|,
name|bce_methods
block|,
expr|sizeof
operator|(
expr|struct
name|bce_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|bce_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bce
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bce
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bce
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bce
argument_list|,
name|pci
argument_list|,
name|bce_driver
argument_list|,
name|bce_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|bce
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Tunable device values                                                    */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|bce
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"bce driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allowable values are TRUE or FALSE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bce_tso_enable
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bce.tso_enable"
argument_list|,
operator|&
name|bce_tso_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bce
argument_list|,
name|OID_AUTO
argument_list|,
name|tso_enable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bce_tso_enable
argument_list|,
literal|0
argument_list|,
literal|"TSO Enable/Disable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allowable values are 0 (IRQ), 1 (MSI/IRQ), and 2 (MSI-X/MSI/IRQ) */
end_comment

begin_comment
comment|/* ToDo: Add MSI-X support. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bce_msi_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bce.msi_enable"
argument_list|,
operator|&
name|bce_msi_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bce
argument_list|,
name|OID_AUTO
argument_list|,
name|msi_enable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bce_msi_enable
argument_list|,
literal|0
argument_list|,
literal|"MSI-X|MSI|INTx selector"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ToDo: Add tunable to enable/disable strict MTU handling. */
end_comment

begin_comment
comment|/* Currently allows "loose" RX MTU checking (i.e. sets the  */
end_comment

begin_comment
comment|/* H/W RX MTU to the size of the largest receive buffer, or */
end_comment

begin_comment
comment|/* 2048 bytes). This will cause a UNH failure but is more   */
end_comment

begin_comment
comment|/* desireable from a functional perspective.                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Device probe function.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Compares the device to the driver's list of supported devices and        */
end_comment

begin_comment
comment|/* reports back to the OS whether this is the right driver for the device.  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   BUS_PROBE_DEFAULT on success, positive value on failure.               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_type
modifier|*
name|t
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|descbuf
decl_stmt|;
name|u16
name|vid
init|=
literal|0
decl_stmt|,
name|did
init|=
literal|0
decl_stmt|,
name|svid
init|=
literal|0
decl_stmt|,
name|sdid
init|=
literal|0
decl_stmt|;
name|t
operator|=
name|bce_devs
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bce_softc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_dev
operator|=
name|dev
expr_stmt|;
comment|/* Get the data for the device to be probed. */
name|vid
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|did
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|svid
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sdid
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_LOAD
argument_list|,
literal|"%s(); VID = 0x%04X, DID = 0x%04X, SVID = 0x%04X, "
literal|"SDID = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|vid
argument_list|,
name|did
argument_list|,
name|svid
argument_list|,
name|sdid
argument_list|)
expr_stmt|;
comment|/* Look through the list of known devices for a match. */
while|while
condition|(
name|t
operator|->
name|bce_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|vid
operator|==
name|t
operator|->
name|bce_vid
operator|)
operator|&&
operator|(
name|did
operator|==
name|t
operator|->
name|bce_did
operator|)
operator|&&
operator|(
operator|(
name|svid
operator|==
name|t
operator|->
name|bce_svid
operator|)
operator|||
operator|(
name|t
operator|->
name|bce_svid
operator|==
name|PCI_ANY_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|sdid
operator|==
name|t
operator|->
name|bce_sdid
operator|)
operator|||
operator|(
name|t
operator|->
name|bce_sdid
operator|==
name|PCI_ANY_ID
operator|)
operator|)
condition|)
block|{
name|descbuf
operator|=
name|malloc
argument_list|(
name|BCE_DEVDESC_MAX
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Print out the device identity. */
name|snprintf
argument_list|(
name|descbuf
argument_list|,
name|BCE_DEVDESC_MAX
argument_list|,
literal|"%s (%c%d)"
argument_list|,
name|t
operator|->
name|bce_name
argument_list|,
operator|(
operator|(
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|+
literal|'A'
operator|)
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|descbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|t
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* PCI Capabilities Probe Function.                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Walks the PCI capabiites list for the device to find what features are   */
end_comment

begin_comment
comment|/* supported.                                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   None.                                                                  */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_print_adapter_info
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"ASIC (0x%08X); "
argument_list|,
name|sc
operator|->
name|bce_chipid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Rev (%c%d); "
argument_list|,
operator|(
operator|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|+
literal|'A'
argument_list|,
operator|(
operator|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|&
literal|0x0ff0
operator|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|/* Bus info. */
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCIE_FLAG
condition|)
block|{
name|printf
argument_list|(
literal|"Bus (PCIe x%d, "
argument_list|,
name|sc
operator|->
name|link_width
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|link_speed
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"2.5Gbps); "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"5Gbps); "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown link speed); "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Bus (PCI%s, %s, %dMHz); "
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCIX_FLAG
operator|)
condition|?
literal|"-X"
else|:
literal|""
operator|)
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCI_32BIT_FLAG
operator|)
condition|?
literal|"32-bit"
else|:
literal|"64-bit"
operator|)
argument_list|,
name|sc
operator|->
name|bus_speed_mhz
argument_list|)
expr_stmt|;
block|}
comment|/* Firmware version and device features. */
name|printf
argument_list|(
literal|"B/C (%s); Flags ("
argument_list|,
name|sc
operator|->
name|bce_bc_ver
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|printf
argument_list|(
literal|"SPLT"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_USING_MSI_FLAG
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSI"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_USING_MSIX_FLAG
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSI-X"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_2_5G_CAPABLE_FLAG
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"2.5G"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_MFW_ENABLE_FLAG
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MFW); MFW (%s)\n"
argument_list|,
name|sc
operator|->
name|bce_mfw_ver
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* PCI Capabilities Probe Function.                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Walks the PCI capabiites list for the device to find what features are   */
end_comment

begin_comment
comment|/* supported.                                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   None.                                                                  */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_probe_pci_caps
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
comment|/* Check if PCI-X capability is enabled. */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_PCIX
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
name|sc
operator|->
name|bce_cap_flags
operator||=
name|BCE_PCIX_CAPABLE_FLAG
expr_stmt|;
block|}
comment|/* Check if PCIe capability is enabled. */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|u16
name|link_status
init|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x12
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"PCIe link_status = "
literal|"0x%08X\n"
argument_list|,
name|link_status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_speed
operator|=
name|link_status
operator|&
literal|0xf
expr_stmt|;
name|sc
operator|->
name|link_width
operator|=
operator|(
name|link_status
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|sc
operator|->
name|bce_cap_flags
operator||=
name|BCE_PCIE_CAPABLE_FLAG
expr_stmt|;
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_PCIE_FLAG
expr_stmt|;
block|}
block|}
comment|/* Check if MSI capability is enabled. */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSI
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
name|sc
operator|->
name|bce_cap_flags
operator||=
name|BCE_MSI_CAPABLE_FLAG
expr_stmt|;
block|}
comment|/* Check if MSI-X capability is enabled. */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
name|sc
operator|->
name|bce_cap_flags
operator||=
name|BCE_MSIX_CAPABLE_FLAG
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Device attach function.                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Allocates device resources, performs secondary chip identification,      */
end_comment

begin_comment
comment|/* resets and initializes the hardware, and initializes driver instance     */
end_comment

begin_comment
comment|/* variables.                                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_dev
operator|=
name|dev
expr_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Set initial device and PHY flags */
name|sc
operator|->
name|bce_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_phy_flags
operator|=
literal|0
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate PCI memory resources. */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_res_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|PCI_RF_DENSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_res_mem
operator|==
name|NULL
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): PCI memory allocation failed\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Get various resource handles. */
name|sc
operator|->
name|bce_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|bce_res_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|bce_res_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_vhandle
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|bce_res_mem
argument_list|)
expr_stmt|;
name|bce_probe_pci_caps
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Try allocating MSI-X interrupts. */
block|if ((sc->bce_cap_flags& BCE_MSIX_CAPABLE_FLAG)&& 		(bce_msi_enable>= 2)&& 		((sc->bce_res_irq = bus_alloc_resource_any(dev, SYS_RES_MEMORY,&rid, RF_ACTIVE)) != NULL)) {  		msi_needed = sc->bce_msi_count = 1;  		if (((error = pci_alloc_msix(dev,&sc->bce_msi_count)) != 0) || 			(sc->bce_msi_count != msi_needed)) { 			BCE_PRINTF("%s(%d): MSI-X allocation failed! Requested = %d," 				"Received = %d, error = %d\n", __FILE__, __LINE__, 				msi_needed, sc->bce_msi_count, error); 			sc->bce_msi_count = 0; 			pci_release_msi(dev); 			bus_release_resource(dev, SYS_RES_MEMORY, rid, 				sc->bce_res_irq); 			sc->bce_res_irq = NULL; 		} else { 			DBPRINT(sc, BCE_INFO_LOAD, "%s(): Using MSI-X interrupt.\n", 				__FUNCTION__); 			sc->bce_flags |= BCE_USING_MSIX_FLAG; 			sc->bce_intr = bce_intr; 		} 	}
endif|#
directive|endif
comment|/* Try allocating a MSI interrupt. */
if|if
condition|(
operator|(
name|sc
operator|->
name|bce_cap_flags
operator|&
name|BCE_MSI_CAPABLE_FLAG
operator|)
operator|&&
operator|(
name|bce_msi_enable
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|sc
operator|->
name|bce_msi_count
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|bce_msi_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|bce_msi_count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): MSI allocation failed! "
literal|"error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_msi_count
operator|=
literal|0
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): Using MSI "
literal|"interrupt.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_USING_MSI_FLAG
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_ONE_SHOT_MSI_FLAG
expr_stmt|;
name|sc
operator|->
name|bce_irq_rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_intr
operator|=
name|bce_intr
expr_stmt|;
block|}
block|}
comment|/* Try allocating a legacy interrupt. */
if|if
condition|(
name|sc
operator|->
name|bce_msi_count
operator|==
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): Using INTx interrupt.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_intr
operator|=
name|bce_intr
expr_stmt|;
block|}
name|sc
operator|->
name|bce_res_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_irq_rid
operator|=
name|rid
expr_stmt|;
comment|/* Report any IRQ allocation errors. */
if|if
condition|(
name|sc
operator|->
name|bce_res_irq
operator|==
name|NULL
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): PCI map interrupt failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Initialize mutex for the current device instance. */
name|BCE_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Configure byte swap and enable indirect register access. 	 * Rely on CPU to do target byte swapping on big endian systems. 	 * Access to registers outside of PCI configurtion space are not 	 * valid until this is done. 	 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_MISC_CONFIG
argument_list|,
name|BCE_PCICFG_MISC_CONFIG_REG_WINDOW_ENA
operator||
name|BCE_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Save ASIC revsion info. */
name|sc
operator|->
name|bce_chipid
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ID
argument_list|)
expr_stmt|;
comment|/* Weed out any non-production controller revisions. */
switch|switch
condition|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
condition|)
block|{
case|case
name|BCE_CHIP_ID_5706_A0
case|:
case|case
name|BCE_CHIP_ID_5706_A1
case|:
case|case
name|BCE_CHIP_ID_5708_A0
case|:
case|case
name|BCE_CHIP_ID_5708_B0
case|:
case|case
name|BCE_CHIP_ID_5709_A0
case|:
case|case
name|BCE_CHIP_ID_5709_B0
case|:
case|case
name|BCE_CHIP_ID_5709_B1
case|:
case|case
name|BCE_CHIP_ID_5709_B2
case|:
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Unsupported controller "
literal|"revision (%c%d)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
operator|(
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|+
literal|'A'
operator|)
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* 	 * The embedded PCIe to PCI-X bridge (EPB) 	 * in the 5708 cannot address memory above 	 * 40 bits (E7_5708CB1_23043& E6_5708SB1_23043). 	 */
if|if
condition|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5708
condition|)
name|sc
operator|->
name|max_bus_addr
operator|=
name|BCE_BUS_SPACE_MAXADDR
expr_stmt|;
else|else
name|sc
operator|->
name|max_bus_addr
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
comment|/* 	 * Find the base address for shared memory access. 	 * Newer versions of bootcode use a signature and offset 	 * while older versions use a fixed address. 	 */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_SHM_HDR_SIGNATURE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_SHM_HDR_SIGNATURE_SIG_MASK
operator|)
operator|==
name|BCE_SHM_HDR_SIGNATURE_SIG
condition|)
comment|/* Multi-port devices use different offsets in shared memory. */
name|sc
operator|->
name|bce_shmem_base
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_SHM_HDR_ADDR_0
operator|+
operator|(
name|pci_get_function
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|)
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|bce_shmem_base
operator|=
name|HOST_VIEW_SHMEM_BASE
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_FIRMWARE
argument_list|,
literal|"%s(): bce_shmem_base = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|bce_shmem_base
argument_list|)
expr_stmt|;
comment|/* Fetch the bootcode revision. */
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_DEV_INFO_BC_REV
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|u8
name|num
decl_stmt|;
name|num
operator|=
call|(
name|u8
call|)
argument_list|(
name|val
operator|>>
operator|(
literal|24
operator|-
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|100
init|,
name|skip0
init|=
literal|1
init|;
name|k
operator|>=
literal|1
condition|;
name|num
operator|%=
name|k
operator|,
name|k
operator|/=
literal|10
control|)
block|{
if|if
condition|(
name|num
operator|>=
name|k
operator|||
operator|!
name|skip0
operator|||
name|k
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|bce_bc_ver
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|num
operator|/
name|k
operator|)
operator|+
literal|'0'
expr_stmt|;
name|skip0
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
literal|2
condition|)
name|sc
operator|->
name|bce_bc_ver
index|[
name|j
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* Check if any management firwmare is enabled. */
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_PORT_FEATURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_PORT_FEATURE_ASF_ENABLED
condition|)
block|{
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_MFW_ENABLE_FLAG
expr_stmt|;
comment|/* Allow time for firmware to enter the running state. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_BC_STATE_CONDITION
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_CONDITION_MFW_RUN_MASK
condition|)
break|break;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/* Check if management firmware is running. */
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_BC_STATE_CONDITION
argument_list|)
expr_stmt|;
name|val
operator|&=
name|BCE_CONDITION_MFW_RUN_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|!=
name|BCE_CONDITION_MFW_RUN_UNKNOWN
operator|)
operator|&&
operator|(
name|val
operator|!=
name|BCE_CONDITION_MFW_RUN_NONE
operator|)
condition|)
block|{
name|u32
name|addr
init|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_MFW_VER_PTR
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Read the management firmware version string. */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|val
operator|=
name|bce_reg_rd_ind
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|j
operator|*
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|bswap32
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|bce_mfw_ver
index|[
name|i
index|]
argument_list|,
operator|&
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* May cause firmware synchronization timeouts. */
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Management firmware enabled "
literal|"but not running!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|bce_mfw_ver
argument_list|,
literal|"NOT RUNNING!"
argument_list|)
expr_stmt|;
comment|/* ToDo: Any action the driver should take? */
block|}
block|}
comment|/* Get PCI bus information (speed and type). */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_MISC_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_PCICFG_MISC_STATUS_PCIX_DET
condition|)
block|{
name|u32
name|clkreg
decl_stmt|;
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_PCIX_FLAG
expr_stmt|;
name|clkreg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS
argument_list|)
expr_stmt|;
name|clkreg
operator|&=
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET
expr_stmt|;
switch|switch
condition|(
name|clkreg
condition|)
block|{
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_133MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|133
expr_stmt|;
break|break;
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_95MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_66MHZ
case|:
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_80MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|66
expr_stmt|;
break|break;
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_48MHZ
case|:
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_55MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|50
expr_stmt|;
break|break;
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_LOW
case|:
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_32MHZ
case|:
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_38MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|33
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|val
operator|&
name|BCE_PCICFG_MISC_STATUS_M66EN
condition|)
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|66
expr_stmt|;
else|else
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|33
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|BCE_PCICFG_MISC_STATUS_32BIT_DET
condition|)
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_PCI_32BIT_FLAG
expr_stmt|;
comment|/* Reset controller and announce to bootcode that driver is present. */
if|if
condition|(
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Controller reset failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Initialize the controller. */
if|if
condition|(
name|bce_chipinit
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Controller initialization failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Perform NVRAM test. */
if|if
condition|(
name|bce_nvram_test
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): NVRAM test failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Fetch the permanent Ethernet MAC address. */
name|bce_get_mac_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Trip points control how many BDs 	 * should be ready before generating an 	 * interrupt while ticks control how long 	 * a BD can sit in the chain before 	 * generating an interrupt.  Set the default 	 * values for the RX and TX chains. 	 */
ifdef|#
directive|ifdef
name|BCE_DEBUG
comment|/* Force more frequent interrupts. */
name|sc
operator|->
name|bce_tx_quick_cons_trip_int
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_tx_quick_cons_trip
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_tx_ticks_int
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_tx_ticks
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_rx_quick_cons_trip_int
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_rx_quick_cons_trip
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_rx_ticks_int
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_rx_ticks
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* Improve throughput at the expense of increased latency. */
name|sc
operator|->
name|bce_tx_quick_cons_trip_int
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|bce_tx_quick_cons_trip
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|bce_tx_ticks_int
operator|=
literal|80
expr_stmt|;
name|sc
operator|->
name|bce_tx_ticks
operator|=
literal|80
expr_stmt|;
name|sc
operator|->
name|bce_rx_quick_cons_trip_int
operator|=
literal|6
expr_stmt|;
name|sc
operator|->
name|bce_rx_quick_cons_trip
operator|=
literal|6
expr_stmt|;
name|sc
operator|->
name|bce_rx_ticks_int
operator|=
literal|18
expr_stmt|;
name|sc
operator|->
name|bce_rx_ticks
operator|=
literal|18
expr_stmt|;
endif|#
directive|endif
comment|/* Not used for L2. */
name|sc
operator|->
name|bce_comp_prod_trip_int
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_comp_prod_trip
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_com_ticks_int
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_com_ticks
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_cmd_ticks_int
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_cmd_ticks
operator|=
literal|0
expr_stmt|;
comment|/* Update statistics once every second. */
name|sc
operator|->
name|bce_stats_ticks
operator|=
literal|1000000
operator|&
literal|0xffff00
expr_stmt|;
comment|/* Find the media type for the adapter. */
name|bce_get_media
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Store data needed by PHY driver for backplane applications */
name|sc
operator|->
name|bce_shared_hw_cfg
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_SHARED_HW_CFG_CONFIG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_port_hw_cfg
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_PORT_HW_CFG_CONFIG
argument_list|)
expr_stmt|;
comment|/* Allocate DMA memory resources. */
if|if
condition|(
name|bce_dma_alloc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): DMA resource allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Allocate an ifnet structure. */
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Interface allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Initialize the ifnet interface. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|bce_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|bce_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|bce_init
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
if|if
condition|(
name|bce_tso_enable
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator|=
name|BCE_IF_HWASSIST
operator||
name|CSUM_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|BCE_IF_CAPABILITIES
operator||
name|IFCAP_TSO4
operator||
name|IFCAP_VLAN_HWTSO
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_hwassist
operator|=
name|BCE_IF_HWASSIST
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|BCE_IF_CAPABILITIES
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Assume standard mbuf sizes for buffer allocation. 	 * This may change later if the MTU size is set to 	 * something other than 1500. 	 */
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|=
name|MHLEN
expr_stmt|;
comment|/* Make sure offset is 16 byte aligned for hardware. */
name|sc
operator|->
name|rx_bd_mbuf_align_pad
operator|=
name|roundup2
argument_list|(
operator|(
name|MSIZE
operator|-
name|MHLEN
operator|)
argument_list|,
literal|16
argument_list|)
operator|-
operator|(
name|MSIZE
operator|-
name|MHLEN
operator|)
expr_stmt|;
name|sc
operator|->
name|rx_bd_mbuf_data_len
operator|=
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|-
name|sc
operator|->
name|rx_bd_mbuf_align_pad
expr_stmt|;
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|rx_bd_mbuf_align_pad
operator|=
name|roundup2
argument_list|(
name|MCLBYTES
argument_list|,
literal|16
argument_list|)
operator|-
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|rx_bd_mbuf_data_len
operator|=
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|-
name|sc
operator|->
name|rx_bd_mbuf_align_pad
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|USABLE_TX_BD
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_2_5G_CAPABLE_FLAG
condition|)
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
literal|2500ULL
argument_list|)
expr_stmt|;
else|else
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Handle any special PHY initialization for SerDes PHYs. */
name|bce_init_media
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* MII child bus by attaching the PHY. */
name|rc
operator|=
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|bce_miibus
argument_list|,
name|ifp
argument_list|,
name|bce_ifmedia_upd
argument_list|,
name|bce_ifmedia_sts
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|sc
operator|->
name|bce_phy_addr
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
name|MIIF_DOPAUSE
operator||
name|MIIF_FORCEPAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): attaching PHYs failed\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Attach to the Ethernet interface list. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|eaddr
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|bce_tick_callout
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|bce_pulse_callout
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|bce_tick_callout
argument_list|,
operator|&
name|sc
operator|->
name|bce_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|bce_pulse_callout
argument_list|,
operator|&
name|sc
operator|->
name|bce_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Hookup IRQ last. */
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bce_res_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bce_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|bce_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Failed to setup IRQ!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|bce_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|bce_attach_exit
goto|;
block|}
comment|/* 	 * At this point we've acquired all the resources 	 * we need to run so there's no turning back, we're 	 * cleared for launch. 	 */
comment|/* Print some important debugging info. */
name|DBRUNMSG
argument_list|(
name|BCE_INFO
argument_list|,
name|bce_dump_driver_state
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the supported sysctls to the kernel. */
name|bce_add_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The chip reset earlier notified the bootcode that 	 * a driver is present.  We now need to start our pulse 	 * routine so that the bootcode is reminded that we're 	 * still running. 	 */
name|bce_pulse
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_mgmt_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Finally, print some useful adapter info */
name|bce_print_adapter_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_FATAL
argument_list|,
literal|"%s(): sc = %p\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|bce_attach_exit
goto|;
name|bce_attach_fail
label|:
name|bce_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_attach_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Device detach function.                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Stops the controller, resets the controller, and releases resources.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|msg
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_UNLOAD
operator||
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
comment|/* Stop and reset the controller. */
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop the pulse so the bootcode can go to driver absent state. */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|bce_pulse_callout
argument_list|)
expr_stmt|;
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_NO_WOL_FLAG
condition|)
name|msg
operator|=
name|BCE_DRV_MSG_CODE_UNLOAD_LNK_DN
expr_stmt|;
else|else
name|msg
operator|=
name|BCE_DRV_MSG_CODE_UNLOAD
expr_stmt|;
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* If we have a child device on the MII bus remove it too. */
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
comment|/* Release all remaining resources. */
name|bce_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_UNLOAD
operator||
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Device shutdown function.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Stops and resets the controller.                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|msg
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_NO_WOL_FLAG
condition|)
name|msg
operator|=
name|BCE_DRV_MSG_CODE_UNLOAD_LNK_DN
expr_stmt|;
else|else
name|msg
operator|=
name|BCE_DRV_MSG_CODE_UNLOAD
expr_stmt|;
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Register read.                                                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The value of the register.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|u32
name|bce_reg_rd
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
name|u32
name|val
init|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INSANE_REG
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Register write (16 bit).                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_reg_wr16
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|val
parameter_list|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INSANE_REG
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Register write.                                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_reg_wr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INSANE_REG
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Indirect register read.                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Reads NetXtreme II registers using an index/data register pair in PCI    */
end_comment

begin_comment
comment|/* configuration space.  Using this mechanism avoids issues with posted     */
end_comment

begin_comment
comment|/* reads but is much slower than memory-mapped I/O.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The value of the register.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|u32
name|bce_reg_rd_ind
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|bce_dev
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW_ADDRESS
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INSANE_REG
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
else|#
directive|else
return|return
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW
argument_list|,
literal|4
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Indirect register write.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Writes NetXtreme II registers using an index/data register pair in PCI   */
end_comment

begin_comment
comment|/* configuration space.  Using this mechanism avoids issues with posted     */
end_comment

begin_comment
comment|/* writes but is muchh slower than memory-mapped I/O.                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_reg_wr_ind
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|bce_dev
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INSANE_REG
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW_ADDRESS
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Shared memory write.                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Writes NetXtreme II shared memory region.                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_shmem_wr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_FIRMWARE
argument_list|,
literal|"%s(): Writing 0x%08X  to  "
literal|"0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|bce_reg_wr_ind
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Shared memory read.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Reads NetXtreme II shared memory region.                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The 32 bit value read.                                                 */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|u32
name|bce_shmem_rd
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
name|u32
name|val
init|=
name|bce_reg_rd_ind
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|offset
argument_list|)
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_FIRMWARE
argument_list|,
literal|"%s(): Reading 0x%08X from "
literal|"0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Context memory read.                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* The NetXtreme II controller uses context memory to track connection      */
end_comment

begin_comment
comment|/* information for L2 and higher network protocols.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The requested 32 bit value of context memory.                          */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|u32
name|bce_ctx_rd
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|cid_addr
parameter_list|,
name|u32
name|ctx_offset
parameter_list|)
block|{
name|u32
name|idx
decl_stmt|,
name|offset
decl_stmt|,
name|retry_cnt
init|=
literal|5
decl_stmt|,
name|val
decl_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|cid_addr
operator|>
name|MAX_CID_ADDR
operator|||
name|ctx_offset
operator|&
literal|0x3
operator|||
name|cid_addr
operator|&
name|CTX_MASK
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(): Invalid CID "
literal|"address: 0x%08X.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid_addr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ctx_offset
operator|+
name|cid_addr
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_CTX_CTRL
argument_list|,
operator|(
name|offset
operator||
name|BCE_CTX_CTX_CTRL_READ_REQ
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|retry_cnt
condition|;
name|idx
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_CTX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_CTX_CTX_CTRL_READ_REQ
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|BCE_CTX_CTX_CTRL_READ_REQ
condition|)
name|BCE_PRINTF
argument_list|(
literal|"%s(%d); Unable to read CTX memory: "
literal|"cid_addr = 0x%08X, offset = 0x%08X!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|cid_addr
argument_list|,
name|ctx_offset
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_CTX_DATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_DATA_ADR
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_DATA
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_CTX
argument_list|,
literal|"%s(); cid_addr = 0x%08X, offset = 0x%08X, "
literal|"val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid_addr
argument_list|,
name|ctx_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Context memory write.                                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* The NetXtreme II controller uses context memory to track connection      */
end_comment

begin_comment
comment|/* information for L2 and higher network protocols.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_ctx_wr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|cid_addr
parameter_list|,
name|u32
name|ctx_offset
parameter_list|,
name|u32
name|ctx_val
parameter_list|)
block|{
name|u32
name|idx
decl_stmt|,
name|offset
init|=
name|ctx_offset
operator|+
name|cid_addr
decl_stmt|;
name|u32
name|val
decl_stmt|,
name|retry_cnt
init|=
literal|5
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_CTX
argument_list|,
literal|"%s(); cid_addr = 0x%08X, offset = 0x%08X, "
literal|"val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid_addr
argument_list|,
name|ctx_offset
argument_list|,
name|ctx_val
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|cid_addr
operator|>
name|MAX_CID_ADDR
operator|||
name|ctx_offset
operator|&
literal|0x3
operator|||
name|cid_addr
operator|&
name|CTX_MASK
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(): Invalid CID address: 0x%08X.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_CTX_DATA
argument_list|,
name|ctx_val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_CTX_CTRL
argument_list|,
operator|(
name|offset
operator||
name|BCE_CTX_CTX_CTRL_WRITE_REQ
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|retry_cnt
condition|;
name|idx
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_CTX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_CTX_CTX_CTRL_WRITE_REQ
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|BCE_CTX_CTX_CTRL_WRITE_REQ
condition|)
name|BCE_PRINTF
argument_list|(
literal|"%s(%d); Unable to write CTX memory: "
literal|"cid_addr = 0x%08X, offset = 0x%08X!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|cid_addr
argument_list|,
name|ctx_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_DATA_ADR
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_DATA
argument_list|,
name|ctx_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* PHY register read.                                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Implements register reads on the MII bus.                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The value of the register.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_miibus_read_reg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Make sure we are accessing the correct PHY address. */
if|if
condition|(
name|phy
operator|!=
name|sc
operator|->
name|bce_phy_addr
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INSANE_PHY
argument_list|,
literal|"Invalid PHY address %d "
literal|"for PHY read!\n"
argument_list|,
name|phy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * The 5709S PHY is an IEEE Clause 45 PHY      * with special mappings to work with IEEE      * Clause 22 register accesses.      */
if|if
condition|(
operator|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_IEEE_CLAUSE_45_FLAG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|>=
name|MII_BMCR
operator|&&
name|reg
operator|<=
name|MII_ANLPRNP
condition|)
name|reg
operator|+=
literal|0x10
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_INT_MODE_AUTO_POLLING_FLAG
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|BCE_EMAC_MDIO_MODE_AUTO_POLL
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|BCE_MIPHY
argument_list|(
name|phy
argument_list|)
operator||
name|BCE_MIREG
argument_list|(
name|reg
argument_list|)
operator||
name|BCE_EMAC_MDIO_COMM_COMMAND_READ
operator||
name|BCE_EMAC_MDIO_COMM_DISEXT
operator||
name|BCE_EMAC_MDIO_COMM_START_BUSY
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCE_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|BCE_EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
name|val
operator|&=
name|BCE_EMAC_MDIO_COMM_DATA
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|val
operator|&
name|BCE_EMAC_MDIO_COMM_START_BUSY
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Error: PHY read timeout! phy = %d, "
literal|"reg = 0x%04X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_INT_MODE_AUTO_POLLING_FLAG
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_EMAC_MDIO_MODE_AUTO_POLL
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
name|DB_PRINT_PHY_REG
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* PHY register write.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Implements register writes on the MII bus.                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The value of the register.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_miibus_write_reg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|u32
name|val1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Make sure we are accessing the correct PHY address. */
if|if
condition|(
name|phy
operator|!=
name|sc
operator|->
name|bce_phy_addr
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INSANE_PHY
argument_list|,
literal|"Invalid PHY address %d "
literal|"for PHY write!\n"
argument_list|,
name|phy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DB_PRINT_PHY_REG
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * The 5709S PHY is an IEEE Clause 45 PHY 	 * with special mappings to work with IEEE 	 * Clause 22 register accesses. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_IEEE_CLAUSE_45_FLAG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|>=
name|MII_BMCR
operator|&&
name|reg
operator|<=
name|MII_ANLPRNP
condition|)
name|reg
operator|+=
literal|0x10
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_INT_MODE_AUTO_POLLING_FLAG
condition|)
block|{
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|val1
operator|&=
operator|~
name|BCE_EMAC_MDIO_MODE_AUTO_POLL
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
name|val1
operator|=
name|BCE_MIPHY
argument_list|(
name|phy
argument_list|)
operator||
name|BCE_MIREG
argument_list|(
name|reg
argument_list|)
operator||
name|val
operator||
name|BCE_EMAC_MDIO_COMM_COMMAND_WRITE
operator||
name|BCE_EMAC_MDIO_COMM_START_BUSY
operator||
name|BCE_EMAC_MDIO_COMM_DISEXT
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|,
name|val1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCE_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val1
operator|&
name|BCE_EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|val1
operator|&
name|BCE_EMAC_MDIO_COMM_START_BUSY
condition|)
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): PHY write timeout!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_INT_MODE_AUTO_POLLING_FLAG
condition|)
block|{
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|val1
operator||=
name|BCE_EMAC_MDIO_MODE_AUTO_POLL
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* MII bus status change.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Called by the MII bus driver when the PHY establishes link to set the    */
end_comment

begin_comment
comment|/* MAC interface registers.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|val
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MODE
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|BCE_EMAC_MODE_PORT
operator||
name|BCE_EMAC_MODE_HALF_DUPLEX
operator||
name|BCE_EMAC_MODE_MAC_LOOP
operator||
name|BCE_EMAC_MODE_FORCE_LINK
operator||
name|BCE_EMAC_MODE_25G
operator|)
expr_stmt|;
comment|/* Set MII or GMII interface based on the PHY speed. */
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_10_T
case|:
if|if
condition|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|!=
name|BCE_CHIP_NUM_5706
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"Enabling 10Mb interface.\n"
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_EMAC_MODE_PORT_MII_10
expr_stmt|;
break|break;
block|}
comment|/* fall-through */
case|case
name|IFM_100_TX
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"Enabling MII interface.\n"
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_EMAC_MODE_PORT_MII
expr_stmt|;
break|break;
case|case
name|IFM_2500_SX
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"Enabling 2.5G MAC mode.\n"
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_EMAC_MODE_25G
expr_stmt|;
comment|/* fall-through */
case|case
name|IFM_1000_T
case|:
case|case
name|IFM_1000_SX
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"Enabling GMII interface.\n"
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_EMAC_MODE_PORT_GMII
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"Unknown link speed, enabling "
literal|"default GMII interface.\n"
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_EMAC_MODE_PORT_GMII
expr_stmt|;
block|}
comment|/* Set half or full duplex based on PHY settings. */
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_HDX
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"Setting Half-Duplex interface.\n"
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_EMAC_MODE_HALF_DUPLEX
expr_stmt|;
block|}
else|else
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"Setting Full-Duplex interface.\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"%s(): Enabling RX flow control.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BCE_SETBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_RX_MODE
argument_list|,
name|BCE_EMAC_RX_MODE_FLOW_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"%s(): Disabling RX flow control.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BCE_CLRBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_RX_MODE
argument_list|,
name|BCE_EMAC_RX_MODE_FLOW_EN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"%s(): Enabling TX flow control.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BCE_SETBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_TX_MODE
argument_list|,
name|BCE_EMAC_TX_MODE_FLOW_EN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_USING_TX_FLOW_CONTROL
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"%s(): Disabling TX flow control.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BCE_CLRBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_TX_MODE
argument_list|,
name|BCE_EMAC_TX_MODE_FLOW_EN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_flags
operator|&=
operator|~
name|BCE_USING_TX_FLOW_CONTROL
expr_stmt|;
block|}
comment|/* ToDo: Update watermarks in bce_init_rx_context(). */
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Acquire NVRAM lock.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Before the NVRAM can be accessed the caller must acquire an NVRAM lock.  */
end_comment

begin_comment
comment|/* Locks 0 and 2 are reserved, lock 1 is used by firmware and lock 2 is     */
end_comment

begin_comment
comment|/* for use by the driver.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_acquire_nvram_lock
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|j
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
comment|/* Request access to the flash interface. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_SW_ARB
argument_list|,
name|BCE_NVM_SW_ARB_ARB_REQ_SET2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_SW_ARB
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_NVM_SW_ARB_ARB_ARB2
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Timeout acquiring NVRAM lock!\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Release NVRAM lock.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When the caller is finished accessing NVRAM the lock must be released.   */
end_comment

begin_comment
comment|/* Locks 0 and 2 are reserved, lock 1 is used by firmware and lock 2 is     */
end_comment

begin_comment
comment|/* for use by the driver.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_release_nvram_lock
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|j
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
comment|/* 	 * Relinquish nvram interface. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_SW_ARB
argument_list|,
name|BCE_NVM_SW_ARB_ARB_REQ_CLR2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_SW_ARB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|BCE_NVM_SW_ARB_ARB_ARB2
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Timeout releasing NVRAM lock!\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Enable NVRAM write access.                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Before writing to NVRAM the caller must enable NVRAM writes.             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_enable_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_CFG
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_CFG
argument_list|,
name|val
operator||
name|BCE_MISC_CFG_NVM_WR_EN_PCI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|flags
operator|&
name|BCE_NV_BUFFERED
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_WREN
operator||
name|BCE_NVM_COMMAND_DOIT
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_NVM_COMMAND_DONE
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Timeout writing NVRAM!\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
block|}
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Disable NVRAM write access.                                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When the caller is finished writing to NVRAM write access must be        */
end_comment

begin_comment
comment|/* disabled.                                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_disable_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_CFG
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_CFG
argument_list|,
name|val
operator|&
operator|~
name|BCE_MISC_CFG_NVM_WR_EN
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Enable NVRAM access.                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Before accessing NVRAM for read or write operations the caller must      */
end_comment

begin_comment
comment|/* enabled NVRAM access.                                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_enable_nvram_access
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ACCESS_ENABLE
argument_list|)
expr_stmt|;
comment|/* Enable both bits, even on read. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ACCESS_ENABLE
argument_list|,
name|val
operator||
name|BCE_NVM_ACCESS_ENABLE_EN
operator||
name|BCE_NVM_ACCESS_ENABLE_WR_EN
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Disable NVRAM access.                                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When the caller is finished accessing NVRAM access must be disabled.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_disable_nvram_access
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ACCESS_ENABLE
argument_list|)
expr_stmt|;
comment|/* Disable both bits, even after read. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ACCESS_ENABLE
argument_list|,
name|val
operator|&
operator|~
operator|(
name|BCE_NVM_ACCESS_ENABLE_EN
operator||
name|BCE_NVM_ACCESS_ENABLE_WR_EN
operator|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Erase NVRAM page before writing.                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Non-buffered flash parts require that a page be erased before it is      */
end_comment

begin_comment
comment|/* written.                                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_erase_page
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
name|u32
name|cmd
decl_stmt|;
name|int
name|j
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
comment|/* Buffered flash doesn't require an erase. */
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|flags
operator|&
name|BCE_NV_BUFFERED
condition|)
goto|goto
name|bce_nvram_erase_page_exit
goto|;
comment|/* Build an erase command. */
name|cmd
operator|=
name|BCE_NVM_COMMAND_ERASE
operator||
name|BCE_NVM_COMMAND_WR
operator||
name|BCE_NVM_COMMAND_DOIT
expr_stmt|;
comment|/* 	 * Clear the DONE bit separately, set the NVRAM adress to erase, 	 * and issue the erase command. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ADDR
argument_list|,
name|offset
operator|&
name|BCE_NVM_ADDR_NVM_ADDR_VALUE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|u32
name|val
decl_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_NVM_COMMAND_DONE
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Timeout erasing NVRAM.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|bce_nvram_erase_page_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BCE_NVRAM_WRITE_SUPPORT */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Read a dword (32 bits) from NVRAM.                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Read a 32 bit word from NVRAM.  The caller is assumed to have already    */
end_comment

begin_comment
comment|/* obtained the NVRAM lock and enabled the controller for NVRAM access.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success and the 32 bit value read, positive value on failure.     */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_read_dword
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|ret_val
parameter_list|,
name|u32
name|cmd_flags
parameter_list|)
block|{
name|u32
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_EXTREME_NVRAM
argument_list|)
expr_stmt|;
comment|/* Build the command word. */
name|cmd
operator|=
name|BCE_NVM_COMMAND_DOIT
operator||
name|cmd_flags
expr_stmt|;
comment|/* Calculate the offset for buffered flash if translation is used. */
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|flags
operator|&
name|BCE_NV_TRANSLATE
condition|)
block|{
name|offset
operator|=
operator|(
operator|(
name|offset
operator|/
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
operator|<<
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_bits
operator|)
operator|+
operator|(
name|offset
operator|%
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
expr_stmt|;
block|}
comment|/* 	 * Clear the DONE bit separately, set the address to read, 	 * and issue the read. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ADDR
argument_list|,
name|offset
operator|&
name|BCE_NVM_ADDR_NVM_ADDR_VALUE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|val
decl_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_NVM_COMMAND_DONE
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_READ
argument_list|)
expr_stmt|;
name|val
operator|=
name|bce_be32toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_val
argument_list|,
operator|&
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for errors. */
if|if
condition|(
name|i
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Timeout error reading NVRAM at "
literal|"offset 0x%08X!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_EXTREME_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Write a dword (32 bits) to NVRAM.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Write a 32 bit word to NVRAM.  The caller is assumed to have already     */
end_comment

begin_comment
comment|/* obtained the NVRAM lock, enabled the controller for NVRAM access, and    */
end_comment

begin_comment
comment|/* enabled NVRAM write access.                                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_write_dword
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|,
name|u32
name|cmd_flags
parameter_list|)
block|{
name|u32
name|cmd
decl_stmt|,
name|val32
decl_stmt|;
name|int
name|j
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
comment|/* Build the command word. */
name|cmd
operator|=
name|BCE_NVM_COMMAND_DOIT
operator||
name|BCE_NVM_COMMAND_WR
operator||
name|cmd_flags
expr_stmt|;
comment|/* Calculate the offset for buffered flash if translation is used. */
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|flags
operator|&
name|BCE_NV_TRANSLATE
condition|)
block|{
name|offset
operator|=
operator|(
operator|(
name|offset
operator|/
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
operator|<<
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_bits
operator|)
operator|+
operator|(
name|offset
operator|%
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
expr_stmt|;
block|}
comment|/* 	 * Clear the DONE bit separately, convert NVRAM data to big-endian, 	 * set the NVRAM address to write, and issue the write command 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|val32
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val32
operator|=
name|htobe32
argument_list|(
name|val32
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_WRITE
argument_list|,
name|val32
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ADDR
argument_list|,
name|offset
operator|&
name|BCE_NVM_ADDR_NVM_ADDR_VALUE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|)
operator|&
name|BCE_NVM_COMMAND_DONE
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Timeout error writing NVRAM at "
literal|"offset 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BCE_NVRAM_WRITE_SUPPORT */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize NVRAM access.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Identify the NVRAM device in use and prepare the NVRAM interface to      */
end_comment

begin_comment
comment|/* access that device.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_init_nvram
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|j
decl_stmt|,
name|entry_count
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|flash_spec
modifier|*
name|flash
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|sc
operator|->
name|bce_flash_info
operator|=
operator|&
name|flash_5709
expr_stmt|;
goto|goto
name|bce_init_nvram_get_flash_size
goto|;
block|}
comment|/* Determine the selected interface. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_CFG1
argument_list|)
expr_stmt|;
name|entry_count
operator|=
sizeof|sizeof
argument_list|(
name|flash_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|flash_spec
argument_list|)
expr_stmt|;
comment|/* 	 * Flash reconfiguration is required to support additional 	 * NVRAM devices not directly supported in hardware. 	 * Check if the flash interface was reconfigured 	 * by the bootcode. 	 */
if|if
condition|(
name|val
operator|&
literal|0x40000000
condition|)
block|{
comment|/* Flash interface reconfigured by bootcode. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"bce_init_nvram(): Flash WAS reconfigured.\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|flash
operator|=
operator|&
name|flash_table
index|[
literal|0
index|]
init|;
name|j
operator|<
name|entry_count
condition|;
name|j
operator|++
operator|,
name|flash
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|FLASH_BACKUP_STRAP_MASK
operator|)
operator|==
operator|(
name|flash
operator|->
name|config1
operator|&
name|FLASH_BACKUP_STRAP_MASK
operator|)
condition|)
block|{
name|sc
operator|->
name|bce_flash_info
operator|=
name|flash
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Flash interface not yet reconfigured. */
name|u32
name|mask
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): Flash was NOT reconfigured.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|mask
operator|=
name|FLASH_BACKUP_STRAP_MASK
expr_stmt|;
else|else
name|mask
operator|=
name|FLASH_STRAP_MASK
expr_stmt|;
comment|/* Look for the matching NVRAM device configuration data. */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|flash
operator|=
operator|&
name|flash_table
index|[
literal|0
index|]
init|;
name|j
operator|<
name|entry_count
condition|;
name|j
operator|++
operator|,
name|flash
operator|++
control|)
block|{
comment|/* Check if the device matches any of the known devices. */
if|if
condition|(
operator|(
name|val
operator|&
name|mask
operator|)
operator|==
operator|(
name|flash
operator|->
name|strapping
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* Found a device match. */
name|sc
operator|->
name|bce_flash_info
operator|=
name|flash
expr_stmt|;
comment|/* Request access to the flash interface. */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
comment|/* Reconfigure the flash interface. */
name|bce_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_CFG1
argument_list|,
name|flash
operator|->
name|config1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_CFG2
argument_list|,
name|flash
operator|->
name|config2
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_CFG3
argument_list|,
name|flash
operator|->
name|config3
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_WRITE1
argument_list|,
name|flash
operator|->
name|write1
argument_list|)
expr_stmt|;
name|bce_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Check if a matching device was found. */
if|if
condition|(
name|j
operator|==
name|entry_count
condition|)
block|{
name|sc
operator|->
name|bce_flash_info
operator|=
name|NULL
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Unknown Flash NVRAM found!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|bce_init_nvram_get_flash_size
label|:
comment|/* Write the flash config data to the shared memory interface. */
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_SHARED_HW_CFG_CONFIG2
argument_list|)
expr_stmt|;
name|val
operator|&=
name|BCE_SHARED_HW_CFG2_NVM_SIZE_MASK
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|sc
operator|->
name|bce_flash_size
operator|=
name|val
expr_stmt|;
else|else
name|sc
operator|->
name|bce_flash_size
operator|=
name|sc
operator|->
name|bce_flash_info
operator|->
name|total_size
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): Found %s, size = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|bce_flash_info
operator|->
name|name
argument_list|,
name|sc
operator|->
name|bce_flash_info
operator|->
name|total_size
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Read an arbitrary range of data from NVRAM.                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Prepares the NVRAM interface for access and reads the requested data     */
end_comment

begin_comment
comment|/* into the supplied buffer.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success and the data read, positive value on failure.             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_read
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|ret_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|u32
name|cmd_flags
decl_stmt|,
name|offset32
decl_stmt|,
name|len32
decl_stmt|,
name|extra
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_size
operator|==
literal|0
condition|)
goto|goto
name|bce_nvram_read_exit
goto|;
comment|/* Request access to the flash interface. */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_read_exit
goto|;
comment|/* Enable access to flash interface */
name|bce_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|len32
operator|=
name|buf_size
expr_stmt|;
name|offset32
operator|=
name|offset
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset32
operator|&
literal|3
condition|)
block|{
name|u8
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|pre_len
decl_stmt|;
name|offset32
operator|&=
operator|~
literal|3
expr_stmt|;
name|pre_len
operator|=
literal|4
operator|-
operator|(
name|offset
operator|&
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|pre_len
operator|>=
name|len32
condition|)
block|{
name|pre_len
operator|=
name|len32
expr_stmt|;
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
operator||
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
block|}
else|else
block|{
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
expr_stmt|;
block|}
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
name|buf
operator|+
operator|(
name|offset
operator|&
literal|3
operator|)
argument_list|,
name|pre_len
argument_list|)
expr_stmt|;
name|offset32
operator|+=
literal|4
expr_stmt|;
name|ret_buf
operator|+=
name|pre_len
expr_stmt|;
name|len32
operator|-=
name|pre_len
expr_stmt|;
block|}
if|if
condition|(
name|len32
operator|&
literal|3
condition|)
block|{
name|extra
operator|=
literal|4
operator|-
operator|(
name|len32
operator|&
literal|3
operator|)
expr_stmt|;
name|len32
operator|=
operator|(
name|len32
operator|+
literal|4
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|len32
operator|==
literal|4
condition|)
block|{
name|u8
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|cmd_flags
condition|)
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
else|else
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
operator||
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
name|buf
argument_list|,
literal|4
operator|-
name|extra
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len32
operator|>
literal|0
condition|)
block|{
name|u8
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Read the first word. */
if|if
condition|(
name|cmd_flags
condition|)
name|cmd_flags
operator|=
literal|0
expr_stmt|;
else|else
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
expr_stmt|;
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|ret_buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
comment|/* Advance to the next dword. */
name|offset32
operator|+=
literal|4
expr_stmt|;
name|ret_buf
operator|+=
literal|4
expr_stmt|;
name|len32
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|len32
operator|>
literal|4
operator|&&
name|rc
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|ret_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Advance to the next dword. */
name|offset32
operator|+=
literal|4
expr_stmt|;
name|ret_buf
operator|+=
literal|4
expr_stmt|;
name|len32
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
goto|goto
name|bce_nvram_read_locked_exit
goto|;
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
name|buf
argument_list|,
literal|4
operator|-
name|extra
argument_list|)
expr_stmt|;
block|}
name|bce_nvram_read_locked_exit
label|:
comment|/* Disable access to flash interface and release the lock. */
name|bce_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_nvram_read_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Write an arbitrary range of data from NVRAM.                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Prepares the NVRAM interface for write access and writes the requested   */
end_comment

begin_comment
comment|/* data from the supplied buffer.  The caller is responsible for            */
end_comment

begin_comment
comment|/* calculating any appropriate CRCs.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|data_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|u32
name|written
decl_stmt|,
name|offset32
decl_stmt|,
name|len32
decl_stmt|;
name|u8
modifier|*
name|buf
decl_stmt|,
name|start
index|[
literal|4
index|]
decl_stmt|,
name|end
index|[
literal|4
index|]
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|align_start
decl_stmt|,
name|align_end
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|buf
operator|=
name|data_buf
expr_stmt|;
name|offset32
operator|=
name|offset
expr_stmt|;
name|len32
operator|=
name|buf_size
expr_stmt|;
name|align_start
operator|=
name|align_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|align_start
operator|=
operator|(
name|offset32
operator|&
literal|3
operator|)
operator|)
condition|)
block|{
name|offset32
operator|&=
operator|~
literal|3
expr_stmt|;
name|len32
operator|+=
name|align_start
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|start
argument_list|,
literal|4
argument_list|)
operator|)
condition|)
goto|goto
name|bce_nvram_write_exit
goto|;
block|}
if|if
condition|(
name|len32
operator|&
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|len32
operator|>
literal|4
operator|)
operator|||
operator|!
name|align_start
condition|)
block|{
name|align_end
operator|=
literal|4
operator|-
operator|(
name|len32
operator|&
literal|3
operator|)
expr_stmt|;
name|len32
operator|+=
name|align_end
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
name|offset32
operator|+
name|len32
operator|-
literal|4
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|bce_nvram_write_exit
goto|;
block|}
block|}
block|}
if|if
condition|(
name|align_start
operator|||
name|align_end
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|len32
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_nvram_write_exit
goto|;
block|}
if|if
condition|(
name|align_start
condition|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align_end
condition|)
block|{
name|memcpy
argument_list|(
name|buf
operator|+
name|len32
operator|-
literal|4
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
operator|+
name|align_start
argument_list|,
name|data_buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
block|}
name|written
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|written
operator|<
name|len32
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
condition|)
block|{
name|u32
name|page_start
decl_stmt|,
name|page_end
decl_stmt|,
name|data_start
decl_stmt|,
name|data_end
decl_stmt|;
name|u32
name|addr
decl_stmt|,
name|cmd_flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u8
name|flash_buffer
index|[
literal|264
index|]
decl_stmt|;
comment|/* Find the page_start addr */
name|page_start
operator|=
name|offset32
operator|+
name|written
expr_stmt|;
name|page_start
operator|-=
operator|(
name|page_start
operator|%
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
expr_stmt|;
comment|/* Find the page_end addr */
name|page_end
operator|=
name|page_start
operator|+
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
expr_stmt|;
comment|/* Find the data_start addr */
name|data_start
operator|=
operator|(
name|written
operator|==
literal|0
operator|)
condition|?
name|offset32
else|:
name|page_start
expr_stmt|;
comment|/* Find the data_end addr */
name|data_end
operator|=
operator|(
name|page_end
operator|>
name|offset32
operator|+
name|len32
operator|)
condition|?
operator|(
name|offset32
operator|+
name|len32
operator|)
else|:
name|page_end
expr_stmt|;
comment|/* Request access to the flash interface. */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_write_exit
goto|;
comment|/* Enable access to flash interface */
name|bce_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|flags
operator|&
name|BCE_NV_BUFFERED
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Read the whole page into the buffer 			 * (non-buffer flash only) */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
condition|;
name|j
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|j
operator|==
operator|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|-
literal|4
operator|)
condition|)
block|{
name|cmd_flags
operator||=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
block|}
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|page_start
operator|+
name|j
argument_list|,
operator|&
name|flash_buffer
index|[
name|j
index|]
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bce_nvram_write_locked_exit
goto|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Enable writes to flash interface (unlock write-protect) */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_enable_nvram_write
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_write_locked_exit
goto|;
comment|/* Erase the page */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_erase_page
argument_list|(
name|sc
argument_list|,
name|page_start
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_write_locked_exit
goto|;
comment|/* Re-enable the write again for the actual write */
name|bce_enable_nvram_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Loop to write back the buffer data from page_start to 		 * data_start */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|flags
operator|&
name|BCE_NV_BUFFERED
operator|)
condition|)
block|{
for|for
control|(
name|addr
operator|=
name|page_start
init|;
name|addr
operator|<
name|data_start
condition|;
name|addr
operator|+=
literal|4
operator|,
name|i
operator|+=
literal|4
control|)
block|{
name|rc
operator|=
name|bce_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|&
name|flash_buffer
index|[
name|i
index|]
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_write_locked_exit
goto|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Loop to write the new data from data_start to data_end */
for|for
control|(
name|addr
operator|=
name|data_start
init|;
name|addr
operator|<
name|data_end
condition|;
name|addr
operator|+=
literal|4
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|addr
operator|==
name|page_end
operator|-
literal|4
operator|)
operator|||
operator|(
operator|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|flags
operator|&
name|BCE_NV_BUFFERED
operator|)
operator|&&
operator|(
name|addr
operator|==
name|data_end
operator|-
literal|4
operator|)
operator|)
condition|)
block|{
name|cmd_flags
operator||=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
block|}
name|rc
operator|=
name|bce_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_write_locked_exit
goto|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Loop to write back the buffer data from data_end 		 * to page_end */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|flags
operator|&
name|BCE_NV_BUFFERED
operator|)
condition|)
block|{
for|for
control|(
name|addr
operator|=
name|data_end
init|;
name|addr
operator|<
name|page_end
condition|;
name|addr
operator|+=
literal|4
operator|,
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|addr
operator|==
name|page_end
operator|-
literal|4
condition|)
block|{
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
block|}
name|rc
operator|=
name|bce_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|&
name|flash_buffer
index|[
name|i
index|]
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_write_locked_exit
goto|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Disable writes to flash interface (lock write-protect) */
name|bce_disable_nvram_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable access to flash interface */
name|bce_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Increment written */
name|written
operator|+=
name|data_end
operator|-
name|data_start
expr_stmt|;
block|}
goto|goto
name|bce_nvram_write_exit
goto|;
name|bce_nvram_write_locked_exit
label|:
name|bce_disable_nvram_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_nvram_write_exit
label|:
if|if
condition|(
name|align_start
operator|||
name|align_end
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BCE_NVRAM_WRITE_SUPPORT */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Verifies that NVRAM is accessible and contains valid data.               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Reads the configuration data from NVRAM and verifies that the CRC is     */
end_comment

begin_comment
comment|/* correct.                                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_test
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|buf
index|[
name|BCE_NVRAM_SIZE
operator|/
literal|4
index|]
decl_stmt|;
name|u8
modifier|*
name|data
init|=
operator|(
name|u8
operator|*
operator|)
name|buf
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|u32
name|magic
decl_stmt|,
name|csum
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_NVRAM
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the device NVRAM is valid by reading 	 * the magic value at offset 0. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Unable to read NVRAM!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_nvram_test_exit
goto|;
block|}
comment|/* 	 * Verify that offset 0 of the NVRAM contains 	 * a valid magic number. 	 */
name|magic
operator|=
name|bce_be32toh
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|BCE_NVRAM_MAGIC
condition|)
block|{
name|rc
operator|=
name|ENODEV
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Invalid NVRAM magic value! "
literal|"Expected: 0x%08X, Found: 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|BCE_NVRAM_MAGIC
argument_list|,
name|magic
argument_list|)
expr_stmt|;
goto|goto
name|bce_nvram_test_exit
goto|;
block|}
comment|/* 	 * Verify that the device NVRAM includes valid 	 * configuration data. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
literal|0x100
argument_list|,
name|data
argument_list|,
name|BCE_NVRAM_SIZE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Unable to read manufacturing "
literal|"Information from  NVRAM!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_nvram_test_exit
goto|;
block|}
name|csum
operator|=
name|ether_crc32_le
argument_list|(
name|data
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|BCE_CRC32_RESIDUAL
condition|)
block|{
name|rc
operator|=
name|ENODEV
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Invalid manufacturing information "
literal|"NVRAM CRC!	Expected: 0x%08X, Found: 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|BCE_CRC32_RESIDUAL
argument_list|,
name|csum
argument_list|)
expr_stmt|;
goto|goto
name|bce_nvram_test_exit
goto|;
block|}
name|csum
operator|=
name|ether_crc32_le
argument_list|(
name|data
operator|+
literal|0x100
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|BCE_CRC32_RESIDUAL
condition|)
block|{
name|rc
operator|=
name|ENODEV
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Invalid feature configuration "
literal|"information NVRAM CRC! Expected: 0x%08X, "
literal|"Found: 08%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|BCE_CRC32_RESIDUAL
argument_list|,
name|csum
argument_list|)
expr_stmt|;
block|}
name|bce_nvram_test_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_NVRAM
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Identifies the current media type of the controller and sets the PHY     */
end_comment

begin_comment
comment|/* address.                                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_get_media
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_PHY
argument_list|)
expr_stmt|;
comment|/* Assume PHY address for copper controllers. */
name|sc
operator|->
name|bce_phy_addr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
condition|)
block|{
name|u32
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_DUAL_MEDIA_CTRL
argument_list|)
decl_stmt|;
name|u32
name|bond_id
init|=
name|val
operator|&
name|BCE_MISC_DUAL_MEDIA_CTRL_BOND_ID
decl_stmt|;
name|u32
name|strap
decl_stmt|;
comment|/* 		 * The BCM5709S is software configurable 		 * for Copper or SerDes operation. 		 */
if|if
condition|(
name|bond_id
operator|==
name|BCE_MISC_DUAL_MEDIA_CTRL_BOND_ID_C
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"5709 bonded "
literal|"for copper.\n"
argument_list|)
expr_stmt|;
goto|goto
name|bce_get_media_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|bond_id
operator|==
name|BCE_MISC_DUAL_MEDIA_CTRL_BOND_ID_S
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"5709 bonded "
literal|"for dual media.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_SERDES_FLAG
expr_stmt|;
goto|goto
name|bce_get_media_exit
goto|;
block|}
if|if
condition|(
name|val
operator|&
name|BCE_MISC_DUAL_MEDIA_CTRL_STRAP_OVERRIDE
condition|)
name|strap
operator|=
operator|(
name|val
operator|&
name|BCE_MISC_DUAL_MEDIA_CTRL_PHY_CTRL
operator|)
operator|>>
literal|21
expr_stmt|;
else|else
name|strap
operator|=
operator|(
name|val
operator|&
name|BCE_MISC_DUAL_MEDIA_CTRL_PHY_CTRL_STRAP
operator|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|pci_get_function
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|strap
condition|)
block|{
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"BCM5709 s/w configured for SerDes.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_SERDES_FLAG
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"BCM5709 s/w configured for Copper.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|strap
condition|)
block|{
case|case
literal|0x1
case|:
case|case
literal|0x2
case|:
case|case
literal|0x4
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"BCM5709 s/w configured for SerDes.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_SERDES_FLAG
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"BCM5709 s/w configured for Copper.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|BCE_CHIP_BOND_ID
argument_list|(
name|sc
argument_list|)
operator|&
name|BCE_CHIP_BOND_ID_SERDES_BIT
condition|)
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_SERDES_FLAG
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_SERDES_FLAG
condition|)
block|{
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_NO_WOL_FLAG
expr_stmt|;
if|if
condition|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
condition|)
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_IEEE_CLAUSE_45_FLAG
expr_stmt|;
if|if
condition|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|!=
name|BCE_CHIP_NUM_5706
condition|)
block|{
comment|/* 5708S/09S/16S use a separate PHY for SerDes. */
name|sc
operator|->
name|bce_phy_addr
operator|=
literal|2
expr_stmt|;
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_SHARED_HW_CFG_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_SHARED_HW_CFG_PHY_2_5G
condition|)
block|{
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_2_5G_CAPABLE_FLAG
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"Found 2.5Gb "
literal|"capable adapter\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5706
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5708
operator|)
condition|)
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_CRC_FIX_FLAG
expr_stmt|;
name|bce_get_media_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BCE_INFO_LOAD
operator||
name|BCE_INFO_PHY
operator|)
argument_list|,
literal|"Using PHY address %d.\n"
argument_list|,
name|sc
operator|->
name|bce_phy_addr
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Performs PHY initialization required before MII drivers access the       */
end_comment

begin_comment
comment|/* device.                                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_media
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_IEEE_CLAUSE_45_FLAG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Configure 5709S/5716S PHYs to use traditional IEEE 		 * Clause 22 method. Otherwise we have no way to attach 		 * the PHY in mii(4) layer. PHY specific configuration 		 * is done in mii layer. 		 */
comment|/* Select auto-negotiation MMD of the PHY. */
name|bce_miibus_write_reg
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|,
name|sc
operator|->
name|bce_phy_addr
argument_list|,
name|BRGPHY_BLOCK_ADDR
argument_list|,
name|BRGPHY_BLOCK_ADDR_ADDR_EXT
argument_list|)
expr_stmt|;
name|bce_miibus_write_reg
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|,
name|sc
operator|->
name|bce_phy_addr
argument_list|,
name|BRGPHY_ADDR_EXT
argument_list|,
name|BRGPHY_ADDR_EXT_AN_MMD
argument_list|)
expr_stmt|;
comment|/* Set IEEE0 block of AN MMD (assumed in brgphy(4) code). */
name|bce_miibus_write_reg
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|,
name|sc
operator|->
name|bce_phy_addr
argument_list|,
name|BRGPHY_BLOCK_ADDR
argument_list|,
name|BRGPHY_BLOCK_ADDR_COMBO_IEEE0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Free any DMA memory owned by the driver.                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Scans through each data structre that requires DMA memory and frees      */
end_comment

begin_comment
comment|/* the memory if allocated.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_dma_free
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_UNLOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* Free, unmap, and destroy the status block. */
if|if
condition|(
name|sc
operator|->
name|status_block
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_block
argument_list|,
name|sc
operator|->
name|status_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status_block
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|status_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|status_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free, unmap, and destroy the statistics block. */
if|if
condition|(
name|sc
operator|->
name|stats_block
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
name|sc
operator|->
name|stats_block
argument_list|,
name|sc
operator|->
name|stats_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats_block
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|stats_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
name|sc
operator|->
name|stats_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
name|sc
operator|->
name|stats_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|stats_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free, unmap and destroy all context memory pages. */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ctx_pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|ctx_block
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|ctx_tag
argument_list|,
name|sc
operator|->
name|ctx_block
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|ctx_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ctx_block
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ctx_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|ctx_tag
argument_list|,
name|sc
operator|->
name|ctx_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|ctx_tag
argument_list|,
name|sc
operator|->
name|ctx_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ctx_map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Destroy the context memory tag. */
if|if
condition|(
name|sc
operator|->
name|ctx_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ctx_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ctx_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Free, unmap and destroy all TX buffer descriptor chain pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Destroy the TX buffer descriptor tag. */
if|if
condition|(
name|sc
operator|->
name|tx_bd_chain_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_bd_chain_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free, unmap and destroy all RX buffer descriptor chain pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Destroy the RX buffer descriptor tag. */
if|if
condition|(
name|sc
operator|->
name|rx_bd_chain_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_bd_chain_tag
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
comment|/* Free, unmap and destroy all page buffer descriptor chain pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PG_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|pg_bd_chain
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|,
name|sc
operator|->
name|pg_bd_chain
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pg_bd_chain
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|,
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|,
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Destroy the page buffer descriptor tag. */
if|if
condition|(
name|sc
operator|->
name|pg_bd_chain_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pg_bd_chain_tag
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Unload and destroy the TX mbuf maps. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_TX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Destroy the TX mbuf tag. */
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_mbuf_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Unload and destroy the RX mbuf maps. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_RX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Destroy the RX mbuf tag. */
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mbuf_tag
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
comment|/* Unload and destroy the page mbuf maps. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_PG_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|pg_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|pg_mbuf_tag
argument_list|,
name|sc
operator|->
name|pg_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|pg_mbuf_tag
argument_list|,
name|sc
operator|->
name|pg_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pg_mbuf_map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Destroy the page mbuf tag. */
if|if
condition|(
name|sc
operator|->
name|pg_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|pg_mbuf_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pg_mbuf_tag
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Destroy the parent tag */
if|if
condition|(
name|sc
operator|->
name|parent_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|parent_tag
operator|=
name|NULL
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_UNLOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Get DMA memory from the OS.                                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Validates that the OS has provided DMA buffers in response to a          */
end_comment

begin_comment
comment|/* bus_dmamap_load() call and saves the physical address of those buffers.  */
end_comment

begin_comment
comment|/* When the callback is used the OS will return 0 for the mapping function  */
end_comment

begin_comment
comment|/* (bus_dmamap_load()) so we use the value of map_arg->maxsegs to pass any  */
end_comment

begin_comment
comment|/* failures back to the caller.                                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|busaddr
init|=
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"%s(): Too many segments returned (%d)!"
operator|,
name|__FUNCTION__
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
comment|/* Simulate a mapping failure. */
name|DBRUNIF
argument_list|(
name|DB_RANDOMTRUE
argument_list|(
name|dma_map_addr_failed_sim_control
argument_list|)
argument_list|,
name|error
operator|=
name|ENOMEM
argument_list|)
expr_stmt|;
comment|/* ToDo: How to increment debug sim_count variable here? */
comment|/* Check for an error and signal the caller that an error occurred. */
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|busaddr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|busaddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allocate any DMA memory needed by the driver.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Allocates DMA memory needed for the various global structures needed by  */
end_comment

begin_comment
comment|/* hardware.                                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Memory alignment requirements:                                           */
end_comment

begin_comment
comment|/* +-----------------+----------+----------+----------+----------+          */
end_comment

begin_comment
comment|/* |                 |   5706   |   5708   |   5709   |   5716   |          */
end_comment

begin_comment
comment|/* +-----------------+----------+----------+----------+----------+          */
end_comment

begin_comment
comment|/* |Status Block     | 8 bytes  | 8 bytes  | 16 bytes | 16 bytes |          */
end_comment

begin_comment
comment|/* |Statistics Block | 8 bytes  | 8 bytes  | 16 bytes | 16 bytes |          */
end_comment

begin_comment
comment|/* |RX Buffers       | 16 bytes | 16 bytes | 16 bytes | 16 bytes |          */
end_comment

begin_comment
comment|/* |PG Buffers       |   none   |   none   |   none   |   none   |          */
end_comment

begin_comment
comment|/* |TX Buffers       |   none   |   none   |   none   |   none   |          */
end_comment

begin_comment
comment|/* |Chain Pages(1)   |   4KiB   |   4KiB   |   4KiB   |   4KiB   |          */
end_comment

begin_comment
comment|/* |Context Memory   |          |          |          |          |          */
end_comment

begin_comment
comment|/* +-----------------+----------+----------+----------+----------+          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* (1) Must align with CPU page size (BCM_PAGE_SZIE).                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_dma_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|bus_size_t
name|max_size
decl_stmt|,
name|max_seg_size
decl_stmt|;
name|int
name|max_segments
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the parent bus DMA tag appropriate for PCI. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|parent_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate parent DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
comment|/* 	 * Create a DMA tag for the status block, allocate and clear the 	 * memory, map the memory into DMA space, and fetch the physical 	 * address of the block. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
name|BCE_DMA_ALIGN
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BCE_STATUS_BLK_SZ
argument_list|,
literal|1
argument_list|,
name|BCE_STATUS_BLK_SZ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|status_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate status block "
literal|"DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|status_block
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|status_map
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate status block "
literal|"DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|,
name|sc
operator|->
name|status_block
argument_list|,
name|BCE_STATUS_BLK_SZ
argument_list|,
name|bce_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|status_block_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not map status block "
literal|"DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): status_block_paddr = 0x%jX\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|status_block_paddr
argument_list|)
expr_stmt|;
comment|/* 	 * Create a DMA tag for the statistics block, allocate and clear the 	 * memory, map the memory into DMA space, and fetch the physical 	 * address of the block. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
name|BCE_DMA_ALIGN
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BCE_STATS_BLK_SZ
argument_list|,
literal|1
argument_list|,
name|BCE_STATS_BLK_SZ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|stats_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate statistics block "
literal|"DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|stats_block
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|stats_map
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate statistics block "
literal|"DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
name|sc
operator|->
name|stats_map
argument_list|,
name|sc
operator|->
name|stats_block
argument_list|,
name|BCE_STATS_BLK_SZ
argument_list|,
name|bce_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|stats_block_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not map statistics block "
literal|"DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): stats_block_paddr = 0x%jX\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|stats_block_paddr
argument_list|)
expr_stmt|;
comment|/* BCM5709 uses host memory as cache for context memory. */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|sc
operator|->
name|ctx_pages
operator|=
literal|0x2000
operator|/
name|BCM_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ctx_pages
operator|==
literal|0
condition|)
name|sc
operator|->
name|ctx_pages
operator|=
literal|1
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|ctx_pages
operator|>
literal|512
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Too many CTX pages! %d> 512\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|ctx_pages
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Create a DMA tag for the context pages, 		 * allocate and clear the memory, map the 		 * memory into DMA space, and fetch the 		 * physical address of the block. 		 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|ctx_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate CTX "
literal|"DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ctx_pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|ctx_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ctx_block
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|ctx_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate CTX "
literal|"DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|ctx_tag
argument_list|,
name|sc
operator|->
name|ctx_map
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|ctx_block
index|[
name|i
index|]
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
name|bce_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|ctx_paddr
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not map CTX "
literal|"DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): ctx_paddr[%d] "
literal|"= 0x%jX\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|ctx_paddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Create a DMA tag for the TX buffer descriptor chain, 	 * allocate and clear the  memory, and fetch the 	 * physical address of the block. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BCE_TX_CHAIN_PAGE_SZ
argument_list|,
literal|1
argument_list|,
name|BCE_TX_CHAIN_PAGE_SZ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate TX descriptor "
literal|"chain DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate TX descriptor "
literal|"chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_TX_CHAIN_PAGE_SZ
argument_list|,
name|bce_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not map TX descriptor "
literal|"chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): tx_bd_chain_paddr[%d] = "
literal|"0x%jX\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Check the required size before mapping to conserve resources. */
if|if
condition|(
name|bce_tso_enable
condition|)
block|{
name|max_size
operator|=
name|BCE_TSO_MAX_SIZE
expr_stmt|;
name|max_segments
operator|=
name|BCE_MAX_SEGMENTS
expr_stmt|;
name|max_seg_size
operator|=
name|BCE_TSO_MAX_SEG_SIZE
expr_stmt|;
block|}
else|else
block|{
name|max_size
operator|=
name|MCLBYTES
operator|*
name|BCE_MAX_SEGMENTS
expr_stmt|;
name|max_segments
operator|=
name|BCE_MAX_SEGMENTS
expr_stmt|;
name|max_seg_size
operator|=
name|MCLBYTES
expr_stmt|;
block|}
comment|/* Create a DMA tag for TX mbufs. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
literal|1
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|max_size
argument_list|,
name|max_segments
argument_list|,
name|max_seg_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tx_mbuf_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate TX mbuf DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
comment|/* Create DMA maps for the TX mbufs clusters. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_TX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create TX mbuf DMA "
literal|"map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
block|}
comment|/* 	 * Create a DMA tag for the RX buffer descriptor chain, 	 * allocate and clear the memory, and fetch the physical 	 * address of the blocks. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|,
literal|1
argument_list|,
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate RX descriptor chain "
literal|"DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate RX descriptor "
literal|"chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|,
name|bce_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not map RX descriptor "
literal|"chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): rx_bd_chain_paddr[%d] = "
literal|"0x%jX\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create a DMA tag for RX mbufs. 	 */
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|max_size
operator|=
name|max_seg_size
operator|=
operator|(
operator|(
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|<
name|MCLBYTES
operator|)
condition|?
name|MCLBYTES
else|:
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|)
expr_stmt|;
else|#
directive|else
name|max_size
operator|=
name|max_seg_size
operator|=
name|MJUM9BYTES
expr_stmt|;
endif|#
directive|endif
name|max_segments
operator|=
literal|1
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): Creating rx_mbuf_tag "
literal|"(max size = 0x%jX max segments = %d, max segment "
literal|"size = 0x%jX)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|max_size
argument_list|,
name|max_segments
argument_list|,
operator|(
name|uintmax_t
operator|)
name|max_seg_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
name|BCE_RX_BUF_ALIGN
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|max_size
argument_list|,
name|max_segments
argument_list|,
name|max_seg_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rx_mbuf_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate RX mbuf DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
comment|/* Create DMA maps for the RX mbuf clusters. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_RX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create RX mbuf "
literal|"DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
comment|/* 	 * Create a DMA tag for the page buffer descriptor chain, 	 * allocate and clear the memory, and fetch the physical 	 * address of the blocks. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BCE_PG_CHAIN_PAGE_SZ
argument_list|,
literal|1
argument_list|,
name|BCE_PG_CHAIN_PAGE_SZ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate page descriptor "
literal|"chain DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PG_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|pg_bd_chain
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate page "
literal|"descriptor chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|,
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|pg_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_PG_CHAIN_PAGE_SZ
argument_list|,
name|bce_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|pg_bd_chain_paddr
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not map page descriptor "
literal|"chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): pg_bd_chain_paddr[%d] = "
literal|"0x%jX\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pg_bd_chain_paddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create a DMA tag for page mbufs. 	 */
name|max_size
operator|=
name|max_seg_size
operator|=
operator|(
operator|(
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
operator|<
name|MCLBYTES
operator|)
condition|?
name|MCLBYTES
else|:
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
operator|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
literal|1
argument_list|,
name|BCE_DMA_BOUNDARY
argument_list|,
name|sc
operator|->
name|max_bus_addr
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|max_size
argument_list|,
literal|1
argument_list|,
name|max_seg_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|pg_mbuf_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate page mbuf "
literal|"DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
comment|/* Create DMA maps for the page mbuf clusters. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_PG_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|pg_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|pg_mbuf_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create page mbuf "
literal|"DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
block|}
endif|#
directive|endif
name|bce_dma_alloc_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Release all resources used by the driver.                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Releases all resources acquired by the driver including interrupts,      */
end_comment

begin_comment
comment|/* interrupt handler, interfaces, mutexes, and DMA memory.                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_release_resources
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|bce_dev
expr_stmt|;
name|bce_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_intrhand
operator|!=
name|NULL
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Removing interrupt handler.\n"
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bce_res_irq
argument_list|,
name|sc
operator|->
name|bce_intrhand
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_res_irq
operator|!=
name|NULL
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Releasing IRQ.\n"
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|bce_irq_rid
argument_list|,
name|sc
operator|->
name|bce_res_irq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
operator|(
name|BCE_USING_MSI_FLAG
operator||
name|BCE_USING_MSIX_FLAG
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Releasing MSI/MSI-X vector.\n"
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_res_mem
operator|!=
name|NULL
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Releasing PCI memory.\n"
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|bce_res_mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_ifp
operator|!=
name|NULL
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Releasing IF.\n"
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|bce_ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|bce_mtx
argument_list|)
condition|)
name|BCE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Firmware synchronization.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Before performing certain events such as a chip reset, synchronize with  */
end_comment

begin_comment
comment|/* the firmware first.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_fw_sync
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|msg_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Don't waste any time if we've timed out before. */
if|if
condition|(
name|sc
operator|->
name|bce_fw_timed_out
operator|==
name|TRUE
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bce_fw_sync_exit
goto|;
block|}
comment|/* Increment the message sequence number. */
name|sc
operator|->
name|bce_fw_wr_seq
operator|++
expr_stmt|;
name|msg_data
operator||=
name|sc
operator|->
name|bce_fw_wr_seq
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_FIRMWARE
argument_list|,
literal|"bce_fw_sync(): msg_data = "
literal|"0x%08X\n"
argument_list|,
name|msg_data
argument_list|)
expr_stmt|;
comment|/* Send the message to the bootcode driver mailbox. */
name|bce_shmem_wr
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MB
argument_list|,
name|msg_data
argument_list|)
expr_stmt|;
comment|/* Wait for the bootcode to acknowledge the message. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FW_ACK_TIME_OUT_MS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check for a response in the bootcode firmware mailbox. */
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_FW_MB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_FW_MSG_ACK
operator|)
operator|==
operator|(
name|msg_data
operator|&
name|BCE_DRV_MSG_SEQ
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* If we've timed out, tell bootcode that we've stopped waiting. */
if|if
condition|(
operator|(
operator|(
name|val
operator|&
name|BCE_FW_MSG_ACK
operator|)
operator|!=
operator|(
name|msg_data
operator|&
name|BCE_DRV_MSG_SEQ
operator|)
operator|)
operator|&&
operator|(
operator|(
name|msg_data
operator|&
name|BCE_DRV_MSG_DATA
operator|)
operator|!=
name|BCE_DRV_MSG_DATA_WAIT0
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Firmware synchronization timeout! "
literal|"msg_data = 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|msg_data
argument_list|)
expr_stmt|;
name|msg_data
operator|&=
operator|~
name|BCE_DRV_MSG_CODE
expr_stmt|;
name|msg_data
operator||=
name|BCE_DRV_MSG_CODE_FW_TIMEOUT
expr_stmt|;
name|bce_shmem_wr
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MB
argument_list|,
name|msg_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_fw_timed_out
operator|=
name|TRUE
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|bce_fw_sync_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Load Receive Virtual 2 Physical (RV2P) processor firmware.               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_load_rv2p_fw
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
modifier|*
name|rv2p_code
parameter_list|,
name|u32
name|rv2p_code_len
parameter_list|,
name|u32
name|rv2p_proc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Set the page size used by RV2P. */
if|if
condition|(
name|rv2p_proc
operator|==
name|RV2P_PROC2
condition|)
block|{
name|BCE_RV2P_PROC2_CHG_MAX_BD_PAGE
argument_list|(
name|USABLE_RX_BD_PER_PAGE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rv2p_code_len
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_INSTR_HIGH
argument_list|,
operator|*
name|rv2p_code
argument_list|)
expr_stmt|;
name|rv2p_code
operator|++
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_INSTR_LOW
argument_list|,
operator|*
name|rv2p_code
argument_list|)
expr_stmt|;
name|rv2p_code
operator|++
expr_stmt|;
if|if
condition|(
name|rv2p_proc
operator|==
name|RV2P_PROC1
condition|)
block|{
name|val
operator|=
operator|(
name|i
operator|/
literal|8
operator|)
operator||
name|BCE_RV2P_PROC1_ADDR_CMD_RDWR
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_PROC1_ADDR_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
name|i
operator|/
literal|8
operator|)
operator||
name|BCE_RV2P_PROC2_ADDR_CMD_RDWR
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_PROC2_ADDR_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset the processor, un-stall is done later. */
if|if
condition|(
name|rv2p_proc
operator|==
name|RV2P_PROC1
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_COMMAND
argument_list|,
name|BCE_RV2P_COMMAND_PROC1_RESET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_COMMAND
argument_list|,
name|BCE_RV2P_COMMAND_PROC2_RESET
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Load RISC processor firmware.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Loads firmware from the file if_bcefw.h into the scratchpad memory       */
end_comment

begin_comment
comment|/* associated with a particular processor.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_load_cpu_fw
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cpu_reg
modifier|*
name|cpu_reg
parameter_list|,
name|struct
name|fw_info
modifier|*
name|fw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|bce_halt_cpu
argument_list|(
name|sc
argument_list|,
name|cpu_reg
argument_list|)
expr_stmt|;
comment|/* Load the Text area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|text_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|text
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|text_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|text
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load the Data area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|data_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|data
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|data_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load the SBSS area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|sbss_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|sbss
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|sbss_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|sbss
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load the BSS area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|bss_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|bss
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|bss_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|bss
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load the Read-Only area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|rodata_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|rodata
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|rodata_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|rodata
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear the pre-fetch instruction and set the FW start address. */
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|inst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|pc
argument_list|,
name|fw
operator|->
name|start_addr
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Starts the RISC processor.                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Assumes the CPU starting address has already been set.                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_start_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cpu_reg
modifier|*
name|cpu_reg
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Start the CPU. */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|mode
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|cpu_reg
operator|->
name|mode_value_halt
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|state
argument_list|,
name|cpu_reg
operator|->
name|state_value_clear
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Halts the RISC processor.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_halt_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cpu_reg
modifier|*
name|cpu_reg
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Halt the CPU. */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|mode
argument_list|)
expr_stmt|;
name|val
operator||=
name|cpu_reg
operator|->
name|mode_value_halt
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|state
argument_list|,
name|cpu_reg
operator|->
name|state_value_clear
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the RX CPU.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_start_rxp_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cpu_reg
name|cpu_reg
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_RXP_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_RXP_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_RXP_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_RXP_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_RXP_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_RXP_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_RXP_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_RXP_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_RXP_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_RXP_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Starting RX firmware.\n"
argument_list|)
expr_stmt|;
name|bce_start_cpu
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the RX CPU.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_rxp_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cpu_reg
name|cpu_reg
decl_stmt|;
name|struct
name|fw_info
name|fw
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_RXP_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_RXP_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_RXP_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_RXP_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_RXP_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_RXP_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_RXP_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_RXP_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_RXP_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_RXP_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_RXP_b09FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_RXP_b09FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_RXP_b09FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_RXP_b09FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_RXP_b09FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_RXP_b09FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_RXP_b09FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_RXP_b09FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_RXP_b09FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_RXP_b09FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_RXP_b09FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_RXP_b09FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_RXP_b09FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_RXP_b09FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_RXP_b09FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_RXP_b09FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_RXP_b09FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_RXP_b09FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_RXP_b09FwRodata
expr_stmt|;
block|}
else|else
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_RXP_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_RXP_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_RXP_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_RXP_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_RXP_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_RXP_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_RXP_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_RXP_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_RXP_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_RXP_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_RXP_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_RXP_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_RXP_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_RXP_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_RXP_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_RXP_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_RXP_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_RXP_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_RXP_b06FwRodata
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading RX firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
comment|/* Delay RXP start until initialization is complete. */
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the TX CPU.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_txp_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cpu_reg
name|cpu_reg
decl_stmt|;
name|struct
name|fw_info
name|fw
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_TXP_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_TXP_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_TXP_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_TXP_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_TXP_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_TXP_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_TXP_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_TXP_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_TXP_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_TXP_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_TXP_b09FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_TXP_b09FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_TXP_b09FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_TXP_b09FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_TXP_b09FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_TXP_b09FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_TXP_b09FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_TXP_b09FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_TXP_b09FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_TXP_b09FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_TXP_b09FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_TXP_b09FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_TXP_b09FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_TXP_b09FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_TXP_b09FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_TXP_b09FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_TXP_b09FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_TXP_b09FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_TXP_b09FwRodata
expr_stmt|;
block|}
else|else
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_TXP_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_TXP_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_TXP_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_TXP_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_TXP_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_TXP_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_TXP_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_TXP_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_TXP_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_TXP_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_TXP_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_TXP_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_TXP_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_TXP_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_TXP_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_TXP_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_TXP_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_TXP_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_TXP_b06FwRodata
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading TX firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
name|bce_start_cpu
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the TPAT CPU.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_tpat_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cpu_reg
name|cpu_reg
decl_stmt|;
name|struct
name|fw_info
name|fw
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_TPAT_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_TPAT_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_TPAT_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_TPAT_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_TPAT_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_TPAT_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_TPAT_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_TPAT_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_TPAT_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_TPAT_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_TPAT_b09FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_TPAT_b09FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_TPAT_b09FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_TPAT_b09FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_TPAT_b09FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_TPAT_b09FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_TPAT_b09FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_TPAT_b09FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_TPAT_b09FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_TPAT_b09FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_TPAT_b09FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_TPAT_b09FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_TPAT_b09FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_TPAT_b09FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_TPAT_b09FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_TPAT_b09FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_TPAT_b09FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_TPAT_b09FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_TPAT_b09FwRodata
expr_stmt|;
block|}
else|else
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_TPAT_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_TPAT_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_TPAT_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_TPAT_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_TPAT_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_TPAT_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_TPAT_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_TPAT_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_TPAT_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_TPAT_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_TPAT_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_TPAT_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_TPAT_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_TPAT_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_TPAT_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_TPAT_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_TPAT_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_TPAT_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_TPAT_b06FwRodata
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading TPAT firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
name|bce_start_cpu
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the CP CPU.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_cp_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cpu_reg
name|cpu_reg
decl_stmt|;
name|struct
name|fw_info
name|fw
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_CP_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_CP_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_CP_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_CP_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_CP_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_CP_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_CP_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_CP_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_CP_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_CP_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_CP_b09FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_CP_b09FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_CP_b09FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_CP_b09FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_CP_b09FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_CP_b09FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_CP_b09FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_CP_b09FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_CP_b09FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_CP_b09FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_CP_b09FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_CP_b09FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_CP_b09FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_CP_b09FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_CP_b09FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_CP_b09FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_CP_b09FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_CP_b09FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_CP_b09FwRodata
expr_stmt|;
block|}
else|else
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_CP_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_CP_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_CP_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_CP_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_CP_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_CP_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_CP_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_CP_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_CP_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_CP_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_CP_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_CP_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_CP_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_CP_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_CP_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_CP_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_CP_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_CP_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_CP_b06FwRodata
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading CP firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
name|bce_start_cpu
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the COM CPU.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_com_cpu
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cpu_reg
name|cpu_reg
decl_stmt|;
name|struct
name|fw_info
name|fw
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_COM_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_COM_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_COM_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_COM_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_COM_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_COM_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_COM_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_COM_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_COM_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_COM_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_COM_b09FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_COM_b09FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_COM_b09FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_COM_b09FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_COM_b09FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_COM_b09FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_COM_b09FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_COM_b09FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_COM_b09FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_COM_b09FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_COM_b09FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_COM_b09FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_COM_b09FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_COM_b09FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_COM_b09FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_COM_b09FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_COM_b09FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_COM_b09FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_COM_b09FwRodata
expr_stmt|;
block|}
else|else
block|{
name|fw
operator|.
name|ver_major
operator|=
name|bce_COM_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_COM_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_COM_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_COM_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_COM_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_COM_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_COM_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_COM_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_COM_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_COM_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_COM_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_COM_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_COM_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_COM_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_COM_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_COM_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_COM_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_COM_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_COM_b06FwRodata
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading COM firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
name|bce_start_cpu
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the RV2P, RX, TX, TPAT, COM, and CP CPUs.                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Loads the firmware for each CPU and starts the CPU.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_cpus
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|BCE_CHIP_REV
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_REV_Ax
operator|)
condition|)
block|{
name|bce_load_rv2p_fw
argument_list|(
name|sc
argument_list|,
name|bce_xi90_rv2p_proc1
argument_list|,
sizeof|sizeof
argument_list|(
name|bce_xi90_rv2p_proc1
argument_list|)
argument_list|,
name|RV2P_PROC1
argument_list|)
expr_stmt|;
name|bce_load_rv2p_fw
argument_list|(
name|sc
argument_list|,
name|bce_xi90_rv2p_proc2
argument_list|,
sizeof|sizeof
argument_list|(
name|bce_xi90_rv2p_proc2
argument_list|)
argument_list|,
name|RV2P_PROC2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bce_load_rv2p_fw
argument_list|(
name|sc
argument_list|,
name|bce_xi_rv2p_proc1
argument_list|,
sizeof|sizeof
argument_list|(
name|bce_xi_rv2p_proc1
argument_list|)
argument_list|,
name|RV2P_PROC1
argument_list|)
expr_stmt|;
name|bce_load_rv2p_fw
argument_list|(
name|sc
argument_list|,
name|bce_xi_rv2p_proc2
argument_list|,
sizeof|sizeof
argument_list|(
name|bce_xi_rv2p_proc2
argument_list|)
argument_list|,
name|RV2P_PROC2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bce_load_rv2p_fw
argument_list|(
name|sc
argument_list|,
name|bce_rv2p_proc1
argument_list|,
sizeof|sizeof
argument_list|(
name|bce_rv2p_proc1
argument_list|)
argument_list|,
name|RV2P_PROC1
argument_list|)
expr_stmt|;
name|bce_load_rv2p_fw
argument_list|(
name|sc
argument_list|,
name|bce_rv2p_proc2
argument_list|,
sizeof|sizeof
argument_list|(
name|bce_rv2p_proc2
argument_list|)
argument_list|,
name|RV2P_PROC2
argument_list|)
expr_stmt|;
block|}
name|bce_init_rxp_cpu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_init_txp_cpu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_init_tpat_cpu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_init_com_cpu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_init_cp_cpu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize context memory.                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Clears the memory associated with each Context ID (CID).                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_init_ctx
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|,
name|val
decl_stmt|,
name|vcid_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rc
decl_stmt|,
name|retry_cnt
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|retry_cnt
operator|=
name|CTX_INIT_RETRY_COUNT
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_CTX
argument_list|,
literal|"Initializing 5709 context.\n"
argument_list|)
expr_stmt|;
comment|/* 		 * BCM5709 context memory may be cached 		 * in host memory so prepare the host memory 		 * for access. 		 */
name|val
operator|=
name|BCE_CTX_COMMAND_ENABLED
operator||
name|BCE_CTX_COMMAND_MEM_INIT
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|val
operator||=
operator|(
name|BCM_PAGE_BITS
operator|-
literal|8
operator|)
operator|<<
literal|16
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Wait for mem init command to complete. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retry_cnt
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|BCE_CTX_COMMAND_MEM_INIT
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_CTX_COMMAND_MEM_INIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(): Context memory initialization failed!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|init_ctx_fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ctx_pages
condition|;
name|i
operator|++
control|)
block|{
comment|/* Set the physical address of the context memory. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_HOST_PAGE_TBL_DATA0
argument_list|,
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|ctx_paddr
index|[
name|i
index|]
operator|&
literal|0xfffffff0
argument_list|)
operator||
name|BCE_CTX_HOST_PAGE_TBL_DATA0_VALID
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_HOST_PAGE_TBL_DATA1
argument_list|,
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|ctx_paddr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_HOST_PAGE_TBL_CTRL
argument_list|,
name|i
operator||
name|BCE_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ
argument_list|)
expr_stmt|;
comment|/* Verify the context memory write was successful. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|retry_cnt
condition|;
name|j
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_HOST_PAGE_TBL_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(): Failed to initialize "
literal|"context page %d!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|init_ctx_fail
goto|;
block|}
block|}
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Initializing 5706/5708 context.\n"
argument_list|)
expr_stmt|;
comment|/* 		 * For the 5706/5708, context memory is local to 		 * the controller, so initialize the controller 		 * context memory. 		 */
name|vcid_addr
operator|=
name|GET_CID_ADDR
argument_list|(
literal|96
argument_list|)
expr_stmt|;
while|while
condition|(
name|vcid_addr
condition|)
block|{
name|vcid_addr
operator|-=
name|PHY_CTX_SIZE
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_VIRT_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_PAGE_TBL
argument_list|,
name|vcid_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|PHY_CTX_SIZE
condition|;
name|offset
operator|+=
literal|4
control|)
block|{
name|CTX_WR
argument_list|(
name|sc
argument_list|,
literal|0x00
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_VIRT_ADDR
argument_list|,
name|vcid_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_PAGE_TBL
argument_list|,
name|vcid_addr
argument_list|)
expr_stmt|;
block|}
block|}
name|init_ctx_fail
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Fetch the permanent MAC address of the controller.                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_get_mac_addr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|mac_lo
init|=
literal|0
decl_stmt|,
name|mac_hi
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * The NetXtreme II bootcode populates various NIC 	 * power-on and runtime configuration items in a 	 * shared memory area.  The factory configured MAC 	 * address is available from both NVRAM and the 	 * shared memory area so we'll read the value from 	 * shared memory for speed. 	 */
name|mac_hi
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_PORT_HW_CFG_MAC_UPPER
argument_list|)
expr_stmt|;
name|mac_lo
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_PORT_HW_CFG_MAC_LOWER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mac_lo
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mac_hi
operator|==
literal|0
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Invalid Ethernet address!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|eaddr
index|[
literal|0
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_hi
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|1
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_hi
operator|>>
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|2
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|3
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|4
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|5
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|0
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_MISC
argument_list|,
literal|"Permanent Ethernet "
literal|"address = %6D\n"
argument_list|,
name|sc
operator|->
name|eaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Program the MAC address.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_set_mac_addr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|u8
modifier|*
name|mac_addr
init|=
name|sc
operator|->
name|eaddr
decl_stmt|;
comment|/* ToDo: Add support for setting multiple MAC addresses. */
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_MISC
argument_list|,
literal|"Setting Ethernet address = "
literal|"%6D\n"
argument_list|,
name|sc
operator|->
name|eaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|mac_addr
index|[
literal|1
index|]
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MAC_MATCH0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|mac_addr
index|[
literal|5
index|]
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MAC_MATCH1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Stop the controller.                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_stop
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|bce_tick_callout
argument_list|)
expr_stmt|;
comment|/* Disable the transmit/receive blocks. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS
argument_list|,
name|BCE_MISC_ENABLE_CLR_DEFAULT
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|bce_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free RX buffers. */
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|bce_free_pg_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bce_free_rx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free TX buffers. */
name|bce_free_tx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|watchdog_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_link_up
operator|=
name|FALSE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bce_reset
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|reset_code
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"%s(): reset_code = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reset_code
argument_list|)
expr_stmt|;
comment|/* Wait for pending PCI transactions to complete. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS_TX_DMA_ENABLE
operator||
name|BCE_MISC_ENABLE_CLR_BITS_DMA_ENGINE_ENABLE
operator||
name|BCE_MISC_ENABLE_CLR_BITS_RX_DMA_ENABLE
operator||
name|BCE_MISC_ENABLE_CLR_BITS_HOST_COALESCE_ENABLE
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Disable DMA */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_NEW_CORE_CTL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|BCE_MISC_NEW_CORE_CTL_DMA_ENABLE
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_NEW_CORE_CTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Assume bootcode is running. */
name|sc
operator|->
name|bce_fw_timed_out
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|bce_drv_cardiac_arrest
operator|=
name|FALSE
expr_stmt|;
comment|/* Give the firmware a chance to prepare for the reset. */
name|rc
operator|=
name|bce_fw_sync
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_DATA_WAIT0
operator||
name|reset_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bce_reset_exit
goto|;
comment|/* Set a firmware reminder that this is a soft reset. */
name|bce_shmem_wr
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_RESET_SIGNATURE
argument_list|,
name|BCE_DRV_RESET_SIGNATURE_MAGIC
argument_list|)
expr_stmt|;
comment|/* Dummy read to force the chip to complete all current transactions. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ID
argument_list|)
expr_stmt|;
comment|/* Chip reset. */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_COMMAND
argument_list|,
name|BCE_MISC_COMMAND_SW_RESET
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_COMMAND
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_PCICFG_MISC_CONFIG_REG_WINDOW_ENA
operator||
name|BCE_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|,
name|BCE_PCICFG_MISC_CONFIG
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_REQ
operator||
name|BCE_PCICFG_MISC_CONFIG_REG_WINDOW_ENA
operator||
name|BCE_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_MISC_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Allow up to 30us for reset to complete. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_MISC_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_REQ
operator||
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_BSY
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Check that reset completed successfully. */
if|if
condition|(
name|val
operator|&
operator|(
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_REQ
operator||
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_BSY
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Reset failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bce_reset_exit
goto|;
block|}
block|}
comment|/* Make sure byte swapping is properly configured. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCI_SWAP_DIAG0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0x01020304
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Byte swap is incorrect!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_reset_exit
goto|;
block|}
comment|/* Just completed a reset, assume that firmware is running again. */
name|sc
operator|->
name|bce_fw_timed_out
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|bce_drv_cardiac_arrest
operator|=
name|FALSE
expr_stmt|;
comment|/* Wait for the firmware to finish its initialization. */
name|rc
operator|=
name|bce_fw_sync
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_DATA_WAIT1
operator||
name|reset_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Firmware did not complete "
literal|"initialization!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|bce_reset_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bce_chipinit
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|bce_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize DMA byte/word swapping, configure the number of DMA 	 * channels and PCI clock compensation delay. 	 */
name|val
operator|=
name|BCE_DMA_CONFIG_DATA_BYTE_SWAP
operator||
name|BCE_DMA_CONFIG_DATA_WORD_SWAP
operator||
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|BCE_DMA_CONFIG_CNTL_BYTE_SWAP
operator||
endif|#
directive|endif
name|BCE_DMA_CONFIG_CNTL_WORD_SWAP
operator||
name|DMA_READ_CHANS
operator|<<
literal|12
operator||
name|DMA_WRITE_CHANS
operator|<<
literal|16
expr_stmt|;
name|val
operator||=
operator|(
literal|0x2
operator|<<
literal|20
operator|)
operator||
name|BCE_DMA_CONFIG_CNTL_PCI_COMP_DLY
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCIX_FLAG
operator|)
operator|&&
operator|(
name|sc
operator|->
name|bus_speed_mhz
operator|==
literal|133
operator|)
condition|)
name|val
operator||=
name|BCE_DMA_CONFIG_PCI_FAST_CLK_CMP
expr_stmt|;
comment|/* 	 * This setting resolves a problem observed on certain Intel PCI 	 * chipsets that cannot handle multiple outstanding DMA operations. 	 * See errata E9_5706A1_65. 	 */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5706
operator|)
operator|&&
operator|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|!=
name|BCE_CHIP_ID_5706_A0
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCIX_FLAG
operator|)
condition|)
name|val
operator||=
name|BCE_DMA_CONFIG_CNTL_PING_PONG_DMA
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_DMA_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Enable the RX_V2P and Context state machines before access. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS_HOST_COALESCE_ENABLE
operator||
name|BCE_MISC_ENABLE_STATUS_BITS_RX_V2P_ENABLE
operator||
name|BCE_MISC_ENABLE_STATUS_BITS_CONTEXT_ENABLE
argument_list|)
expr_stmt|;
comment|/* Initialize context mapping and zero out the quick contexts. */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_init_ctx
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bce_chipinit_exit
goto|;
comment|/* Initialize the on-boards CPUs */
name|bce_init_cpus
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable management frames (NC-SI) to flow to the MCP. */
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_MFW_ENABLE_FLAG
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_MGMT_PKT_CTRL
argument_list|)
operator||
name|BCE_RPM_MGMT_PKT_CTRL_MGMT_EN
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_MGMT_PKT_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare NVRAM for access. */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_init_nvram
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bce_chipinit_exit
goto|;
comment|/* Set the kernel bypass block size */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|BCE_MQ_CONFIG_KNL_BYP_BLK_SIZE
expr_stmt|;
name|val
operator||=
name|BCE_MQ_CONFIG_KNL_BYP_BLK_SIZE_256
expr_stmt|;
comment|/* Enable bins used on the 5709. */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|val
operator||=
name|BCE_MQ_CONFIG_BIN_MQ_MODE
expr_stmt|;
if|if
condition|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_ID_5709_A1
condition|)
name|val
operator||=
name|BCE_MQ_CONFIG_HALT_DIS
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x10000
operator|+
operator|(
name|MAX_CID_CNT
operator|*
name|MB_KERNEL_CTX_SIZE
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_KNL_BYP_WIND_START
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_KNL_WIND_END
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set the page size and clear the RV2P processor stall bits. */
name|val
operator|=
operator|(
name|BCM_PAGE_BITS
operator|-
literal|8
operator|)
operator|<<
literal|24
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Configure page size. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TBDR_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|BCE_TBDR_CONFIG_PAGE_SIZE
expr_stmt|;
name|val
operator||=
operator|(
name|BCM_PAGE_BITS
operator|-
literal|8
operator|)
operator|<<
literal|24
operator||
literal|0x40
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_TBDR_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set the perfect match control register to default. */
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_PM_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bce_chipinit_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the controller in preparation to send/receive traffic.        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_blockinit
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Load the hardware default MAC address. */
name|bce_set_mac_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set the Ethernet backoff seed value */
name|val
operator|=
name|sc
operator|->
name|eaddr
index|[
literal|0
index|]
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|3
index|]
operator|)
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_BACKOFF_SEED
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_status_idx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_mode
operator|=
name|BCE_EMAC_RX_MODE_SORT_MODE
expr_stmt|;
comment|/* Set up link change interrupt generation. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_ATTENTION_ENA
argument_list|,
name|BCE_EMAC_ATTENTION_ENA_LINK
argument_list|)
expr_stmt|;
comment|/* Program the physical address of the status block. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATUS_ADDR_L
argument_list|,
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|status_block_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATUS_ADDR_H
argument_list|,
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|status_block_paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Program the physical address of the statistics block. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATISTICS_ADDR_L
argument_list|,
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|stats_block_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATISTICS_ADDR_H
argument_list|,
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|stats_block_paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Program various host coalescing parameters. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_TX_QUICK_CONS_TRIP
argument_list|,
operator|(
name|sc
operator|->
name|bce_tx_quick_cons_trip_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_tx_quick_cons_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_RX_QUICK_CONS_TRIP
argument_list|,
operator|(
name|sc
operator|->
name|bce_rx_quick_cons_trip_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_rx_quick_cons_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMP_PROD_TRIP
argument_list|,
operator|(
name|sc
operator|->
name|bce_comp_prod_trip_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_comp_prod_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_TX_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_tx_ticks_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_tx_ticks
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_RX_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_rx_ticks_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_rx_ticks
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COM_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_com_ticks_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_com_ticks
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_CMD_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_cmd_ticks_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_cmd_ticks
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATS_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_stats_ticks
operator|&
literal|0xffff00
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_COLLECT_TICKS
argument_list|,
literal|0xbb8
argument_list|)
expr_stmt|;
comment|/* 3ms */
comment|/* Configure the Host Coalescing block. */
name|val
operator|=
name|BCE_HC_CONFIG_RX_TMR_MODE
operator||
name|BCE_HC_CONFIG_TX_TMR_MODE
operator||
name|BCE_HC_CONFIG_COLLECT_STATS
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ToDo: Add MSI-X support. */
block|if (sc->bce_flags& BCE_USING_MSIX_FLAG) { 		u32 base = ((BCE_TX_VEC - 1) * BCE_HC_SB_CONFIG_SIZE) + 		    BCE_HC_SB_CONFIG_1;  		REG_WR(sc, BCE_HC_MSIX_BIT_VECTOR, BCE_HC_MSIX_BIT_VECTOR_VAL);  		REG_WR(sc, base, BCE_HC_SB_CONFIG_1_TX_TMR_MODE | 		    BCE_HC_SB_CONFIG_1_ONE_SHOT);  		REG_WR(sc, base + BCE_HC_TX_QUICK_CONS_TRIP_OFF, 		    (sc->tx_quick_cons_trip_int<< 16) | 		     sc->tx_quick_cons_trip);  		REG_WR(sc, base + BCE_HC_TX_TICKS_OFF, 		    (sc->tx_ticks_int<< 16) | sc->tx_ticks);  		val |= BCE_HC_CONFIG_SB_ADDR_INC_128B; 	}
comment|/* 	 * Tell the HC block to automatically set the 	 * INT_MASK bit after an MSI/MSI-X interrupt 	 * is generated so the driver doesn't have to. 	 */
block|if (sc->bce_flags& BCE_ONE_SHOT_MSI_FLAG) 		val |= BCE_HC_CONFIG_ONE_SHOT;
comment|/* Set the MSI-X status blocks to 128 byte boundaries. */
block|if (sc->bce_flags& BCE_USING_MSIX_FLAG) 		val |= BCE_HC_CONFIG_SB_ADDR_INC_128B;
endif|#
directive|endif
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Clear the internal statistics counters. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|,
name|BCE_HC_COMMAND_CLR_STAT_NOW
argument_list|)
expr_stmt|;
comment|/* Verify that bootcode is running. */
name|reg
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_DEV_INFO_SIGNATURE
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(bootcode_running_failure_sim_control)
argument_list|,
argument|BCE_PRINTF(
literal|"%s(%d): Simulating bootcode failure.\n"
argument|, 	    __FILE__, __LINE__); 	    reg =
literal|0
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|BCE_DEV_INFO_SIGNATURE_MAGIC_MASK
operator|)
operator|!=
name|BCE_DEV_INFO_SIGNATURE_MAGIC
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Bootcode not running! Found: 0x%08X, "
literal|"Expected: 08%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|reg
operator|&
name|BCE_DEV_INFO_SIGNATURE_MAGIC_MASK
operator|)
argument_list|,
name|BCE_DEV_INFO_SIGNATURE_MAGIC
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_blockinit_exit
goto|;
block|}
comment|/* Enable DMA */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_NEW_CORE_CTL
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_MISC_NEW_CORE_CTL_DMA_ENABLE
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_NEW_CORE_CTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Allow bootcode to apply additional fixes before enabling MAC. */
name|rc
operator|=
name|bce_fw_sync
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_DATA_WAIT2
operator||
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
expr_stmt|;
comment|/* Enable link state change interrupt generation. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_ATTN_BITS_ENABLE
argument_list|,
name|STATUS_ATTN_BITS_LINK_STATE
argument_list|)
expr_stmt|;
comment|/* Enable the RXP. */
name|bce_start_rxp_cpu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable management frames (NC-SI) from flowing to the MCP. */
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_MFW_ENABLE_FLAG
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_MGMT_PKT_CTRL
argument_list|)
operator|&
operator|~
name|BCE_RPM_MGMT_PKT_CTRL_MGMT_EN
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_MGMT_PKT_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Enable all remaining blocks in the MAC. */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|,
name|BCE_MISC_ENABLE_DEFAULT_XI
argument_list|)
expr_stmt|;
else|else
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|,
name|BCE_MISC_ENABLE_DEFAULT
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Save the current host coalescing block settings. */
name|sc
operator|->
name|hc_command
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|)
expr_stmt|;
name|bce_blockinit_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Encapsulate an mbuf into the rx_bd chain.                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_get_rx_buf
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u16
modifier|*
name|prod
parameter_list|,
name|u16
modifier|*
name|chain_prod
parameter_list|,
name|u32
modifier|*
name|prod_bseq
parameter_list|)
block|{
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|BCE_MAX_SEGMENTS
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
init|=
name|NULL
decl_stmt|;
name|struct
name|rx_bd
modifier|*
name|rxbd
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|error
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|u16
name|debug_chain_prod
init|=
operator|*
name|chain_prod
decl_stmt|;
endif|#
directive|endif
name|DBENTER
argument_list|(
name|BCE_EXTREME_RESET
operator||
name|BCE_EXTREME_RECV
operator||
name|BCE_EXTREME_LOAD
argument_list|)
expr_stmt|;
comment|/* Make sure the inputs are valid. */
name|DBRUNIF
argument_list|(
operator|(
operator|*
name|chain_prod
operator|>
name|MAX_RX_BD
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): RX producer out of range: "
literal|"0x%04X> 0x%04X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|*
name|chain_prod
argument_list|,
operator|(
name|u16
operator|)
name|MAX_RX_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_RECV
argument_list|,
literal|"%s(enter): prod = 0x%04X, "
literal|"chain_prod = 0x%04X, prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|prod
argument_list|,
operator|*
name|chain_prod
argument_list|,
operator|*
name|prod_bseq
argument_list|)
expr_stmt|;
comment|/* Update some debug statistic counters */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_rx_bd
operator|<
name|sc
operator|->
name|rx_low_watermark
operator|)
argument_list|,
name|sc
operator|->
name|rx_low_watermark
operator|=
name|sc
operator|->
name|free_rx_bd
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_rx_bd
operator|==
name|sc
operator|->
name|max_rx_bd
operator|)
argument_list|,
name|sc
operator|->
name|rx_empty_count
operator|++
argument_list|)
expr_stmt|;
comment|/* Check whether this is a new mbuf allocation. */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* Simulate an mbuf allocation failure. */
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(mbuf_alloc_failed_sim_control)
argument_list|,
argument|sc->mbuf_alloc_failed_count++; 		    sc->mbuf_alloc_failed_sim_count++; 		    rc = ENOBUFS; 		    goto bce_get_rx_buf_exit
argument_list|)
empty_stmt|;
comment|/* This is a new mbuf allocation. */
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|MGETHDR
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|<=
name|MCLBYTES
condition|)
name|m_new
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
else|else
name|m_new
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|mbuf_alloc_failed_count
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_get_rx_buf_exit
goto|;
block|}
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_rx_mbuf_alloc
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reuse an existing mbuf. */
name|m_new
operator|=
name|m
expr_stmt|;
block|}
comment|/* Make sure we have a valid packet header. */
name|M_ASSERTPKTHDR
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
comment|/* Initialize the mbuf size and pad if necessary for alignment. */
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m_new
operator|->
name|m_len
operator|=
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
expr_stmt|;
name|m_adj
argument_list|(
name|m_new
argument_list|,
name|sc
operator|->
name|rx_bd_mbuf_align_pad
argument_list|)
expr_stmt|;
comment|/* ToDo: Consider calling m_fragment() to test error handling. */
comment|/* Map the mbuf cluster into device memory. */
name|map
operator|=
name|sc
operator|->
name|rx_mbuf_map
index|[
operator|*
name|chain_prod
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|map
argument_list|,
name|m_new
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Handle any mapping errors. */
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Error mapping mbuf into RX "
literal|"chain (%d)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dma_map_addr_rx_failed_count
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_get_rx_buf_exit
goto|;
block|}
comment|/* All mbufs must map to a single segment. */
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s(): Too many segments returned (%d)!"
operator|,
name|__FUNCTION__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
comment|/* Setup the rx_bd for the segment. */
name|rxbd
operator|=
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|RX_PAGE
argument_list|(
operator|*
name|chain_prod
argument_list|)
index|]
index|[
name|RX_IDX
argument_list|(
operator|*
name|chain_prod
argument_list|)
index|]
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_len
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_flags
operator|=
name|htole32
argument_list|(
name|RX_BD_FLAGS_START
operator||
name|RX_BD_FLAGS_END
argument_list|)
expr_stmt|;
operator|*
name|prod_bseq
operator|+=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
expr_stmt|;
comment|/* Save the mbuf and update our counter. */
name|sc
operator|->
name|rx_mbuf_ptr
index|[
operator|*
name|chain_prod
index|]
operator|=
name|m_new
expr_stmt|;
name|sc
operator|->
name|free_rx_bd
operator|-=
name|nsegs
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_INSANE_RECV
argument_list|,
name|bce_dump_rx_mbuf_chain
argument_list|(
name|sc
argument_list|,
name|debug_chain_prod
argument_list|,
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_RECV
argument_list|,
literal|"%s(exit): prod = 0x%04X, "
literal|"chain_prod = 0x%04X, prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|prod
argument_list|,
operator|*
name|chain_prod
argument_list|,
operator|*
name|prod_bseq
argument_list|)
expr_stmt|;
name|bce_get_rx_buf_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_EXTREME_RESET
operator||
name|BCE_EXTREME_RECV
operator||
name|BCE_EXTREME_LOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Encapsulate an mbuf cluster into the page chain.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_get_pg_buf
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u16
modifier|*
name|prod
parameter_list|,
name|u16
modifier|*
name|prod_idx
parameter_list|)
block|{
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_addr_t
name|busaddr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
init|=
name|NULL
decl_stmt|;
name|struct
name|rx_bd
modifier|*
name|pgbd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|u16
name|debug_prod_idx
init|=
operator|*
name|prod_idx
decl_stmt|;
endif|#
directive|endif
name|DBENTER
argument_list|(
name|BCE_EXTREME_RESET
operator||
name|BCE_EXTREME_RECV
operator||
name|BCE_EXTREME_LOAD
argument_list|)
expr_stmt|;
comment|/* Make sure the inputs are valid. */
name|DBRUNIF
argument_list|(
operator|(
operator|*
name|prod_idx
operator|>
name|MAX_PG_BD
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): page producer out of range: "
literal|"0x%04X> 0x%04X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|*
name|prod_idx
argument_list|,
operator|(
name|u16
operator|)
name|MAX_PG_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_RECV
argument_list|,
literal|"%s(enter): prod = 0x%04X, "
literal|"chain_prod = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|prod
argument_list|,
operator|*
name|prod_idx
argument_list|)
expr_stmt|;
comment|/* Update counters if we've hit a new low or run out of pages. */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_pg_bd
operator|<
name|sc
operator|->
name|pg_low_watermark
operator|)
argument_list|,
name|sc
operator|->
name|pg_low_watermark
operator|=
name|sc
operator|->
name|free_pg_bd
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_pg_bd
operator|==
name|sc
operator|->
name|max_pg_bd
operator|)
argument_list|,
name|sc
operator|->
name|pg_empty_count
operator|++
argument_list|)
expr_stmt|;
comment|/* Check whether this is a new mbuf allocation. */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* Simulate an mbuf allocation failure. */
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(mbuf_alloc_failed_sim_control)
argument_list|,
argument|sc->mbuf_alloc_failed_count++; 		    sc->mbuf_alloc_failed_sim_count++; 		    rc = ENOBUFS; 		    goto bce_get_pg_buf_exit
argument_list|)
empty_stmt|;
comment|/* This is a new mbuf allocation. */
name|m_new
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|mbuf_alloc_failed_count
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_get_pg_buf_exit
goto|;
block|}
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_pg_mbuf_alloc
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reuse an existing mbuf. */
name|m_new
operator|=
name|m
expr_stmt|;
name|m_new
operator|->
name|m_data
operator|=
name|m_new
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
name|m_new
operator|->
name|m_len
operator|=
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
expr_stmt|;
comment|/* ToDo: Consider calling m_fragment() to test error handling. */
comment|/* Map the mbuf cluster into device memory. */
name|map
operator|=
name|sc
operator|->
name|pg_mbuf_map
index|[
operator|*
name|prod_idx
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|pg_mbuf_tag
argument_list|,
name|map
argument_list|,
name|mtod
argument_list|(
name|m_new
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
argument_list|,
name|bce_dma_map_addr
argument_list|,
operator|&
name|busaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Handle any mapping errors. */
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Error mapping mbuf into page chain!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_pg_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_get_pg_buf_exit
goto|;
block|}
comment|/* ToDo: Do we need bus_dmamap_sync(,,BUS_DMASYNC_PREREAD) here? */
comment|/* 	 * The page chain uses the same rx_bd data structure 	 * as the receive chain but doesn't require a byte sequence (bseq). 	 */
name|pgbd
operator|=
operator|&
name|sc
operator|->
name|pg_bd_chain
index|[
name|PG_PAGE
argument_list|(
operator|*
name|prod_idx
argument_list|)
index|]
index|[
name|PG_IDX
argument_list|(
operator|*
name|prod_idx
argument_list|)
index|]
expr_stmt|;
name|pgbd
operator|->
name|rx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|pgbd
operator|->
name|rx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|pgbd
operator|->
name|rx_bd_len
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
argument_list|)
expr_stmt|;
name|pgbd
operator|->
name|rx_bd_flags
operator|=
name|htole32
argument_list|(
name|RX_BD_FLAGS_START
operator||
name|RX_BD_FLAGS_END
argument_list|)
expr_stmt|;
comment|/* Save the mbuf and update our counter. */
name|sc
operator|->
name|pg_mbuf_ptr
index|[
operator|*
name|prod_idx
index|]
operator|=
name|m_new
expr_stmt|;
name|sc
operator|->
name|free_pg_bd
operator|--
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_INSANE_RECV
argument_list|,
name|bce_dump_pg_mbuf_chain
argument_list|(
name|sc
argument_list|,
name|debug_prod_idx
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_RECV
argument_list|,
literal|"%s(exit): prod = 0x%04X, "
literal|"prod_idx = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|prod
argument_list|,
operator|*
name|prod_idx
argument_list|)
expr_stmt|;
name|bce_get_pg_buf_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_EXTREME_RESET
operator||
name|BCE_EXTREME_RECV
operator||
name|BCE_EXTREME_LOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BCE_JUMBO_HDRSPLIT */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the TX context memory.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing                                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_tx_context
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* Initialize the context ID for an L2 TX chain. */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
comment|/* Set the CID type to support an L2 connection. */
name|val
operator|=
name|BCE_L2CTX_TX_TYPE_TYPE_L2_XI
operator||
name|BCE_L2CTX_TX_TYPE_SIZE_L2_XI
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TYPE_XI
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_L2CTX_TX_CMD_TYPE_TYPE_L2_XI
operator||
operator|(
literal|8
operator|<<
literal|16
operator|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_CMD_TYPE_XI
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Point the hardware to the first page in the chain. */
name|val
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TBDR_BHADDR_HI_XI
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TBDR_BHADDR_LO_XI
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the CID type to support an L2 connection. */
name|val
operator|=
name|BCE_L2CTX_TX_TYPE_TYPE_L2
operator||
name|BCE_L2CTX_TX_TYPE_SIZE_L2
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TYPE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_L2CTX_TX_CMD_TYPE_TYPE_L2
operator||
operator|(
literal|8
operator|<<
literal|16
operator|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_CMD_TYPE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Point the hardware to the first page in the chain. */
name|val
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TBDR_BHADDR_HI
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TBDR_BHADDR_LO
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allocate memory and initialize the TX data structures.                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_init_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tx_bd
modifier|*
name|txbd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
comment|/* Set the initial TX producer/consumer indices. */
name|sc
operator|->
name|tx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx_prod_bseq
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|used_tx_bd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|max_tx_bd
operator|=
name|USABLE_TX_BD
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|tx_hi_watermark
operator|=
literal|0
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|tx_full_count
operator|=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * The NetXtreme II supports a linked-list structre called 	 * a Buffer Descriptor Chain (or BD chain).  A BD chain 	 * consists of a series of 1 or more chain pages, each of which 	 * consists of a fixed number of BD entries. 	 * The last BD entry on each page is a pointer to the next page 	 * in the chain, and the last pointer in the BD chain 	 * points back to the beginning of the chain. 	 */
comment|/* Set the TX next pointer chain entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|txbd
operator|=
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
index|[
name|USABLE_TX_BD_PER_PAGE
index|]
expr_stmt|;
comment|/* Check if we've reached the last page. */
if|if
condition|(
name|i
operator|==
operator|(
name|TX_PAGES
operator|-
literal|1
operator|)
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bce_init_tx_context
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_INSANE_SEND
argument_list|,
name|bce_dump_tx_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TOTAL_TX_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Free memory and clear the TX data structures.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_free_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
comment|/* Unmap, unload, and free any mbufs still in the TX mbuf chain. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_TX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_tx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear each TX chain page. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_TX_CHAIN_PAGE_SZ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|used_tx_bd
operator|=
literal|0
expr_stmt|;
comment|/* Check if we lost any mbufs in the process. */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|debug_tx_mbuf_alloc
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Memory leak! Lost %d mbufs "
literal|"from tx chain!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|debug_tx_mbuf_alloc
argument_list|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the RX context memory.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing                                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_rx_context
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* Init the type, size, and BD cache levels for the RX context. */
name|val
operator|=
name|BCE_L2CTX_RX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE
operator||
name|BCE_L2CTX_RX_CTX_TYPE_SIZE_L2
operator||
operator|(
literal|0x02
operator|<<
name|BCE_L2CTX_RX_BD_PRE_READ_SHIFT
operator|)
expr_stmt|;
comment|/* 	 * Set the level for generating pause frames 	 * when the number of available rx_bd's gets 	 * too low (the low watermark) and the level 	 * when pause frames can be stopped (the high 	 * watermark). 	 */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|u32
name|lo_water
decl_stmt|,
name|hi_water
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&&
name|BCE_USING_TX_FLOW_CONTROL
condition|)
block|{
name|lo_water
operator|=
name|BCE_L2CTX_RX_LO_WATER_MARK_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|lo_water
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lo_water
operator|>=
name|USABLE_RX_BD
condition|)
block|{
name|lo_water
operator|=
literal|0
expr_stmt|;
block|}
name|hi_water
operator|=
name|USABLE_RX_BD
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|hi_water
operator|<=
name|lo_water
condition|)
block|{
name|lo_water
operator|=
literal|0
expr_stmt|;
block|}
name|lo_water
operator|/=
name|BCE_L2CTX_RX_LO_WATER_MARK_SCALE
expr_stmt|;
name|hi_water
operator|/=
name|BCE_L2CTX_RX_HI_WATER_MARK_SCALE
expr_stmt|;
if|if
condition|(
name|hi_water
operator|>
literal|0xf
condition|)
name|hi_water
operator|=
literal|0xf
expr_stmt|;
elseif|else
if|if
condition|(
name|hi_water
operator|==
literal|0
condition|)
name|lo_water
operator|=
literal|0
expr_stmt|;
name|val
operator||=
operator|(
name|lo_water
operator|<<
name|BCE_L2CTX_RX_LO_WATER_MARK_SHIFT
operator|)
operator||
operator|(
name|hi_water
operator|<<
name|BCE_L2CTX_RX_HI_WATER_MARK_SHIFT
operator|)
expr_stmt|;
block|}
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_CTX_TYPE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Setup the MQ BIN mapping for l2_ctx_host_bseq. */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_MAP_L2_5
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_MAP_L2_5
argument_list|,
name|val
operator||
name|BCE_MQ_MAP_L2_5_ARM
argument_list|)
expr_stmt|;
block|}
comment|/* Point the hardware to the first page in the chain. */
name|val
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_BDHADDR_HI
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_BDHADDR_LO
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allocate memory and initialize the RX data structures.                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_init_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|rx_bd
modifier|*
name|rxbd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* Initialize the RX producer and consumer indices. */
name|sc
operator|->
name|rx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_prod_bseq
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|free_rx_bd
operator|=
name|USABLE_RX_BD
expr_stmt|;
name|sc
operator|->
name|max_rx_bd
operator|=
name|USABLE_RX_BD
expr_stmt|;
comment|/* Initialize the RX next pointer chain entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|rxbd
operator|=
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
index|[
name|USABLE_RX_BD_PER_PAGE
index|]
expr_stmt|;
comment|/* Check if we've reached the last page. */
if|if
condition|(
name|i
operator|==
operator|(
name|RX_PAGES
operator|-
literal|1
operator|)
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Setup the chain page pointers. */
name|rxbd
operator|->
name|rx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fill up the RX chain. */
name|bce_fill_rx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|rx_low_watermark
operator|=
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|rx_empty_count
operator|=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|bce_init_rx_context
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_EXTREME_RECV
argument_list|,
name|bce_dump_rx_bd_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TOTAL_RX_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* ToDo: Are there possible failure modes here? */
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Add mbufs to the RX chain until its full or an mbuf allocation error     */
end_comment

begin_comment
comment|/* occurs.                                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing                                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_fill_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u16
name|prod
decl_stmt|,
name|prod_idx
decl_stmt|;
name|u32
name|prod_bseq
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_EXTREME_RECV
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* Get the RX chain producer indices. */
name|prod
operator|=
name|sc
operator|->
name|rx_prod
expr_stmt|;
name|prod_bseq
operator|=
name|sc
operator|->
name|rx_prod_bseq
expr_stmt|;
comment|/* Keep filling the RX chain until it's full. */
while|while
condition|(
name|sc
operator|->
name|free_rx_bd
operator|>
literal|0
condition|)
block|{
name|prod_idx
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|prod
argument_list|)
expr_stmt|;
if|if
condition|(
name|bce_get_rx_buf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prod
argument_list|,
operator|&
name|prod_idx
argument_list|,
operator|&
name|prod_bseq
argument_list|)
condition|)
block|{
comment|/* Bail out if we can't add an mbuf to the chain. */
break|break;
block|}
name|prod
operator|=
name|NEXT_RX_BD
argument_list|(
name|prod
argument_list|)
expr_stmt|;
block|}
comment|/* Save the RX chain producer indices. */
name|sc
operator|->
name|rx_prod
operator|=
name|prod
expr_stmt|;
name|sc
operator|->
name|rx_prod_bseq
operator|=
name|prod_bseq
expr_stmt|;
comment|/* We should never end up pointing to a next page pointer. */
name|DBRUNIF
argument_list|(
operator|(
operator|(
name|prod
operator|&
name|USABLE_RX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_RX_BD_PER_PAGE
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(): Invalid rx_prod value: 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the mailbox and tell the chip about the waiting rx_bd's. */
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|MB_GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
operator|+
name|BCE_L2MQ_RX_HOST_BDIDX
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MB_GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
operator|+
name|BCE_L2MQ_RX_HOST_BSEQ
argument_list|,
name|sc
operator|->
name|rx_prod_bseq
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_EXTREME_RECV
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Free memory and clear the RX data structures.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_free_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
comment|/* Free any mbufs still in the RX mbuf chain. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_RX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear each RX chain page. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|free_rx_bd
operator|=
name|sc
operator|->
name|max_rx_bd
expr_stmt|;
comment|/* Check if we lost any mbufs in the process. */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|debug_rx_mbuf_alloc
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(): Memory leak! Lost %d mbufs from rx chain!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|debug_rx_mbuf_alloc
argument_list|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allocate memory and initialize the page data structures.                 */
end_comment

begin_comment
comment|/* Assumes that bce_init_rx_chain() has not already been called.            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_init_pg_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|rx_bd
modifier|*
name|pgbd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* Initialize the page producer and consumer indices. */
name|sc
operator|->
name|pg_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pg_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|free_pg_bd
operator|=
name|USABLE_PG_BD
expr_stmt|;
name|sc
operator|->
name|max_pg_bd
operator|=
name|USABLE_PG_BD
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|pg_low_watermark
operator|=
name|sc
operator|->
name|max_pg_bd
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|pg_empty_count
operator|=
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the page next pointer chain entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PG_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|pgbd
operator|=
operator|&
name|sc
operator|->
name|pg_bd_chain
index|[
name|i
index|]
index|[
name|USABLE_PG_BD_PER_PAGE
index|]
expr_stmt|;
comment|/* Check if we've reached the last page. */
if|if
condition|(
name|i
operator|==
operator|(
name|PG_PAGES
operator|-
literal|1
operator|)
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Setup the chain page pointers. */
name|pgbd
operator|->
name|rx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|pg_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|pgbd
operator|->
name|rx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|pg_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the MQ BIN mapping for host_pg_bidx. */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_MAP_L2_3
argument_list|,
name|BCE_MQ_MAP_L2_3_DEFAULT
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_PG_BUF_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure the rx_bd and page chain mbuf cluster size. */
name|val
operator|=
operator|(
name|sc
operator|->
name|rx_bd_mbuf_data_len
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_PG_BUF_SIZE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Configure the context reserved for jumbo support. */
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_RBDC_KEY
argument_list|,
name|BCE_L2CTX_RX_RBDC_JUMBO_KEY
argument_list|)
expr_stmt|;
comment|/* Point the hardware to the first page in the page chain. */
name|val
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|pg_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_PG_BDHADDR_HI
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|pg_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_PG_BDHADDR_LO
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Fill up the page chain. */
name|bce_fill_pg_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PG_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|,
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|DBRUNMSG
argument_list|(
name|BCE_EXTREME_RECV
argument_list|,
name|bce_dump_pg_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TOTAL_PG_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Add mbufs to the page chain until its full or an mbuf allocation error   */
end_comment

begin_comment
comment|/* occurs.                                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing                                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_fill_pg_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u16
name|prod
decl_stmt|,
name|prod_idx
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_EXTREME_RECV
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
comment|/* Get the page chain prodcuer index. */
name|prod
operator|=
name|sc
operator|->
name|pg_prod
expr_stmt|;
comment|/* Keep filling the page chain until it's full. */
while|while
condition|(
name|sc
operator|->
name|free_pg_bd
operator|>
literal|0
condition|)
block|{
name|prod_idx
operator|=
name|PG_CHAIN_IDX
argument_list|(
name|prod
argument_list|)
expr_stmt|;
if|if
condition|(
name|bce_get_pg_buf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prod
argument_list|,
operator|&
name|prod_idx
argument_list|)
condition|)
block|{
comment|/* Bail out if we can't add an mbuf to the chain. */
break|break;
block|}
name|prod
operator|=
name|NEXT_PG_BD
argument_list|(
name|prod
argument_list|)
expr_stmt|;
block|}
comment|/* Save the page chain producer index. */
name|sc
operator|->
name|pg_prod
operator|=
name|prod
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
operator|(
name|prod
operator|&
name|USABLE_RX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_RX_BD_PER_PAGE
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(): Invalid pg_prod value: 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|pg_prod
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Write the mailbox and tell the chip about 	 * the new rx_bd's in the page chain. 	 */
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|MB_GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
operator|+
name|BCE_L2MQ_RX_HOST_PG_BDIDX
argument_list|,
name|sc
operator|->
name|pg_prod
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_EXTREME_RECV
operator||
name|BCE_VERBOSE_LOAD
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Free memory and clear the RX data structures.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_free_pg_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
comment|/* Free any mbufs still in the mbuf page chain. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_PG_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|pg_mbuf_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|pg_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|pg_mbuf_tag
argument_list|,
name|sc
operator|->
name|pg_mbuf_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|pg_mbuf_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pg_mbuf_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_pg_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear each page chain pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PG_PAGES
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|pg_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_PG_CHAIN_PAGE_SZ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|free_pg_bd
operator|=
name|sc
operator|->
name|max_pg_bd
expr_stmt|;
comment|/* Check if we lost any mbufs in the process. */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|debug_pg_mbuf_alloc
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(): Memory leak! Lost %d mbufs from page chain!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|debug_pg_mbuf_alloc
argument_list|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BCE_JUMBO_HDRSPLIT */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Set media options.                                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bce_ifmedia_upd_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Set media options.                                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_ifmedia_upd_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
comment|/* Make sure the MII bus has been enumerated. */
if|if
condition|(
name|mii
condition|)
block|{
name|sc
operator|->
name|bce_link_up
operator|=
name|FALSE
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|miisc
argument_list|,
argument|&mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
name|mii_phy_reset
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_PHY
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Reports current media status.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles PHY generated interrupt events.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_phy_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|new_link_state
decl_stmt|,
name|old_link_state
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_PHY
operator||
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|phy_interrupts
operator|++
argument_list|)
expr_stmt|;
name|new_link_state
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits
operator|&
name|STATUS_ATTN_BITS_LINK_STATE
expr_stmt|;
name|old_link_state
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits_ack
operator|&
name|STATUS_ATTN_BITS_LINK_STATE
expr_stmt|;
comment|/* Handle any changes if the link state has changed. */
if|if
condition|(
name|new_link_state
operator|!=
name|old_link_state
condition|)
block|{
comment|/* Update the status_attn_bits_ack field. */
if|if
condition|(
name|new_link_state
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_STATUS_BIT_SET_CMD
argument_list|,
name|STATUS_ATTN_BITS_LINK_STATE
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"%s(): Link is now UP.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_STATUS_BIT_CLEAR_CMD
argument_list|,
name|STATUS_ATTN_BITS_LINK_STATE
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_PHY
argument_list|,
literal|"%s(): Link is now DOWN.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Assume link is down and allow 		 * tick routine to update the state 		 * based on the actual media state. 		 */
name|sc
operator|->
name|bce_link_up
operator|=
name|FALSE
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|bce_tick_callout
argument_list|)
expr_stmt|;
name|bce_tick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Acknowledge the link change interrupt. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_STATUS
argument_list|,
name|BCE_EMAC_STATUS_LINK_CHANGE
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_PHY
operator||
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Reads the receive consumer value from the status block (skipping over    */
end_comment

begin_comment
comment|/* chain page pointer if necessary).                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   hw_cons                                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|u16
name|bce_get_hw_rx_cons
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u16
name|hw_cons
decl_stmt|;
name|rmb
argument_list|()
expr_stmt|;
name|hw_cons
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_rx_quick_consumer_index0
expr_stmt|;
if|if
condition|(
operator|(
name|hw_cons
operator|&
name|USABLE_RX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_RX_BD_PER_PAGE
condition|)
name|hw_cons
operator|++
expr_stmt|;
return|return
name|hw_cons
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles received frame interrupt events.                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_rx_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|bce_ifp
decl_stmt|;
name|struct
name|l2_fhdr
modifier|*
name|l2fhdr
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|vh
decl_stmt|;
name|unsigned
name|int
name|pkt_len
decl_stmt|;
name|u16
name|sw_rx_cons
decl_stmt|,
name|sw_rx_cons_idx
decl_stmt|,
name|hw_rx_cons
decl_stmt|;
name|u32
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|unsigned
name|int
name|rem_len
decl_stmt|;
name|u16
name|sw_pg_cons
decl_stmt|,
name|sw_pg_cons_idx
decl_stmt|;
endif|#
directive|endif
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|interrupts_rx
operator|++
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_RECV
argument_list|,
literal|"%s(enter): rx_prod = 0x%04X, "
literal|"rx_cons = 0x%04X, rx_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|,
name|sc
operator|->
name|rx_cons
argument_list|,
name|sc
operator|->
name|rx_prod_bseq
argument_list|)
expr_stmt|;
comment|/* Prepare the RX chain pages to be accessed by the host CPU. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
comment|/* Prepare the page chain pages to be accessed by the host CPU. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|PG_PAGES
condition|;
name|i
operator|++
control|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|,
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get the hardware's view of the RX consumer index. */
name|hw_rx_cons
operator|=
name|sc
operator|->
name|hw_rx_cons
operator|=
name|bce_get_hw_rx_cons
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get working copies of the driver's view of the consumer indices. */
name|sw_rx_cons
operator|=
name|sc
operator|->
name|rx_cons
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|sw_pg_cons
operator|=
name|sc
operator|->
name|pg_cons
expr_stmt|;
endif|#
directive|endif
comment|/* Update some debug statistics counters */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_rx_bd
operator|<
name|sc
operator|->
name|rx_low_watermark
operator|)
argument_list|,
name|sc
operator|->
name|rx_low_watermark
operator|=
name|sc
operator|->
name|free_rx_bd
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_rx_bd
operator|==
name|sc
operator|->
name|max_rx_bd
operator|)
argument_list|,
name|sc
operator|->
name|rx_empty_count
operator|++
argument_list|)
expr_stmt|;
comment|/* Scan through the receive chain as long as there is work to do */
comment|/* ToDo: Consider setting a limit on the number of packets processed. */
name|rmb
argument_list|()
expr_stmt|;
while|while
condition|(
name|sw_rx_cons
operator|!=
name|hw_rx_cons
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
comment|/* Convert the producer/consumer indices to an actual rx_bd index. */
name|sw_rx_cons_idx
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|sw_rx_cons
argument_list|)
expr_stmt|;
comment|/* Unmap the mbuf from DMA space. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|sw_rx_cons_idx
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|sw_rx_cons_idx
index|]
argument_list|)
expr_stmt|;
comment|/* Remove the mbuf from the RX chain. */
name|m0
operator|=
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|sw_rx_cons_idx
index|]
expr_stmt|;
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|sw_rx_cons_idx
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|sc
operator|->
name|free_rx_bd
operator|++
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_RECV
argument_list|,
literal|"%s(): Oops! Empty mbuf pointer "
literal|"found in sc->rx_mbuf_ptr[0x%04X]!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sw_rx_cons_idx
argument_list|)
expr_stmt|;
goto|goto
name|bce_rx_int_next_rx
goto|;
block|}
comment|/*  		 * Frames received on the NetXteme II are prepended  		 * with an l2_fhdr structure which provides status  		 * information about the received frame (including  		 * VLAN tags and checksum info).  The frames are 		 * also automatically adjusted to align the IP  		 * header (i.e. two null bytes are inserted before  		 * the Ethernet	header).  As a result the data  		 * DMA'd by the controller into	the mbuf looks 		 * like this: 		 * 		 * +---------+-----+---------------------+-----+ 		 * | l2_fhdr | pad | packet data         | FCS | 		 * +---------+-----+---------------------+-----+ 		 *  		 * The l2_fhdr needs to be checked and skipped and  		 * the FCS needs to be stripped before sending the 		 * packet up the stack. 		 */
name|l2fhdr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|l2_fhdr
operator|*
argument_list|)
expr_stmt|;
comment|/* Get the packet data + FCS length and the status. */
name|pkt_len
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_pkt_len
expr_stmt|;
name|status
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_status
expr_stmt|;
comment|/* 		 * Skip over the l2_fhdr and pad, resulting in the 		 * following data in the mbuf: 		 * +---------------------+-----+ 		 * | packet data         | FCS | 		 * +---------------------+-----+ 		 */
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|l2_fhdr
argument_list|)
operator|+
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
comment|/* 		 * Check whether the received frame fits in a single 		 * mbuf or not (i.e. packet data + FCS<= 		 * sc->rx_bd_mbuf_data_len bytes). 		 */
if|if
condition|(
name|pkt_len
operator|>
name|m0
operator|->
name|m_len
condition|)
block|{
comment|/* 			 * The received frame is larger than a single mbuf. 			 * If the frame was a TCP frame then only the TCP 			 * header is placed in the mbuf, the remaining 			 * payload (including FCS) is placed in the page 			 * chain, the SPLIT flag is set, and the header 			 * length is placed in the IP checksum field. 			 * If the frame is not a TCP frame then the mbuf 			 * is filled and the remaining bytes are placed 			 * in the page chain. 			 */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RECV
argument_list|,
literal|"%s(): Found a large "
literal|"packet.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* 			 * When the page chain is enabled and the TCP 			 * header has been split from the TCP payload, 			 * the ip_xsum structure will reflect the length 			 * of the TCP header, not the IP checksum.  Set 			 * the packet length of the mbuf accordingly. 			 */
if|if
condition|(
name|status
operator|&
name|L2_FHDR_STATUS_SPLIT
condition|)
name|m0
operator|->
name|m_len
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_ip_xsum
expr_stmt|;
name|rem_len
operator|=
name|pkt_len
operator|-
name|m0
operator|->
name|m_len
expr_stmt|;
comment|/* Pull mbufs off the page chain for the remaining data. */
while|while
condition|(
name|rem_len
operator|>
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_pg
decl_stmt|;
name|sw_pg_cons_idx
operator|=
name|PG_CHAIN_IDX
argument_list|(
name|sw_pg_cons
argument_list|)
expr_stmt|;
comment|/* Remove the mbuf from the page chain. */
name|m_pg
operator|=
name|sc
operator|->
name|pg_mbuf_ptr
index|[
name|sw_pg_cons_idx
index|]
expr_stmt|;
name|sc
operator|->
name|pg_mbuf_ptr
index|[
name|sw_pg_cons_idx
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_pg_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|sc
operator|->
name|free_pg_bd
operator|++
expr_stmt|;
comment|/* Unmap the page chain mbuf from DMA space. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|pg_mbuf_tag
argument_list|,
name|sc
operator|->
name|pg_mbuf_map
index|[
name|sw_pg_cons_idx
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|pg_mbuf_tag
argument_list|,
name|sc
operator|->
name|pg_mbuf_map
index|[
name|sw_pg_cons_idx
index|]
argument_list|)
expr_stmt|;
comment|/* Adjust the mbuf length. */
if|if
condition|(
name|rem_len
operator|<
name|m_pg
operator|->
name|m_len
condition|)
block|{
comment|/* The mbuf chain is complete. */
name|m_pg
operator|->
name|m_len
operator|=
name|rem_len
expr_stmt|;
name|rem_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* More packet data is waiting. */
name|rem_len
operator|-=
name|m_pg
operator|->
name|m_len
expr_stmt|;
block|}
comment|/* Concatenate the mbuf cluster to the mbuf. */
name|m_cat
argument_list|(
name|m0
argument_list|,
name|m_pg
argument_list|)
expr_stmt|;
name|sw_pg_cons
operator|=
name|NEXT_PG_BD
argument_list|(
name|sw_pg_cons
argument_list|)
expr_stmt|;
block|}
comment|/* Set the total packet length. */
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The received packet is small and fits in a 			 * single mbuf (i.e. the l2_fhdr + pad + packet + 			 * FCS<= MHLEN).  In other words, the packet is 			 * 154 bytes or less in size. 			 */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RECV
argument_list|,
literal|"%s(): Found a small "
literal|"packet.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Set the total packet length. */
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
name|pkt_len
expr_stmt|;
block|}
else|#
directive|else
comment|/* Set the total packet length. */
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
name|pkt_len
expr_stmt|;
endif|#
directive|endif
comment|/* Remove the trailing Ethernet FCS. */
name|m_adj
argument_list|(
name|m0
argument_list|,
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
comment|/* Check that the resulting mbuf chain is valid. */
name|DBRUN
argument_list|(
name|m_sanity
argument_list|(
name|m0
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|((m0->m_len< ETHER_HDR_LEN) | 		    (m0->m_pkthdr.len> BCE_MAX_JUMBO_ETHER_MTU_VLAN))
argument_list|,
argument|BCE_PRINTF(
literal|"Invalid Ethernet frame size!\n"
argument|); 		     m_print(m0,
literal|128
argument|)
argument_list|)
empty_stmt|;
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(l2fhdr_error_sim_control)
argument_list|,
argument|sc->l2fhdr_error_sim_count++; 		    status = status | L2_FHDR_ERRORS_PHY_DECODE
argument_list|)
empty_stmt|;
comment|/* Check the received frame for errors. */
if|if
condition|(
name|status
operator|&
operator|(
name|L2_FHDR_ERRORS_BAD_CRC
operator||
name|L2_FHDR_ERRORS_PHY_DECODE
operator||
name|L2_FHDR_ERRORS_ALIGNMENT
operator||
name|L2_FHDR_ERRORS_TOO_SHORT
operator||
name|L2_FHDR_ERRORS_GIANT_FRAME
operator|)
condition|)
block|{
comment|/* Log the error and release the mbuf. */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|l2fhdr_error_count
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|bce_rx_int_next_rx
goto|;
block|}
comment|/* Send the packet to the appropriate interface. */
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* Assume no hardware checksum. */
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
comment|/* Validate the checksum if offload enabled. */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
comment|/* Check for an IP datagram. */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|L2_FHDR_STATUS_SPLIT
operator|)
operator|&&
operator|(
name|status
operator|&
name|L2_FHDR_STATUS_IP_DATAGRAM
operator|)
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|csum_offload_ip
operator|++
argument_list|)
expr_stmt|;
comment|/* Check if the IP checksum is valid. */
if|if
condition|(
operator|(
name|l2fhdr
operator|->
name|l2_fhdr_ip_xsum
operator|^
literal|0xffff
operator|)
operator|==
literal|0
condition|)
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
comment|/* Check for a valid TCP/UDP frame. */
if|if
condition|(
name|status
operator|&
operator|(
name|L2_FHDR_STATUS_TCP_SEGMENT
operator||
name|L2_FHDR_STATUS_UDP_DATAGRAM
operator|)
condition|)
block|{
comment|/* Check for a good TCP/UDP checksum. */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|L2_FHDR_ERRORS_TCP_XSUM
operator||
name|L2_FHDR_ERRORS_UDP_XSUM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|DBRUN
argument_list|(
name|sc
operator|->
name|csum_offload_tcp_udp
operator|++
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_tcp_udp_xsum
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Attach the VLAN tag.	*/
if|if
condition|(
name|status
operator|&
name|L2_FHDR_STATUS_L2_VLAN_TAG
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
name|VLAN_INPUT_TAG
argument_list|(
argument|ifp
argument_list|,
argument|m0
argument_list|,
argument|l2fhdr->l2_fhdr_vlan_tag
argument_list|,
argument|continue
argument_list|)
empty_stmt|;
else|#
directive|else
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_vlan_tag
expr_stmt|;
name|m0
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 				 * bce(4) controllers can't disable VLAN 				 * tag stripping if management firmware 				 * (ASF/IPMI/UMP) is running. So we always 				 * strip VLAN tag and manually reconstruct 				 * the VLAN frame by appending stripped 				 * VLAN tag in driver if VLAN tag stripping 				 * was disabled. 				 * 				 * TODO: LLC SNAP handling. 				 */
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|-
name|ETHER_VLAN_ENCAP_LEN
argument_list|,
name|ETHER_ADDR_LEN
operator|*
literal|2
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_data
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|vh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|vh
operator|->
name|evl_encap_proto
operator|=
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
name|vh
operator|->
name|evl_tag
operator|=
name|htons
argument_list|(
name|l2fhdr
operator|->
name|l2_fhdr_vlan_tag
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|m0
operator|->
name|m_len
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
block|}
comment|/* Increment received packet statistics. */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|bce_rx_int_next_rx
label|:
name|sw_rx_cons
operator|=
name|NEXT_RX_BD
argument_list|(
name|sw_rx_cons
argument_list|)
expr_stmt|;
comment|/* If we have a packet, pass it up the stack */
if|if
condition|(
name|m0
condition|)
block|{
comment|/* Make sure we don't lose our place when we release the lock. */
name|sc
operator|->
name|rx_cons
operator|=
name|sw_rx_cons
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|sc
operator|->
name|pg_cons
operator|=
name|sw_pg_cons
expr_stmt|;
endif|#
directive|endif
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Recover our place. */
name|sw_rx_cons
operator|=
name|sc
operator|->
name|rx_cons
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|sw_pg_cons
operator|=
name|sc
operator|->
name|pg_cons
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Refresh hw_cons to see if there's new work */
if|if
condition|(
name|sw_rx_cons
operator|==
name|hw_rx_cons
condition|)
name|hw_rx_cons
operator|=
name|sc
operator|->
name|hw_rx_cons
operator|=
name|bce_get_hw_rx_cons
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
comment|/* No new packets.  Refill the page chain. */
name|sc
operator|->
name|pg_cons
operator|=
name|sw_pg_cons
expr_stmt|;
name|bce_fill_pg_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No new packets.  Refill the RX chain. */
name|sc
operator|->
name|rx_cons
operator|=
name|sw_rx_cons
expr_stmt|;
name|bce_fill_rx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepare the page chain pages to be accessed by the NIC. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|PG_PAGES
condition|;
name|i
operator|++
control|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|pg_bd_chain_tag
argument_list|,
name|sc
operator|->
name|pg_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_RECV
argument_list|,
literal|"%s(exit): rx_prod = 0x%04X, "
literal|"rx_cons = 0x%04X, rx_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|,
name|sc
operator|->
name|rx_cons
argument_list|,
name|sc
operator|->
name|rx_prod_bseq
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Reads the transmit consumer value from the status block (skipping over   */
end_comment

begin_comment
comment|/* chain page pointer if necessary).                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   hw_cons                                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|u16
name|bce_get_hw_tx_cons
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u16
name|hw_cons
decl_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|hw_cons
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_tx_quick_consumer_index0
expr_stmt|;
if|if
condition|(
operator|(
name|hw_cons
operator|&
name|USABLE_TX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_TX_BD_PER_PAGE
condition|)
name|hw_cons
operator|++
expr_stmt|;
return|return
name|hw_cons
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles transmit completion interrupt events.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_tx_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|bce_ifp
decl_stmt|;
name|u16
name|hw_tx_cons
decl_stmt|,
name|sw_tx_cons
decl_stmt|,
name|sw_tx_chain_cons
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|interrupts_tx
operator|++
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_SEND
argument_list|,
literal|"%s(enter): tx_prod = 0x%04X, "
literal|"tx_cons = 0x%04X, tx_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|tx_prod
argument_list|,
name|sc
operator|->
name|tx_cons
argument_list|,
name|sc
operator|->
name|tx_prod_bseq
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get the hardware's view of the TX consumer index. */
name|hw_tx_cons
operator|=
name|sc
operator|->
name|hw_tx_cons
operator|=
name|bce_get_hw_tx_cons
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sw_tx_cons
operator|=
name|sc
operator|->
name|tx_cons
expr_stmt|;
comment|/* Prevent speculative reads of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
comment|/* Cycle through any completed TX chain page entries. */
while|while
condition|(
name|sw_tx_cons
operator|!=
name|hw_tx_cons
condition|)
block|{
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|struct
name|tx_bd
modifier|*
name|txbd
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|sw_tx_chain_cons
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|sw_tx_cons
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): hw_tx_cons = 0x%04X, sw_tx_cons = 0x%04X, "
literal|"sw_tx_chain_cons = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|hw_tx_cons
argument_list|,
name|sw_tx_cons
argument_list|,
name|sw_tx_chain_cons
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|(sw_tx_chain_cons> MAX_TX_BD)
argument_list|,
argument|BCE_PRINTF(
literal|"%s(%d): TX chain consumer out of range! "
literal|" 0x%04X> 0x%04X\n"
argument|, __FILE__, __LINE__, sw_tx_chain_cons, 		    (int) MAX_TX_BD); 		    bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|DBRUN
argument_list|(
name|txbd
operator|=
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|TX_PAGE
argument_list|(
name|sw_tx_chain_cons
argument_list|)
index|]
index|[
name|TX_IDX
argument_list|(
name|sw_tx_chain_cons
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|(txbd == NULL)
argument_list|,
argument|BCE_PRINTF(
literal|"%s(%d): Unexpected NULL tx_bd[0x%04X]!\n"
argument|, 		    __FILE__, __LINE__, sw_tx_chain_cons); 		    bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|DBRUNMSG
argument_list|(
argument|BCE_INFO_SEND
argument_list|,
argument|BCE_PRINTF(
literal|"%s(): "
argument|, __FUNCTION__); 		    bce_dump_txbd(sc, sw_tx_chain_cons, txbd)
argument_list|)
empty_stmt|;
comment|/* 		 * Free the associated mbuf. Remember 		 * that only the last tx_bd of a packet 		 * has an mbuf pointer and DMA map. 		 */
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|sw_tx_chain_cons
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* Validate that this is the last tx_bd. */
name|DBRUNIF
argument_list|(
argument|(!(txbd->tx_bd_flags& TX_BD_FLAGS_END))
argument_list|,
argument|BCE_PRINTF(
literal|"%s(%d): tx_bd END flag not set but "
literal|"txmbuf == NULL!\n"
argument|, __FILE__, __LINE__); 			    bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_INFO_SEND
argument_list|,
name|BCE_PRINTF
argument_list|(
literal|"%s(): Unloading map/freeing mbuf "
literal|"from tx_bd[0x%04X]\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sw_tx_chain_cons
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unmap the mbuf. */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|sc
operator|->
name|tx_mbuf_map
index|[
name|sw_tx_chain_cons
index|]
argument_list|)
expr_stmt|;
comment|/* Free the mbuf. */
name|m_freem
argument_list|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|sw_tx_chain_cons
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|sw_tx_chain_cons
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|debug_tx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|used_tx_bd
operator|--
expr_stmt|;
name|sw_tx_cons
operator|=
name|NEXT_TX_BD
argument_list|(
name|sw_tx_cons
argument_list|)
expr_stmt|;
comment|/* Refresh hw_cons to see if there's new work. */
name|hw_tx_cons
operator|=
name|sc
operator|->
name|hw_tx_cons
operator|=
name|bce_get_hw_tx_cons
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prevent speculative reads of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the TX timeout timer. */
name|sc
operator|->
name|watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* Clear the tx hardware queue full flag. */
if|if
condition|(
name|sc
operator|->
name|used_tx_bd
operator|<
name|sc
operator|->
name|max_tx_bd
condition|)
block|{
name|DBRUNIF
argument_list|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
argument_list|,
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): Open TX chain! %d/%d (used/total)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|used_tx_bd
argument_list|,
name|sc
operator|->
name|max_tx_bd
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|sc
operator|->
name|tx_cons
operator|=
name|sw_tx_cons
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_SEND
argument_list|,
literal|"%s(exit): tx_prod = 0x%04X, "
literal|"tx_cons = 0x%04X, tx_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|tx_prod
argument_list|,
name|sc
operator|->
name|tx_cons
argument_list|,
name|sc
operator|->
name|tx_prod_bseq
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Disables interrupt generation.                                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_disable_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_MASK_INT
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Enables interrupt generation.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_enable_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|coal_now
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_INDEX_VALID
operator||
name|BCE_PCICFG_INT_ACK_CMD_MASK_INT
operator||
name|sc
operator|->
name|last_status_idx
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_INDEX_VALID
operator||
name|sc
operator|->
name|last_status_idx
argument_list|)
expr_stmt|;
comment|/* Force an immediate interrupt (whether there is new data or not). */
if|if
condition|(
name|coal_now
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|,
name|sc
operator|->
name|hc_command
operator||
name|BCE_HC_COMMAND_COAL_NOW
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles controller initialization.                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|ether_mtu
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
comment|/* Check if the driver is still running and bail out if it is. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
goto|goto
name|bce_init_locked_exit
goto|;
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Controller reset failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_init_locked_exit
goto|;
block|}
if|if
condition|(
name|bce_chipinit
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Controller initialization failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_init_locked_exit
goto|;
block|}
if|if
condition|(
name|bce_blockinit
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Block initialization failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_init_locked_exit
goto|;
block|}
comment|/* Load our MAC address. */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|bce_ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bce_set_mac_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate and program the hardware Ethernet MTU 	 * size. Be generous on the receive if we have room. 	 */
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|<=
operator|(
name|sc
operator|->
name|rx_bd_mbuf_data_len
operator|+
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
operator|)
condition|)
name|ether_mtu
operator|=
name|sc
operator|->
name|rx_bd_mbuf_data_len
operator|+
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|<=
name|sc
operator|->
name|rx_bd_mbuf_data_len
condition|)
name|ether_mtu
operator|=
name|sc
operator|->
name|rx_bd_mbuf_data_len
expr_stmt|;
endif|#
directive|endif
else|else
name|ether_mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
name|ether_mtu
operator|+=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_MISC
argument_list|,
literal|"%s(): setting h/w mtu = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ether_mtu
argument_list|)
expr_stmt|;
comment|/* Program the mtu, enabling jumbo frame support if necessary. */
if|if
condition|(
name|ether_mtu
operator|>
operator|(
name|ETHER_MAX_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_RX_MTU_SIZE
argument_list|,
name|min
argument_list|(
name|ether_mtu
argument_list|,
name|BCE_MAX_JUMBO_ETHER_MTU
argument_list|)
operator||
name|BCE_EMAC_RX_MTU_SIZE_JUMBO_ENA
argument_list|)
expr_stmt|;
else|else
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_RX_MTU_SIZE
argument_list|,
name|ether_mtu
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): rx_bd_mbuf_alloc_size = %d, rx_bce_mbuf_data_len = %d, "
literal|"rx_bd_mbuf_align_pad = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
argument_list|,
name|sc
operator|->
name|rx_bd_mbuf_data_len
argument_list|,
name|sc
operator|->
name|rx_bd_mbuf_align_pad
argument_list|)
expr_stmt|;
comment|/* Program appropriate promiscuous/multicast filtering. */
name|bce_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"%s(): pg_bd_mbuf_alloc_size = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|pg_bd_mbuf_alloc_size
argument_list|)
expr_stmt|;
comment|/* Init page buffer descriptor chain. */
name|bce_init_pg_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Init RX buffer descriptor chain. */
name|bce_init_rx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Init TX buffer descriptor chain. */
name|bce_init_tx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable host interrupts. */
name|bce_enable_intr
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bce_ifmedia_upd_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Let the OS know the driver is up and running. */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|bce_tick_callout
argument_list|,
name|hz
argument_list|,
name|bce_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|bce_init_locked_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the controller just enough so that any management firmware    */
end_comment

begin_comment
comment|/* running on the device will continue to operate correctly.                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_mgmt_init_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Bail out if management firmware is not running. */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_MFW_ENABLE_FLAG
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_SPECIAL
argument_list|,
literal|"No management firmware running...\n"
argument_list|)
expr_stmt|;
goto|goto
name|bce_mgmt_init_locked_exit
goto|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
comment|/* Enable all critical blocks in the MAC. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|,
name|BCE_MISC_ENABLE_DEFAULT
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|bce_ifmedia_upd_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bce_mgmt_init_locked_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles controller initialization when called from an unlocked routine.  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Modifies an mbuf for TSO on the hardware.                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Pointer to a modified mbuf.                                            */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|bce_tso_setup
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|,
name|u16
modifier|*
name|flags
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|int
name|hdr_len
decl_stmt|,
name|ip_hlen
init|=
literal|0
decl_stmt|,
name|tcp_hlen
init|=
literal|0
decl_stmt|,
name|ip_len
init|=
literal|0
decl_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|tso_frames_requested
operator|++
argument_list|)
expr_stmt|;
comment|/* Controller may modify mbuf chains. */
if|if
condition|(
name|M_WRITABLE
argument_list|(
operator|*
name|m_head
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m_dup
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|mbuf_alloc_failed_count
operator|++
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 * For TSO the controller needs two pieces of info, 	 * the MSS and the IP+TCP options length. 	 */
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m_head
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* Check for supported TSO Ethernet types (only IPv4 for now) */
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
expr_stmt|;
comment|/* TSO only supported for TCP protocol. */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): TSO enabled for non-TCP frame!.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Get IP header length in bytes (min 20) */
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m_head
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
name|ip_hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Get the TCP header length in bytes (min 20) */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|tcp_hlen
operator|=
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Make sure all IP/TCP options live in the same buffer. */
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m_head
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
name|ip_hlen
operator|+
name|tcp_hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* IP header length and checksum will be calc'd by hardware */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
expr_stmt|;
name|ip_len
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): TSO over IPv6 not supported!.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* NOT REACHED */
default|default:
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): TSO enabled for unsupported protocol!.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|hdr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
name|ip_hlen
operator|+
name|tcp_hlen
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXTREME_SEND
argument_list|,
literal|"%s(): hdr_len = %d, e_hlen = %d, "
literal|"ip_hlen = %d, tcp_hlen = %d, ip_len = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|hdr_len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|ip_hlen
argument_list|,
name|tcp_hlen
argument_list|,
name|ip_len
argument_list|)
expr_stmt|;
comment|/* Set the LSO flag in the TX BD */
operator|*
name|flags
operator||=
name|TX_BD_FLAGS_SW_LSO
expr_stmt|;
comment|/* Set the length of IP + TCP options (in 32 bit words) */
operator|*
name|flags
operator||=
operator|(
operator|(
operator|(
name|ip_hlen
operator|+
name|tcp_hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|)
operator|>>
literal|2
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|tso_frames_completed
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|m_head
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Encapsultes an mbuf cluster into the tx_bd chain structure and makes the */
end_comment

begin_comment
comment|/* memory visible to the controller.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/* Modified:                                                                */
end_comment

begin_comment
comment|/*   m_head: May be set to NULL if MBUF is excessively fragmented.          */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_tx_encap
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
name|BCE_MAX_SEGMENTS
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|tx_bd
modifier|*
name|txbd
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|u16
name|prod
decl_stmt|,
name|chain_prod
decl_stmt|,
name|mss
init|=
literal|0
decl_stmt|,
name|vlan_tag
init|=
literal|0
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|u32
name|prod_bseq
decl_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|u16
name|debug_prod
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_SEND
argument_list|)
expr_stmt|;
comment|/* Make sure we have room in the TX chain. */
if|if
condition|(
name|sc
operator|->
name|used_tx_bd
operator|>=
name|sc
operator|->
name|max_tx_bd
condition|)
goto|goto
name|bce_tx_encap_exit
goto|;
comment|/* Transfer any checksum offload flags to the bd. */
name|m0
operator|=
operator|*
name|m_head
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|m0
operator|=
name|bce_tso_setup
argument_list|(
name|sc
argument_list|,
name|m_head
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|DBRUN
argument_list|(
name|sc
operator|->
name|tso_frames_failed
operator|++
argument_list|)
expr_stmt|;
goto|goto
name|bce_tx_encap_exit
goto|;
block|}
name|mss
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
name|flags
operator||=
name|TX_BD_FLAGS_IP_CKSUM
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
condition|)
name|flags
operator||=
name|TX_BD_FLAGS_TCP_UDP_CKSUM
expr_stmt|;
block|}
block|}
comment|/* Transfer any VLAN tags to the bd. */
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|flags
operator||=
name|TX_BD_FLAGS_VLAN_TAG
expr_stmt|;
name|vlan_tag
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
expr_stmt|;
block|}
comment|/* Map the mbuf into DMAable memory. */
name|prod
operator|=
name|sc
operator|->
name|tx_prod
expr_stmt|;
name|chain_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|prod
argument_list|)
expr_stmt|;
name|map
operator|=
name|sc
operator|->
name|tx_mbuf_map
index|[
name|chain_prod
index|]
expr_stmt|;
comment|/* Map the mbuf into our DMA address space. */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Check if the DMA mapping was successful */
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|sc
operator|->
name|mbuf_frag_count
operator|++
expr_stmt|;
comment|/* Try to defrag the mbuf. */
name|m0
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|BCE_MAX_SEGMENTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
comment|/* Defrag was unsuccessful */
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|mbuf_alloc_failed_count
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_tx_encap_exit
goto|;
block|}
comment|/* Defrag was successful, try mapping again */
operator|*
name|m_head
operator|=
name|m0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Still getting an error after a defrag. */
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
comment|/* Insufficient DMA buffers available. */
name|sc
operator|->
name|dma_map_addr_tx_failed_count
operator|++
expr_stmt|;
name|rc
operator|=
name|error
expr_stmt|;
goto|goto
name|bce_tx_encap_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Release it and return an error. */
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Unknown error mapping mbuf into "
literal|"TX chain!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|dma_map_addr_tx_failed_count
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_tx_encap_exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
comment|/* Insufficient DMA buffers available. */
name|sc
operator|->
name|dma_map_addr_tx_failed_count
operator|++
expr_stmt|;
name|rc
operator|=
name|error
expr_stmt|;
goto|goto
name|bce_tx_encap_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|dma_map_addr_tx_failed_count
operator|++
expr_stmt|;
name|rc
operator|=
name|error
expr_stmt|;
goto|goto
name|bce_tx_encap_exit
goto|;
block|}
comment|/* Make sure there's room in the chain */
if|if
condition|(
name|nsegs
operator|>
operator|(
name|sc
operator|->
name|max_tx_bd
operator|-
name|sc
operator|->
name|used_tx_bd
operator|)
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_tx_encap_exit
goto|;
block|}
comment|/* prod points to an empty tx_bd at this point. */
name|prod_bseq
operator|=
name|sc
operator|->
name|tx_prod_bseq
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|debug_prod
operator|=
name|chain_prod
expr_stmt|;
endif|#
directive|endif
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(start): prod = 0x%04X, chain_prod = 0x%04X, "
literal|"prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|prod
argument_list|,
name|chain_prod
argument_list|,
name|prod_bseq
argument_list|)
expr_stmt|;
comment|/* 	 * Cycle through each mbuf segment that makes up 	 * the outgoing frame, gathering the mapping info 	 * for that segment and creating a tx_bd for 	 * the mbuf. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|chain_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|prod
argument_list|)
expr_stmt|;
name|txbd
operator|=
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|TX_PAGE
argument_list|(
name|chain_prod
argument_list|)
index|]
index|[
name|TX_IDX
argument_list|(
name|chain_prod
argument_list|)
index|]
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_mss_nbytes
operator|=
name|htole32
argument_list|(
name|mss
operator|<<
literal|16
argument_list|)
operator||
name|htole16
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_vlan_tag
operator|=
name|htole16
argument_list|(
name|vlan_tag
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_flags
operator|=
name|htole16
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|prod_bseq
operator|+=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|txbd
operator|->
name|tx_bd_flags
operator||=
name|htole16
argument_list|(
name|TX_BD_FLAGS_START
argument_list|)
expr_stmt|;
name|prod
operator|=
name|NEXT_TX_BD
argument_list|(
name|prod
argument_list|)
expr_stmt|;
block|}
comment|/* Set the END flag on the last TX buffer descriptor. */
name|txbd
operator|->
name|tx_bd_flags
operator||=
name|htole16
argument_list|(
name|TX_BD_FLAGS_END
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_EXTREME_SEND
argument_list|,
name|bce_dump_tx_chain
argument_list|(
name|sc
argument_list|,
name|debug_prod
argument_list|,
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the mbuf pointer for this transmission 	 * is placed at the array index of the last 	 * descriptor in this chain.  This is done 	 * because a single map is used for all 	 * segments of the mbuf and we don't want to 	 * unload the map before all of the segments 	 * have been freed. 	 */
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|chain_prod
index|]
operator|=
name|m0
expr_stmt|;
name|sc
operator|->
name|used_tx_bd
operator|+=
name|nsegs
expr_stmt|;
comment|/* Update some debug statistic counters */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|used_tx_bd
operator|>
name|sc
operator|->
name|tx_hi_watermark
operator|)
argument_list|,
name|sc
operator|->
name|tx_hi_watermark
operator|=
name|sc
operator|->
name|used_tx_bd
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|used_tx_bd
operator|==
name|sc
operator|->
name|max_tx_bd
operator|)
argument_list|,
name|sc
operator|->
name|tx_full_count
operator|++
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
name|sc
operator|->
name|debug_tx_mbuf_alloc
operator|++
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_EXTREME_SEND
argument_list|,
name|bce_dump_tx_mbuf_chain
argument_list|(
name|sc
argument_list|,
name|chain_prod
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prod points to the next free tx_bd at this point. */
name|sc
operator|->
name|tx_prod
operator|=
name|prod
expr_stmt|;
name|sc
operator|->
name|tx_prod_bseq
operator|=
name|prod_bseq
expr_stmt|;
comment|/* Tell the chip about the waiting TX frames. */
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|MB_GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
operator|+
name|BCE_L2MQ_TX_HOST_BIDX
argument_list|,
name|sc
operator|->
name|tx_prod
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MB_GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
operator|+
name|BCE_L2MQ_TX_HOST_BSEQ
argument_list|,
name|sc
operator|->
name|tx_prod_bseq
argument_list|)
expr_stmt|;
name|bce_tx_encap_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_SEND
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Main transmit routine when called from another routine with a lock.      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
init|=
name|NULL
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u16
name|tx_prod
decl_stmt|,
name|tx_chain_prod
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* prod points to the next free tx_bd. */
name|tx_prod
operator|=
name|sc
operator|->
name|tx_prod
expr_stmt|;
name|tx_chain_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|tx_prod
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(enter): tx_prod = 0x%04X, tx_chain_prod = 0x%04X, "
literal|"tx_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|tx_prod
argument_list|,
name|tx_chain_prod
argument_list|,
name|sc
operator|->
name|tx_prod_bseq
argument_list|)
expr_stmt|;
comment|/* If there's no link or the transmit queue is empty then just exit. */
if|if
condition|(
name|sc
operator|->
name|bce_link_up
operator|==
name|FALSE
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): No link.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bce_start_locked_exit
goto|;
block|}
if|if
condition|(
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): Transmit queue empty.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bce_start_locked_exit
goto|;
block|}
comment|/* 	 * Keep adding entries while there is space in the ring. 	 */
while|while
condition|(
name|sc
operator|->
name|used_tx_bd
operator|<
name|sc
operator|->
name|max_tx_bd
condition|)
block|{
comment|/* Check for any frames to send. */
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
comment|/* Stop when the transmit queue is empty. */
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, place the mbuf back at the 		 * head of the queue and set the OACTIVE flag 		 * to wait for the NIC to drain the chain. 		 */
if|if
condition|(
name|bce_tx_encap
argument_list|(
name|sc
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|!=
name|NULL
condition|)
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"TX chain is closed for business! Total "
literal|"tx_bd used = %d\n"
argument_list|,
name|sc
operator|->
name|used_tx_bd
argument_list|)
expr_stmt|;
break|break;
block|}
name|count
operator|++
expr_stmt|;
comment|/* Send a copy of the frame to any BPF listeners. */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
comment|/* Exit if no packets were dequeued. */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_SEND
argument_list|,
literal|"%s(): No packets were "
literal|"dequeued\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bce_start_locked_exit
goto|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_SEND
argument_list|,
literal|"%s(): Inserted %d frames into "
literal|"send queue.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Set the tx timeout. */
name|sc
operator|->
name|watchdog_timer
operator|=
name|BCE_TX_TIMEOUT
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_VERBOSE_SEND
argument_list|,
name|bce_dump_ctx
argument_list|(
name|sc
argument_list|,
name|TX_CID
argument_list|)
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_VERBOSE_SEND
argument_list|,
name|bce_dump_mq_regs
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bce_start_locked_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_CTX
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Main transmit routine when called from another routine without a lock.   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_SEND
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_SEND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles any IOCTL calls from the operating system.                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|reinit
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_MISC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
comment|/* Set the interface MTU. */
case|case
name|SIOCSIFMTU
case|:
comment|/* Check that the MTU setting is supported. */
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|BCE_MIN_MTU
operator|)
operator|||
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|BCE_MAX_JUMBO_MTU
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_MISC
argument_list|,
literal|"SIOCSIFMTU: Changing MTU from %d to %d\n"
argument_list|,
operator|(
name|int
operator|)
name|ifp
operator|->
name|if_mtu
argument_list|,
operator|(
name|int
operator|)
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 			 * Because allocation size is used in RX 			 * buffer allocation, stop controller if 			 * it is already running. 			 */
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
comment|/* No buffer allocation size changes are necessary. */
else|#
directive|else
comment|/* Recalculate our buffer allocation sizes. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|+
name|ETHER_CRC_LEN
operator|)
operator|>
name|MCLBYTES
condition|)
block|{
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|=
name|MJUM9BYTES
expr_stmt|;
name|sc
operator|->
name|rx_bd_mbuf_align_pad
operator|=
name|roundup2
argument_list|(
name|MJUM9BYTES
argument_list|,
literal|16
argument_list|)
operator|-
name|MJUM9BYTES
expr_stmt|;
name|sc
operator|->
name|rx_bd_mbuf_data_len
operator|=
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|-
name|sc
operator|->
name|rx_bd_mbuf_align_pad
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|rx_bd_mbuf_align_pad
operator|=
name|roundup2
argument_list|(
name|MCLBYTES
argument_list|,
literal|16
argument_list|)
operator|-
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|rx_bd_mbuf_data_len
operator|=
name|sc
operator|->
name|rx_bd_mbuf_alloc_size
operator|-
name|sc
operator|->
name|rx_bd_mbuf_align_pad
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reinit
operator|!=
literal|0
condition|)
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
comment|/* Set interface flags. */
case|case
name|SIOCSIFFLAGS
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_SPECIAL
argument_list|,
literal|"Received SIOCSIFFLAGS\n"
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check if the interface is up. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* Change promiscuous/multicast flags as necessary. */
name|bce_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Start the HW */
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The interface is down, check if driver is running. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If MFW is running, restart the controller a bit. */
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_MFW_ENABLE_FLAG
condition|)
block|{
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
expr_stmt|;
name|bce_chipinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_mgmt_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
comment|/* Add/Delete multicast address */
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_MISC
argument_list|,
literal|"Received SIOCADDMULTI/SIOCDELMULTI\n"
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|bce_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
comment|/* Set/Get Interface media */
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_MISC
argument_list|,
literal|"Received SIOCSIFMEDIA/SIOCGIFMEDIA\n"
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
comment|/* Set interface capability */
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_MISC
argument_list|,
literal|"Received SIOCSIFCAP = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|mask
argument_list|)
expr_stmt|;
comment|/* Toggle the TX checksum capabilities enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
operator|&&
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|BCE_IF_HWASSIST
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|BCE_IF_HWASSIST
expr_stmt|;
block|}
comment|/* Toggle the RX checksum capabilities enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
operator|&&
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
comment|/* Toggle the TSO capabilities enable flag. */
if|if
condition|(
name|bce_tso_enable
operator|&&
operator|(
name|mask
operator|&
name|IFCAP_TSO4
operator|)
operator|&&
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
operator|&&
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_VLAN_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_VLAN_HWTSO
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
comment|/* 		 * Don't actually disable VLAN tag stripping as 		 * management firmware (ASF/IPMI/UMP) requires the 		 * feature. If VLAN tag stripping is disabled driver 		 * will manually reconstruct the VLAN frame by 		 * appending stripped VLAN tag. 		 */
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_VLAN_HWTSO
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* We don't know how to handle the IOCTL, pass it on. */
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_MISC
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Transmit timeout handler.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_watchdog
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BCE_EXTREME_SEND
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If the watchdog timer hasn't expired then just exit. */
if|if
condition|(
name|sc
operator|->
name|watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|watchdog_timer
condition|)
goto|goto
name|bce_watchdog_exit
goto|;
comment|/* If pause frames are active then don't reset the hardware. */
comment|/* ToDo: Should we reset the timer here? */
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_TX_STATUS
argument_list|)
operator|&
name|BCE_EMAC_TX_STATUS_XOFFED
condition|)
goto|goto
name|bce_watchdog_exit
goto|;
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Watchdog timeout occurred, resetting!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
argument|BCE_INFO
argument_list|,
argument|bce_dump_driver_state(sc); 	    bce_dump_status_block(sc); 	    bce_dump_stats_block(sc); 	    bce_dump_ftqs(sc); 	    bce_dump_txp_state(sc,
literal|0
argument|); 	    bce_dump_rxp_state(sc,
literal|0
argument|); 	    bce_dump_tpat_state(sc,
literal|0
argument|); 	    bce_dump_cp_state(sc,
literal|0
argument|); 	    bce_dump_com_state(sc,
literal|0
argument|)
argument_list|)
empty_stmt|;
name|DBRUN
argument_list|(
name|bce_breakpoint
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|bce_watchdog_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_EXTREME_SEND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler.  */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Main interrupt entry point.  Verifies that the controller generated the  */
end_comment

begin_comment
comment|/* interrupt and then calls a separate routine for handle the various       */
end_comment

begin_comment
comment|/* interrupt causes (PHY, TX, RX).                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|status_attn_bits
decl_stmt|;
name|u16
name|hw_rx_cons
decl_stmt|,
name|hw_tx_cons
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_VERBOSE_INTR
argument_list|,
name|bce_dump_status_block
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BCE_VERBOSE_INTR
argument_list|,
name|bce_dump_stats_block
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|sc
operator|->
name|interrupts_generated
operator|++
argument_list|)
expr_stmt|;
comment|/* Synchnorize before we read from interface's status block */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 	 * If the hardware status block index 	 * matches the last value read by the 	 * driver and we haven't asserted our 	 * interrupt then there's nothing to do. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|status_block
operator|->
name|status_idx
operator|==
name|sc
operator|->
name|last_status_idx
operator|)
operator|&&
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_MISC_STATUS
argument_list|)
operator|&
name|BCE_PCICFG_MISC_STATUS_INTA_VALUE
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_INTR
argument_list|,
literal|"%s(): Spurious interrupt.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bce_intr_exit
goto|;
block|}
comment|/* Ack the interrupt and stop others from occuring. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM
operator||
name|BCE_PCICFG_INT_ACK_CMD_MASK_INT
argument_list|)
expr_stmt|;
comment|/* Check if the hardware has finished any work. */
name|hw_rx_cons
operator|=
name|bce_get_hw_rx_cons
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hw_tx_cons
operator|=
name|bce_get_hw_tx_cons
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Keep processing data as long as there is work to do. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|status_attn_bits
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(unexpected_attention_sim_control)
argument_list|,
argument|BCE_PRINTF(
literal|"Simulating unexpected status attention "
literal|"bit set."
argument|); 		    sc->unexpected_attention_sim_count++; 		    status_attn_bits = status_attn_bits | 		    STATUS_ATTN_BITS_PARITY_ERROR
argument_list|)
empty_stmt|;
comment|/* Was it a link change interrupt? */
if|if
condition|(
operator|(
name|status_attn_bits
operator|&
name|STATUS_ATTN_BITS_LINK_STATE
operator|)
operator|!=
operator|(
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits_ack
operator|&
name|STATUS_ATTN_BITS_LINK_STATE
operator|)
condition|)
block|{
name|bce_phy_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear transient updates during link state change. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|,
name|sc
operator|->
name|hc_command
operator||
name|BCE_HC_COMMAND_COAL_NOW_WO_INT
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|)
expr_stmt|;
block|}
comment|/* If any other attention is asserted, the chip is toast. */
if|if
condition|(
operator|(
operator|(
name|status_attn_bits
operator|&
operator|~
name|STATUS_ATTN_BITS_LINK_STATE
operator|)
operator|!=
operator|(
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits_ack
operator|&
operator|~
name|STATUS_ATTN_BITS_LINK_STATE
operator|)
operator|)
condition|)
block|{
name|sc
operator|->
name|unexpected_attention_count
operator|++
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"%s(%d): Fatal attention detected: "
literal|"0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits
argument_list|)
expr_stmt|;
name|DBRUNMSG
argument_list|(
argument|BCE_FATAL
argument_list|,
argument|if (unexpected_attention_sim_control ==
literal|0
argument|) 				bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|bce_intr_exit
goto|;
block|}
comment|/* Check for any completed RX frames. */
if|if
condition|(
name|hw_rx_cons
operator|!=
name|sc
operator|->
name|hw_rx_cons
condition|)
name|bce_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check for any completed TX frames. */
if|if
condition|(
name|hw_tx_cons
operator|!=
name|sc
operator|->
name|hw_tx_cons
condition|)
name|bce_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Save status block index value for the next interrupt. */
name|sc
operator|->
name|last_status_idx
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_idx
expr_stmt|;
comment|/*  		 * Prevent speculative reads from getting  		 * ahead of the status block. 		 */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
comment|/*  		 * If there's no work left then exit the  		 * interrupt service routine. 		 */
name|hw_rx_cons
operator|=
name|bce_get_hw_rx_cons
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hw_tx_cons
operator|=
name|bce_get_hw_tx_cons
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw_rx_cons
operator|==
name|sc
operator|->
name|hw_rx_cons
operator|)
operator|&&
operator|(
name|hw_tx_cons
operator|==
name|sc
operator|->
name|hw_tx_cons
operator|)
condition|)
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts. */
name|bce_enable_intr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle any frames that arrived while handling the interrupt. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|bce_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bce_intr_exit
label|:
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_SEND
operator||
name|BCE_VERBOSE_RECV
operator||
name|BCE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Programs the various packet receive modes (broadcast and multicast).     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_set_rx_mode
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u32
name|hashes
index|[
name|NUM_MC_HASH_REGISTERS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u32
name|rx_mode
decl_stmt|,
name|sort_mode
decl_stmt|;
name|int
name|h
decl_stmt|,
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
comment|/* Initialize receive mode default settings. */
name|rx_mode
operator|=
name|sc
operator|->
name|rx_mode
operator|&
operator|~
operator|(
name|BCE_EMAC_RX_MODE_PROMISCUOUS
operator||
name|BCE_EMAC_RX_MODE_KEEP_VLAN_TAG
operator|)
expr_stmt|;
name|sort_mode
operator|=
literal|1
operator||
name|BCE_RPM_SORT_USER0_BC_EN
expr_stmt|;
comment|/* 	 * ASF/IPMI/UMP firmware requires that VLAN tag stripping 	 * be enbled. 	 */
if|if
condition|(
operator|!
operator|(
name|BCE_IF_CAPABILITIES
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|&&
operator|(
operator|!
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_MFW_ENABLE_FLAG
operator|)
operator|)
condition|)
name|rx_mode
operator||=
name|BCE_EMAC_RX_MODE_KEEP_VLAN_TAG
expr_stmt|;
comment|/* 	 * Check for promiscuous, all multicast, or selected 	 * multicast address filtering. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_MISC
argument_list|,
literal|"Enabling promiscuous mode.\n"
argument_list|)
expr_stmt|;
comment|/* Enable promiscuous mode. */
name|rx_mode
operator||=
name|BCE_EMAC_RX_MODE_PROMISCUOUS
expr_stmt|;
name|sort_mode
operator||=
name|BCE_RPM_SORT_USER0_PROM_EN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_MISC
argument_list|,
literal|"Enabling all multicast mode.\n"
argument_list|)
expr_stmt|;
comment|/* Enable all multicast addresses. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MC_HASH_REGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MULTICAST_HASH0
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
name|sort_mode
operator||=
name|BCE_RPM_SORT_USER0_MC_EN
expr_stmt|;
block|}
else|else
block|{
comment|/* Accept one or more multicast(s). */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_MISC
argument_list|,
literal|"Enabling selective multicast mode.\n"
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|h
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|hashes
index|[
operator|(
name|h
operator|&
literal|0xE0
operator|)
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|h
operator|&
literal|0x1F
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MC_HASH_REGISTERS
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MULTICAST_HASH0
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
name|hashes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sort_mode
operator||=
name|BCE_RPM_SORT_USER0_MC_HSH_EN
expr_stmt|;
block|}
comment|/* Only make changes if the recive mode has actually changed. */
if|if
condition|(
name|rx_mode
operator|!=
name|sc
operator|->
name|rx_mode
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_MISC
argument_list|,
literal|"Enabling new receive mode: "
literal|"0x%08X\n"
argument_list|,
name|rx_mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mode
operator|=
name|rx_mode
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_RX_MODE
argument_list|,
name|rx_mode
argument_list|)
expr_stmt|;
block|}
comment|/* Disable and clear the exisitng sort before enabling a new sort. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_SORT_USER0
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_SORT_USER0
argument_list|,
name|sort_mode
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_SORT_USER0
argument_list|,
name|sort_mode
operator||
name|BCE_RPM_SORT_USER0_ENA
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_MISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Called periodically to updates statistics from the controllers           */
end_comment

begin_comment
comment|/* statistics block.                                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_stats_update
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|statistics_block
modifier|*
name|stats
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_EXTREME_MISC
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|statistics_block
operator|*
operator|)
name|sc
operator|->
name|stats_block
expr_stmt|;
comment|/* 	 * Certain controllers don't report 	 * carrier sense errors correctly. 	 * See errata E11_5708CA0_1165. 	 */
if|if
condition|(
operator|!
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5706
operator|)
operator|&&
operator|!
operator|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_ID_5708_A0
operator|)
condition|)
name|ifp
operator|->
name|if_oerrors
operator|+=
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_Dot3StatsCarrierSenseErrors
expr_stmt|;
comment|/* 	 * Update the sysctl statistics from the 	 * hardware statistics. 	 */
name|sc
operator|->
name|stat_IfHCInOctets
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInOctets_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInOctets_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCInBadOctets
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInBadOctets_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInBadOctets_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutOctets
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutOctets_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutOctets_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutBadOctets
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutBadOctets_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutBadOctets_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCInUcastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInUcastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInUcastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCInMulticastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInMulticastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInMulticastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCInBroadcastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInBroadcastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInBroadcastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutUcastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutUcastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutUcastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutMulticastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutMulticastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutMulticastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutBroadcastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutBroadcastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutBroadcastPkts_lo
expr_stmt|;
comment|/* ToDo: Preserve counters beyond 32 bits? */
comment|/* ToDo: Read the statistics from auto-clear regs? */
name|sc
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
operator|=
name|stats
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsCarrierSenseErrors
operator|=
name|stats
operator|->
name|stat_Dot3StatsCarrierSenseErrors
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsFCSErrors
operator|=
name|stats
operator|->
name|stat_Dot3StatsFCSErrors
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsAlignmentErrors
operator|=
name|stats
operator|->
name|stat_Dot3StatsAlignmentErrors
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsSingleCollisionFrames
operator|=
name|stats
operator|->
name|stat_Dot3StatsSingleCollisionFrames
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsMultipleCollisionFrames
operator|=
name|stats
operator|->
name|stat_Dot3StatsMultipleCollisionFrames
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsDeferredTransmissions
operator|=
name|stats
operator|->
name|stat_Dot3StatsDeferredTransmissions
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsExcessiveCollisions
operator|=
name|stats
operator|->
name|stat_Dot3StatsExcessiveCollisions
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsLateCollisions
operator|=
name|stats
operator|->
name|stat_Dot3StatsLateCollisions
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsCollisions
operator|=
name|stats
operator|->
name|stat_EtherStatsCollisions
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsFragments
operator|=
name|stats
operator|->
name|stat_EtherStatsFragments
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsJabbers
operator|=
name|stats
operator|->
name|stat_EtherStatsJabbers
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsUndersizePkts
operator|=
name|stats
operator|->
name|stat_EtherStatsUndersizePkts
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsOversizePkts
operator|=
name|stats
operator|->
name|stat_EtherStatsOversizePkts
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx64Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx64Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx65Octetsto127Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx65Octetsto127Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx128Octetsto255Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx128Octetsto255Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx256Octetsto511Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx256Octetsto511Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx512Octetsto1023Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx512Octetsto1023Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx64Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx64Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx65Octetsto127Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx65Octetsto127Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx128Octetsto255Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx128Octetsto255Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx256Octetsto511Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx256Octetsto511Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx512Octetsto1023Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx512Octetsto1023Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
expr_stmt|;
name|sc
operator|->
name|stat_XonPauseFramesReceived
operator|=
name|stats
operator|->
name|stat_XonPauseFramesReceived
expr_stmt|;
name|sc
operator|->
name|stat_XoffPauseFramesReceived
operator|=
name|stats
operator|->
name|stat_XoffPauseFramesReceived
expr_stmt|;
name|sc
operator|->
name|stat_OutXonSent
operator|=
name|stats
operator|->
name|stat_OutXonSent
expr_stmt|;
name|sc
operator|->
name|stat_OutXoffSent
operator|=
name|stats
operator|->
name|stat_OutXoffSent
expr_stmt|;
name|sc
operator|->
name|stat_FlowControlDone
operator|=
name|stats
operator|->
name|stat_FlowControlDone
expr_stmt|;
name|sc
operator|->
name|stat_MacControlFramesReceived
operator|=
name|stats
operator|->
name|stat_MacControlFramesReceived
expr_stmt|;
name|sc
operator|->
name|stat_XoffStateEntered
operator|=
name|stats
operator|->
name|stat_XoffStateEntered
expr_stmt|;
name|sc
operator|->
name|stat_IfInFramesL2FilterDiscards
operator|=
name|stats
operator|->
name|stat_IfInFramesL2FilterDiscards
expr_stmt|;
name|sc
operator|->
name|stat_IfInRuleCheckerDiscards
operator|=
name|stats
operator|->
name|stat_IfInRuleCheckerDiscards
expr_stmt|;
name|sc
operator|->
name|stat_IfInFTQDiscards
operator|=
name|stats
operator|->
name|stat_IfInFTQDiscards
expr_stmt|;
name|sc
operator|->
name|stat_IfInMBUFDiscards
operator|=
name|stats
operator|->
name|stat_IfInMBUFDiscards
expr_stmt|;
name|sc
operator|->
name|stat_IfInRuleCheckerP4Hit
operator|=
name|stats
operator|->
name|stat_IfInRuleCheckerP4Hit
expr_stmt|;
name|sc
operator|->
name|stat_CatchupInRuleCheckerDiscards
operator|=
name|stats
operator|->
name|stat_CatchupInRuleCheckerDiscards
expr_stmt|;
name|sc
operator|->
name|stat_CatchupInFTQDiscards
operator|=
name|stats
operator|->
name|stat_CatchupInFTQDiscards
expr_stmt|;
name|sc
operator|->
name|stat_CatchupInMBUFDiscards
operator|=
name|stats
operator|->
name|stat_CatchupInMBUFDiscards
expr_stmt|;
name|sc
operator|->
name|stat_CatchupInRuleCheckerP4Hit
operator|=
name|stats
operator|->
name|stat_CatchupInRuleCheckerP4Hit
expr_stmt|;
name|sc
operator|->
name|com_no_buffers
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
literal|0x120084
argument_list|)
expr_stmt|;
comment|/* 	 * Update the interface statistics from the 	 * hardware statistics. 	 */
name|ifp
operator|->
name|if_collisions
operator|=
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_EtherStatsCollisions
expr_stmt|;
comment|/* ToDo: This method loses soft errors. */
name|ifp
operator|->
name|if_ierrors
operator|=
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_EtherStatsUndersizePkts
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_EtherStatsOversizePkts
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_IfInMBUFDiscards
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_Dot3StatsAlignmentErrors
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_Dot3StatsFCSErrors
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_IfInRuleCheckerDiscards
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_IfInFTQDiscards
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|com_no_buffers
expr_stmt|;
comment|/* ToDo: This method loses soft errors. */
name|ifp
operator|->
name|if_oerrors
operator|=
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_Dot3StatsExcessiveCollisions
operator|+
operator|(
name|u_long
operator|)
name|sc
operator|->
name|stat_Dot3StatsLateCollisions
expr_stmt|;
comment|/* ToDo: Add additional statistics? */
name|DBEXIT
argument_list|(
name|BCE_EXTREME_MISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Periodic function to notify the bootcode that the driver is still        */
end_comment

begin_comment
comment|/* present.                                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_pulse
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|u32
name|msg
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_EXTREME_MISC
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Tell the firmware that the driver is still running. */
name|msg
operator|=
operator|(
name|u32
operator|)
operator|++
name|sc
operator|->
name|bce_fw_drv_pulse_wr_seq
expr_stmt|;
name|bce_shmem_wr
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_PULSE_MB
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Update the bootcode condition. */
name|sc
operator|->
name|bc_state
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_BC_STATE_CONDITION
argument_list|)
expr_stmt|;
comment|/* Report whether the bootcode still knows the driver is running. */
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bce_drv_cardiac_arrest
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|bc_state
operator|&
name|BCE_CONDITION_DRV_PRESENT
operator|)
condition|)
block|{
name|sc
operator|->
name|bce_drv_cardiac_arrest
operator|=
name|TRUE
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"%s(): Warning: bootcode "
literal|"thinks driver is absent! "
literal|"(bc_state = 0x%08X)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|bc_state
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Not supported by all bootcode versions. 			 * (v5.0.11+ and v5.2.1+)  Older bootcode 			 * will require the driver to reset the 			 * controller to clear this condition. 			 */
if|if
condition|(
name|sc
operator|->
name|bc_state
operator|&
name|BCE_CONDITION_DRV_PRESENT
condition|)
block|{
name|sc
operator|->
name|bce_drv_cardiac_arrest
operator|=
name|FALSE
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"%s(): Bootcode found the "
literal|"driver pulse! (bc_state = 0x%08X)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|bc_state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Schedule the next pulse. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|bce_pulse_callout
argument_list|,
name|hz
argument_list|,
name|bce_pulse
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BCE_EXTREME_MISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Periodic function to perform maintenance tasks.                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
name|DBENTER
argument_list|(
name|BCE_EXTREME_MISC
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Schedule the next tick. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|bce_tick_callout
argument_list|,
name|hz
argument_list|,
name|bce_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Update the statistics from the hardware statistics block. */
name|bce_stats_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Top off the receive and page chains. */
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|bce_fill_pg_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bce_fill_rx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check that chip hasn't hung. */
name|bce_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If link is up already up then we're done. */
if|if
condition|(
name|sc
operator|->
name|bce_link_up
operator|==
name|TRUE
condition|)
goto|goto
name|bce_tick_exit
goto|;
comment|/* Link is down.  Check what the PHY's doing. */
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
comment|/* Check if the link has come up. */
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
operator|)
operator|&&
operator|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|!=
name|IFM_NONE
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_MISC
argument_list|,
literal|"%s(): Link up!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_link_up
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_1000_T
operator|||
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_1000_SX
operator|||
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_2500_SX
operator|)
operator|&&
name|bootverbose
condition|)
name|BCE_PRINTF
argument_list|(
literal|"Gigabit link up!\n"
argument_list|)
expr_stmt|;
comment|/* Now that link is up, handle any outstanding TX traffic. */
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_MISC
argument_list|,
literal|"%s(): Found "
literal|"pending TX traffic.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|bce_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
name|bce_tick_exit
label|:
name|DBEXIT
argument_list|(
name|BCE_EXTREME_MISC
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allows the driver state to be dumped through the sysctl interface.       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_driver_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allows the hardware state to be dumped through the sysctl interface.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_hw_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_hw_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allows the status block to be dumped through the sysctl interface.       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_status_block
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_status_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allows the stats block to be dumped through the sysctl interface.        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_stats_block
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_stats_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allows the stat counters to be cleared without unloading/reloading the   */
end_comment

begin_comment
comment|/* driver.                                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_stats_clear
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
comment|/* Clear the internal H/W statistics counters. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|,
name|BCE_HC_COMMAND_CLR_STAT_NOW
argument_list|)
expr_stmt|;
comment|/* Reset the driver maintained statistics. */
name|sc
operator|->
name|interrupts_rx
operator|=
name|sc
operator|->
name|interrupts_tx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tso_frames_requested
operator|=
name|sc
operator|->
name|tso_frames_completed
operator|=
name|sc
operator|->
name|tso_frames_failed
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_empty_count
operator|=
name|sc
operator|->
name|tx_full_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_low_watermark
operator|=
name|USABLE_RX_BD
expr_stmt|;
name|sc
operator|->
name|tx_hi_watermark
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|l2fhdr_error_count
operator|=
name|sc
operator|->
name|l2fhdr_error_sim_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mbuf_alloc_failed_count
operator|=
name|sc
operator|->
name|mbuf_alloc_failed_sim_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dma_map_addr_rx_failed_count
operator|=
name|sc
operator|->
name|dma_map_addr_tx_failed_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mbuf_frag_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|csum_offload_tcp_udp
operator|=
name|sc
operator|->
name|csum_offload_ip
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vlan_tagged_frames_rcvd
operator|=
name|sc
operator|->
name|vlan_tagged_frames_stripped
operator|=
literal|0
expr_stmt|;
comment|/* Clear firmware maintained statistics. */
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
literal|0x120084
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allows the bootcode state to be dumped through the sysctl interface.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_bc_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_bc_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to allow dumping the RX BD chain.            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_dump_rx_bd_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_rx_bd_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TOTAL_RX_BD
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to allow dumping the RX MBUF chain.          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_dump_rx_mbuf_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_rx_mbuf_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to allow dumping the TX chain.               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_dump_tx_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_tx_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TOTAL_TX_BD
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to allow dumping the page chain.             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_dump_pg_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_pg_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TOTAL_PG_BD
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to allow reading arbitrary NVRAM offsets in  */
end_comment

begin_comment
comment|/* the device.  DO NOT ENABLE ON PRODUCTION SYSTEMS!                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_nvram_read
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u32
name|result
decl_stmt|;
name|u32
name|val
index|[
literal|1
index|]
decl_stmt|;
name|u8
modifier|*
name|data
init|=
operator|(
name|u8
operator|*
operator|)
name|val
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
name|result
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"offset 0x%08X = 0x%08X\n"
argument_list|,
name|result
argument_list|,
name|bce_be32toh
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to allow reading arbitrary registers in the  */
end_comment

begin_comment
comment|/* device.  DO NOT ENABLE ON PRODUCTION SYSTEMS!                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_reg_read
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u32
name|val
decl_stmt|,
name|result
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Make sure the register is accessible. */
if|if
condition|(
name|result
operator|<
literal|0x8000
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"reg 0x%08X = 0x%08X\n"
argument_list|,
name|result
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|<
literal|0x0280000
condition|)
block|{
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"reg 0x%08X = 0x%08X\n"
argument_list|,
name|result
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to allow reading arbitrary PHY registers in  */
end_comment

begin_comment
comment|/* the device.  DO NOT ENABLE ON PRODUCTION SYSTEMS!                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_phy_read
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|u16
name|val
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Make sure the register is accessible. */
if|if
condition|(
name|result
operator|<
literal|0x20
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|bce_dev
expr_stmt|;
name|val
operator|=
name|bce_miibus_read_reg
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bce_phy_addr
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"phy 0x%02X = 0x%04X\n"
argument_list|,
name|result
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to allow reading a CID.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_dump_ctx
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Make sure the register is accessible. */
if|if
condition|(
name|result
operator|<=
name|TX_CID
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_ctx
argument_list|(
name|sc
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Provides a sysctl interface to forcing the driver to dump state and      */
end_comment

begin_comment
comment|/* enter the debugger.  DO NOT ENABLE ON PRODUCTION SYSTEMS!                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_breakpoint
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_breakpoint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Adds any sysctl parameters for tuning or debugging purposes.             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_add_sysctls
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|DBENTER
argument_list|(
name|BCE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"l2fhdr_error_sim_control"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|l2fhdr_error_sim_control
argument_list|,
literal|0
argument_list|,
literal|"Debug control to force l2fhdr errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"l2fhdr_error_sim_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|l2fhdr_error_sim_count
argument_list|,
literal|0
argument_list|,
literal|"Number of simulated l2_fhdr errors"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"l2fhdr_error_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|l2fhdr_error_count
argument_list|,
literal|0
argument_list|,
literal|"Number of l2_fhdr errors"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_alloc_failed_sim_control"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mbuf_alloc_failed_sim_control
argument_list|,
literal|0
argument_list|,
literal|"Debug control to force mbuf allocation failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_alloc_failed_sim_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|mbuf_alloc_failed_sim_count
argument_list|,
literal|0
argument_list|,
literal|"Number of simulated mbuf cluster allocation failures"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_alloc_failed_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|mbuf_alloc_failed_count
argument_list|,
literal|0
argument_list|,
literal|"Number of mbuf allocation failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_frag_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|mbuf_frag_count
argument_list|,
literal|0
argument_list|,
literal|"Number of fragmented mbufs"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dma_map_addr_failed_sim_control"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dma_map_addr_failed_sim_control
argument_list|,
literal|0
argument_list|,
literal|"Debug control to force DMA mapping failures"
argument_list|)
expr_stmt|;
comment|/* ToDo: Figure out how to update this value in bce_dma_map_addr(). */
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dma_map_addr_failed_sim_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|dma_map_addr_failed_sim_count
argument_list|,
literal|0
argument_list|,
literal|"Number of simulated DMA mapping failures"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dma_map_addr_rx_failed_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|dma_map_addr_rx_failed_count
argument_list|,
literal|0
argument_list|,
literal|"Number of RX DMA mapping failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dma_map_addr_tx_failed_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|dma_map_addr_tx_failed_count
argument_list|,
literal|0
argument_list|,
literal|"Number of TX DMA mapping failures"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"unexpected_attention_sim_control"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unexpected_attention_sim_control
argument_list|,
literal|0
argument_list|,
literal|"Debug control to simulate unexpected attentions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"unexpected_attention_sim_count"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|unexpected_attention_sim_count
argument_list|,
literal|0
argument_list|,
literal|"Number of simulated unexpected attentions"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"unexpected_attention_count"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|unexpected_attention_count
argument_list|,
literal|0
argument_list|,
literal|"Number of unexpected attentions"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_bootcode_running_failure"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bootcode_running_failure_sim_control
argument_list|,
literal|0
argument_list|,
literal|"Debug control to force bootcode running failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_low_watermark"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|rx_low_watermark
argument_list|,
literal|0
argument_list|,
literal|"Lowest level of free rx_bd's"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_empty_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|rx_empty_count
argument_list|,
literal|0
argument_list|,
literal|"Number of times the RX chain was empty"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_hi_watermark"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx_hi_watermark
argument_list|,
literal|0
argument_list|,
literal|"Highest level of used tx_bd's"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_full_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx_full_count
argument_list|,
literal|0
argument_list|,
literal|"Number of times the TX chain was full"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_frames_requested"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tso_frames_requested
argument_list|,
literal|0
argument_list|,
literal|"Number of TSO frames requested"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_frames_completed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tso_frames_completed
argument_list|,
literal|0
argument_list|,
literal|"Number of TSO frames completed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_frames_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tso_frames_failed
argument_list|,
literal|0
argument_list|,
literal|"Number of TSO frames failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_offload_ip"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|csum_offload_ip
argument_list|,
literal|0
argument_list|,
literal|"Number of IP checksum offload frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_offload_tcp_udp"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|csum_offload_tcp_udp
argument_list|,
literal|0
argument_list|,
literal|"Number of TCP/UDP checksum offload frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vlan_tagged_frames_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|vlan_tagged_frames_rcvd
argument_list|,
literal|0
argument_list|,
literal|"Number of VLAN tagged frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vlan_tagged_frames_stripped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|vlan_tagged_frames_stripped
argument_list|,
literal|0
argument_list|,
literal|"Number of VLAN tagged frames stripped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupts_rx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|interrupts_rx
argument_list|,
literal|0
argument_list|,
literal|"Number of RX interrupts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupts_tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|interrupts_tx
argument_list|,
literal|0
argument_list|,
literal|"Number of TX interrupts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHcInOctets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInOctets
argument_list|,
literal|"Bytes received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCInBadOctets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInBadOctets
argument_list|,
literal|"Bad bytes received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutOctets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutOctets
argument_list|,
literal|"Bytes sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutBadOctets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutBadOctets
argument_list|,
literal|"Bad bytes sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCInUcastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInUcastPkts
argument_list|,
literal|"Unicast packets received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCInMulticastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInMulticastPkts
argument_list|,
literal|"Multicast packets received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCInBroadcastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInBroadcastPkts
argument_list|,
literal|"Broadcast packets received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutUcastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutUcastPkts
argument_list|,
literal|"Unicast packets sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutMulticastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutMulticastPkts
argument_list|,
literal|"Multicast packets sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutBroadcastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutBroadcastPkts
argument_list|,
literal|"Broadcast packets sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_emac_tx_stat_dot3statsinternalmactransmiterrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
argument_list|,
literal|0
argument_list|,
literal|"Internal MAC transmit errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsCarrierSenseErrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsCarrierSenseErrors
argument_list|,
literal|0
argument_list|,
literal|"Carrier sense errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsFCSErrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsFCSErrors
argument_list|,
literal|0
argument_list|,
literal|"Frame check sequence errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsAlignmentErrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsAlignmentErrors
argument_list|,
literal|0
argument_list|,
literal|"Alignment errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsSingleCollisionFrames"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsSingleCollisionFrames
argument_list|,
literal|0
argument_list|,
literal|"Single Collision Frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsMultipleCollisionFrames"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsMultipleCollisionFrames
argument_list|,
literal|0
argument_list|,
literal|"Multiple Collision Frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsDeferredTransmissions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsDeferredTransmissions
argument_list|,
literal|0
argument_list|,
literal|"Deferred Transmissions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsExcessiveCollisions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsExcessiveCollisions
argument_list|,
literal|0
argument_list|,
literal|"Excessive Collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsLateCollisions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsLateCollisions
argument_list|,
literal|0
argument_list|,
literal|"Late Collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsCollisions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsCollisions
argument_list|,
literal|0
argument_list|,
literal|"Collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsFragments"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsFragments
argument_list|,
literal|0
argument_list|,
literal|"Fragments"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsJabbers"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsJabbers
argument_list|,
literal|0
argument_list|,
literal|"Jabbers"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsUndersizePkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsUndersizePkts
argument_list|,
literal|0
argument_list|,
literal|"Undersize packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsOversizePkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsOversizePkts
argument_list|,
literal|0
argument_list|,
literal|"stat_EtherStatsOversizePkts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx64Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx64Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 64 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx65Octetsto127Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx65Octetsto127Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 65 to 127 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx128Octetsto255Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx128Octetsto255Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 128 to 255 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx256Octetsto511Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx256Octetsto511Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 256 to 511 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx512Octetsto1023Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx512Octetsto1023Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 512 to 1023 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx1024Octetsto1522Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 1024 t0 1522 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx1523Octetsto9022Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 1523 to 9022 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx64Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx64Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 64 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx65Octetsto127Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx65Octetsto127Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 65 to 127 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx128Octetsto255Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx128Octetsto255Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 128 to 255 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx256Octetsto511Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx256Octetsto511Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 256 to 511 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx512Octetsto1023Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx512Octetsto1023Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 512 to 1023 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx1024Octetsto1522Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 1024 to 1522 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx1523Octetsto9022Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 1523 to 9022 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_XonPauseFramesReceived"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_XonPauseFramesReceived
argument_list|,
literal|0
argument_list|,
literal|"XON pause frames receved"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_XoffPauseFramesReceived"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_XoffPauseFramesReceived
argument_list|,
literal|0
argument_list|,
literal|"XOFF pause frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_OutXonSent"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_OutXonSent
argument_list|,
literal|0
argument_list|,
literal|"XON pause frames sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_OutXoffSent"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_OutXoffSent
argument_list|,
literal|0
argument_list|,
literal|"XOFF pause frames sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_FlowControlDone"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_FlowControlDone
argument_list|,
literal|0
argument_list|,
literal|"Flow control done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_MacControlFramesReceived"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_MacControlFramesReceived
argument_list|,
literal|0
argument_list|,
literal|"MAC control frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_XoffStateEntered"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_XoffStateEntered
argument_list|,
literal|0
argument_list|,
literal|"XOFF state entered"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInFramesL2FilterDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInFramesL2FilterDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received L2 packets discarded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInRuleCheckerDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInRuleCheckerDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded by rule"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInFTQDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInFTQDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packet FTQ discards"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInMBUFDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInMBUFDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded due to lack "
literal|"of controller buffer memory"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInRuleCheckerP4Hit"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInRuleCheckerP4Hit
argument_list|,
literal|0
argument_list|,
literal|"Received packets rule checker hits"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_CatchupInRuleCheckerDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_CatchupInRuleCheckerDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded in Catchup path"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_CatchupInFTQDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_CatchupInFTQDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded in FTQ in Catchup path"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_CatchupInMBUFDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_CatchupInMBUFDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded in controller "
literal|"buffer memory in Catchup path"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_CatchupInRuleCheckerP4Hit"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_CatchupInRuleCheckerP4Hit
argument_list|,
literal|0
argument_list|,
literal|"Received packets rule checker hits in Catchup path"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"com_no_buffers"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|com_no_buffers
argument_list|,
literal|0
argument_list|,
literal|"Valid packets received but no RX buffers available"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_driver_state
argument_list|,
literal|"I"
argument_list|,
literal|"Drive state information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_hw_state
argument_list|,
literal|"I"
argument_list|,
literal|"Hardware state information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"status_block"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_status_block
argument_list|,
literal|"I"
argument_list|,
literal|"Dump status block"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats_block"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_stats_block
argument_list|,
literal|"I"
argument_list|,
literal|"Dump statistics block"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats_clear"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_stats_clear
argument_list|,
literal|"I"
argument_list|,
literal|"Clear statistics block"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bc_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_bc_state
argument_list|,
literal|"I"
argument_list|,
literal|"Bootcode state information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_rx_bd_chain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_dump_rx_bd_chain
argument_list|,
literal|"I"
argument_list|,
literal|"Dump RX BD chain"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_rx_mbuf_chain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_dump_rx_mbuf_chain
argument_list|,
literal|"I"
argument_list|,
literal|"Dump RX MBUF chain"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_tx_chain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_dump_tx_chain
argument_list|,
literal|"I"
argument_list|,
literal|"Dump tx_bd chain"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_pg_chain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_dump_pg_chain
argument_list|,
literal|"I"
argument_list|,
literal|"Dump page chain"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_ctx"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_dump_ctx
argument_list|,
literal|"I"
argument_list|,
literal|"Dump context memory"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"breakpoint"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_breakpoint
argument_list|,
literal|"I"
argument_list|,
literal|"Driver breakpoint"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"reg_read"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_reg_read
argument_list|,
literal|"I"
argument_list|,
literal|"Register read"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nvram_read"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_nvram_read
argument_list|,
literal|"I"
argument_list|,
literal|"NVRAM read"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phy_read"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_phy_read
argument_list|,
literal|"I"
argument_list|,
literal|"PHY register read"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBEXIT
argument_list|(
name|BCE_VERBOSE_MISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Debug Routines                                                       */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Freezes the controller to allow for a cohesive state dump.               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_freeze_controller
argument_list|(
argument|struct bce_softc *sc
argument_list|)
block|{
name|u32
name|val
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_COMMAND
argument_list|)
block|;
name|val
operator||=
name|BCE_MISC_COMMAND_DISABLE_ALL
block|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_COMMAND
argument_list|,
name|val
argument_list|)
block|; }
comment|/****************************************************************************/
comment|/* Unfreezes the controller after a freeze operation.  This may not always  */
comment|/* work and the controller will require a reset!                            */
comment|/*                                                                          */
comment|/* Returns:                                                                 */
comment|/*   Nothing.                                                               */
comment|/****************************************************************************/
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_unfreeze_controller
argument_list|(
argument|struct bce_softc *sc
argument_list|)
block|{
name|u32
name|val
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_COMMAND
argument_list|)
block|;
name|val
operator||=
name|BCE_MISC_COMMAND_ENABLE_ALL
block|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_COMMAND
argument_list|,
name|val
argument_list|)
block|; }
comment|/****************************************************************************/
comment|/* Prints out Ethernet frame information from an mbuf.                      */
comment|/*                                                                          */
comment|/* Partially decode an Ethernet frame to look at some important headers.    */
comment|/*                                                                          */
comment|/* Returns:                                                                 */
comment|/*   Nothing.                                                               */
comment|/****************************************************************************/
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_enet
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|struct mbuf *m
argument_list|)
block|{ 	struct
name|ether_vlan_header
operator|*
name|eh
block|;
name|u16
name|etype
block|;
name|int
name|ehlen
block|; 	struct
name|ip
operator|*
name|ip
block|; 	struct
name|tcphdr
operator|*
name|th
block|; 	struct
name|udphdr
operator|*
name|uh
block|; 	struct
name|arphdr
operator|*
name|ah
block|;
name|BCE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|" Frame Decode "
literal|"-----------------------------\n"
argument_list|)
block|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
block|;
comment|/* Handle VLAN encapsulation if present. */
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|ehlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|ehlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
end_else

begin_comment
comment|/* ToDo: Add VLAN output. */
end_comment

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"enet: dest = %6D, src = %6D, type = 0x%04X, hlen = %d\n"
argument_list|,
name|eh
operator|->
name|evl_dhost
argument_list|,
literal|":"
argument_list|,
name|eh
operator|->
name|evl_shost
argument_list|,
literal|":"
argument_list|,
name|etype
argument_list|,
name|ehlen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ehlen
operator|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"--ip: dest = 0x%08X , src = 0x%08X, "
literal|"len = %d bytes, protocol = 0x%02X, xsum = 0x%04X\n"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_p
argument_list|,
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_sum
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"-tcp: dest = %d, src = %d, hlen = "
literal|"%d bytes, flags = 0x%b, csum = 0x%04X\n"
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_dport
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_sport
argument_list|)
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
argument_list|,
name|th
operator|->
name|th_flags
argument_list|,
literal|"\20\10CWR\07ECE\06URG\05ACK\04PSH\03RST"
literal|"\02SYN\01FIN"
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_sum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"-udp: dest = %d, src = %d, len = %d "
literal|"bytes, csum = 0x%04X\n"
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_dport
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_sport
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_ulen
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_sum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|BCE_PRINTF
argument_list|(
literal|"icmp:\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BCE_PRINTF
argument_list|(
literal|"----: Other IP protocol.\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|BCE_PRINTF
argument_list|(
literal|"ipv6: No decode supported.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_ARP
case|:
name|BCE_PRINTF
argument_list|(
literal|"-arp: "
argument_list|)
expr_stmt|;
name|ah
operator|=
operator|(
expr|struct
name|arphdr
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ehlen
operator|)
expr_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|ah
operator|->
name|ar_op
argument_list|)
condition|)
block|{
case|case
name|ARPOP_REVREQUEST
case|:
name|printf
argument_list|(
literal|"reverse ARP request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARPOP_REVREPLY
case|:
name|printf
argument_list|(
literal|"reverse ARP reply\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARPOP_REQUEST
case|:
name|printf
argument_list|(
literal|"ARP request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARPOP_REPLY
case|:
name|printf
argument_list|(
literal|"ARP reply\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"other ARP operation\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|BCE_PRINTF
argument_list|(
literal|"----: Other protocol.\n"
argument_list|)
expr_stmt|;
block|}
end_switch

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|"--------------"
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out information about an mbuf.                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_mbuf
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
init|=
name|m
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"mbuf: null pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|mp
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"mbuf: %p, m_len = %d, m_flags = 0x%b, "
literal|"m_data = %p\n"
argument_list|,
name|mp
argument_list|,
name|mp
operator|->
name|m_len
argument_list|,
name|mp
operator|->
name|m_flags
argument_list|,
literal|"\20\1M_EXT\2M_PKTHDR\3M_EOR\4M_RDONLY"
argument_list|,
name|mp
operator|->
name|m_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"- m_pkthdr: len = %d, flags = 0x%b, "
literal|"csum_flags = %b\n"
argument_list|,
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mp
operator|->
name|m_flags
argument_list|,
literal|"\20\12M_BCAST\13M_MCAST\14M_FRAG"
literal|"\15M_FIRSTFRAG\16M_LASTFRAG\21M_VLANTAG"
literal|"\22M_PROMISC\23M_NOFREE"
argument_list|,
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
literal|"\20\1CSUM_IP\2CSUM_TCP\3CSUM_UDP\4CSUM_IP_FRAGS"
literal|"\5CSUM_FRAGMENT\6CSUM_TSO\11CSUM_IP_CHECKED"
literal|"\12CSUM_IP_VALID\13CSUM_DATA_VALID"
literal|"\14CSUM_PSEUDO_HDR"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"- m_ext: %p, ext_size = %d, type = "
argument_list|,
name|mp
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|mp
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|m_ext
operator|.
name|ext_type
condition|)
block|{
case|case
name|EXT_CLUSTER
case|:
name|printf
argument_list|(
literal|"EXT_CLUSTER\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_SFBUF
case|:
name|printf
argument_list|(
literal|"EXT_SFBUF\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_JUMBO9
case|:
name|printf
argument_list|(
literal|"EXT_JUMBO9\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_JUMBO16
case|:
name|printf
argument_list|(
literal|"EXT_JUMBO16\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_PACKET
case|:
name|printf
argument_list|(
literal|"EXT_PACKET\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_MBUF
case|:
name|printf
argument_list|(
literal|"EXT_MBUF\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_NET_DRV
case|:
name|printf
argument_list|(
literal|"EXT_NET_DRV\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_MOD_TYPE
case|:
name|printf
argument_list|(
literal|"EXT_MDD_TYPE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_DISPOSABLE
case|:
name|printf
argument_list|(
literal|"EXT_DISPOSABLE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_EXTREF
case|:
name|printf
argument_list|(
literal|"EXT_EXTREF\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"UNKNOWN\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the mbufs in the TX mbuf chain.                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_tx_mbuf_chain
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|u16 chain_prod
argument_list|,
argument|int count
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|m
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  tx mbuf data  "
literal|"----------------------------\n"
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|chain_prod
index|]
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"txmbuf[0x%04X]\n"
argument_list|,
name|chain_prod
argument_list|)
expr_stmt|;
name|bce_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|chain_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|NEXT_TX_BD
argument_list|(
name|chain_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the mbufs in the RX mbuf chain.                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_rx_mbuf_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|chain_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  rx mbuf data  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|chain_prod
index|]
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"rxmbuf[0x%04X]\n"
argument_list|,
name|chain_prod
argument_list|)
expr_stmt|;
name|bce_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|chain_prod
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|NEXT_RX_BD
argument_list|(
name|chain_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the mbufs in the mbuf page chain.                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_pg_mbuf_chain
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|u16 chain_prod
argument_list|,
argument|int count
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|m
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  pg mbuf data  "
literal|"----------------------------\n"
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|pg_mbuf_ptr
index|[
name|chain_prod
index|]
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"pgmbuf[0x%04X]\n"
argument_list|,
name|chain_prod
argument_list|)
expr_stmt|;
name|bce_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|chain_prod
operator|=
name|PG_CHAIN_IDX
argument_list|(
name|NEXT_PG_BD
argument_list|(
name|chain_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out a tx_bd structure.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_txbd
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|tx_bd
modifier|*
name|txbd
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|MAX_TX_BD
condition|)
comment|/* Index out of range. */
name|BCE_PRINTF
argument_list|(
literal|"tx_bd[0x%04X]: Invalid tx_bd index!\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|idx
operator|&
name|USABLE_TX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_TX_BD_PER_PAGE
condition|)
comment|/* TX Chain page pointer. */
name|BCE_PRINTF
argument_list|(
literal|"tx_bd[0x%04X]: haddr = 0x%08X:%08X, chain page "
literal|"pointer\n"
argument_list|,
name|idx
argument_list|,
name|txbd
operator|->
name|tx_bd_haddr_hi
argument_list|,
name|txbd
operator|->
name|tx_bd_haddr_lo
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Normal tx_bd entry. */
name|BCE_PRINTF
argument_list|(
literal|"tx_bd[0x%04X]: haddr = 0x%08X:%08X, "
literal|"mss_nbytes = 0x%08X, vlan tag = 0x%04X, flags = "
literal|"0x%04X ("
argument_list|,
name|idx
argument_list|,
name|txbd
operator|->
name|tx_bd_haddr_hi
argument_list|,
name|txbd
operator|->
name|tx_bd_haddr_lo
argument_list|,
name|txbd
operator|->
name|tx_bd_mss_nbytes
argument_list|,
name|txbd
operator|->
name|tx_bd_vlan_tag
argument_list|,
name|txbd
operator|->
name|tx_bd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_CONN_FAULT
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CONN_FAULT"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_TCP_UDP_CKSUM
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TCP_UDP_CKSUM"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_IP_CKSUM
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IP_CKSUM"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_VLAN_TAG
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"VLAN"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_COAL_NOW
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"COAL_NOW"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_DONT_GEN_CRC
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DONT_GEN_CRC"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_START
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"START"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_END
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"END"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_SW_LSO
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LSO"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_SW_OPTION_WORD
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SW_OPTION=%d"
argument_list|,
operator|(
operator|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_SW_OPTION_WORD
operator|)
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_SW_FLAGS
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SW_FLAGS"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|txbd
operator|->
name|tx_bd_flags
operator|&
name|TX_BD_FLAGS_SW_SNAP
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SNAP)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out a rx_bd structure.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_rxbd
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|int idx
argument_list|,
argument|struct rx_bd *rxbd
argument_list|)
block|{
if|if
condition|(
name|idx
operator|>
name|MAX_RX_BD
condition|)
comment|/* Index out of range. */
name|BCE_PRINTF
argument_list|(
literal|"rx_bd[0x%04X]: Invalid rx_bd index!\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|idx
operator|&
name|USABLE_RX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_RX_BD_PER_PAGE
condition|)
comment|/* RX Chain page pointer. */
name|BCE_PRINTF
argument_list|(
literal|"rx_bd[0x%04X]: haddr = 0x%08X:%08X, chain page "
literal|"pointer\n"
argument_list|,
name|idx
argument_list|,
name|rxbd
operator|->
name|rx_bd_haddr_hi
argument_list|,
name|rxbd
operator|->
name|rx_bd_haddr_lo
argument_list|)
expr_stmt|;
else|else
comment|/* Normal rx_bd entry. */
name|BCE_PRINTF
argument_list|(
literal|"rx_bd[0x%04X]: haddr = 0x%08X:%08X, nbytes = "
literal|"0x%08X, flags = 0x%08X\n"
argument_list|,
name|idx
argument_list|,
name|rxbd
operator|->
name|rx_bd_haddr_hi
argument_list|,
name|rxbd
operator|->
name|rx_bd_haddr_lo
argument_list|,
name|rxbd
operator|->
name|rx_bd_len
argument_list|,
name|rxbd
operator|->
name|rx_bd_flags
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out a rx_bd structure in the page chain.                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_pgbd
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|int idx
argument_list|,
argument|struct rx_bd *pgbd
argument_list|)
block|{
if|if
condition|(
name|idx
operator|>
name|MAX_PG_BD
condition|)
comment|/* Index out of range. */
name|BCE_PRINTF
argument_list|(
literal|"pg_bd[0x%04X]: Invalid pg_bd index!\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|idx
operator|&
name|USABLE_PG_BD_PER_PAGE
operator|)
operator|==
name|USABLE_PG_BD_PER_PAGE
condition|)
comment|/* Page Chain page pointer. */
name|BCE_PRINTF
argument_list|(
literal|"px_bd[0x%04X]: haddr = 0x%08X:%08X, chain page pointer\n"
argument_list|,
name|idx
argument_list|,
name|pgbd
operator|->
name|rx_bd_haddr_hi
argument_list|,
name|pgbd
operator|->
name|rx_bd_haddr_lo
argument_list|)
expr_stmt|;
else|else
comment|/* Normal rx_bd entry. */
name|BCE_PRINTF
argument_list|(
literal|"pg_bd[0x%04X]: haddr = 0x%08X:%08X, nbytes = 0x%08X, "
literal|"flags = 0x%08X\n"
argument_list|,
name|idx
argument_list|,
name|pgbd
operator|->
name|rx_bd_haddr_hi
argument_list|,
name|pgbd
operator|->
name|rx_bd_haddr_lo
argument_list|,
name|pgbd
operator|->
name|rx_bd_len
argument_list|,
name|pgbd
operator|->
name|rx_bd_flags
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out a l2_fhdr structure.                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_l2fhdr
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|int idx
argument_list|,
argument|struct l2_fhdr *l2fhdr
argument_list|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"l2_fhdr[0x%04X]: status = 0x%b, "
literal|"pkt_len = %d, vlan = 0x%04x, ip_xsum/hdr_len = 0x%04X, "
literal|"tcp_udp_xsum = 0x%04X\n"
argument_list|,
name|idx
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_status
argument_list|,
name|BCE_L2FHDR_PRINTFB
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_pkt_len
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_vlan_tag
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_ip_xsum
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_tcp_udp_xsum
argument_list|)
block|; }
comment|/****************************************************************************/
comment|/* Prints out context memory info.  (Only useful for CID 0 to 16.)          */
comment|/*                                                                          */
comment|/* Returns:                                                                 */
comment|/*   Nothing.                                                               */
comment|/****************************************************************************/
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_ctx
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|u16 cid
argument_list|)
block|{
if|if
condition|(
name|cid
operator|>
name|TX_CID
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|" Unknown CID\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"    CTX Data    "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"     0x%04X - (CID) Context ID\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|cid
operator|==
name|RX_CID
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_HOST_BDIDX) host rx "
literal|"producer index\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_HOST_BDIDX
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_HOST_BSEQ) host "
literal|"byte sequence\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_HOST_BSEQ
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_NX_BSEQ) h/w byte sequence\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_BSEQ
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_NX_BDHADDR_HI) h/w buffer "
literal|"descriptor address\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_BDHADDR_HI
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_NX_BDHADDR_LO) h/w buffer "
literal|"descriptor address\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_BDHADDR_LO
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_NX_BDIDX) h/w rx consumer "
literal|"index\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_BDIDX
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_HOST_PG_BDIDX) host page "
literal|"producer index\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_HOST_PG_BDIDX
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_PG_BUF_SIZE) host rx_bd/page "
literal|"buffer size\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_PG_BUF_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_NX_PG_BDHADDR_HI) h/w page "
literal|"chain address\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_PG_BDHADDR_HI
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_NX_PG_BDHADDR_LO) h/w page "
literal|"chain address\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_PG_BDHADDR_LO
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_RX_NX_PG_BDIDX) h/w page "
literal|"consumer index\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_RX_NX_PG_BDIDX
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cid
operator|==
name|TX_CID
condition|)
block|{
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_TYPE_XI) ctx type\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TYPE_XI
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_CMD_TX_TYPE_XI) ctx "
literal|"cmd\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_CMD_TYPE_XI
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_TBDR_BDHADDR_HI_XI) "
literal|"h/w buffer descriptor address\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TBDR_BHADDR_HI_XI
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_TBDR_BHADDR_LO_XI) "
literal|"h/w buffer	descriptor address\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TBDR_BHADDR_LO_XI
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_HOST_BIDX_XI) "
literal|"host producer index\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_HOST_BIDX_XI
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_HOST_BSEQ_XI) "
literal|"host byte sequence\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_HOST_BSEQ_XI
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_TYPE) ctx type\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_CMD_TYPE) ctx cmd\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_CMD_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_TBDR_BDHADDR_HI) "
literal|"h/w buffer	descriptor address\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TBDR_BHADDR_HI
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_TBDR_BHADDR_LO) "
literal|"h/w buffer	descriptor address\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_TBDR_BHADDR_LO
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_HOST_BIDX) host "
literal|"producer index\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_HOST_BIDX
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" 0x%08X - (L2CTX_TX_HOST_BSEQ) host byte "
literal|"sequence\n"
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|BCE_L2CTX_TX_HOST_BSEQ
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"    Raw CTX     "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|int
name|i
init|=
literal|0x0
init|;
name|i
operator|<
literal|0x300
condition|;
name|i
operator|+=
literal|0x10
control|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|CTX_RD
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|cid
argument_list|)
argument_list|,
name|i
operator|+
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the FTQ data.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_ftqs
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|cmd
decl_stmt|,
name|ctl
decl_stmt|,
name|cur_depth
decl_stmt|,
name|max_depth
decl_stmt|,
name|valid_cnt
decl_stmt|,
name|val
decl_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"    FTQ Data    "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"   FTQ    Command    Control   Depth_Now  "
literal|"Max_Depth  Valid_Cnt \n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" ------- ---------- ---------- ---------- "
literal|"---------- ----------\n"
argument_list|)
expr_stmt|;
comment|/* Setup the generic statistic counters for the FTQ valid count. */
name|val
operator|=
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PPQ_VALID_CNT
operator|<<
literal|24
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXPCQ_VALID_CNT
operator|<<
literal|16
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXPQ_VALID_CNT
operator|<<
literal|8
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_RLUPQ_VALID_CNT
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_SEL_0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_TSCHQ_VALID_CNT
operator|<<
literal|24
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_RDMAQ_VALID_CNT
operator|<<
literal|16
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PTQ_VALID_CNT
operator|<<
literal|8
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PMQ_VALID_CNT
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_SEL_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_TPATQ_VALID_CNT
operator|<<
literal|24
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_TDMAQ_VALID_CNT
operator|<<
literal|16
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXPQ_VALID_CNT
operator|<<
literal|8
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_TBDRQ_VALID_CNT
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_SEL_2
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_COMQ_VALID_CNT
operator|<<
literal|24
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_COMTQ_VALID_CNT
operator|<<
literal|16
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_COMXQ_VALID_CNT
operator|<<
literal|8
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_TASQ_VALID_CNT
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_SEL_3
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Input queue to the Receive Lookup state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RLUP_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RLUP_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RLUP_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RLUP_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT0
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" RLUP    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Receive Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RXP_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RXP_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT1
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" RXP     0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Recevie Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_CFTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_CFTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RXP_CFTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RXP_CFTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT2
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" RXPC    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Receive Virtual to Physical state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_PFTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_PFTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RV2P_PFTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RV2P_PFTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT3
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" RV2PP   0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Recevie Virtual to Physical state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_MFTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_MFTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RV2P_MFTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RV2P_MFTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT4
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" RV2PM   0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Receive Virtual to Physical state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_TFTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_TFTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RV2P_TFTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RV2P_TFTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT5
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" RV2PT   0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Receive DMA state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RDMA_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RDMA_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RDMA_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_RDMA_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT6
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" RDMA    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Transmit Scheduler state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TSCH_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TSCH_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TSCH_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TSCH_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT7
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" TSCH    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Transmit Buffer Descriptor state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TBDR_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TBDR_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TBDR_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TBDR_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT8
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" TBDR    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Transmit Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TXP_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TXP_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TXP_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TXP_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT9
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" TXP     0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Transmit DMA state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TDMA_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TDMA_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TDMA_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TDMA_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT10
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" TDMA    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Transmit Patch-Up Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TPAT_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TPAT_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TPAT_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TPAT_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT11
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" TPAT    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Transmit Assembler state machine */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TAS_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TAS_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TAS_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_TAS_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT12
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" TAS     0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Completion Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_COMXQ_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_COMXQ_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_COM_COMXQ_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_COM_COMXQ_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT13
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" COMX    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Completion Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_COMTQ_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_COMTQ_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_COM_COMTQ_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_COM_COMTQ_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT14
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" COMT    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Completion Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_COMQ_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_COMQ_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_COM_COMQ_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_COM_COMQ_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT15
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" COMX    0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Setup the generic statistic counters for the FTQ valid count. */
name|val
operator|=
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_CSQ_VALID_CNT
operator|<<
literal|16
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_CPQ_VALID_CNT
operator|<<
literal|8
operator|)
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_MGMQ_VALID_CNT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
name|val
operator|=
name|val
operator||
operator|(
name|BCE_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PCSQ_VALID_CNT_XI
operator|<<
literal|24
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_SEL_0
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Input queue to the Management Control Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_MCP_MCPQ_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_MCP_MCPQ_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_MCP_MCPQ_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_MCP_MCPQ_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT0
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" MCP     0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Command Processor */
name|cmd
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_CP_CPQ_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_CP_CPQ_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_CP_CPQ_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_CP_CPQ_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT1
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" CP      0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
comment|/* Input queue to the Completion Scheduler state machine */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CSCH_CH_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CSCH_CH_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_CSCH_CH_FTQ_CTL_CUR_DEPTH
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
name|BCE_CSCH_CH_FTQ_CTL_MAX_DEPTH
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT2
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" CS      0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5709
operator|)
operator|||
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5716
operator|)
condition|)
block|{
comment|/* Input queue to the RV2P Command Scheduler */
name|cmd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2PCSR_FTQ_CMD
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2PCSR_FTQ_CTL
argument_list|)
expr_stmt|;
name|cur_depth
operator|=
operator|(
name|ctl
operator|&
literal|0xFFC00000
operator|)
operator|>>
literal|22
expr_stmt|;
name|max_depth
operator|=
operator|(
name|ctl
operator|&
literal|0x003FF000
operator|)
operator|>>
literal|12
expr_stmt|;
name|valid_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_GEN_STAT3
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|" RV2PCSR 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|cmd
argument_list|,
name|ctl
argument_list|,
name|cur_depth
argument_list|,
name|max_depth
argument_list|,
name|valid_cnt
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the TX chain.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_tx_chain
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|u16 tx_prod
argument_list|,
argument|int count
argument_list|)
block|{ 	struct
name|tx_bd
operator|*
name|txbd
block|;
comment|/* First some info about the tx_bd chain structure. */
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  tx_bd  chain  "
literal|"----------------------------\n"
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"page size      = 0x%08X, tx chain pages        = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|BCM_PAGE_SIZE
argument_list|,
operator|(
name|u32
operator|)
name|TX_PAGES
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"tx_bd per page = 0x%08X, usable tx_bd per page = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_TX_BD_PER_PAGE
argument_list|,
operator|(
name|u32
operator|)
name|USABLE_TX_BD_PER_PAGE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"total tx_bd    = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_TX_BD
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   tx_bd data   "
literal|"----------------------------\n"
argument_list|)
block|;
comment|/* Now print out a decoded list of TX buffer descriptors. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|txbd
operator|=
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|TX_PAGE
argument_list|(
name|tx_prod
argument_list|)
index|]
index|[
name|TX_IDX
argument_list|(
name|tx_prod
argument_list|)
index|]
expr_stmt|;
name|bce_dump_txbd
argument_list|(
name|sc
argument_list|,
name|tx_prod
argument_list|,
name|txbd
argument_list|)
expr_stmt|;
name|tx_prod
operator|++
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the RX chain.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_rx_bd_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|rx_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|rx_bd
modifier|*
name|rxbd
decl_stmt|;
comment|/* First some info about the rx_bd chain structure. */
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  rx_bd  chain  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"page size      = 0x%08X, rx chain pages        = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|BCM_PAGE_SIZE
argument_list|,
operator|(
name|u32
operator|)
name|RX_PAGES
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"rx_bd per page = 0x%08X, usable rx_bd per page = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_RX_BD_PER_PAGE
argument_list|,
operator|(
name|u32
operator|)
name|USABLE_RX_BD_PER_PAGE
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"total rx_bd    = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_RX_BD
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   rx_bd data   "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Now print out the rx_bd's themselves. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rxbd
operator|=
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|RX_PAGE
argument_list|(
name|rx_prod
argument_list|)
index|]
index|[
name|RX_IDX
argument_list|(
name|rx_prod
argument_list|)
index|]
expr_stmt|;
name|bce_dump_rxbd
argument_list|(
name|sc
argument_list|,
name|rx_prod
argument_list|,
name|rxbd
argument_list|)
expr_stmt|;
name|rx_prod
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|rx_prod
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the page chain.                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_pg_chain
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|u16 pg_prod
argument_list|,
argument|int count
argument_list|)
block|{ 	struct
name|rx_bd
operator|*
name|pgbd
block|;
comment|/* First some info about the page chain structure. */
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   page chain   "
literal|"----------------------------\n"
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"page size      = 0x%08X, pg chain pages        = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|BCM_PAGE_SIZE
argument_list|,
operator|(
name|u32
operator|)
name|PG_PAGES
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"rx_bd per page = 0x%08X, usable rx_bd per page = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_PG_BD_PER_PAGE
argument_list|,
operator|(
name|u32
operator|)
name|USABLE_PG_BD_PER_PAGE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"total rx_bd    = 0x%08X, max_pg_bd             = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_PG_BD
argument_list|,
operator|(
name|u32
operator|)
name|MAX_PG_BD
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   page data    "
literal|"----------------------------\n"
argument_list|)
block|;
comment|/* Now print out the rx_bd's themselves. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pgbd
operator|=
operator|&
name|sc
operator|->
name|pg_bd_chain
index|[
name|PG_PAGE
argument_list|(
name|pg_prod
argument_list|)
index|]
index|[
name|PG_IDX
argument_list|(
name|pg_prod
argument_list|)
index|]
expr_stmt|;
name|bce_dump_pgbd
argument_list|(
name|sc
argument_list|,
name|pg_prod
argument_list|,
name|pgbd
argument_list|)
expr_stmt|;
name|pg_prod
operator|=
name|PG_CHAIN_IDX
argument_list|(
name|pg_prod
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BCE_PRINT_RX_CONS
parameter_list|(
name|arg
parameter_list|)
define|\
value|if (sblk->status_rx_quick_consumer_index##arg)				\ 	BCE_PRINTF("0x%04X(0x%04X) - rx_quick_consumer_index%d\n",	\ 	    sblk->status_rx_quick_consumer_index##arg, (u16)		\ 	    RX_CHAIN_IDX(sblk->status_rx_quick_consumer_index##arg),	\ 	    arg);
end_define

begin_define
define|#
directive|define
name|BCE_PRINT_TX_CONS
parameter_list|(
name|arg
parameter_list|)
define|\
value|if (sblk->status_tx_quick_consumer_index##arg)				\ 	BCE_PRINTF("0x%04X(0x%04X) - tx_quick_consumer_index%d\n",	\ 	    sblk->status_tx_quick_consumer_index##arg, (u16)		\ 	    TX_CHAIN_IDX(sblk->status_tx_quick_consumer_index##arg),	\ 	    arg);
end_define

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the status block from host memory.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_status_block
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|status_block
modifier|*
name|sblk
decl_stmt|;
name|sblk
operator|=
name|sc
operator|->
name|status_block
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  Status Block  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Theses indices are used for normal L2 drivers. */
name|BCE_PRINTF
argument_list|(
literal|"    0x%08X - attn_bits\n"
argument_list|,
name|sblk
operator|->
name|status_attn_bits
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"    0x%08X - attn_bits_ack\n"
argument_list|,
name|sblk
operator|->
name|status_attn_bits_ack
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|BCE_PRINT_TX_CONS
argument_list|(
literal|0
argument_list|)
name|BCE_PRINTF
argument_list|(
literal|"        0x%04X - status_idx\n"
argument_list|,
name|sblk
operator|->
name|status_idx
argument_list|)
expr_stmt|;
comment|/* Theses indices are not used for normal L2 drivers. */
name|BCE_PRINT_RX_CONS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|BCE_PRINT_RX_CONS
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|BCE_PRINT_TX_CONS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|BCE_PRINT_TX_CONS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BCE_PRINT_TX_CONS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_completion_producer_index
operator|||
name|sblk
operator|->
name|status_cmd_consumer_index
condition|)
name|BCE_PRINTF
argument_list|(
literal|"com_prod  = 0x%08X, cmd_cons      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_completion_producer_index
argument_list|,
name|sblk
operator|->
name|status_cmd_consumer_index
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BCE_PRINT_64BIT_STAT
parameter_list|(
name|arg
parameter_list|)
define|\
value|if (sblk->arg##_lo || sblk->arg##_hi)				\ 	BCE_PRINTF("0x%08X:%08X : %s\n", sblk->arg##_hi,	\ 	    sblk->arg##_lo, #arg);
end_define

begin_define
define|#
directive|define
name|BCE_PRINT_32BIT_STAT
parameter_list|(
name|arg
parameter_list|)
define|\
value|if (sblk->arg)							\ 	BCE_PRINTF("         0x%08X : %s\n", 			\ 	    sblk->arg, #arg);
end_define

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the statistics block from host memory.                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_stats_block
argument_list|(
argument|struct bce_softc *sc
argument_list|)
block|{ 	struct
name|statistics_block
operator|*
name|sblk
block|;
name|sblk
operator|=
name|sc
operator|->
name|stats_block
block|;
name|BCE_PRINTF
argument_list|(
literal|"---------------"
literal|" Stats Block  (All Stats Not Shown Are 0) "
literal|"---------------\n"
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCInOctets
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCInBadOctets
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCOutOctets
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCOutBadOctets
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCInUcastPkts
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCInBroadcastPkts
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCInMulticastPkts
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCOutUcastPkts
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCOutBroadcastPkts
argument_list|)
block|;
name|BCE_PRINT_64BIT_STAT
argument_list|(
name|stat_IfHCOutMulticastPkts
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_Dot3StatsCarrierSenseErrors
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_Dot3StatsFCSErrors
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_Dot3StatsAlignmentErrors
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_Dot3StatsSingleCollisionFrames
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_Dot3StatsMultipleCollisionFrames
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_Dot3StatsDeferredTransmissions
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_Dot3StatsExcessiveCollisions
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_Dot3StatsLateCollisions
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsCollisions
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsFragments
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsJabbers
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsUndersizePkts
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsOversizePkts
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsRx64Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsRx65Octetsto127Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsRx128Octetsto255Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsRx256Octetsto511Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsRx512Octetsto1023Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsTx64Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsTx65Octetsto127Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsTx128Octetsto255Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsTx256Octetsto511Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsTx512Octetsto1023Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_XonPauseFramesReceived
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_XoffPauseFramesReceived
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_OutXonSent
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_OutXoffSent
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_FlowControlDone
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_MacControlFramesReceived
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_XoffStateEntered
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_IfInFramesL2FilterDiscards
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_IfInRuleCheckerDiscards
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_IfInFTQDiscards
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_IfInMBUFDiscards
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_IfInRuleCheckerP4Hit
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_CatchupInRuleCheckerDiscards
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_CatchupInFTQDiscards
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_CatchupInMBUFDiscards
argument_list|)
block|;
name|BCE_PRINT_32BIT_STAT
argument_list|(
name|stat_CatchupInRuleCheckerP4Hit
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
block|; }
comment|/****************************************************************************/
comment|/* Prints out a summary of the driver state.                                */
comment|/*                                                                          */
comment|/* Returns:                                                                 */
comment|/*   Nothing.                                                               */
comment|/****************************************************************************/
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_driver_state
argument_list|(
argument|struct bce_softc *sc
argument_list|)
block|{
name|u32
name|val_hi
block|,
name|val_lo
block|;
name|BCE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|" Driver State "
literal|"-----------------------------\n"
argument_list|)
block|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc) driver softc structure virtual "
literal|"address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|bce_vhandle
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|bce_vhandle
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->bce_vhandle) PCI BAR virtual "
literal|"address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|status_block
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|status_block
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->status_block) status block "
literal|"virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|stats_block
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|stats_block
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->stats_block) statistics block "
literal|"virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_bd_chain
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_bd_chain
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->tx_bd_chain) tx_bd chain "
literal|"virtual adddress\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|rx_bd_chain
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|rx_bd_chain
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->rx_bd_chain) rx_bd chain "
literal|"virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|pg_bd_chain
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|pg_bd_chain
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->pg_bd_chain) page chain "
literal|"virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
endif|#
directive|endif
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_mbuf_ptr
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_mbuf_ptr
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->tx_mbuf_ptr) tx mbuf chain "
literal|"virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|rx_mbuf_ptr
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|rx_mbuf_ptr
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->rx_mbuf_ptr) rx mbuf chain "
literal|"virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|pg_mbuf_ptr
argument_list|)
block|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|pg_mbuf_ptr
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->pg_mbuf_ptr) page mbuf chain "
literal|"virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
block|;
endif|#
directive|endif
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->interrupts_generated) "
literal|"h/w intrs\n"
argument_list|,
name|sc
operator|->
name|interrupts_generated
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->interrupts_rx) "
literal|"rx interrupts handled\n"
argument_list|,
name|sc
operator|->
name|interrupts_rx
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->interrupts_tx) "
literal|"tx interrupts handled\n"
argument_list|,
name|sc
operator|->
name|interrupts_tx
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->phy_interrupts) "
literal|"phy interrupts handled\n"
argument_list|,
name|sc
operator|->
name|phy_interrupts
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->last_status_idx) "
literal|"status block index\n"
argument_list|,
name|sc
operator|->
name|last_status_idx
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"     0x%04X(0x%04X) - (sc->tx_prod) tx producer "
literal|"index\n"
argument_list|,
name|sc
operator|->
name|tx_prod
argument_list|,
operator|(
name|u16
operator|)
name|TX_CHAIN_IDX
argument_list|(
name|sc
operator|->
name|tx_prod
argument_list|)
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"     0x%04X(0x%04X) - (sc->tx_cons) tx consumer "
literal|"index\n"
argument_list|,
name|sc
operator|->
name|tx_cons
argument_list|,
operator|(
name|u16
operator|)
name|TX_CHAIN_IDX
argument_list|(
name|sc
operator|->
name|tx_cons
argument_list|)
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->tx_prod_bseq) tx producer "
literal|"byte seq index\n"
argument_list|,
name|sc
operator|->
name|tx_prod_bseq
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->debug_tx_mbuf_alloc) tx "
literal|"mbufs allocated\n"
argument_list|,
name|sc
operator|->
name|debug_tx_mbuf_alloc
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->used_tx_bd) used "
literal|"tx_bd's\n"
argument_list|,
name|sc
operator|->
name|used_tx_bd
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X/%08X - (sc->tx_hi_watermark) tx hi "
literal|"watermark\n"
argument_list|,
name|sc
operator|->
name|tx_hi_watermark
argument_list|,
name|sc
operator|->
name|max_tx_bd
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"     0x%04X(0x%04X) - (sc->rx_prod) rx producer "
literal|"index\n"
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|,
operator|(
name|u16
operator|)
name|RX_CHAIN_IDX
argument_list|(
name|sc
operator|->
name|rx_prod
argument_list|)
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"     0x%04X(0x%04X) - (sc->rx_cons) rx consumer "
literal|"index\n"
argument_list|,
name|sc
operator|->
name|rx_cons
argument_list|,
operator|(
name|u16
operator|)
name|RX_CHAIN_IDX
argument_list|(
name|sc
operator|->
name|rx_cons
argument_list|)
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->rx_prod_bseq) rx producer "
literal|"byte seq index\n"
argument_list|,
name|sc
operator|->
name|rx_prod_bseq
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->debug_rx_mbuf_alloc) rx "
literal|"mbufs allocated\n"
argument_list|,
name|sc
operator|->
name|debug_rx_mbuf_alloc
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->free_rx_bd) free "
literal|"rx_bd's\n"
argument_list|,
name|sc
operator|->
name|free_rx_bd
argument_list|)
block|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|BCE_PRINTF
argument_list|(
literal|"     0x%04X(0x%04X) - (sc->pg_prod) page producer "
literal|"index\n"
argument_list|,
name|sc
operator|->
name|pg_prod
argument_list|,
operator|(
name|u16
operator|)
name|PG_CHAIN_IDX
argument_list|(
name|sc
operator|->
name|pg_prod
argument_list|)
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"     0x%04X(0x%04X) - (sc->pg_cons) page consumer "
literal|"index\n"
argument_list|,
name|sc
operator|->
name|pg_cons
argument_list|,
operator|(
name|u16
operator|)
name|PG_CHAIN_IDX
argument_list|(
name|sc
operator|->
name|pg_cons
argument_list|)
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->debug_pg_mbuf_alloc) page "
literal|"mbufs allocated\n"
argument_list|,
name|sc
operator|->
name|debug_pg_mbuf_alloc
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->free_pg_bd) free page "
literal|"rx_bd's\n"
argument_list|,
name|sc
operator|->
name|free_pg_bd
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X/%08X - (sc->pg_low_watermark) page low "
literal|"watermark\n"
argument_list|,
name|sc
operator|->
name|pg_low_watermark
argument_list|,
name|sc
operator|->
name|max_pg_bd
argument_list|)
block|;
endif|#
directive|endif
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->mbuf_alloc_failed_count) "
literal|"mbuf alloc failures\n"
argument_list|,
name|sc
operator|->
name|mbuf_alloc_failed_count
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->bce_flags) "
literal|"bce mac flags\n"
argument_list|,
name|sc
operator|->
name|bce_flags
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->bce_phy_flags) "
literal|"bce phy flags\n"
argument_list|,
name|sc
operator|->
name|bce_phy_flags
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
block|; }
comment|/****************************************************************************/
comment|/* Prints out the hardware state through a summary of important register,   */
comment|/* followed by a complete register dump.                                    */
comment|/*                                                                          */
comment|/* Returns:                                                                 */
comment|/*   Nothing.                                                               */
comment|/****************************************************************************/
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_hw_state
argument_list|(
argument|struct bce_softc *sc
argument_list|)
block|{
name|u32
name|val
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Hardware State "
literal|"----------------------------\n"
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"%s - bootcode version\n"
argument_list|,
name|sc
operator|->
name|bce_bc_ver
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_STATUS_BITS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) misc_enable_status_bits\n"
argument_list|,
name|val
argument_list|,
name|BCE_MISC_ENABLE_STATUS_BITS
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_DMA_STATUS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) dma_status\n"
argument_list|,
name|val
argument_list|,
name|BCE_DMA_STATUS
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_STATUS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) ctx_status\n"
argument_list|,
name|val
argument_list|,
name|BCE_CTX_STATUS
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_STATUS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) emac_status\n"
argument_list|,
name|val
argument_list|,
name|BCE_EMAC_STATUS
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_STATUS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) rpm_status\n"
argument_list|,
name|val
argument_list|,
name|BCE_RPM_STATUS
argument_list|)
block|;
comment|/* ToDo: Create a #define for this constant. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0x2004
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) rlup_status\n"
argument_list|,
name|val
argument_list|,
literal|0x2004
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_STATUS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) rv2p_status\n"
argument_list|,
name|val
argument_list|,
name|BCE_RV2P_STATUS
argument_list|)
block|;
comment|/* ToDo: Create a #define for this constant. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0x2c04
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) rdma_status\n"
argument_list|,
name|val
argument_list|,
literal|0x2c04
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TBDR_STATUS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) tbdr_status\n"
argument_list|,
name|val
argument_list|,
name|BCE_TBDR_STATUS
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TDMA_STATUS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) tdma_status\n"
argument_list|,
name|val
argument_list|,
name|BCE_TDMA_STATUS
argument_list|)
block|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATUS
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) hc_status\n"
argument_list|,
name|val
argument_list|,
name|BCE_HC_STATUS
argument_list|)
block|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TXP_CPU_STATE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) txp_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_TXP_CPU_STATE
argument_list|)
block|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TPAT_CPU_STATE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) tpat_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_TPAT_CPU_STATE
argument_list|)
block|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_CPU_STATE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) rxp_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_RXP_CPU_STATE
argument_list|)
block|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_CPU_STATE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) com_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_COM_CPU_STATE
argument_list|)
block|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_MCP_CPU_STATE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) mcp_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_MCP_CPU_STATE
argument_list|)
block|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_CP_CPU_STATE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) cp_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_CP_CPU_STATE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Register  Dump "
literal|"----------------------------\n"
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0x400
init|;
name|i
operator|<
literal|0x8000
condition|;
name|i
operator|+=
literal|0x10
control|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the mailbox queue registers.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_mq_regs
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"    MQ Regs     "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0x3c00
init|;
name|i
operator|<
literal|0x4000
condition|;
name|i
operator|+=
literal|0x10
control|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the bootcode state.                                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_bc_state
argument_list|(
argument|struct bce_softc *sc
argument_list|)
block|{
name|u32
name|val
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Bootcode State "
literal|"----------------------------\n"
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"%s - bootcode version\n"
argument_list|,
name|sc
operator|->
name|bce_bc_ver
argument_list|)
block|;
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_BC_RESET_TYPE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) reset_type\n"
argument_list|,
name|val
argument_list|,
name|BCE_BC_RESET_TYPE
argument_list|)
block|;
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_BC_STATE
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) state\n"
argument_list|,
name|val
argument_list|,
name|BCE_BC_STATE
argument_list|)
block|;
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_BC_STATE_CONDITION
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) condition\n"
argument_list|,
name|val
argument_list|,
name|BCE_BC_STATE_CONDITION
argument_list|)
block|;
name|val
operator|=
name|bce_shmem_rd
argument_list|(
name|sc
argument_list|,
name|BCE_BC_STATE_DEBUG_CMD
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) debug_cmd\n"
argument_list|,
name|val
argument_list|,
name|BCE_BC_STATE_DEBUG_CMD
argument_list|)
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
block|; }
comment|/****************************************************************************/
comment|/* Prints out the TXP processor state.                                      */
comment|/*                                                                          */
comment|/* Returns:                                                                 */
comment|/*   Nothing.                                                               */
comment|/****************************************************************************/
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_txp_state
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|int regs
argument_list|)
block|{
name|u32
name|val
block|;
name|u32
name|fw_version
index|[
literal|3
index|]
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   TXP  State   "
literal|"----------------------------\n"
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|fw_version
index|[
name|i
index|]
operator|=
name|htonl
argument_list|(
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
operator|(
name|BCE_TXP_SCRATCH
operator|+
literal|0x10
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"Firmware version - %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fw_version
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TXP_CPU_MODE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) txp_cpu_mode\n"
argument_list|,
name|val
argument_list|,
name|BCE_TXP_CPU_MODE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TXP_CPU_STATE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) txp_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_TXP_CPU_STATE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TXP_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) txp_cpu_event_mask\n"
argument_list|,
name|val
argument_list|,
name|BCE_TXP_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|regs
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Register  Dump "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BCE_TXP_CPU_MODE
init|;
name|i
operator|<
literal|0x68000
condition|;
name|i
operator|+=
literal|0x10
control|)
block|{
comment|/* Skip the big blank spaces */
if|if
condition|(
name|i
operator|<
literal|0x454000
operator|&&
name|i
operator|>
literal|0x5ffff
condition|)
name|BCE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X "
literal|"0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the RXP processor state.                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_rxp_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|regs
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|u32
name|fw_version
index|[
literal|3
index|]
decl_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   RXP  State   "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|fw_version
index|[
name|i
index|]
operator|=
name|htonl
argument_list|(
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
operator|(
name|BCE_RXP_SCRATCH
operator|+
literal|0x10
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"Firmware version - %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fw_version
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_CPU_MODE
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) rxp_cpu_mode\n"
argument_list|,
name|val
argument_list|,
name|BCE_RXP_CPU_MODE
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_CPU_STATE
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) rxp_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_RXP_CPU_STATE
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RXP_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) rxp_cpu_event_mask\n"
argument_list|,
name|val
argument_list|,
name|BCE_RXP_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Register  Dump "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BCE_RXP_CPU_MODE
init|;
name|i
operator|<
literal|0xe8fff
condition|;
name|i
operator|+=
literal|0x10
control|)
block|{
comment|/* Skip the big blank sapces */
if|if
condition|(
name|i
operator|<
literal|0xc5400
operator|&&
name|i
operator|>
literal|0xdffff
condition|)
name|BCE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X "
literal|"0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the TPAT processor state.                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_tpat_state
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|int regs
argument_list|)
block|{
name|u32
name|val
block|;
name|u32
name|fw_version
index|[
literal|3
index|]
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   TPAT State   "
literal|"----------------------------\n"
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|fw_version
index|[
name|i
index|]
operator|=
name|htonl
argument_list|(
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
operator|(
name|BCE_TPAT_SCRATCH
operator|+
literal|0x410
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"Firmware version - %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fw_version
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TPAT_CPU_MODE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) tpat_cpu_mode\n"
argument_list|,
name|val
argument_list|,
name|BCE_TPAT_CPU_MODE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TPAT_CPU_STATE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) tpat_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_TPAT_CPU_STATE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_TPAT_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) tpat_cpu_event_mask\n"
argument_list|,
name|val
argument_list|,
name|BCE_TPAT_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|regs
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Register  Dump "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BCE_TPAT_CPU_MODE
init|;
name|i
operator|<
literal|0xa3fff
condition|;
name|i
operator|+=
literal|0x10
control|)
block|{
comment|/* Skip the big blank spaces */
if|if
condition|(
name|i
operator|<
literal|0x854000
operator|&&
name|i
operator|>
literal|0x9ffff
condition|)
name|BCE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X "
literal|"0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the Command Procesor (CP) state.                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_cp_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|regs
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|u32
name|fw_version
index|[
literal|3
index|]
decl_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"    CP State    "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|fw_version
index|[
name|i
index|]
operator|=
name|htonl
argument_list|(
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
operator|(
name|BCE_CP_SCRATCH
operator|+
literal|0x10
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"Firmware version - %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fw_version
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_CP_CPU_MODE
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) cp_cpu_mode\n"
argument_list|,
name|val
argument_list|,
name|BCE_CP_CPU_MODE
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_CP_CPU_STATE
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) cp_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_CP_CPU_STATE
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_CP_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) cp_cpu_event_mask\n"
argument_list|,
name|val
argument_list|,
name|BCE_CP_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Register  Dump "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BCE_CP_CPU_MODE
init|;
name|i
operator|<
literal|0x1aa000
condition|;
name|i
operator|+=
literal|0x10
control|)
block|{
comment|/* Skip the big blank spaces */
if|if
condition|(
name|i
operator|<
literal|0x185400
operator|&&
name|i
operator|>
literal|0x19ffff
condition|)
name|BCE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X "
literal|"0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the Completion Procesor (COM) state.                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_dump_com_state
argument_list|(
argument|struct bce_softc *sc
argument_list|,
argument|int regs
argument_list|)
block|{
name|u32
name|val
block|;
name|u32
name|fw_version
index|[
literal|4
index|]
block|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   COM State    "
literal|"----------------------------\n"
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|fw_version
index|[
name|i
index|]
operator|=
name|htonl
argument_list|(
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
operator|(
name|BCE_COM_SCRATCH
operator|+
literal|0x10
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"Firmware version - %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fw_version
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_CPU_MODE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) com_cpu_mode\n"
argument_list|,
name|val
argument_list|,
name|BCE_COM_CPU_MODE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_CPU_STATE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) com_cpu_state\n"
argument_list|,
name|val
argument_list|,
name|BCE_COM_CPU_STATE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_COM_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - (0x%06X) com_cpu_event_mask\n"
argument_list|,
name|val
argument_list|,
name|BCE_COM_CPU_EVENT_MASK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|regs
condition|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Register  Dump "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BCE_COM_CPU_MODE
init|;
name|i
operator|<
literal|0x1053e8
condition|;
name|i
operator|+=
literal|0x10
control|)
block|{
name|BCE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X "
literal|"0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the Receive Virtual 2 Physical (RV2P) state.                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
unit|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_function
name|void
name|bce_dump_rv2p_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|,
name|pc1
decl_stmt|,
name|pc2
decl_stmt|,
name|fw_ver_high
decl_stmt|,
name|fw_ver_low
decl_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   RV2P State   "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Stall the RV2P processors. */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_RV2P_CONFIG_STALL_PROC1
operator||
name|BCE_RV2P_CONFIG_STALL_PROC2
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Read the firmware version. */
name|val
operator|=
literal|0x00000001
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_PROC1_ADDR_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|fw_ver_low
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_INSTR_LOW
argument_list|)
expr_stmt|;
name|fw_ver_high
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_INSTR_HIGH
argument_list|)
operator|&
name|BCE_RV2P_INSTR_HIGH_HIGH
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"RV2P1 Firmware version - 0x%08X:0x%08X\n"
argument_list|,
name|fw_ver_high
argument_list|,
name|fw_ver_low
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x00000001
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_PROC2_ADDR_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|fw_ver_low
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_INSTR_LOW
argument_list|)
expr_stmt|;
name|fw_ver_high
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_INSTR_HIGH
argument_list|)
operator|&
name|BCE_RV2P_INSTR_HIGH_HIGH
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"RV2P2 Firmware version - 0x%08X:0x%08X\n"
argument_list|,
name|fw_ver_high
argument_list|,
name|fw_ver_low
argument_list|)
expr_stmt|;
comment|/* Resume the RV2P processors. */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|BCE_RV2P_CONFIG_STALL_PROC1
operator||
name|BCE_RV2P_CONFIG_STALL_PROC2
operator|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Fetch the program counter value. */
name|val
operator|=
literal|0x68007800
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_DEBUG_VECT_PEEK
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_DEBUG_VECT_PEEK
argument_list|)
expr_stmt|;
name|pc1
operator|=
operator|(
name|val
operator|&
name|BCE_RV2P_DEBUG_VECT_PEEK_1_VALUE
operator|)
expr_stmt|;
name|pc2
operator|=
operator|(
name|val
operator|&
name|BCE_RV2P_DEBUG_VECT_PEEK_2_VALUE
operator|)
operator|>>
literal|16
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - RV2P1 program counter (1st read)\n"
argument_list|,
name|pc1
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - RV2P2 program counter (1st read)\n"
argument_list|,
name|pc2
argument_list|)
expr_stmt|;
comment|/* Fetch the program counter value again to see if it is advancing. */
name|val
operator|=
literal|0x68007800
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_DEBUG_VECT_PEEK
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_DEBUG_VECT_PEEK
argument_list|)
expr_stmt|;
name|pc1
operator|=
operator|(
name|val
operator|&
name|BCE_RV2P_DEBUG_VECT_PEEK_1_VALUE
operator|)
expr_stmt|;
name|pc2
operator|=
operator|(
name|val
operator|&
name|BCE_RV2P_DEBUG_VECT_PEEK_2_VALUE
operator|)
operator|>>
literal|16
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - RV2P1 program counter (2nd read)\n"
argument_list|,
name|pc1
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"0x%08X - RV2P2 program counter (2nd read)\n"
argument_list|,
name|pc2
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the driver state and then enters the debugger.                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|bce_breakpoint
argument_list|(
argument|struct bce_softc *sc
argument_list|)
block|{
comment|/* 	 * Unreachable code to silence compiler warnings 	 * about unused functions. 	 */
if|if
condition|(
literal|0
condition|)
block|{
name|bce_freeze_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_unfreeze_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_enet
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bce_dump_txbd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bce_dump_rxbd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bce_dump_tx_mbuf_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
name|bce_dump_rx_mbuf_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
name|bce_dump_l2fhdr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bce_dump_ctx
argument_list|(
name|sc
argument_list|,
name|RX_CID
argument_list|)
expr_stmt|;
name|bce_dump_ftqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_tx_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
name|bce_dump_rx_bd_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
name|bce_dump_status_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_stats_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_hw_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_bc_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_txp_state
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bce_dump_rxp_state
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bce_dump_tpat_state
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bce_dump_cp_state
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bce_dump_com_state
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bce_dump_rv2p_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_JUMBO_HDRSPLIT
name|bce_dump_pgbd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bce_dump_pg_mbuf_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_PG_BD
argument_list|)
expr_stmt|;
name|bce_dump_pg_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_PG_BD
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bce_dump_status_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bce_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Call the debugger. */
end_comment

begin_expr_stmt
name|breakpoint
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

