begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Broadcom Corporation  *	David Christensen<davidch@broadcom.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of Broadcom Corporation nor the name of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written consent.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The following controllers are supported by this driver:  *   BCM5706C A2, A3  *   BCM5708C B1  *  * The following controllers are not supported by this driver:  * (These are not "Production" versions of the controller.)  *   *   BCM5706C A0, A1  *   BCM5706S A0, A1, A2, A3  *   BCM5708C A0, B0  *   BCM5708S A0, B0, B1  */
end_comment

begin_include
include|#
directive|include
file|"opt_bce.h"
end_include

begin_include
include|#
directive|include
file|<dev/bce/if_bcereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bce/if_bcefw.h>
end_include

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Driver Version                                                       */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_decl_stmt
name|char
name|bce_driver_version
index|[]
init|=
literal|"v0.9.6"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Debug Options                                                        */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_decl_stmt
name|u32
name|bce_debug
init|=
name|BCE_WARN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*          0 = Never              */
end_comment

begin_comment
comment|/*          1 = 1 in 2,147,483,648 */
end_comment

begin_comment
comment|/*        256 = 1 in     8,388,608 */
end_comment

begin_comment
comment|/*       2048 = 1 in     1,048,576 */
end_comment

begin_comment
comment|/*      65536 = 1 in        32,768 */
end_comment

begin_comment
comment|/*    1048576 = 1 in         2,048 */
end_comment

begin_comment
comment|/*  268435456 =	1 in             8 */
end_comment

begin_comment
comment|/*  536870912 = 1 in             4 */
end_comment

begin_comment
comment|/* 1073741824 = 1 in             2 */
end_comment

begin_comment
comment|/* Controls how often the l2_fhdr frame error check will fail. */
end_comment

begin_decl_stmt
name|int
name|bce_debug_l2fhdr_status_check
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often the unexpected attention check will fail. */
end_comment

begin_decl_stmt
name|int
name|bce_debug_unexpected_attention
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often to simulate an mbuf allocation failure. */
end_comment

begin_decl_stmt
name|int
name|bce_debug_mbuf_allocation_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often to simulate a DMA mapping failure. */
end_comment

begin_decl_stmt
name|int
name|bce_debug_dma_map_addr_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often to simulate a bootcode failure. */
end_comment

begin_decl_stmt
name|int
name|bce_debug_bootcode_running_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* PCI Device ID Table                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Used by bce_probe() to identify the devices supported by this driver.    */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|BCE_DEVDESC_MAX
value|64
end_define

begin_decl_stmt
specifier|static
name|struct
name|bce_type
name|bce_devs
index|[]
init|=
block|{
comment|/* BCM5706C Controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706
block|,
name|HP_VENDORID
block|,
literal|0x3101
block|,
literal|"HP NC370T Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706
block|,
name|HP_VENDORID
block|,
literal|0x3106
block|,
literal|"HP NC370i Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5706 1000Base-T"
block|}
block|,
comment|/* BCM5706S controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706S
block|,
name|HP_VENDORID
block|,
literal|0x3102
block|,
literal|"HP NC370F Multifunction Gigabit Server Adapter"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5706S
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5706 1000Base-SX"
block|}
block|,
comment|/* BCM5708C controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5708 1000Base-T"
block|}
block|,
comment|/* BCM5708S controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM5708
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM5708 1000Base-T"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Supported Flash NVRAM device data.                                       */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|flash_spec
name|flash_table
index|[]
init|=
block|{
comment|/* Slow EEPROM */
block|{
literal|0x00000000
block|,
literal|0x40830380
block|,
literal|0x009f0081
block|,
literal|0xa184a053
block|,
literal|0xaf000400
block|,
literal|1
block|,
name|SEEPROM_PAGE_BITS
block|,
name|SEEPROM_PAGE_SIZE
block|,
name|SEEPROM_BYTE_ADDR_MASK
block|,
name|SEEPROM_TOTAL_SIZE
block|,
literal|"EEPROM - slow"
block|}
block|,
comment|/* Expansion entry 0001 */
block|{
literal|0x08000002
block|,
literal|0x4b808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 0001"
block|}
block|,
comment|/* Saifun SA25F010 (non-buffered flash) */
comment|/* strap, cfg1,& write1 need updates */
block|{
literal|0x04000001
block|,
literal|0x47808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
name|SAIFUN_FLASH_BASE_TOTAL_SIZE
operator|*
literal|2
block|,
literal|"Non-buffered flash (128kB)"
block|}
block|,
comment|/* Saifun SA25F020 (non-buffered flash) */
comment|/* strap, cfg1,& write1 need updates */
block|{
literal|0x0c000003
block|,
literal|0x4f808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
name|SAIFUN_FLASH_BASE_TOTAL_SIZE
operator|*
literal|4
block|,
literal|"Non-buffered flash (256kB)"
block|}
block|,
comment|/* Expansion entry 0100 */
block|{
literal|0x11000000
block|,
literal|0x53808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 0100"
block|}
block|,
comment|/* Entry 0101: ST M45PE10 (non-buffered flash, TetonII B0) */
block|{
literal|0x19000002
block|,
literal|0x5b808201
block|,
literal|0x000500db
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|ST_MICRO_FLASH_PAGE_BITS
block|,
name|ST_MICRO_FLASH_PAGE_SIZE
block|,
name|ST_MICRO_FLASH_BYTE_ADDR_MASK
block|,
name|ST_MICRO_FLASH_BASE_TOTAL_SIZE
operator|*
literal|2
block|,
literal|"Entry 0101: ST M45PE10 (128kB non-bufferred)"
block|}
block|,
comment|/* Entry 0110: ST M45PE20 (non-buffered flash)*/
block|{
literal|0x15000001
block|,
literal|0x57808201
block|,
literal|0x000500db
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|ST_MICRO_FLASH_PAGE_BITS
block|,
name|ST_MICRO_FLASH_PAGE_SIZE
block|,
name|ST_MICRO_FLASH_BYTE_ADDR_MASK
block|,
name|ST_MICRO_FLASH_BASE_TOTAL_SIZE
operator|*
literal|4
block|,
literal|"Entry 0110: ST M45PE20 (256kB non-bufferred)"
block|}
block|,
comment|/* Saifun SA25F005 (non-buffered flash) */
comment|/* strap, cfg1,& write1 need updates */
block|{
literal|0x1d000003
block|,
literal|0x5f808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
name|SAIFUN_FLASH_BASE_TOTAL_SIZE
block|,
literal|"Non-buffered flash (64kB)"
block|}
block|,
comment|/* Fast EEPROM */
block|{
literal|0x22000000
block|,
literal|0x62808380
block|,
literal|0x009f0081
block|,
literal|0xa184a053
block|,
literal|0xaf000400
block|,
literal|1
block|,
name|SEEPROM_PAGE_BITS
block|,
name|SEEPROM_PAGE_SIZE
block|,
name|SEEPROM_BYTE_ADDR_MASK
block|,
name|SEEPROM_TOTAL_SIZE
block|,
literal|"EEPROM - fast"
block|}
block|,
comment|/* Expansion entry 1001 */
block|{
literal|0x2a000002
block|,
literal|0x6b808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1001"
block|}
block|,
comment|/* Expansion entry 1010 */
block|{
literal|0x26000001
block|,
literal|0x67808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1010"
block|}
block|,
comment|/* ATMEL AT45DB011B (buffered flash) */
block|{
literal|0x2e000003
block|,
literal|0x6e808273
block|,
literal|0x00570081
block|,
literal|0x68848353
block|,
literal|0xaf000400
block|,
literal|1
block|,
name|BUFFERED_FLASH_PAGE_BITS
block|,
name|BUFFERED_FLASH_PAGE_SIZE
block|,
name|BUFFERED_FLASH_BYTE_ADDR_MASK
block|,
name|BUFFERED_FLASH_TOTAL_SIZE
block|,
literal|"Buffered flash (128kB)"
block|}
block|,
comment|/* Expansion entry 1100 */
block|{
literal|0x33000000
block|,
literal|0x73808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1100"
block|}
block|,
comment|/* Expansion entry 1101 */
block|{
literal|0x3b000002
block|,
literal|0x7b808201
block|,
literal|0x00050081
block|,
literal|0x03840253
block|,
literal|0xaf020406
block|,
literal|0
block|,
name|SAIFUN_FLASH_PAGE_BITS
block|,
name|SAIFUN_FLASH_PAGE_SIZE
block|,
name|SAIFUN_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1101"
block|}
block|,
comment|/* Ateml Expansion entry 1110 */
block|{
literal|0x37000001
block|,
literal|0x76808273
block|,
literal|0x00570081
block|,
literal|0x68848353
block|,
literal|0xaf000400
block|,
literal|1
block|,
name|BUFFERED_FLASH_PAGE_BITS
block|,
name|BUFFERED_FLASH_PAGE_SIZE
block|,
name|BUFFERED_FLASH_BYTE_ADDR_MASK
block|,
literal|0
block|,
literal|"Entry 1110 (Atmel)"
block|}
block|,
comment|/* ATMEL AT45DB021B (buffered flash) */
block|{
literal|0x3f000003
block|,
literal|0x7e808273
block|,
literal|0x00570081
block|,
literal|0x68848353
block|,
literal|0xaf000400
block|,
literal|1
block|,
name|BUFFERED_FLASH_PAGE_BITS
block|,
name|BUFFERED_FLASH_PAGE_SIZE
block|,
name|BUFFERED_FLASH_BYTE_ADDR_MASK
block|,
name|BUFFERED_FLASH_TOTAL_SIZE
operator|*
literal|2
block|,
literal|"Buffered flash (256kB)"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* FreeBSD device entry points.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|bce_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Debug Data Structure Dump Routines                                   */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|bce_dump_mbuf
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_tx_mbuf_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_rx_mbuf_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_txbd
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|tx_bd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_rxbd
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|rx_bd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_l2fhdr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|l2_fhdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_status_block
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_stats_block
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_driver_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dump_hw_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_breakpoint
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Register/Memory Access Routines                                      */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|u32
name|bce_reg_rd_ind
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_reg_wr_ind
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_ctx_wr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_miibus_read_reg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_miibus_write_reg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE NVRAM Access Routines                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|bce_acquire_nvram_lock
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_release_nvram_lock
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_enable_nvram_access
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_disable_nvram_access
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_read_dword
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_init_nvram
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_read
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_test
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_function_decl
specifier|static
name|int
name|bce_enable_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_disable_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_erase_page
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_write_dword
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|bce_dma_map_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dma_map_tx_desc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_dma_alloc
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_dma_free
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_release_resources
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Firmware Synchronization and Load                                    */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|bce_fw_sync
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_load_rv2p_fw
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_load_cpu_fw
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|cpu_reg
modifier|*
parameter_list|,
name|struct
name|fw_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_cpus
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_stop
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_reset
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_chipinit
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_blockinit
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_get_buf
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_init_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_init_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_free_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_free_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_tx_encap
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|,
name|u16
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bce_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_mgmt_init_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_init_context
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_get_mac_addr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_set_mac_addr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_phy_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_rx_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_tx_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_disable_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_enable_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function_decl
specifier|static
name|void
name|bce_poll_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|enum
name|poll_cmd
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|enum
name|poll_cmd
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|bce_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_set_rx_mode
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_stats_update
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_tick_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bce_add_sysctls
parameter_list|(
name|struct
name|bce_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* FreeBSD device dispatch table.                                           */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|bce_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bce_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bce_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bce_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bce_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|bce_miibus_read_reg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|bce_miibus_write_reg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|bce_miibus_statchg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|bce_driver
init|=
block|{
literal|"bce"
block|,
name|bce_methods
block|,
expr|sizeof
operator|(
expr|struct
name|bce_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|bce_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bce
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bce
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bce
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bce
argument_list|,
name|pci
argument_list|,
name|bce_driver
argument_list|,
name|bce_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|bce
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Device probe function.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Compares the device to the driver's list of supported devices and        */
end_comment

begin_comment
comment|/* reports back to the OS whether this is the right driver for the device.  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   BUS_PROBE_DEFAULT on success, positive value on failure.               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_type
modifier|*
name|t
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|descbuf
decl_stmt|;
name|u16
name|vid
init|=
literal|0
decl_stmt|,
name|did
init|=
literal|0
decl_stmt|,
name|svid
init|=
literal|0
decl_stmt|,
name|sdid
init|=
literal|0
decl_stmt|;
name|t
operator|=
name|bce_devs
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bce_softc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_dev
operator|=
name|dev
expr_stmt|;
comment|/* Get the data for the device to be probed. */
name|vid
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|did
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|svid
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sdid
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_LOAD
argument_list|,
literal|"%s(); VID = 0x%04X, DID = 0x%04X, SVID = 0x%04X, "
literal|"SDID = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|vid
argument_list|,
name|did
argument_list|,
name|svid
argument_list|,
name|sdid
argument_list|)
expr_stmt|;
comment|/* Look through the list of known devices for a match. */
while|while
condition|(
name|t
operator|->
name|bce_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|vid
operator|==
name|t
operator|->
name|bce_vid
operator|)
operator|&&
operator|(
name|did
operator|==
name|t
operator|->
name|bce_did
operator|)
operator|&&
operator|(
operator|(
name|svid
operator|==
name|t
operator|->
name|bce_svid
operator|)
operator|||
operator|(
name|t
operator|->
name|bce_svid
operator|==
name|PCI_ANY_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|sdid
operator|==
name|t
operator|->
name|bce_sdid
operator|)
operator|||
operator|(
name|t
operator|->
name|bce_sdid
operator|==
name|PCI_ANY_ID
operator|)
operator|)
condition|)
block|{
name|descbuf
operator|=
name|malloc
argument_list|(
name|BCE_DEVDESC_MAX
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Print out the device identity. */
name|snprintf
argument_list|(
name|descbuf
argument_list|,
name|BCE_DEVDESC_MAX
argument_list|,
literal|"%s (%c%d), %s"
argument_list|,
name|t
operator|->
name|bce_name
argument_list|,
operator|(
operator|(
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|+
literal|'A'
operator|)
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf
operator|)
argument_list|,
name|bce_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|descbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|t
operator|++
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_LOAD
argument_list|,
literal|"%s(%d): No IOCTL match found!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Device attach function.                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Allocates device resources, performs secondary chip identification,      */
end_comment

begin_comment
comment|/* resets and initializes the hardware, and initializes driver instance     */
end_comment

begin_comment
comment|/* variables.                                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|int
name|mbuf
decl_stmt|,
name|rid
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_dev
operator|=
name|dev
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_unit
operator|=
name|mbuf
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate PCI memory resources. */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
comment|/* dev */
name|SYS_RES_MEMORY
argument_list|,
comment|/* type */
operator|&
name|rid
argument_list|,
comment|/* rid */
name|RF_ACTIVE
operator||
name|PCI_RF_DENSE
argument_list|)
expr_stmt|;
comment|/* flags */
if|if
condition|(
name|sc
operator|->
name|bce_res
operator|==
name|NULL
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): PCI memory allocation failed\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Get various resource handles. */
name|sc
operator|->
name|bce_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|bce_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|bce_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_vhandle
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|bce_res
argument_list|)
expr_stmt|;
comment|/* Allocate PCI IRQ resources. */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_irq
operator|==
name|NULL
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): PCI map interrupt failed\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Initialize mutex for the current device instance. */
name|BCE_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Configure byte swap and enable indirect register access. 	 * Rely on CPU to do target byte swapping on big endian systems. 	 * Access to registers outside of PCI configurtion space are not 	 * valid until this is done. 	 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_MISC_CONFIG
argument_list|,
name|BCE_PCICFG_MISC_CONFIG_REG_WINDOW_ENA
operator||
name|BCE_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Save ASIC revsion info. */
name|sc
operator|->
name|bce_chipid
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ID
argument_list|)
expr_stmt|;
comment|/* Weed out any non-production controller revisions. */
switch|switch
condition|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
condition|)
block|{
case|case
name|BCE_CHIP_ID_5706_A0
case|:
case|case
name|BCE_CHIP_ID_5706_A1
case|:
case|case
name|BCE_CHIP_ID_5708_A0
case|:
case|case
name|BCE_CHIP_ID_5708_B0
case|:
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Unsupported controller revision (%c%d)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
operator|(
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|+
literal|'A'
operator|)
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
if|if
condition|(
name|BCE_CHIP_BOND_ID
argument_list|(
name|sc
argument_list|)
operator|&
name|BCE_CHIP_BOND_ID_SERDES_BIT
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): SerDes controllers are not supported!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/*  	 * The embedded PCIe to PCI-X bridge (EPB)  	 * in the 5708 cannot address memory above  	 * 40 bits (E7_5708CB1_23043& E6_5708SB1_23043).  	 */
if|if
condition|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5708
condition|)
name|sc
operator|->
name|max_bus_addr
operator|=
name|BCE_BUS_SPACE_MAXADDR
expr_stmt|;
else|else
name|sc
operator|->
name|max_bus_addr
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
comment|/* 	 * Find the base address for shared memory access. 	 * Newer versions of bootcode use a signature and offset 	 * while older versions use a fixed address. 	 */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_SHM_HDR_SIGNATURE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_SHM_HDR_SIGNATURE_SIG_MASK
operator|)
operator|==
name|BCE_SHM_HDR_SIGNATURE_SIG
condition|)
name|sc
operator|->
name|bce_shmem_base
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|BCE_SHM_HDR_ADDR_0
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|bce_shmem_base
operator|=
name|HOST_VIEW_SHMEM_BASE
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"bce_shmem_base = 0x%08X\n"
argument_list|,
name|sc
operator|->
name|bce_shmem_base
argument_list|)
expr_stmt|;
comment|/* Set initial device and PHY flags */
name|sc
operator|->
name|bce_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_phy_flags
operator|=
literal|0
expr_stmt|;
comment|/* Get PCI bus information (speed and type). */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_MISC_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_PCICFG_MISC_STATUS_PCIX_DET
condition|)
block|{
name|u32
name|clkreg
decl_stmt|;
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_PCIX_FLAG
expr_stmt|;
name|clkreg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS
argument_list|)
expr_stmt|;
name|clkreg
operator|&=
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET
expr_stmt|;
switch|switch
condition|(
name|clkreg
condition|)
block|{
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_133MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|133
expr_stmt|;
break|break;
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_95MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_66MHZ
case|:
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_80MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|66
expr_stmt|;
break|break;
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_48MHZ
case|:
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_55MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|50
expr_stmt|;
break|break;
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_LOW
case|:
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_32MHZ
case|:
case|case
name|BCE_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_38MHZ
case|:
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|33
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|val
operator|&
name|BCE_PCICFG_MISC_STATUS_M66EN
condition|)
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|66
expr_stmt|;
else|else
name|sc
operator|->
name|bus_speed_mhz
operator|=
literal|33
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|BCE_PCICFG_MISC_STATUS_32BIT_DET
condition|)
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_PCI_32BIT_FLAG
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"ASIC ID 0x%08X; Revision (%c%d); PCI%s %s %dMHz\n"
argument_list|,
name|sc
operator|->
name|bce_chipid
argument_list|,
operator|(
operator|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|+
literal|'A'
argument_list|,
operator|(
operator|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|&
literal|0x0ff0
operator|)
operator|>>
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCIX_FLAG
operator|)
condition|?
literal|"-X"
else|:
literal|""
operator|)
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCI_32BIT_FLAG
operator|)
condition|?
literal|"32-bit"
else|:
literal|"64-bit"
operator|)
argument_list|,
name|sc
operator|->
name|bus_speed_mhz
argument_list|)
expr_stmt|;
comment|/* Reset the controller. */
if|if
condition|(
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Initialize the controller. */
if|if
condition|(
name|bce_chipinit
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Controller initialization failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Perform NVRAM test. */
if|if
condition|(
name|bce_nvram_test
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): NVRAM test failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Fetch the permanent Ethernet MAC address. */
name|bce_get_mac_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Trip points control how many BDs 	 * should be ready before generating an 	 * interrupt while ticks control how long 	 * a BD can sit in the chain before 	 * generating an interrupt.  Set the default  	 * values for the RX and TX rings. 	 */
ifdef|#
directive|ifdef
name|BCE_DRBUG
comment|/* Force more frequent interrupts. */
name|sc
operator|->
name|bce_tx_quick_cons_trip_int
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_tx_quick_cons_trip
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_tx_ticks_int
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_tx_ticks
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_rx_quick_cons_trip_int
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_rx_quick_cons_trip
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bce_rx_ticks_int
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_rx_ticks
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|bce_tx_quick_cons_trip_int
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|bce_tx_quick_cons_trip
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|bce_tx_ticks_int
operator|=
literal|80
expr_stmt|;
name|sc
operator|->
name|bce_tx_ticks
operator|=
literal|80
expr_stmt|;
name|sc
operator|->
name|bce_rx_quick_cons_trip_int
operator|=
literal|6
expr_stmt|;
name|sc
operator|->
name|bce_rx_quick_cons_trip
operator|=
literal|6
expr_stmt|;
name|sc
operator|->
name|bce_rx_ticks_int
operator|=
literal|18
expr_stmt|;
name|sc
operator|->
name|bce_rx_ticks
operator|=
literal|18
expr_stmt|;
endif|#
directive|endif
comment|/* Update statistics once every second. */
name|sc
operator|->
name|bce_stats_ticks
operator|=
literal|1000000
operator|&
literal|0xffff00
expr_stmt|;
comment|/* 	 * The copper based NetXtreme II controllers 	 * use an integrated PHY at address 1 while 	 * the SerDes controllers use a PHY at 	 * address 2. 	 */
name|sc
operator|->
name|bce_phy_addr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|BCE_CHIP_BOND_ID
argument_list|(
name|sc
argument_list|)
operator|&
name|BCE_CHIP_BOND_ID_SERDES_BIT
condition|)
block|{
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_SERDES_FLAG
expr_stmt|;
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_NO_WOL_FLAG
expr_stmt|;
if|if
condition|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5708
condition|)
block|{
name|sc
operator|->
name|bce_phy_addr
operator|=
literal|2
expr_stmt|;
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_SHARED_HW_CFG_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_SHARED_HW_CFG_PHY_2_5G
condition|)
name|sc
operator|->
name|bce_phy_flags
operator||=
name|BCE_PHY_2_5G_CAPABLE_FLAG
expr_stmt|;
block|}
block|}
comment|/* Allocate DMA memory resources. */
if|if
condition|(
name|bce_dma_alloc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): DMA resource allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Allocate an ifnet structure. */
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Interface allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
comment|/* Initialize the ifnet interface. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|bce_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|bce_start
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|bce_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|bce_init
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|BCE_IF_HWASSIST
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|BCE_IF_CAPABILITIES
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* Assume a standard 1500 byte MTU size for mbuf allocations. */
name|sc
operator|->
name|mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|USABLE_TX_BD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_2_5G_CAPABLE_FLAG
condition|)
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|2.5
argument_list|)
expr_stmt|;
else|else
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_SERDES_FLAG
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): SerDes is not supported by this driver!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
else|else
block|{
comment|/* Look for our PHY. */
if|if
condition|(
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|bce_miibus
argument_list|,
name|bce_ifmedia_upd
argument_list|,
name|bce_ifmedia_sts
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): PHY probe failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bce_attach_fail
goto|;
block|}
block|}
comment|/* Attach to the Ethernet interface list. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|eaddr
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|bce_stat_ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|bce_stat_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Hookup IRQ last. */
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bce_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|bce_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|bce_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Failed to setup IRQ!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|bce_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|bce_attach_exit
goto|;
block|}
comment|/* Print some important debugging info. */
name|DBRUN
argument_list|(
name|BCE_INFO
argument_list|,
name|bce_dump_driver_state
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the supported sysctls to the kernel. */
name|bce_add_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get the firmware running so IPMI still works */
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_mgmt_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|bce_attach_exit
goto|;
name|bce_attach_fail
label|:
name|bce_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_attach_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Device detach function.                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Stops the controller, resets the controller, and releases resources.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Stop and reset the controller. */
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* If we have a child device on the MII bus remove it too. */
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_SERDES_FLAG
condition|)
block|{
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|bce_ifmedia
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
block|}
comment|/* Release all remaining resources. */
name|bce_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Device shutdown function.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Stops and resets the controller.                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing                                                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Indirect register read.                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Reads NetXtreme II registers using an index/data register pair in PCI    */
end_comment

begin_comment
comment|/* configuration space.  Using this mechanism avoids issues with posted     */
end_comment

begin_comment
comment|/* reads but is much slower than memory-mapped I/O.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The value of the register.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|u32
name|bce_reg_rd_ind
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|bce_dev
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW_ADDRESS
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXCESSIVE
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
else|#
directive|else
return|return
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW
argument_list|,
literal|4
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Indirect register write.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Writes NetXtreme II registers using an index/data register pair in PCI   */
end_comment

begin_comment
comment|/* configuration space.  Using this mechanism avoids issues with posted     */
end_comment

begin_comment
comment|/* writes but is muchh slower than memory-mapped I/O.                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_reg_wr_ind
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|bce_dev
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXCESSIVE
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW_ADDRESS
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|BCE_PCICFG_REG_WINDOW
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Context memory write.                                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* The NetXtreme II controller uses context memory to track connection      */
end_comment

begin_comment
comment|/* information for L2 and higher network protocols.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_ctx_wr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|cid_addr
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXCESSIVE
argument_list|,
literal|"%s(); cid_addr = 0x%08X, offset = 0x%08X, "
literal|"val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid_addr
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|cid_addr
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_DATA_ADR
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* PHY register read.                                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Implements register reads on the MII bus.                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The value of the register.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_miibus_read_reg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Make sure we are accessing the correct PHY address. */
if|if
condition|(
name|phy
operator|!=
name|sc
operator|->
name|bce_phy_addr
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Invalid PHY address %d for PHY read!\n"
argument_list|,
name|phy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_INT_MODE_AUTO_POLLING_FLAG
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|BCE_EMAC_MDIO_MODE_AUTO_POLL
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|BCE_MIPHY
argument_list|(
name|phy
argument_list|)
operator||
name|BCE_MIREG
argument_list|(
name|reg
argument_list|)
operator||
name|BCE_EMAC_MDIO_COMM_COMMAND_READ
operator||
name|BCE_EMAC_MDIO_COMM_DISEXT
operator||
name|BCE_EMAC_MDIO_COMM_START_BUSY
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCE_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|BCE_EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
name|val
operator|&=
name|BCE_EMAC_MDIO_COMM_DATA
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|val
operator|&
name|BCE_EMAC_MDIO_COMM_START_BUSY
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Error: PHY read timeout! phy = %d, reg = 0x%04X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXCESSIVE
argument_list|,
literal|"%s(): phy = %d, reg = 0x%04X, val = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|phy
argument_list|,
operator|(
name|u16
operator|)
name|reg
operator|&
literal|0xffff
argument_list|,
operator|(
name|u16
operator|)
name|val
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_INT_MODE_AUTO_POLLING_FLAG
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|val
operator||=
name|BCE_EMAC_MDIO_MODE_AUTO_POLL
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* PHY register write.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Implements register writes on the MII bus.                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   The value of the register.                                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_miibus_write_reg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|u32
name|val1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Make sure we are accessing the correct PHY address. */
if|if
condition|(
name|phy
operator|!=
name|sc
operator|->
name|bce_phy_addr
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Invalid PHY address %d for PHY write!\n"
argument_list|,
name|phy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXCESSIVE
argument_list|,
literal|"%s(): phy = %d, reg = 0x%04X, val = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|phy
argument_list|,
operator|(
name|u16
operator|)
name|reg
operator|&
literal|0xffff
argument_list|,
operator|(
name|u16
operator|)
name|val
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_INT_MODE_AUTO_POLLING_FLAG
condition|)
block|{
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|val1
operator|&=
operator|~
name|BCE_EMAC_MDIO_MODE_AUTO_POLL
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
name|val1
operator|=
name|BCE_MIPHY
argument_list|(
name|phy
argument_list|)
operator||
name|BCE_MIREG
argument_list|(
name|reg
argument_list|)
operator||
name|val
operator||
name|BCE_EMAC_MDIO_COMM_COMMAND_WRITE
operator||
name|BCE_EMAC_MDIO_COMM_START_BUSY
operator||
name|BCE_EMAC_MDIO_COMM_DISEXT
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|,
name|val1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCE_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val1
operator|&
name|BCE_EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|val1
operator|&
name|BCE_EMAC_MDIO_COMM_START_BUSY
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): PHY write timeout!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_INT_MODE_AUTO_POLLING_FLAG
condition|)
block|{
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|val1
operator||=
name|BCE_EMAC_MDIO_MODE_AUTO_POLL
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* MII bus status change.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Called by the MII bus driver when the PHY establishes link to set the    */
end_comment

begin_comment
comment|/* MAC interface registers.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|BCE_CLRBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MODE
argument_list|,
name|BCE_EMAC_MODE_PORT
argument_list|)
expr_stmt|;
comment|/* Set MII or GMII inerface based on the speed negotiated by the PHY. */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_1000_T
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Setting GMII interface.\n"
argument_list|)
expr_stmt|;
name|BCE_SETBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MODE
argument_list|,
name|BCE_EMAC_MODE_PORT_GMII
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Setting MII interface.\n"
argument_list|)
expr_stmt|;
name|BCE_SETBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MODE
argument_list|,
name|BCE_EMAC_MODE_PORT_MII
argument_list|)
expr_stmt|;
block|}
comment|/* Set half or full duplex based on the duplicity negotiated by the PHY. */
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Setting Full-Duplex interface.\n"
argument_list|)
expr_stmt|;
name|BCE_CLRBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MODE
argument_list|,
name|BCE_EMAC_MODE_HALF_DUPLEX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Setting Half-Duplex interface.\n"
argument_list|)
expr_stmt|;
name|BCE_SETBIT
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MODE
argument_list|,
name|BCE_EMAC_MODE_HALF_DUPLEX
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Acquire NVRAM lock.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Before the NVRAM can be accessed the caller must acquire an NVRAM lock.  */
end_comment

begin_comment
comment|/* Locks 0 and 2 are reserved, lock 1 is used by firmware and lock 2 is     */
end_comment

begin_comment
comment|/* for use by the driver.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_acquire_nvram_lock
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|j
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Acquiring NVRAM lock.\n"
argument_list|)
expr_stmt|;
comment|/* Request access to the flash interface. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_SW_ARB
argument_list|,
name|BCE_NVM_SW_ARB_ARB_REQ_SET2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_SW_ARB
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_NVM_SW_ARB_ARB_ARB2
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Timeout acquiring NVRAM lock!\n"
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Release NVRAM lock.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When the caller is finished accessing NVRAM the lock must be released.   */
end_comment

begin_comment
comment|/* Locks 0 and 2 are reserved, lock 1 is used by firmware and lock 2 is     */
end_comment

begin_comment
comment|/* for use by the driver.                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_release_nvram_lock
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Releasing NVRAM lock.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Relinquish nvram interface. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_SW_ARB
argument_list|,
name|BCE_NVM_SW_ARB_ARB_REQ_CLR2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_SW_ARB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|BCE_NVM_SW_ARB_ARB_ARB2
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Timeout reeasing NVRAM lock!\n"
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Enable NVRAM write access.                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Before writing to NVRAM the caller must enable NVRAM writes.             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_enable_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Enabling NVRAM write.\n"
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_CFG
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_CFG
argument_list|,
name|val
operator||
name|BCE_MISC_CFG_NVM_WR_EN_PCI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|bce_flash_info
operator|->
name|buffered
condition|)
block|{
name|int
name|j
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_WREN
operator||
name|BCE_NVM_COMMAND_DOIT
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_NVM_COMMAND_DONE
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Timeout writing NVRAM!\n"
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Disable NVRAM write access.                                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When the caller is finished writing to NVRAM write access must be        */
end_comment

begin_comment
comment|/* disabled.                                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_disable_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Disabling NVRAM write.\n"
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_CFG
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_CFG
argument_list|,
name|val
operator|&
operator|~
name|BCE_MISC_CFG_NVM_WR_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Enable NVRAM access.                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Before accessing NVRAM for read or write operations the caller must      */
end_comment

begin_comment
comment|/* enabled NVRAM access.                                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_enable_nvram_access
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Enabling NVRAM access.\n"
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ACCESS_ENABLE
argument_list|)
expr_stmt|;
comment|/* Enable both bits, even on read. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ACCESS_ENABLE
argument_list|,
name|val
operator||
name|BCE_NVM_ACCESS_ENABLE_EN
operator||
name|BCE_NVM_ACCESS_ENABLE_WR_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Disable NVRAM access.                                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When the caller is finished accessing NVRAM access must be disabled.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_disable_nvram_access
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Disabling NVRAM access.\n"
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ACCESS_ENABLE
argument_list|)
expr_stmt|;
comment|/* Disable both bits, even after read. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ACCESS_ENABLE
argument_list|,
name|val
operator|&
operator|~
operator|(
name|BCE_NVM_ACCESS_ENABLE_EN
operator||
name|BCE_NVM_ACCESS_ENABLE_WR_EN
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Erase NVRAM page before writing.                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Non-buffered flash parts require that a page be erased before it is      */
end_comment

begin_comment
comment|/* written.                                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_erase_page
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
name|u32
name|cmd
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Buffered flash doesn't require an erase. */
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|buffered
condition|)
return|return
literal|0
return|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Erasing NVRAM page.\n"
argument_list|)
expr_stmt|;
comment|/* Build an erase command. */
name|cmd
operator|=
name|BCE_NVM_COMMAND_ERASE
operator||
name|BCE_NVM_COMMAND_WR
operator||
name|BCE_NVM_COMMAND_DOIT
expr_stmt|;
comment|/* 	 * Clear the DONE bit separately, set the NVRAM adress to erase, 	 * and issue the erase command. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ADDR
argument_list|,
name|offset
operator|&
name|BCE_NVM_ADDR_NVM_ADDR_VALUE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|u32
name|val
decl_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_NVM_COMMAND_DONE
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"Timeout erasing NVRAM.\n"
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BCE_NVRAM_WRITE_SUPPORT */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Read a dword (32 bits) from NVRAM.                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Read a 32 bit word from NVRAM.  The caller is assumed to have already    */
end_comment

begin_comment
comment|/* obtained the NVRAM lock and enabled the controller for NVRAM access.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success and the 32 bit value read, positive value on failure.     */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_read_dword
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|ret_val
parameter_list|,
name|u32
name|cmd_flags
parameter_list|)
block|{
name|u32
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
comment|/* Build the command word. */
name|cmd
operator|=
name|BCE_NVM_COMMAND_DOIT
operator||
name|cmd_flags
expr_stmt|;
comment|/* Calculate the offset for buffered flash. */
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|buffered
condition|)
block|{
name|offset
operator|=
operator|(
operator|(
name|offset
operator|/
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
operator|<<
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_bits
operator|)
operator|+
operator|(
name|offset
operator|%
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
expr_stmt|;
block|}
comment|/* 	 * Clear the DONE bit separately, set the address to read, 	 * and issue the read. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ADDR
argument_list|,
name|offset
operator|&
name|BCE_NVM_ADDR_NVM_ADDR_VALUE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|val
decl_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BCE_NVM_COMMAND_DONE
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_READ
argument_list|)
expr_stmt|;
name|val
operator|=
name|bce_be32toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_val
argument_list|,
operator|&
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for errors. */
if|if
condition|(
name|i
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Timeout error reading NVRAM at offset 0x%08X!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Write a dword (32 bits) to NVRAM.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Write a 32 bit word to NVRAM.  The caller is assumed to have already     */
end_comment

begin_comment
comment|/* obtained the NVRAM lock, enabled the controller for NVRAM access, and    */
end_comment

begin_comment
comment|/* enabled NVRAM write access.                                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_write_dword
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|,
name|u32
name|cmd_flags
parameter_list|)
block|{
name|u32
name|cmd
decl_stmt|,
name|val32
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Build the command word. */
name|cmd
operator|=
name|BCE_NVM_COMMAND_DOIT
operator||
name|BCE_NVM_COMMAND_WR
operator||
name|cmd_flags
expr_stmt|;
comment|/* Calculate the offset for buffered flash. */
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|buffered
condition|)
block|{
name|offset
operator|=
operator|(
operator|(
name|offset
operator|/
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
operator|<<
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_bits
operator|)
operator|+
operator|(
name|offset
operator|%
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
expr_stmt|;
block|}
comment|/* 	 * Clear the DONE bit separately, convert NVRAM data to big-endian, 	 * set the NVRAM address to write, and issue the write command 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|BCE_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|val32
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val32
operator|=
name|htobe32
argument_list|(
name|val32
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_WRITE
argument_list|,
name|val32
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_ADDR
argument_list|,
name|offset
operator|&
name|BCE_NVM_ADDR_NVM_ADDR_VALUE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|j
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_COMMAND
argument_list|)
operator|&
name|BCE_NVM_COMMAND_DONE
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
name|NVRAM_TIMEOUT_COUNT
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Timeout error writing NVRAM at offset 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BCE_NVRAM_WRITE_SUPPORT */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize NVRAM access.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Identify the NVRAM device in use and prepare the NVRAM interface to      */
end_comment

begin_comment
comment|/* access that device.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_init_nvram
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|j
decl_stmt|,
name|entry_count
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|flash_spec
modifier|*
name|flash
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Determine the selected interface. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_CFG1
argument_list|)
expr_stmt|;
name|entry_count
operator|=
sizeof|sizeof
argument_list|(
name|flash_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|flash_spec
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Flash reconfiguration is required to support additional 	 * NVRAM devices not directly supported in hardware. 	 * Check if the flash interface was reconfigured 	 * by the bootcode. 	 */
if|if
condition|(
name|val
operator|&
literal|0x40000000
condition|)
block|{
comment|/* Flash interface reconfigured by bootcode. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"bce_init_nvram(): Flash WAS reconfigured.\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|flash
operator|=
operator|&
name|flash_table
index|[
literal|0
index|]
init|;
name|j
operator|<
name|entry_count
condition|;
name|j
operator|++
operator|,
name|flash
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|FLASH_BACKUP_STRAP_MASK
operator|)
operator|==
operator|(
name|flash
operator|->
name|config1
operator|&
name|FLASH_BACKUP_STRAP_MASK
operator|)
condition|)
block|{
name|sc
operator|->
name|bce_flash_info
operator|=
name|flash
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Flash interface not yet reconfigured. */
name|u32
name|mask
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"bce_init_nvram(): Flash was NOT reconfigured.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|mask
operator|=
name|FLASH_BACKUP_STRAP_MASK
expr_stmt|;
else|else
name|mask
operator|=
name|FLASH_STRAP_MASK
expr_stmt|;
comment|/* Look for the matching NVRAM device configuration data. */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|flash
operator|=
operator|&
name|flash_table
index|[
literal|0
index|]
init|;
name|j
operator|<
name|entry_count
condition|;
name|j
operator|++
operator|,
name|flash
operator|++
control|)
block|{
comment|/* Check if the device matches any of the known devices. */
if|if
condition|(
operator|(
name|val
operator|&
name|mask
operator|)
operator|==
operator|(
name|flash
operator|->
name|strapping
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* Found a device match. */
name|sc
operator|->
name|bce_flash_info
operator|=
name|flash
expr_stmt|;
comment|/* Request access to the flash interface. */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
comment|/* Reconfigure the flash interface. */
name|bce_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_CFG1
argument_list|,
name|flash
operator|->
name|config1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_CFG2
argument_list|,
name|flash
operator|->
name|config2
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_CFG3
argument_list|,
name|flash
operator|->
name|config3
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_NVM_WRITE1
argument_list|,
name|flash
operator|->
name|write1
argument_list|)
expr_stmt|;
name|bce_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Check if a matching device was found. */
if|if
condition|(
name|j
operator|==
name|entry_count
condition|)
block|{
name|sc
operator|->
name|bce_flash_info
operator|=
name|NULL
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Unknown Flash NVRAM found!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
comment|/* Write the flash config data to the shared memory interface. */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_SHARED_HW_CFG_CONFIG2
argument_list|)
expr_stmt|;
name|val
operator|&=
name|BCE_SHARED_HW_CFG2_NVM_SIZE_MASK
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|sc
operator|->
name|bce_flash_size
operator|=
name|val
expr_stmt|;
else|else
name|sc
operator|->
name|bce_flash_size
operator|=
name|sc
operator|->
name|bce_flash_info
operator|->
name|total_size
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_LOAD
argument_list|,
literal|"bce_init_nvram() flash->total_size = 0x%08X\n"
argument_list|,
name|sc
operator|->
name|bce_flash_info
operator|->
name|total_size
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Read an arbitrary range of data from NVRAM.                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Prepares the NVRAM interface for access and reads the requested data     */
end_comment

begin_comment
comment|/* into the supplied buffer.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success and the data read, positive value on failure.             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_read
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|ret_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|u32
name|cmd_flags
decl_stmt|,
name|offset32
decl_stmt|,
name|len32
decl_stmt|,
name|extra
decl_stmt|;
if|if
condition|(
name|buf_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Request access to the flash interface. */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
comment|/* Enable access to flash interface */
name|bce_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|len32
operator|=
name|buf_size
expr_stmt|;
name|offset32
operator|=
name|offset
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset32
operator|&
literal|3
condition|)
block|{
name|u8
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|pre_len
decl_stmt|;
name|offset32
operator|&=
operator|~
literal|3
expr_stmt|;
name|pre_len
operator|=
literal|4
operator|-
operator|(
name|offset
operator|&
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|pre_len
operator|>=
name|len32
condition|)
block|{
name|pre_len
operator|=
name|len32
expr_stmt|;
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
operator||
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
block|}
else|else
block|{
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
expr_stmt|;
block|}
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
name|buf
operator|+
operator|(
name|offset
operator|&
literal|3
operator|)
argument_list|,
name|pre_len
argument_list|)
expr_stmt|;
name|offset32
operator|+=
literal|4
expr_stmt|;
name|ret_buf
operator|+=
name|pre_len
expr_stmt|;
name|len32
operator|-=
name|pre_len
expr_stmt|;
block|}
if|if
condition|(
name|len32
operator|&
literal|3
condition|)
block|{
name|extra
operator|=
literal|4
operator|-
operator|(
name|len32
operator|&
literal|3
operator|)
expr_stmt|;
name|len32
operator|=
operator|(
name|len32
operator|+
literal|4
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|len32
operator|==
literal|4
condition|)
block|{
name|u8
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|cmd_flags
condition|)
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
else|else
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
operator||
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
name|buf
argument_list|,
literal|4
operator|-
name|extra
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len32
operator|>
literal|0
condition|)
block|{
name|u8
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Read the first word. */
if|if
condition|(
name|cmd_flags
condition|)
name|cmd_flags
operator|=
literal|0
expr_stmt|;
else|else
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
expr_stmt|;
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|ret_buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
comment|/* Advance to the next dword. */
name|offset32
operator|+=
literal|4
expr_stmt|;
name|ret_buf
operator|+=
literal|4
expr_stmt|;
name|len32
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|len32
operator|>
literal|4
operator|&&
name|rc
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|ret_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Advance to the next dword. */
name|offset32
operator|+=
literal|4
expr_stmt|;
name|ret_buf
operator|+=
literal|4
expr_stmt|;
name|len32
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
name|buf
argument_list|,
literal|4
operator|-
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* Disable access to flash interface and release the lock. */
name|bce_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Write an arbitrary range of data from NVRAM.                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Prepares the NVRAM interface for write access and writes the requested   */
end_comment

begin_comment
comment|/* data from the supplied buffer.  The caller is responsible for            */
end_comment

begin_comment
comment|/* calculating any appropriate CRCs.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_write
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|data_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|u32
name|written
decl_stmt|,
name|offset32
decl_stmt|,
name|len32
decl_stmt|;
name|u8
modifier|*
name|buf
decl_stmt|,
name|start
index|[
literal|4
index|]
decl_stmt|,
name|end
index|[
literal|4
index|]
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|align_start
decl_stmt|,
name|align_end
decl_stmt|;
name|buf
operator|=
name|data_buf
expr_stmt|;
name|offset32
operator|=
name|offset
expr_stmt|;
name|len32
operator|=
name|buf_size
expr_stmt|;
name|align_start
operator|=
name|align_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|align_start
operator|=
operator|(
name|offset32
operator|&
literal|3
operator|)
operator|)
condition|)
block|{
name|offset32
operator|&=
operator|~
literal|3
expr_stmt|;
name|len32
operator|+=
name|align_start
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
name|offset32
argument_list|,
name|start
argument_list|,
literal|4
argument_list|)
operator|)
condition|)
return|return
name|rc
return|;
block|}
if|if
condition|(
name|len32
operator|&
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|len32
operator|>
literal|4
operator|)
operator|||
operator|!
name|align_start
condition|)
block|{
name|align_end
operator|=
literal|4
operator|-
operator|(
name|len32
operator|&
literal|3
operator|)
expr_stmt|;
name|len32
operator|+=
name|align_end
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
name|offset32
operator|+
name|len32
operator|-
literal|4
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
operator|)
condition|)
block|{
return|return
name|rc
return|;
block|}
block|}
block|}
if|if
condition|(
name|align_start
operator|||
name|align_end
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|len32
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
name|align_start
condition|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align_end
condition|)
block|{
name|memcpy
argument_list|(
name|buf
operator|+
name|len32
operator|-
literal|4
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
operator|+
name|align_start
argument_list|,
name|data_buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
block|}
name|written
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|written
operator|<
name|len32
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
condition|)
block|{
name|u32
name|page_start
decl_stmt|,
name|page_end
decl_stmt|,
name|data_start
decl_stmt|,
name|data_end
decl_stmt|;
name|u32
name|addr
decl_stmt|,
name|cmd_flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u8
name|flash_buffer
index|[
literal|264
index|]
decl_stmt|;
comment|/* Find the page_start addr */
name|page_start
operator|=
name|offset32
operator|+
name|written
expr_stmt|;
name|page_start
operator|-=
operator|(
name|page_start
operator|%
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|)
expr_stmt|;
comment|/* Find the page_end addr */
name|page_end
operator|=
name|page_start
operator|+
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
expr_stmt|;
comment|/* Find the data_start addr */
name|data_start
operator|=
operator|(
name|written
operator|==
literal|0
operator|)
condition|?
name|offset32
else|:
name|page_start
expr_stmt|;
comment|/* Find the data_end addr */
name|data_end
operator|=
operator|(
name|page_end
operator|>
name|offset32
operator|+
name|len32
operator|)
condition|?
operator|(
name|offset32
operator|+
name|len32
operator|)
else|:
name|page_end
expr_stmt|;
comment|/* Request access to the flash interface. */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|nvram_write_end
goto|;
comment|/* Enable access to flash interface */
name|bce_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_FIRST
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|buffered
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Read the whole page into the buffer 			 * (non-buffer flash only) */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
condition|;
name|j
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|j
operator|==
operator|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|page_size
operator|-
literal|4
operator|)
condition|)
block|{
name|cmd_flags
operator||=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
block|}
name|rc
operator|=
name|bce_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|page_start
operator|+
name|j
argument_list|,
operator|&
name|flash_buffer
index|[
name|j
index|]
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|nvram_write_end
goto|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Enable writes to flash interface (unlock write-protect) */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_enable_nvram_write
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|nvram_write_end
goto|;
comment|/* Erase the page */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_erase_page
argument_list|(
name|sc
argument_list|,
name|page_start
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|nvram_write_end
goto|;
comment|/* Re-enable the write again for the actual write */
name|bce_enable_nvram_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Loop to write back the buffer data from page_start to 		 * data_start */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|buffered
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|addr
operator|=
name|page_start
init|;
name|addr
operator|<
name|data_start
condition|;
name|addr
operator|+=
literal|4
operator|,
name|i
operator|+=
literal|4
control|)
block|{
name|rc
operator|=
name|bce_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|&
name|flash_buffer
index|[
name|i
index|]
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|nvram_write_end
goto|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Loop to write the new data from data_start to data_end */
for|for
control|(
name|addr
operator|=
name|data_start
init|;
name|addr
operator|<
name|data_end
condition|;
name|addr
operator|+=
literal|4
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|addr
operator|==
name|page_end
operator|-
literal|4
operator|)
operator|||
operator|(
operator|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|buffered
operator|)
operator|&&
operator|(
name|addr
operator|==
name|data_end
operator|-
literal|4
operator|)
operator|)
condition|)
block|{
name|cmd_flags
operator||=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
block|}
name|rc
operator|=
name|bce_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|buf
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|nvram_write_end
goto|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Loop to write back the buffer data from data_end 		 * to page_end */
if|if
condition|(
name|sc
operator|->
name|bce_flash_info
operator|->
name|buffered
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|addr
operator|=
name|data_end
init|;
name|addr
operator|<
name|page_end
condition|;
name|addr
operator|+=
literal|4
operator|,
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|addr
operator|==
name|page_end
operator|-
literal|4
condition|)
block|{
name|cmd_flags
operator|=
name|BCE_NVM_COMMAND_LAST
expr_stmt|;
block|}
name|rc
operator|=
name|bce_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|&
name|flash_buffer
index|[
name|i
index|]
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|nvram_write_end
goto|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Disable writes to flash interface (lock write-protect) */
name|bce_disable_nvram_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable access to flash interface */
name|bce_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Increment written */
name|written
operator|+=
name|data_end
operator|-
name|data_start
expr_stmt|;
block|}
name|nvram_write_end
label|:
if|if
condition|(
name|align_start
operator|||
name|align_end
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BCE_NVRAM_WRITE_SUPPORT */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Verifies that NVRAM is accessible and contains valid data.               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Reads the configuration data from NVRAM and verifies that the CRC is     */
end_comment

begin_comment
comment|/* correct.                                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 on success, positive value on failure.                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_nvram_test
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|buf
index|[
name|BCE_NVRAM_SIZE
operator|/
literal|4
index|]
decl_stmt|;
name|u8
modifier|*
name|data
init|=
operator|(
name|u8
operator|*
operator|)
name|buf
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|u32
name|magic
decl_stmt|,
name|csum
decl_stmt|;
comment|/* 	 * Check that the device NVRAM is valid by reading 	 * the magic value at offset 0. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_test_done
goto|;
name|magic
operator|=
name|bce_be32toh
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|BCE_NVRAM_MAGIC
condition|)
block|{
name|rc
operator|=
name|ENODEV
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Invalid NVRAM magic value! Expected: 0x%08X, "
literal|"Found: 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|BCE_NVRAM_MAGIC
argument_list|,
name|magic
argument_list|)
expr_stmt|;
goto|goto
name|bce_nvram_test_done
goto|;
block|}
comment|/* 	 * Verify that the device NVRAM includes valid 	 * configuration data. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|bce_nvram_read
argument_list|(
name|sc
argument_list|,
literal|0x100
argument_list|,
name|data
argument_list|,
name|BCE_NVRAM_SIZE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bce_nvram_test_done
goto|;
name|csum
operator|=
name|ether_crc32_le
argument_list|(
name|data
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|BCE_CRC32_RESIDUAL
condition|)
block|{
name|rc
operator|=
name|ENODEV
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Invalid Manufacturing Information NVRAM CRC! "
literal|"Expected: 0x%08X, Found: 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|BCE_CRC32_RESIDUAL
argument_list|,
name|csum
argument_list|)
expr_stmt|;
goto|goto
name|bce_nvram_test_done
goto|;
block|}
name|csum
operator|=
name|ether_crc32_le
argument_list|(
name|data
operator|+
literal|0x100
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|BCE_CRC32_RESIDUAL
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Invalid Feature Configuration Information "
literal|"NVRAM CRC! Expected: 0x%08X, Found: 08%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|BCE_CRC32_RESIDUAL
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
name|bce_nvram_test_done
label|:
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Free any DMA memory owned by the driver.                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Scans through each data structre that requires DMA memory and frees      */
end_comment

begin_comment
comment|/* the memory if allocated.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_dma_free
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Destroy the status block. */
if|if
condition|(
name|sc
operator|->
name|status_block
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_block
argument_list|,
name|sc
operator|->
name|status_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|status_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|status_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|)
expr_stmt|;
comment|/* Destroy the statistics block. */
if|if
condition|(
name|sc
operator|->
name|stats_block
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
name|sc
operator|->
name|stats_block
argument_list|,
name|sc
operator|->
name|stats_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|stats_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
name|sc
operator|->
name|stats_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
name|sc
operator|->
name|stats_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|stats_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|)
expr_stmt|;
comment|/* Free, unmap and destroy all TX buffer descriptor chain pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Destroy the TX buffer descriptor tag. */
if|if
condition|(
name|sc
operator|->
name|tx_bd_chain_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|)
expr_stmt|;
comment|/* Free, unmap and destroy all RX buffer descriptor chain pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Destroy the RX buffer descriptor tag. */
if|if
condition|(
name|sc
operator|->
name|rx_bd_chain_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|)
expr_stmt|;
comment|/* Unload and destroy the TX mbuf maps. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_TX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Destroy the TX mbuf tag. */
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|)
expr_stmt|;
comment|/* Unload and destroy the RX mbuf maps. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_RX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Destroy the RX mbuf tag. */
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|)
expr_stmt|;
comment|/* Destroy the parent tag */
if|if
condition|(
name|sc
operator|->
name|parent_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Get DMA memory from the OS.                                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Validates that the OS has provided DMA buffers in response to a          */
end_comment

begin_comment
comment|/* bus_dmamap_load() call and saves the physical address of those buffers.  */
end_comment

begin_comment
comment|/* When the callback is used the OS will return 0 for the mapping function  */
end_comment

begin_comment
comment|/* (bus_dmamap_load()) so we use the value of map_arg->maxsegs to pass any  */
end_comment

begin_comment
comment|/* failures back to the caller.                                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bce_dmamap_arg
modifier|*
name|map_arg
init|=
name|arg
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|map_arg
operator|->
name|sc
decl_stmt|;
comment|/* Simulate a mapping failure. */
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(bce_debug_dma_map_addr_failure)
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(%d): Simulating DMA mapping error.\n"
argument|, 			__FILE__, __LINE__); 		error = ENOMEM
argument_list|)
empty_stmt|;
comment|/* Check for an error and signal the caller that an error occurred. */
if|if
condition|(
name|error
operator|||
operator|(
name|nseg
operator|>
name|map_arg
operator|->
name|maxsegs
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): DMA mapping error! error = %d, "
literal|"nseg = %d, maxsegs = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|,
name|nseg
argument_list|,
name|map_arg
operator|->
name|maxsegs
argument_list|)
expr_stmt|;
name|map_arg
operator|->
name|maxsegs
operator|=
literal|0
expr_stmt|;
goto|goto
name|bce_dma_map_addr_exit
goto|;
block|}
name|map_arg
operator|->
name|busaddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
name|bce_dma_map_addr_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Map TX buffers into TX buffer descriptors.                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Given a series of DMA memory containting an outgoing frame, map the      */
end_comment

begin_comment
comment|/* segments into the tx_bd structure used by the hardware.                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_dma_map_tx_desc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bce_dmamap_arg
modifier|*
name|map_arg
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tx_bd
modifier|*
name|txbd
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u16
name|prod
decl_stmt|,
name|chain_prod
decl_stmt|;
name|u32
name|prod_bseq
decl_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|u16
name|debug_prod
decl_stmt|;
endif|#
directive|endif
name|map_arg
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|map_arg
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"%s(): Called with error = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Signal error to caller if there's too many segments */
if|if
condition|(
name|nseg
operator|>
name|map_arg
operator|->
name|maxsegs
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"%s(): Mapped TX descriptors: max segs = %d, "
literal|"actual segs = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|map_arg
operator|->
name|maxsegs
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|map_arg
operator|->
name|maxsegs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* prod points to an empty tx_bd at this point. */
name|prod
operator|=
name|map_arg
operator|->
name|prod
expr_stmt|;
name|chain_prod
operator|=
name|map_arg
operator|->
name|chain_prod
expr_stmt|;
name|prod_bseq
operator|=
name|map_arg
operator|->
name|prod_bseq
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|debug_prod
operator|=
name|chain_prod
expr_stmt|;
endif|#
directive|endif
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): Start: prod = 0x%04X, chain_prod = %04X, "
literal|"prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|prod
argument_list|,
name|chain_prod
argument_list|,
name|prod_bseq
argument_list|)
expr_stmt|;
comment|/* 	 * Cycle through each mbuf segment that makes up 	 * the outgoing frame, gathering the mapping info 	 * for that segment and creating a tx_bd to for 	 * the mbuf. 	 */
name|txbd
operator|=
operator|&
name|map_arg
operator|->
name|tx_chain
index|[
name|TX_PAGE
argument_list|(
name|chain_prod
argument_list|)
index|]
index|[
name|TX_IDX
argument_list|(
name|chain_prod
argument_list|)
index|]
expr_stmt|;
comment|/* Setup the first tx_bd for the first segment. */
name|txbd
operator|->
name|tx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_mss_nbytes
operator|=
name|htole16
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_vlan_tag_flags
operator|=
name|htole16
argument_list|(
name|map_arg
operator|->
name|tx_flags
operator||
name|TX_BD_FLAGS_START
argument_list|)
expr_stmt|;
name|prod_bseq
operator|+=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
comment|/* Setup any remaing segments. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|prod
operator|=
name|NEXT_TX_BD
argument_list|(
name|prod
argument_list|)
expr_stmt|;
name|chain_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|prod
argument_list|)
expr_stmt|;
name|txbd
operator|=
operator|&
name|map_arg
operator|->
name|tx_chain
index|[
name|TX_PAGE
argument_list|(
name|chain_prod
argument_list|)
index|]
index|[
name|TX_IDX
argument_list|(
name|chain_prod
argument_list|)
index|]
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_mss_nbytes
operator|=
name|htole16
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_vlan_tag_flags
operator|=
name|htole16
argument_list|(
name|map_arg
operator|->
name|tx_flags
argument_list|)
expr_stmt|;
name|prod_bseq
operator|+=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
comment|/* Set the END flag on the last TX buffer descriptor. */
name|txbd
operator|->
name|tx_bd_vlan_tag_flags
operator||=
name|htole16
argument_list|(
name|TX_BD_FLAGS_END
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|BCE_INFO_SEND
argument_list|,
name|bce_dump_tx_chain
argument_list|(
name|sc
argument_list|,
name|debug_prod
argument_list|,
name|nseg
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): End: prod = 0x%04X, chain_prod = %04X, "
literal|"prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|prod
argument_list|,
name|chain_prod
argument_list|,
name|prod_bseq
argument_list|)
expr_stmt|;
comment|/* prod points to the last tx_bd at this point. */
name|map_arg
operator|->
name|maxsegs
operator|=
name|nseg
expr_stmt|;
name|map_arg
operator|->
name|prod
operator|=
name|prod
expr_stmt|;
name|map_arg
operator|->
name|chain_prod
operator|=
name|chain_prod
expr_stmt|;
name|map_arg
operator|->
name|prod_bseq
operator|=
name|prod_bseq
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allocate any DMA memory needed by the driver.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Allocates DMA memory needed for the various global structures needed by  */
end_comment

begin_comment
comment|/* hardware.                                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_dma_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|bce_dmamap_arg
name|map_arg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the parent bus DMA tag appropriate for PCI. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent     */
name|BCE_DMA_ALIGN
argument_list|,
comment|/* alignment  */
name|BCE_DMA_BOUNDARY
argument_list|,
comment|/* boundary   */
name|sc
operator|->
name|max_bus_addr
argument_list|,
comment|/* lowaddr    */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr   */
name|NULL
argument_list|,
comment|/* filterfunc */
name|NULL
argument_list|,
comment|/* filterarg  */
name|MAXBSIZE
argument_list|,
comment|/* maxsize    */
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* nsegments  */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags      */
name|NULL
argument_list|,
comment|/* locfunc    */
name|NULL
argument_list|,
comment|/* lockarg    */
operator|&
name|sc
operator|->
name|parent_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate parent DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
comment|/* 	 * Create a DMA tag for the status block, allocate and clear the 	 * memory, map the memory into DMA space, and fetch the physical  	 * address of the block. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent      */
name|BCE_DMA_ALIGN
argument_list|,
comment|/* alignment   */
name|BCE_DMA_BOUNDARY
argument_list|,
comment|/* boundary    */
name|sc
operator|->
name|max_bus_addr
argument_list|,
comment|/* lowaddr     */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr    */
name|NULL
argument_list|,
comment|/* filterfunc  */
name|NULL
argument_list|,
comment|/* filterarg   */
name|BCE_STATUS_BLK_SZ
argument_list|,
comment|/* maxsize     */
literal|1
argument_list|,
comment|/* nsegments   */
name|BCE_STATUS_BLK_SZ
argument_list|,
comment|/* maxsegsize  */
literal|0
argument_list|,
comment|/* flags       */
name|NULL
argument_list|,
comment|/* lockfunc    */
name|NULL
argument_list|,
comment|/* lockarg     */
operator|&
name|sc
operator|->
name|status_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate status block DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
comment|/* dmat        */
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|status_block
argument_list|,
comment|/* vaddr       */
name|BUS_DMA_NOWAIT
argument_list|,
comment|/* flags       */
operator|&
name|sc
operator|->
name|status_map
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate status block DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|status_block
argument_list|,
name|BCE_STATUS_BLK_SZ
argument_list|)
expr_stmt|;
name|map_arg
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|map_arg
operator|.
name|maxsegs
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
comment|/* dmat        */
name|sc
operator|->
name|status_map
argument_list|,
comment|/* map         */
name|sc
operator|->
name|status_block
argument_list|,
comment|/* buf         */
name|BCE_STATUS_BLK_SZ
argument_list|,
comment|/* buflen      */
name|bce_dma_map_addr
argument_list|,
comment|/* callback    */
operator|&
name|map_arg
argument_list|,
comment|/* callbackarg */
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* flags       */
if|if
condition|(
name|error
operator|||
operator|(
name|map_arg
operator|.
name|maxsegs
operator|==
literal|0
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not map status block DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|sc
operator|->
name|status_block_paddr
operator|=
name|map_arg
operator|.
name|busaddr
expr_stmt|;
comment|/* DRC - Fix for 64 bit addresses. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"status_block_paddr = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|sc
operator|->
name|status_block_paddr
argument_list|)
expr_stmt|;
comment|/* 	 * Create a DMA tag for the statistics block, allocate and clear the 	 * memory, map the memory into DMA space, and fetch the physical  	 * address of the block. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent      */
name|BCE_DMA_ALIGN
argument_list|,
comment|/* alignment   */
name|BCE_DMA_BOUNDARY
argument_list|,
comment|/* boundary    */
name|sc
operator|->
name|max_bus_addr
argument_list|,
comment|/* lowaddr     */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr    */
name|NULL
argument_list|,
comment|/* filterfunc  */
name|NULL
argument_list|,
comment|/* filterarg   */
name|BCE_STATS_BLK_SZ
argument_list|,
comment|/* maxsize     */
literal|1
argument_list|,
comment|/* nsegments   */
name|BCE_STATS_BLK_SZ
argument_list|,
comment|/* maxsegsize  */
literal|0
argument_list|,
comment|/* flags       */
name|NULL
argument_list|,
comment|/* lockfunc    */
name|NULL
argument_list|,
comment|/* lockarg     */
operator|&
name|sc
operator|->
name|stats_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate statistics block DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
comment|/* dmat        */
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|stats_block
argument_list|,
comment|/* vaddr       */
name|BUS_DMA_NOWAIT
argument_list|,
comment|/* flags       */
operator|&
name|sc
operator|->
name|stats_map
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate statistics block DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|stats_block
argument_list|,
name|BCE_STATS_BLK_SZ
argument_list|)
expr_stmt|;
name|map_arg
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|map_arg
operator|.
name|maxsegs
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|stats_tag
argument_list|,
comment|/* dmat        */
name|sc
operator|->
name|stats_map
argument_list|,
comment|/* map         */
name|sc
operator|->
name|stats_block
argument_list|,
comment|/* buf         */
name|BCE_STATS_BLK_SZ
argument_list|,
comment|/* buflen      */
name|bce_dma_map_addr
argument_list|,
comment|/* callback    */
operator|&
name|map_arg
argument_list|,
comment|/* callbackarg */
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* flags       */
if|if
condition|(
name|error
operator|||
operator|(
name|map_arg
operator|.
name|maxsegs
operator|==
literal|0
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not map statistics block DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|sc
operator|->
name|stats_block_paddr
operator|=
name|map_arg
operator|.
name|busaddr
expr_stmt|;
comment|/* DRC - Fix for 64 bit address. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"stats_block_paddr = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|sc
operator|->
name|stats_block_paddr
argument_list|)
expr_stmt|;
comment|/* 	 * Create a DMA tag for the TX buffer descriptor chain, 	 * allocate and clear the  memory, and fetch the 	 * physical address of the block. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent      */
name|BCM_PAGE_SIZE
argument_list|,
comment|/* alignment   */
name|BCE_DMA_BOUNDARY
argument_list|,
comment|/* boundary    */
name|sc
operator|->
name|max_bus_addr
argument_list|,
comment|/* lowaddr     */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr    */
name|NULL
argument_list|,
comment|/* filterfunc  */
name|NULL
argument_list|,
comment|/* filterarg   */
name|BCE_TX_CHAIN_PAGE_SZ
argument_list|,
comment|/* maxsize     */
literal|1
argument_list|,
comment|/* nsegments   */
name|BCE_TX_CHAIN_PAGE_SZ
argument_list|,
comment|/* maxsegsize  */
literal|0
argument_list|,
comment|/* flags       */
name|NULL
argument_list|,
comment|/* lockfunc    */
name|NULL
argument_list|,
comment|/* lockarg     */
operator|&
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate TX descriptor chain DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
comment|/* tag   */
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
argument_list|,
comment|/* vaddr */
name|BUS_DMA_NOWAIT
argument_list|,
comment|/* flags */
operator|&
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate TX descriptor "
literal|"chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|map_arg
operator|.
name|maxsegs
operator|=
literal|1
expr_stmt|;
name|map_arg
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|tx_bd_chain_tag
argument_list|,
comment|/* dmat        */
name|sc
operator|->
name|tx_bd_chain_map
index|[
name|i
index|]
argument_list|,
comment|/* map         */
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
argument_list|,
comment|/* buf         */
name|BCE_TX_CHAIN_PAGE_SZ
argument_list|,
comment|/* buflen      */
name|bce_dma_map_addr
argument_list|,
comment|/* callback    */
operator|&
name|map_arg
argument_list|,
comment|/* callbackarg */
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* flags       */
if|if
condition|(
name|error
operator|||
operator|(
name|map_arg
operator|.
name|maxsegs
operator|==
literal|0
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not map TX descriptor chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
name|i
index|]
operator|=
name|map_arg
operator|.
name|busaddr
expr_stmt|;
comment|/* DRC - Fix for 64 bit systems. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"tx_bd_chain_paddr[%d] = 0x%08X\n"
argument_list|,
name|i
argument_list|,
operator|(
name|u32
operator|)
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Create a DMA tag for TX mbufs. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent      */
name|BCE_DMA_ALIGN
argument_list|,
comment|/* alignment   */
name|BCE_DMA_BOUNDARY
argument_list|,
comment|/* boundary    */
name|sc
operator|->
name|max_bus_addr
argument_list|,
comment|/* lowaddr     */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr    */
name|NULL
argument_list|,
comment|/* filterfunc  */
name|NULL
argument_list|,
comment|/* filterarg   */
name|MCLBYTES
operator|*
name|BCE_MAX_SEGMENTS
argument_list|,
comment|/* maxsize     */
name|BCE_MAX_SEGMENTS
argument_list|,
comment|/* nsegments   */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize  */
literal|0
argument_list|,
comment|/* flags       */
name|NULL
argument_list|,
comment|/* lockfunc    */
name|NULL
argument_list|,
comment|/* lockarg     */
operator|&
name|sc
operator|->
name|tx_mbuf_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate TX mbuf DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
comment|/* Create DMA maps for the TX mbufs clusters. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_TX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Unable to create TX mbuf DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
block|}
comment|/* 	 * Create a DMA tag for the RX buffer descriptor chain, 	 * allocate and clear the  memory, and fetch the physical 	 * address of the blocks. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent      */
name|BCM_PAGE_SIZE
argument_list|,
comment|/* alignment   */
name|BCE_DMA_BOUNDARY
argument_list|,
comment|/* boundary    */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr     */
name|sc
operator|->
name|max_bus_addr
argument_list|,
comment|/* lowaddr     */
name|NULL
argument_list|,
comment|/* filter      */
name|NULL
argument_list|,
comment|/* filterarg   */
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|,
comment|/* maxsize     */
literal|1
argument_list|,
comment|/* nsegments   */
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|,
comment|/* maxsegsize  */
literal|0
argument_list|,
comment|/* flags       */
name|NULL
argument_list|,
comment|/* lockfunc    */
name|NULL
argument_list|,
comment|/* lockarg     */
operator|&
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate RX descriptor chain DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
comment|/* tag   */
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
comment|/* vaddr */
name|BUS_DMA_NOWAIT
argument_list|,
comment|/* flags */
operator|&
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate RX descriptor chain "
literal|"DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|)
expr_stmt|;
name|map_arg
operator|.
name|maxsegs
operator|=
literal|1
expr_stmt|;
name|map_arg
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
comment|/* dmat        */
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|,
comment|/* map         */
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
comment|/* buf         */
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|,
comment|/* buflen      */
name|bce_dma_map_addr
argument_list|,
comment|/* callback    */
operator|&
name|map_arg
argument_list|,
comment|/* callbackarg */
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* flags       */
if|if
condition|(
name|error
operator|||
operator|(
name|map_arg
operator|.
name|maxsegs
operator|==
literal|0
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not map RX descriptor chain DMA memory!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
name|i
index|]
operator|=
name|map_arg
operator|.
name|busaddr
expr_stmt|;
comment|/* DRC - Fix for 64 bit systems. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"rx_bd_chain_paddr[%d] = 0x%08X\n"
argument_list|,
name|i
argument_list|,
operator|(
name|u32
operator|)
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create a DMA tag for RX mbufs. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent      */
name|BCE_DMA_ALIGN
argument_list|,
comment|/* alignment   */
name|BCE_DMA_BOUNDARY
argument_list|,
comment|/* boundary    */
name|sc
operator|->
name|max_bus_addr
argument_list|,
comment|/* lowaddr     */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr    */
name|NULL
argument_list|,
comment|/* filterfunc  */
name|NULL
argument_list|,
comment|/* filterarg   */
name|MJUM9BYTES
argument_list|,
comment|/* maxsize     */
name|BCE_MAX_SEGMENTS
argument_list|,
comment|/* nsegments   */
name|MJUM9BYTES
argument_list|,
comment|/* maxsegsize  */
literal|0
argument_list|,
comment|/* flags       */
name|NULL
argument_list|,
comment|/* lockfunc    */
name|NULL
argument_list|,
comment|/* lockarg     */
operator|&
name|sc
operator|->
name|rx_mbuf_tag
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Could not allocate RX mbuf DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
comment|/* Create DMA maps for the RX mbuf clusters. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_RX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Unable to create RX mbuf DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bce_dma_alloc_exit
goto|;
block|}
block|}
name|bce_dma_alloc_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Release all resources used by the driver.                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Releases all resources acquired by the driver including interrupts,      */
end_comment

begin_comment
comment|/* interrupt handler, interfaces, mutexes, and DMA memory.                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_release_resources
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|bce_dev
expr_stmt|;
name|bce_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_intrhand
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bce_irq
argument_list|,
name|sc
operator|->
name|bce_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|bce_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|bce_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|bce_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|bce_mtx
argument_list|)
condition|)
name|BCE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Firmware synchronization.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Before performing certain events such as a chip reset, synchronize with  */
end_comment

begin_comment
comment|/* the firmware first.                                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_fw_sync
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|msg_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* Don't waste any time if we've timed out before. */
if|if
condition|(
name|sc
operator|->
name|bce_fw_timed_out
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bce_fw_sync_exit
goto|;
block|}
comment|/* Increment the message sequence number. */
name|sc
operator|->
name|bce_fw_wr_seq
operator|++
expr_stmt|;
name|msg_data
operator||=
name|sc
operator|->
name|bce_fw_wr_seq
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"bce_fw_sync(): msg_data = 0x%08X\n"
argument_list|,
name|msg_data
argument_list|)
expr_stmt|;
comment|/* Send the message to the bootcode driver mailbox. */
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_DRV_MB
argument_list|,
name|msg_data
argument_list|)
expr_stmt|;
comment|/* Wait for the bootcode to acknowledge the message. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FW_ACK_TIME_OUT_MS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check for a response in the bootcode firmware mailbox. */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_FW_MB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BCE_FW_MSG_ACK
operator|)
operator|==
operator|(
name|msg_data
operator|&
name|BCE_DRV_MSG_SEQ
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* If we've timed out, tell the bootcode that we've stopped waiting. */
if|if
condition|(
operator|(
operator|(
name|val
operator|&
name|BCE_FW_MSG_ACK
operator|)
operator|!=
operator|(
name|msg_data
operator|&
name|BCE_DRV_MSG_SEQ
operator|)
operator|)
operator|&&
operator|(
operator|(
name|msg_data
operator|&
name|BCE_DRV_MSG_DATA
operator|)
operator|!=
name|BCE_DRV_MSG_DATA_WAIT0
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Firmware synchronization timeout! "
literal|"msg_data = 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|msg_data
argument_list|)
expr_stmt|;
name|msg_data
operator|&=
operator|~
name|BCE_DRV_MSG_CODE
expr_stmt|;
name|msg_data
operator||=
name|BCE_DRV_MSG_CODE_FW_TIMEOUT
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_DRV_MB
argument_list|,
name|msg_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_fw_timed_out
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|bce_fw_sync_exit
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Load Receive Virtual 2 Physical (RV2P) processor firmware.               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_load_rv2p_fw
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
modifier|*
name|rv2p_code
parameter_list|,
name|u32
name|rv2p_code_len
parameter_list|,
name|u32
name|rv2p_proc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rv2p_code_len
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_INSTR_HIGH
argument_list|,
operator|*
name|rv2p_code
argument_list|)
expr_stmt|;
name|rv2p_code
operator|++
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_INSTR_LOW
argument_list|,
operator|*
name|rv2p_code
argument_list|)
expr_stmt|;
name|rv2p_code
operator|++
expr_stmt|;
if|if
condition|(
name|rv2p_proc
operator|==
name|RV2P_PROC1
condition|)
block|{
name|val
operator|=
operator|(
name|i
operator|/
literal|8
operator|)
operator||
name|BCE_RV2P_PROC1_ADDR_CMD_RDWR
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_PROC1_ADDR_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
name|i
operator|/
literal|8
operator|)
operator||
name|BCE_RV2P_PROC2_ADDR_CMD_RDWR
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_PROC2_ADDR_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset the processor, un-stall is done later. */
if|if
condition|(
name|rv2p_proc
operator|==
name|RV2P_PROC1
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_COMMAND
argument_list|,
name|BCE_RV2P_COMMAND_PROC1_RESET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_COMMAND
argument_list|,
name|BCE_RV2P_COMMAND_PROC2_RESET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Load RISC processor firmware.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Loads firmware from the file if_bcefw.h into the scratchpad memory       */
end_comment

begin_comment
comment|/* associated with a particular processor.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_load_cpu_fw
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cpu_reg
modifier|*
name|cpu_reg
parameter_list|,
name|struct
name|fw_info
modifier|*
name|fw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|u32
name|val
decl_stmt|;
comment|/* Halt the CPU. */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|mode
argument_list|)
expr_stmt|;
name|val
operator||=
name|cpu_reg
operator|->
name|mode_value_halt
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|state
argument_list|,
name|cpu_reg
operator|->
name|state_value_clear
argument_list|)
expr_stmt|;
comment|/* Load the Text area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|text_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|text
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|text_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|text
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load the Data area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|data_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|data
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|data_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load the SBSS area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|sbss_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|sbss
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|sbss_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|sbss
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load the BSS area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|bss_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|bss
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|bss_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|bss
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load the Read-Only area. */
name|offset
operator|=
name|cpu_reg
operator|->
name|spad_base
operator|+
operator|(
name|fw
operator|->
name|rodata_addr
operator|-
name|cpu_reg
operator|->
name|mips_view_base
operator|)
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|rodata
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|fw
operator|->
name|rodata_len
operator|/
literal|4
operator|)
condition|;
name|j
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|fw
operator|->
name|rodata
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear the pre-fetch instruction. */
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|inst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|pc
argument_list|,
name|fw
operator|->
name|start_addr
argument_list|)
expr_stmt|;
comment|/* Start the CPU. */
name|val
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|mode
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|cpu_reg
operator|->
name|mode_value_halt
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|state
argument_list|,
name|cpu_reg
operator|->
name|state_value_clear
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|cpu_reg
operator|->
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the RV2P, RX, TX, TPAT, and COM CPUs.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Loads the firmware for each CPU and starts the CPU.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_cpus
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cpu_reg
name|cpu_reg
decl_stmt|;
name|struct
name|fw_info
name|fw
decl_stmt|;
comment|/* Initialize the RV2P processor. */
name|bce_load_rv2p_fw
argument_list|(
name|sc
argument_list|,
name|bce_rv2p_proc1
argument_list|,
sizeof|sizeof
argument_list|(
name|bce_rv2p_proc1
argument_list|)
argument_list|,
name|RV2P_PROC1
argument_list|)
expr_stmt|;
name|bce_load_rv2p_fw
argument_list|(
name|sc
argument_list|,
name|bce_rv2p_proc2
argument_list|,
sizeof|sizeof
argument_list|(
name|bce_rv2p_proc2
argument_list|)
argument_list|,
name|RV2P_PROC2
argument_list|)
expr_stmt|;
comment|/* Initialize the RX Processor. */
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_RXP_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_RXP_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_RXP_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_RXP_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_RXP_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_RXP_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_RXP_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_RXP_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_RXP_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_RXP_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
name|fw
operator|.
name|ver_major
operator|=
name|bce_RXP_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_RXP_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_RXP_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_RXP_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_RXP_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_RXP_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_RXP_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_RXP_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_RXP_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_RXP_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_RXP_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_RXP_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_RXP_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_RXP_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_RXP_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_RXP_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_RXP_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_RXP_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_RXP_b06FwRodata
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading RX firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
comment|/* Initialize the TX Processor. */
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_TXP_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_TXP_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_TXP_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_TXP_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_TXP_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_TXP_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_TXP_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_TXP_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_TXP_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_TXP_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
name|fw
operator|.
name|ver_major
operator|=
name|bce_TXP_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_TXP_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_TXP_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_TXP_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_TXP_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_TXP_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_TXP_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_TXP_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_TXP_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_TXP_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_TXP_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_TXP_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_TXP_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_TXP_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_TXP_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_TXP_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_TXP_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_TXP_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_TXP_b06FwRodata
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading TX firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
comment|/* Initialize the TX Patch-up Processor. */
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_TPAT_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_TPAT_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_TPAT_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_TPAT_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_TPAT_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_TPAT_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_TPAT_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_TPAT_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_TPAT_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_TPAT_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
name|fw
operator|.
name|ver_major
operator|=
name|bce_TPAT_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_TPAT_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_TPAT_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_TPAT_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_TPAT_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_TPAT_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_TPAT_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_TPAT_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_TPAT_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_TPAT_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_TPAT_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_TPAT_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_TPAT_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_TPAT_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_TPAT_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_TPAT_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_TPAT_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_TPAT_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_TPAT_b06FwRodata
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading TPAT firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
comment|/* Initialize the Completion Processor. */
name|cpu_reg
operator|.
name|mode
operator|=
name|BCE_COM_CPU_MODE
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_halt
operator|=
name|BCE_COM_CPU_MODE_SOFT_HALT
expr_stmt|;
name|cpu_reg
operator|.
name|mode_value_sstep
operator|=
name|BCE_COM_CPU_MODE_STEP_ENA
expr_stmt|;
name|cpu_reg
operator|.
name|state
operator|=
name|BCE_COM_CPU_STATE
expr_stmt|;
name|cpu_reg
operator|.
name|state_value_clear
operator|=
literal|0xffffff
expr_stmt|;
name|cpu_reg
operator|.
name|gpr0
operator|=
name|BCE_COM_CPU_REG_FILE
expr_stmt|;
name|cpu_reg
operator|.
name|evmask
operator|=
name|BCE_COM_CPU_EVENT_MASK
expr_stmt|;
name|cpu_reg
operator|.
name|pc
operator|=
name|BCE_COM_CPU_PROGRAM_COUNTER
expr_stmt|;
name|cpu_reg
operator|.
name|inst
operator|=
name|BCE_COM_CPU_INSTRUCTION
expr_stmt|;
name|cpu_reg
operator|.
name|bp
operator|=
name|BCE_COM_CPU_HW_BREAKPOINT
expr_stmt|;
name|cpu_reg
operator|.
name|spad_base
operator|=
name|BCE_COM_SCRATCH
expr_stmt|;
name|cpu_reg
operator|.
name|mips_view_base
operator|=
literal|0x8000000
expr_stmt|;
name|fw
operator|.
name|ver_major
operator|=
name|bce_COM_b06FwReleaseMajor
expr_stmt|;
name|fw
operator|.
name|ver_minor
operator|=
name|bce_COM_b06FwReleaseMinor
expr_stmt|;
name|fw
operator|.
name|ver_fix
operator|=
name|bce_COM_b06FwReleaseFix
expr_stmt|;
name|fw
operator|.
name|start_addr
operator|=
name|bce_COM_b06FwStartAddr
expr_stmt|;
name|fw
operator|.
name|text_addr
operator|=
name|bce_COM_b06FwTextAddr
expr_stmt|;
name|fw
operator|.
name|text_len
operator|=
name|bce_COM_b06FwTextLen
expr_stmt|;
name|fw
operator|.
name|text_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|text
operator|=
name|bce_COM_b06FwText
expr_stmt|;
name|fw
operator|.
name|data_addr
operator|=
name|bce_COM_b06FwDataAddr
expr_stmt|;
name|fw
operator|.
name|data_len
operator|=
name|bce_COM_b06FwDataLen
expr_stmt|;
name|fw
operator|.
name|data_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|data
operator|=
name|bce_COM_b06FwData
expr_stmt|;
name|fw
operator|.
name|sbss_addr
operator|=
name|bce_COM_b06FwSbssAddr
expr_stmt|;
name|fw
operator|.
name|sbss_len
operator|=
name|bce_COM_b06FwSbssLen
expr_stmt|;
name|fw
operator|.
name|sbss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|sbss
operator|=
name|bce_COM_b06FwSbss
expr_stmt|;
name|fw
operator|.
name|bss_addr
operator|=
name|bce_COM_b06FwBssAddr
expr_stmt|;
name|fw
operator|.
name|bss_len
operator|=
name|bce_COM_b06FwBssLen
expr_stmt|;
name|fw
operator|.
name|bss_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|bss
operator|=
name|bce_COM_b06FwBss
expr_stmt|;
name|fw
operator|.
name|rodata_addr
operator|=
name|bce_COM_b06FwRodataAddr
expr_stmt|;
name|fw
operator|.
name|rodata_len
operator|=
name|bce_COM_b06FwRodataLen
expr_stmt|;
name|fw
operator|.
name|rodata_index
operator|=
literal|0
expr_stmt|;
name|fw
operator|.
name|rodata
operator|=
name|bce_COM_b06FwRodata
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RESET
argument_list|,
literal|"Loading COM firmware.\n"
argument_list|)
expr_stmt|;
name|bce_load_cpu_fw
argument_list|(
name|sc
argument_list|,
operator|&
name|cpu_reg
argument_list|,
operator|&
name|fw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize context memory.                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Clears the memory associated with each Context ID (CID).                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_context
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|vcid
decl_stmt|;
name|vcid
operator|=
literal|96
expr_stmt|;
while|while
condition|(
name|vcid
condition|)
block|{
name|u32
name|vcid_addr
decl_stmt|,
name|pcid_addr
decl_stmt|,
name|offset
decl_stmt|;
name|vcid
operator|--
expr_stmt|;
name|vcid_addr
operator|=
name|GET_CID_ADDR
argument_list|(
name|vcid
argument_list|)
expr_stmt|;
name|pcid_addr
operator|=
name|vcid_addr
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_VIRT_ADDR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_PAGE_TBL
argument_list|,
name|pcid_addr
argument_list|)
expr_stmt|;
comment|/* Zero out the context. */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|PHY_CTX_SIZE
condition|;
name|offset
operator|+=
literal|4
control|)
block|{
name|CTX_WR
argument_list|(
name|sc
argument_list|,
literal|0x00
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_VIRT_ADDR
argument_list|,
name|vcid_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_PAGE_TBL
argument_list|,
name|pcid_addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Fetch the permanent MAC address of the controller.                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_get_mac_addr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|mac_lo
init|=
literal|0
decl_stmt|,
name|mac_hi
init|=
literal|0
decl_stmt|;
comment|/* 	 * The NetXtreme II bootcode populates various NIC 	 * power-on and runtime configuration items in a 	 * shared memory area.  The factory configured MAC 	 * address is available from both NVRAM and the 	 * shared memory area so we'll read the value from 	 * shared memory for speed. 	 */
name|mac_hi
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_PORT_HW_CFG_MAC_UPPER
argument_list|)
expr_stmt|;
name|mac_lo
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_PORT_HW_CFG_MAC_LOWER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mac_lo
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mac_hi
operator|==
literal|0
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Invalid Ethernet address!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|eaddr
index|[
literal|0
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_hi
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|1
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_hi
operator|>>
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|2
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|3
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|4
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eaddr
index|[
literal|5
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|0
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Permanent Ethernet address = %6D\n"
argument_list|,
name|sc
operator|->
name|eaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Program the MAC address.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_set_mac_addr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|u8
modifier|*
name|mac_addr
init|=
name|sc
operator|->
name|eaddr
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Setting Ethernet address = %6D\n"
argument_list|,
name|sc
operator|->
name|eaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|mac_addr
index|[
literal|1
index|]
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MAC_MATCH0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|mac_addr
index|[
literal|5
index|]
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MAC_MATCH1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Stop the controller.                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_stop
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|ifm
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|NULL
decl_stmt|;
name|int
name|mtmp
decl_stmt|,
name|itmp
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|bce_stat_ch
argument_list|)
expr_stmt|;
comment|/* Disable the transmit/receive blocks. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS
argument_list|,
literal|0x5ffffff
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|bce_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Tell firmware that the driver is going away. */
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_CODE_SUSPEND_NO_WOL
argument_list|)
expr_stmt|;
comment|/* Free the RX lists. */
name|bce_free_rx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free TX buffers. */
name|bce_free_tx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Isolate/power down the PHY, but leave the media selection 	 * unchanged so that things will be put back to normal when 	 * we bring the interface back up. 	 */
name|itmp
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
comment|/* 	 * If we are called from bce_detach(), mii is already NULL. 	 */
if|if
condition|(
name|mii
operator|!=
name|NULL
condition|)
block|{
name|ifm
operator|=
name|mii
operator|->
name|mii_media
operator|.
name|ifm_cur
expr_stmt|;
name|mtmp
operator|=
name|ifm
operator|->
name|ifm_media
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_NONE
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|mtmp
expr_stmt|;
block|}
name|ifp
operator|->
name|if_flags
operator|=
name|itmp
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bce_link
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|bce_mgmt_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bce_reset
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|reset_code
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Wait for pending PCI transactions to complete. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS_TX_DMA_ENABLE
operator||
name|BCE_MISC_ENABLE_CLR_BITS_DMA_ENGINE_ENABLE
operator||
name|BCE_MISC_ENABLE_CLR_BITS_RX_DMA_ENABLE
operator||
name|BCE_MISC_ENABLE_CLR_BITS_HOST_COALESCE_ENABLE
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_CLR_BITS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Assume bootcode is running. */
name|sc
operator|->
name|bce_fw_timed_out
operator|=
literal|0
expr_stmt|;
comment|/* Give the firmware a chance to prepare for the reset. */
name|rc
operator|=
name|bce_fw_sync
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_DATA_WAIT0
operator||
name|reset_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bce_reset_exit
goto|;
comment|/* Set a firmware reminder that this is a soft reset. */
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_DRV_RESET_SIGNATURE
argument_list|,
name|BCE_DRV_RESET_SIGNATURE_MAGIC
argument_list|)
expr_stmt|;
comment|/* Dummy read to force the chip to complete all current transactions. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ID
argument_list|)
expr_stmt|;
comment|/* Chip reset. */
name|val
operator|=
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_REQ
operator||
name|BCE_PCICFG_MISC_CONFIG_REG_WINDOW_ENA
operator||
name|BCE_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_MISC_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Allow up to 30us for reset to complete. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_MISC_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_REQ
operator||
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_BSY
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Check that reset completed successfully. */
if|if
condition|(
name|val
operator|&
operator|(
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_REQ
operator||
name|BCE_PCICFG_MISC_CONFIG_CORE_RST_BSY
operator|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Reset failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bce_reset_exit
goto|;
block|}
comment|/* Make sure byte swapping is properly configured. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCI_SWAP_DIAG0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0x01020304
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Byte swap is incorrect!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_reset_exit
goto|;
block|}
comment|/* Just completed a reset, assume that firmware is running again. */
name|sc
operator|->
name|bce_fw_timed_out
operator|=
literal|0
expr_stmt|;
comment|/* Wait for the firmware to finish its initialization. */
name|rc
operator|=
name|bce_fw_sync
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_DATA_WAIT1
operator||
name|reset_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Firmware did not complete initialization!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|bce_reset_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bce_chipinit
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Make sure the interrupt is not active. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_MASK_INT
argument_list|)
expr_stmt|;
comment|/* Initialize DMA byte/word swapping, configure the number of DMA  */
comment|/* channels and PCI clock compensation delay.                      */
name|val
operator|=
name|BCE_DMA_CONFIG_DATA_BYTE_SWAP
operator||
name|BCE_DMA_CONFIG_DATA_WORD_SWAP
operator||
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|BCE_DMA_CONFIG_CNTL_BYTE_SWAP
operator||
endif|#
directive|endif
name|BCE_DMA_CONFIG_CNTL_WORD_SWAP
operator||
name|DMA_READ_CHANS
operator|<<
literal|12
operator||
name|DMA_WRITE_CHANS
operator|<<
literal|16
expr_stmt|;
name|val
operator||=
operator|(
literal|0x2
operator|<<
literal|20
operator|)
operator||
name|BCE_DMA_CONFIG_CNTL_PCI_COMP_DLY
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCIX_FLAG
operator|)
operator|&&
operator|(
name|sc
operator|->
name|bus_speed_mhz
operator|==
literal|133
operator|)
condition|)
name|val
operator||=
name|BCE_DMA_CONFIG_PCI_FAST_CLK_CMP
expr_stmt|;
comment|/* 	 * This setting resolves a problem observed on certain Intel PCI 	 * chipsets that cannot handle multiple outstanding DMA operations. 	 * See errata E9_5706A1_65. 	 */
if|if
condition|(
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5706
operator|)
operator|&&
operator|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|!=
name|BCE_CHIP_ID_5706_A0
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCIX_FLAG
operator|)
condition|)
name|val
operator||=
name|BCE_DMA_CONFIG_CNTL_PING_PONG_DMA
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_DMA_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Clear the PCI-X relaxed ordering bit. See errata E3_5708CA0_570. */
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_PCIX_FLAG
condition|)
block|{
name|u16
name|val
decl_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|,
name|BCE_PCI_PCIX_CMD
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|,
name|BCE_PCI_PCIX_CMD
argument_list|,
name|val
operator|&
operator|~
literal|0x2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Enable the RX_V2P and Context state machines before access. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS_HOST_COALESCE_ENABLE
operator||
name|BCE_MISC_ENABLE_STATUS_BITS_RX_V2P_ENABLE
operator||
name|BCE_MISC_ENABLE_STATUS_BITS_CONTEXT_ENABLE
argument_list|)
expr_stmt|;
comment|/* Initialize context mapping and zero out the quick contexts. */
name|bce_init_context
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize the on-boards CPUs */
name|bce_init_cpus
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepare NVRAM for access. */
if|if
condition|(
name|bce_init_nvram
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_chipinit_exit
goto|;
block|}
comment|/* Set the kernel bypass block size */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|BCE_MQ_CONFIG_KNL_BYP_BLK_SIZE
expr_stmt|;
name|val
operator||=
name|BCE_MQ_CONFIG_KNL_BYP_BLK_SIZE_256
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x10000
operator|+
operator|(
name|MAX_CID_CNT
operator|*
name|MB_KERNEL_CTX_SIZE
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_KNL_BYP_WIND_START
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MQ_KNL_WIND_END
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|BCM_PAGE_BITS
operator|-
literal|8
operator|)
operator|<<
literal|24
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Configure page size. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TBDR_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|BCE_TBDR_CONFIG_PAGE_SIZE
expr_stmt|;
name|val
operator||=
operator|(
name|BCM_PAGE_BITS
operator|-
literal|8
operator|)
operator|<<
literal|24
operator||
literal|0x40
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_TBDR_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bce_chipinit_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Initialize the controller in preparation to send/receive traffic.        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_blockinit
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Load the hardware default MAC address. */
name|bce_set_mac_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set the Ethernet backoff seed value */
name|val
operator|=
name|sc
operator|->
name|eaddr
index|[
literal|0
index|]
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|3
index|]
operator|)
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|sc
operator|->
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_BACKOFF_SEED
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_status_idx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_mode
operator|=
name|BCE_EMAC_RX_MODE_SORT_MODE
expr_stmt|;
comment|/* Set up link change interrupt generation. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_ATTENTION_ENA
argument_list|,
name|BCE_EMAC_ATTENTION_ENA_LINK
argument_list|)
expr_stmt|;
comment|/* Program the physical address of the status block. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATUS_ADDR_L
argument_list|,
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|status_block_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATUS_ADDR_H
argument_list|,
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|status_block_paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Program the physical address of the statistics block. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATISTICS_ADDR_L
argument_list|,
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|stats_block_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATISTICS_ADDR_H
argument_list|,
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|stats_block_paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Program various host coalescing parameters. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_TX_QUICK_CONS_TRIP
argument_list|,
operator|(
name|sc
operator|->
name|bce_tx_quick_cons_trip_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_tx_quick_cons_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_RX_QUICK_CONS_TRIP
argument_list|,
operator|(
name|sc
operator|->
name|bce_rx_quick_cons_trip_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_rx_quick_cons_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMP_PROD_TRIP
argument_list|,
operator|(
name|sc
operator|->
name|bce_comp_prod_trip_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_comp_prod_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_TX_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_tx_ticks_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_tx_ticks
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_RX_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_rx_ticks_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_rx_ticks
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COM_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_com_ticks_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_com_ticks
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_CMD_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_cmd_ticks_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_cmd_ticks
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATS_TICKS
argument_list|,
operator|(
name|sc
operator|->
name|bce_stats_ticks
operator|&
literal|0xffff00
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STAT_COLLECT_TICKS
argument_list|,
literal|0xbb8
argument_list|)
expr_stmt|;
comment|/* 3ms */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_CONFIG
argument_list|,
operator|(
name|BCE_HC_CONFIG_RX_TMR_MODE
operator||
name|BCE_HC_CONFIG_TX_TMR_MODE
operator||
name|BCE_HC_CONFIG_COLLECT_STATS
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear the internal statistics counters. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|,
name|BCE_HC_COMMAND_CLR_STAT_NOW
argument_list|)
expr_stmt|;
comment|/* Verify that bootcode is running. */
name|reg
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_DEV_INFO_SIGNATURE
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(bce_debug_bootcode_running_failure)
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(%d): Simulating bootcode failure.\n"
argument|, 			__FILE__, __LINE__); 		reg =
literal|0
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|BCE_DEV_INFO_SIGNATURE_MAGIC_MASK
operator|)
operator|!=
name|BCE_DEV_INFO_SIGNATURE_MAGIC
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Bootcode not running! Found: 0x%08X, "
literal|"Expected: 08%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|reg
operator|&
name|BCE_DEV_INFO_SIGNATURE_MAGIC_MASK
operator|)
argument_list|,
name|BCE_DEV_INFO_SIGNATURE_MAGIC
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bce_blockinit_exit
goto|;
block|}
comment|/* Check if any management firmware is running. */
name|reg
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_PORT_FEATURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
operator|(
name|BCE_PORT_FEATURE_ASF_ENABLED
operator||
name|BCE_PORT_FEATURE_IMD_ENABLED
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Management F/W Enabled.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_flags
operator||=
name|BCE_MFW_ENABLE_FLAG
expr_stmt|;
block|}
name|sc
operator|->
name|bce_fw_ver
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_DEV_INFO_BC_REV
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"bootcode rev = 0x%08X\n"
argument_list|,
name|sc
operator|->
name|bce_fw_ver
argument_list|)
expr_stmt|;
comment|/* Allow bootcode to apply any additional fixes before enabling MAC. */
name|rc
operator|=
name|bce_fw_sync
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_DATA_WAIT2
operator||
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
expr_stmt|;
comment|/* Enable link state change interrupt generation. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_ATTN_BITS_ENABLE
argument_list|,
name|STATUS_ATTN_BITS_LINK_STATE
argument_list|)
expr_stmt|;
comment|/* Enable all remaining blocks in the MAC. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|,
literal|0x5ffffff
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|bce_blockinit_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Encapsulate an mbuf cluster into the rx_bd chain.                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* The NetXtreme II can support Jumbo frames by using multiple rx_bd's.     */
end_comment

begin_comment
comment|/* This routine will map an mbuf cluster into 1 or more rx_bd's as          */
end_comment

begin_comment
comment|/* necessary.                                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_get_buf
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u16
modifier|*
name|prod
parameter_list|,
name|u16
modifier|*
name|chain_prod
parameter_list|,
name|u32
modifier|*
name|prod_bseq
parameter_list|)
block|{
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
init|=
name|NULL
decl_stmt|;
name|struct
name|rx_bd
modifier|*
name|rxbd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|u16
name|debug_chain_prod
init|=
operator|*
name|chain_prod
decl_stmt|;
endif|#
directive|endif
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator|)
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Make sure the inputs are valid. */
name|DBRUNIF
argument_list|(
operator|(
operator|*
name|chain_prod
operator|>
name|MAX_RX_BD
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): RX producer out of range: 0x%04X> 0x%04X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|*
name|chain_prod
argument_list|,
operator|(
name|u16
operator|)
name|MAX_RX_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RECV
argument_list|,
literal|"%s(enter): prod = 0x%04X, chain_prod = 0x%04X, "
literal|"prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|prod
argument_list|,
operator|*
name|chain_prod
argument_list|,
operator|*
name|prod_bseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(bce_debug_mbuf_allocation_failure)
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(%d): Simulating mbuf allocation failure.\n"
argument|,  				__FILE__, __LINE__); 			sc->mbuf_alloc_failed++; 			rc = ENOBUFS; 			goto bce_get_buf_exit
argument_list|)
empty_stmt|;
comment|/* This is a new mbuf allocation. */
name|MGETHDR
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"%s(%d): RX mbuf header allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|mbuf_alloc_failed
operator|++
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_get_buf_exit
goto|;
block|}
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|rx_mbuf_alloc
operator|++
argument_list|)
expr_stmt|;
name|m_cljget
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|sc
operator|->
name|mbuf_alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m_new
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"%s(%d): RX mbuf chain allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|mbuf_alloc_failed
operator|++
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_get_buf_exit
goto|;
block|}
name|m_new
operator|->
name|m_len
operator|=
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|sc
operator|->
name|mbuf_alloc_size
expr_stmt|;
block|}
else|else
block|{
name|m_new
operator|=
name|m
expr_stmt|;
name|m_new
operator|->
name|m_len
operator|=
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|sc
operator|->
name|mbuf_alloc_size
expr_stmt|;
name|m_new
operator|->
name|m_data
operator|=
name|m_new
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
comment|/* Map the mbuf cluster into device memory. */
name|map
operator|=
name|sc
operator|->
name|rx_mbuf_map
index|[
operator|*
name|chain_prod
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|map
argument_list|,
name|m_new
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Error mapping mbuf into RX chain!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_get_buf_exit
goto|;
block|}
comment|/* Watch for overflow. */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_rx_bd
operator|>
name|USABLE_RX_BD
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Too many free rx_bd (0x%04X> 0x%04X)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|free_rx_bd
argument_list|,
operator|(
name|u16
operator|)
name|USABLE_RX_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_rx_bd
operator|<
name|sc
operator|->
name|rx_low_watermark
operator|)
argument_list|,
name|sc
operator|->
name|rx_low_watermark
operator|=
name|sc
operator|->
name|free_rx_bd
argument_list|)
expr_stmt|;
comment|/* Setup the rx_bd for the first segment. */
name|rxbd
operator|=
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|RX_PAGE
argument_list|(
operator|*
name|chain_prod
argument_list|)
index|]
index|[
name|RX_IDX
argument_list|(
operator|*
name|chain_prod
argument_list|)
index|]
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_len
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_flags
operator|=
name|htole32
argument_list|(
name|RX_BD_FLAGS_START
argument_list|)
expr_stmt|;
operator|*
name|prod_bseq
operator|+=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|prod
operator|=
name|NEXT_RX_BD
argument_list|(
operator|*
name|prod
argument_list|)
expr_stmt|;
operator|*
name|chain_prod
operator|=
name|RX_CHAIN_IDX
argument_list|(
operator|*
name|prod
argument_list|)
expr_stmt|;
name|rxbd
operator|=
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|RX_PAGE
argument_list|(
operator|*
name|chain_prod
argument_list|)
index|]
index|[
name|RX_IDX
argument_list|(
operator|*
name|chain_prod
argument_list|)
index|]
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_len
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_flags
operator|=
literal|0
expr_stmt|;
operator|*
name|prod_bseq
operator|+=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
name|rxbd
operator|->
name|rx_bd_flags
operator||=
name|htole32
argument_list|(
name|RX_BD_FLAGS_END
argument_list|)
expr_stmt|;
comment|/* Save the mbuf and update our counter. */
name|sc
operator|->
name|rx_mbuf_ptr
index|[
operator|*
name|chain_prod
index|]
operator|=
name|m_new
expr_stmt|;
name|sc
operator|->
name|free_rx_bd
operator|-=
name|nsegs
expr_stmt|;
name|DBRUN
argument_list|(
name|BCE_VERBOSE_RECV
argument_list|,
name|bce_dump_rx_mbuf_chain
argument_list|(
name|sc
argument_list|,
name|debug_chain_prod
argument_list|,
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RECV
argument_list|,
literal|"%s(exit): prod = 0x%04X, chain_prod = 0x%04X, "
literal|"prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|prod
argument_list|,
operator|*
name|chain_prod
argument_list|,
operator|*
name|prod_bseq
argument_list|)
expr_stmt|;
name|bce_get_buf_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BCE_VERBOSE_RESET
operator||
name|BCE_VERBOSE_RECV
operator|)
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allocate memory and initialize the TX data structures.                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_init_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tx_bd
modifier|*
name|txbd
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Set the initial TX producer/consumer indices. */
name|sc
operator|->
name|tx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx_prod_bseq
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|used_tx_bd
operator|=
literal|0
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|tx_hi_watermark
operator|=
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
comment|/* 	 * The NetXtreme II supports a linked-list structre called 	 * a Buffer Descriptor Chain (or BD chain).  A BD chain 	 * consists of a series of 1 or more chain pages, each of which 	 * consists of a fixed number of BD entries. 	 * The last BD entry on each page is a pointer to the next page 	 * in the chain, and the last pointer in the BD chain 	 * points back to the beginning of the chain. 	 */
comment|/* Set the TX next pointer chain entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|txbd
operator|=
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
index|[
name|USABLE_TX_BD_PER_PAGE
index|]
expr_stmt|;
comment|/* Check if we've reached the last page. */
if|if
condition|(
name|i
operator|==
operator|(
name|TX_PAGES
operator|-
literal|1
operator|)
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|txbd
operator|->
name|tx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the context ID for an L2 TX chain. 	 */
name|val
operator|=
name|BCE_L2CTX_TYPE_TYPE_L2
expr_stmt|;
name|val
operator||=
name|BCE_L2CTX_TYPE_SIZE_L2
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TYPE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_L2CTX_CMD_TYPE_TYPE_L2
operator||
operator|(
literal|8
operator|<<
literal|16
operator|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_CMD_TYPE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Point the hardware to the first page in the chain. */
name|val
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TBDR_BHADDR_HI
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|TX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_TBDR_BHADDR_LO
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|BCE_VERBOSE_SEND
argument_list|,
name|bce_dump_tx_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TOTAL_TX_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Free memory and clear the TX data structures.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_free_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Unmap, unload, and free any mbufs still in the TX mbuf chain. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_TX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_map
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|sc
operator|->
name|tx_mbuf_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|tx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear each TX chain page. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_TX_CHAIN_PAGE_SZ
argument_list|)
expr_stmt|;
comment|/* Check if we lost any mbufs in the process. */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|tx_mbuf_alloc
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Memory leak! Lost %d mbufs "
literal|"from tx chain!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|tx_mbuf_alloc
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allocate memory and initialize the RX data structures.                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_init_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|rx_bd
modifier|*
name|rxbd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|u16
name|prod
decl_stmt|,
name|chain_prod
decl_stmt|;
name|u32
name|prod_bseq
decl_stmt|,
name|val
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Initialize the RX producer and consumer indices. */
name|sc
operator|->
name|rx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_prod_bseq
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|free_rx_bd
operator|=
name|BCE_RX_SLACK_SPACE
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|rx_low_watermark
operator|=
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
comment|/* Initialize the RX next pointer chain entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|rxbd
operator|=
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
index|[
name|USABLE_RX_BD_PER_PAGE
index|]
expr_stmt|;
comment|/* Check if we've reached the last page. */
if|if
condition|(
name|i
operator|==
operator|(
name|RX_PAGES
operator|-
literal|1
operator|)
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Setup the chain page pointers. */
name|rxbd
operator|->
name|rx_bd_haddr_hi
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|rxbd
operator|->
name|rx_bd_haddr_lo
operator|=
name|htole32
argument_list|(
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the context ID for an L2 RX chain. */
name|val
operator|=
name|BCE_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE
expr_stmt|;
name|val
operator||=
name|BCE_L2CTX_CTX_TYPE_SIZE_L2
expr_stmt|;
name|val
operator||=
literal|0x02
operator|<<
literal|8
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_CTX_TYPE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Point the hardware to the first page in the chain. */
name|val
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_NX_BDHADDR_HI
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|rx_bd_chain_paddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CTX_WR
argument_list|(
name|sc
argument_list|,
name|GET_CID_ADDR
argument_list|(
name|RX_CID
argument_list|)
argument_list|,
name|BCE_L2CTX_NX_BDHADDR_LO
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Allocate mbuf clusters for the rx_bd chain. */
name|prod
operator|=
name|prod_bseq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|prod
operator|<
name|BCE_RX_SLACK_SPACE
condition|)
block|{
name|chain_prod
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|prod
argument_list|)
expr_stmt|;
if|if
condition|(
name|bce_get_buf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prod
argument_list|,
operator|&
name|chain_prod
argument_list|,
operator|&
name|prod_bseq
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Error filling RX chain: rx_bd[0x%04X]!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|chain_prod
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|prod
operator|=
name|NEXT_RX_BD
argument_list|(
name|prod
argument_list|)
expr_stmt|;
block|}
comment|/* Save the RX chain producer index. */
name|sc
operator|->
name|rx_prod
operator|=
name|prod
expr_stmt|;
name|sc
operator|->
name|rx_prod_bseq
operator|=
name|prod_bseq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the chip about the waiting rx_bd's. */
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|MB_RX_CID_ADDR
operator|+
name|BCE_L2CTX_HOST_BDIDX
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MB_RX_CID_ADDR
operator|+
name|BCE_L2CTX_HOST_BSEQ
argument_list|,
name|sc
operator|->
name|rx_prod_bseq
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|BCE_VERBOSE_RECV
argument_list|,
name|bce_dump_rx_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TOTAL_RX_BD
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Free memory and clear the RX data structures.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_free_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Free any mbufs still in the RX mbuf chain. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_RX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear each RX chain page. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|rx_bd_chain
index|[
name|i
index|]
argument_list|,
name|BCE_RX_CHAIN_PAGE_SZ
argument_list|)
expr_stmt|;
comment|/* Check if we lost any mbufs in the process. */
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|rx_mbuf_alloc
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Memory leak! Lost %d mbufs from rx chain!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|rx_mbuf_alloc
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Set media options.                                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|bce_ifmedia
expr_stmt|;
comment|/* DRC - ToDo: Add SerDes support. */
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_instance
condition|)
block|{
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
for|for
control|(
name|miisc
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|mii
operator|->
name|mii_phys
argument_list|)
init|;
name|miisc
operator|!=
name|NULL
condition|;
name|miisc
operator|=
name|LIST_NEXT
argument_list|(
name|miisc
argument_list|,
name|mii_list
argument_list|)
control|)
name|mii_phy_reset
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
block|}
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Reports current media status.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
comment|/* DRC - ToDo: Add SerDes support. */
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles PHY generated interrupt events.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_phy_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|new_link_state
decl_stmt|,
name|old_link_state
decl_stmt|;
name|new_link_state
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits
operator|&
name|STATUS_ATTN_BITS_LINK_STATE
expr_stmt|;
name|old_link_state
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits_ack
operator|&
name|STATUS_ATTN_BITS_LINK_STATE
expr_stmt|;
comment|/* Handle any changes if the link state has changed. */
if|if
condition|(
name|new_link_state
operator|!=
name|old_link_state
condition|)
block|{
name|DBRUN
argument_list|(
name|BCE_VERBOSE_INTR
argument_list|,
name|bce_dump_status_block
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_link
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|bce_stat_ch
argument_list|)
expr_stmt|;
name|bce_tick_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Update the status_attn_bits_ack field in the status block. */
if|if
condition|(
name|new_link_state
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_STATUS_BIT_SET_CMD
argument_list|,
name|STATUS_ATTN_BITS_LINK_STATE
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Link is now UP.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_STATUS_BIT_CLEAR_CMD
argument_list|,
name|STATUS_ATTN_BITS_LINK_STATE
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Link is now DOWN.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Acknowledge the link change interrupt. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_STATUS
argument_list|,
name|BCE_EMAC_STATUS_LINK_CHANGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles received frame interrupt events.                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_rx_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|status_block
modifier|*
name|sblk
init|=
name|sc
operator|->
name|status_block
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|bce_ifp
decl_stmt|;
name|u16
name|hw_cons
decl_stmt|,
name|sw_cons
decl_stmt|,
name|sw_chain_cons
decl_stmt|,
name|sw_prod
decl_stmt|,
name|sw_chain_prod
decl_stmt|;
name|u32
name|sw_prod_bseq
decl_stmt|;
name|struct
name|l2_fhdr
modifier|*
name|l2fhdr
decl_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|rx_interrupts
operator|++
argument_list|)
expr_stmt|;
comment|/* Prepare the RX chain pages to be accessed by the host CPU. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* Get the hardware's view of the RX consumer index. */
name|hw_cons
operator|=
name|sc
operator|->
name|hw_rx_cons
operator|=
name|sblk
operator|->
name|status_rx_quick_consumer_index0
expr_stmt|;
if|if
condition|(
operator|(
name|hw_cons
operator|&
name|USABLE_RX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_RX_BD_PER_PAGE
condition|)
name|hw_cons
operator|++
expr_stmt|;
comment|/* Get working copies of the driver's view of the RX indices. */
name|sw_cons
operator|=
name|sc
operator|->
name|rx_cons
expr_stmt|;
name|sw_prod
operator|=
name|sc
operator|->
name|rx_prod
expr_stmt|;
name|sw_prod_bseq
operator|=
name|sc
operator|->
name|rx_prod_bseq
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RECV
argument_list|,
literal|"%s(enter): sw_prod = 0x%04X, "
literal|"sw_cons = 0x%04X, sw_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sw_prod
argument_list|,
name|sw_cons
argument_list|,
name|sw_prod_bseq
argument_list|)
expr_stmt|;
comment|/* Prevent speculative reads from getting ahead of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|free_rx_bd
operator|<
name|sc
operator|->
name|rx_low_watermark
operator|)
argument_list|,
name|sc
operator|->
name|rx_low_watermark
operator|=
name|sc
operator|->
name|free_rx_bd
argument_list|)
expr_stmt|;
comment|/*  	 * Scan through the receive chain as long  	 * as there is work to do. 	 */
while|while
condition|(
name|sw_cons
operator|!=
name|hw_cons
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|rx_bd
modifier|*
name|rxbd
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|u32
name|status
decl_stmt|;
comment|/* Convert the producer/consumer indices to an actual rx_bd index. */
name|sw_chain_cons
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|sw_cons
argument_list|)
expr_stmt|;
name|sw_chain_prod
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|sw_prod
argument_list|)
expr_stmt|;
comment|/* Get the used rx_bd. */
name|rxbd
operator|=
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|RX_PAGE
argument_list|(
name|sw_chain_cons
argument_list|)
index|]
index|[
name|RX_IDX
argument_list|(
name|sw_chain_cons
argument_list|)
index|]
expr_stmt|;
name|sc
operator|->
name|free_rx_bd
operator|++
expr_stmt|;
name|DBRUN
argument_list|(
argument|BCE_VERBOSE_RECV
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(): "
argument|, __FUNCTION__);  			bce_dump_rxbd(sc, sw_chain_cons, rxbd)
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bce_rxcycles
operator|<=
literal|0
condition|)
break|break;
name|sc
operator|->
name|bce_rxcycles
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* The mbuf is stored with the last rx_bd entry of a packet. */
if|if
condition|(
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|sw_chain_cons
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* Validate that this is the last rx_bd. */
name|DBRUNIF
argument_list|(
argument|(!(rxbd->rx_bd_flags& RX_BD_FLAGS_END))
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(%d): Unexpected mbuf found in rx_bd[0x%04X]!\n"
argument|, 				__FILE__, __LINE__, sw_chain_cons); 				bce_breakpoint(sc)
argument_list|)
empty_stmt|;
comment|/* DRC - ToDo: If the received packet is small, say less */
comment|/*             than 128 bytes, allocate a new mbuf here, */
comment|/*             copy the data to that mbuf, and recycle   */
comment|/*             the mapped jumbo frame.                   */
comment|/* Unmap the mbuf from DMA space. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|sw_chain_cons
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_mbuf_tag
argument_list|,
name|sc
operator|->
name|rx_mbuf_map
index|[
name|sw_chain_cons
index|]
argument_list|)
expr_stmt|;
comment|/* Remove the mbuf from the driver's chain. */
name|m
operator|=
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|sw_chain_cons
index|]
expr_stmt|;
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|sw_chain_cons
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Frames received on the NetXteme II are prepended  			 * with the l2_fhdr structure which provides status 			 * information about the received frame (including 			 * VLAN tags and checksum info) and are also 			 * automatically adjusted to align the IP header 			 * (i.e. two null bytes are inserted before the  			 * Ethernet header). 			 */
name|l2fhdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|l2_fhdr
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_pkt_len
expr_stmt|;
name|status
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_status
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(bce_debug_l2fhdr_status_check)
argument_list|,
argument|BCE_PRINTF(sc,
literal|"Simulating l2_fhdr status error.\n"
argument|); 				status = status | L2_FHDR_ERRORS_PHY_DECODE
argument_list|)
empty_stmt|;
comment|/* Watch for unusual sized frames. */
name|DBRUNIF
argument_list|(
argument|((len< BCE_MIN_MTU) || (len> BCE_MAX_JUMBO_ETHER_MTU_VLAN))
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(%d): Unusual frame size found. "
literal|"Min(%d), Actual(%d), Max(%d)\n"
argument|,  					__FILE__, __LINE__, (int) BCE_MIN_MTU,  					len, (int) BCE_MAX_JUMBO_ETHER_MTU_VLAN); 				bce_dump_mbuf(sc, m); 		 		bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|len
operator|-=
name|ETHER_CRC_LEN
expr_stmt|;
comment|/* Check the received frame for errors. */
if|if
condition|(
name|status
operator|&
operator|(
name|L2_FHDR_ERRORS_BAD_CRC
operator||
name|L2_FHDR_ERRORS_PHY_DECODE
operator||
name|L2_FHDR_ERRORS_ALIGNMENT
operator||
name|L2_FHDR_ERRORS_TOO_SHORT
operator||
name|L2_FHDR_ERRORS_GIANT_FRAME
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|l2fhdr_status_errors
operator|++
argument_list|)
expr_stmt|;
comment|/* Reuse the mbuf for a new frame. */
if|if
condition|(
name|bce_get_buf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
operator|&
name|sw_prod
argument_list|,
operator|&
name|sw_chain_prod
argument_list|,
operator|&
name|sw_prod_bseq
argument_list|)
condition|)
block|{
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|bce_breakpoint
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"bce%d: Can't reuse RX mbuf!\n"
argument_list|,
name|sc
operator|->
name|bce_unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bce_rx_int_next_rx
goto|;
block|}
comment|/*  			 * Get a new mbuf for the rx_bd.   If no new 			 * mbufs are available then reuse the current mbuf, 			 * log an ierror on the interface, and generate 			 * an error in the system log. 			 */
if|if
condition|(
name|bce_get_buf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
operator|&
name|sw_prod
argument_list|,
operator|&
name|sw_chain_prod
argument_list|,
operator|&
name|sw_prod_bseq
argument_list|)
condition|)
block|{
name|DBRUN
argument_list|(
name|BCE_WARN
argument_list|,
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Failed to allocate "
literal|"new mbuf, incoming frame dropped!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
comment|/* Try and reuse the exisitng mbuf. */
if|if
condition|(
name|bce_get_buf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
operator|&
name|sw_prod
argument_list|,
operator|&
name|sw_chain_prod
argument_list|,
operator|&
name|sw_prod_bseq
argument_list|)
condition|)
block|{
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|bce_breakpoint
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"bce%d: Double mbuf allocation failure!"
argument_list|,
name|sc
operator|->
name|bce_unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bce_rx_int_next_rx
goto|;
block|}
comment|/* Skip over the l2_fhdr when passing the data up the stack. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|l2_fhdr
argument_list|)
operator|+
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
comment|/* Adjust the packet length to match the received data. */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* Send the packet to the appropriate interface. */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|DBRUN
argument_list|(
argument|BCE_VERBOSE_RECV
argument_list|,
argument|struct ether_header *eh; 				eh = mtod(m, struct ether_header *); 				BCE_PRINTF(sc,
literal|"%s(): to: %6D, from: %6D, type: 0x%04X\n"
argument|, 					__FUNCTION__, eh->ether_dhost,
literal|":"
argument|,  					eh->ether_shost,
literal|":"
argument|, htons(eh->ether_type))
argument_list|)
empty_stmt|;
comment|/* Validate the checksum if offload enabled. */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
comment|/* Check for an IP datagram. */
if|if
condition|(
name|status
operator|&
name|L2_FHDR_STATUS_IP_DATAGRAM
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
comment|/* Check if the IP checksum is valid. */
if|if
condition|(
operator|(
name|l2fhdr
operator|->
name|l2_fhdr_ip_xsum
operator|^
literal|0xffff
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
else|else
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN_SEND
argument_list|,
literal|"%s(): Invalid IP checksum = 0x%04X!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_ip_xsum
argument_list|)
expr_stmt|;
block|}
comment|/* Check for a valid TCP/UDP frame. */
if|if
condition|(
name|status
operator|&
operator|(
name|L2_FHDR_STATUS_TCP_SEGMENT
operator||
name|L2_FHDR_STATUS_UDP_DATAGRAM
operator|)
condition|)
block|{
comment|/* Check for a good TCP/UDP checksum. */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|L2_FHDR_ERRORS_TCP_XSUM
operator||
name|L2_FHDR_ERRORS_UDP_XSUM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_tcp_udp_xsum
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
block|}
else|else
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN_SEND
argument_list|,
literal|"%s(): Invalid TCP/UDP checksum = 0x%04X!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_tcp_udp_xsum
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * If we received a packet with a vlan tag, 			 * attach that information to the packet. 			 */
if|if
condition|(
name|status
operator|&
name|L2_FHDR_STATUS_L2_VLAN_TAG
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_SEND
argument_list|,
literal|"%s(): VLAN tag = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_vlan_tag
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
name|VLAN_INPUT_TAG
argument_list|(
argument|ifp
argument_list|,
argument|m
argument_list|,
argument|l2fhdr->l2_fhdr_vlan_tag
argument_list|,
argument|continue
argument_list|)
empty_stmt|;
else|#
directive|else
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|l2fhdr
operator|->
name|l2_fhdr_vlan_tag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Pass the mbuf off to the upper layers. */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RECV
argument_list|,
literal|"%s(): Passing received frame up.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_rx_int_next_rx
label|:
name|sw_prod
operator|=
name|NEXT_RX_BD
argument_list|(
name|sw_prod
argument_list|)
expr_stmt|;
block|}
name|sw_cons
operator|=
name|NEXT_RX_BD
argument_list|(
name|sw_cons
argument_list|)
expr_stmt|;
comment|/* Refresh hw_cons to see if there's new work */
if|if
condition|(
name|sw_cons
operator|==
name|hw_cons
condition|)
block|{
name|hw_cons
operator|=
name|sc
operator|->
name|hw_rx_cons
operator|=
name|sblk
operator|->
name|status_rx_quick_consumer_index0
expr_stmt|;
if|if
condition|(
operator|(
name|hw_cons
operator|&
name|USABLE_RX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_RX_BD_PER_PAGE
condition|)
name|hw_cons
operator|++
expr_stmt|;
block|}
comment|/* Prevent speculative reads from getting ahead of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RX_PAGES
condition|;
name|i
operator|++
control|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_bd_chain_tag
argument_list|,
name|sc
operator|->
name|rx_bd_chain_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_cons
operator|=
name|sw_cons
expr_stmt|;
name|sc
operator|->
name|rx_prod
operator|=
name|sw_prod
expr_stmt|;
name|sc
operator|->
name|rx_prod_bseq
operator|=
name|sw_prod_bseq
expr_stmt|;
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|MB_RX_CID_ADDR
operator|+
name|BCE_L2CTX_HOST_BDIDX
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MB_RX_CID_ADDR
operator|+
name|BCE_L2CTX_HOST_BSEQ
argument_list|,
name|sc
operator|->
name|rx_prod_bseq
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_RECV
argument_list|,
literal|"%s(exit): rx_prod = 0x%04X, "
literal|"rx_cons = 0x%04X, rx_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|,
name|sc
operator|->
name|rx_cons
argument_list|,
name|sc
operator|->
name|rx_prod_bseq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles transmit completion interrupt events.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_tx_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|status_block
modifier|*
name|sblk
init|=
name|sc
operator|->
name|status_block
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|bce_ifp
decl_stmt|;
name|u16
name|hw_tx_cons
decl_stmt|,
name|sw_tx_cons
decl_stmt|,
name|sw_tx_chain_cons
decl_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|tx_interrupts
operator|++
argument_list|)
expr_stmt|;
comment|/* Get the hardware's view of the TX consumer index. */
name|hw_tx_cons
operator|=
name|sc
operator|->
name|hw_tx_cons
operator|=
name|sblk
operator|->
name|status_tx_quick_consumer_index0
expr_stmt|;
comment|/* Skip to the next entry if this is a chain page pointer. */
if|if
condition|(
operator|(
name|hw_tx_cons
operator|&
name|USABLE_TX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_TX_BD_PER_PAGE
condition|)
name|hw_tx_cons
operator|++
expr_stmt|;
name|sw_tx_cons
operator|=
name|sc
operator|->
name|tx_cons
expr_stmt|;
comment|/* Prevent speculative reads from getting ahead of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
comment|/* Cycle through any completed TX chain page entries. */
while|while
condition|(
name|sw_tx_cons
operator|!=
name|hw_tx_cons
condition|)
block|{
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|struct
name|tx_bd
modifier|*
name|txbd
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|sw_tx_chain_cons
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|sw_tx_cons
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): hw_tx_cons = 0x%04X, sw_tx_cons = 0x%04X, "
literal|"sw_tx_chain_cons = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|hw_tx_cons
argument_list|,
name|sw_tx_cons
argument_list|,
name|sw_tx_chain_cons
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|(sw_tx_chain_cons> MAX_TX_BD)
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(%d): TX chain consumer out of range! "
literal|" 0x%04X> 0x%04X\n"
argument|, 				__FILE__, __LINE__, sw_tx_chain_cons,  				(int) MAX_TX_BD); 			bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|txbd
operator|=
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|TX_PAGE
argument_list|(
name|sw_tx_chain_cons
argument_list|)
index|]
index|[
name|TX_IDX
argument_list|(
name|sw_tx_chain_cons
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|(txbd == NULL)
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(%d): Unexpected NULL tx_bd[0x%04X]!\n"
argument|,  				__FILE__, __LINE__, sw_tx_chain_cons); 			bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|DBRUN
argument_list|(
argument|BCE_INFO_SEND
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(): "
argument|, __FUNCTION__); 			bce_dump_txbd(sc, sw_tx_chain_cons, txbd)
argument_list|)
empty_stmt|;
comment|/* 		 * Free the associated mbuf. Remember 		 * that only the last tx_bd of a packet 		 * has an mbuf pointer and DMA map. 		 */
if|if
condition|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|sw_tx_chain_cons
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* Validate that this is the last tx_bd. */
name|DBRUNIF
argument_list|(
argument|(!(txbd->tx_bd_vlan_tag_flags& TX_BD_FLAGS_END))
argument_list|,
argument|BCE_PRINTF(sc,
literal|"%s(%d): tx_bd END flag not set but "
literal|"txmbuf == NULL!\n"
argument|, __FILE__, __LINE__); 				bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|DBRUN
argument_list|(
name|BCE_INFO_SEND
argument_list|,
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(): Unloading map/freeing mbuf "
literal|"from tx_bd[0x%04X]\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sw_tx_chain_cons
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unmap the mbuf. */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|sc
operator|->
name|tx_mbuf_map
index|[
name|sw_tx_chain_cons
index|]
argument_list|)
expr_stmt|;
comment|/* Free the mbuf. */
name|m_freem
argument_list|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|sw_tx_chain_cons
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|sw_tx_chain_cons
index|]
operator|=
name|NULL
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|tx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|used_tx_bd
operator|--
expr_stmt|;
name|sw_tx_cons
operator|=
name|NEXT_TX_BD
argument_list|(
name|sw_tx_cons
argument_list|)
expr_stmt|;
comment|/* Refresh hw_cons to see if there's new work. */
name|hw_tx_cons
operator|=
name|sc
operator|->
name|hw_tx_cons
operator|=
name|sblk
operator|->
name|status_tx_quick_consumer_index0
expr_stmt|;
if|if
condition|(
operator|(
name|hw_tx_cons
operator|&
name|USABLE_TX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_TX_BD_PER_PAGE
condition|)
name|hw_tx_cons
operator|++
expr_stmt|;
comment|/* Prevent speculative reads from getting ahead of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the TX timeout timer. */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* Clear the tx hardware queue full flag. */
if|if
condition|(
operator|(
name|sc
operator|->
name|used_tx_bd
operator|+
name|BCE_TX_SLACK_SPACE
operator|)
operator|<
name|USABLE_TX_BD
condition|)
block|{
name|DBRUNIF
argument_list|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
argument_list|,
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(): TX chain is open for business! Used tx_bd = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|used_tx_bd
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|sc
operator|->
name|tx_cons
operator|=
name|sw_tx_cons
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Disables interrupt generation.                                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_disable_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_MASK_INT
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Enables interrupt generation.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_enable_intr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_INDEX_VALID
operator||
name|BCE_PCICFG_INT_ACK_CMD_MASK_INT
operator||
name|sc
operator|->
name|last_status_idx
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_INDEX_VALID
operator||
name|sc
operator|->
name|last_status_idx
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_COMMAND
argument_list|,
name|val
operator||
name|BCE_HC_COMMAND_COAL_NOW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles controller initialization.                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Must be called from a locked routine.                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|ether_mtu
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
comment|/* Check if the driver is still running and bail out if it is. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
goto|goto
name|bce_init_locked_exit
goto|;
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bce_reset
argument_list|(
name|sc
argument_list|,
name|BCE_DRV_MSG_CODE_RESET
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Controller reset failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_init_locked_exit
goto|;
block|}
if|if
condition|(
name|bce_chipinit
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Controller initialization failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_init_locked_exit
goto|;
block|}
if|if
condition|(
name|bce_blockinit
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Block initialization failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_init_locked_exit
goto|;
block|}
comment|/* Load our MAC address. */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|bce_ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bce_set_mac_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Calculate and program the Ethernet MTU size. */
name|ether_mtu
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|+
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"%s(): setting mtu = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ether_mtu
argument_list|)
expr_stmt|;
comment|/*  	 * Program the mtu, enabling jumbo frame  	 * support if necessary.  Also set the mbuf 	 * allocation count for RX frames. 	 */
if|if
condition|(
name|ether_mtu
operator|>
name|ETHER_MAX_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_RX_MTU_SIZE
argument_list|,
name|ether_mtu
operator||
name|BCE_EMAC_RX_MTU_SIZE_JUMBO_ENA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mbuf_alloc_size
operator|=
name|MJUM9BYTES
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_RX_MTU_SIZE
argument_list|,
name|ether_mtu
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
block|}
comment|/* Calculate the RX Ethernet frame size for rx_bd's. */
name|sc
operator|->
name|max_frame_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|l2_fhdr
argument_list|)
operator|+
literal|2
operator|+
name|ether_mtu
operator|+
literal|8
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"%s(): mclbytes = %d, mbuf_alloc_size = %d, "
literal|"max_frame_size = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|int
operator|)
name|MCLBYTES
argument_list|,
name|sc
operator|->
name|mbuf_alloc_size
argument_list|,
name|sc
operator|->
name|max_frame_size
argument_list|)
expr_stmt|;
comment|/* Program appropriate promiscuous/multicast filtering. */
name|bce_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Init RX buffer descriptor chain. */
name|bce_init_rx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Init TX buffer descriptor chain. */
name|bce_init_tx_chain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* Disable interrupts if we are polling. */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|bce_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_RX_QUICK_CONS_TRIP
argument_list|,
operator|(
literal|1
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_rx_quick_cons_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_TX_QUICK_CONS_TRIP
argument_list|,
operator|(
literal|1
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_tx_quick_cons_trip
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* Enable host interrupts. */
name|bce_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_ifmedia_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|bce_stat_ch
argument_list|,
name|hz
argument_list|,
name|bce_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|bce_init_locked_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_mgmt_init_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
comment|/* Check if the driver is still running and bail out if it is. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
goto|goto
name|bce_mgmt_init_locked_exit
goto|;
comment|/* Initialize the on-boards CPUs */
name|bce_init_cpus
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|BCM_PAGE_BITS
operator|-
literal|8
operator|)
operator|<<
literal|24
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RV2P_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Enable all critical blocks in the MAC. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS_RX_V2P_ENABLE
operator||
name|BCE_MISC_ENABLE_SET_BITS_RX_DMA_ENABLE
operator||
name|BCE_MISC_ENABLE_SET_BITS_COMPLETION_ENABLE
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_SET_BITS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|bce_ifmedia_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bce_mgmt_init_locked_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles controller initialization when called from an unlocked routine.  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Encapsultes an mbuf cluster into the tx_bd chain structure and makes the */
end_comment

begin_comment
comment|/* memory visible to the controller.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_tx_encap
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|,
name|u16
modifier|*
name|prod
parameter_list|,
name|u16
modifier|*
name|chain_prod
parameter_list|,
name|u32
modifier|*
name|prod_bseq
parameter_list|)
block|{
name|u32
name|vlan_tag_flags
init|=
literal|0
decl_stmt|;
name|struct
name|bce_dmamap_arg
name|map_arg
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
comment|/* Transfer any checksum offload flags to the bd. */
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
name|vlan_tag_flags
operator||=
name|TX_BD_FLAGS_IP_CKSUM
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
condition|)
name|vlan_tag_flags
operator||=
name|TX_BD_FLAGS_TCP_UDP_CKSUM
expr_stmt|;
block|}
comment|/* Transfer any VLAN tags to the bd. */
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
name|vlan_tag_flags
operator||=
operator|(
name|TX_BD_FLAGS_VLAN_TAG
operator||
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
comment|/* Map the mbuf into DMAable memory. */
name|map
operator|=
name|sc
operator|->
name|tx_mbuf_map
index|[
operator|*
name|chain_prod
index|]
expr_stmt|;
name|map_arg
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|map_arg
operator|.
name|prod
operator|=
operator|*
name|prod
expr_stmt|;
name|map_arg
operator|.
name|chain_prod
operator|=
operator|*
name|chain_prod
expr_stmt|;
name|map_arg
operator|.
name|prod_bseq
operator|=
operator|*
name|prod_bseq
expr_stmt|;
name|map_arg
operator|.
name|tx_flags
operator|=
name|vlan_tag_flags
expr_stmt|;
name|map_arg
operator|.
name|maxsegs
operator|=
name|USABLE_TX_BD
operator|-
name|sc
operator|->
name|used_tx_bd
operator|-
name|BCE_TX_SLACK_SPACE
expr_stmt|;
name|KASSERT
argument_list|(
name|map_arg
operator|.
name|maxsegs
operator|>
literal|0
argument_list|,
operator|(
literal|"Invalid TX maxsegs value!"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_PAGES
condition|;
name|i
operator|++
control|)
name|map_arg
operator|.
name|tx_chain
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|tx_bd_chain
index|[
name|i
index|]
expr_stmt|;
comment|/* Map the mbuf into our DMA address space. */
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|map
argument_list|,
name|m_head
argument_list|,
name|bce_dma_map_tx_desc
argument_list|,
operator|&
name|map_arg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|map_arg
operator|.
name|maxsegs
operator|==
literal|0
condition|)
block|{
comment|/* Try to defrag the mbuf if there are too many segments. */
if|if
condition|(
name|error
operator|==
name|EFBIG
operator|&&
name|map_arg
operator|.
name|maxsegs
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_WARN
argument_list|,
literal|"%s(): fragmented mbuf (%d pieces)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|map_arg
operator|.
name|maxsegs
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m_defrag
argument_list|(
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|m_head
operator|=
name|m0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|tx_mbuf_tag
argument_list|,
name|map
argument_list|,
name|m_head
argument_list|,
name|bce_dma_map_tx_desc
argument_list|,
operator|&
name|map_arg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Still getting an error after a defrag. */
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Error mapping mbuf into TX chain!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bce_tx_encap_exit
goto|;
block|}
block|}
comment|/* 	 * Ensure that the map for this transmission 	 * is placed at the array index of the last 	 * descriptor in this chain.  This is done 	 * because a single map is used for all  	 * segments of the mbuf and we don't want to 	 * delete the map before all of the segments 	 * have been freed. 	 */
name|sc
operator|->
name|tx_mbuf_map
index|[
operator|*
name|chain_prod
index|]
operator|=
name|sc
operator|->
name|tx_mbuf_map
index|[
name|map_arg
operator|.
name|chain_prod
index|]
expr_stmt|;
name|sc
operator|->
name|tx_mbuf_map
index|[
name|map_arg
operator|.
name|chain_prod
index|]
operator|=
name|map
expr_stmt|;
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|map_arg
operator|.
name|chain_prod
index|]
operator|=
name|m_head
expr_stmt|;
name|sc
operator|->
name|used_tx_bd
operator|+=
name|map_arg
operator|.
name|maxsegs
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|sc
operator|->
name|used_tx_bd
operator|>
name|sc
operator|->
name|tx_hi_watermark
operator|)
argument_list|,
name|sc
operator|->
name|tx_hi_watermark
operator|=
name|sc
operator|->
name|used_tx_bd
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|tx_mbuf_alloc
operator|++
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|BCE_VERBOSE_SEND
argument_list|,
name|bce_dump_tx_mbuf_chain
argument_list|(
name|sc
argument_list|,
operator|*
name|chain_prod
argument_list|,
name|map_arg
operator|.
name|maxsegs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prod still points the last used tx_bd at this point. */
operator|*
name|prod
operator|=
name|map_arg
operator|.
name|prod
expr_stmt|;
operator|*
name|chain_prod
operator|=
name|map_arg
operator|.
name|chain_prod
expr_stmt|;
operator|*
name|prod_bseq
operator|=
name|map_arg
operator|.
name|prod_bseq
expr_stmt|;
name|bce_tx_encap_exit
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Main transmit routine when called from another routine with a lock.      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
init|=
name|NULL
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u16
name|tx_prod
decl_stmt|,
name|tx_chain_prod
decl_stmt|;
name|u32
name|tx_prod_bseq
decl_stmt|;
comment|/* If there's no link or the transmit queue is empty then just exit. */
if|if
condition|(
operator|!
name|sc
operator|->
name|bce_link
operator|||
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): No link or transmit queue empty.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bce_start_locked_exit
goto|;
block|}
comment|/* prod points to the next free tx_bd. */
name|tx_prod
operator|=
name|sc
operator|->
name|tx_prod
expr_stmt|;
name|tx_chain_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|tx_prod
argument_list|)
expr_stmt|;
name|tx_prod_bseq
operator|=
name|sc
operator|->
name|tx_prod_bseq
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): Start: tx_prod = 0x%04X, tx_chain_prod = %04X, "
literal|"tx_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|tx_prod
argument_list|,
name|tx_chain_prod
argument_list|,
name|tx_prod_bseq
argument_list|)
expr_stmt|;
comment|/* Keep adding entries while there is space in the ring. */
while|while
condition|(
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|tx_chain_prod
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* Check for any frames to send. */
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, place the mbuf back at the 		 * head of the queue and set the OACTIVE flag 		 * to wait for the NIC to drain the chain. 		 */
if|if
condition|(
name|bce_tx_encap
argument_list|(
name|sc
argument_list|,
name|m_head
argument_list|,
operator|&
name|tx_prod
argument_list|,
operator|&
name|tx_chain_prod
argument_list|,
operator|&
name|tx_prod_bseq
argument_list|)
condition|)
block|{
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"TX chain is closed for business! Total tx_bd used = %d\n"
argument_list|,
name|sc
operator|->
name|used_tx_bd
argument_list|)
expr_stmt|;
break|break;
block|}
name|count
operator|++
expr_stmt|;
comment|/* Send a copy of the frame to any BPF listeners. */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|tx_prod
operator|=
name|NEXT_TX_BD
argument_list|(
name|tx_prod
argument_list|)
expr_stmt|;
name|tx_chain_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|tx_prod
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* no packets were dequeued */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_SEND
argument_list|,
literal|"%s(): No packets were dequeued\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bce_start_locked_exit
goto|;
block|}
comment|/* Update the driver's counters. */
name|sc
operator|->
name|tx_prod
operator|=
name|tx_prod
expr_stmt|;
name|sc
operator|->
name|tx_prod_bseq
operator|=
name|tx_prod_bseq
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO_SEND
argument_list|,
literal|"%s(): End: tx_prod = 0x%04X, tx_chain_prod = 0x%04X, "
literal|"tx_prod_bseq = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|tx_prod
argument_list|,
name|tx_chain_prod
argument_list|,
name|tx_prod_bseq
argument_list|)
expr_stmt|;
comment|/* Start the transmit. */
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|MB_TX_CID_ADDR
operator|+
name|BCE_L2CTX_TX_HOST_BIDX
argument_list|,
name|sc
operator|->
name|tx_prod
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MB_TX_CID_ADDR
operator|+
name|BCE_L2CTX_TX_HOST_BSEQ
argument_list|,
name|sc
operator|->
name|tx_prod_bseq
argument_list|)
expr_stmt|;
comment|/* Set the tx timeout. */
name|ifp
operator|->
name|if_timer
operator|=
name|BCE_TX_TIMEOUT
expr_stmt|;
name|bce_start_locked_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Main transmit routine when called from another routine without a lock.   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Handles any IOCTL calls from the operating system.                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
comment|/* Set the MTU. */
case|case
name|SIOCSIFMTU
case|:
comment|/* Check that the MTU setting is supported. */
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|BCE_MIN_MTU
operator|)
operator|||
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|BCE_MAX_JUMBO_MTU
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Setting new MTU of %d\n"
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
comment|/* Set interface. */
case|case
name|SIOCSIFFLAGS
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Received SIOCSIFFLAGS\n"
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check if the interface is up. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* Change the promiscuous/multicast flags as necessary. */
name|bce_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Start the HW */
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The interface is down.  Check if the driver is running. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|bce_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Add/Delete multicast address */
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Received SIOCADDMULTI/SIOCDELMULTI\n"
argument_list|)
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|bce_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
comment|/* Set/Get Interface media */
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Received SIOCSIFMEDIA/SIOCGIFMEDIA\n"
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"bce_phy_flags = 0x%08X\n"
argument_list|,
name|sc
operator|->
name|bce_phy_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bce_phy_flags
operator|&
name|BCE_PHY_SERDES_FLAG
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"SerDes media set/get\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|bce_ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Copper media set/get\n"
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Set interface capability */
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Received SIOCSIFCAP = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|mask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
condition|)
block|{
comment|/* Setup the poll routine to call. */
name|error
operator|=
name|ether_poll_register
argument_list|(
name|bce_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Error registering poll function!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bce_ioctl_exit
goto|;
block|}
comment|/* Clear the interrupt. */
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_RX_QUICK_CONS_TRIP
argument_list|,
operator|(
literal|1
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_rx_quick_cons_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_TX_QUICK_CONS_TRIP
argument_list|,
operator|(
literal|1
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_tx_quick_cons_trip
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear the poll routine. */
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupt even in error case */
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_TX_QUICK_CONS_TRIP
argument_list|,
operator|(
name|sc
operator|->
name|bce_tx_quick_cons_trip_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_tx_quick_cons_trip
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_HC_RX_QUICK_CONS_TRIP
argument_list|,
operator|(
name|sc
operator|->
name|bce_rx_quick_cons_trip_int
operator|<<
literal|16
operator|)
operator||
name|sc
operator|->
name|bce_rx_quick_cons_trip
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*DEVICE_POLLING */
comment|/* Toggle the TX checksum capabilites enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|BCE_IF_HWASSIST
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Toggle the RX checksum capabilities enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|IFCAP_RXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|BCE_IF_HWASSIST
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Toggle VLAN_MTU capabilities enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Changing VLAN_MTU not supported.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
comment|/* Toggle VLANHWTAG capabilities enabled flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_MFW_ENABLE_FLAG
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Cannot change VLAN_HWTAGGING while "
literal|"management firmware (ASF/IPMI/UMP) is running!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|else
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Changing VLAN_HWTAGGING not supported!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Received unsupported IOCTL: 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|command
argument_list|)
expr_stmt|;
comment|/* We don't know how to handle the IOCTL, pass it on. */
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|bce_ioctl_exit
label|:
endif|#
directive|endif
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE_RESET
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Transmit timeout handler.                                                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DBRUN
argument_list|(
argument|BCE_WARN_SEND
argument_list|,
argument|bce_dump_driver_state(sc); 		bce_dump_status_block(sc)
argument_list|)
empty_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Watchdog timeout occurred, resetting!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* DBRUN(BCE_FATAL, bce_breakpoint(sc)); */
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function
specifier|static
name|void
name|bce_poll_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bce_rxcycles
operator|=
name|count
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* Check for any completed RX frames. */
if|if
condition|(
name|sc
operator|->
name|status_block
operator|->
name|status_rx_quick_consumer_index0
operator|!=
name|sc
operator|->
name|hw_rx_cons
condition|)
name|bce_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check for any completed TX frames. */
if|if
condition|(
name|sc
operator|->
name|status_block
operator|->
name|status_tx_quick_consumer_index0
operator|!=
name|sc
operator|->
name|hw_tx_cons
condition|)
name|bce_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check for new frames to transmit. */
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|bce_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|bce_poll_locked
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static inline int bce_has_work(struct bce_softc *sc) { 	struct status_block *stat = sc->status_block;  	if ((stat->status_rx_quick_consumer_index0 != sc->hw_rx_cons) || 	    (stat->status_tx_quick_consumer_index0 != sc->hw_tx_cons)) 		return 1;  	if (((stat->status_attn_bits& STATUS_ATTN_BITS_LINK_STATE) != 0) != 	    bp->link_up) 		return 1;  	return 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Interrupt handler.  */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Main interrupt entry point.  Verifies that the controller generated the  */
end_comment

begin_comment
comment|/* interrupt and then calls a separate routine for handle the various       */
end_comment

begin_comment
comment|/* interrupt causes (PHY, TX, RX).                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|status_attn_bits
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|interrupts_generated
operator|++
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Polling enabled!\n"
argument_list|)
expr_stmt|;
goto|goto
name|bce_intr_exit
goto|;
block|}
endif|#
directive|endif
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * If the hardware status block index 	 * matches the last value read by the 	 * driver and we haven't asserted our 	 * interrupt then there's nothing to do. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|status_block
operator|->
name|status_idx
operator|==
name|sc
operator|->
name|last_status_idx
operator|)
operator|&&
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_MISC_STATUS
argument_list|)
operator|&
name|BCE_PCICFG_MISC_STATUS_INTA_VALUE
operator|)
condition|)
goto|goto
name|bce_intr_exit
goto|;
comment|/* Ack the interrupt and stop others from occuring. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM
operator||
name|BCE_PCICFG_INT_ACK_CMD_MASK_INT
argument_list|)
expr_stmt|;
comment|/* Keep processing data as long as there is work to do. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|status_attn_bits
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits
expr_stmt|;
name|DBRUNIF
argument_list|(
argument|DB_RANDOMTRUE(bce_debug_unexpected_attention)
argument_list|,
argument|BCE_PRINTF(sc,
literal|"Simulating unexpected status attention bit set."
argument|); 			status_attn_bits = status_attn_bits | STATUS_ATTN_BITS_PARITY_ERROR
argument_list|)
empty_stmt|;
comment|/* Was it a link change interrupt? */
if|if
condition|(
operator|(
name|status_attn_bits
operator|&
name|STATUS_ATTN_BITS_LINK_STATE
operator|)
operator|!=
operator|(
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits_ack
operator|&
name|STATUS_ATTN_BITS_LINK_STATE
operator|)
condition|)
name|bce_phy_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If any other attention is asserted then the chip is toast. */
if|if
condition|(
operator|(
operator|(
name|status_attn_bits
operator|&
operator|~
name|STATUS_ATTN_BITS_LINK_STATE
operator|)
operator|!=
operator|(
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits_ack
operator|&
operator|~
name|STATUS_ATTN_BITS_LINK_STATE
operator|)
operator|)
condition|)
block|{
name|DBRUN
argument_list|(
literal|1
argument_list|,
name|sc
operator|->
name|unexpected_attentions
operator|++
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"%s(%d): Fatal attention detected: 0x%08X\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|status_block
operator|->
name|status_attn_bits
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
argument|BCE_FATAL
argument_list|,
argument|if (bce_debug_unexpected_attention ==
literal|0
argument|) 					bce_breakpoint(sc)
argument_list|)
empty_stmt|;
name|bce_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|bce_intr_exit
goto|;
block|}
comment|/* Check for any completed RX frames. */
if|if
condition|(
name|sc
operator|->
name|status_block
operator|->
name|status_rx_quick_consumer_index0
operator|!=
name|sc
operator|->
name|hw_rx_cons
condition|)
name|bce_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check for any completed TX frames. */
if|if
condition|(
name|sc
operator|->
name|status_block
operator|->
name|status_tx_quick_consumer_index0
operator|!=
name|sc
operator|->
name|hw_tx_cons
condition|)
name|bce_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Save the status block index value for use during the next interrupt. */
name|sc
operator|->
name|last_status_idx
operator|=
name|sc
operator|->
name|status_block
operator|->
name|status_idx
expr_stmt|;
comment|/* Prevent speculative reads from getting ahead of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bce_btag
argument_list|,
name|sc
operator|->
name|bce_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
comment|/* If there's no work left then exit the interrupt service routine. */
if|if
condition|(
operator|(
name|sc
operator|->
name|status_block
operator|->
name|status_rx_quick_consumer_index0
operator|==
name|sc
operator|->
name|hw_rx_cons
operator|)
operator|&&
operator|(
name|sc
operator|->
name|status_block
operator|->
name|status_tx_quick_consumer_index0
operator|==
name|sc
operator|->
name|hw_tx_cons
operator|)
condition|)
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|status_tag
argument_list|,
name|sc
operator|->
name|status_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_INDEX_VALID
operator||
name|sc
operator|->
name|last_status_idx
operator||
name|BCE_PCICFG_INT_ACK_CMD_MASK_INT
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD
argument_list|,
name|BCE_PCICFG_INT_ACK_CMD_INDEX_VALID
operator||
name|sc
operator|->
name|last_status_idx
argument_list|)
expr_stmt|;
comment|/* Handle any frames that arrived while handling the interrupt. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|bce_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bce_intr_exit
label|:
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Programs the various packet receive modes (broadcast and multicast).     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_set_rx_mode
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u32
name|hashes
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u32
name|rx_mode
decl_stmt|,
name|sort_mode
decl_stmt|;
name|int
name|h
decl_stmt|,
name|i
decl_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
comment|/* Initialize receive mode default settings. */
name|rx_mode
operator|=
name|sc
operator|->
name|rx_mode
operator|&
operator|~
operator|(
name|BCE_EMAC_RX_MODE_PROMISCUOUS
operator||
name|BCE_EMAC_RX_MODE_KEEP_VLAN_TAG
operator|)
expr_stmt|;
name|sort_mode
operator|=
literal|1
operator||
name|BCE_RPM_SORT_USER0_BC_EN
expr_stmt|;
comment|/* 	 * ASF/IPMI/UMP firmware requires that VLAN tag stripping 	 * be enbled. 	 */
if|if
condition|(
operator|!
operator|(
name|BCE_IF_CAPABILITIES
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|&&
operator|(
operator|!
operator|(
name|sc
operator|->
name|bce_flags
operator|&
name|BCE_MFW_ENABLE_FLAG
operator|)
operator|)
condition|)
name|rx_mode
operator||=
name|BCE_EMAC_RX_MODE_KEEP_VLAN_TAG
expr_stmt|;
comment|/* 	 * Check for promiscuous, all multicast, or selected 	 * multicast address filtering. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Enabling promiscuous mode.\n"
argument_list|)
expr_stmt|;
comment|/* Enable promiscuous mode. */
name|rx_mode
operator||=
name|BCE_EMAC_RX_MODE_PROMISCUOUS
expr_stmt|;
name|sort_mode
operator||=
name|BCE_RPM_SORT_USER0_PROM_EN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Enabling all multicast mode.\n"
argument_list|)
expr_stmt|;
comment|/* Enable all multicast addresses. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MC_HASH_REGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MULTICAST_HASH0
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
name|sort_mode
operator||=
name|BCE_RPM_SORT_USER0_MC_EN
expr_stmt|;
block|}
else|else
block|{
comment|/* Accept one or more multicast(s). */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_INFO
argument_list|,
literal|"Enabling selective multicast mode.\n"
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|h
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&
literal|0x7F
expr_stmt|;
name|hashes
index|[
operator|(
name|h
operator|&
literal|0x60
operator|)
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|h
operator|&
literal|0x1F
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_MULTICAST_HASH0
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
name|hashes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sort_mode
operator||=
name|BCE_RPM_SORT_USER0_MC_HSH_EN
expr_stmt|;
block|}
comment|/* Only make changes if the recive mode has actually changed. */
if|if
condition|(
name|rx_mode
operator|!=
name|sc
operator|->
name|rx_mode
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_VERBOSE
argument_list|,
literal|"Enabling new receive mode: 0x%08X\n"
argument_list|,
name|rx_mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mode
operator|=
name|rx_mode
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_RX_MODE
argument_list|,
name|rx_mode
argument_list|)
expr_stmt|;
block|}
comment|/* Disable and clear the exisitng sort before enabling a new sort. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_SORT_USER0
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_SORT_USER0
argument_list|,
name|sort_mode
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_SORT_USER0
argument_list|,
name|sort_mode
operator||
name|BCE_RPM_SORT_USER0_ENA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Called periodically to updates statistics from the controllers           */
end_comment

begin_comment
comment|/* statistics block.                                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_stats_update
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|statistics_block
modifier|*
name|stats
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXCESSIVE
argument_list|,
literal|"Entering %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|statistics_block
operator|*
operator|)
name|sc
operator|->
name|stats_block
expr_stmt|;
comment|/*  	 * Update the interface statistics from the 	 * hardware statistics. 	 */
name|ifp
operator|->
name|if_collisions
operator|=
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_EtherStatsCollisions
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|=
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_EtherStatsUndersizePkts
operator|+
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_EtherStatsOverrsizePkts
operator|+
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_IfInMBUFDiscards
operator|+
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_Dot3StatsAlignmentErrors
operator|+
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_Dot3StatsFCSErrors
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|=
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
operator|+
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_Dot3StatsExcessiveCollisions
operator|+
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_Dot3StatsLateCollisions
expr_stmt|;
comment|/*  	 * Certain controllers don't report  	 * carrier sense errors correctly. 	 * See errata E11_5708CA0_1165.  	 */
if|if
condition|(
operator|!
operator|(
name|BCE_CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_NUM_5706
operator|)
operator|&&
operator|!
operator|(
name|BCE_CHIP_ID
argument_list|(
name|sc
argument_list|)
operator|==
name|BCE_CHIP_ID_5708_A0
operator|)
condition|)
name|ifp
operator|->
name|if_oerrors
operator|+=
operator|(
name|u_long
operator|)
name|stats
operator|->
name|stat_Dot3StatsCarrierSenseErrors
expr_stmt|;
comment|/* 	 * Update the sysctl statistics from the 	 * hardware statistics. 	 */
name|sc
operator|->
name|stat_IfHCInOctets
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInOctets_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInOctets_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCInBadOctets
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInBadOctets_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInBadOctets_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutOctets
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutOctets_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutOctets_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutBadOctets
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutBadOctets_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutBadOctets_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCInUcastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInUcastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInUcastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCInMulticastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInMulticastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInMulticastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCInBroadcastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInBroadcastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCInBroadcastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutUcastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutUcastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutUcastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutMulticastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutMulticastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutMulticastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_IfHCOutBroadcastPkts
operator|=
operator|(
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutBroadcastPkts_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|stats
operator|->
name|stat_IfHCOutBroadcastPkts_lo
expr_stmt|;
name|sc
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
operator|=
name|stats
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsCarrierSenseErrors
operator|=
name|stats
operator|->
name|stat_Dot3StatsCarrierSenseErrors
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsFCSErrors
operator|=
name|stats
operator|->
name|stat_Dot3StatsFCSErrors
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsAlignmentErrors
operator|=
name|stats
operator|->
name|stat_Dot3StatsAlignmentErrors
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsSingleCollisionFrames
operator|=
name|stats
operator|->
name|stat_Dot3StatsSingleCollisionFrames
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsMultipleCollisionFrames
operator|=
name|stats
operator|->
name|stat_Dot3StatsMultipleCollisionFrames
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsDeferredTransmissions
operator|=
name|stats
operator|->
name|stat_Dot3StatsDeferredTransmissions
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsExcessiveCollisions
operator|=
name|stats
operator|->
name|stat_Dot3StatsExcessiveCollisions
expr_stmt|;
name|sc
operator|->
name|stat_Dot3StatsLateCollisions
operator|=
name|stats
operator|->
name|stat_Dot3StatsLateCollisions
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsCollisions
operator|=
name|stats
operator|->
name|stat_EtherStatsCollisions
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsFragments
operator|=
name|stats
operator|->
name|stat_EtherStatsFragments
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsJabbers
operator|=
name|stats
operator|->
name|stat_EtherStatsJabbers
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsUndersizePkts
operator|=
name|stats
operator|->
name|stat_EtherStatsUndersizePkts
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsOverrsizePkts
operator|=
name|stats
operator|->
name|stat_EtherStatsOverrsizePkts
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx64Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx64Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx65Octetsto127Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx65Octetsto127Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx128Octetsto255Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx128Octetsto255Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx256Octetsto511Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx256Octetsto511Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx512Octetsto1023Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx512Octetsto1023Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx64Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx64Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx65Octetsto127Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx65Octetsto127Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx128Octetsto255Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx128Octetsto255Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx256Octetsto511Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx256Octetsto511Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx512Octetsto1023Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx512Octetsto1023Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
expr_stmt|;
name|sc
operator|->
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
operator|=
name|stats
operator|->
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
expr_stmt|;
name|sc
operator|->
name|stat_XonPauseFramesReceived
operator|=
name|stats
operator|->
name|stat_XonPauseFramesReceived
expr_stmt|;
name|sc
operator|->
name|stat_XoffPauseFramesReceived
operator|=
name|stats
operator|->
name|stat_XoffPauseFramesReceived
expr_stmt|;
name|sc
operator|->
name|stat_OutXonSent
operator|=
name|stats
operator|->
name|stat_OutXonSent
expr_stmt|;
name|sc
operator|->
name|stat_OutXoffSent
operator|=
name|stats
operator|->
name|stat_OutXoffSent
expr_stmt|;
name|sc
operator|->
name|stat_FlowControlDone
operator|=
name|stats
operator|->
name|stat_FlowControlDone
expr_stmt|;
name|sc
operator|->
name|stat_MacControlFramesReceived
operator|=
name|stats
operator|->
name|stat_MacControlFramesReceived
expr_stmt|;
name|sc
operator|->
name|stat_XoffStateEntered
operator|=
name|stats
operator|->
name|stat_XoffStateEntered
expr_stmt|;
name|sc
operator|->
name|stat_IfInFramesL2FilterDiscards
operator|=
name|stats
operator|->
name|stat_IfInFramesL2FilterDiscards
expr_stmt|;
name|sc
operator|->
name|stat_IfInRuleCheckerDiscards
operator|=
name|stats
operator|->
name|stat_IfInRuleCheckerDiscards
expr_stmt|;
name|sc
operator|->
name|stat_IfInFTQDiscards
operator|=
name|stats
operator|->
name|stat_IfInFTQDiscards
expr_stmt|;
name|sc
operator|->
name|stat_IfInMBUFDiscards
operator|=
name|stats
operator|->
name|stat_IfInMBUFDiscards
expr_stmt|;
name|sc
operator|->
name|stat_IfInRuleCheckerP4Hit
operator|=
name|stats
operator|->
name|stat_IfInRuleCheckerP4Hit
expr_stmt|;
name|sc
operator|->
name|stat_CatchupInRuleCheckerDiscards
operator|=
name|stats
operator|->
name|stat_CatchupInRuleCheckerDiscards
expr_stmt|;
name|sc
operator|->
name|stat_CatchupInFTQDiscards
operator|=
name|stats
operator|->
name|stat_CatchupInFTQDiscards
expr_stmt|;
name|sc
operator|->
name|stat_CatchupInMBUFDiscards
operator|=
name|stats
operator|->
name|stat_CatchupInMBUFDiscards
expr_stmt|;
name|sc
operator|->
name|stat_CatchupInRuleCheckerP4Hit
operator|=
name|stats
operator|->
name|stat_CatchupInRuleCheckerP4Hit
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BCE_EXCESSIVE
argument_list|,
literal|"Exiting %s()\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_tick_locked
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|msg
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bce_ifp
expr_stmt|;
name|BCE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Tell the firmware that the driver is still running. */
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|msg
operator|=
operator|(
name|u32
operator|)
name|BCE_DRV_MSG_DATA_PULSE_CODE_ALWAYS_ALIVE
expr_stmt|;
else|#
directive|else
name|msg
operator|=
operator|(
name|u32
operator|)
operator|++
name|sc
operator|->
name|bce_fw_drv_pulse_wr_seq
expr_stmt|;
endif|#
directive|endif
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|bce_shmem_base
operator|+
name|BCE_DRV_PULSE_MB
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Update the statistics from the hardware statistics block. */
name|bce_stats_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Schedule the next tick. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|bce_stat_ch
argument_list|,
comment|/* callout */
name|hz
argument_list|,
comment|/* ticks */
name|bce_tick
argument_list|,
comment|/* function */
name|sc
argument_list|)
expr_stmt|;
comment|/* function argument */
comment|/* If link is up already up then we're done. */
if|if
condition|(
name|sc
operator|->
name|bce_link
condition|)
goto|goto
name|bce_tick_locked_exit
goto|;
comment|/* DRC - ToDo: Add SerDes support and check SerDes link here. */
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|bce_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
comment|/* Check if the link has come up. */
if|if
condition|(
operator|!
name|sc
operator|->
name|bce_link
operator|&&
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
operator|&&
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|!=
name|IFM_NONE
condition|)
block|{
name|sc
operator|->
name|bce_link
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_1000_T
operator|||
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_1000_SX
operator|)
operator|&&
name|bootverbose
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"Gigabit link up\n"
argument_list|)
expr_stmt|;
comment|/* Now that link is up, handle any outstanding TX traffic. */
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|bce_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|bce_tick_locked_exit
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|BCE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_tick_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allows the driver state to be dumped through the sysctl interface.       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_driver_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Allows the hardware state to be dumped through the sysctl interface.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_hw_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_hw_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_dump_rx_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_dump_rx_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bce_sysctl_breakpoint
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|bce_softc
modifier|*
name|sc
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bce_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bce_breakpoint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Adds any sysctl parameters for tuning or debugging purposes.             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   0 for success, positive value for failure.                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_add_sysctls
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|bce_dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|bce_driver_version
argument_list|,
literal|0
argument_list|,
literal|"bce driver version"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_low_watermark"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|rx_low_watermark
argument_list|,
literal|0
argument_list|,
literal|"Lowest level of free rx_bd's"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_hi_watermark"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx_hi_watermark
argument_list|,
literal|0
argument_list|,
literal|"Highest level of used tx_bd's"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"l2fhdr_status_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|l2fhdr_status_errors
argument_list|,
literal|0
argument_list|,
literal|"l2_fhdr status errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"unexpected_attentions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|unexpected_attentions
argument_list|,
literal|0
argument_list|,
literal|"unexpected attentions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lost_status_block_updates"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|lost_status_block_updates
argument_list|,
literal|0
argument_list|,
literal|"lost status block updates"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_alloc_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|mbuf_alloc_failed
argument_list|,
literal|0
argument_list|,
literal|"mbuf cluster allocation failures"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHcInOctets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInOctets
argument_list|,
literal|"Bytes received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCInBadOctets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInBadOctets
argument_list|,
literal|"Bad bytes received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutOctets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutOctets
argument_list|,
literal|"Bytes sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutBadOctets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutBadOctets
argument_list|,
literal|"Bad bytes sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCInUcastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInUcastPkts
argument_list|,
literal|"Unicast packets received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCInMulticastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInMulticastPkts
argument_list|,
literal|"Multicast packets received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCInBroadcastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCInBroadcastPkts
argument_list|,
literal|"Broadcast packets received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutUcastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutUcastPkts
argument_list|,
literal|"Unicast packets sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutMulticastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutMulticastPkts
argument_list|,
literal|"Multicast packets sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfHCOutBroadcastPkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfHCOutBroadcastPkts
argument_list|,
literal|"Broadcast packets sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_emac_tx_stat_dot3statsinternalmactransmiterrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
argument_list|,
literal|0
argument_list|,
literal|"Internal MAC transmit errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsCarrierSenseErrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsCarrierSenseErrors
argument_list|,
literal|0
argument_list|,
literal|"Carrier sense errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsFCSErrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsFCSErrors
argument_list|,
literal|0
argument_list|,
literal|"Frame check sequence errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsAlignmentErrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsAlignmentErrors
argument_list|,
literal|0
argument_list|,
literal|"Alignment errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsSingleCollisionFrames"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsSingleCollisionFrames
argument_list|,
literal|0
argument_list|,
literal|"Single Collision Frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsMultipleCollisionFrames"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsMultipleCollisionFrames
argument_list|,
literal|0
argument_list|,
literal|"Multiple Collision Frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsDeferredTransmissions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsDeferredTransmissions
argument_list|,
literal|0
argument_list|,
literal|"Deferred Transmissions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsExcessiveCollisions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsExcessiveCollisions
argument_list|,
literal|0
argument_list|,
literal|"Excessive Collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_Dot3StatsLateCollisions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_Dot3StatsLateCollisions
argument_list|,
literal|0
argument_list|,
literal|"Late Collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsCollisions"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsCollisions
argument_list|,
literal|0
argument_list|,
literal|"Collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsFragments"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsFragments
argument_list|,
literal|0
argument_list|,
literal|"Fragments"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsJabbers"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsJabbers
argument_list|,
literal|0
argument_list|,
literal|"Jabbers"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsUndersizePkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsUndersizePkts
argument_list|,
literal|0
argument_list|,
literal|"Undersize packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsOverrsizePkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsOverrsizePkts
argument_list|,
literal|0
argument_list|,
literal|"stat_EtherStatsOverrsizePkts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx64Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx64Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 64 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx65Octetsto127Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx65Octetsto127Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 65 to 127 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx128Octetsto255Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx128Octetsto255Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 128 to 255 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx256Octetsto511Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx256Octetsto511Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 256 to 511 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx512Octetsto1023Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx512Octetsto1023Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 512 to 1023 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx1024Octetsto1522Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 1024 t0 1522 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsRx1523Octetsto9022Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes received in 1523 to 9022 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx64Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx64Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 64 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx65Octetsto127Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx65Octetsto127Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 65 to 127 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx128Octetsto255Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx128Octetsto255Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 128 to 255 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx256Octetsto511Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx256Octetsto511Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 256 to 511 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx512Octetsto1023Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx512Octetsto1023Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 512 to 1023 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx1024Octetsto1522Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 1024 to 1522 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_EtherStatsPktsTx1523Octetsto9022Octets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
argument_list|,
literal|0
argument_list|,
literal|"Bytes sent in 1523 to 9022 byte packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_XonPauseFramesReceived"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_XonPauseFramesReceived
argument_list|,
literal|0
argument_list|,
literal|"XON pause frames receved"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_XoffPauseFramesReceived"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_XoffPauseFramesReceived
argument_list|,
literal|0
argument_list|,
literal|"XOFF pause frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_OutXonSent"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_OutXonSent
argument_list|,
literal|0
argument_list|,
literal|"XON pause frames sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_OutXoffSent"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_OutXoffSent
argument_list|,
literal|0
argument_list|,
literal|"XOFF pause frames sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_FlowControlDone"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_FlowControlDone
argument_list|,
literal|0
argument_list|,
literal|"Flow control done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_MacControlFramesReceived"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_MacControlFramesReceived
argument_list|,
literal|0
argument_list|,
literal|"MAC control frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_XoffStateEntered"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_XoffStateEntered
argument_list|,
literal|0
argument_list|,
literal|"XOFF state entered"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInFramesL2FilterDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInFramesL2FilterDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received L2 packets discarded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInRuleCheckerDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInRuleCheckerDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded by rule"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInFTQDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInFTQDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packet FTQ discards"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInMBUFDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInMBUFDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded due to lack of controller buffer memory"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_IfInRuleCheckerP4Hit"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_IfInRuleCheckerP4Hit
argument_list|,
literal|0
argument_list|,
literal|"Received packets rule checker hits"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_CatchupInRuleCheckerDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_CatchupInRuleCheckerDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded in Catchup path"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_CatchupInFTQDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_CatchupInFTQDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded in FTQ in Catchup path"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_CatchupInMBUFDiscards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_CatchupInMBUFDiscards
argument_list|,
literal|0
argument_list|,
literal|"Received packets discarded in controller buffer memory in Catchup path"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stat_CatchupInRuleCheckerP4Hit"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|stat_CatchupInRuleCheckerP4Hit
argument_list|,
literal|0
argument_list|,
literal|"Received packets rule checker hits in Catchup path"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCE_DEBUG
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_driver_state
argument_list|,
literal|"I"
argument_list|,
literal|"Drive state information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_hw_state
argument_list|,
literal|"I"
argument_list|,
literal|"Hardware state information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_rx_chain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_dump_rx_chain
argument_list|,
literal|"I"
argument_list|,
literal|"Dump rx_bd chain"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"breakpoint"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bce_sysctl_breakpoint
argument_list|,
literal|"I"
argument_list|,
literal|"Driver breakpoint"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* BCE Debug Routines                                                       */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BCE_DEBUG
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out information about an mbuf.                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_dump_mbuf
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|u32
name|val_hi
decl_stmt|,
name|val_lo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
init|=
name|m
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* Index out of range. */
name|printf
argument_list|(
literal|"mbuf ptr is null!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|mp
condition|)
block|{
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"mbuf: vaddr = 0x%08X:%08X, m_len = %d, m_flags = "
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|,
name|mp
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|printf
argument_list|(
literal|"M_EXT "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|printf
argument_list|(
literal|"M_PKTHDR "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|mp
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|mp
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"- m_ext: vaddr = 0x%08X:%08X, ext_size = 0x%04X\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|,
name|mp
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|)
expr_stmt|;
block|}
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* Prints out the mbufs in the TX mbuf chain.                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns:                                                                 */
end_comment

begin_comment
comment|/*   Nothing.                                                               */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bce_dump_tx_mbuf_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chain_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"  tx mbuf data  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|tx_mbuf_ptr
index|[
name|chain_prod
index|]
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"txmbuf[%d]\n"
argument_list|,
name|chain_prod
argument_list|)
expr_stmt|;
name|bce_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|chain_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|NEXT_TX_BD
argument_list|(
name|chain_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine prints the RX mbuf chain.  */
end_comment

begin_function
specifier|static
name|void
name|bce_dump_rx_mbuf_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chain_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"  rx mbuf data  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|rx_mbuf_ptr
index|[
name|chain_prod
index|]
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rxmbuf[0x%04X]\n"
argument_list|,
name|chain_prod
argument_list|)
expr_stmt|;
name|bce_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|chain_prod
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|NEXT_RX_BD
argument_list|(
name|chain_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_dump_txbd
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|tx_bd
modifier|*
name|txbd
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>
name|MAX_TX_BD
condition|)
comment|/* Index out of range. */
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"tx_bd[0x%04X]: Invalid tx_bd index!\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|idx
operator|&
name|USABLE_TX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_TX_BD_PER_PAGE
condition|)
comment|/* TX Chain page pointer. */
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"tx_bd[0x%04X]: haddr = 0x%08X:%08X, chain page pointer\n"
argument_list|,
name|idx
argument_list|,
name|txbd
operator|->
name|tx_bd_haddr_hi
argument_list|,
name|txbd
operator|->
name|tx_bd_haddr_lo
argument_list|)
expr_stmt|;
else|else
comment|/* Normal tx_bd entry. */
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"tx_bd[0x%04X]: haddr = 0x%08X:%08X, nbytes = 0x%08X, "
literal|"flags = 0x%08X\n"
argument_list|,
name|idx
argument_list|,
name|txbd
operator|->
name|tx_bd_haddr_hi
argument_list|,
name|txbd
operator|->
name|tx_bd_haddr_lo
argument_list|,
name|txbd
operator|->
name|tx_bd_mss_nbytes
argument_list|,
name|txbd
operator|->
name|tx_bd_vlan_tag_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_dump_rxbd
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|rx_bd
modifier|*
name|rxbd
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>
name|MAX_RX_BD
condition|)
comment|/* Index out of range. */
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_bd[0x%04X]: Invalid rx_bd index!\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|idx
operator|&
name|USABLE_RX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_RX_BD_PER_PAGE
condition|)
comment|/* TX Chain page pointer. */
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_bd[0x%04X]: haddr = 0x%08X:%08X, chain page pointer\n"
argument_list|,
name|idx
argument_list|,
name|rxbd
operator|->
name|rx_bd_haddr_hi
argument_list|,
name|rxbd
operator|->
name|rx_bd_haddr_lo
argument_list|)
expr_stmt|;
else|else
comment|/* Normal tx_bd entry. */
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_bd[0x%04X]: haddr = 0x%08X:%08X, nbytes = 0x%08X, "
literal|"flags = 0x%08X\n"
argument_list|,
name|idx
argument_list|,
name|rxbd
operator|->
name|rx_bd_haddr_hi
argument_list|,
name|rxbd
operator|->
name|rx_bd_haddr_lo
argument_list|,
name|rxbd
operator|->
name|rx_bd_len
argument_list|,
name|rxbd
operator|->
name|rx_bd_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_dump_l2fhdr
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|l2_fhdr
modifier|*
name|l2fhdr
parameter_list|)
block|{
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"l2_fhdr[0x%04X]: status = 0x%08X, "
literal|"pkt_len = 0x%04X, vlan = 0x%04x, ip_xsum = 0x%04X, "
literal|"tcp_udp_xsum = 0x%04X\n"
argument_list|,
name|idx
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_status
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_pkt_len
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_vlan_tag
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_ip_xsum
argument_list|,
name|l2fhdr
operator|->
name|l2_fhdr_tcp_udp_xsum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine prints the TX chain.  */
end_comment

begin_function
specifier|static
name|void
name|bce_dump_tx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|tx_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|tx_bd
modifier|*
name|txbd
decl_stmt|;
comment|/* First some info about the tx_bd chain structure. */
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"  tx_bd  chain  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"page size      = 0x%08X, tx chain pages        = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|BCM_PAGE_SIZE
argument_list|,
operator|(
name|u32
operator|)
name|TX_PAGES
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"tx_bd per page = 0x%08X, usable tx_bd per page = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_TX_BD_PER_PAGE
argument_list|,
operator|(
name|u32
operator|)
name|USABLE_TX_BD_PER_PAGE
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"total tx_bd    = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_TX_BD
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|""
literal|"-----------------------------"
literal|"   tx_bd data   "
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Now print out the tx_bd's themselves. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|txbd
operator|=
operator|&
name|sc
operator|->
name|tx_bd_chain
index|[
name|TX_PAGE
argument_list|(
name|tx_prod
argument_list|)
index|]
index|[
name|TX_IDX
argument_list|(
name|tx_prod
argument_list|)
index|]
expr_stmt|;
name|bce_dump_txbd
argument_list|(
name|sc
argument_list|,
name|tx_prod
argument_list|,
name|txbd
argument_list|)
expr_stmt|;
name|tx_prod
operator|=
name|TX_CHAIN_IDX
argument_list|(
name|NEXT_TX_BD
argument_list|(
name|tx_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"-----------------------------"
literal|"--------------"
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine prints the RX chain.  */
end_comment

begin_function
specifier|static
name|void
name|bce_dump_rx_chain
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|,
name|int
name|rx_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|rx_bd
modifier|*
name|rxbd
decl_stmt|;
comment|/* First some info about the tx_bd chain structure. */
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"  rx_bd  chain  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----- RX_BD Chain -----\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"page size      = 0x%08X, rx chain pages        = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|BCM_PAGE_SIZE
argument_list|,
operator|(
name|u32
operator|)
name|RX_PAGES
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_bd per page = 0x%08X, usable rx_bd per page = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_RX_BD_PER_PAGE
argument_list|,
operator|(
name|u32
operator|)
name|USABLE_RX_BD_PER_PAGE
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"total rx_bd    = 0x%08X\n"
argument_list|,
operator|(
name|u32
operator|)
name|TOTAL_RX_BD
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"   rx_bd data   "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Now print out the rx_bd's themselves. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rxbd
operator|=
operator|&
name|sc
operator|->
name|rx_bd_chain
index|[
name|RX_PAGE
argument_list|(
name|rx_prod
argument_list|)
index|]
index|[
name|RX_IDX
argument_list|(
name|rx_prod
argument_list|)
index|]
expr_stmt|;
name|bce_dump_rxbd
argument_list|(
name|sc
argument_list|,
name|rx_prod
argument_list|,
name|rxbd
argument_list|)
expr_stmt|;
name|rx_prod
operator|=
name|RX_CHAIN_IDX
argument_list|(
name|NEXT_RX_BD
argument_list|(
name|rx_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"--------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine prints the status block.  */
end_comment

begin_function
specifier|static
name|void
name|bce_dump_status_block
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|status_block
modifier|*
name|sblk
decl_stmt|;
name|sblk
operator|=
name|sc
operator|->
name|status_block
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------- Status Block "
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"attn_bits  = 0x%08X, attn_bits_ack = 0x%08X, index = 0x%04X\n"
argument_list|,
name|sblk
operator|->
name|status_attn_bits
argument_list|,
name|sblk
operator|->
name|status_attn_bits_ack
argument_list|,
name|sblk
operator|->
name|status_idx
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons0   = 0x%08X, tx_cons0      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index0
argument_list|,
name|sblk
operator|->
name|status_tx_quick_consumer_index0
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"status_idx = 0x%04X\n"
argument_list|,
name|sblk
operator|->
name|status_idx
argument_list|)
expr_stmt|;
comment|/* Theses indices are not used for normal L2 drivers. */
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index1
operator|||
name|sblk
operator|->
name|status_tx_quick_consumer_index1
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons1  = 0x%08X, tx_cons1      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index1
argument_list|,
name|sblk
operator|->
name|status_tx_quick_consumer_index1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index2
operator|||
name|sblk
operator|->
name|status_tx_quick_consumer_index2
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons2  = 0x%08X, tx_cons2      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index2
argument_list|,
name|sblk
operator|->
name|status_tx_quick_consumer_index2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index3
operator|||
name|sblk
operator|->
name|status_tx_quick_consumer_index3
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons3  = 0x%08X, tx_cons3      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index3
argument_list|,
name|sblk
operator|->
name|status_tx_quick_consumer_index3
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index4
operator|||
name|sblk
operator|->
name|status_rx_quick_consumer_index5
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons4  = 0x%08X, rx_cons5      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index4
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index5
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index6
operator|||
name|sblk
operator|->
name|status_rx_quick_consumer_index7
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons6  = 0x%08X, rx_cons7      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index6
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index7
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index8
operator|||
name|sblk
operator|->
name|status_rx_quick_consumer_index9
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons8  = 0x%08X, rx_cons9      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index8
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index9
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index10
operator|||
name|sblk
operator|->
name|status_rx_quick_consumer_index11
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons10 = 0x%08X, rx_cons11     = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index10
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index11
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index12
operator|||
name|sblk
operator|->
name|status_rx_quick_consumer_index13
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons12 = 0x%08X, rx_cons13     = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index12
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index13
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_rx_quick_consumer_index14
operator|||
name|sblk
operator|->
name|status_rx_quick_consumer_index15
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"rx_cons14 = 0x%08X, rx_cons15     = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index14
argument_list|,
name|sblk
operator|->
name|status_rx_quick_consumer_index15
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|status_completion_producer_index
operator|||
name|sblk
operator|->
name|status_cmd_consumer_index
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"com_prod  = 0x%08X, cmd_cons      = 0x%08X\n"
argument_list|,
name|sblk
operator|->
name|status_completion_producer_index
argument_list|,
name|sblk
operator|->
name|status_cmd_consumer_index
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"-------------------------------------------"
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine prints the statistics block.  */
end_comment

begin_function
specifier|static
name|void
name|bce_dump_stats_block
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|statistics_block
modifier|*
name|sblk
decl_stmt|;
name|sblk
operator|=
name|sc
operator|->
name|stats_block
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|""
literal|"-----------------------------"
literal|" Stats  Block "
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"IfHcInOctets         = 0x%08X:%08X, "
literal|"IfHcInBadOctets      = 0x%08X:%08X\n"
argument_list|,
name|sblk
operator|->
name|stat_IfHCInOctets_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCInOctets_lo
argument_list|,
name|sblk
operator|->
name|stat_IfHCInBadOctets_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCInBadOctets_lo
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"IfHcOutOctets        = 0x%08X:%08X, "
literal|"IfHcOutBadOctets     = 0x%08X:%08X\n"
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutOctets_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutOctets_lo
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutBadOctets_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutBadOctets_lo
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"IfHcInUcastPkts      = 0x%08X:%08X, "
literal|"IfHcInMulticastPkts  = 0x%08X:%08X\n"
argument_list|,
name|sblk
operator|->
name|stat_IfHCInUcastPkts_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCInUcastPkts_lo
argument_list|,
name|sblk
operator|->
name|stat_IfHCInMulticastPkts_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCInMulticastPkts_lo
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"IfHcInBroadcastPkts  = 0x%08X:%08X, "
literal|"IfHcOutUcastPkts     = 0x%08X:%08X\n"
argument_list|,
name|sblk
operator|->
name|stat_IfHCInBroadcastPkts_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCInBroadcastPkts_lo
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutUcastPkts_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutUcastPkts_lo
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"IfHcOutMulticastPkts = 0x%08X:%08X, IfHcOutBroadcastPkts = 0x%08X:%08X\n"
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutMulticastPkts_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutMulticastPkts_lo
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutBroadcastPkts_hi
argument_list|,
name|sblk
operator|->
name|stat_IfHCOutBroadcastPkts_lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : "
literal|"emac_tx_stat_dot3statsinternalmactransmiterrors\n"
argument_list|,
name|sblk
operator|->
name|stat_emac_tx_stat_dot3statsinternalmactransmiterrors
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_Dot3StatsCarrierSenseErrors
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : Dot3StatsCarrierSenseErrors\n"
argument_list|,
name|sblk
operator|->
name|stat_Dot3StatsCarrierSenseErrors
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_Dot3StatsFCSErrors
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : Dot3StatsFCSErrors\n"
argument_list|,
name|sblk
operator|->
name|stat_Dot3StatsFCSErrors
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_Dot3StatsAlignmentErrors
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : Dot3StatsAlignmentErrors\n"
argument_list|,
name|sblk
operator|->
name|stat_Dot3StatsAlignmentErrors
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_Dot3StatsSingleCollisionFrames
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : Dot3StatsSingleCollisionFrames\n"
argument_list|,
name|sblk
operator|->
name|stat_Dot3StatsSingleCollisionFrames
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_Dot3StatsMultipleCollisionFrames
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : Dot3StatsMultipleCollisionFrames\n"
argument_list|,
name|sblk
operator|->
name|stat_Dot3StatsMultipleCollisionFrames
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_Dot3StatsDeferredTransmissions
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : Dot3StatsDeferredTransmissions\n"
argument_list|,
name|sblk
operator|->
name|stat_Dot3StatsDeferredTransmissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_Dot3StatsExcessiveCollisions
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : Dot3StatsExcessiveCollisions\n"
argument_list|,
name|sblk
operator|->
name|stat_Dot3StatsExcessiveCollisions
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_Dot3StatsLateCollisions
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : Dot3StatsLateCollisions\n"
argument_list|,
name|sblk
operator|->
name|stat_Dot3StatsLateCollisions
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsCollisions
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsCollisions\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsCollisions
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsFragments
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsFragments\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsFragments
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsJabbers
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsJabbers\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsJabbers
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsUndersizePkts
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsUndersizePkts\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsUndersizePkts
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsOverrsizePkts
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsOverrsizePkts\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsOverrsizePkts
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsRx64Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsRx64Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsRx64Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsRx65Octetsto127Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsRx65Octetsto127Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsRx65Octetsto127Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsRx128Octetsto255Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsRx128Octetsto255Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsRx128Octetsto255Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsRx256Octetsto511Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsRx256Octetsto511Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsRx256Octetsto511Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsRx512Octetsto1023Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsRx512Octetsto1023Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsRx512Octetsto1023Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsRx1024Octetsto1522Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsRx1024Octetsto1522Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsRx1523Octetsto9022Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsRx1523Octetsto9022Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsTx64Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsTx64Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsTx64Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsTx65Octetsto127Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsTx65Octetsto127Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsTx65Octetsto127Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsTx128Octetsto255Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsTx128Octetsto255Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsTx128Octetsto255Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsTx256Octetsto511Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsTx256Octetsto511Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsTx256Octetsto511Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsTx512Octetsto1023Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsTx512Octetsto1023Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsTx512Octetsto1023Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsTx1024Octetsto1522Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsTx1024Octetsto1522Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : EtherStatsPktsTx1523Octetsto9022Octets\n"
argument_list|,
name|sblk
operator|->
name|stat_EtherStatsPktsTx1523Octetsto9022Octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_XonPauseFramesReceived
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : XonPauseFramesReceived\n"
argument_list|,
name|sblk
operator|->
name|stat_XonPauseFramesReceived
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_XoffPauseFramesReceived
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : XoffPauseFramesReceived\n"
argument_list|,
name|sblk
operator|->
name|stat_XoffPauseFramesReceived
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_OutXonSent
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : OutXonSent\n"
argument_list|,
name|sblk
operator|->
name|stat_OutXonSent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_OutXoffSent
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : OutXoffSent\n"
argument_list|,
name|sblk
operator|->
name|stat_OutXoffSent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_FlowControlDone
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : FlowControlDone\n"
argument_list|,
name|sblk
operator|->
name|stat_FlowControlDone
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_MacControlFramesReceived
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : MacControlFramesReceived\n"
argument_list|,
name|sblk
operator|->
name|stat_MacControlFramesReceived
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_XoffStateEntered
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : XoffStateEntered\n"
argument_list|,
name|sblk
operator|->
name|stat_XoffStateEntered
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_IfInFramesL2FilterDiscards
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : IfInFramesL2FilterDiscards\n"
argument_list|,
name|sblk
operator|->
name|stat_IfInFramesL2FilterDiscards
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_IfInRuleCheckerDiscards
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : IfInRuleCheckerDiscards\n"
argument_list|,
name|sblk
operator|->
name|stat_IfInRuleCheckerDiscards
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_IfInFTQDiscards
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : IfInFTQDiscards\n"
argument_list|,
name|sblk
operator|->
name|stat_IfInFTQDiscards
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_IfInMBUFDiscards
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : IfInMBUFDiscards\n"
argument_list|,
name|sblk
operator|->
name|stat_IfInMBUFDiscards
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_IfInRuleCheckerP4Hit
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : IfInRuleCheckerP4Hit\n"
argument_list|,
name|sblk
operator|->
name|stat_IfInRuleCheckerP4Hit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_CatchupInRuleCheckerDiscards
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : CatchupInRuleCheckerDiscards\n"
argument_list|,
name|sblk
operator|->
name|stat_CatchupInRuleCheckerDiscards
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_CatchupInFTQDiscards
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : CatchupInFTQDiscards\n"
argument_list|,
name|sblk
operator|->
name|stat_CatchupInFTQDiscards
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_CatchupInMBUFDiscards
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : CatchupInMBUFDiscards\n"
argument_list|,
name|sblk
operator|->
name|stat_CatchupInMBUFDiscards
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|->
name|stat_CatchupInRuleCheckerP4Hit
condition|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : CatchupInRuleCheckerP4Hit\n"
argument_list|,
name|sblk
operator|->
name|stat_CatchupInRuleCheckerP4Hit
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"-----------------------------"
literal|"--------------"
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_dump_driver_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val_hi
decl_stmt|,
name|val_lo
decl_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"-----------------------------"
literal|" Driver State "
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X:%08X - (sc) driver softc structure virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|bce_vhandle
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|bce_vhandle
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X:%08X - (sc->bce_vhandle) PCI BAR virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|status_block
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|status_block
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X:%08X - (sc->status_block) status block virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|stats_block
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|stats_block
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X:%08X - (sc->stats_block) statistics block virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_bd_chain
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_bd_chain
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X:%08X - (sc->tx_bd_chain) tx_bd chain virtual adddress\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|rx_bd_chain
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|rx_bd_chain
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X:%08X - (sc->rx_bd_chain) rx_bd chain virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|tx_mbuf_ptr
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|tx_mbuf_ptr
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X:%08X - (sc->tx_mbuf_ptr) tx mbuf chain virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|BCE_ADDR_HI
argument_list|(
name|sc
operator|->
name|rx_mbuf_ptr
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|BCE_ADDR_LO
argument_list|(
name|sc
operator|->
name|rx_mbuf_ptr
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X:%08X - (sc->rx_mbuf_ptr) rx mbuf chain virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->interrupts_generated) h/w intrs\n"
argument_list|,
name|sc
operator|->
name|interrupts_generated
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->rx_interrupts) rx interrupts handled\n"
argument_list|,
name|sc
operator|->
name|rx_interrupts
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->tx_interrupts) tx interrupts handled\n"
argument_list|,
name|sc
operator|->
name|tx_interrupts
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->last_status_idx) status block index\n"
argument_list|,
name|sc
operator|->
name|last_status_idx
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->tx_prod) tx producer index\n"
argument_list|,
name|sc
operator|->
name|tx_prod
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->tx_cons) tx consumer index\n"
argument_list|,
name|sc
operator|->
name|tx_cons
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->tx_prod_bseq) tx producer bseq index\n"
argument_list|,
name|sc
operator|->
name|tx_prod_bseq
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->rx_prod) rx producer index\n"
argument_list|,
name|sc
operator|->
name|rx_prod
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->rx_cons) rx consumer index\n"
argument_list|,
name|sc
operator|->
name|rx_cons
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->rx_prod_bseq) rx producer bseq index\n"
argument_list|,
name|sc
operator|->
name|rx_prod_bseq
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->rx_mbuf_alloc) rx mbufs allocated\n"
argument_list|,
name|sc
operator|->
name|rx_mbuf_alloc
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->free_rx_bd) free rx_bd's\n"
argument_list|,
name|sc
operator|->
name|free_rx_bd
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X/%08X - (sc->rx_low_watermark) rx low watermark\n"
argument_list|,
name|sc
operator|->
name|rx_low_watermark
argument_list|,
operator|(
name|u32
operator|)
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->txmbuf_alloc) tx mbufs allocated\n"
argument_list|,
name|sc
operator|->
name|tx_mbuf_alloc
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->rx_mbuf_alloc) rx mbufs allocated\n"
argument_list|,
name|sc
operator|->
name|rx_mbuf_alloc
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->used_tx_bd) used tx_bd's\n"
argument_list|,
name|sc
operator|->
name|used_tx_bd
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X/%08X - (sc->tx_hi_watermark) tx hi watermark\n"
argument_list|,
name|sc
operator|->
name|tx_hi_watermark
argument_list|,
operator|(
name|u32
operator|)
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"         0x%08X - (sc->mbuf_alloc_failed) failed mbuf alloc\n"
argument_list|,
name|sc
operator|->
name|mbuf_alloc_failed
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"-----------------------------"
literal|"--------------"
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_dump_hw_state
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|val1
decl_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|" Hardware State "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : bootcode version\n"
argument_list|,
name|sc
operator|->
name|bce_fw_ver
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_MISC_ENABLE_STATUS_BITS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : (0x%04X) misc_enable_status_bits\n"
argument_list|,
name|val1
argument_list|,
name|BCE_MISC_ENABLE_STATUS_BITS
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_DMA_STATUS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : (0x%04X) dma_status\n"
argument_list|,
name|val1
argument_list|,
name|BCE_DMA_STATUS
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_CTX_STATUS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : (0x%04X) ctx_status\n"
argument_list|,
name|val1
argument_list|,
name|BCE_CTX_STATUS
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_EMAC_STATUS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : (0x%04X) emac_status\n"
argument_list|,
name|val1
argument_list|,
name|BCE_EMAC_STATUS
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_RPM_STATUS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : (0x%04X) rpm_status\n"
argument_list|,
name|val1
argument_list|,
name|BCE_RPM_STATUS
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TBDR_STATUS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : (0x%04X) tbdr_status\n"
argument_list|,
name|val1
argument_list|,
name|BCE_TBDR_STATUS
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_TDMA_STATUS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : (0x%04X) tdma_status\n"
argument_list|,
name|val1
argument_list|,
name|BCE_TDMA_STATUS
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BCE_HC_STATUS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%08X : (0x%04X) hc_status\n"
argument_list|,
name|val1
argument_list|,
name|BCE_HC_STATUS
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|" Register  Dump "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0x400
init|;
name|i
operator|<
literal|0x8000
condition|;
name|i
operator|+=
literal|0x10
control|)
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"0x%04X: 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
name|BCE_PRINTF
argument_list|(
name|sc
argument_list|,
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bce_breakpoint
parameter_list|(
name|struct
name|bce_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Unreachable code to shut the compiler up about unused functions. */
if|if
condition|(
literal|0
condition|)
block|{
name|bce_dump_txbd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bce_dump_rxbd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bce_dump_tx_mbuf_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
name|bce_dump_rx_mbuf_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
name|bce_dump_l2fhdr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bce_dump_tx_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
name|bce_dump_rx_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
name|bce_dump_status_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_stats_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bce_dump_hw_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bce_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Print the important status block fields. */
name|bce_dump_status_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Call the debugger. */
name|breakpoint
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

