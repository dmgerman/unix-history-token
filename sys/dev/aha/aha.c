begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic register and struct definitions for the Adaptech 154x/164x  * SCSI host adapters. Product specific probe and attach routines can  * be found in:  *      aha 1542A/1542B/1542C/1542CF/1542CP	aha_isa.c  *      aha 1640			aha_mca.c  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998 M. Warner Losh.  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Derived from bt.c written by:  *  * Copyright (c) 1998 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/aha/ahareg.h>
end_include

begin_define
define|#
directive|define
name|PRVERB
parameter_list|(
name|x
parameter_list|)
value|do { if (bootverbose) device_printf x; } while (0)
end_define

begin_comment
comment|/* Macro to determine that a rev is potentially a new valid one  * so that the driver doesn't keep breaking on new revs as it  * did for the CF and CP.  */
end_comment

begin_define
define|#
directive|define
name|PROBABLY_NEW_BOARD
parameter_list|(
name|REV
parameter_list|)
value|(REV> 0x43&& REV< 0x56)
end_define

begin_comment
comment|/* MailBox Management functions */
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahanextinbox
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahanextoutbox
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aha_name
parameter_list|(
name|aha
parameter_list|)
value|device_get_nameunit(aha->dev)
end_define

begin_function
specifier|static
name|__inline
name|void
name|ahanextinbox
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
if|if
condition|(
name|aha
operator|->
name|cur_inbox
operator|==
name|aha
operator|->
name|last_inbox
condition|)
name|aha
operator|->
name|cur_inbox
operator|=
name|aha
operator|->
name|in_boxes
expr_stmt|;
else|else
name|aha
operator|->
name|cur_inbox
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahanextoutbox
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
if|if
condition|(
name|aha
operator|->
name|cur_outbox
operator|==
name|aha
operator|->
name|last_outbox
condition|)
name|aha
operator|->
name|cur_outbox
operator|=
name|aha
operator|->
name|out_boxes
expr_stmt|;
else|else
name|aha
operator|->
name|cur_outbox
operator|++
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ahautoa24
parameter_list|(
name|u
parameter_list|,
name|s3
parameter_list|)
define|\
value|(s3)[0] = ((u)>> 16)& 0xff;	\ 	(s3)[1] = ((u)>> 8)& 0xff;	\ 	(s3)[2] = (u)& 0xff;
end_define

begin_define
define|#
directive|define
name|aha_a24tou
parameter_list|(
name|s3
parameter_list|)
define|\
value|(((s3)[0]<< 16) | ((s3)[1]<< 8) | (s3)[2])
end_define

begin_comment
comment|/* CCB Mangement functions */
end_comment

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahaccbvtop
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|struct
name|aha_ccb
modifier|*
name|accb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|aha_ccb
operator|*
name|ahaccbptov
argument_list|(
argument|struct aha_softc *aha
argument_list|,
argument|uint32_t ccb_addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahaccbvtop
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|struct
name|aha_ccb
modifier|*
name|accb
parameter_list|)
block|{
return|return
operator|(
name|aha
operator|->
name|aha_ccb_physbase
operator|+
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
name|accb
operator|-
operator|(
name|caddr_t
operator|)
name|aha
operator|->
name|aha_ccb_array
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|aha_ccb
operator|*
name|ahaccbptov
argument_list|(
argument|struct aha_softc *aha
argument_list|,
argument|uint32_t ccb_addr
argument_list|)
block|{
return|return
operator|(
name|aha
operator|->
name|aha_ccb_array
operator|+
operator|+
operator|(
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ccb_addr
operator|-
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|aha
operator|->
name|aha_ccb_physbase
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|aha_ccb
modifier|*
name|ahagetccb
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahafreeccb
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|struct
name|aha_ccb
modifier|*
name|accb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahaallocccbs
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|ahaexecuteccb
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ahadone
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|struct
name|aha_ccb
modifier|*
name|accb
parameter_list|,
name|aha_mbi_comp_code_t
name|comp_code
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Host adapter command functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ahareset
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|int
name|hard_reset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialization functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ahainitmboxes
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|ahamapmboxes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|ahamapccbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|ahamapsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transfer Negotiation Functions */
end_comment

begin_function_decl
specifier|static
name|void
name|ahafetchtransinfo
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* CAM SIM entry points */
end_comment

begin_define
define|#
directive|define
name|ccb_accb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_aha_ptr
value|spriv_ptr1
end_define

begin_function_decl
specifier|static
name|void
name|ahaaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahapoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Our timeout handler */
end_comment

begin_decl_stmt
specifier|static
name|timeout_t
name|ahatimeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exported functions */
end_comment

begin_function
name|void
name|aha_alloc
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|int
name|unit
parameter_list|,
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|)
block|{
name|SLIST_INIT
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|aha
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|aha
operator|->
name|sg_maps
argument_list|)
expr_stmt|;
name|aha
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|aha
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|aha
operator|->
name|bsh
operator|=
name|bsh
expr_stmt|;
name|aha
operator|->
name|ccb_sg_opcode
operator|=
name|INITIATOR_SG_CCB_WRESID
expr_stmt|;
name|aha
operator|->
name|ccb_ccb_opcode
operator|=
name|INITIATOR_CCB_WRESID
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aha_free
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
switch|switch
condition|(
name|aha
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|8
case|:
block|{
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
while|while
condition|(
operator|(
name|sg_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|sg_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|aha
operator|->
name|sg_maps
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|aha
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|aha
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|aha
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
block|}
case|case
literal|7
case|:
name|bus_dmamap_unload
argument_list|(
name|aha
operator|->
name|ccb_dmat
argument_list|,
name|aha
operator|->
name|ccb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|bus_dmamap_destroy
argument_list|(
name|aha
operator|->
name|ccb_dmat
argument_list|,
name|aha
operator|->
name|ccb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|aha
operator|->
name|ccb_dmat
argument_list|,
name|aha
operator|->
name|aha_ccb_array
argument_list|,
name|aha
operator|->
name|ccb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|bus_dma_tag_destroy
argument_list|(
name|aha
operator|->
name|ccb_dmat
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|bus_dmamap_unload
argument_list|(
name|aha
operator|->
name|mailbox_dmat
argument_list|,
name|aha
operator|->
name|mailbox_dmamap
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|bus_dmamem_free
argument_list|(
name|aha
operator|->
name|mailbox_dmat
argument_list|,
name|aha
operator|->
name|in_boxes
argument_list|,
name|aha
operator|->
name|mailbox_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|aha
operator|->
name|mailbox_dmat
argument_list|,
name|aha
operator|->
name|mailbox_dmamap
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|bus_dma_tag_destroy
argument_list|(
name|aha
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|bus_dma_tag_destroy
argument_list|(
name|aha
operator|->
name|mailbox_dmat
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Probe the adapter and verify that the card is an Adaptec.  */
end_comment

begin_function
name|int
name|aha_probe
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
name|u_int
name|status
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|int
name|error
decl_stmt|;
name|board_id_data_t
name|board_id
decl_stmt|;
comment|/* 	 * See if the three I/O ports look reasonable. 	 * Touch the minimal number of registers in the 	 * failure case. 	 */
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
literal|0
operator|)
operator|||
operator|(
name|status
operator|&
operator|(
name|DIAG_ACTIVE
operator||
name|CMD_REG_BUSY
operator||
name|STATUS_REG_RSVD
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"status reg test failed %x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|intstat
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|INTSTAT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|INTSTAT_REG_RSVD
operator|)
operator|!=
literal|0
condition|)
block|{
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"Failed Intstat Reg Test\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Looking good so far.  Final test is to reset the 	 * adapter and fetch the board ID and ensure we aren't 	 * looking at a BusLogic. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|ahareset
argument_list|(
name|aha
argument_list|,
comment|/*hard_reset*/
name|TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"Failed Reset\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Get the board ID.  We use this to see if we're dealing with 	 * a buslogic card or an aha card (or clone). 	 */
name|error
operator|=
name|aha_cmd
argument_list|(
name|aha
argument_list|,
name|AOP_INQUIRE_BOARD_ID
argument_list|,
name|NULL
argument_list|,
comment|/*parmlen*/
literal|0
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|board_id
argument_list|,
sizeof|sizeof
argument_list|(
name|board_id
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"INQUIRE failed %x\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|aha
operator|->
name|fw_major
operator|=
name|board_id
operator|.
name|firmware_rev_major
expr_stmt|;
name|aha
operator|->
name|fw_minor
operator|=
name|board_id
operator|.
name|firmware_rev_minor
expr_stmt|;
name|aha
operator|->
name|boardid
operator|=
name|board_id
operator|.
name|board_type
expr_stmt|;
comment|/* 	 * The Buslogic cards have an id of either 0x41 or 0x42.  So 	 * if those come up in the probe, we test the geometry register 	 * of the board.  Adaptec boards that are this old will not have 	 * this register, and return 0xff, while buslogic cards will return 	 * something different. 	 * 	 * It appears that for reasons unknow, for the for the 	 * aha-1542B cards, we need to wait a little bit before trying 	 * to read the geometry register.  I picked 10ms since we have 	 * reports that a for loop to 1000 did the trick, and this 	 * errs on the side of conservatism.  Besides, no one will 	 * notice a 10mS delay here, even the 1542B card users :-) 	 * 	 * Some compatible cards return 0 here.  Some cards also 	 * seem to return 0x7f. 	 * 	 * XXX I'm not sure how this will impact other cloned cards 	 * 	 * This really should be replaced with the esetup command, since 	 * that appears to be more reliable.  This becomes more and more 	 * true over time as we discover more cards that don't read the 	 * geometry register consistantly. 	 */
if|if
condition|(
name|aha
operator|->
name|boardid
operator|<=
literal|0x42
condition|)
block|{
comment|/* Wait 10ms before reading */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|GEOMETRY_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0xff
operator|&&
name|status
operator|!=
literal|0x00
operator|&&
name|status
operator|!=
literal|0x7f
condition|)
block|{
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"Geometry Register test failed %#x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pull the boards setup information and record it in our softc.  */
end_comment

begin_function
name|int
name|aha_fetch_adapter_info
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
name|setup_data_t
name|setup_info
decl_stmt|;
name|config_data_t
name|config_data
decl_stmt|;
name|uint8_t
name|length_param
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|aha_extbios
name|extbios
decl_stmt|;
switch|switch
condition|(
name|aha
operator|->
name|boardid
condition|)
block|{
case|case
name|BOARD_1540_16HEAD_BIOS
case|:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"1540 16 head BIOS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOARD_1540_64HEAD_BIOS
case|:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"1540 64 head BIOS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOARD_1542
case|:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"1540/1542 64 head BIOS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOARD_1640
case|:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"1640"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOARD_1740
case|:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"1740A/1742A/1744"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOARD_1542C
case|:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"1542C"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOARD_1542CF
case|:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"1542CF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOARD_1542CP
case|:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"1542CP"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|aha
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|aha
operator|->
name|model
argument_list|)
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * If we are a new type of 1542 board (anything newer than a 1542C) 	 * then disable the extended bios so that the 	 * mailbox interface is unlocked. 	 * This is also true for the 1542B Version 3.20. First Adaptec 	 * board that supports>1Gb drives. 	 * No need to check the extended bios flags as some of the 	 * extensions that cause us problems are not flagged in that byte. 	 */
if|if
condition|(
name|PROBABLY_NEW_BOARD
argument_list|(
name|aha
operator|->
name|boardid
argument_list|)
operator|||
operator|(
name|aha
operator|->
name|boardid
operator|==
literal|0x41
operator|&&
name|aha
operator|->
name|fw_major
operator|==
literal|0x31
operator|&&
name|aha
operator|->
name|fw_minor
operator|>=
literal|0x34
operator|)
condition|)
block|{
name|error
operator|=
name|aha_cmd
argument_list|(
name|aha
argument_list|,
name|AOP_RETURN_EXT_BIOS_INFO
argument_list|,
name|NULL
argument_list|,
comment|/*paramlen*/
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|extbios
argument_list|,
sizeof|sizeof
argument_list|(
name|extbios
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"AOP_RETURN_EXT_BIOS_INFO - Failed."
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|aha_cmd
argument_list|(
name|aha
argument_list|,
name|AOP_MBOX_IF_ENABLE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|extbios
argument_list|,
comment|/*paramlen*/
literal|2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"AOP_MBOX_IF_ENABLE - Failed."
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|aha
operator|->
name|boardid
operator|<
literal|0x41
condition|)
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"Warning: aha-1542A won't work.\n"
argument_list|)
expr_stmt|;
name|aha
operator|->
name|max_sg
operator|=
literal|17
expr_stmt|;
comment|/* Need>= 17 to do 64k I/O */
name|aha
operator|->
name|diff_bus
operator|=
literal|0
expr_stmt|;
name|aha
operator|->
name|extended_lun
operator|=
literal|0
expr_stmt|;
name|aha
operator|->
name|extended_trans
operator|=
literal|0
expr_stmt|;
name|aha
operator|->
name|max_ccbs
operator|=
literal|16
expr_stmt|;
comment|/* Determine Sync/Wide/Disc settings */
name|length_param
operator|=
sizeof|sizeof
argument_list|(
name|setup_info
argument_list|)
expr_stmt|;
name|error
operator|=
name|aha_cmd
argument_list|(
name|aha
argument_list|,
name|AOP_INQUIRE_SETUP_INFO
argument_list|,
operator|&
name|length_param
argument_list|,
comment|/*paramlen*/
literal|1
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|setup_info
argument_list|,
sizeof|sizeof
argument_list|(
name|setup_info
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"aha_fetch_adapter_info - Failed "
literal|"Get Setup Info\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|setup_info
operator|.
name|initiate_sync
operator|!=
literal|0
condition|)
block|{
name|aha
operator|->
name|sync_permitted
operator|=
name|ALL_TARGETS
expr_stmt|;
block|}
name|aha
operator|->
name|disc_permitted
operator|=
name|ALL_TARGETS
expr_stmt|;
comment|/* We need as many mailboxes as we can have ccbs */
name|aha
operator|->
name|num_boxes
operator|=
name|aha
operator|->
name|max_ccbs
expr_stmt|;
comment|/* Determine our SCSI ID */
name|error
operator|=
name|aha_cmd
argument_list|(
name|aha
argument_list|,
name|AOP_INQUIRE_CONFIG
argument_list|,
name|NULL
argument_list|,
comment|/*parmlen*/
literal|0
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|config_data
argument_list|,
sizeof|sizeof
argument_list|(
name|config_data
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"aha_fetch_adapter_info - Failed Get Config\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|aha
operator|->
name|scsi_id
operator|=
name|config_data
operator|.
name|scsi_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|aha_init
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
comment|/* Announce the Adapter */
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"AHA-%s FW Rev. %c.%c (ID=%x) "
argument_list|,
name|aha
operator|->
name|model
argument_list|,
name|aha
operator|->
name|fw_major
argument_list|,
name|aha
operator|->
name|fw_minor
argument_list|,
name|aha
operator|->
name|boardid
argument_list|)
expr_stmt|;
if|if
condition|(
name|aha
operator|->
name|diff_bus
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Diff "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI Host Adapter, SCSI ID %d, %d CCBs\n"
argument_list|,
name|aha
operator|->
name|scsi_id
argument_list|,
name|aha
operator|->
name|max_ccbs
argument_list|)
expr_stmt|;
comment|/* 	 * Create our DMA tags.  These tags define the kinds of device 	 * accessible memory allocations and memory mappings we will 	 * need to perform during normal operation. 	 * 	 * Unless we need to further restrict the allocation, we rely 	 * on the restrictions of the parent dmat, hence the common 	 * use of MAXADDR and MAXSIZE. 	 */
comment|/* DMA tag for mapping buffers into device visible space. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|aha
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|MAXBSIZE
argument_list|,
comment|/* nsegments	*/
name|AHA_NSEG
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_24BIT
argument_list|,
comment|/* flags	*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|aha
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|aha
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our mailboxes */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|aha
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|aha
operator|->
name|num_boxes
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|aha_mbox_in_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|aha_mbox_out_t
argument_list|)
operator|)
argument_list|,
comment|/* nsegments	*/
literal|1
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_24BIT
argument_list|,
comment|/* flags	*/
literal|0
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|aha
operator|->
name|mailbox_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|aha
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our mailboxes */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|aha
operator|->
name|mailbox_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|aha
operator|->
name|out_boxes
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|aha
operator|->
name|mailbox_dmamap
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|aha
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|aha
operator|->
name|mailbox_dmat
argument_list|,
name|aha
operator|->
name|mailbox_dmamap
argument_list|,
name|aha
operator|->
name|out_boxes
argument_list|,
name|aha
operator|->
name|num_boxes
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|aha_mbox_in_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|aha_mbox_out_t
argument_list|)
operator|)
argument_list|,
name|ahamapmboxes
argument_list|,
name|aha
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|aha
operator|->
name|init_level
operator|++
expr_stmt|;
name|aha
operator|->
name|in_boxes
operator|=
operator|(
name|aha_mbox_in_t
operator|*
operator|)
operator|&
name|aha
operator|->
name|out_boxes
index|[
name|aha
operator|->
name|num_boxes
index|]
expr_stmt|;
name|ahainitmboxes
argument_list|(
name|aha
argument_list|)
expr_stmt|;
comment|/* DMA tag for our ccb structures */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|aha
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|aha
operator|->
name|max_ccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aha_ccb
argument_list|)
argument_list|,
comment|/* nsegments	*/
literal|1
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_24BIT
argument_list|,
comment|/* flags	*/
literal|0
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|aha
operator|->
name|ccb_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|aha
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our ccbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|aha
operator|->
name|ccb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|aha
operator|->
name|aha_ccb_array
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|aha
operator|->
name|ccb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|aha
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|aha
operator|->
name|ccb_dmat
argument_list|,
name|aha
operator|->
name|ccb_dmamap
argument_list|,
name|aha
operator|->
name|aha_ccb_array
argument_list|,
name|aha
operator|->
name|max_ccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aha_ccb
argument_list|)
argument_list|,
name|ahamapccbs
argument_list|,
name|aha
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|aha
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our S/G structures.  We allocate in page sized chunks */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|aha
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|PAGE_SIZE
argument_list|,
comment|/* nsegments	*/
literal|1
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_24BIT
argument_list|,
comment|/* flags	*/
literal|0
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|aha
operator|->
name|sg_dmat
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|aha
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Perform initial CCB allocation */
name|bzero
argument_list|(
name|aha
operator|->
name|aha_ccb_array
argument_list|,
name|aha
operator|->
name|max_ccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aha_ccb
argument_list|)
argument_list|)
expr_stmt|;
name|ahaallocccbs
argument_list|(
name|aha
argument_list|)
expr_stmt|;
if|if
condition|(
name|aha
operator|->
name|num_ccbs
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"aha_init - Unable to allocate initial ccbs\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* 	 * Note that we are going and return (to probe) 	 */
return|return
operator|(
literal|0
operator|)
return|;
name|error_exit
label|:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aha_attach
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
name|int
name|tagged_dev_openings
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* 	 * We don't do tagged queueing, since the aha cards don't 	 * support it. 	 */
name|tagged_dev_openings
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Create the device queue for our SIM. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|aha
operator|->
name|max_ccbs
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Construct our SIM entry 	 */
name|aha
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahaaction
argument_list|,
name|ahapoll
argument_list|,
literal|"aha"
argument_list|,
name|aha
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
operator|&
name|Giant
argument_list|,
literal|2
argument_list|,
name|tagged_dev_openings
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|aha
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|aha
operator|->
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|aha
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|aha
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|aha
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|aha
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|aha
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahaallocccbs
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
name|struct
name|aha_ccb
modifier|*
name|next_ccb
decl_stmt|;
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
name|bus_addr_t
name|physaddr
decl_stmt|;
name|aha_sg_t
modifier|*
name|segs
decl_stmt|;
name|int
name|newcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|next_ccb
operator|=
operator|&
name|aha
operator|->
name|aha_ccb_array
index|[
name|aha
operator|->
name|num_ccbs
index|]
expr_stmt|;
name|sg_map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_map
operator|==
name|NULL
condition|)
return|return;
comment|/* Allocate S/G space for the next batch of CCBS */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|aha
operator|->
name|sg_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|aha
operator|->
name|sg_maps
argument_list|,
name|sg_map
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|aha
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|ahamapsgs
argument_list|,
name|aha
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|segs
operator|=
name|sg_map
operator|->
name|sg_vaddr
expr_stmt|;
name|physaddr
operator|=
name|sg_map
operator|->
name|sg_physaddr
expr_stmt|;
name|newcount
operator|=
operator|(
name|PAGE_SIZE
operator|/
operator|(
name|AHA_NSEG
operator|*
sizeof|sizeof
argument_list|(
name|aha_sg_t
argument_list|)
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|aha
operator|->
name|num_ccbs
operator|<
name|aha
operator|->
name|max_ccbs
operator|&&
name|i
operator|<
name|newcount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|error
decl_stmt|;
name|next_ccb
operator|->
name|sg_list
operator|=
name|segs
expr_stmt|;
name|next_ccb
operator|->
name|sg_list_phys
operator|=
name|physaddr
expr_stmt|;
name|next_ccb
operator|->
name|flags
operator|=
name|ACCB_FREE
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|aha
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|next_ccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|,
name|next_ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|segs
operator|+=
name|AHA_NSEG
expr_stmt|;
name|physaddr
operator|+=
operator|(
name|AHA_NSEG
operator|*
sizeof|sizeof
argument_list|(
name|aha_sg_t
argument_list|)
operator|)
expr_stmt|;
name|next_ccb
operator|++
expr_stmt|;
name|aha
operator|->
name|num_ccbs
operator|++
expr_stmt|;
block|}
comment|/* Reserve a CCB for error recovery */
if|if
condition|(
name|aha
operator|->
name|recovery_accb
operator|==
name|NULL
condition|)
block|{
name|aha
operator|->
name|recovery_accb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahafreeccb
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|struct
name|aha_ccb
modifier|*
name|accb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_ACTIVE
operator|)
operator|!=
literal|0
condition|)
name|LIST_REMOVE
argument_list|(
operator|&
name|accb
operator|->
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
name|aha
operator|->
name|resource_shortage
operator|!=
literal|0
operator|&&
operator|(
name|accb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|accb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|aha
operator|->
name|resource_shortage
operator|=
name|FALSE
expr_stmt|;
block|}
name|accb
operator|->
name|flags
operator|=
name|ACCB_FREE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|,
name|accb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aha
operator|->
name|active_ccbs
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|aha_ccb
modifier|*
name|ahagetccb
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
name|struct
name|aha_ccb
modifier|*
name|accb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|accb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aha
operator|->
name|active_ccbs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aha
operator|->
name|num_ccbs
operator|<
name|aha
operator|->
name|max_ccbs
condition|)
block|{
name|ahaallocccbs
argument_list|(
name|aha
argument_list|)
expr_stmt|;
name|accb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|accb
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"Can't malloc ACCB\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|aha
operator|->
name|free_aha_ccbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aha
operator|->
name|active_ccbs
operator|++
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|accb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahaaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|aha_softc
modifier|*
name|aha
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahaaction\n"
operator|)
argument_list|)
expr_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|struct
name|aha_ccb
modifier|*
name|accb
decl_stmt|;
name|struct
name|aha_hccb
modifier|*
name|hccb
decl_stmt|;
comment|/* 		 * Get an accb to use. 		 */
if|if
condition|(
operator|(
name|accb
operator|=
name|ahagetccb
argument_list|(
name|aha
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|aha
operator|->
name|resource_shortage
operator|=
name|TRUE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|aha
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|hccb
operator|=
operator|&
name|accb
operator|->
name|hccb
expr_stmt|;
comment|/* 		 * So we can find the ACCB when an abort is requested 		 */
name|accb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_accb_ptr
operator|=
name|accb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_aha_ptr
operator|=
name|aha
expr_stmt|;
comment|/* 		 * Put all the arguments for the xfer in the accb 		 */
name|hccb
operator|->
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|hccb
operator|->
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|hccb
operator|->
name|ahastat
operator|=
literal|0
expr_stmt|;
name|hccb
operator|->
name|sdstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|ccbh
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
name|hccb
operator|->
name|opcode
operator|=
name|aha
operator|->
name|ccb_ccb_opcode
expr_stmt|;
name|hccb
operator|->
name|datain
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
operator|!=
literal|0
expr_stmt|;
name|hccb
operator|->
name|dataout
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
operator|)
operator|!=
literal|0
expr_stmt|;
name|hccb
operator|->
name|cmd_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|hccb
operator|->
name|cmd_len
operator|>
sizeof|sizeof
argument_list|(
name|hccb
operator|->
name|scsi_cdb
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ahafreeccb
argument_list|(
name|aha
argument_list|,
name|accb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|hccb
operator|->
name|sense_len
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hccb
operator|->
name|scsi_cdb
argument_list|,
name|hccb
operator|->
name|cmd_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I guess I could map it in... */
name|ccbh
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ahafreeccb
argument_list|(
name|aha
argument_list|,
name|accb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hccb
operator|->
name|scsi_cdb
argument_list|,
name|hccb
operator|->
name|cmd_len
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If we have any data to send with this command, 			 * map it into bus space. 			 */
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * We've been given a pointer 					 * to a single buffer. 					 */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|aha
operator|->
name|buffer_dmat
argument_list|,
name|accb
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|ahaexecuteccb
argument_list|,
name|accb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 							 * So as to maintain 							 * ordering, freeze the 							 * controller queue 							 * until our mapping is 							 * returned. 							 */
name|xpt_freeze_simq
argument_list|(
name|aha
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|ahaexecuteccb
argument_list|(
name|accb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ahaaction - Physical "
literal|"segment pointers "
literal|"unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahaaction - Virtual "
literal|"segment addresses "
literal|"unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|ahaexecuteccb
argument_list|(
name|accb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahaexecuteccb
argument_list|(
name|accb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hccb
operator|->
name|opcode
operator|=
name|INITIATOR_BUS_DEV_RESET
expr_stmt|;
comment|/* No data transfer */
name|hccb
operator|->
name|datain
operator|=
name|TRUE
expr_stmt|;
name|hccb
operator|->
name|dataout
operator|=
name|TRUE
expr_stmt|;
name|hccb
operator|->
name|cmd_len
operator|=
literal|0
expr_stmt|;
name|hccb
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|ahaexecuteccb
argument_list|(
name|accb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|u_int
name|target_mask
init|=
literal|0x01
operator|<<
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
name|spi
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|aha
operator|->
name|disc_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
if|if
condition|(
operator|(
name|aha
operator|->
name|sync_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|aha
operator|->
name|boardid
operator|>=
name|BOARD_1542CF
condition|)
name|spi
operator|->
name|sync_period
operator|=
literal|25
expr_stmt|;
else|else
name|spi
operator|->
name|sync_period
operator|=
literal|50
expr_stmt|;
block|}
else|else
block|{
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|spi
operator|->
name|sync_period
operator|!=
literal|0
condition|)
name|spi
operator|->
name|sync_offset
operator|=
literal|15
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
block|}
else|else
block|{
name|ahafetchtransinfo
argument_list|(
name|aha
argument_list|,
name|cts
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|uint32_t
name|size_mb
decl_stmt|;
name|uint32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>=
literal|1024
operator|&&
operator|(
name|aha
operator|->
name|extended_trans
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|size_mb
operator|>=
literal|2048
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|128
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
name|ahareset
argument_list|(
name|aha
argument_list|,
comment|/*hardreset*/
name|TRUE
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|aha
operator|->
name|scsi_id
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahaexecuteccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aha_ccb
modifier|*
name|accb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|aha_softc
modifier|*
name|aha
decl_stmt|;
name|int
name|s
decl_stmt|;
name|uint32_t
name|paddr
decl_stmt|;
name|accb
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|accb
operator|->
name|ccb
expr_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_aha_ptr
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"Unexepected error 0x%x returned from "
literal|"bus_dmamap_load\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|ahafreeccb
argument_list|(
name|aha
argument_list|,
name|accb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|aha_sg_t
modifier|*
name|sg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|end_seg
operator|=
name|dm_segs
operator|+
name|nseg
expr_stmt|;
comment|/* Copy the segments into our SG list */
name|sg
operator|=
name|accb
operator|->
name|sg_list
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|ahautoa24
argument_list|(
name|dm_segs
operator|->
name|ds_len
argument_list|,
name|sg
operator|->
name|len
argument_list|)
expr_stmt|;
name|ahautoa24
argument_list|(
name|dm_segs
operator|->
name|ds_addr
argument_list|,
name|sg
operator|->
name|addr
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|>
literal|1
condition|)
block|{
name|accb
operator|->
name|hccb
operator|.
name|opcode
operator|=
name|aha
operator|->
name|ccb_sg_opcode
expr_stmt|;
name|ahautoa24
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|aha_sg_t
argument_list|)
operator|*
name|nseg
operator|)
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|data_len
argument_list|)
expr_stmt|;
name|ahautoa24
argument_list|(
name|accb
operator|->
name|sg_list_phys
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|data_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|accb
operator|->
name|sg_list
operator|->
name|len
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|data_len
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|accb
operator|->
name|sg_list
operator|->
name|addr
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|data_addr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|aha
operator|->
name|buffer_dmat
argument_list|,
name|accb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|accb
operator|->
name|hccb
operator|.
name|opcode
operator|=
name|INITIATOR_CCB
expr_stmt|;
name|ahautoa24
argument_list|(
literal|0
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|data_len
argument_list|)
expr_stmt|;
name|ahautoa24
argument_list|(
literal|0
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|data_addr
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Last time we need to check if this CCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|aha
operator|->
name|buffer_dmat
argument_list|,
name|accb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahafreeccb
argument_list|(
name|aha
argument_list|,
name|accb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|accb
operator|->
name|flags
operator|=
name|ACCB_ACTIVE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|aha
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahatimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|accb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
comment|/* Tell the adapter about this command */
if|if
condition|(
name|aha
operator|->
name|cur_outbox
operator|->
name|action_code
operator|!=
name|AMBO_FREE
condition|)
block|{
comment|/* 		 * We should never encounter a busy mailbox. 		 * If we do, warn the user, and treat it as 		 * a resource shortage.  If the controller is 		 * hung, one of the pending transactions will 		 * timeout causing us to start recovery operations. 		 */
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"Encountered busy mailbox with %d out of %d "
literal|"commands active!!!"
argument_list|,
name|aha
operator|->
name|active_ccbs
argument_list|,
name|aha
operator|->
name|max_ccbs
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ahatimeout
argument_list|,
name|accb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|aha
operator|->
name|buffer_dmat
argument_list|,
name|accb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahafreeccb
argument_list|(
name|aha
argument_list|,
name|accb
argument_list|)
expr_stmt|;
name|aha
operator|->
name|resource_shortage
operator|=
name|TRUE
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|aha
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|paddr
operator|=
name|ahaccbvtop
argument_list|(
name|aha
argument_list|,
name|accb
argument_list|)
expr_stmt|;
name|ahautoa24
argument_list|(
name|paddr
argument_list|,
name|aha
operator|->
name|cur_outbox
operator|->
name|ccb_addr
argument_list|)
expr_stmt|;
name|aha
operator|->
name|cur_outbox
operator|->
name|action_code
operator|=
name|AMBO_START
expr_stmt|;
name|aha_outb
argument_list|(
name|aha
argument_list|,
name|COMMAND_REG
argument_list|,
name|AOP_START_MBOX
argument_list|)
expr_stmt|;
name|ahanextoutbox
argument_list|(
name|aha
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aha_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aha_softc
modifier|*
name|aha
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|uint32_t
name|paddr
decl_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_softc
operator|*
operator|)
name|arg
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|intstat
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|INTSTAT_REG
argument_list|)
operator|)
operator|&
name|INTR_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|intstat
operator|&
name|CMD_COMPLETE
operator|)
operator|!=
literal|0
condition|)
block|{
name|aha
operator|->
name|latched_status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
name|aha
operator|->
name|command_cmp
operator|=
name|TRUE
expr_stmt|;
block|}
name|aha_outb
argument_list|(
name|aha
argument_list|,
name|CONTROL_REG
argument_list|,
name|RESET_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|IMB_LOADED
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|aha
operator|->
name|cur_inbox
operator|->
name|comp_code
operator|!=
name|AMBI_FREE
condition|)
block|{
name|paddr
operator|=
name|aha_a24tou
argument_list|(
name|aha
operator|->
name|cur_inbox
operator|->
name|ccb_addr
argument_list|)
expr_stmt|;
name|ahadone
argument_list|(
name|aha
argument_list|,
name|ahaccbptov
argument_list|(
name|aha
argument_list|,
name|paddr
argument_list|)
argument_list|,
name|aha
operator|->
name|cur_inbox
operator|->
name|comp_code
argument_list|)
expr_stmt|;
name|aha
operator|->
name|cur_inbox
operator|->
name|comp_code
operator|=
name|AMBI_FREE
expr_stmt|;
name|ahanextinbox
argument_list|(
name|aha
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
name|SCSI_BUS_RESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahareset
argument_list|(
name|aha
argument_list|,
comment|/*hardreset*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahadone
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|struct
name|aha_ccb
modifier|*
name|accb
parameter_list|,
name|aha_mbi_comp_code_t
name|comp_code
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|ccb
operator|=
name|accb
operator|->
name|ccb
expr_stmt|;
name|csio
operator|=
operator|&
name|accb
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"ahadone - Attempt to free non-active ACCB %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|accb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|aha
operator|->
name|buffer_dmat
argument_list|,
name|accb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|aha
operator|->
name|buffer_dmat
argument_list|,
name|accb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accb
operator|==
name|aha
operator|->
name|recovery_accb
condition|)
block|{
comment|/* 		 * The recovery ACCB does not have a CCB associated 		 * with it, so short circuit the normal error handling. 		 * We now traverse our list of pending CCBs and process 		 * any that were terminated by the recovery CCBs action. 		 * We also reinstate timeouts for all remaining, pending, 		 * CCBs. 		 */
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|cam_status
name|error
decl_stmt|;
comment|/* Notify all clients that a BDR occured */
name|error
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|aha
operator|->
name|sim
argument_list|)
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
name|xpt_async
argument_list|(
name|AC_SENT_BDR
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|aha_ccb
modifier|*
name|pending_accb
decl_stmt|;
name|pending_accb
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_accb_ptr
expr_stmt|;
if|if
condition|(
name|pending_accb
operator|->
name|hccb
operator|.
name|target
operator|==
name|accb
operator|->
name|hccb
operator|.
name|target
condition|)
block|{
name|pending_accb
operator|->
name|hccb
operator|.
name|ahastat
operator|=
name|AHASTAT_HA_BDR
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|ahadone
argument_list|(
name|aha
argument_list|,
name|pending_accb
argument_list|,
name|AMBI_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb_h
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahatimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|pending_accb
argument_list|,
operator|(
name|ccb_h
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
block|}
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"No longer in timeout\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|untimeout
argument_list|(
name|ahatimeout
argument_list|,
name|accb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|AMBI_FREE
case|:
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"ahadone - CCB completed with free status!\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AMBI_NOT_FOUND
case|:
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"ahadone - CCB Abort failed to find CCB\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AMBI_ABORT
case|:
case|case
name|AMBI_ERROR
case|:
comment|/* An error occured */
if|if
condition|(
name|accb
operator|->
name|hccb
operator|.
name|opcode
operator|<
name|INITIATOR_CCB_WRESID
condition|)
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
else|else
name|csio
operator|->
name|resid
operator|=
name|aha_a24tou
argument_list|(
name|accb
operator|->
name|hccb
operator|.
name|data_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|accb
operator|->
name|hccb
operator|.
name|ahastat
condition|)
block|{
case|case
name|AHASTAT_DATARUN_ERROR
case|:
block|{
if|if
condition|(
name|csio
operator|->
name|resid
operator|<=
literal|0
condition|)
block|{
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
block|}
case|case
name|AHASTAT_NOERROR
case|:
name|csio
operator|->
name|scsi_status
operator|=
name|accb
operator|->
name|hccb
operator|.
name|sdstat
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|scsi_status
condition|)
block|{
case|case
name|SCSI_STATUS_CHECK_COND
case|:
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/* 				 * The aha writes the sense data at different 				 * offsets based on the scsi cmd len 				 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|accb
operator|->
name|hccb
operator|.
name|scsi_cdb
operator|+
name|accb
operator|->
name|hccb
operator|.
name|cmd_len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|sense_len
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
case|case
name|SCSI_STATUS_OK
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|AHASTAT_SELTIMEOUT
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|AHASTAT_UNEXPECTED_BUSFREE
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNEXP_BUSFREE
expr_stmt|;
break|break;
case|case
name|AHASTAT_INVALID_PHASE
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEQUENCE_FAIL
expr_stmt|;
break|break;
case|case
name|AHASTAT_INVALID_ACTION_CODE
case|:
name|panic
argument_list|(
literal|"%s: Inavlid Action code"
argument_list|,
name|aha_name
argument_list|(
name|aha
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AHASTAT_INVALID_OPCODE
case|:
if|if
condition|(
name|accb
operator|->
name|hccb
operator|.
name|opcode
operator|<
name|INITIATOR_CCB_WRESID
condition|)
name|panic
argument_list|(
literal|"%s: Invalid CCB Opcode %x hccb = %p"
argument_list|,
name|aha_name
argument_list|(
name|aha
argument_list|)
argument_list|,
name|accb
operator|->
name|hccb
operator|.
name|opcode
argument_list|,
operator|&
name|accb
operator|->
name|hccb
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"AHA-1540A compensation failed\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
break|break;
case|case
name|AHASTAT_LINKED_CCB_LUN_MISMATCH
case|:
comment|/* We don't even support linked commands... */
name|panic
argument_list|(
literal|"%s: Linked CCB Lun Mismatch"
argument_list|,
name|aha_name
argument_list|(
name|aha
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AHASTAT_INVALID_CCB_OR_SG_PARAM
case|:
name|panic
argument_list|(
literal|"%s: Invalid CCB or SG list"
argument_list|,
name|aha_name
argument_list|(
name|aha
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AHASTAT_HA_SCSI_BUS_RESET
case|:
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_CMD_TIMEOUT
condition|)
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
break|break;
case|case
name|AHASTAT_HA_BDR
case|:
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_DEVICE_RESET
operator|)
operator|==
literal|0
condition|)
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BDR_SENT
expr_stmt|;
else|else
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_RELEASE_SIMQ
operator|)
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|ahafreeccb
argument_list|(
name|aha
argument_list|,
name|accb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|AMBI_OK
case|:
comment|/* All completed without incident */
comment|/* XXX DO WE NEED TO COPY SENSE BYTES HERE???? XXX */
comment|/* I don't think so since it works???? */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_RELEASE_SIMQ
operator|)
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|ahafreeccb
argument_list|(
name|aha
argument_list|,
name|accb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahareset
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|int
name|hard_reset
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|u_int
name|timeout
decl_stmt|;
name|uint8_t
name|reset_type
decl_stmt|;
if|if
condition|(
name|hard_reset
operator|!=
literal|0
condition|)
name|reset_type
operator|=
name|HARD_RESET
expr_stmt|;
else|else
name|reset_type
operator|=
name|SOFT_RESET
expr_stmt|;
name|aha_outb
argument_list|(
name|aha
argument_list|,
name|CONTROL_REG
argument_list|,
name|reset_type
argument_list|)
expr_stmt|;
comment|/* Wait 5sec. for Diagnostic start */
name|timeout
operator|=
literal|5
operator|*
literal|10000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DIAG_ACTIVE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"ahareset - Diagnostic Active failed to "
literal|"assert. status = %#x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* Wait 10sec. for Diagnostic end */
name|timeout
operator|=
literal|10
operator|*
literal|10000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DIAG_ACTIVE
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s: ahareset - Diagnostic Active failed to drop. "
literal|"status = 0x%x\n"
argument_list|,
name|aha_name
argument_list|(
name|aha
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* Wait for the host adapter to become ready or report a failure */
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|DIAG_FAIL
operator||
name|HA_READY
operator||
name|DATAIN_REG_READY
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"ahareset - Host adapter failed to "
literal|"come ready. status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* If the diagnostics failed, tell the user */
if|if
condition|(
operator|(
name|status
operator|&
name|DIAG_FAIL
operator|)
operator|!=
literal|0
operator|||
operator|(
name|status
operator|&
name|HA_READY
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"ahareset - Adapter failed diag\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DATAIN_REG_READY
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"ahareset - Host Adapter "
literal|"Error code = 0x%x\n"
argument_list|,
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|DATAIN_REG
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* If we've attached to the XPT, tell it about the event */
if|if
condition|(
name|aha
operator|->
name|path
operator|!=
name|NULL
condition|)
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|aha
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Perform completion processing for all outstanding CCBs. 	 */
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|pending_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|aha_ccb
modifier|*
name|pending_accb
decl_stmt|;
name|pending_accb
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_accb_ptr
expr_stmt|;
name|pending_accb
operator|->
name|hccb
operator|.
name|ahastat
operator|=
name|AHASTAT_HA_SCSI_BUS_RESET
expr_stmt|;
name|ahadone
argument_list|(
name|aha
argument_list|,
name|pending_accb
argument_list|,
name|AMBI_ERROR
argument_list|)
expr_stmt|;
block|}
comment|/* If we've allocated mailboxes, initialize them */
comment|/* Must be done after we've aborted our queue, or aha_cmd fails */
if|if
condition|(
name|aha
operator|->
name|init_level
operator|>
literal|4
condition|)
name|ahainitmboxes
argument_list|(
name|aha
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a command to the adapter.  */
end_comment

begin_function
name|int
name|aha_cmd
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|aha_op_t
name|opcode
parameter_list|,
name|uint8_t
modifier|*
name|params
parameter_list|,
name|u_int
name|param_len
parameter_list|,
name|uint8_t
modifier|*
name|reply_data
parameter_list|,
name|u_int
name|reply_len
parameter_list|,
name|u_int
name|cmd_timeout
parameter_list|)
block|{
name|u_int
name|timeout
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|u_int
name|saved_status
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|u_int
name|reply_buf_size
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|cmd_complete
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* No data returned to start */
name|reply_buf_size
operator|=
name|reply_len
expr_stmt|;
name|reply_len
operator|=
literal|0
expr_stmt|;
name|intstat
operator|=
literal|0
expr_stmt|;
name|cmd_complete
operator|=
literal|0
expr_stmt|;
name|saved_status
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * All commands except for the "start mailbox" and the "enable 	 * outgoing mailbox read interrupt" commands cannot be issued 	 * while there are pending transactions.  Freeze our SIMQ 	 * and wait for all completions to occur if necessary. 	 */
name|timeout
operator|=
literal|10000
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|pending_ccbs
argument_list|)
operator|!=
name|NULL
operator|&&
operator|--
name|timeout
condition|)
block|{
comment|/* Fire the interrupt handler in case interrupts are blocked */
name|aha_intr
argument_list|(
name|aha
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"aha_cmd: Timeout waiting for adapter idle\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|aha
operator|->
name|command_cmp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Wait up to 10 sec. for the adapter to become 	 * ready to accept commands. 	 */
name|timeout
operator|=
literal|100000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|HA_READY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
name|CMD_REG_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Throw away any pending data which may be 		 * left over from earlier commands that we 		 * timedout on. 		 */
if|if
condition|(
operator|(
name|status
operator|&
name|DATAIN_REG_READY
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|DATAIN_REG
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"aha_cmd: Timeout waiting for adapter"
literal|" ready, status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* 	 * Send the opcode followed by any necessary parameter bytes. 	 */
name|aha_outb
argument_list|(
name|aha
argument_list|,
name|COMMAND_REG
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for up to 1sec to get the parameter list sent 	 */
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
name|param_len
operator|&&
operator|--
name|timeout
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
name|intstat
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|INTSTAT_REG
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|INTR_PENDING
operator||
name|CMD_COMPLETE
operator|)
operator|)
operator|==
operator|(
name|INTR_PENDING
operator||
name|CMD_COMPLETE
operator|)
condition|)
block|{
name|saved_status
operator|=
name|status
expr_stmt|;
name|cmd_complete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|aha
operator|->
name|command_cmp
operator|!=
literal|0
condition|)
block|{
name|saved_status
operator|=
name|aha
operator|->
name|latched_status
expr_stmt|;
name|cmd_complete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|DATAIN_REG_READY
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|&
name|CMD_REG_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|aha_outb
argument_list|(
name|aha
argument_list|,
name|COMMAND_REG
argument_list|,
operator|*
name|params
operator|++
argument_list|)
expr_stmt|;
name|param_len
operator|--
expr_stmt|;
name|timeout
operator|=
literal|10000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"aha_cmd: Timeout sending parameters, "
literal|"status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
comment|/* 	 * For all other commands, we wait for any output data 	 * and the final comand completion interrupt. 	 */
while|while
condition|(
name|cmd_complete
operator|==
literal|0
operator|&&
operator|--
name|cmd_timeout
condition|)
block|{
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
name|intstat
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|INTSTAT_REG
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|aha
operator|->
name|command_cmp
operator|!=
literal|0
condition|)
block|{
name|cmd_complete
operator|=
literal|1
expr_stmt|;
name|saved_status
operator|=
name|aha
operator|->
name|latched_status
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|INTR_PENDING
operator||
name|CMD_COMPLETE
operator|)
operator|)
operator|==
operator|(
name|INTR_PENDING
operator||
name|CMD_COMPLETE
operator|)
condition|)
block|{
comment|/* 			 * Our poll (in case interrupts are blocked) 			 * saw the CMD_COMPLETE interrupt. 			 */
name|cmd_complete
operator|=
literal|1
expr_stmt|;
name|saved_status
operator|=
name|status
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|DATAIN_REG_READY
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint8_t
name|data
decl_stmt|;
name|data
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|DATAIN_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_len
operator|<
name|reply_buf_size
condition|)
block|{
operator|*
name|reply_data
operator|++
operator|=
name|data
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"aha_cmd - Discarded reply data "
literal|"byte for opcode 0x%x\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Reset timeout to ensure at least a second 			 * between response bytes. 			 */
name|cmd_timeout
operator|=
name|MAX
argument_list|(
name|cmd_timeout
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|reply_len
operator|++
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd_timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"aha_cmd: Timeout: status = 0x%x, "
literal|"intstat = 0x%x, reply_len = %d\n"
argument_list|,
name|status
argument_list|,
name|intstat
argument_list|,
name|reply_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* 	 * Clear any pending interrupts.  Block interrupts so our 	 * interrupt handler is not re-entered. 	 */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|aha_intr
argument_list|(
name|aha
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If the command was rejected by the controller, tell the caller. 	 */
if|if
condition|(
operator|(
name|saved_status
operator|&
name|CMD_INVALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"Invalid Command 0x%x\n"
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Some early adapters may not recover properly from 		 * an invalid command.  If it appears that the controller 		 * has wedged (i.e. status was not cleared by our interrupt 		 * reset above), perform a soft reset.       		 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|status
operator|=
name|aha_inb
argument_list|(
name|aha
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|CMD_INVALID
operator||
name|STATUS_REG_RSVD
operator||
name|DATAIN_REG_READY
operator||
name|CMD_REG_BUSY
operator||
name|DIAG_FAIL
operator||
name|DIAG_ACTIVE
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|status
operator|&
operator|(
name|HA_READY
operator||
name|INIT_REQUIRED
operator|)
operator|)
operator|!=
operator|(
name|HA_READY
operator||
name|INIT_REQUIRED
operator|)
condition|)
name|ahareset
argument_list|(
name|aha
argument_list|,
comment|/*hard_reset*/
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|param_len
operator|>
literal|0
condition|)
block|{
comment|/* The controller did not accept the full argument list */
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"Controller did not accept full argument "
literal|"list (%d> 0)\n"
operator|,
name|param_len
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
if|if
condition|(
name|reply_len
operator|!=
name|reply_buf_size
condition|)
block|{
comment|/* Too much or too little data received */
name|PRVERB
argument_list|(
operator|(
name|aha
operator|->
name|dev
operator|,
literal|"data received mismatch (%d != %d)\n"
operator|,
name|reply_len
operator|,
name|reply_buf_size
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
comment|/* We were successful */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahainitmboxes
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|init_24b_mbox_params_t
name|init_mbox
decl_stmt|;
name|bzero
argument_list|(
name|aha
operator|->
name|in_boxes
argument_list|,
sizeof|sizeof
argument_list|(
name|aha_mbox_in_t
argument_list|)
operator|*
name|aha
operator|->
name|num_boxes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|aha
operator|->
name|out_boxes
argument_list|,
sizeof|sizeof
argument_list|(
name|aha_mbox_out_t
argument_list|)
operator|*
name|aha
operator|->
name|num_boxes
argument_list|)
expr_stmt|;
name|aha
operator|->
name|cur_inbox
operator|=
name|aha
operator|->
name|in_boxes
expr_stmt|;
name|aha
operator|->
name|last_inbox
operator|=
name|aha
operator|->
name|in_boxes
operator|+
name|aha
operator|->
name|num_boxes
operator|-
literal|1
expr_stmt|;
name|aha
operator|->
name|cur_outbox
operator|=
name|aha
operator|->
name|out_boxes
expr_stmt|;
name|aha
operator|->
name|last_outbox
operator|=
name|aha
operator|->
name|out_boxes
operator|+
name|aha
operator|->
name|num_boxes
operator|-
literal|1
expr_stmt|;
comment|/* Tell the adapter about them */
name|init_mbox
operator|.
name|num_mboxes
operator|=
name|aha
operator|->
name|num_boxes
expr_stmt|;
name|ahautoa24
argument_list|(
name|aha
operator|->
name|mailbox_physbase
argument_list|,
name|init_mbox
operator|.
name|base_addr
argument_list|)
expr_stmt|;
name|error
operator|=
name|aha_cmd
argument_list|(
name|aha
argument_list|,
name|AOP_INITIALIZE_MBOX
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|init_mbox
argument_list|,
comment|/*parmlen*/
sizeof|sizeof
argument_list|(
name|init_mbox
argument_list|)
argument_list|,
comment|/*reply_buf*/
name|NULL
argument_list|,
comment|/*reply_len*/
literal|0
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ahainitmboxes: Initialization command failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the XPT's idea of the negotiated transfer  * parameters for a particular target.  */
end_comment

begin_function
specifier|static
name|void
name|ahafetchtransinfo
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|setup_data_t
name|setup_info
decl_stmt|;
name|u_int
name|target
decl_stmt|;
name|u_int
name|targ_offset
decl_stmt|;
name|u_int
name|sync_period
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|param
decl_stmt|;
name|targ_syncinfo_t
name|sync_info
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|target
operator|=
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|targ_offset
operator|=
operator|(
name|target
operator|&
literal|0x7
operator|)
expr_stmt|;
comment|/* 	 * Inquire Setup Information.  This command retreives 	 * the sync info for older models. 	 */
name|param
operator|=
sizeof|sizeof
argument_list|(
name|setup_info
argument_list|)
expr_stmt|;
name|error
operator|=
name|aha_cmd
argument_list|(
name|aha
argument_list|,
name|AOP_INQUIRE_SETUP_INFO
argument_list|,
operator|&
name|param
argument_list|,
comment|/*paramlen*/
literal|1
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|setup_info
argument_list|,
sizeof|sizeof
argument_list|(
name|setup_info
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"ahafetchtransinfo - Inquire Setup Info Failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|sync_info
operator|=
name|setup_info
operator|.
name|syncinfo
index|[
name|targ_offset
index|]
expr_stmt|;
if|if
condition|(
name|sync_info
operator|.
name|sync
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_offset
operator|=
literal|0
expr_stmt|;
else|else
name|spi
operator|->
name|sync_offset
operator|=
name|sync_info
operator|.
name|offset
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
if|if
condition|(
name|aha
operator|->
name|boardid
operator|>=
name|BOARD_1542CF
condition|)
name|sync_period
operator|=
literal|1000
expr_stmt|;
else|else
name|sync_period
operator|=
literal|2000
expr_stmt|;
name|sync_period
operator|+=
literal|500
operator|*
name|sync_info
operator|.
name|period
expr_stmt|;
comment|/* Convert ns value to standard SCSI sync rate */
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|!=
literal|0
condition|)
name|spi
operator|->
name|sync_period
operator|=
name|scsi_calc_syncparam
argument_list|(
name|sync_period
argument_list|)
expr_stmt|;
else|else
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|cts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahamapmboxes
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aha_softc
modifier|*
name|aha
decl_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|aha
operator|->
name|mailbox_physbase
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahamapccbs
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aha_softc
modifier|*
name|aha
decl_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|aha
operator|->
name|aha_ccb_physbase
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahamapsgs
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aha_softc
modifier|*
name|aha
decl_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|SLIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|sg_maps
argument_list|)
operator|->
name|sg_physaddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahapoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|aha_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahatimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aha_ccb
modifier|*
name|accb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|aha_softc
modifier|*
name|aha
decl_stmt|;
name|int
name|s
decl_stmt|;
name|uint32_t
name|paddr
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|accb
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|accb
operator|->
name|ccb
expr_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_aha_ptr
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CCB %p - timed out\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|accb
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CCB %p - timed out CCB already completed\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|accb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * In order to simplify the recovery process, we ask the XPT 	 * layer to halt the queue of new transactions and we traverse 	 * the list of pending CCBs and remove their timeouts. This 	 * means that the driver attempts to clear only one error 	 * condition at a time.  In general, timeouts that occur 	 * close together are related anyway, so there is no benefit 	 * in attempting to handle errors in parrallel.  Timeouts will 	 * be reinstated when the recovery process ends. 	 */
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_DEVICE_RESET
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|aha
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|accb
operator|->
name|flags
operator||=
name|ACCB_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|aha
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|aha_ccb
modifier|*
name|pending_accb
decl_stmt|;
name|pending_accb
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_accb_ptr
expr_stmt|;
name|untimeout
argument_list|(
name|ahatimeout
argument_list|,
name|pending_accb
argument_list|,
name|ccb_h
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|accb
operator|->
name|flags
operator|&
name|ACCB_DEVICE_RESET
operator|)
operator|!=
literal|0
operator|||
name|aha
operator|->
name|cur_outbox
operator|->
name|action_code
operator|!=
name|AMBO_FREE
condition|)
block|{
comment|/* 		 * Try a full host adapter/SCSI bus reset. 		 * We do this only if we have already attempted 		 * to clear the condition with a BDR, or we cannot 		 * attempt a BDR for lack of mailbox resources. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|ahareset
argument_list|(
name|aha
argument_list|,
comment|/*hardreset*/
name|TRUE
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|aha
operator|->
name|dev
argument_list|,
literal|"No longer in timeout\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Send a Bus Device Reset message: 		 * The target that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths), 		 * but we have no way of determining this from our 		 * timeout handler.  Our strategy here is to queue a 		 * BDR message to the target of the timed out command. 		 * If this fails, we'll get another timeout 2 seconds 		 * later which will attempt a bus reset. 		 */
name|accb
operator|->
name|flags
operator||=
name|ACCB_DEVICE_RESET
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahatimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|accb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|aha
operator|->
name|recovery_accb
operator|->
name|hccb
operator|.
name|opcode
operator|=
name|INITIATOR_BUS_DEV_RESET
expr_stmt|;
comment|/* No Data Transfer */
name|aha
operator|->
name|recovery_accb
operator|->
name|hccb
operator|.
name|datain
operator|=
name|TRUE
expr_stmt|;
name|aha
operator|->
name|recovery_accb
operator|->
name|hccb
operator|.
name|dataout
operator|=
name|TRUE
expr_stmt|;
name|aha
operator|->
name|recovery_accb
operator|->
name|hccb
operator|.
name|ahastat
operator|=
literal|0
expr_stmt|;
name|aha
operator|->
name|recovery_accb
operator|->
name|hccb
operator|.
name|sdstat
operator|=
literal|0
expr_stmt|;
name|aha
operator|->
name|recovery_accb
operator|->
name|hccb
operator|.
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
comment|/* Tell the adapter about this command */
name|paddr
operator|=
name|ahaccbvtop
argument_list|(
name|aha
argument_list|,
name|aha
operator|->
name|recovery_accb
argument_list|)
expr_stmt|;
name|ahautoa24
argument_list|(
name|paddr
argument_list|,
name|aha
operator|->
name|cur_outbox
operator|->
name|ccb_addr
argument_list|)
expr_stmt|;
name|aha
operator|->
name|cur_outbox
operator|->
name|action_code
operator|=
name|AMBO_START
expr_stmt|;
name|aha_outb
argument_list|(
name|aha
argument_list|,
name|COMMAND_REG
argument_list|,
name|AOP_START_MBOX
argument_list|)
expr_stmt|;
name|ahanextoutbox
argument_list|(
name|aha
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|aha_detach
parameter_list|(
name|struct
name|aha_softc
modifier|*
name|aha
parameter_list|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|aha
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|aha
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|aha
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|aha
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|aha
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

