begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Benno Rice.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for SMSC LAN91C111, may work for older variants.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<dev/smc/if_smcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/smc/if_smcvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii_bitbang.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_define
define|#
directive|define
name|SMC_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&(sc)->smc_mtx)
end_define

begin_define
define|#
directive|define
name|SMC_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&(sc)->smc_mtx)
end_define

begin_define
define|#
directive|define
name|SMC_ASSERT_LOCKED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->smc_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|SMC_INTR_PRIORITY
value|0
end_define

begin_define
define|#
directive|define
name|SMC_RX_PRIORITY
value|5
end_define

begin_define
define|#
directive|define
name|SMC_TX_PRIORITY
value|10
end_define

begin_decl_stmt
name|devclass_t
name|smc_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|smc_chip_ids
index|[
literal|16
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
comment|/* 3 */
literal|"SMSC LAN91C90 or LAN91C92"
block|,
comment|/* 4 */
literal|"SMSC LAN91C94"
block|,
comment|/* 5 */
literal|"SMSC LAN91C95"
block|,
comment|/* 6 */
literal|"SMSC LAN91C96"
block|,
comment|/* 7 */
literal|"SMSC LAN91C100"
block|,
comment|/* 8 */
literal|"SMSC LAN91C100FD"
block|,
comment|/* 9 */
literal|"SMSC LAN91C110FD or LAN91C111FD"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|smc_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_stop
parameter_list|(
name|struct
name|smc_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smc_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_init_locked
parameter_list|(
name|struct
name|smc_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_reset
parameter_list|(
name|struct
name|smc_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smc_mii_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_mii_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_mii_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_mii_mediachg
parameter_list|(
name|struct
name|smc_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smc_mii_mediaioctl
parameter_list|(
name|struct
name|smc_softc
modifier|*
parameter_list|,
name|struct
name|ifreq
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_task_intr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_task_rx
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_task_tx
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|driver_filter_t
name|smc_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|smc_watchdog
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|smc_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MII bit-bang glue  */
end_comment

begin_function_decl
specifier|static
name|uint32_t
name|smc_mii_bitbang_read
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smc_mii_bitbang_write
parameter_list|(
name|device_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mii_bitbang_ops
name|smc_mii_bitbang_ops
init|=
block|{
name|smc_mii_bitbang_read
block|,
name|smc_mii_bitbang_write
block|,
block|{
name|MGMT_MDO
block|,
comment|/* MII_BIT_MDO */
name|MGMT_MDI
block|,
comment|/* MII_BIT_MDI */
name|MGMT_MCLK
block|,
comment|/* MII_BIT_MDC */
name|MGMT_MDOE
block|,
comment|/* MII_BIT_DIR_HOST_PHY */
literal|0
block|,
comment|/* MII_BIT_DIR_PHY_HOST */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|smc_select_bank
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|bank
parameter_list|)
block|{
name|bus_barrier
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|BSR
argument_list|,
literal|2
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|bus_write_2
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|BSR
argument_list|,
name|bank
operator|&
name|BSR_BANK_MASK
argument_list|)
expr_stmt|;
name|bus_barrier
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|BSR
argument_list|,
literal|2
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Never call this when not in bank 2. */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|smc_mmu_wait
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|bus_read_2
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|BSR
argument_list|)
operator|&
name|BSR_BANK_MASK
operator|)
operator|==
literal|2
argument_list|,
operator|(
literal|"%s: smc_mmu_wait called when not in bank 2"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|bus_read_2
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|MMUCR
argument_list|)
operator|&
name|MMUCR_BUSY
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
name|smc_read_1
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
return|return
operator|(
name|bus_read_1
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|smc_write_1
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|bus_write_1
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint16_t
name|smc_read_2
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
return|return
operator|(
name|bus_read_2
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|smc_write_2
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|bus_write_2
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|smc_read_multi_2
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint16_t
modifier|*
name|datap
parameter_list|,
name|bus_size_t
name|count
parameter_list|)
block|{
name|bus_read_multi_2
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|offset
argument_list|,
name|datap
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|smc_write_multi_2
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint16_t
modifier|*
name|datap
parameter_list|,
name|bus_size_t
name|count
parameter_list|)
block|{
name|bus_write_multi_2
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|offset
argument_list|,
name|datap
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|smc_barrier
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|bus_size_t
name|length
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bus_barrier
argument_list|(
name|sc
operator|->
name|smc_reg
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|rid
decl_stmt|,
name|type
decl_stmt|,
name|error
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_usemem
condition|)
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|reg
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|16
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate I/O resource for probe\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Check for the identification value in the BSR. */
name|val
operator|=
name|bus_read_2
argument_list|(
name|reg
argument_list|,
name|BSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BSR_IDENTIFY_MASK
operator|)
operator|!=
name|BSR_IDENTIFY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"identification value not in BSR\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Try switching banks and make sure we still get the identification 	 * value. 	 */
name|bus_write_2
argument_list|(
name|reg
argument_list|,
name|BSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|bus_read_2
argument_list|(
name|reg
argument_list|,
name|BSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|BSR_IDENTIFY_MASK
operator|)
operator|!=
name|BSR_IDENTIFY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"identification value not in BSR after write\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
literal|0
comment|/* Check the BAR. */
block|bus_write_2(reg, BSR, 1); 	val = bus_read_2(reg, BAR); 	val = BAR_ADDRESS(val); 	if (rman_get_start(reg) != val) { 		if (bootverbose) 			device_printf(dev, "BAR address %x does not match " 			    "I/O resource address %lx\n", val, 			    rman_get_start(reg)); 		error = ENXIO; 		goto done; 	}
endif|#
directive|endif
comment|/* Compare REV against known chip revisions. */
name|bus_write_2
argument_list|(
name|reg
argument_list|,
name|BSR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|bus_read_2
argument_list|(
name|reg
argument_list|,
name|REV
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|&
name|REV_CHIP_MASK
operator|)
operator|>>
name|REV_CHIP_SHIFT
expr_stmt|;
if|if
condition|(
name|smc_chip_ids
index|[
name|val
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unknown chip revision: %d\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|smc_chip_ids
index|[
name|val
index|]
argument_list|)
expr_stmt|;
name|done
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|smc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|error
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|u_char
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|smc_dev
operator|=
name|dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|smc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|smc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Set up watchdog callout. */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|smc_watchdog
argument_list|,
operator|&
name|sc
operator|->
name|smc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_usemem
condition|)
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|sc
operator|->
name|smc_reg_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|smc_reg
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|sc
operator|->
name|smc_reg_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|16
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_reg
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|smc_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|smc_irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_irq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|REV
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_chip
operator|=
operator|(
name|val
operator|&
name|REV_CHIP_MASK
operator|)
operator|>>
name|REV_CHIP_SHIFT
expr_stmt|;
name|sc
operator|->
name|smc_rev
operator|=
operator|(
name|val
operator|*
name|REV_REV_MASK
operator|)
operator|>>
name|REV_REV_SHIFT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"revision %x\n"
argument_list|,
name|sc
operator|->
name|smc_rev
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|smc_mii_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|smc_mtx
argument_list|,
name|CALLOUT_RETURNUNLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_chip
operator|>=
name|REV_CHIP_91110FD
condition|)
block|{
operator|(
name|void
operator|)
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|smc_miibus
argument_list|,
name|ifp
argument_list|,
name|smc_mii_ifmedia_upd
argument_list|,
name|smc_mii_ifmedia_sts
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_miibus
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|smc_mii_tick
operator|=
name|smc_mii_tick
expr_stmt|;
name|sc
operator|->
name|smc_mii_mediachg
operator|=
name|smc_mii_mediachg
expr_stmt|;
name|sc
operator|->
name|smc_mii_mediaioctl
operator|=
name|smc_mii_mediaioctl
expr_stmt|;
block|}
block|}
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|IAR0
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|1
index|]
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|IAR1
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|2
index|]
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|IAR2
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|IAR3
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|IAR4
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|IAR5
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|smc_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|smc_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|smc_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|ifp
operator|->
name|if_capenable
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Set up taskqueue */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|smc_intr
argument_list|,
name|SMC_INTR_PRIORITY
argument_list|,
name|smc_task_intr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|smc_rx
argument_list|,
name|SMC_RX_PRIORITY
argument_list|,
name|smc_task_rx
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|smc_tx
argument_list|,
name|SMC_TX_PRIORITY
argument_list|,
name|smc_task_tx
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"smc_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|smc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|smc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mask all interrupts. */
name|sc
operator|->
name|smc_mask
operator|=
literal|0
expr_stmt|;
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wire up interrupt */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|smc_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|smc_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|smc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|done
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|smc_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|smc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|smc_ifp
argument_list|)
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|smc_watchdog
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|smc_mii_tick_ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|sc
operator|->
name|smc_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|sc
operator|->
name|smc_ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|smc_ih
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|,
name|sc
operator|->
name|smc_irq
argument_list|,
name|sc
operator|->
name|smc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_intr
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_rx
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_tx
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_tq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|smc_ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|sc
operator|->
name|smc_ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|smc_miibus
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|,
name|sc
operator|->
name|smc_miibus
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|smc_reg
operator|!=
name|NULL
condition|)
block|{
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_usemem
condition|)
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|,
name|type
argument_list|,
name|sc
operator|->
name|smc_reg_rid
argument_list|,
name|sc
operator|->
name|smc_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|smc_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|smc_irq_rid
argument_list|,
name|sc
operator|->
name|smc_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|smc_mtx
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|smc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|npages
decl_stmt|,
name|spin_count
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|SMC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
return|return;
if|if
condition|(
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
return|return;
comment|/* 	 * Grab the next packet.  If it's too big, drop it. 	 */
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|len
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|len
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"large packet discarded\n"
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX readcheck? */
block|}
comment|/* 	 * Flag that we're busy. 	 */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|smc_pending
operator|=
name|m
expr_stmt|;
comment|/* 	 * Work out how many 256 byte "pages" we need.  We have to include the 	 * control data for the packet in this calculation. 	 */
name|npages
operator|=
operator|(
name|len
operator|*
name|PKT_CTRL_DATA_LEN
operator|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|npages
operator|==
literal|0
condition|)
name|npages
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Request memory. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|smc_mmu_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|MMUCR
argument_list|,
name|MMUCR_CMD_TX_ALLOC
operator||
name|npages
argument_list|)
expr_stmt|;
comment|/* 	 * Spin briefly to see if the allocation succeeds. 	 */
name|spin_count
operator|=
name|TX_ALLOC_WAIT_TIME
expr_stmt|;
do|do
block|{
if|if
condition|(
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|IST
argument_list|)
operator|&
name|ALLOC_INT
condition|)
block|{
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|ACK
argument_list|,
name|ALLOC_INT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|--
name|spin_count
condition|)
do|;
comment|/* 	 * If the allocation is taking too long, unmask the alloc interrupt 	 * and wait. 	 */
if|if
condition|(
name|spin_count
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|smc_mask
operator||=
name|ALLOC_INT
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|==
literal|0
condition|)
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
name|sc
operator|->
name|smc_mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_task_tx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|u_int
name|packet
decl_stmt|,
name|len
decl_stmt|;
name|int
name|last_len
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
operator|(
name|void
operator|)
name|pending
expr_stmt|;
name|ifp
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|context
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_pending
operator|==
name|NULL
condition|)
block|{
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|next_packet
goto|;
block|}
name|m
operator|=
name|m0
operator|=
name|sc
operator|->
name|smc_pending
expr_stmt|;
name|sc
operator|->
name|smc_pending
operator|=
name|NULL
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Check the allocation result. 	 */
name|packet
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|ARR
argument_list|)
expr_stmt|;
comment|/* 	 * If the allocation failed, requeue the packet and retry. 	 */
if|if
condition|(
name|packet
operator|&
name|ARR_FAILED
condition|)
block|{
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|smc_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Tell the device to write to our packet number. 	 */
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|PNR
argument_list|,
name|packet
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|PTR
argument_list|,
literal|0
operator||
name|PTR_AUTO_INCR
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the device how long the packet is (including control data). 	 */
name|len
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|+=
name|PKT_CTRL_DATA_LEN
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Push the data out to the device. 	 */
name|data
operator|=
name|NULL
expr_stmt|;
name|last_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|smc_write_multi_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|data
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
name|last_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
comment|/* 	 * Push out the control byte and and the odd byte if needed. 	 */
if|if
condition|(
operator|(
name|len
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|data
operator|!=
name|NULL
condition|)
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|,
operator|(
name|CTRL_ODD
operator|<<
literal|8
operator|)
operator||
name|data
index|[
name|last_len
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Unmask the TX empty interrupt. 	 */
name|sc
operator|->
name|smc_mask
operator||=
name|TX_EMPTY_INT
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|==
literal|0
condition|)
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
name|sc
operator|->
name|smc_mask
argument_list|)
expr_stmt|;
comment|/* 	 * Enqueue the packet. 	 */
name|smc_mmu_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|MMUCR
argument_list|,
name|MMUCR_CMD_ENQUEUE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|smc_watchdog
argument_list|,
name|hz
operator|*
literal|2
argument_list|,
name|smc_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Finish up. 	 */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|next_packet
label|:
comment|/* 	 * See if there's anything else to do. 	 */
name|smc_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_task_rx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|u_int
name|packet
decl_stmt|,
name|status
decl_stmt|,
name|len
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mhead
decl_stmt|,
modifier|*
name|mtail
decl_stmt|;
operator|(
name|void
operator|)
name|pending
expr_stmt|;
name|ifp
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|context
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mhead
operator|=
name|mtail
operator|=
name|NULL
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|packet
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|FIFO_RX
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|packet
operator|&
name|FIFO_EMPTY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Grab an mbuf and attach a cluster. 		 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Point to the start of the packet. 		 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|PNR
argument_list|,
name|packet
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|PTR
argument_list|,
literal|0
operator||
name|PTR_READ
operator||
name|PTR_RCV
operator||
name|PTR_AUTO_INCR
argument_list|)
expr_stmt|;
comment|/* 		 * Grab status and packet length. 		 */
name|status
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|)
expr_stmt|;
name|len
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|)
operator|&
name|RX_LEN_MASK
expr_stmt|;
name|len
operator|-=
literal|6
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|RX_ODDFRM
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
comment|/* 		 * Check for errors. 		 */
if|if
condition|(
name|status
operator|&
operator|(
name|RX_TOOSHORT
operator||
name|RX_TOOLNG
operator||
name|RX_BADCRC
operator||
name|RX_ALGNERR
operator|)
condition|)
block|{
name|smc_mmu_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|MMUCR
argument_list|,
name|MMUCR_CMD_RELEASE
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Set the mbuf up the way we want it. 		 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|+
literal|2
expr_stmt|;
comment|/* XXX: Is this right? */
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
comment|/* 		 * Pull the packet out of the device.  Make sure we're in the 		 * right bank first as things may have changed while we were 		 * allocating our mbuf. 		 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|PNR
argument_list|,
name|packet
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|PTR
argument_list|,
literal|4
operator||
name|PTR_READ
operator||
name|PTR_RCV
operator||
name|PTR_AUTO_INCR
argument_list|)
expr_stmt|;
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|smc_read_multi_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
operator|*
name|data
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Tell the device we're done. 		 */
name|smc_mmu_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|MMUCR
argument_list|,
name|MMUCR_CMD_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|mhead
operator|==
name|NULL
condition|)
block|{
name|mhead
operator|=
name|mtail
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mtail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mtail
operator|=
name|m
expr_stmt|;
block|}
name|packet
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|FIFO_RX
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|smc_mask
operator||=
name|RCV_INT
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|==
literal|0
condition|)
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
name|sc
operator|->
name|smc_mask
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|mhead
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|mhead
expr_stmt|;
name|mhead
operator|=
name|mhead
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function
specifier|static
name|void
name|smc_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|smc_intr
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|smc_softc
operator|*
operator|)
name|context
expr_stmt|;
comment|/* 	 * Block interrupts in order to let smc_task_intr to kick in 	 */
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_intr
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_task_intr
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|status
decl_stmt|,
name|packet
decl_stmt|,
name|counter
decl_stmt|,
name|tcr
decl_stmt|;
operator|(
name|void
operator|)
name|pending
expr_stmt|;
name|ifp
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|context
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Find out what interrupts are flagged. 	 */
name|status
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|IST
argument_list|)
operator|&
name|sc
operator|->
name|smc_mask
expr_stmt|;
comment|/* 	 * Transmit error 	 */
if|if
condition|(
name|status
operator|&
name|TX_INT
condition|)
block|{
comment|/* 		 * Kill off the packet if there is one and re-enable transmit. 		 */
name|packet
operator|=
name|smc_read_1
argument_list|(
name|sc
argument_list|,
name|FIFO_TX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|packet
operator|&
name|FIFO_EMPTY
operator|)
operator|==
literal|0
condition|)
block|{
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|PNR
argument_list|,
name|packet
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|PTR
argument_list|,
literal|0
operator||
name|PTR_READ
operator||
name|PTR_AUTO_INCR
argument_list|)
expr_stmt|;
name|tcr
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|DATA0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcr
operator|&
name|EPHSR_TX_SUC
operator|)
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|,
literal|"bad packet\n"
argument_list|)
expr_stmt|;
name|smc_mmu_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|MMUCR
argument_list|,
name|MMUCR_CMD_RELEASE_PKT
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcr
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|TCR
argument_list|)
expr_stmt|;
name|tcr
operator||=
name|TCR_TXENA
operator||
name|TCR_PAD_EN
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|TCR
argument_list|,
name|tcr
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_tx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Ack the interrupt. 		 */
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|ACK
argument_list|,
name|TX_INT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Receive 	 */
if|if
condition|(
name|status
operator|&
name|RCV_INT
condition|)
block|{
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|ACK
argument_list|,
name|RCV_INT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_mask
operator|&=
operator|~
name|RCV_INT
expr_stmt|;
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_rx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocation 	 */
if|if
condition|(
name|status
operator|&
name|ALLOC_INT
condition|)
block|{
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|ACK
argument_list|,
name|ALLOC_INT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_mask
operator|&=
operator|~
name|ALLOC_INT
expr_stmt|;
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Receive overrun 	 */
if|if
condition|(
name|status
operator|&
name|RX_OVRN_INT
condition|)
block|{
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|ACK
argument_list|,
name|RX_OVRN_INT
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Transmit empty 	 */
if|if
condition|(
name|status
operator|&
name|TX_EMPTY_INT
condition|)
block|{
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|ACK
argument_list|,
name|TX_EMPTY_INT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_mask
operator|&=
operator|~
name|TX_EMPTY_INT
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|smc_watchdog
argument_list|)
expr_stmt|;
comment|/* 		 * Update collision stats. 		 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|counter
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|ECR
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFNET_COLLISIONS
argument_list|,
operator|(
operator|(
name|counter
operator|&
name|ECR_SNGLCOL_MASK
operator|)
operator|>>
name|ECR_SNGLCOL_SHIFT
operator|)
operator|+
operator|(
operator|(
name|counter
operator|&
name|ECR_MULCOL_MASK
operator|)
operator|>>
name|ECR_MULCOL_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * See if there are any packets to transmit. 		 */
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the interrupt mask. 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|==
literal|0
condition|)
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
name|sc
operator|->
name|smc_mask
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|smc_mii_bitbang_read
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SMC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|BSR
argument_list|)
operator|&
name|BSR_BANK_MASK
operator|)
operator|==
literal|3
argument_list|,
operator|(
literal|"%s: smc_mii_bitbang_read called with bank %d (!= 3)"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|)
operator|,
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|BSR
argument_list|)
operator|&
name|BSR_BANK_MASK
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|MGMT
argument_list|)
expr_stmt|;
name|smc_barrier
argument_list|(
name|sc
argument_list|,
name|MGMT
argument_list|,
literal|2
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_mii_bitbang_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SMC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|BSR
argument_list|)
operator|&
name|BSR_BANK_MASK
operator|)
operator|==
literal|3
argument_list|,
operator|(
literal|"%s: smc_mii_bitbang_write called with bank %d (!= 3)"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|)
operator|,
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|BSR
argument_list|)
operator|&
name|BSR_BANK_MASK
operator|)
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|MGMT
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|smc_barrier
argument_list|(
name|sc
argument_list|,
name|MGMT
argument_list|,
literal|2
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smc_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|val
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|mii_bitbang_readreg
argument_list|(
name|dev
argument_list|,
operator|&
name|smc_mii_bitbang_ops
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|int
name|smc_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|mii_bitbang_writereg
argument_list|(
name|dev
argument_list|,
operator|&
name|smc_mii_bitbang_ops
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|smc_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint16_t
name|tcr
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|smc_miibus
argument_list|)
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcr
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|TCR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|tcr
operator||=
name|TCR_SWFDUP
expr_stmt|;
else|else
name|tcr
operator|&=
operator|~
name|TCR_SWFDUP
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|TCR
argument_list|,
name|tcr
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|smc_mii_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_miibus
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|smc_miibus
argument_list|)
expr_stmt|;
return|return
operator|(
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_mii_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_miibus
operator|==
name|NULL
condition|)
return|return;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|smc_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_mii_tick
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|smc_softc
operator|*
operator|)
name|context
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_miibus
operator|==
name|NULL
condition|)
return|return;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|device_get_softc
argument_list|(
name|sc
operator|->
name|smc_miibus
argument_list|)
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|smc_mii_tick_ch
argument_list|,
name|hz
argument_list|,
name|smc_mii_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_mii_mediachg
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|smc_miibus
operator|==
name|NULL
condition|)
return|return;
name|mii_mediachg
argument_list|(
name|device_get_softc
argument_list|(
name|sc
operator|->
name|smc_miibus
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|smc_mii_mediaioctl
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifreq
modifier|*
name|ifr
parameter_list|,
name|u_long
name|command
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_miibus
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|smc_miibus
argument_list|)
expr_stmt|;
return|return
operator|(
name|ifmedia_ioctl
argument_list|(
name|sc
operator|->
name|smc_ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_reset
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|ctr
decl_stmt|;
name|SMC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Mask all interrupts. 	 */
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the device to reset. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|RCR
argument_list|,
name|RCR_SOFT_RST
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the configuration register. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|CR
argument_list|,
name|CR_EPH_POWER_EN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off transmit and receive. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|RCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the control register. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctr
operator|=
name|smc_read_2
argument_list|(
name|sc
argument_list|,
name|CTR
argument_list|)
expr_stmt|;
name|ctr
operator||=
name|CTR_LE_ENABLE
operator||
name|CTR_AUTO_RELEASE
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|CTR
argument_list|,
name|ctr
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the MMU. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|smc_mmu_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|MMUCR
argument_list|,
name|MMUCR_CMD_MMU_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_enable
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|SMC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|smc_ifp
expr_stmt|;
comment|/* 	 * Set up the receive/PHY control register. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|RPCR
argument_list|,
name|RPCR_ANEG
operator||
operator|(
name|RPCR_LED_LINK_ANY
operator|<<
name|RPCR_LSA_SHIFT
operator|)
operator||
operator|(
name|RPCR_LED_ACT_ANY
operator|<<
name|RPCR_LSB_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the transmit and receive control registers. 	 */
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|TCR
argument_list|,
name|TCR_TXENA
operator||
name|TCR_PAD_EN
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|RCR
argument_list|,
name|RCR_RXEN
operator||
name|RCR_STRIP_CRC
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the interrupt mask. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_mask
operator|=
name|EPH_INT
operator||
name|RX_OVRN_INT
operator||
name|RCV_INT
operator||
name|TX_INT
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
condition|)
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
name|sc
operator|->
name|smc_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_stop
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|SMC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off callouts. 	 */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|smc_watchdog
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|smc_mii_tick_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Mask all interrupts. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_mask
operator|=
literal|0
expr_stmt|;
name|smc_write_1
argument_list|(
name|sc
argument_list|,
name|MSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|ether_poll_deregister
argument_list|(
name|sc
operator|->
name|smc_ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|sc
operator|->
name|smc_ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING_NOCOUNT
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Disable transmit and receive. 	 */
name|smc_select_bank
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smc_write_2
argument_list|(
name|sc
argument_list|,
name|RCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smc_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|smc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|smc_dev
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|smc_tq
argument_list|,
operator|&
name|sc
operator|->
name|smc_intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_init
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|smc_softc
operator|*
operator|)
name|context
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smc_init_locked
parameter_list|(
name|struct
name|smc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|SMC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|smc_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
name|smc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|smc_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_mii_tick
operator|!=
name|NULL
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|smc_mii_tick_ch
argument_list|,
name|hz
argument_list|,
name|sc
operator|->
name|smc_mii_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_poll_register
argument_list|(
name|smc_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING_NOCOUNT
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|smc_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|smc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|SMC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|smc_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SMC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|smc_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smc_mii_mediachg
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|smc_mii_mediachg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* XXX 		SMC_LOCK(sc); 		smc_setmcast(sc); 		SMC_UNLOCK(sc); 		*/
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
if|if
condition|(
name|sc
operator|->
name|smc_mii_mediaioctl
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|smc_mii_mediaioctl
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

