begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 Myson Technology Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Written by: yen_cw@myson.com.tw  available at: http://www.myson.com.tw/  *  * $FreeBSD$  *  * Myson fast ethernet PCI NIC driver  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_define
define|#
directive|define
name|NBPFILTER
value|1
end_define

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_comment
comment|/*  * #define MY_USEIOSPACE  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|MY_USEIOSPACE
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|MY_USEIOSPACE
operator|)
end_if

begin_define
define|#
directive|define
name|MY_RES
value|SYS_RES_IOPORT
end_define

begin_define
define|#
directive|define
name|MY_RID
value|MY_PCI_LOIO
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MY_RES
value|SYS_RES_MEMORY
end_define

begin_define
define|#
directive|define
name|MY_RID
value|MY_PCI_LOMEM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/my/if_myreg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: if_my.c,v 1.50 2001/12/03 04:15:33<yen_cw@myson.com.tw> wpaul Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Various supported device vendors/types and their names.  */
end_comment

begin_decl_stmt
name|struct
name|my_type
modifier|*
name|my_info_tmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|my_type
name|my_devs
index|[]
init|=
block|{
block|{
name|MYSONVENDORID
block|,
name|MTD800ID
block|,
literal|"Myson MTD80X Based Fast Ethernet Card"
block|}
block|,
block|{
name|MYSONVENDORID
block|,
name|MTD803ID
block|,
literal|"Myson MTD80X Based Fast Ethernet Card"
block|}
block|,
block|{
name|MYSONVENDORID
block|,
name|MTD891ID
block|,
literal|"Myson MTD89X Based Giga Ethernet Card"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Various supported PHY vendors/types and their names. Note that this driver  * will work with pretty much any MII-compliant PHY, so failure to positively  * identify the chip is not a fatal error.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|my_type
name|my_phys
index|[]
init|=
block|{
block|{
name|MysonPHYID0
block|,
name|MysonPHYID0
block|,
literal|"<MYSON MTD981>"
block|}
block|,
block|{
name|SeeqPHYID0
block|,
name|SeeqPHYID0
block|,
literal|"<SEEQ 80225>"
block|}
block|,
block|{
name|AhdocPHYID0
block|,
name|AhdocPHYID0
block|,
literal|"<AHDOC 101>"
block|}
block|,
block|{
name|MarvellPHYID0
block|,
name|MarvellPHYID0
block|,
literal|"<MARVELL 88E1000>"
block|}
block|,
block|{
name|LevelOnePHYID0
block|,
name|LevelOnePHYID0
block|,
literal|"<LevelOne LXT1000>"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|"<MII-compliant physical interface>"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|my_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_newbuf
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|,
name|struct
name|my_chain_onefrag
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_encap
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|,
name|struct
name|my_chain
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_rxeof
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_txeof
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_txeoc
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_stop
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|my_phy_readreg
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_phy_writereg
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_autoneg_xmit
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_autoneg_mii
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_setmode_mii
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_getmode_mii
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_setcfg
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|my_calchash
parameter_list|(
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_setmulti
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_reset
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_list_rx_init
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_list_tx_init
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|my_send_cmd_to_phy
parameter_list|(
name|struct
name|my_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MY_SETBIT
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|x
parameter_list|)
value|CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) | x)
end_define

begin_define
define|#
directive|define
name|MY_CLRBIT
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|x
parameter_list|)
value|CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg)& ~x)
end_define

begin_decl_stmt
specifier|static
name|device_method_t
name|my_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|my_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|my_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|my_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|my_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|my_driver
init|=
block|{
literal|"my"
block|,
name|my_methods
block|,
expr|sizeof
operator|(
expr|struct
name|my_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|my_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_my
argument_list|,
name|pci
argument_list|,
name|my_driver
argument_list|,
name|my_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|long
name|my_send_cmd_to_phy
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|,
name|int
name|opcode
parameter_list|,
name|int
name|regad
parameter_list|)
block|{
name|long
name|miir
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|data
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* enable MII output */
name|miir
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|)
expr_stmt|;
name|miir
operator|&=
literal|0xfffffff0
expr_stmt|;
name|miir
operator||=
name|MY_MASK_MIIR_MII_WRITE
operator|+
name|MY_MASK_MIIR_MII_MDO
expr_stmt|;
comment|/* send 32 1's preamble */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* low MDC; MDO is already high (miir) */
name|miir
operator|&=
operator|~
name|MY_MASK_MIIR_MII_MDC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
comment|/* high MDC */
name|miir
operator||=
name|MY_MASK_MIIR_MII_MDC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
block|}
comment|/* calculate ST+OP+PHYAD+REGAD+TA */
name|data
operator|=
name|opcode
operator||
operator|(
name|sc
operator|->
name|my_phy_addr
operator|<<
literal|7
operator|)
operator||
operator|(
name|regad
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* sent out */
name|mask
operator|=
literal|0x8000
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
comment|/* low MDC, prepare MDO */
name|miir
operator|&=
operator|~
operator|(
name|MY_MASK_MIIR_MII_MDC
operator|+
name|MY_MASK_MIIR_MII_MDO
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|data
condition|)
name|miir
operator||=
name|MY_MASK_MIIR_MII_MDO
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
comment|/* high MDC */
name|miir
operator||=
name|MY_MASK_MIIR_MII_MDC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* next */
name|mask
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0x2
operator|&&
name|opcode
operator|==
name|MY_OP_READ
condition|)
name|miir
operator|&=
operator|~
name|MY_MASK_MIIR_MII_WRITE
expr_stmt|;
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|miir
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|my_phy_readreg
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|long
name|miir
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|data
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_info
operator|->
name|my_did
operator|==
name|MTD803ID
condition|)
name|data
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|MY_PHYBASE
operator|+
name|reg
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|miir
operator|=
name|my_send_cmd_to_phy
argument_list|(
name|sc
argument_list|,
name|MY_OP_READ
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* read data */
name|mask
operator|=
literal|0x8000
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
comment|/* low MDC */
name|miir
operator|&=
operator|~
name|MY_MASK_MIIR_MII_MDC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
comment|/* read MDI */
name|miir
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|miir
operator|&
name|MY_MASK_MIIR_MII_MDI
condition|)
name|data
operator||=
name|mask
expr_stmt|;
comment|/* high MDC, and wait */
name|miir
operator||=
name|MY_MASK_MIIR_MII_MDC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* next */
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* low MDC */
name|miir
operator|&=
operator|~
name|MY_MASK_MIIR_MII_MDC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_int16_t
operator|)
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_phy_writereg
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|long
name|miir
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_info
operator|->
name|my_did
operator|==
name|MTD803ID
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MY_PHYBASE
operator|+
name|reg
operator|*
literal|2
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|miir
operator|=
name|my_send_cmd_to_phy
argument_list|(
name|sc
argument_list|,
name|MY_OP_WRITE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* write data */
name|mask
operator|=
literal|0x8000
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
comment|/* low MDC, prepare MDO */
name|miir
operator|&=
operator|~
operator|(
name|MY_MASK_MIIR_MII_MDC
operator|+
name|MY_MASK_MIIR_MII_MDO
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|data
condition|)
name|miir
operator||=
name|MY_MASK_MIIR_MII_MDO
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* high MDC */
name|miir
operator||=
name|MY_MASK_MIIR_MII_MDC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* next */
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* low MDC */
name|miir
operator|&=
operator|~
name|MY_MASK_MIIR_MII_MDC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MANAGEMENT
argument_list|,
name|miir
argument_list|)
expr_stmt|;
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|my_calchash
parameter_list|(
name|caddr_t
name|addr
parameter_list|)
block|{
name|u_int32_t
name|crc
decl_stmt|,
name|carry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int8_t
name|c
decl_stmt|;
comment|/* Compute CRC for the address value. */
name|crc
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* initial value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
operator|(
name|addr
operator|+
name|i
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|carry
operator|=
operator|(
operator|(
name|crc
operator|&
literal|0x80000000
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|^
operator|(
name|c
operator|&
literal|0x01
operator|)
expr_stmt|;
name|crc
operator|<<=
literal|1
expr_stmt|;
name|c
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|carry
condition|)
name|crc
operator|=
operator|(
name|crc
operator|^
literal|0x04c11db6
operator|)
operator||
name|carry
expr_stmt|;
block|}
block|}
comment|/* 	 * return the filter bit position Note: I arrived at the following 	 * nonsense through experimentation. It's not the usual way to 	 * generate the bit position but it's the only thing I could come up 	 * with that works. 	 */
return|return
operator|(
operator|~
operator|(
name|crc
operator|>>
literal|26
operator|)
operator|&
literal|0x0000003F
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Program the 64-bit multicast hash filter.  */
end_comment

begin_function
specifier|static
name|void
name|my_setmulti
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|h
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|hashes
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u_int32_t
name|rxfilt
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|rxfilt
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|rxfilt
operator||=
name|MY_AM
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|rxfilt
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MAR0
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MAR1
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* first, zot all the existing hash bits */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MAR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MAR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* now program new ones */
comment|/* 	 * Add by Surfer for (ifma = ifp->if_multiaddrs.lh_first; ifma != 	 * NULL; ifma = ifma->ifma_link.le_next) { if 	 * (ifma->ifma_addr->sa_family != AF_LINK) continue; h = 	 * my_calchash(LLADDR((struct sockaddr_dl *)ifma->ifma_addr)); if (h 	 *< 32) hashes[0] |= (1<< h); else hashes[1] |= (1<< (h - 32)); 	 * mcnt++; } 	 */
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|h
operator|=
name|my_calchash
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|32
condition|)
name|hashes
index|[
literal|0
index|]
operator||=
operator|(
literal|1
operator|<<
name|h
operator|)
expr_stmt|;
else|else
name|hashes
index|[
literal|1
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|h
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mcnt
condition|)
name|rxfilt
operator||=
name|MY_AM
expr_stmt|;
else|else
name|rxfilt
operator|&=
operator|~
name|MY_AM
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MAR0
argument_list|,
name|hashes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_MAR1
argument_list|,
name|hashes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|rxfilt
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Initiate an autonegotiation session.  */
end_comment

begin_function
specifier|static
name|void
name|my_autoneg_xmit
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|phy_sts
init|=
literal|0
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|my_phy_writereg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
operator|&
name|PHY_BMCR_RESET
condition|)
empty_stmt|;
name|phy_sts
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
expr_stmt|;
name|phy_sts
operator||=
name|PHY_BMCR_AUTONEGENBL
operator||
name|PHY_BMCR_AUTONEGRSTR
expr_stmt|;
name|my_phy_writereg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|,
name|phy_sts
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Invoke autonegotiation on a PHY.  */
end_comment

begin_function
specifier|static
name|void
name|my_autoneg_mii
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|u_int16_t
name|phy_sts
init|=
literal|0
decl_stmt|,
name|media
decl_stmt|,
name|advert
decl_stmt|,
name|ability
decl_stmt|;
name|u_int16_t
name|ability2
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|ifmedia
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
ifndef|#
directive|ifndef
name|FORCE_AUTONEG_TFOUR
comment|/* 	 * First, see if autoneg is supported. If not, there's no point in 	 * continuing. 	 */
name|phy_sts
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy_sts
operator|&
name|PHY_BMSR_CANAUTONEG
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"my%d: autonegotiation not supported\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_HDX
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|MY_FLAG_FORCEDELAY
case|:
comment|/* 		 * XXX Never use this option anywhere but in the probe 		 * routine: making the kernel stop dead in its tracks for 		 * three whole seconds after we've gone multi-user is really 		 * bad manners. 		 */
name|my_autoneg_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000000
argument_list|)
expr_stmt|;
break|break;
case|case
name|MY_FLAG_SCHEDDELAY
case|:
comment|/* 		 * Wait for the transmitter to go idle before starting an 		 * autoneg session, otherwise my_start() may clobber our 		 * timeout, and we don't want to allow transmission during an 		 * autoneg session since that can screw it up. 		 */
if|if
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|my_want_auto
operator|=
literal|1
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|my_autoneg_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|sc
operator|->
name|my_autoneg
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|my_want_auto
operator|=
literal|0
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
case|case
name|MY_FLAG_DELAYTIMEO
case|:
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|my_autoneg
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"my%d: invalid autoneg flag: %d\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMSR
argument_list|)
operator|&
name|PHY_BMSR_AUTONEGCOMP
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"my%d: autoneg complete, "
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|phy_sts
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"my%d: autoneg not complete, "
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
block|}
name|media
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
expr_stmt|;
comment|/* Link is good. Report modes and set duplex mode. */
if|if
condition|(
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMSR
argument_list|)
operator|&
name|PHY_BMSR_LINKSTAT
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"my%d: link status good. "
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|advert
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_ANAR
argument_list|)
expr_stmt|;
name|ability
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|my_pinfo
operator|->
name|my_vid
operator|==
name|MarvellPHYID0
operator|)
operator|||
operator|(
name|sc
operator|->
name|my_pinfo
operator|->
name|my_vid
operator|==
name|LevelOnePHYID0
operator|)
condition|)
block|{
name|ability2
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_1000SR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ability2
operator|&
name|PHY_1000SR_1000BTXFULL
condition|)
block|{
name|advert
operator|=
literal|0
expr_stmt|;
name|ability
operator|=
literal|0
expr_stmt|;
comment|/* 				 * this version did not support 1000M, 				 * ifm->ifm_media = 				 * IFM_ETHER|IFM_1000_TX|IFM_FDX; 				 */
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
name|media
operator|&=
operator|~
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
name|media
operator||=
name|PHY_BMCR_1000
expr_stmt|;
name|media
operator||=
name|PHY_BMCR_DUPLEX
expr_stmt|;
name|printf
argument_list|(
literal|"(full-duplex, 1000Mbps)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ability2
operator|&
name|PHY_1000SR_1000BTXHALF
condition|)
block|{
name|advert
operator|=
literal|0
expr_stmt|;
name|ability
operator|=
literal|0
expr_stmt|;
comment|/* 				 * this version did not support 1000M, 				 * ifm->ifm_media = IFM_ETHER|IFM_1000_TX; 				 */
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
expr_stmt|;
name|media
operator|&=
operator|~
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
name|media
operator|&=
operator|~
name|PHY_BMCR_DUPLEX
expr_stmt|;
name|media
operator||=
name|PHY_BMCR_1000
expr_stmt|;
name|printf
argument_list|(
literal|"(half-duplex, 1000Mbps)\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_100BT4
operator|&&
name|ability
operator|&
name|PHY_ANAR_100BT4
condition|)
block|{
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_T4
expr_stmt|;
name|media
operator||=
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
name|media
operator|&=
operator|~
name|PHY_BMCR_DUPLEX
expr_stmt|;
name|printf
argument_list|(
literal|"(100baseT4)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_100BTXFULL
operator|&&
name|ability
operator|&
name|PHY_ANAR_100BTXFULL
condition|)
block|{
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
name|media
operator||=
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
name|media
operator||=
name|PHY_BMCR_DUPLEX
expr_stmt|;
name|printf
argument_list|(
literal|"(full-duplex, 100Mbps)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_100BTXHALF
operator|&&
name|ability
operator|&
name|PHY_ANAR_100BTXHALF
condition|)
block|{
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_HDX
expr_stmt|;
name|media
operator||=
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
name|media
operator|&=
operator|~
name|PHY_BMCR_DUPLEX
expr_stmt|;
name|printf
argument_list|(
literal|"(half-duplex, 100Mbps)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_10BTFULL
operator|&&
name|ability
operator|&
name|PHY_ANAR_10BTFULL
condition|)
block|{
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
expr_stmt|;
name|media
operator|&=
operator|~
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
name|media
operator||=
name|PHY_BMCR_DUPLEX
expr_stmt|;
name|printf
argument_list|(
literal|"(full-duplex, 10Mbps)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|advert
condition|)
block|{
name|ifm
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_HDX
expr_stmt|;
name|media
operator|&=
operator|~
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
name|media
operator|&=
operator|~
name|PHY_BMCR_DUPLEX
expr_stmt|;
name|printf
argument_list|(
literal|"(half-duplex, 10Mbps)\n"
argument_list|)
expr_stmt|;
block|}
name|media
operator|&=
operator|~
name|PHY_BMCR_AUTONEGENBL
expr_stmt|;
comment|/* Set ASIC's duplex mode to match the PHY. */
name|my_phy_writereg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|my_setcfg
argument_list|(
name|sc
argument_list|,
name|media
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"my%d: no carrier\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
block|}
name|my_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_tx_pend
condition|)
block|{
name|sc
operator|->
name|my_autoneg
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|my_tx_pend
operator|=
literal|0
expr_stmt|;
name|my_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * To get PHY ability.  */
end_comment

begin_function
specifier|static
name|void
name|my_getmode_mii
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|bmsr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|bmsr
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: PHY status word: %x\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|,
name|bmsr
argument_list|)
expr_stmt|;
comment|/* fallback */
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_HDX
expr_stmt|;
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_10BTHALF
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: 10Mbps half-duplex mode supported\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_HDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_10BTFULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: 10Mbps full-duplex mode supported\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
expr_stmt|;
block|}
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_100BTXHALF
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: 100Mbps half-duplex mode supported\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_HDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_HDX
expr_stmt|;
block|}
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_100BTXFULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: 100Mbps full-duplex mode supported\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
block|}
comment|/* Some also support 100BaseT4. */
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_100BT4
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: 100baseT4 mode supported\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_T4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_T4
expr_stmt|;
ifdef|#
directive|ifdef
name|FORCE_AUTONEG_TFOUR
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: forcing on autoneg support for BT4\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
name|NULL
argument_list|)
operator|:
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
comment|/* this version did not support 1000M, */
block|if (sc->my_pinfo->my_vid == MarvellPHYID0) { 		if (bootverbose) 			printf("my%d: 1000Mbps half-duplex mode supported\n", 			       sc->my_unit);  		ifp->if_baudrate = 1000000000; 		ifmedia_add(&sc->ifmedia, IFM_ETHER | IFM_1000_TX, 0, NULL); 		ifmedia_add(&sc->ifmedia, IFM_ETHER | IFM_1000_TX | IFM_HDX, 		    0, NULL); 		if (bootverbose) 			printf("my%d: 1000Mbps full-duplex mode supported\n", 			   sc->my_unit); 		ifp->if_baudrate = 1000000000; 		ifmedia_add(&sc->ifmedia, IFM_ETHER | IFM_1000_TX | IFM_FDX, 		    0, NULL); 		sc->ifmedia.ifm_media = IFM_ETHER | IFM_1000_TX | IFM_FDX; 	}
endif|#
directive|endif
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_CANAUTONEG
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: autoneg supported\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Set speed and duplex mode.  */
end_comment

begin_function
specifier|static
name|void
name|my_setmode_mii
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|,
name|int
name|media
parameter_list|)
block|{
name|u_int16_t
name|bmcr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* 	 * If an autoneg session is in progress, stop it. 	 */
if|if
condition|(
name|sc
operator|->
name|my_autoneg
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: canceling autoneg session\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
name|sc
operator|->
name|my_autoneg
operator|=
name|sc
operator|->
name|my_want_auto
operator|=
literal|0
expr_stmt|;
name|bmcr
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
expr_stmt|;
name|bmcr
operator|&=
operator|~
name|PHY_BMCR_AUTONEGENBL
expr_stmt|;
name|my_phy_writereg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"my%d: selecting MII, "
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|bmcr
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
expr_stmt|;
name|bmcr
operator|&=
operator|~
operator|(
name|PHY_BMCR_AUTONEGENBL
operator||
name|PHY_BMCR_SPEEDSEL
operator||
name|PHY_BMCR_1000
operator||
name|PHY_BMCR_DUPLEX
operator||
name|PHY_BMCR_LOOPBK
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this version did not support 1000M, */
block|if (IFM_SUBTYPE(media) == IFM_1000_TX) { 		printf("1000Mbps/T4, half-duplex\n"); 		bmcr&= ~PHY_BMCR_SPEEDSEL; 		bmcr&= ~PHY_BMCR_DUPLEX; 		bmcr |= PHY_BMCR_1000; 	}
endif|#
directive|endif
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_100_T4
condition|)
block|{
name|printf
argument_list|(
literal|"100Mbps/T4, half-duplex\n"
argument_list|)
expr_stmt|;
name|bmcr
operator||=
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
name|bmcr
operator|&=
operator|~
name|PHY_BMCR_DUPLEX
expr_stmt|;
block|}
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_100_TX
condition|)
block|{
name|printf
argument_list|(
literal|"100Mbps, "
argument_list|)
expr_stmt|;
name|bmcr
operator||=
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
block|}
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_10_T
condition|)
block|{
name|printf
argument_list|(
literal|"10Mbps, "
argument_list|)
expr_stmt|;
name|bmcr
operator|&=
operator|~
name|PHY_BMCR_SPEEDSEL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
block|{
name|printf
argument_list|(
literal|"full duplex\n"
argument_list|)
expr_stmt|;
name|bmcr
operator||=
name|PHY_BMCR_DUPLEX
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"half duplex\n"
argument_list|)
expr_stmt|;
name|bmcr
operator|&=
operator|~
name|PHY_BMCR_DUPLEX
expr_stmt|;
block|}
name|my_phy_writereg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|my_setcfg
argument_list|(
name|sc
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The Myson manual states that in order to fiddle with the 'full-duplex' and  * '100Mbps' bits in the netconfig register, we first have to put the  * transmit and/or receive logic in the idle state.  */
end_comment

begin_function
specifier|static
name|void
name|my_setcfg
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bmcr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|restart
init|=
literal|0
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|)
operator|&
operator|(
name|MY_TE
operator||
name|MY_RE
operator|)
condition|)
block|{
name|restart
operator|=
literal|1
expr_stmt|;
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
operator|(
name|MY_TE
operator||
name|MY_RE
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|)
operator|&
operator|(
name|MY_TXRUN
operator||
name|MY_RXRUN
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MY_TIMEOUT
condition|)
name|printf
argument_list|(
literal|"my%d: failed to force tx and rx to idle \n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
block|}
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_PS1000
argument_list|)
expr_stmt|;
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_PS10
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmcr
operator|&
name|PHY_BMCR_1000
condition|)
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_PS1000
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|bmcr
operator|&
name|PHY_BMCR_SPEEDSEL
operator|)
condition|)
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_PS10
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmcr
operator|&
name|PHY_BMCR_DUPLEX
condition|)
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_FD
argument_list|)
expr_stmt|;
else|else
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_FD
argument_list|)
expr_stmt|;
if|if
condition|(
name|restart
condition|)
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_TE
operator||
name|MY_RE
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|my_reset
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_BCR
argument_list|,
name|MY_SWR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_BCR
argument_list|)
operator|&
name|MY_SWR
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MY_TIMEOUT
condition|)
name|printf
argument_list|(
literal|"m0x%d: reset never completed!\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
comment|/* Wait a little while for the chip to get its brains in order. */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Probe for a Myson chip. Check the PCI vendor and device IDs against our  * list and return a device name if we find a match.  */
end_comment

begin_function
specifier|static
name|int
name|my_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|my_type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|my_devs
expr_stmt|;
while|while
condition|(
name|t
operator|->
name|my_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|t
operator|->
name|my_vid
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|t
operator|->
name|my_did
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|t
operator|->
name|my_name
argument_list|)
expr_stmt|;
name|my_info_tmp
operator|=
name|t
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|t
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the interface. Allocate softc structures, do ifmedia setup and  * ethernet/BPF attach.  */
end_comment

begin_function
specifier|static
name|int
name|my_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|u_char
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|u_int32_t
name|command
decl_stmt|,
name|iobase
decl_stmt|;
name|struct
name|my_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|media
init|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
decl_stmt|;
name|unsigned
name|int
name|round
decl_stmt|;
name|caddr_t
name|roundptr
decl_stmt|;
name|struct
name|my_type
modifier|*
name|p
decl_stmt|;
name|u_int16_t
name|phy_vid
decl_stmt|,
name|phy_did
decl_stmt|,
name|phy_sts
init|=
literal|0
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|unit
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: no memory for softc struct!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|my_softc
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|my_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
if|#
directive|if
literal|0
block|command = pci_read_config(dev, PCI_COMMAND_STATUS_REG, 4); 	command |= (PCIM_CMD_PORTEN | PCIM_CMD_MEMEN | PCIM_CMD_BUSMASTEREN); 	pci_write_config(dev, PCI_COMMAND_STATUS_REG, command& 0x000000ff, 4); 	command = pci_read_config(dev, PCI_COMMAND_STATUS_REG, 4);
endif|#
directive|endif
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|command
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
operator|&
literal|0x000000ff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_info_tmp
operator|->
name|my_did
operator|==
name|MTD800ID
condition|)
block|{
name|iobase
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|MY_PCI_LOIO
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|iobase
operator|&
literal|0x300
condition|)
name|MY_USEIOSPACE
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|MY_USEIOSPACE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|PCIM_CMD_PORTEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: failed to enable I/O ports!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|#
directive|if
literal|0
block|if (!pci_map_port(config_id, MY_PCI_LOIO, (u_int16_t *)& (sc->my_bhandle))) { 			printf("my%d: couldn't map ports\n", unit); 			error = ENXIO; 			goto fail; 		} 		   		sc->my_btag = I386_BUS_SPACE_IO;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|PCIM_CMD_MEMEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: failed to enable memory mapping!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|#
directive|if
literal|0
block|if (!pci_map_mem(config_id, MY_PCI_LOMEM,&vbase,&pbase)) { 			printf ("my%d: couldn't map memory\n", unit); 			error = ENXIO; 			goto fail; 		} 		sc->my_btag = I386_BUS_SPACE_MEM; 		sc->my_bhandle = vbase;
endif|#
directive|endif
block|}
name|rid
operator|=
name|MY_RID
expr_stmt|;
name|sc
operator|->
name|my_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|MY_RES
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_res
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: couldn't map ports/memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|my_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|my_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|my_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|my_res
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|my_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_irq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: couldn't map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|MY_RES
argument_list|,
name|MY_RID
argument_list|,
name|sc
operator|->
name|my_res
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|my_irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|my_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|my_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|my_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|MY_RES
argument_list|,
name|MY_RID
argument_list|,
name|sc
operator|->
name|my_res
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"my%d: couldn't set up irq\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|my_stat_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|my_info
operator|=
name|my_info_tmp
expr_stmt|;
comment|/* Reset the adapter. */
name|my_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Get station address 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|eaddr
index|[
name|i
index|]
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|MY_PAR0
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * A Myson chip was detected. Inform the world. 	 */
name|printf
argument_list|(
literal|"my%d: Ethernet address: %6D\n"
argument_list|,
name|unit
argument_list|,
name|eaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|my_unit
operator|=
name|unit
expr_stmt|;
name|bcopy
argument_list|(
name|eaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|my_ldata_ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|my_list_data
argument_list|)
operator|+
literal|8
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_ldata_ptr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"my%d: no memory for list buffers!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|my_ldata
operator|=
operator|(
expr|struct
name|my_list_data
operator|*
operator|)
name|sc
operator|->
name|my_ldata_ptr
expr_stmt|;
name|round
operator|=
operator|(
name|unsigned
name|int
operator|)
name|sc
operator|->
name|my_ldata_ptr
operator|&
literal|0xF
expr_stmt|;
name|roundptr
operator|=
name|sc
operator|->
name|my_ldata_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|round
operator|%
literal|8
condition|)
block|{
name|round
operator|++
expr_stmt|;
name|roundptr
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
name|sc
operator|->
name|my_ldata
operator|=
operator|(
expr|struct
name|my_list_data
operator|*
operator|)
name|roundptr
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|my_ldata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|my_list_data
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"my"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|my_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|my_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|my_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|my_init
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_info
operator|->
name|my_did
operator|==
name|MTD803ID
condition|)
name|sc
operator|->
name|my_pinfo
operator|=
name|my_phys
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: probing for a PHY\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MY_PHYADDR_MIN
init|;
name|i
operator|<
name|MY_PHYADDR_MAX
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: checking address: %d\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|my_phy_addr
operator|=
name|i
expr_stmt|;
name|phy_sts
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_sts
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|phy_sts
operator|!=
literal|0xffff
operator|)
condition|)
break|break;
else|else
name|phy_sts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|phy_sts
condition|)
block|{
name|phy_vid
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_VENID
argument_list|)
expr_stmt|;
name|phy_did
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_DEVID
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: found PHY at address %d, "
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|,
name|sc
operator|->
name|my_phy_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vendor id: %x device id: %x\n"
argument_list|,
name|phy_vid
argument_list|,
name|phy_did
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|my_phys
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|my_vid
condition|)
block|{
if|if
condition|(
name|phy_vid
operator|==
name|p
operator|->
name|my_vid
condition|)
block|{
name|sc
operator|->
name|my_pinfo
operator|=
name|p
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|my_pinfo
operator|==
name|NULL
condition|)
name|sc
operator|->
name|my_pinfo
operator|=
operator|&
name|my_phys
index|[
name|PHY_UNKNOWN
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"my%d: PHY type: %s\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|,
name|sc
operator|->
name|my_pinfo
operator|->
name|my_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"my%d: MII without any phy!\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Do ifmedia setup. */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
literal|0
argument_list|,
name|my_ifmedia_upd
argument_list|,
name|my_ifmedia_sts
argument_list|)
expr_stmt|;
name|my_getmode_mii
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|my_autoneg_mii
argument_list|(
name|sc
argument_list|,
name|MY_FLAG_FORCEDELAY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|media
operator|=
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
expr_stmt|;
name|my_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|at_shutdown(my_shutdown, sc, SHUTDOWN_POST_SYNC); 	shutdownhook_establish(my_shutdown, sc);
endif|#
directive|endif
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|my_mtx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|my_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_generic_detach(dev); 	device_delete_child(dev, sc->rl_miibus);
endif|#
directive|endif
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|my_irq
argument_list|,
name|sc
operator|->
name|my_intrhand
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|my_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|MY_RES
argument_list|,
name|MY_RID
argument_list|,
name|sc
operator|->
name|my_res
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|contigfree(sc->my_cdata.my_rx_buf, MY_RXBUFLEN + 32, M_DEVBUF);
endif|#
directive|endif
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|my_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the transmit descriptors.  */
end_comment

begin_function
specifier|static
name|int
name|my_list_tx_init
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|my_chain_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|my_list_data
modifier|*
name|ld
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|sc
operator|->
name|my_cdata
expr_stmt|;
name|ld
operator|=
name|sc
operator|->
name|my_ldata
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MY_TX_LIST_CNT
condition|;
name|i
operator|++
control|)
block|{
name|cd
operator|->
name|my_tx_chain
index|[
name|i
index|]
operator|.
name|my_ptr
operator|=
operator|&
name|ld
operator|->
name|my_tx_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|MY_TX_LIST_CNT
operator|-
literal|1
operator|)
condition|)
name|cd
operator|->
name|my_tx_chain
index|[
name|i
index|]
operator|.
name|my_nextdesc
operator|=
operator|&
name|cd
operator|->
name|my_tx_chain
index|[
literal|0
index|]
expr_stmt|;
else|else
name|cd
operator|->
name|my_tx_chain
index|[
name|i
index|]
operator|.
name|my_nextdesc
operator|=
operator|&
name|cd
operator|->
name|my_tx_chain
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|cd
operator|->
name|my_tx_free
operator|=
operator|&
name|cd
operator|->
name|my_tx_chain
index|[
literal|0
index|]
expr_stmt|;
name|cd
operator|->
name|my_tx_tail
operator|=
name|cd
operator|->
name|my_tx_head
operator|=
name|NULL
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the RX descriptors and allocate mbufs for them. Note that we  * arrange the descriptors in a closed ring, so that the last descriptor  * points back to the first.  */
end_comment

begin_function
specifier|static
name|int
name|my_list_rx_init
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|my_chain_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|my_list_data
modifier|*
name|ld
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|sc
operator|->
name|my_cdata
expr_stmt|;
name|ld
operator|=
name|sc
operator|->
name|my_ldata
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MY_RX_LIST_CNT
condition|;
name|i
operator|++
control|)
block|{
name|cd
operator|->
name|my_rx_chain
index|[
name|i
index|]
operator|.
name|my_ptr
operator|=
operator|(
expr|struct
name|my_desc
operator|*
operator|)
operator|&
name|ld
operator|->
name|my_rx_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|my_newbuf
argument_list|(
name|sc
argument_list|,
operator|&
name|cd
operator|->
name|my_rx_chain
index|[
name|i
index|]
argument_list|)
operator|==
name|ENOBUFS
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
name|i
operator|==
operator|(
name|MY_RX_LIST_CNT
operator|-
literal|1
operator|)
condition|)
block|{
name|cd
operator|->
name|my_rx_chain
index|[
name|i
index|]
operator|.
name|my_nextdesc
operator|=
operator|&
name|cd
operator|->
name|my_rx_chain
index|[
literal|0
index|]
expr_stmt|;
name|ld
operator|->
name|my_rx_list
index|[
name|i
index|]
operator|.
name|my_next
operator|=
name|vtophys
argument_list|(
operator|&
name|ld
operator|->
name|my_rx_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cd
operator|->
name|my_rx_chain
index|[
name|i
index|]
operator|.
name|my_nextdesc
operator|=
operator|&
name|cd
operator|->
name|my_rx_chain
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|ld
operator|->
name|my_rx_list
index|[
name|i
index|]
operator|.
name|my_next
operator|=
name|vtophys
argument_list|(
operator|&
name|ld
operator|->
name|my_rx_list
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|cd
operator|->
name|my_rx_head
operator|=
operator|&
name|cd
operator|->
name|my_rx_chain
index|[
literal|0
index|]
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize an RX descriptor and attach an MBUF cluster.  */
end_comment

begin_function
specifier|static
name|int
name|my_newbuf
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|my_chain_onefrag
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
init|=
name|NULL
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: no memory for rx list -- packet dropped!\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|MCLGET
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m_new
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: no memory for rx list -- packet dropped!\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|c
operator|->
name|my_mbuf
operator|=
name|m_new
expr_stmt|;
name|c
operator|->
name|my_ptr
operator|->
name|my_data
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m_new
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|my_ptr
operator|->
name|my_ctl
operator|=
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
operator|<<
name|MY_RBSShift
expr_stmt|;
name|c
operator|->
name|my_ptr
operator|->
name|my_status
operator|=
name|MY_OWNByNIC
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A frame has been uploaded: pass the resulting mbuf chain up to the higher  * level protocols.  */
end_comment

begin_function
specifier|static
name|void
name|my_rxeof
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|my_chain_onefrag
modifier|*
name|cur_rx
decl_stmt|;
name|int
name|total_len
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|rxstat
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|rxstat
operator|=
name|sc
operator|->
name|my_cdata
operator|.
name|my_rx_head
operator|->
name|my_ptr
operator|->
name|my_status
operator|)
operator|&
name|MY_OWNByNIC
operator|)
condition|)
block|{
name|cur_rx
operator|=
name|sc
operator|->
name|my_cdata
operator|.
name|my_rx_head
expr_stmt|;
name|sc
operator|->
name|my_cdata
operator|.
name|my_rx_head
operator|=
name|cur_rx
operator|->
name|my_nextdesc
expr_stmt|;
if|if
condition|(
name|rxstat
operator|&
name|MY_ES
condition|)
block|{
comment|/* error summary: give up this rx pkt */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|cur_rx
operator|->
name|my_ptr
operator|->
name|my_status
operator|=
name|MY_OWNByNIC
expr_stmt|;
continue|continue;
block|}
comment|/* No errors; receive the packet. */
name|total_len
operator|=
operator|(
name|rxstat
operator|&
name|MY_FLNGMASK
operator|)
operator|>>
name|MY_FLNGShift
expr_stmt|;
name|total_len
operator|-=
name|ETHER_CRC_LEN
expr_stmt|;
if|if
condition|(
name|total_len
operator|<
name|MINCLSIZE
condition|)
block|{
name|m
operator|=
name|m_devget
argument_list|(
name|mtod
argument_list|(
name|cur_rx
operator|->
name|my_mbuf
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|total_len
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cur_rx
operator|->
name|my_ptr
operator|->
name|my_status
operator|=
name|MY_OWNByNIC
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|m
operator|=
name|cur_rx
operator|->
name|my_mbuf
expr_stmt|;
comment|/* 			 * Try to conjure up a new mbuf cluster. If that 			 * fails, it means we have an out of memory condition 			 * and should leave the buffer in place and continue. 			 * This will result in a lost packet, but there's 			 * little else we can do in this situation. 			 */
if|if
condition|(
name|my_newbuf
argument_list|(
name|sc
argument_list|,
name|cur_rx
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|cur_rx
operator|->
name|my_ptr
operator|->
name|my_status
operator|=
name|MY_OWNByNIC
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|total_len
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 		 * Handle BPF listeners. Let the BPF user see the packet, but 		 * don't pass it up to the ether_input() layer unless it's a 		 * broadcast packet, multicast packet, matches our ethernet 		 * address or the interface is in promiscuous mode. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|(
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* Remove header from mbuf and pass it on. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * A frame was downloaded to the chip. It's safe for us to clean up the list  * buffers.  */
end_comment

begin_function
specifier|static
name|void
name|my_txeof
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|my_chain
modifier|*
name|cur_tx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* Clear the timeout timer. */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Go through our tx list and free mbufs for those frames that have 	 * been transmitted. 	 */
while|while
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|->
name|my_mbuf
operator|!=
name|NULL
condition|)
block|{
name|u_int32_t
name|txstat
decl_stmt|;
name|cur_tx
operator|=
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
expr_stmt|;
name|txstat
operator|=
name|MY_TXSTATUS
argument_list|(
name|cur_tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txstat
operator|&
name|MY_OWNByNIC
operator|)
operator|||
name|txstat
operator|==
name|MY_UNSENT
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|)
operator|&
name|MY_Enhanced
operator|)
condition|)
block|{
if|if
condition|(
name|txstat
operator|&
name|MY_TXERR
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|txstat
operator|&
name|MY_EC
condition|)
comment|/* excessive collision */
name|ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
if|if
condition|(
name|txstat
operator|&
name|MY_LC
condition|)
comment|/* late collision */
name|ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
block|}
name|ifp
operator|->
name|if_collisions
operator|+=
operator|(
name|txstat
operator|&
name|MY_NCRMASK
operator|)
operator|>>
name|MY_NCRShift
expr_stmt|;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|cur_tx
operator|->
name|my_mbuf
argument_list|)
expr_stmt|;
name|cur_tx
operator|->
name|my_mbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|==
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_tail
condition|)
block|{
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_tail
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|=
name|cur_tx
operator|->
name|my_nextdesc
expr_stmt|;
block|}
if|if
condition|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|)
operator|&
name|MY_Enhanced
condition|)
block|{
name|ifp
operator|->
name|if_collisions
operator|+=
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_TSR
argument_list|)
operator|&
name|MY_NCRMask
operator|)
expr_stmt|;
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * TX 'end of channel' interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|my_txeoc
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_tail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_want_auto
condition|)
name|my_autoneg_mii
argument_list|(
name|sc
argument_list|,
name|MY_FLAG_SCHEDDELAY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|MY_TXOWN
argument_list|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
argument_list|)
operator|==
name|MY_UNSENT
condition|)
block|{
name|MY_TXOWN
argument_list|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
argument_list|)
operator|=
name|MY_OWNByNIC
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_TXPDR
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|my_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Disable interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_IMR
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MY_ISR
argument_list|)
expr_stmt|;
name|status
operator|&=
name|MY_INTRS
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_ISR
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|status
operator|&
name|MY_RI
condition|)
comment|/* receive interrupt */
name|my_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MY_RBU
operator|)
operator|||
operator|(
name|status
operator|&
name|MY_RxErr
operator|)
condition|)
block|{
comment|/* rx buffer unavailable or rx error */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|foo
name|my_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|my_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|my_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|MY_TI
condition|)
comment|/* tx interrupt */
name|my_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MY_ETI
condition|)
comment|/* tx early interrupt */
name|my_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MY_TBU
condition|)
comment|/* tx buffer unavailable */
name|my_txeoc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 90/1/18 delete */
block|if (status& MY_FBE) { 			my_reset(sc); 			my_init(sc); 		}
endif|#
directive|endif
block|}
comment|/* Re-enable interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_IMR
argument_list|,
name|MY_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|my_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data  * pointers to the fragment pointers.  */
end_comment

begin_function
specifier|static
name|int
name|my_encap
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|my_chain
modifier|*
name|c
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|my_desc
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|int
name|total_len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_new
init|=
name|NULL
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* calculate the total tx pkt length */
name|total_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|total_len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* 	 * Start packing the mbufs in this chain into the fragment pointers. 	 * Stop when we run out of fragments or hit the end of the mbuf 	 * chain. 	 */
name|m
operator|=
name|m_head
expr_stmt|;
name|MGETHDR
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: no memory for tx list"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m_new
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"my%d: no memory for tx list"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|m_copydata
argument_list|(
name|m_head
argument_list|,
literal|0
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m_new
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m_new
operator|->
name|m_len
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
name|m_head
operator|=
name|m_new
expr_stmt|;
name|f
operator|=
operator|&
name|c
operator|->
name|my_ptr
operator|->
name|my_frag
index|[
literal|0
index|]
expr_stmt|;
name|f
operator|->
name|my_status
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|my_data
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m_new
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|total_len
operator|=
name|m_new
operator|->
name|m_len
expr_stmt|;
name|f
operator|->
name|my_ctl
operator|=
name|MY_TXFD
operator||
name|MY_TXLD
operator||
name|MY_CRCEnable
operator||
name|MY_PADEnable
expr_stmt|;
name|f
operator|->
name|my_ctl
operator||=
name|total_len
operator|<<
name|MY_PKTShift
expr_stmt|;
comment|/* pkt size */
name|f
operator|->
name|my_ctl
operator||=
name|total_len
expr_stmt|;
comment|/* buffer size */
comment|/* 89/12/29 add, for mtd891 */
if|if
condition|(
name|sc
operator|->
name|my_info
operator|->
name|my_did
operator|==
name|MTD891ID
condition|)
name|f
operator|->
name|my_ctl
operator||=
name|MY_ETIControl
operator||
name|MY_RetryTxLC
expr_stmt|;
name|c
operator|->
name|my_mbuf
operator|=
name|m_head
expr_stmt|;
name|c
operator|->
name|my_lastdesc
operator|=
literal|0
expr_stmt|;
name|MY_TXNEXT
argument_list|(
name|c
argument_list|)
operator|=
name|vtophys
argument_list|(
operator|&
name|c
operator|->
name|my_nextdesc
operator|->
name|my_ptr
operator|->
name|my_frag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main transmit routine. To avoid having to do mbuf copies, we put pointers  * to the mbuf data regions directly in the transmit lists. We also save a  * copy of the pointers since the transmit list fragment pointers are  * physical addresses.  */
end_comment

begin_function
specifier|static
name|void
name|my_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
init|=
name|NULL
decl_stmt|;
name|struct
name|my_chain
modifier|*
name|cur_tx
init|=
name|NULL
decl_stmt|,
modifier|*
name|start_tx
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_autoneg
condition|)
block|{
name|sc
operator|->
name|my_tx_pend
operator|=
literal|1
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check for an available queue slot. If there are none, punt. 	 */
if|if
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_free
operator|->
name|my_mbuf
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_tx
operator|=
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_free
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_free
operator|->
name|my_mbuf
operator|==
name|NULL
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* Pick a descriptor off the free list. */
name|cur_tx
operator|=
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_free
expr_stmt|;
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_free
operator|=
name|cur_tx
operator|->
name|my_nextdesc
expr_stmt|;
comment|/* Pack the data into the descriptor. */
name|my_encap
argument_list|(
name|sc
argument_list|,
name|cur_tx
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_tx
operator|!=
name|start_tx
condition|)
name|MY_TXOWN
argument_list|(
name|cur_tx
argument_list|)
operator|=
name|MY_OWNByNIC
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 		 * If there's a BPF listener, bounce a copy of this frame to 		 * him. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|cur_tx
operator|->
name|my_mbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If there are no packets queued, bail. 	 */
if|if
condition|(
name|cur_tx
operator|==
name|NULL
condition|)
block|{
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Place the request for the upload interrupt in the last descriptor 	 * in the chain. This way, if we're chaining several packets at once, 	 * we'll only get an interupt once for the whole chain rather than 	 * once for each packet. 	 */
name|MY_TXCTL
argument_list|(
name|cur_tx
argument_list|)
operator||=
name|MY_TXIC
expr_stmt|;
name|cur_tx
operator|->
name|my_ptr
operator|->
name|my_frag
index|[
literal|0
index|]
operator|.
name|my_ctl
operator||=
name|MY_TXIC
expr_stmt|;
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_tail
operator|=
name|cur_tx
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|==
name|NULL
condition|)
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_head
operator|=
name|start_tx
expr_stmt|;
name|MY_TXOWN
argument_list|(
name|start_tx
argument_list|)
operator|=
name|MY_OWNByNIC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_TXPDR
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* tx polling demand */
comment|/* 	 * Set a timeout in case the chip goes out to lunch. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|my_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_int16_t
name|phy_bmcr
init|=
literal|0
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_autoneg
condition|)
block|{
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_pinfo
operator|!=
name|NULL
condition|)
name|phy_bmcr
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
expr_stmt|;
comment|/* 	 * Cancel pending I/O and free all RX/TX buffers. 	 */
name|my_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|my_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Set cache alignment and burst length. 	 */
if|#
directive|if
literal|0
comment|/* 89/9/1 modify,  */
block|CSR_WRITE_4(sc, MY_BCR, MY_RPBLE512); 	CSR_WRITE_4(sc, MY_TCRRCR, MY_TFTSF);
endif|#
directive|endif
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_BCR
argument_list|,
name|MY_PBL8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_TFTSF
operator||
name|MY_RBLEN
operator||
name|MY_RPBLE512
argument_list|)
expr_stmt|;
comment|/* 	 * 89/12/29 add, for mtd891, 	 */
if|if
condition|(
name|sc
operator|->
name|my_info
operator|->
name|my_did
operator|==
name|MTD891ID
condition|)
block|{
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_BCR
argument_list|,
name|MY_PROG
argument_list|)
expr_stmt|;
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_Enhanced
argument_list|)
expr_stmt|;
block|}
name|my_setcfg
argument_list|(
name|sc
argument_list|,
name|phy_bmcr
argument_list|)
expr_stmt|;
comment|/* Init circular RX list. */
if|if
condition|(
name|my_list_rx_init
argument_list|(
name|sc
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|printf
argument_list|(
literal|"my%d: init failed: no memory for rx buffers\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|my_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Init TX descriptors. */
name|my_list_tx_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If we want promiscuous mode, set the allframes bit. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_PROM
argument_list|)
expr_stmt|;
else|else
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_PROM
argument_list|)
expr_stmt|;
comment|/* 	 * Set capture broadcast bit to capture broadcast frames. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_AB
argument_list|)
expr_stmt|;
else|else
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_AB
argument_list|)
expr_stmt|;
comment|/* 	 * Program the multicast filter, if necessary. 	 */
name|my_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Load the address of the RX list. 	 */
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_RE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_RXLBA
argument_list|,
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|my_ldata
operator|->
name|my_rx_list
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Enable interrupts. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_IMR
argument_list|,
name|MY_INTRS
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_ISR
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Enable receiver and transmitter. */
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_RE
argument_list|)
expr_stmt|;
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_TE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_TXLBA
argument_list|,
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|my_ldata
operator|->
name|my_tx_list
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|MY_SETBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
name|MY_TE
argument_list|)
expr_stmt|;
comment|/* Restore state of BMCR */
if|if
condition|(
name|sc
operator|->
name|my_pinfo
operator|!=
name|NULL
condition|)
name|my_phy_writereg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|,
name|phy_bmcr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Set media options.  */
end_comment

begin_function
specifier|static
name|int
name|my_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|ifmedia
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
block|{
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_AUTO
condition|)
name|my_autoneg_mii
argument_list|(
name|sc
argument_list|,
name|MY_FLAG_SCHEDDELAY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|my_setmode_mii
argument_list|(
name|sc
argument_list|,
name|ifm
operator|->
name|ifm_media
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Report current media status.  */
end_comment

begin_function
specifier|static
name|void
name|my_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
decl_stmt|;
name|u_int16_t
name|advert
init|=
literal|0
decl_stmt|,
name|ability
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
operator|&
name|PHY_BMCR_AUTONEGENBL
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* this version did not support 1000M, */
block|if (my_phy_readreg(sc, PHY_BMCR)& PHY_BMCR_1000) 			ifmr->ifm_active = IFM_ETHER | IFM_1000TX;
endif|#
directive|endif
if|if
condition|(
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
operator|&
name|PHY_BMCR_SPEEDSEL
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
expr_stmt|;
if|if
condition|(
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMCR
argument_list|)
operator|&
name|PHY_BMCR_DUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ability
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_LPAR
argument_list|)
expr_stmt|;
name|advert
operator|=
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_ANAR
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this version did not support 1000M, */
block|if (sc->my_pinfo->my_vid = MarvellPHYID0) { 		ability2 = my_phy_readreg(sc, PHY_1000SR); 		if (ability2& PHY_1000SR_1000BTXFULL) { 			advert = 0; 			ability = 0; 	  		ifmr->ifm_active = IFM_ETHER|IFM_1000_TX|IFM_FDX; 	  	} else if (ability& PHY_1000SR_1000BTXHALF) { 			advert = 0; 			ability = 0; 			ifmr->ifm_active = IFM_ETHER|IFM_1000_TX|IFM_HDX; 		} 	}
endif|#
directive|endif
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_100BT4
operator|&&
name|ability
operator|&
name|PHY_ANAR_100BT4
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_100_T4
expr_stmt|;
elseif|else
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_100BTXFULL
operator|&&
name|ability
operator|&
name|PHY_ANAR_100BTXFULL
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
elseif|else
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_100BTXHALF
operator|&&
name|ability
operator|&
name|PHY_ANAR_100BTXHALF
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_HDX
expr_stmt|;
elseif|else
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_10BTFULL
operator|&&
name|ability
operator|&
name|PHY_ANAR_10BTFULL
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
expr_stmt|;
elseif|else
if|if
condition|(
name|advert
operator|&
name|PHY_ANAR_10BTHALF
operator|&&
name|ability
operator|&
name|PHY_ANAR_10BTHALF
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_HDX
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|my_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|my_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|my_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|my_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|my_autoneg
condition|)
block|{
name|my_autoneg_mii
argument_list|(
name|sc
argument_list|,
name|MY_FLAG_DELAYTIMEO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"my%d: watchdog timeout\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|my_phy_readreg
argument_list|(
name|sc
argument_list|,
name|PHY_BMSR
argument_list|)
operator|&
name|PHY_BMSR_LINKSTAT
operator|)
condition|)
name|printf
argument_list|(
literal|"my%d: no carrier - transceiver cable problem?\n"
argument_list|,
name|sc
operator|->
name|my_unit
argument_list|)
expr_stmt|;
name|my_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|my_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|my_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|my_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Stop the adapter and free any mbufs allocated to the RX and TX lists.  */
end_comment

begin_function
specifier|static
name|void
name|my_stop
parameter_list|(
name|struct
name|my_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|MY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|MY_CLRBIT
argument_list|(
name|sc
argument_list|,
name|MY_TCRRCR
argument_list|,
operator|(
name|MY_RE
operator||
name|MY_TE
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_IMR
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_TXLBA
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MY_RXLBA
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|/* 	 * Free data in the RX lists. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MY_RX_LIST_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_rx_chain
index|[
name|i
index|]
operator|.
name|my_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_rx_chain
index|[
name|i
index|]
operator|.
name|my_mbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|my_cdata
operator|.
name|my_rx_chain
index|[
name|i
index|]
operator|.
name|my_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|my_ldata
operator|->
name|my_rx_list
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|my_ldata
operator|->
name|my_rx_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Free the TX list buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MY_TX_LIST_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_chain
index|[
name|i
index|]
operator|.
name|my_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_chain
index|[
name|i
index|]
operator|.
name|my_mbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|my_cdata
operator|.
name|my_tx_chain
index|[
name|i
index|]
operator|.
name|my_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|my_ldata
operator|->
name|my_tx_list
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|my_ldata
operator|->
name|my_tx_list
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|MY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Stop all chip I/O so that the kernel's probe routines don't get confused  * by errant DMAs when rebooting.  */
end_comment

begin_function
specifier|static
name|void
name|my_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|my_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|my_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

