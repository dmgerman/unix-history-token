begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Ian Lepore<ian@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for NXP real-time clock/calendar chips:  *  - PCF8563 = low power, countdown timer  *  - PCA8565 = like PCF8563, automotive temperature range  *  - PCF8523 = low power, countdown timer, oscillator freq tuning, 2 timers  *  - PCF2127 = like PCF8523, industrial, tcxo, tamper/ts, i2c& spi, 512B ram  *  - PCA2129 = like PCF8523, automotive, tcxo, tamper/ts, i2c& spi, no timer  *  - PCF2129 = like PCF8523, industrial, tcxo, tamper/ts, i2c& spi, no timer  *  *  Most chips have a countdown timer, ostensibly intended to generate periodic  *  interrupt signals on an output pin.  The timer is driven from the same  *  divider chain that clocks the time of day registers, and they start counting  *  in sync when the STOP bit is cleared after the time and timer registers are  *  set.  The timer register can also be read on the fly, so we use it to count  *  fractional seconds and get a resolution of ~15ms.  */
end_comment

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iicbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"clock_if.h"
end_include

begin_include
include|#
directive|include
file|"iicbus_if.h"
end_include

begin_comment
comment|/*  * I2C address 1010 001x : PCA2129 PCF2127 PCF2129 PCF8563 PCF8565  * I2C address 1101 000x : PCF8523  */
end_comment

begin_define
define|#
directive|define
name|PCF8563_ADDR
value|0xa2
end_define

begin_define
define|#
directive|define
name|PCF8523_ADDR
value|0xd0
end_define

begin_comment
comment|/*  * Registers, bits within them, and masks that are common to all chip types.  */
end_comment

begin_define
define|#
directive|define
name|PCF85xx_R_CS1
value|0x00
end_define

begin_comment
comment|/* CS1 and CS2 control regs are in */
end_comment

begin_define
define|#
directive|define
name|PCF85xx_R_CS2
value|0x01
end_define

begin_comment
comment|/* the same location on all chips. */
end_comment

begin_define
define|#
directive|define
name|PCF85xx_B_CS1_STOP
value|0x20
end_define

begin_comment
comment|/* Stop time incrementing bit */
end_comment

begin_define
define|#
directive|define
name|PCF85xx_B_SECOND_OS
value|0x80
end_define

begin_comment
comment|/* Oscillator Stopped bit */
end_comment

begin_define
define|#
directive|define
name|PCF85xx_M_SECOND
value|0x7f
end_define

begin_comment
comment|/* Masks for all BCD time regs... */
end_comment

begin_define
define|#
directive|define
name|PCF85xx_M_MINUTE
value|0x7f
end_define

begin_define
define|#
directive|define
name|PCF85xx_M_12HOUR
value|0x1f
end_define

begin_define
define|#
directive|define
name|PCF85xx_M_24HOUR
value|0x3f
end_define

begin_define
define|#
directive|define
name|PCF85xx_M_DAY
value|0x3f
end_define

begin_define
define|#
directive|define
name|PCF85xx_M_MONTH
value|0x1f
end_define

begin_define
define|#
directive|define
name|PCF85xx_M_YEAR
value|0xff
end_define

begin_comment
comment|/*  * PCF2127-specific registers, bits, and masks.  */
end_comment

begin_define
define|#
directive|define
name|PCF2127_R_TMR_CTL
value|0x10
end_define

begin_comment
comment|/* Timer/watchdog control */
end_comment

begin_define
define|#
directive|define
name|PCF2127_M_TMR_CTRL
value|0xe3
end_define

begin_comment
comment|/* Mask off undef bits */
end_comment

begin_define
define|#
directive|define
name|PCF2127_B_TMR_CD
value|0x40
end_define

begin_comment
comment|/* Run in countdown mode */
end_comment

begin_define
define|#
directive|define
name|PCF2127_B_TMR_64HZ
value|0x01
end_define

begin_comment
comment|/* Timer frequency 64Hz */
end_comment

begin_comment
comment|/*  * PCA/PCF2129-specific registers, bits, and masks.  */
end_comment

begin_define
define|#
directive|define
name|PCF2129_B_CS1_12HR
value|0x04
end_define

begin_comment
comment|/* Use 12-hour (AM/PM) mode bit */
end_comment

begin_define
define|#
directive|define
name|PCF2129_B_CLKOUT_OTPR
value|0x20
end_define

begin_comment
comment|/* OTP refresh command */
end_comment

begin_define
define|#
directive|define
name|PCF2129_B_CLKOUT_HIGHZ
value|0x07
end_define

begin_comment
comment|/* Clock Out Freq = disable */
end_comment

begin_comment
comment|/*  * PCF8523-specific registers, bits, and masks.  */
end_comment

begin_define
define|#
directive|define
name|PCF8523_R_CS3
value|0x02
end_define

begin_comment
comment|/* Control and status reg 3 */
end_comment

begin_define
define|#
directive|define
name|PCF8523_R_SECOND
value|0x03
end_define

begin_comment
comment|/* Seconds */
end_comment

begin_define
define|#
directive|define
name|PCF8523_R_TMR_CLKOUT
value|0x0F
end_define

begin_comment
comment|/* Timer and clockout control */
end_comment

begin_define
define|#
directive|define
name|PCF8523_R_TMR_A_FREQ
value|0x10
end_define

begin_comment
comment|/* Timer A frequency control */
end_comment

begin_define
define|#
directive|define
name|PCF8523_R_TMR_A_COUNT
value|0x11
end_define

begin_comment
comment|/* Timer A count */
end_comment

begin_define
define|#
directive|define
name|PCF8523_M_TMR_A_FREQ
value|0x07
end_define

begin_comment
comment|/* Mask off undef bits */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_HOUR_PM
value|0x20
end_define

begin_comment
comment|/* PM bit */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_CS1_SOFTRESET
value|0x58
end_define

begin_comment
comment|/* Initiate Soft Reset bits */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_CS1_12HR
value|0x08
end_define

begin_comment
comment|/* Use 12-hour (AM/PM) mode bit */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_CLKOUT_TACD
value|0x02
end_define

begin_comment
comment|/* TimerA runs in CountDown mode */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_CLKOUT_HIGHZ
value|0x38
end_define

begin_comment
comment|/* Clock Out Freq = disable */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_TMR_A_64HZ
value|0x01
end_define

begin_comment
comment|/* Timer A freq 64Hz */
end_comment

begin_define
define|#
directive|define
name|PCF8523_M_CS3_PM
value|0xE0
end_define

begin_comment
comment|/* Power mode mask */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_CS3_PM_NOBAT
value|0xE0
end_define

begin_comment
comment|/* PM bits: no battery usage */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_CS3_PM_STD
value|0x00
end_define

begin_comment
comment|/* PM bits: standard */
end_comment

begin_define
define|#
directive|define
name|PCF8523_B_CS3_BLF
value|0x04
end_define

begin_comment
comment|/* Battery Low Flag bit */
end_comment

begin_comment
comment|/*  * PCF8563-specific registers, bits, and masks.  */
end_comment

begin_define
define|#
directive|define
name|PCF8563_R_SECOND
value|0x02
end_define

begin_comment
comment|/* Seconds */
end_comment

begin_define
define|#
directive|define
name|PCF8563_R_TMR_CTRL
value|0x0e
end_define

begin_comment
comment|/* Timer control */
end_comment

begin_define
define|#
directive|define
name|PCF8563_R_TMR_COUNT
value|0x0f
end_define

begin_comment
comment|/* Timer count */
end_comment

begin_define
define|#
directive|define
name|PCF8563_M_TMR_CTRL
value|0x93
end_define

begin_comment
comment|/* Mask off undef bits */
end_comment

begin_define
define|#
directive|define
name|PCF8563_B_TMR_ENABLE
value|0x80
end_define

begin_comment
comment|/* Enable countdown timer */
end_comment

begin_define
define|#
directive|define
name|PCF8563_B_TMR_64HZ
value|0x01
end_define

begin_comment
comment|/* Timer frequency 64Hz */
end_comment

begin_define
define|#
directive|define
name|PCF8563_B_MONTH_C
value|0x80
end_define

begin_comment
comment|/* Century bit */
end_comment

begin_comment
comment|/*  * We use the countdown timer for fractional seconds.  We program it for 64 Hz,  * the fastest available rate that doesn't roll over in less than a second.  */
end_comment

begin_define
define|#
directive|define
name|TMR_TICKS_SEC
value|64
end_define

begin_define
define|#
directive|define
name|TMR_TICKS_HALFSEC
value|32
end_define

begin_comment
comment|/*  * The chip types we support.  */
end_comment

begin_enum
enum|enum
block|{
name|TYPE_NONE
block|,
name|TYPE_PCA2129
block|,
name|TYPE_PCA8565
block|,
name|TYPE_PCF2127
block|,
name|TYPE_PCF2129
block|,
name|TYPE_PCF8523
block|,
name|TYPE_PCF8563
block|,
name|TYPE_COUNT
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|desc_strings
index|[]
init|=
block|{
literal|""
block|,
literal|"NXP PCA2129 RTC"
block|,
literal|"NXP PCA8565 RTC"
block|,
literal|"NXP PCF2127 RTC"
block|,
literal|"NXP PCF2129 RTC"
block|,
literal|"NXP PCF8523 RTC"
block|,
literal|"NXP PCF8563 RTC"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|nitems
argument_list|(
name|desc_strings
argument_list|)
operator|==
name|TYPE_COUNT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The time registers in the order they are laid out in hardware.  */
end_comment

begin_struct
struct|struct
name|time_regs
block|{
name|uint8_t
name|sec
decl_stmt|,
name|min
decl_stmt|,
name|hour
decl_stmt|,
name|day
decl_stmt|,
name|wday
decl_stmt|,
name|month
decl_stmt|,
name|year
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nxprtc_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|device_t
name|busdev
decl_stmt|;
name|struct
name|intr_config_hook
name|config_hook
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
comment|/* SC_F_* flags */
name|u_int
name|chiptype
decl_stmt|;
comment|/* Type of PCF85xx chip */
name|uint8_t
name|secaddr
decl_stmt|;
comment|/* Address of seconds register */
name|uint8_t
name|tmcaddr
decl_stmt|;
comment|/* Address of timer count register */
name|uint8_t
name|slave_addr
decl_stmt|;
comment|/* PCF85xx slave address */
name|bool
name|use_timer
decl_stmt|;
comment|/* Use timer for fractional sec */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SC_F_CPOL
value|(1<< 0)
end_define

begin_comment
comment|/* Century bit means 19xx */
end_comment

begin_define
define|#
directive|define
name|SC_F_AMPM
value|(1<< 1)
end_define

begin_comment
comment|/* Use PM flag in hours reg */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"nxp,pca2129"
block|,
name|TYPE_PCA2129
block|}
block|,
block|{
literal|"nxp,pca8565"
block|,
name|TYPE_PCA8565
block|}
block|,
block|{
literal|"nxp,pcf2127"
block|,
name|TYPE_PCF2127
block|}
block|,
block|{
literal|"nxp,pcf2129"
block|,
name|TYPE_PCF2129
block|}
block|,
block|{
literal|"nxp,pcf8523"
block|,
name|TYPE_PCF8523
block|}
block|,
block|{
literal|"nxp,pcf8563"
block|,
name|TYPE_PCF8563
block|}
block|,
comment|/* Undocumented compat strings known to exist in the wild... */
block|{
literal|"pcf8563"
block|,
name|TYPE_PCF8563
block|}
block|,
block|{
literal|"phg,pcf8563"
block|,
name|TYPE_PCF8563
block|}
block|,
block|{
literal|"philips,pcf8563"
block|,
name|TYPE_PCF8563
block|}
block|,
block|{
name|NULL
block|,
name|TYPE_NONE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|read_reg
parameter_list|(
name|struct
name|nxprtc_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|iicdev_readfrom
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|,
name|IIC_WAIT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_reg
parameter_list|(
name|struct
name|nxprtc_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|iicdev_writeto
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|IIC_WAIT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_timeregs
parameter_list|(
name|struct
name|nxprtc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|time_regs
modifier|*
name|tregs
parameter_list|,
name|uint8_t
modifier|*
name|tmr
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|sec
decl_stmt|,
name|tmr1
decl_stmt|,
name|tmr2
decl_stmt|;
comment|/* 	 * The datasheet says loop to read the same timer value twice because it 	 * does not freeze while reading.  To that we add our own logic that 	 * the seconds register must be the same before and after reading the 	 * timer, ensuring the fractional part is from the same second as tregs. 	 */
do|do
block|{
if|if
condition|(
name|sc
operator|->
name|use_timer
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|secaddr
argument_list|,
operator|&
name|sec
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tmcaddr
argument_list|,
operator|&
name|tmr1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tmcaddr
argument_list|,
operator|&
name|tmr2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|tmr1
operator|!=
name|tmr2
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|iicdev_readfrom
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|secaddr
argument_list|,
name|tregs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tregs
argument_list|)
argument_list|,
name|IIC_WAIT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
do|while
condition|(
name|sc
operator|->
name|use_timer
operator|&&
name|tregs
operator|->
name|sec
operator|!=
name|sec
condition|)
do|;
comment|/* 	 * If the timer value is greater than our hz rate (or is zero), 	 * something is wrong.  Maybe some other OS used the timer differently? 	 * Just set it to zero.  Likewise if we're not using the timer.  After 	 * the offset calc below, the zero turns into 32, the mid-second point, 	 * which in effect performs 4/5 rounding, which is just the right thing 	 * to do if we don't have fine-grained time. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|use_timer
operator|||
name|tmr1
operator|>
name|TMR_TICKS_SEC
condition|)
name|tmr1
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Turn the downcounter into an upcounter.  The timer starts counting at 	 * and rolls over at mid-second, so add half a second worth of ticks to 	 * get its zero point back in sync with the tregs.sec rollover. 	 */
operator|*
name|tmr
operator|=
operator|(
name|TMR_TICKS_SEC
operator|-
name|tmr1
operator|+
name|TMR_TICKS_HALFSEC
operator|)
operator|%
name|TMR_TICKS_SEC
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_timeregs
parameter_list|(
name|struct
name|nxprtc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|time_regs
modifier|*
name|tregs
parameter_list|)
block|{
return|return
operator|(
name|iicdev_writeto
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|secaddr
argument_list|,
name|tregs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tregs
argument_list|)
argument_list|,
name|IIC_WAIT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf8523_start
parameter_list|(
name|struct
name|nxprtc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|cs1
decl_stmt|,
name|cs3
decl_stmt|,
name|clkout
decl_stmt|;
name|bool
name|is2129
decl_stmt|;
name|is2129
operator|=
operator|(
name|sc
operator|->
name|chiptype
operator|==
name|TYPE_PCA2129
operator|||
name|sc
operator|->
name|chiptype
operator|==
name|TYPE_PCF2129
operator|)
expr_stmt|;
comment|/* Read and sanity-check the control registers. */
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF85xx_R_CS1
argument_list|,
operator|&
name|cs1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot read RTC CS1 control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_CS3
argument_list|,
operator|&
name|cs3
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot read RTC CS3 control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Do a full init (soft-reset) if... 	 *  - The chip is in battery-disable mode (fresh from the factory). 	 *  - The clock-increment STOP flag is set (this is just insane). 	 * After reset, battery disable mode has to be overridden to "standard" 	 * mode.  Also, turn off clock output to save battery power. 	 */
if|if
condition|(
operator|(
name|cs3
operator|&
name|PCF8523_M_CS3_PM
operator|)
operator|==
name|PCF8523_B_CS3_PM_NOBAT
operator|||
operator|(
name|cs1
operator|&
name|PCF85xx_B_CS1_STOP
operator|)
condition|)
block|{
name|cs1
operator|=
name|PCF8523_B_CS1_SOFTRESET
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF85xx_R_CS1
argument_list|,
name|cs1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot write CS1 control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|cs3
operator|=
name|PCF8523_B_CS3_PM_STD
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_CS3
argument_list|,
name|cs3
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot write CS3 control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 		 * For 2129 series, trigger OTP refresh by forcing the OTPR bit 		 * to zero then back to 1, then wait 100ms for the refresh, and 		 * finally set the bit back to zero with the COF_HIGHZ write. 		 */
if|if
condition|(
name|is2129
condition|)
block|{
name|clkout
operator|=
name|PCF2129_B_CLKOUT_HIGHZ
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_TMR_CLKOUT
argument_list|,
name|clkout
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot write CLKOUT control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_TMR_CLKOUT
argument_list|,
name|clkout
operator||
name|PCF2129_B_CLKOUT_OTPR
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot write CLKOUT control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|pause_sbt
argument_list|(
literal|"nxpotp"
argument_list|,
name|mstosbt
argument_list|(
literal|100
argument_list|)
argument_list|,
name|mstosbt
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|clkout
operator|=
name|PCF8523_B_CLKOUT_HIGHZ
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_TMR_CLKOUT
argument_list|,
name|clkout
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot write CLKOUT control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"first time startup, enabled RTC battery operation\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Sleep briefly so the battery monitor can make a measurement, 		 * then re-read CS3 so battery-low status can be reported below. 		 */
name|pause_sbt
argument_list|(
literal|"nxpbat"
argument_list|,
name|mstosbt
argument_list|(
literal|100
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_CS3
argument_list|,
operator|&
name|cs3
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot read RTC CS3 control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
comment|/* Let someone know if the battery is weak. */
if|if
condition|(
name|cs3
operator|&
name|PCF8523_B_CS3_BLF
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING: RTC battery is low\n"
argument_list|)
expr_stmt|;
comment|/* Remember whether we're running in AM/PM mode. */
if|if
condition|(
name|is2129
condition|)
block|{
if|if
condition|(
name|cs1
operator|&
name|PCF2129_B_CS1_12HR
condition|)
name|sc
operator|->
name|flags
operator||=
name|SC_F_AMPM
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cs1
operator|&
name|PCF8523_B_CS1_12HR
condition|)
name|sc
operator|->
name|flags
operator||=
name|SC_F_AMPM
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf8523_start_timer
parameter_list|(
name|struct
name|nxprtc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|clkout
decl_stmt|,
name|stdclk
decl_stmt|,
name|stdfreq
decl_stmt|,
name|tmrfreq
decl_stmt|;
comment|/* 	 * Read the timer control and frequency regs.  If they don't have the 	 * values we normally program into them then the timer count doesn't 	 * contain a valid fractional second, so zero it to prevent using a bad 	 * value.  Then program the normal timer values so that on the first 	 * settime call we'll begin to use fractional time. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_TMR_A_FREQ
argument_list|,
operator|&
name|tmrfreq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_TMR_CLKOUT
argument_list|,
operator|&
name|clkout
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|stdfreq
operator|=
name|PCF8523_B_TMR_A_64HZ
expr_stmt|;
name|stdclk
operator|=
name|PCF8523_B_CLKOUT_TACD
operator||
name|PCF8523_B_CLKOUT_HIGHZ
expr_stmt|;
if|if
condition|(
name|clkout
operator|!=
name|stdclk
operator|||
operator|(
name|tmrfreq
operator|&
name|PCF8523_M_TMR_A_FREQ
operator|)
operator|!=
name|stdfreq
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tmcaddr
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_TMR_A_FREQ
argument_list|,
name|stdfreq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF8523_R_TMR_CLKOUT
argument_list|,
name|stdclk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf2127_start_timer
parameter_list|(
name|struct
name|nxprtc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|stdctl
decl_stmt|,
name|tmrctl
decl_stmt|;
comment|/* See comment in pcf8523_start_timer().  */
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF2127_R_TMR_CTL
argument_list|,
operator|&
name|tmrctl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|stdctl
operator|=
name|PCF2127_B_TMR_CD
operator||
name|PCF8523_B_TMR_A_64HZ
expr_stmt|;
if|if
condition|(
operator|(
name|tmrctl
operator|&
name|PCF2127_M_TMR_CTRL
operator|)
operator|!=
name|stdctl
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tmcaddr
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF2127_R_TMR_CTL
argument_list|,
name|stdctl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf8563_start_timer
parameter_list|(
name|struct
name|nxprtc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|stdctl
decl_stmt|,
name|tmrctl
decl_stmt|;
comment|/* See comment in pcf8523_start_timer().  */
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF8563_R_TMR_CTRL
argument_list|,
operator|&
name|tmrctl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|stdctl
operator|=
name|PCF8563_B_TMR_ENABLE
operator||
name|PCF8563_B_TMR_64HZ
expr_stmt|;
if|if
condition|(
operator|(
name|tmrctl
operator|&
name|PCF8563_M_TMR_CTRL
operator|)
operator|!=
name|stdctl
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tmcaddr
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF8563_R_TMR_CTRL
argument_list|,
name|stdctl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nxprtc_start
parameter_list|(
name|void
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|nxprtc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|clockflags
decl_stmt|,
name|resolution
decl_stmt|;
name|uint8_t
name|sec
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
operator|(
name|device_t
operator|)
name|dev
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|config_hook
argument_list|)
expr_stmt|;
comment|/* First do chip-specific inits. */
switch|switch
condition|(
name|sc
operator|->
name|chiptype
condition|)
block|{
case|case
name|TYPE_PCA2129
case|:
case|case
name|TYPE_PCF2129
case|:
if|if
condition|(
name|pcf8523_start
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* No timer to start */
break|break;
case|case
name|TYPE_PCF2127
case|:
if|if
condition|(
name|pcf8523_start
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|pcf2127_start_timer
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
break|break;
case|case
name|TYPE_PCF8523
case|:
if|if
condition|(
name|pcf8523_start
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|pcf8523_start_timer
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
break|break;
case|case
name|TYPE_PCA8565
case|:
case|case
name|TYPE_PCF8563
case|:
if|if
condition|(
name|pcf8563_start_timer
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"missing init code for this chiptype\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Common init.  Read the seconds register so we can check the 	 * oscillator-stopped status bit in it. 	 */
if|if
condition|(
name|read_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|secaddr
argument_list|,
operator|&
name|sec
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot read RTC seconds\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sec
operator|&
name|PCF85xx_B_SECOND_OS
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING: RTC battery failed; time is invalid\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Everything looks good if we make it to here; register as an RTC.  If 	 * we're using the timer to count fractional seconds, our resolution is 	 * 1e6/64, about 15.6ms.  Without the timer we still align the RTC clock 	 * when setting it so our error is an average .5s when reading it. 	 */
name|resolution
operator|=
name|sc
operator|->
name|use_timer
condition|?
literal|1000000
operator|/
name|TMR_TICKS_SEC
else|:
literal|1000000
operator|/
literal|2
expr_stmt|;
name|clockflags
operator|=
name|CLOCKF_GETTIME_NO_ADJ
operator||
name|CLOCKF_SETTIME_NO_TS
expr_stmt|;
name|clock_register_flags
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|resolution
argument_list|,
name|clockflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nxprtc_gettime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|clocktime
name|ct
decl_stmt|;
name|struct
name|time_regs
name|tregs
decl_stmt|;
name|struct
name|nxprtc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|cs1
decl_stmt|,
name|hourmask
decl_stmt|,
name|tmrcount
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Read the time, but before using it, validate that the oscillator- 	 * stopped/power-fail bit is not set, and that the time-increment STOP 	 * bit is not set in the control reg.  The latter can happen if there 	 * was an error when setting the time. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|read_timeregs
argument_list|(
name|sc
argument_list|,
operator|&
name|tregs
argument_list|,
operator|&
name|tmrcount
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot read RTC time\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF85xx_R_CS1
argument_list|,
operator|&
name|cs1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot read RTC time\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|tregs
operator|.
name|sec
operator|&
name|PCF85xx_B_SECOND_OS
operator|)
operator|||
operator|(
name|cs1
operator|&
name|PCF85xx_B_CS1_STOP
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RTC clock not running\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* hardware is good, time is not. */
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_F_AMPM
condition|)
name|hourmask
operator|=
name|PCF85xx_M_12HOUR
expr_stmt|;
else|else
name|hourmask
operator|=
name|PCF85xx_M_24HOUR
expr_stmt|;
name|ct
operator|.
name|nsec
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|tmrcount
operator|*
literal|1000000000
operator|)
operator|/
name|TMR_TICKS_SEC
expr_stmt|;
name|ct
operator|.
name|sec
operator|=
name|FROMBCD
argument_list|(
name|tregs
operator|.
name|sec
operator|&
name|PCF85xx_M_SECOND
argument_list|)
expr_stmt|;
name|ct
operator|.
name|min
operator|=
name|FROMBCD
argument_list|(
name|tregs
operator|.
name|min
operator|&
name|PCF85xx_M_MINUTE
argument_list|)
expr_stmt|;
name|ct
operator|.
name|hour
operator|=
name|FROMBCD
argument_list|(
name|tregs
operator|.
name|hour
operator|&
name|hourmask
argument_list|)
expr_stmt|;
name|ct
operator|.
name|day
operator|=
name|FROMBCD
argument_list|(
name|tregs
operator|.
name|day
operator|&
name|PCF85xx_M_DAY
argument_list|)
expr_stmt|;
name|ct
operator|.
name|mon
operator|=
name|FROMBCD
argument_list|(
name|tregs
operator|.
name|month
operator|&
name|PCF85xx_M_MONTH
argument_list|)
expr_stmt|;
name|ct
operator|.
name|year
operator|=
name|FROMBCD
argument_list|(
name|tregs
operator|.
name|year
operator|&
name|PCF85xx_M_YEAR
argument_list|)
expr_stmt|;
name|ct
operator|.
name|year
operator|+=
literal|1900
expr_stmt|;
if|if
condition|(
name|ct
operator|.
name|year
operator|<
name|POSIX_BASE_YEAR
condition|)
name|ct
operator|.
name|year
operator|+=
literal|100
expr_stmt|;
comment|/* assume [1970, 2069] */
comment|/* 	 * Old PCF8563 datasheets recommended that the C bit be 1 for 19xx and 0 	 * for 20xx; newer datasheets don't recommend that.  We don't care, 	 * but we may co-exist with other OSes sharing the hardware. Determine 	 * existing polarity on a read so that we can preserve it on a write. 	 */
if|if
condition|(
name|sc
operator|->
name|chiptype
operator|==
name|TYPE_PCF8563
condition|)
block|{
if|if
condition|(
name|tregs
operator|.
name|month
operator|&
name|PCF8563_B_MONTH_C
condition|)
block|{
if|if
condition|(
name|ct
operator|.
name|year
operator|>=
literal|2000
condition|)
name|sc
operator|->
name|flags
operator||=
name|SC_F_CPOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ct
operator|.
name|year
operator|<
literal|2000
condition|)
name|sc
operator|->
name|flags
operator||=
name|SC_F_CPOL
expr_stmt|;
block|}
comment|/* If this chip is running in 12-hour/AMPM mode, deal with it. */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_F_AMPM
condition|)
block|{
if|if
condition|(
name|ct
operator|.
name|hour
operator|==
literal|12
condition|)
name|ct
operator|.
name|hour
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tregs
operator|.
name|hour
operator|&
name|PCF8523_B_HOUR_PM
condition|)
name|ct
operator|.
name|hour
operator|+=
literal|12
expr_stmt|;
block|}
name|err
operator|=
name|clock_ct_to_ts
argument_list|(
operator|&
name|ct
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|tv_sec
operator|+=
name|utc_offset
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nxprtc_settime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|clocktime
name|ct
decl_stmt|;
name|struct
name|time_regs
name|tregs
decl_stmt|;
name|struct
name|nxprtc_softc
modifier|*
name|sc
decl_stmt|;
name|long
name|waitns
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|cflag
decl_stmt|,
name|cs1
decl_stmt|,
name|pmflag
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * We stop the clock, set the time, then restart the clock.  Half a 	 * second after restarting the clock it ticks over to the next second. 	 * So to align the RTC, sleep until system time is halfway through the 	 * current second (shoot for .495 to allow time for i2c operations). 	 */
name|getnanotime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|waitns
operator|=
literal|495000000
operator|-
name|ts
operator|->
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|waitns
operator|<
literal|0
condition|)
name|waitns
operator|+=
literal|1000000000
expr_stmt|;
name|pause_sbt
argument_list|(
literal|"nxpset"
argument_list|,
name|nstosbt
argument_list|(
name|waitns
argument_list|)
argument_list|,
literal|0
argument_list|,
name|C_PREL
argument_list|(
literal|31
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve use of the i2c bus and stop the RTC clock.  Note that if 	 * anything goes wrong from this point on, we leave the clock stopped, 	 * because we don't really know what state it's in. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|iicbus_request_bus
argument_list|(
name|sc
operator|->
name|busdev
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|IIC_WAIT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|read_reg
argument_list|(
name|sc
argument_list|,
name|PCF85xx_R_CS1
argument_list|,
operator|&
name|cs1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
name|cs1
operator||=
name|PCF85xx_B_CS1_STOP
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF85xx_R_CS1
argument_list|,
name|cs1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
comment|/* Grab a fresh post-sleep idea of what time it is. */
name|getnanotime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|tv_sec
operator|-=
name|utc_offset
argument_list|()
expr_stmt|;
name|ts
operator|->
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|clock_ts_to_ct
argument_list|(
name|ts
argument_list|,
operator|&
name|ct
argument_list|)
expr_stmt|;
comment|/* If the chip is in AMPM mode deal with the PM flag. */
name|pmflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_F_AMPM
condition|)
block|{
if|if
condition|(
name|ct
operator|.
name|hour
operator|>=
literal|12
condition|)
block|{
name|ct
operator|.
name|hour
operator|-=
literal|12
expr_stmt|;
name|pmflag
operator|=
name|PCF8523_B_HOUR_PM
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|.
name|hour
operator|==
literal|0
condition|)
name|ct
operator|.
name|hour
operator|=
literal|12
expr_stmt|;
block|}
comment|/* On 8563 set the century based on the polarity seen when reading. */
name|cflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chiptype
operator|==
name|TYPE_PCF8563
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_F_CPOL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ct
operator|.
name|year
operator|>=
literal|2000
condition|)
name|cflag
operator|=
name|PCF8563_B_MONTH_C
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ct
operator|.
name|year
operator|<
literal|2000
condition|)
name|cflag
operator|=
name|PCF8563_B_MONTH_C
expr_stmt|;
block|}
name|tregs
operator|.
name|sec
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|sec
argument_list|)
expr_stmt|;
name|tregs
operator|.
name|min
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|min
argument_list|)
expr_stmt|;
name|tregs
operator|.
name|hour
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|hour
argument_list|)
operator||
name|pmflag
expr_stmt|;
name|tregs
operator|.
name|day
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|day
argument_list|)
expr_stmt|;
name|tregs
operator|.
name|month
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|mon
argument_list|)
expr_stmt|;
name|tregs
operator|.
name|year
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|year
operator|%
literal|100
argument_list|)
operator||
name|cflag
expr_stmt|;
name|tregs
operator|.
name|wday
operator|=
name|ct
operator|.
name|dow
expr_stmt|;
comment|/* 	 * Set the time, reset the timer count register, then start the clocks. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|write_timeregs
argument_list|(
name|sc
argument_list|,
operator|&
name|tregs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
if|if
condition|(
operator|(
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tmcaddr
argument_list|,
name|TMR_TICKS_SEC
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|cs1
operator|&=
operator|~
name|PCF85xx_B_CS1_STOP
expr_stmt|;
name|err
operator|=
name|write_reg
argument_list|(
name|sc
argument_list|,
name|PCF85xx_R_CS1
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
name|errout
label|:
name|iicbus_release_bus
argument_list|(
name|sc
operator|->
name|busdev
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot write RTC time\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nxprtc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|chiptype
decl_stmt|;
ifdef|#
directive|ifdef
name|FDT
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|chiptype
operator|=
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
expr_stmt|;
if|if
condition|(
name|chiptype
operator|==
name|TYPE_NONE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|#
directive|else
comment|/* Historically the non-FDT driver supports only PCF8563. */
name|chiptype
operator|=
name|TYPE_PCF8563
expr_stmt|;
endif|#
directive|endif
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|desc_strings
index|[
name|chiptype
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nxprtc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nxprtc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|busdev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|slave_addr
operator|=
name|iicbus_get_addr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * We need to know what kind of chip we're driving.  Historically the 	 * non-FDT driver supported only PCF8563.  There is no machine-readable 	 * identifier in the chip so we would need a set of hints defined to use 	 * the other chips on non-FDT systems. 	 */
ifdef|#
directive|ifdef
name|FDT
name|sc
operator|->
name|chiptype
operator|=
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|chiptype
operator|=
name|TYPE_PCF8563
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slave_addr
operator|==
literal|0
condition|)
name|sc
operator|->
name|slave_addr
operator|=
name|PCF8563_ADDR
expr_stmt|;
endif|#
directive|endif
comment|/* The features and some register addresses vary by chip type. */
switch|switch
condition|(
name|sc
operator|->
name|chiptype
condition|)
block|{
case|case
name|TYPE_PCA2129
case|:
case|case
name|TYPE_PCF2129
case|:
name|sc
operator|->
name|secaddr
operator|=
name|PCF8523_R_SECOND
expr_stmt|;
name|sc
operator|->
name|tmcaddr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|use_timer
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|TYPE_PCF2127
case|:
case|case
name|TYPE_PCF8523
case|:
name|sc
operator|->
name|secaddr
operator|=
name|PCF8523_R_SECOND
expr_stmt|;
name|sc
operator|->
name|tmcaddr
operator|=
name|PCF8523_R_TMR_A_COUNT
expr_stmt|;
name|sc
operator|->
name|use_timer
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|TYPE_PCA8565
case|:
case|case
name|TYPE_PCF8563
case|:
name|sc
operator|->
name|secaddr
operator|=
name|PCF8563_R_SECOND
expr_stmt|;
name|sc
operator|->
name|tmcaddr
operator|=
name|PCF8563_R_TMR_COUNT
expr_stmt|;
name|sc
operator|->
name|use_timer
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"impossible: cannot determine chip type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * We have to wait until interrupts are enabled.  Sometimes I2C read 	 * and write only works when the interrupts are available. 	 */
name|sc
operator|->
name|config_hook
operator|.
name|ich_func
operator|=
name|nxprtc_start
expr_stmt|;
name|sc
operator|->
name|config_hook
operator|.
name|ich_arg
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|config_hook
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nxprtc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|clock_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|nxprtc_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|nxprtc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|nxprtc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|nxprtc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|clock_gettime
argument_list|,
name|nxprtc_gettime
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|clock_settime
argument_list|,
name|nxprtc_settime
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|nxprtc_driver
init|=
block|{
literal|"nxprtc"
block|,
name|nxprtc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|nxprtc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|nxprtc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|nxprtc
argument_list|,
name|iicbus
argument_list|,
name|nxprtc_driver
argument_list|,
name|nxprtc_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|nxprtc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nxprtc
argument_list|,
name|iicbus
argument_list|,
name|IICBB_MINVER
argument_list|,
name|IICBB_PREFVER
argument_list|,
name|IICBB_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

