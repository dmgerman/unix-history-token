begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Yusuke Tanaka  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2011 Frank Wille.  * All rights reserved.  *  * Written by Frank Wille for The NetBSD Project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for Seiko Instruments S-35390A Real-time Clock  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iicbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|"clock_if.h"
end_include

begin_include
include|#
directive|include
file|"iicbus_if.h"
end_include

begin_define
define|#
directive|define
name|S390_DEVNAME
value|"s35390a_rtc"
end_define

begin_define
define|#
directive|define
name|S390_DEVCODE
value|0x6
end_define

begin_comment
comment|/* 0110 */
end_comment

begin_comment
comment|/*  * S-35390A uses 4-bit device code + 3-bit command in the slave address  * field.  The possible combination is 0x60-0x6f including the R/W bit.  * 0x60 means an write access to status register 1.  */
end_comment

begin_define
define|#
directive|define
name|S390_ADDR
value|(S390_DEVCODE<< 4)
end_define

begin_comment
comment|/* Registers are encoded into the slave address */
end_comment

begin_define
define|#
directive|define
name|S390_STATUS1
value|(0<< 1)
end_define

begin_define
define|#
directive|define
name|S390_STATUS2
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|S390_REALTIME1
value|(2<< 1)
end_define

begin_define
define|#
directive|define
name|S390_REALTIME2
value|(3<< 1)
end_define

begin_define
define|#
directive|define
name|S390_INT1_1
value|(4<< 1)
end_define

begin_define
define|#
directive|define
name|S390_INT1_2
value|(5<< 1)
end_define

begin_define
define|#
directive|define
name|S390_CLOCKADJ
value|(6<< 1)
end_define

begin_define
define|#
directive|define
name|S390_FREE
value|(7<< 1)
end_define

begin_comment
comment|/* Status1 bits */
end_comment

begin_define
define|#
directive|define
name|S390_ST1_POC
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|S390_ST1_BLD
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|S390_ST1_24H
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|S390_ST1_RESET
value|(1<< 0)
end_define

begin_comment
comment|/* Status2 bits */
end_comment

begin_define
define|#
directive|define
name|S390_ST2_TEST
value|(1<< 7)
end_define

begin_comment
comment|/* Realtime1 data bytes */
end_comment

begin_define
define|#
directive|define
name|S390_RT1_NBYTES
value|7
end_define

begin_define
define|#
directive|define
name|S390_RT1_YEAR
value|0
end_define

begin_define
define|#
directive|define
name|S390_RT1_MONTH
value|1
end_define

begin_define
define|#
directive|define
name|S390_RT1_DAY
value|2
end_define

begin_define
define|#
directive|define
name|S390_RT1_WDAY
value|3
end_define

begin_define
define|#
directive|define
name|S390_RT1_HOUR
value|4
end_define

begin_define
define|#
directive|define
name|S390_RT1_MINUTE
value|5
end_define

begin_define
define|#
directive|define
name|S390_RT1_SECOND
value|6
end_define

begin_struct
struct|struct
name|s390rtc_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|uint16_t
name|sc_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * S-35390A interprets bits in each byte on SDA in reverse order.  * bitreverse() reverses the bits in uint8_t.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|nibbletab
index|[]
init|=
block|{
comment|/* 0x0 0000 -> 0000 */
literal|0x0
block|,
comment|/* 0x1 0001 -> 1000 */
literal|0x8
block|,
comment|/* 0x2 0010 -> 0100 */
literal|0x4
block|,
comment|/* 0x3 0011 -> 1100 */
literal|0xc
block|,
comment|/* 0x4 0100 -> 0010 */
literal|0x2
block|,
comment|/* 0x5 0101 -> 1010 */
literal|0xa
block|,
comment|/* 0x6 0110 -> 0110 */
literal|0x6
block|,
comment|/* 0x7 0111 -> 1110 */
literal|0xe
block|,
comment|/* 0x8 1000 -> 0001 */
literal|0x1
block|,
comment|/* 0x9 1001 -> 1001 */
literal|0x9
block|,
comment|/* 0xa 1010 -> 0101 */
literal|0x5
block|,
comment|/* 0xb 1011 -> 1101 */
literal|0xd
block|,
comment|/* 0xc 1100 -> 0011 */
literal|0x3
block|,
comment|/* 0xd 1101 -> 1011 */
literal|0xb
block|,
comment|/* 0xe 1110 -> 0111 */
literal|0x7
block|,
comment|/* 0xf 1111 -> 1111 */
literal|0xf
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint8_t
name|bitreverse
parameter_list|(
name|uint8_t
name|x
parameter_list|)
block|{
return|return
operator|(
name|nibbletab
index|[
name|x
operator|&
literal|0xf
index|]
operator|<<
literal|4
operator|)
operator||
name|nibbletab
index|[
name|x
operator|>>
literal|4
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390rtc_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|s390rtc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|iic_msg
name|msg
index|[]
init|=
block|{
block|{
operator|.
name|slave
operator|=
name|sc
operator|->
name|sc_addr
operator||
name|reg
block|,
operator|.
name|flags
operator|=
name|IIC_M_RD
block|,
operator|.
name|len
operator|=
name|len
block|,
operator|.
name|buf
operator|=
name|buf
block|, 		}
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|iicbus_transfer
argument_list|(
name|dev
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* this chip returns each byte in reverse order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|buf
index|[
name|i
index|]
operator|=
name|bitreverse
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390rtc_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|s390rtc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|iic_msg
name|msg
index|[]
init|=
block|{
block|{
operator|.
name|slave
operator|=
name|sc
operator|->
name|sc_addr
operator||
name|reg
block|,
operator|.
name|flags
operator|=
name|IIC_M_WR
block|,
operator|.
name|len
operator|=
name|len
block|,
operator|.
name|buf
operator|=
name|buf
block|, 		}
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* this chip expects each byte in reverse order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|buf
index|[
name|i
index|]
operator|=
name|bitreverse
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|iicbus_transfer
argument_list|(
name|dev
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390rtc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|iicbus_get_addr
argument_list|(
name|dev
argument_list|)
operator|!=
name|S390_ADDR
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"slave address mismatch. "
literal|"(%02x != %02x)\n"
argument_list|,
name|iicbus_get_addr
argument_list|(
name|dev
argument_list|)
argument_list|,
name|S390_ADDR
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Seiko Instruments S-35390A Real-time Clock"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_SPECIFIC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390rtc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|s390rtc_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_addr
operator|=
name|iicbus_get_addr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Reset the chip and turn on 24h mode, after power-off or battery. */
name|error
operator|=
name|s390rtc_read
argument_list|(
name|dev
argument_list|,
name|S390_STATUS1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cannot read status1 register\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|reg
operator|&
operator|(
name|S390_ST1_POC
operator||
name|S390_ST1_BLD
operator|)
condition|)
block|{
name|reg
operator||=
name|S390_ST1_24H
operator||
name|S390_ST1_RESET
expr_stmt|;
name|error
operator|=
name|s390rtc_write
argument_list|(
name|dev
argument_list|,
name|S390_STATUS1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cannot initialize\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Disable the test mode, when enabled. */
name|error
operator|=
name|s390rtc_read
argument_list|(
name|dev
argument_list|,
name|S390_STATUS2
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cannot read status2 register\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|reg
operator|&
name|S390_ST2_TEST
condition|)
block|{
name|reg
operator|&=
operator|~
name|S390_ST2_TEST
expr_stmt|;
name|error
operator|=
name|s390rtc_write
argument_list|(
name|dev
argument_list|,
name|S390_STATUS2
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cannot disable the test mode\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|clock_register
argument_list|(
name|dev
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
comment|/* 1 second resolution */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390rtc_gettime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|uint8_t
name|bcd
index|[
name|S390_RT1_NBYTES
index|]
decl_stmt|;
name|struct
name|clocktime
name|ct
decl_stmt|;
name|struct
name|s390rtc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|s390rtc_read
argument_list|(
name|dev
argument_list|,
name|S390_REALTIME1
argument_list|,
name|bcd
argument_list|,
name|S390_RT1_NBYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cannot read realtime1 register\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Convert the register values into something useable. 	 */
name|ct
operator|.
name|nsec
operator|=
literal|0
expr_stmt|;
name|ct
operator|.
name|sec
operator|=
name|FROMBCD
argument_list|(
name|bcd
index|[
name|S390_RT1_SECOND
index|]
argument_list|)
expr_stmt|;
name|ct
operator|.
name|min
operator|=
name|FROMBCD
argument_list|(
name|bcd
index|[
name|S390_RT1_MINUTE
index|]
argument_list|)
expr_stmt|;
name|ct
operator|.
name|hour
operator|=
name|FROMBCD
argument_list|(
name|bcd
index|[
name|S390_RT1_HOUR
index|]
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
name|ct
operator|.
name|day
operator|=
name|FROMBCD
argument_list|(
name|bcd
index|[
name|S390_RT1_DAY
index|]
argument_list|)
expr_stmt|;
name|ct
operator|.
name|dow
operator|=
name|bcd
index|[
name|S390_RT1_WDAY
index|]
operator|&
literal|0x07
expr_stmt|;
name|ct
operator|.
name|mon
operator|=
name|FROMBCD
argument_list|(
name|bcd
index|[
name|S390_RT1_MONTH
index|]
argument_list|)
expr_stmt|;
name|ct
operator|.
name|year
operator|=
name|FROMBCD
argument_list|(
name|bcd
index|[
name|S390_RT1_YEAR
index|]
argument_list|)
operator|+
literal|2000
expr_stmt|;
return|return
operator|(
name|clock_ct_to_ts
argument_list|(
operator|&
name|ct
argument_list|,
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390rtc_settime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|uint8_t
name|bcd
index|[
name|S390_RT1_NBYTES
index|]
decl_stmt|;
name|struct
name|clocktime
name|ct
decl_stmt|;
name|struct
name|s390rtc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|clock_ts_to_ct
argument_list|(
name|ts
argument_list|,
operator|&
name|ct
argument_list|)
expr_stmt|;
comment|/* 	 * Convert our time representation into something the S-xx390 	 * can understand. 	 */
name|bcd
index|[
name|S390_RT1_SECOND
index|]
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|sec
argument_list|)
expr_stmt|;
name|bcd
index|[
name|S390_RT1_MINUTE
index|]
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|min
argument_list|)
expr_stmt|;
name|bcd
index|[
name|S390_RT1_HOUR
index|]
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|hour
argument_list|)
expr_stmt|;
name|bcd
index|[
name|S390_RT1_DAY
index|]
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|day
argument_list|)
expr_stmt|;
name|bcd
index|[
name|S390_RT1_WDAY
index|]
operator|=
name|ct
operator|.
name|dow
expr_stmt|;
name|bcd
index|[
name|S390_RT1_MONTH
index|]
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|mon
argument_list|)
expr_stmt|;
name|bcd
index|[
name|S390_RT1_YEAR
index|]
operator|=
name|TOBCD
argument_list|(
name|ct
operator|.
name|year
operator|%
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
name|s390rtc_write
argument_list|(
name|dev
argument_list|,
name|S390_REALTIME1
argument_list|,
name|bcd
argument_list|,
name|S390_RT1_NBYTES
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|s390rtc_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|s390rtc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|s390rtc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|clock_gettime
argument_list|,
name|s390rtc_gettime
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|clock_settime
argument_list|,
name|s390rtc_settime
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|s390rtc_driver
init|=
block|{
name|S390_DEVNAME
block|,
name|s390rtc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|s390rtc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|s390rtc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|s35390a
argument_list|,
name|iicbus
argument_list|,
name|s390rtc_driver
argument_list|,
name|s390rtc_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|s35390a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|s35390a
argument_list|,
name|iicbus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

