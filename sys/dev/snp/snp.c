begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 Ugen J.S.Antsilevich  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  *  * Snoop stuff.  */
end_comment

begin_include
include|#
directive|include
file|"snp.h"
end_include

begin_if
if|#
directive|if
name|NSNP
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl_compat.h>
end_include

begin_comment
comment|/* Oooh..We need O/NTTYDISC	 */
end_comment

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_define
define|#
directive|define
name|TTYDEFCHARS
end_define

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_undef
undef|#
directive|undef
name|TTYDEFCHARS
end_undef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/snoop.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ST_PTY
end_ifdef

begin_comment
comment|/*  * This should be same as in "kern/tty_pty.c"  */
end_comment

begin_include
include|#
directive|include
file|"pty.h"
end_include

begin_if
if|#
directive|if
name|NPTY
operator|==
literal|1
end_if

begin_undef
undef|#
directive|undef
name|NPTY
end_undef

begin_define
define|#
directive|define
name|NPTY
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|tty
name|pt_tty
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ST_PTY */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ST_SIO
end_ifdef

begin_comment
comment|/*  * This should be same as "i386/isa/sio.c"  */
end_comment

begin_include
include|#
directive|include
file|"sio.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|tty
name|sio_tty
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ST_SIO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ST_VTY
end_ifdef

begin_comment
comment|/*  * This should match "i386/isa/sc.c"  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAXCONS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAXCONS
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|tty
name|sccons
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ST_VTY */
end_comment

begin_comment
comment|/*  * This is local structure to hold data for all tty arrays we serve.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|tty
name|tty_arr
index|[]
typedef|;
end_typedef

begin_struct
struct|struct
name|tty_tab
block|{
name|int
name|lt_max
decl_stmt|;
name|tty_arr
modifier|*
name|lt_tab
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tty_tab
name|tty_tabs
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|ST_PTY
block|{
name|NPTY
block|,
operator|&
name|pt_tty
block|}
block|,
else|#
directive|else
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ST_VTY
block|{
name|MAXCONS
block|,
operator|&
name|sccons
block|}
block|,
else|#
directive|else
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ST_SIO
block|{
name|NSIO
block|,
operator|&
name|sio_tty
block|}
else|#
directive|else
block|{
operator|-
literal|1
block|,
name|NULL
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|snoop
name|snoopsw
index|[
name|NSNP
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|snpread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|n
decl_stmt|,
name|nblen
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|caddr_t
name|from
decl_stmt|;
name|char
modifier|*
name|nbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|)
operator|>
name|snp
operator|->
name|snp_blen
condition|)
name|panic
argument_list|(
literal|"snoop buffer error"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|snp
operator|->
name|snp_unit
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
do|do
block|{
if|if
condition|(
name|snp
operator|->
name|snp_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_NBIO
condition|)
block|{
return|return
name|EWOULDBLOCK
return|;
block|}
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_RWAIT
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|snp
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
literal|"snoopread"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|snp
operator|->
name|snp_len
operator|==
literal|0
condition|)
do|;
name|n
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
while|while
condition|(
name|snp
operator|->
name|snp_len
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|from
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|uiomove
argument_list|(
name|from
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|+=
name|len
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
operator|)
operator|&&
operator|(
name|n
operator|<
name|snp
operator|->
name|snp_len
operator|)
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OFLOW
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|SNOOP_MINLEN
operator|)
operator|&&
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|snp
operator|->
name|snp_len
condition|)
block|{
while|while
condition|(
operator|(
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|snp
operator|->
name|snp_len
operator|)
operator|&&
operator|(
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|SNOOP_MINLEN
operator|)
condition|)
name|nblen
operator|=
name|nblen
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|nbuf
operator|=
name|malloc
argument_list|(
name|nblen
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|,
name|nbuf
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|nbuf
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|nblen
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|snpin
parameter_list|(
name|snp
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|s_free
decl_stmt|,
name|s_tail
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|nblen
decl_stmt|;
name|caddr_t
name|from
decl_stmt|,
name|to
decl_stmt|;
name|char
modifier|*
name|nbuf
decl_stmt|;
name|struct
name|tty_tab
modifier|*
name|l_tty
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"bad snoop char count"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OPEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Snoop: data coming to closed device.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
condition|)
block|{
name|printf
argument_list|(
literal|"Snoop: more data to down interface.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
condition|)
block|{
name|printf
argument_list|(
literal|"Snoop: buffer overflow.\n"
argument_list|)
expr_stmt|;
comment|/* 		 * On overflow we just repeat the standart close 		 * procedure...yes , this is waste of space but.. Then next 		 * read from device will fail if one would recall he is 		 * snooping and retry... 		 */
return|return
operator|(
name|snpdown
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
name|s_tail
operator|=
name|snp
operator|->
name|snp_blen
operator|-
operator|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|)
expr_stmt|;
name|s_free
operator|=
name|snp
operator|->
name|snp_blen
operator|-
name|snp
operator|->
name|snp_len
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|s_free
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|>
name|s_free
operator|)
operator|&&
operator|(
operator|(
name|nblen
operator|*
literal|2
operator|)
operator|<=
name|SNOOP_MAXLEN
operator|)
condition|)
block|{
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
operator|*
literal|2
expr_stmt|;
name|s_free
operator|=
name|nblen
operator|-
operator|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|<=
name|s_free
operator|)
operator|&&
operator|(
name|nbuf
operator|=
name|malloc
argument_list|(
name|nblen
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|,
name|nbuf
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|nbuf
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|nblen
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_OFLOW
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_RWAIT
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|snp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|s_tail
condition|)
block|{
name|from
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|)
expr_stmt|;
name|to
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
name|bcopy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
name|to
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
operator|+
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|to
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_RWAIT
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|snp
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|snp
operator|->
name|snp_sel
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_sel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|int
name|snpopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|)
operator|>=
name|NSNP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|snp
operator|=
operator|&
name|snoopsw
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OPEN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * We intentionally do not OR flags with SNOOP_OPEN,but set them so 	 * all previous settings (especially SNOOP_OFLOW) will be cleared. 	 */
name|snp
operator|->
name|snp_flags
operator|=
name|SNOOP_OPEN
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|malloc
argument_list|(
name|SNOOP_MINLEN
argument_list|,
name|M_TTYS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|SNOOP_MINLEN
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * unit == -1  is for inactive snoop devices. 	 */
name|snp
operator|->
name|snp_unit
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snp_detach
parameter_list|(
name|snp
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|tty_tab
modifier|*
name|l_tty
decl_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If line disc. changed we do not touch this pointer,SLIP/PPP will 	 * change it anyway. 	 */
if|if
condition|(
name|snp
operator|->
name|snp_unit
operator|==
operator|-
literal|1
condition|)
goto|goto
name|detach_notty
goto|;
name|l_tty
operator|=
operator|&
name|tty_tabs
index|[
name|snp
operator|->
name|snp_type
index|]
expr_stmt|;
name|tp
operator|=
operator|&
operator|(
operator|(
operator|*
name|l_tty
operator|->
name|lt_tab
operator|)
index|[
name|snp
operator|->
name|snp_unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_sc
operator|==
name|snp
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SNOOP
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_line
operator|==
name|OTTYDISC
operator|||
name|tp
operator|->
name|t_line
operator|==
name|NTTYDISC
operator|)
condition|)
block|{
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_SNOOP
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Snoop: bad attached tty data.\n"
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_unit
operator|=
operator|-
literal|1
expr_stmt|;
name|detach_notty
label|:
name|selwakeup
argument_list|(
operator|&
name|snp
operator|->
name|snp_sel
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_sel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snpclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OPEN
expr_stmt|;
return|return
operator|(
name|snp_detach
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snpdown
parameter_list|(
name|snp
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
block|{
name|snp
operator|->
name|snp_blen
operator|=
name|SNOOP_MINLEN
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|malloc
argument_list|(
name|SNOOP_MINLEN
argument_list|,
name|M_TTYS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_DOWN
expr_stmt|;
return|return
operator|(
name|snp_detach
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snpioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
name|int
name|tunit
decl_stmt|,
name|ttype
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tpo
decl_stmt|;
name|struct
name|tty_tab
modifier|*
name|l_tty
decl_stmt|,
modifier|*
name|l_otty
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNPSTTY
case|:
name|tunit
operator|=
operator|(
operator|(
expr|struct
name|snptty
operator|*
operator|)
name|data
operator|)
operator|->
name|st_unit
expr_stmt|;
name|ttype
operator|=
operator|(
operator|(
expr|struct
name|snptty
operator|*
operator|)
name|data
operator|)
operator|->
name|st_type
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
operator|-
literal|1
operator|||
name|tunit
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|snpdown
argument_list|(
name|snp
argument_list|)
operator|)
return|;
if|if
condition|(
name|ttype
operator|<
literal|0
operator|||
name|ttype
operator|>
name|ST_MAXTYPE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|l_tty
operator|=
operator|&
name|tty_tabs
index|[
name|ttype
index|]
expr_stmt|;
if|if
condition|(
name|l_tty
operator|->
name|lt_tab
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|tunit
operator|<
literal|0
operator|||
name|tunit
operator|>=
name|l_tty
operator|->
name|lt_max
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tp
operator|=
operator|&
operator|(
operator|(
operator|*
name|l_tty
operator|->
name|lt_tab
operator|)
index|[
name|tunit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_sc
operator|!=
operator|(
name|caddr_t
operator|)
name|snp
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SNOOP
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|!=
name|OTTYDISC
operator|&&
name|tp
operator|->
name|t_line
operator|!=
name|NTTYDISC
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_unit
operator|!=
operator|-
literal|1
condition|)
block|{
name|l_otty
operator|=
operator|&
name|tty_tabs
index|[
name|snp
operator|->
name|snp_type
index|]
expr_stmt|;
name|tpo
operator|=
operator|&
operator|(
operator|(
operator|*
name|l_otty
operator|->
name|lt_tab
operator|)
index|[
name|snp
operator|->
name|snp_unit
index|]
operator|)
expr_stmt|;
name|tpo
operator|->
name|t_state
operator|&=
operator|~
name|TS_SNOOP
expr_stmt|;
block|}
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|snp
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_SNOOP
expr_stmt|;
name|snp
operator|->
name|snp_unit
operator|=
name|tunit
expr_stmt|;
name|snp
operator|->
name|snp_type
operator|=
name|ttype
expr_stmt|;
comment|/* 		 * Clean overflow and down flags - 		 * we'll have a chance to get them in the future :))) 		 */
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OFLOW
expr_stmt|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_DOWN
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNPGTTY
case|:
operator|(
operator|(
expr|struct
name|snptty
operator|*
operator|)
name|data
operator|)
operator|->
name|st_unit
operator|=
name|snp
operator|->
name|snp_unit
expr_stmt|;
operator|(
operator|(
expr|struct
name|snptty
operator|*
operator|)
name|data
operator|)
operator|->
name|st_type
operator|=
name|snp
operator|->
name|snp_type
expr_stmt|;
break|break;
case|case
name|FIONBIO
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_NBIO
expr_stmt|;
else|else
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_NBIO
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_ASYNC
expr_stmt|;
else|else
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_ASYNC
expr_stmt|;
break|break;
case|case
name|FIONREAD
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_unit
operator|!=
operator|-
literal|1
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
elseif|else
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
condition|)
block|{
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_OFLOW
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_TTYCLOSE
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_DETACH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snpselect
parameter_list|(
name|dev
parameter_list|,
name|rw
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|rw
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|rw
operator|!=
name|FREAD
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|snp
operator|->
name|snp_len
operator|>
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* 	 * If snoop is down,we don't want to select() forever so we return 1. 	 * Caller should see if we down via FIONREAD ioctl().The last should 	 * return -1 to indicate down state. 	 */
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
condition|)
block|{
return|return
literal|1
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|snp
operator|->
name|snp_sel
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

