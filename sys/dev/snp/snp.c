begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995 Ugen J.S.Antsilevich  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  *  * Snoop stuff.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/snoop.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_decl_stmt
specifier|static
name|l_close_t
name|snplclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_write_t
name|snplwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|snpopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|snpclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|snpread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|snpwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|snpioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|snppoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|snp_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_PSEUDO
operator||
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|snpopen
block|,
operator|.
name|d_close
operator|=
name|snpclose
block|,
operator|.
name|d_read
operator|=
name|snpread
block|,
operator|.
name|d_write
operator|=
name|snpwrite
block|,
operator|.
name|d_ioctl
operator|=
name|snpioctl
block|,
operator|.
name|d_poll
operator|=
name|snppoll
block|,
operator|.
name|d_name
operator|=
literal|"snp"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linesw
name|snpdisc
init|=
block|{
operator|.
name|l_open
operator|=
name|tty_open
block|,
operator|.
name|l_close
operator|=
name|snplclose
block|,
operator|.
name|l_read
operator|=
name|ttread
block|,
operator|.
name|l_write
operator|=
name|snplwrite
block|,
operator|.
name|l_ioctl
operator|=
name|l_nullioctl
block|,
operator|.
name|l_rint
operator|=
name|ttyinput
block|,
operator|.
name|l_start
operator|=
name|ttstart
block|,
operator|.
name|l_modem
operator|=
name|ttymodem
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the main snoop per-device structure.  */
end_comment

begin_struct
struct|struct
name|snoop
block|{
name|LIST_ENTRY
argument_list|(
argument|snoop
argument_list|)
name|snp_list
expr_stmt|;
comment|/* List glue. */
name|int
name|snp_unit
decl_stmt|;
comment|/* Device number. */
name|struct
name|cdev
modifier|*
name|snp_target
decl_stmt|;
comment|/* Target tty device. */
name|struct
name|tty
modifier|*
name|snp_tty
decl_stmt|;
comment|/* Target tty pointer. */
name|u_long
name|snp_len
decl_stmt|;
comment|/* Possible length. */
name|u_long
name|snp_base
decl_stmt|;
comment|/* Data base. */
name|u_long
name|snp_blen
decl_stmt|;
comment|/* Used length. */
name|caddr_t
name|snp_buf
decl_stmt|;
comment|/* Allocation pointer. */
name|int
name|snp_flags
decl_stmt|;
comment|/* Flags. */
name|struct
name|selinfo
name|snp_sel
decl_stmt|;
comment|/* Select info. */
name|int
name|snp_olddisc
decl_stmt|;
comment|/* Old line discipline. */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Possible flags.  */
end_comment

begin_define
define|#
directive|define
name|SNOOP_ASYNC
value|0x0002
end_define

begin_define
define|#
directive|define
name|SNOOP_OPEN
value|0x0004
end_define

begin_define
define|#
directive|define
name|SNOOP_RWAIT
value|0x0008
end_define

begin_define
define|#
directive|define
name|SNOOP_OFLOW
value|0x0010
end_define

begin_define
define|#
directive|define
name|SNOOP_DOWN
value|0x0020
end_define

begin_comment
comment|/*  * Other constants.  */
end_comment

begin_define
define|#
directive|define
name|SNOOP_MINLEN
value|(4*1024)
end_define

begin_comment
comment|/* This should be power of 2. 						 * 4K tested to be the minimum 						 * for which on normal tty 						 * usage there is no need to 						 * allocate more. 						 */
end_comment

begin_define
define|#
directive|define
name|SNOOP_MAXLEN
value|(64*1024)
end_define

begin_comment
comment|/* This one also,64K enough 						 * If we grow more,something 						 * really bad in this world.. 						 */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SNP
argument_list|,
literal|"snp"
argument_list|,
literal|"Snoop device data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The number of the "snoop" line discipline.  This gets determined at  * module load time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|snooplinedisc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|snoop
argument_list|)
name|snp_sclist
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|snp_sclist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|clonedevs
modifier|*
name|snpclones
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|tty
modifier|*
name|snpdevtotty
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snp_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|snp_detach
parameter_list|(
name|struct
name|snoop
modifier|*
name|snp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|snp_down
parameter_list|(
name|struct
name|snoop
modifier|*
name|snp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|snp_in
parameter_list|(
name|struct
name|snoop
modifier|*
name|snp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|snp_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|snoop
modifier|*
name|ttytosnp
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|snoop
modifier|*
name|ttytosnp
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|snp
argument_list|,
argument|&snp_sclist
argument_list|,
argument|snp_list
argument_list|)
block|{
if|if
condition|(
name|snp
operator|->
name|snp_tty
operator|==
name|tp
condition|)
return|return
operator|(
name|snp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snplclose
parameter_list|(
name|tp
parameter_list|,
name|flag
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|snp
operator|=
name|ttytosnp
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|snp_down
argument_list|(
name|snp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttylclose
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snplwrite
parameter_list|(
name|tp
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uio2
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ilen
decl_stmt|;
name|char
modifier|*
name|ibuf
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ibuf
operator|=
name|NULL
expr_stmt|;
name|snp
operator|=
name|ttytosnp
argument_list|(
name|tp
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|ilen
operator|=
name|imin
argument_list|(
literal|512
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|ibuf
operator|=
name|malloc
argument_list|(
name|ilen
argument_list|,
name|M_SNP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|ibuf
argument_list|,
name|ilen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|snp_in
argument_list|(
name|snp
argument_list|,
name|ibuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
comment|/* Hackish, but probably the least of all evils. */
name|iov
operator|.
name|iov_base
operator|=
name|ibuf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|ilen
expr_stmt|;
name|uio2
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio2
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio2
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uio2
operator|.
name|uio_resid
operator|=
name|ilen
expr_stmt|;
name|uio2
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio2
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uio2
operator|.
name|uio_td
operator|=
name|uio
operator|->
name|uio_td
expr_stmt|;
name|error
operator|=
name|ttwrite
argument_list|(
name|tp
argument_list|,
operator|&
name|uio2
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|free
argument_list|(
name|ibuf
argument_list|,
name|M_SNP
argument_list|)
expr_stmt|;
name|ibuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ibuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ibuf
argument_list|,
name|M_SNP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tty
modifier|*
name|snpdevtotty
parameter_list|(
name|dev
parameter_list|)
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
block|{
name|struct
name|cdevsw
modifier|*
name|cdp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|cdp
operator|=
name|dev_refthread
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|cdp
operator|->
name|d_flags
operator|&
name|D_TTY
operator|)
condition|)
name|tp
operator|=
name|NULL
expr_stmt|;
else|else
name|tp
operator|=
name|dev
operator|->
name|si_tty
expr_stmt|;
name|dev_relthread
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SNP_INPUT_BUF
value|5
end_define

begin_comment
comment|/* This is even too much, the maximal 				 * interactive mode write is 3 bytes 				 * length for function keys... 				 */
end_comment

begin_function
specifier|static
name|int
name|snpwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|char
name|c
index|[
name|SNP_INPUT_BUF
index|]
decl_stmt|;
name|snp
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|tp
operator|=
name|snp
operator|->
name|snp_tty
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SNOOP
operator|)
operator|&&
name|tp
operator|->
name|t_line
operator|==
name|snooplinedisc
condition|)
goto|goto
name|tty_input
goto|;
name|printf
argument_list|(
literal|"snp%d: attempt to write to bad tty\n"
argument_list|,
name|snp
operator|->
name|snp_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
name|tty_input
label|:
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|imin
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|SNP_INPUT_BUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ttyinput
argument_list|(
name|c
index|[
name|i
index|]
argument_list|,
name|tp
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snpread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|n
decl_stmt|,
name|nblen
decl_stmt|,
name|s
decl_stmt|;
name|caddr_t
name|from
decl_stmt|;
name|char
modifier|*
name|nbuf
decl_stmt|;
name|snp
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|<=
name|snp
operator|->
name|snp_blen
argument_list|,
operator|(
literal|"snoop buffer error"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_tty
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
do|do
block|{
if|if
condition|(
name|snp
operator|->
name|snp_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_RWAIT
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|snp
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
literal|"snprd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
do|while
condition|(
name|snp
operator|->
name|snp_len
operator|==
literal|0
condition|)
do|;
name|n
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|snp
operator|->
name|snp_len
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|min
argument_list|(
operator|(
name|unsigned
operator|)
name|uio
operator|->
name|uio_resid
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|from
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|uiomove
argument_list|(
name|from
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|+=
name|len
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
operator|)
operator|&&
operator|(
name|n
operator|<
name|snp
operator|->
name|snp_len
operator|)
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OFLOW
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|SNOOP_MINLEN
operator|)
operator|&&
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|snp
operator|->
name|snp_len
condition|)
block|{
while|while
condition|(
name|nblen
operator|/
literal|2
operator|>=
name|snp
operator|->
name|snp_len
operator|&&
name|nblen
operator|/
literal|2
operator|>=
name|SNOOP_MINLEN
condition|)
name|nblen
operator|=
name|nblen
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|nbuf
operator|=
name|malloc
argument_list|(
name|nblen
argument_list|,
name|M_SNP
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|,
name|nbuf
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_SNP
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|nbuf
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|nblen
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snp_in
parameter_list|(
name|snp
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|s_free
decl_stmt|,
name|s_tail
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|nblen
decl_stmt|;
name|caddr_t
name|from
decl_stmt|,
name|to
decl_stmt|;
name|char
modifier|*
name|nbuf
decl_stmt|;
name|KASSERT
argument_list|(
name|n
operator|>=
literal|0
argument_list|,
operator|(
literal|"negative snoop char count"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
condition|)
block|{
name|printf
argument_list|(
literal|"snp%d: more data to down interface\n"
argument_list|,
name|snp
operator|->
name|snp_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
condition|)
block|{
name|printf
argument_list|(
literal|"snp%d: buffer overflow\n"
argument_list|,
name|snp
operator|->
name|snp_unit
argument_list|)
expr_stmt|;
comment|/* 		 * On overflow we just repeat the standart close 		 * procedure...yes , this is waste of space but.. Then next 		 * read from device will fail if one would recall he is 		 * snooping and retry... 		 */
return|return
operator|(
name|snp_down
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
name|s_tail
operator|=
name|snp
operator|->
name|snp_blen
operator|-
operator|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|)
expr_stmt|;
name|s_free
operator|=
name|snp
operator|->
name|snp_blen
operator|-
name|snp
operator|->
name|snp_len
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|s_free
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|>
name|s_free
operator|)
operator|&&
operator|(
operator|(
name|nblen
operator|*
literal|2
operator|)
operator|<=
name|SNOOP_MAXLEN
operator|)
condition|)
block|{
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
operator|*
literal|2
expr_stmt|;
name|s_free
operator|=
name|nblen
operator|-
operator|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|<=
name|s_free
operator|)
operator|&&
operator|(
name|nbuf
operator|=
name|malloc
argument_list|(
name|nblen
argument_list|,
name|M_SNP
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|,
name|nbuf
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_SNP
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|nbuf
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|nblen
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_OFLOW
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_RWAIT
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
name|wakeup
argument_list|(
name|snp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|s_tail
condition|)
block|{
name|from
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|)
expr_stmt|;
name|to
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
name|bcopy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
name|to
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
operator|+
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|to
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_RWAIT
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
name|wakeup
argument_list|(
name|snp
argument_list|)
expr_stmt|;
block|}
name|selwakeuppri
argument_list|(
operator|&
name|snp
operator|->
name|snp_sel
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snpopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|td
parameter_list|)
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|si_drv1
operator|==
name|NULL
condition|)
block|{
name|dev
operator|->
name|si_flags
operator|&=
operator|~
name|SI_CHEAPCLONE
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|snp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|snp
argument_list|)
argument_list|,
name|M_SNP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_unit
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * We intentionally do not OR flags with SNOOP_OPEN, but set them so 	 * all previous settings (especially SNOOP_OFLOW) will be cleared. 	 */
name|snp
operator|->
name|snp_flags
operator|=
name|SNOOP_OPEN
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|malloc
argument_list|(
name|SNOOP_MINLEN
argument_list|,
name|M_SNP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|SNOOP_MINLEN
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * snp_tty == NULL  is for inactive snoop devices. 	 */
name|snp
operator|->
name|snp_tty
operator|=
name|NULL
expr_stmt|;
name|snp
operator|->
name|snp_target
operator|=
name|NULL
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|snp_sclist
argument_list|,
name|snp
argument_list|,
name|snp_list
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snp_detach
parameter_list|(
name|snp
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If line disc. changed we do not touch this pointer, SLIP/PPP will 	 * change it anyway. 	 */
name|tp
operator|=
name|snp
operator|->
name|snp_tty
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
goto|goto
name|detach_notty
goto|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SNOOP
operator|)
operator|&&
name|tp
operator|->
name|t_line
operator|==
name|snooplinedisc
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_SNOOP
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
name|snp
operator|->
name|snp_olddisc
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"snp%d: bad attached tty data\n"
argument_list|,
name|snp
operator|->
name|snp_unit
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_tty
operator|=
name|NULL
expr_stmt|;
name|snp
operator|->
name|snp_target
operator|=
name|NULL
expr_stmt|;
name|detach_notty
label|:
name|selwakeuppri
argument_list|(
operator|&
name|snp
operator|->
name|snp_sel
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OPEN
operator|)
operator|==
literal|0
condition|)
name|free
argument_list|(
name|snp
argument_list|,
name|M_SNP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snpclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|td
parameter_list|)
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|snp
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
literal|0
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|snp
argument_list|,
name|snp_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_SNP
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OPEN
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|snp_detach
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snp_down
parameter_list|(
name|snp
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
block|{
if|if
condition|(
name|snp
operator|->
name|snp_blen
operator|!=
name|SNOOP_MINLEN
condition|)
block|{
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_SNP
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|malloc
argument_list|(
name|SNOOP_MINLEN
argument_list|,
name|M_SNP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|SNOOP_MINLEN
expr_stmt|;
block|}
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_DOWN
expr_stmt|;
return|return
operator|(
name|snp_detach
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snpioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flags
parameter_list|,
name|td
parameter_list|)
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tpo
decl_stmt|;
name|struct
name|cdev
modifier|*
name|tdev
decl_stmt|;
name|int
name|s
decl_stmt|;
name|snp
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNPSTTY
case|:
name|tdev
operator|=
name|findcdev
argument_list|(
operator|*
operator|(
operator|(
name|dev_t
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|snp_down
argument_list|(
name|snp
argument_list|)
operator|)
return|;
name|tp
operator|=
name|snpdevtotty
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SNOOP
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_target
operator|==
name|NULL
condition|)
block|{
name|tpo
operator|=
name|snp
operator|->
name|snp_tty
expr_stmt|;
if|if
condition|(
name|tpo
condition|)
name|tpo
operator|->
name|t_state
operator|&=
operator|~
name|TS_SNOOP
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator||=
name|TS_SNOOP
expr_stmt|;
name|snp
operator|->
name|snp_olddisc
operator|=
name|tp
operator|->
name|t_line
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
name|snooplinedisc
expr_stmt|;
name|snp
operator|->
name|snp_tty
operator|=
name|tp
expr_stmt|;
name|snp
operator|->
name|snp_target
operator|=
name|tdev
expr_stmt|;
comment|/* 		 * Clean overflow and down flags - 		 * we'll have a chance to get them in the future :))) 		 */
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OFLOW
expr_stmt|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_DOWN
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNPGTTY
case|:
comment|/* 		 * We keep snp_target field specially to make 		 * SNPGTTY happy, else we can't know what is device 		 * major/minor for tty. 		 */
operator|*
operator|(
operator|(
name|dev_t
operator|*
operator|)
name|data
operator|)
operator|=
name|dev2udev
argument_list|(
name|snp
operator|->
name|snp_target
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIONBIO
case|:
break|break;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_ASYNC
expr_stmt|;
else|else
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_ASYNC
expr_stmt|;
break|break;
case|case
name|FIONREAD
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_tty
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
elseif|else
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
condition|)
block|{
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_OFLOW
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_TTYCLOSE
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_DETACH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snppoll
parameter_list|(
name|dev
parameter_list|,
name|events
parameter_list|,
name|td
parameter_list|)
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|events
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|snp
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If snoop is down, we don't want to poll() forever so we return 1. 	 * Caller should see if we down via FIONREAD ioctl().  The last should 	 * return -1 to indicate down state. 	 */
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
operator|||
name|snp
operator|->
name|snp_len
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|snp
operator|->
name|snp_sel
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|snp_clone
parameter_list|(
name|arg
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|dev
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|cdev
modifier|*
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|u
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
literal|"snp"
argument_list|,
operator|&
name|u
argument_list|)
operator|!=
literal|1
condition|)
return|return;
name|i
operator|=
name|clone_create
argument_list|(
operator|&
name|snpclones
argument_list|,
operator|&
name|snp_cdevsw
argument_list|,
operator|&
name|u
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|snp_cdevsw
argument_list|,
name|unit2minor
argument_list|(
name|u
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"snp%d"
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|dev
operator|)
operator|->
name|si_flags
operator||=
name|SI_CHEAPCLONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|snp_modevent
parameter_list|(
name|mod
parameter_list|,
name|type
parameter_list|,
name|data
parameter_list|)
name|module_t
name|mod
decl_stmt|;
name|int
name|type
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
specifier|static
name|eventhandler_tag
name|eh_tag
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* XXX error checking. */
name|clone_setup
argument_list|(
operator|&
name|snpclones
argument_list|)
expr_stmt|;
name|eh_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|snp_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|snooplinedisc
operator|=
name|ldisc_register
argument_list|(
name|LDISC_LOAD
argument_list|,
operator|&
name|snpdisc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|snp_sclist
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|dev_clone
argument_list|,
name|eh_tag
argument_list|)
expr_stmt|;
name|clone_cleanup
argument_list|(
operator|&
name|snpclones
argument_list|)
expr_stmt|;
name|ldisc_deregister
argument_list|(
name|snooplinedisc
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|snp_mod
init|=
block|{
literal|"snp"
block|,
name|snp_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|snp
argument_list|,
name|snp_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

