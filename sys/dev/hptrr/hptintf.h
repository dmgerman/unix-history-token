begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) HighPoint Technologies, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/hptrr/hptrr_config.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HPT_INTF_H
end_ifndef

begin_define
define|#
directive|define
name|HPT_INTF_H
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__BIG_ENDIAN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__BIG_ENDIAN_BITFIELD
argument_list|)
end_if

begin_define
define|#
directive|define
name|__BIG_ENDIAN_BITFIELD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|__GNUC__
define|#
directive|define
name|__attribute__
parameter_list|(
name|x
parameter_list|)
endif|#
directive|endif
pragma|#
directive|pragma
name|pack
name|(
name|1
name|)
comment|/*  * Version of this interface.  * The user mode application must first issue a hpt_get_version() call to  * check HPT_INTERFACE_VERSION. When an utility using newer version interface  * is used with old version drivers, it must call only the functions that  * driver supported.  * A new version interface should only add ioctl functions; it should implement  * all old version functions without change their definition.  */
define|#
directive|define
name|__this_HPT_INTERFACE_VERSION
value|0x02000001
ifndef|#
directive|ifndef
name|HPT_INTERFACE_VERSION
error|#
directive|error
literal|"You must define HPT_INTERFACE_VERSION you implemented"
endif|#
directive|endif
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>
name|__this_HPT_INTERFACE_VERSION
error|#
directive|error
literal|"HPT_INTERFACE_VERSION is invalid"
endif|#
directive|endif
comment|/*  * DEFINITION  *   Logical device  --- a device that can be accessed by OS.  *   Physical device --- device attached to the controller.  *  A logical device can be simply a physical device.  *  * Each logical and physical device has a 32bit ID. GUI will use this ID  * to identify devices.  *   1. The ID must be unique.  *   2. The ID must be immutable. Once an ID is assigned to a device, it  * must not change when system is running and the device exists.  *   3. The ID of logical device must be NOT reusable. If a device is  * removed, other newly created logical device must not use the same ID.  *   4. The ID must not be zero or 0xFFFFFFFF.  */
typedef|typedef
name|HPT_U32
name|DEVICEID
typedef|;
comment|/*  * logical device type.  * Identify array (logical device) and physical device.  */
define|#
directive|define
name|LDT_ARRAY
value|1
define|#
directive|define
name|LDT_DEVICE
value|2
comment|/*  * Array types  * GUI will treat all array as 1-level RAID. No RAID0/1 or RAID1/0.  * A RAID0/1 device is type AT_RAID1. A RAID1/0 device is type AT_RAID0.  * Their members may be another array of type RAID0 or RAID1.  */
define|#
directive|define
name|AT_UNKNOWN
value|0
define|#
directive|define
name|AT_RAID0
value|1
define|#
directive|define
name|AT_RAID1
value|2
define|#
directive|define
name|AT_RAID5
value|3
define|#
directive|define
name|AT_RAID6
value|4
define|#
directive|define
name|AT_JBOD
value|7
comment|/*  * physical device type  */
define|#
directive|define
name|PDT_UNKNOWN
value|0
define|#
directive|define
name|PDT_HARDDISK
value|1
define|#
directive|define
name|PDT_CDROM
value|2
define|#
directive|define
name|PDT_TAPE
value|3
comment|/*  * Some constants.  */
define|#
directive|define
name|MAX_NAME_LENGTH
value|36
define|#
directive|define
name|MAX_ARRAYNAME_LEN
value|16
define|#
directive|define
name|MAX_ARRAY_MEMBERS_V1
value|8
ifndef|#
directive|ifndef
name|MAX_ARRAY_MEMBERS_V2
define|#
directive|define
name|MAX_ARRAY_MEMBERS_V2
value|16
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MAX_ARRAY_MEMBERS_V3
define|#
directive|define
name|MAX_ARRAY_MEMBERS_V3
value|64
endif|#
directive|endif
comment|/* keep definition for source code compatiblity */
define|#
directive|define
name|MAX_ARRAY_MEMBERS
value|MAX_ARRAY_MEMBERS_V1
comment|/*  * io commands  * GUI use these commands to do IO on logical/physical devices.  */
define|#
directive|define
name|IO_COMMAND_READ
value|1
define|#
directive|define
name|IO_COMMAND_WRITE
value|2
comment|/*  * array flags  */
define|#
directive|define
name|ARRAY_FLAG_DISABLED
value|0x00000001
comment|/* The array is disabled */
define|#
directive|define
name|ARRAY_FLAG_NEEDBUILDING
value|0x00000002
comment|/* array data need to be rebuilt */
define|#
directive|define
name|ARRAY_FLAG_REBUILDING
value|0x00000004
comment|/* array is in rebuilding process */
define|#
directive|define
name|ARRAY_FLAG_BROKEN
value|0x00000008
comment|/* broken but may still working */
define|#
directive|define
name|ARRAY_FLAG_BOOTDISK
value|0x00000010
comment|/* array has a active partition */
define|#
directive|define
name|ARRAY_FLAG_BOOTMARK
value|0x00000040
comment|/* array has boot mark set */
define|#
directive|define
name|ARRAY_FLAG_NEED_AUTOREBUILD
value|0x00000080
comment|/* auto-rebuild should start */
define|#
directive|define
name|ARRAY_FLAG_VERIFYING
value|0x00000100
comment|/* is being verified */
define|#
directive|define
name|ARRAY_FLAG_INITIALIZING
value|0x00000200
comment|/* is being initialized */
define|#
directive|define
name|ARRAY_FLAG_TRANSFORMING
value|0x00000400
comment|/* tranform in progress */
define|#
directive|define
name|ARRAY_FLAG_NEEDTRANSFORM
value|0x00000800
comment|/* array need tranform */
define|#
directive|define
name|ARRAY_FLAG_NEEDINITIALIZING
value|0x00001000
comment|/* the array's initialization hasn't finished*/
define|#
directive|define
name|ARRAY_FLAG_BROKEN_REDUNDANT
value|0x00002000
comment|/* broken but redundant (raid6) */
define|#
directive|define
name|ARRAY_FLAG_RAID15PLUS
value|0x80000000
comment|/* display this RAID 1 as RAID 1.5 */
comment|/*  * device flags  */
define|#
directive|define
name|DEVICE_FLAG_DISABLED
value|0x00000001
comment|/* device is disabled */
define|#
directive|define
name|DEVICE_FLAG_BOOTDISK
value|0x00000002
comment|/* disk has a active partition */
define|#
directive|define
name|DEVICE_FLAG_BOOTMARK
value|0x00000004
comment|/* disk has boot mark set */
define|#
directive|define
name|DEVICE_FLAG_WITH_601
value|0x00000008
comment|/* has HPT601 connected */
define|#
directive|define
name|DEVICE_FLAG_SATA
value|0x00000010
comment|/* S-ATA device */
define|#
directive|define
name|DEVICE_FLAG_ON_PM_PORT
value|0x00000020
comment|/* PM port */
define|#
directive|define
name|DEVICE_FLAG_UNINITIALIZED
value|0x00010000
comment|/* device is not initialized, can't be used to create array */
define|#
directive|define
name|DEVICE_FLAG_LEGACY
value|0x00020000
comment|/* single disk& mbr contains at least one partition */
define|#
directive|define
name|DEVICE_FLAG_IS_SPARE
value|0x80000000
comment|/* is a spare disk */
comment|/*  * array states used by hpt_set_array_state()  */
comment|/* old defines */
define|#
directive|define
name|MIRROR_REBUILD_START
value|1
define|#
directive|define
name|MIRROR_REBUILD_ABORT
value|2
define|#
directive|define
name|MIRROR_REBUILD_COMPLETE
value|3
comment|/* new defines */
define|#
directive|define
name|AS_REBUILD_START
value|1
define|#
directive|define
name|AS_REBUILD_ABORT
value|2
define|#
directive|define
name|AS_REBUILD_PAUSE
value|AS_REBUILD_ABORT
define|#
directive|define
name|AS_REBUILD_COMPLETE
value|3
define|#
directive|define
name|AS_VERIFY_START
value|4
define|#
directive|define
name|AS_VERIFY_ABORT
value|5
define|#
directive|define
name|AS_VERIFY_COMPLETE
value|6
define|#
directive|define
name|AS_INITIALIZE_START
value|7
define|#
directive|define
name|AS_INITIALIZE_ABORT
value|8
define|#
directive|define
name|AS_INITIALIZE_COMPLETE
value|9
define|#
directive|define
name|AS_VERIFY_FAILED
value|10
define|#
directive|define
name|AS_REBUILD_STOP
value|11
define|#
directive|define
name|AS_SAVE_STATE
value|12
define|#
directive|define
name|AS_TRANSFORM_START
value|13
define|#
directive|define
name|AS_TRANSFORM_ABORT
value|14
comment|/************************************************************************  * ioctl code  * It would be better if ioctl code are the same on different platforms,  * but we must not conflict with system defined ioctl code.  ************************************************************************/
if|#
directive|if
name|defined
argument_list|(
name|LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
define|#
directive|define
name|HPT_CTL_CODE
parameter_list|(
name|x
parameter_list|)
value|(x+0xFF00)
define|#
directive|define
name|HPT_CTL_CODE_LINUX_TO_IOP
parameter_list|(
name|x
parameter_list|)
value|((x)-0xff00)
elif|#
directive|elif
name|defined
argument_list|(
name|_MS_WIN32_
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
ifndef|#
directive|ifndef
name|CTL_CODE
define|#
directive|define
name|CTL_CODE
parameter_list|(
name|DeviceType
parameter_list|,
name|Function
parameter_list|,
name|Method
parameter_list|,
name|Access
parameter_list|)
define|\
value|(((DeviceType)<< 16) | ((Access)<< 14) | ((Function)<< 2) | (Method))
endif|#
directive|endif
define|#
directive|define
name|HPT_CTL_CODE
parameter_list|(
name|x
parameter_list|)
value|CTL_CODE(0x370, 0x900+(x), 0, 0)
define|#
directive|define
name|HPT_CTL_CODE_WIN32_TO_IOP
parameter_list|(
name|x
parameter_list|)
value|((((x)& 0xffff)>>2)-0x900)
else|#
directive|else
define|#
directive|define
name|HPT_CTL_CODE
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
define|#
directive|define
name|HPT_IOCTL_GET_VERSION
value|HPT_CTL_CODE(0)
define|#
directive|define
name|HPT_IOCTL_GET_CONTROLLER_COUNT
value|HPT_CTL_CODE(1)
define|#
directive|define
name|HPT_IOCTL_GET_CONTROLLER_INFO
value|HPT_CTL_CODE(2)
define|#
directive|define
name|HPT_IOCTL_GET_CHANNEL_INFO
value|HPT_CTL_CODE(3)
define|#
directive|define
name|HPT_IOCTL_GET_LOGICAL_DEVICES
value|HPT_CTL_CODE(4)
define|#
directive|define
name|HPT_IOCTL_GET_DEVICE_INFO
value|HPT_CTL_CODE(5)
define|#
directive|define
name|HPT_IOCTL_CREATE_ARRAY
value|HPT_CTL_CODE(6)
define|#
directive|define
name|HPT_IOCTL_DELETE_ARRAY
value|HPT_CTL_CODE(7)
define|#
directive|define
name|HPT_IOCTL_ARRAY_IO
value|HPT_CTL_CODE(8)
define|#
directive|define
name|HPT_IOCTL_DEVICE_IO
value|HPT_CTL_CODE(9)
define|#
directive|define
name|HPT_IOCTL_GET_EVENT
value|HPT_CTL_CODE(10)
define|#
directive|define
name|HPT_IOCTL_REBUILD_MIRROR
value|HPT_CTL_CODE(11)
comment|/* use HPT_IOCTL_REBUILD_DATA_BLOCK from now on */
define|#
directive|define
name|HPT_IOCTL_REBUILD_DATA_BLOCK
value|HPT_IOCTL_REBUILD_MIRROR
define|#
directive|define
name|HPT_IOCTL_ADD_SPARE_DISK
value|HPT_CTL_CODE(12)
define|#
directive|define
name|HPT_IOCTL_REMOVE_SPARE_DISK
value|HPT_CTL_CODE(13)
define|#
directive|define
name|HPT_IOCTL_ADD_DISK_TO_ARRAY
value|HPT_CTL_CODE(14)
define|#
directive|define
name|HPT_IOCTL_SET_ARRAY_STATE
value|HPT_CTL_CODE(15)
define|#
directive|define
name|HPT_IOCTL_SET_ARRAY_INFO
value|HPT_CTL_CODE(16)
define|#
directive|define
name|HPT_IOCTL_SET_DEVICE_INFO
value|HPT_CTL_CODE(17)
define|#
directive|define
name|HPT_IOCTL_RESCAN_DEVICES
value|HPT_CTL_CODE(18)
define|#
directive|define
name|HPT_IOCTL_GET_DRIVER_CAPABILITIES
value|HPT_CTL_CODE(19)
define|#
directive|define
name|HPT_IOCTL_GET_601_INFO
value|HPT_CTL_CODE(20)
define|#
directive|define
name|HPT_IOCTL_SET_601_INFO
value|HPT_CTL_CODE(21)
define|#
directive|define
name|HPT_IOCTL_LOCK_DEVICE
value|HPT_CTL_CODE(22)
define|#
directive|define
name|HPT_IOCTL_UNLOCK_DEVICE
value|HPT_CTL_CODE(23)
define|#
directive|define
name|HPT_IOCTL_IDE_PASS_THROUGH
value|HPT_CTL_CODE(24)
define|#
directive|define
name|HPT_IOCTL_VERIFY_DATA_BLOCK
value|HPT_CTL_CODE(25)
define|#
directive|define
name|HPT_IOCTL_INITIALIZE_DATA_BLOCK
value|HPT_CTL_CODE(26)
define|#
directive|define
name|HPT_IOCTL_ADD_DEDICATED_SPARE
value|HPT_CTL_CODE(27)
define|#
directive|define
name|HPT_IOCTL_DEVICE_IO_EX
value|HPT_CTL_CODE(28)
define|#
directive|define
name|HPT_IOCTL_SET_BOOT_MARK
value|HPT_CTL_CODE(29)
define|#
directive|define
name|HPT_IOCTL_QUERY_REMOVE
value|HPT_CTL_CODE(30)
define|#
directive|define
name|HPT_IOCTL_REMOVE_DEVICES
value|HPT_CTL_CODE(31)
define|#
directive|define
name|HPT_IOCTL_CREATE_ARRAY_V2
value|HPT_CTL_CODE(32)
define|#
directive|define
name|HPT_IOCTL_GET_DEVICE_INFO_V2
value|HPT_CTL_CODE(33)
define|#
directive|define
name|HPT_IOCTL_SET_DEVICE_INFO_V2
value|HPT_CTL_CODE(34)
define|#
directive|define
name|HPT_IOCTL_REBUILD_DATA_BLOCK_V2
value|HPT_CTL_CODE(35)
define|#
directive|define
name|HPT_IOCTL_VERIFY_DATA_BLOCK_V2
value|HPT_CTL_CODE(36)
define|#
directive|define
name|HPT_IOCTL_INITIALIZE_DATA_BLOCK_V2
value|HPT_CTL_CODE(37)
define|#
directive|define
name|HPT_IOCTL_LOCK_DEVICE_V2
value|HPT_CTL_CODE(38)
define|#
directive|define
name|HPT_IOCTL_DEVICE_IO_V2
value|HPT_CTL_CODE(39)
define|#
directive|define
name|HPT_IOCTL_DEVICE_IO_EX_V2
value|HPT_CTL_CODE(40)
define|#
directive|define
name|HPT_IOCTL_CREATE_TRANSFORM
value|HPT_CTL_CODE(41)
define|#
directive|define
name|HPT_IOCTL_STEP_TRANSFORM
value|HPT_CTL_CODE(42)
define|#
directive|define
name|HPT_IOCTL_SET_VDEV_INFO
value|HPT_CTL_CODE(43)
define|#
directive|define
name|HPT_IOCTL_CALC_MAX_CAPACITY
value|HPT_CTL_CODE(44)
define|#
directive|define
name|HPT_IOCTL_INIT_DISKS
value|HPT_CTL_CODE(45)
define|#
directive|define
name|HPT_IOCTL_GET_DEVICE_INFO_V3
value|HPT_CTL_CODE(46)
define|#
directive|define
name|HPT_IOCTL_GET_CONTROLLER_INFO_V2
value|HPT_CTL_CODE(47)
define|#
directive|define
name|HPT_IOCTL_I2C_TRANSACTION
value|HPT_CTL_CODE(48)
define|#
directive|define
name|HPT_IOCTL_GET_PARAMETER_LIST
value|HPT_CTL_CODE(49)
define|#
directive|define
name|HPT_IOCTL_GET_PARAMETER
value|HPT_CTL_CODE(50)
define|#
directive|define
name|HPT_IOCTL_SET_PARAMETER
value|HPT_CTL_CODE(51)
define|#
directive|define
name|HPT_IOCTL_GET_DRIVER_CAPABILITIES_V2
value|HPT_CTL_CODE(52)
define|#
directive|define
name|HPT_IOCTL_GET_CHANNEL_INFO_V2
value|HPT_CTL_CODE(53)
define|#
directive|define
name|HPT_IOCTL_GET_CONTROLLER_INFO_V3
value|HPT_CTL_CODE(54)
define|#
directive|define
name|HPT_IOCTL_GET_DEVICE_INFO_V4
value|HPT_CTL_CODE(55)
define|#
directive|define
name|HPT_IOCTL_CREATE_ARRAY_V3
value|HPT_CTL_CODE(56)
define|#
directive|define
name|HPT_IOCTL_CREATE_TRANSFORM_V2
value|HPT_CTL_CODE(57)
define|#
directive|define
name|HPT_IOCTL_CALC_MAX_CAPACITY_V2
value|HPT_CTL_CODE(58)
define|#
directive|define
name|HPT_IOCTL_GET_CONTROLLER_IDS
value|HPT_CTL_CODE(100)
define|#
directive|define
name|HPT_IOCTL_GET_DCB
value|HPT_CTL_CODE(101)
define|#
directive|define
name|HPT_IOCTL_EPROM_IO
value|HPT_CTL_CODE(102)
define|#
directive|define
name|HPT_IOCTL_GET_CONTROLLER_VENID
value|HPT_CTL_CODE(103)
comment|/************************************************************************  * shared data structures  ************************************************************************/
comment|/*  * Chip Type  */
define|#
directive|define
name|CHIP_TYPE_HPT366
value|1
define|#
directive|define
name|CHIP_TYPE_HPT368
value|2
define|#
directive|define
name|CHIP_TYPE_HPT370
value|3
define|#
directive|define
name|CHIP_TYPE_HPT370A
value|4
define|#
directive|define
name|CHIP_TYPE_HPT370B
value|5
define|#
directive|define
name|CHIP_TYPE_HPT374
value|6
define|#
directive|define
name|CHIP_TYPE_HPT372
value|7
define|#
directive|define
name|CHIP_TYPE_HPT372A
value|8
define|#
directive|define
name|CHIP_TYPE_HPT302
value|9
define|#
directive|define
name|CHIP_TYPE_HPT371
value|10
define|#
directive|define
name|CHIP_TYPE_HPT372N
value|11
define|#
directive|define
name|CHIP_TYPE_HPT302N
value|12
define|#
directive|define
name|CHIP_TYPE_HPT371N
value|13
define|#
directive|define
name|CHIP_TYPE_SI3112A
value|14
define|#
directive|define
name|CHIP_TYPE_ICH5
value|15
define|#
directive|define
name|CHIP_TYPE_ICH5R
value|16
comment|/*  * Chip Flags  */
define|#
directive|define
name|CHIP_SUPPORT_ULTRA_66
value|0x20
define|#
directive|define
name|CHIP_SUPPORT_ULTRA_100
value|0x40
define|#
directive|define
name|CHIP_HPT3XX_DPLL_MODE
value|0x80
define|#
directive|define
name|CHIP_SUPPORT_ULTRA_133
value|0x01
define|#
directive|define
name|CHIP_SUPPORT_ULTRA_150
value|0x02
define|#
directive|define
name|CHIP_MASTER
value|0x04
define|#
directive|define
name|CHIP_SUPPORT_SATA_300
value|0x08
define|#
directive|define
name|HPT_SPIN_UP_MODE_NOSUPPORT
value|0
define|#
directive|define
name|HPT_SPIN_UP_MODE_FULL
value|1
define|#
directive|define
name|HPT_SPIN_UP_MODE_STANDBY
value|2
typedef|typedef
struct|struct
name|_DRIVER_CAPABILITIES
block|{
name|HPT_U32
name|dwSize
decl_stmt|;
name|HPT_U8
name|MaximumControllers
decl_stmt|;
comment|/* maximum controllers the driver can support */
name|HPT_U8
name|SupportCrossControllerRAID
decl_stmt|;
comment|/* 1-support, 0-not support */
name|HPT_U8
name|MinimumBlockSizeShift
decl_stmt|;
comment|/* minimum block size shift */
name|HPT_U8
name|MaximumBlockSizeShift
decl_stmt|;
comment|/* maximum block size shift */
name|HPT_U8
name|SupportDiskModeSetting
decl_stmt|;
name|HPT_U8
name|SupportSparePool
decl_stmt|;
name|HPT_U8
name|MaximumArrayNameLength
decl_stmt|;
comment|/* only one HPT_U8 left here! */
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|HPT_U8
name|reserved
range|:
literal|4
decl_stmt|;
name|HPT_U8
name|SupportHotSwap
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|HighPerformanceRAID1
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|RebuildProcessInDriver
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|SupportDedicatedSpare
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|HPT_U8
name|SupportDedicatedSpare
range|:
literal|1
decl_stmt|;
comment|/* call hpt_add_dedicated_spare() for dedicated spare. */
name|HPT_U8
name|RebuildProcessInDriver
range|:
literal|1
decl_stmt|;
comment|/* Windows only. used by mid layer for rebuild control. */
name|HPT_U8
name|HighPerformanceRAID1
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|SupportHotSwap
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|reserved
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
name|HPT_U8
name|SupportedRAIDTypes
index|[
literal|16
index|]
decl_stmt|;
comment|/* maximum members in an array corresponding to SupportedRAIDTypes */
name|HPT_U8
name|MaximumArrayMembers
index|[
literal|16
index|]
decl_stmt|;
block|}
name|DRIVER_CAPABILITIES
operator|,
typedef|*
name|PDRIVER_CAPABILITIES
typedef|;
typedef|typedef
struct|struct
name|_DRIVER_CAPABILITIES_V2
block|{
name|DRIVER_CAPABILITIES
name|v1
decl_stmt|;
name|HPT_U8
name|SupportedCachePolicies
index|[
literal|16
index|]
decl_stmt|;
name|HPT_U32
name|reserved
index|[
literal|17
index|]
decl_stmt|;
block|}
name|DRIVER_CAPABILITIES_V2
operator|,
typedef|*
name|PDRIVER_CAPABILITIES_V2
typedef|;
comment|/*  * Controller information.  */
typedef|typedef
struct|struct
name|_CONTROLLER_INFO
block|{
name|HPT_U8
name|ChipType
decl_stmt|;
comment|/* chip type */
name|HPT_U8
name|InterruptLevel
decl_stmt|;
comment|/* IRQ level */
name|HPT_U8
name|NumBuses
decl_stmt|;
comment|/* bus count */
name|HPT_U8
name|ChipFlags
decl_stmt|;
name|HPT_U8
name|szProductID
index|[
name|MAX_NAME_LENGTH
index|]
decl_stmt|;
comment|/* product name */
name|HPT_U8
name|szVendorID
index|[
name|MAX_NAME_LENGTH
index|]
decl_stmt|;
comment|/* vender name */
block|}
name|CONTROLLER_INFO
operator|,
typedef|*
name|PCONTROLLER_INFO
typedef|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
typedef|typedef
struct|struct
name|_CONTROLLER_INFO_V2
block|{
name|HPT_U8
name|ChipType
decl_stmt|;
comment|/* chip type */
name|HPT_U8
name|InterruptLevel
decl_stmt|;
comment|/* IRQ level */
name|HPT_U8
name|NumBuses
decl_stmt|;
comment|/* bus count */
name|HPT_U8
name|ChipFlags
decl_stmt|;
name|HPT_U8
name|szProductID
index|[
name|MAX_NAME_LENGTH
index|]
decl_stmt|;
comment|/* product name */
name|HPT_U8
name|szVendorID
index|[
name|MAX_NAME_LENGTH
index|]
decl_stmt|;
comment|/* vender name */
name|HPT_U32
name|GroupId
decl_stmt|;
comment|/* low 32bit of vbus pointer the controller belongs 										 * the master controller has CHIP_MASTER flag set*/
name|HPT_U8
name|pci_tree
decl_stmt|;
name|HPT_U8
name|pci_bus
decl_stmt|;
name|HPT_U8
name|pci_device
decl_stmt|;
name|HPT_U8
name|pci_function
decl_stmt|;
name|HPT_U32
name|ExFlags
decl_stmt|;
block|}
name|CONTROLLER_INFO_V2
operator|,
typedef|*
name|PCONTROLLER_INFO_V2
typedef|;
define|#
directive|define
name|CEXF_IOPModel
value|1
define|#
directive|define
name|CEXF_SDRAMSize
value|2
define|#
directive|define
name|CEXF_BatteryInstalled
value|4
define|#
directive|define
name|CEXF_BatteryStatus
value|8
define|#
directive|define
name|CEXF_BatteryVoltage
value|0x10
define|#
directive|define
name|CEXF_BatteryBackupTime
value|0x20
define|#
directive|define
name|CEXF_FirmwareVersion
value|0x40
define|#
directive|define
name|CEXF_SerialNumber
value|0x80
typedef|typedef
struct|struct
name|_CONTROLLER_INFO_V3
block|{
name|HPT_U8
name|ChipType
decl_stmt|;
name|HPT_U8
name|InterruptLevel
decl_stmt|;
name|HPT_U8
name|NumBuses
decl_stmt|;
name|HPT_U8
name|ChipFlags
decl_stmt|;
name|HPT_U8
name|szProductID
index|[
name|MAX_NAME_LENGTH
index|]
decl_stmt|;
name|HPT_U8
name|szVendorID
index|[
name|MAX_NAME_LENGTH
index|]
decl_stmt|;
name|HPT_U32
name|GroupId
decl_stmt|;
name|HPT_U8
name|pci_tree
decl_stmt|;
name|HPT_U8
name|pci_bus
decl_stmt|;
name|HPT_U8
name|pci_device
decl_stmt|;
name|HPT_U8
name|pci_function
decl_stmt|;
name|HPT_U32
name|ExFlags
decl_stmt|;
name|HPT_U8
name|IOPModel
index|[
literal|32
index|]
decl_stmt|;
name|HPT_U32
name|SDRAMSize
decl_stmt|;
name|HPT_U8
name|BatteryInstalled
decl_stmt|;
name|HPT_U8
name|BatteryStatus
decl_stmt|;
name|HPT_U16
name|BatteryVoltage
decl_stmt|;
name|HPT_U32
name|BatteryBackupTime
decl_stmt|;
name|HPT_U32
name|FirmwareVersion
decl_stmt|;
name|HPT_U8
name|SerialNumber
index|[
literal|32
index|]
decl_stmt|;
name|HPT_U8
name|reserve
index|[
literal|88
index|]
decl_stmt|;
block|}
name|CONTROLLER_INFO_V3
operator|,
typedef|*
name|PCONTROLLER_INFO_V3
typedef|;
typedef|typedef
name|char
name|check_CONTROLLER_INFO_V3
index|[
sizeof|sizeof
argument_list|(
name|CONTROLLER_INFO_V3
argument_list|)
operator|==
literal|256
condition|?
literal|1
else|:
operator|-
literal|1
index|]
typedef|;
endif|#
directive|endif
comment|/*  * Channel information.  */
typedef|typedef
struct|struct
name|_CHANNEL_INFO
block|{
name|HPT_U32
name|IoPort
decl_stmt|;
comment|/* IDE Base Port Address */
name|HPT_U32
name|ControlPort
decl_stmt|;
comment|/* IDE Control Port Address */
name|DEVICEID
name|Devices
index|[
literal|2
index|]
decl_stmt|;
comment|/* device connected to this channel */
block|}
name|CHANNEL_INFO
operator|,
typedef|*
name|PCHANNEL_INFO
typedef|;
typedef|typedef
struct|struct
name|_CHANNEL_INFO_V2
block|{
name|HPT_U32
name|IoPort
decl_stmt|;
comment|/* IDE Base Port Address */
name|HPT_U32
name|ControlPort
decl_stmt|;
comment|/* IDE Control Port Address */
name|DEVICEID
name|Devices
index|[
literal|2
operator|+
literal|13
index|]
decl_stmt|;
comment|/* device connected to this channel, PMPort max=15 */
block|}
name|CHANNEL_INFO_V2
operator|,
typedef|*
name|PCHANNEL_INFO_V2
typedef|;
ifndef|#
directive|ifndef
name|__KERNEL__
comment|/*  * time represented in HPT_U32 format  */
typedef|typedef
struct|struct
name|_TIME_RECORD
block|{
name|HPT_U32
name|seconds
range|:
literal|6
decl_stmt|;
comment|/* 0 - 59 */
name|HPT_U32
name|minutes
range|:
literal|6
decl_stmt|;
comment|/* 0 - 59 */
name|HPT_U32
name|month
range|:
literal|4
decl_stmt|;
comment|/* 1 - 12 */
name|HPT_U32
name|hours
range|:
literal|6
decl_stmt|;
comment|/* 0 - 59 */
name|HPT_U32
name|day
range|:
literal|5
decl_stmt|;
comment|/* 1 - 31 */
name|HPT_U32
name|year
range|:
literal|5
decl_stmt|;
comment|/* 0=2000, 31=2031 */
block|}
name|TIME_RECORD
typedef|;
endif|#
directive|endif
comment|/*  * Array information.  */
typedef|typedef
struct|struct
name|_HPT_ARRAY_INFO
block|{
name|HPT_U8
name|Name
index|[
name|MAX_ARRAYNAME_LEN
index|]
decl_stmt|;
comment|/* array name */
name|HPT_U8
name|Description
index|[
literal|64
index|]
decl_stmt|;
comment|/* array description */
name|HPT_U8
name|CreateManager
index|[
literal|16
index|]
decl_stmt|;
comment|/* who created it */
name|TIME_RECORD
name|CreateTime
decl_stmt|;
comment|/* when created it */
name|HPT_U8
name|ArrayType
decl_stmt|;
comment|/* array type */
name|HPT_U8
name|BlockSizeShift
decl_stmt|;
comment|/* stripe size */
name|HPT_U8
name|nDisk
decl_stmt|;
comment|/* member count: Number of ID in Members[] */
name|HPT_U8
name|reserved
decl_stmt|;
name|HPT_U32
name|Flags
decl_stmt|;
comment|/* working flags, see ARRAY_FLAG_XXX */
name|HPT_U32
name|Members
index|[
name|MAX_ARRAY_MEMBERS_V1
index|]
decl_stmt|;
comment|/* member array/disks */
comment|/* 	 * rebuilding progress, xx.xx% = sprintf(s, "%.2f%%", RebuildingProgress/100.0); 	 * only valid if rebuilding is done by driver code. 	 * Member Flags will have ARRAY_FLAG_REBUILDING set at this case. 	 * Verify operation use same fields below, the only difference is 	 * ARRAY_FLAG_VERIFYING is set. 	 */
name|HPT_U32
name|RebuildingProgress
decl_stmt|;
name|HPT_U32
name|RebuiltSectors
decl_stmt|;
comment|/* rebuilding point (LBA) for single member */
block|}
name|HPT_ARRAY_INFO
operator|,
typedef|*
name|PHPT_ARRAY_INFO
typedef|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
typedef|typedef
struct|struct
name|_HPT_ARRAY_INFO_V2
block|{
name|HPT_U8
name|Name
index|[
name|MAX_ARRAYNAME_LEN
index|]
decl_stmt|;
comment|/* array name */
name|HPT_U8
name|Description
index|[
literal|64
index|]
decl_stmt|;
comment|/* array description */
name|HPT_U8
name|CreateManager
index|[
literal|16
index|]
decl_stmt|;
comment|/* who created it */
name|TIME_RECORD
name|CreateTime
decl_stmt|;
comment|/* when created it */
name|HPT_U8
name|ArrayType
decl_stmt|;
comment|/* array type */
name|HPT_U8
name|BlockSizeShift
decl_stmt|;
comment|/* stripe size */
name|HPT_U8
name|nDisk
decl_stmt|;
comment|/* member count: Number of ID in Members[] */
name|HPT_U8
name|reserved
decl_stmt|;
name|HPT_U32
name|Flags
decl_stmt|;
comment|/* working flags, see ARRAY_FLAG_XXX */
name|HPT_U32
name|Members
index|[
name|MAX_ARRAY_MEMBERS_V2
index|]
decl_stmt|;
comment|/* member array/disks */
name|HPT_U32
name|RebuildingProgress
decl_stmt|;
name|HPT_U64
name|RebuiltSectors
decl_stmt|;
comment|/* rebuilding point (LBA) for single member */
name|HPT_U32
name|reserve4
index|[
literal|4
index|]
decl_stmt|;
block|}
name|HPT_ARRAY_INFO_V2
operator|,
typedef|*
name|PHPT_ARRAY_INFO_V2
typedef|;
endif|#
directive|endif
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
typedef|typedef
struct|struct
name|_HPT_ARRAY_INFO_V3
block|{
name|HPT_U8
name|Name
index|[
name|MAX_ARRAYNAME_LEN
index|]
decl_stmt|;
comment|/* array name */
name|HPT_U8
name|Description
index|[
literal|64
index|]
decl_stmt|;
comment|/* array description */
name|HPT_U8
name|CreateManager
index|[
literal|16
index|]
decl_stmt|;
comment|/* who created it */
name|TIME_RECORD
name|CreateTime
decl_stmt|;
comment|/* when created it */
name|HPT_U8
name|ArrayType
decl_stmt|;
comment|/* array type */
name|HPT_U8
name|BlockSizeShift
decl_stmt|;
comment|/* stripe size */
name|HPT_U8
name|nDisk
decl_stmt|;
comment|/* member count: Number of ID in Members[] */
name|HPT_U8
name|reserved
decl_stmt|;
name|HPT_U32
name|Flags
decl_stmt|;
comment|/* working flags, see ARRAY_FLAG_XXX */
name|HPT_U32
name|Members
index|[
name|MAX_ARRAY_MEMBERS_V2
index|]
decl_stmt|;
comment|/* member array/disks */
name|HPT_U32
name|RebuildingProgress
decl_stmt|;
name|HPT_U64
name|RebuiltSectors
decl_stmt|;
comment|/* rebuilding point (LBA) for single member */
name|DEVICEID
name|TransformSource
decl_stmt|;
name|DEVICEID
name|TransformTarget
decl_stmt|;
comment|/* destination device ID */
name|HPT_U32
name|TransformingProgress
decl_stmt|;
name|HPT_U32
name|Signature
decl_stmt|;
comment|/* persistent identification*/
if|#
directive|if
name|MAX_ARRAY_MEMBERS_V2
operator|==
literal|16
name|HPT_U16
name|Critical_Members
decl_stmt|;
comment|/* bit mask of critical members */
name|HPT_U16
name|reserve2
decl_stmt|;
name|HPT_U32
name|reserve
decl_stmt|;
else|#
directive|else
name|HPT_U32
name|Critical_Members
decl_stmt|;
name|HPT_U32
name|reserve
decl_stmt|;
endif|#
directive|endif
block|}
name|HPT_ARRAY_INFO_V3
operator|,
typedef|*
name|PHPT_ARRAY_INFO_V3
typedef|;
endif|#
directive|endif
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000001
typedef|typedef
struct|struct
name|_HPT_ARRAY_INFO_V4
block|{
name|HPT_U8
name|Name
index|[
name|MAX_ARRAYNAME_LEN
index|]
decl_stmt|;
comment|/* array name */
name|HPT_U8
name|Description
index|[
literal|64
index|]
decl_stmt|;
comment|/* array description */
name|HPT_U8
name|CreateManager
index|[
literal|16
index|]
decl_stmt|;
comment|/* who created it */
name|TIME_RECORD
name|CreateTime
decl_stmt|;
comment|/* when created it */
name|HPT_U8
name|ArrayType
decl_stmt|;
comment|/* array type */
name|HPT_U8
name|BlockSizeShift
decl_stmt|;
comment|/* stripe size */
name|HPT_U8
name|nDisk
decl_stmt|;
comment|/* member count: Number of ID in Members[] */
name|HPT_U8
name|reserved
decl_stmt|;
name|HPT_U32
name|Flags
decl_stmt|;
comment|/* working flags, see ARRAY_FLAG_XXX */
name|HPT_U32
name|RebuildingProgress
decl_stmt|;
name|HPT_U64
name|RebuiltSectors
decl_stmt|;
comment|/* rebuilding point (LBA) for single member */
name|DEVICEID
name|TransformSource
decl_stmt|;
name|DEVICEID
name|TransformTarget
decl_stmt|;
comment|/* destination device ID */
name|HPT_U32
name|TransformingProgress
decl_stmt|;
name|HPT_U32
name|Signature
decl_stmt|;
comment|/* persistent identification*/
name|HPT_U32
name|reserved2
index|[
literal|2
index|]
decl_stmt|;
name|HPT_U64
name|Critical_Members
decl_stmt|;
name|HPT_U32
name|Members
index|[
name|MAX_ARRAY_MEMBERS_V3
index|]
decl_stmt|;
comment|/* member array/disks */
block|}
name|HPT_ARRAY_INFO_V4
operator|,
typedef|*
name|PHPT_ARRAY_INFO_V4
typedef|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|__KERNEL__
comment|/*  * ATA/ATAPI Device identify data without the Reserved4.  */
typedef|typedef
struct|struct
name|_IDENTIFY_DATA2
block|{
name|HPT_U16
name|GeneralConfiguration
decl_stmt|;
name|HPT_U16
name|NumberOfCylinders
decl_stmt|;
name|HPT_U16
name|Reserved1
decl_stmt|;
name|HPT_U16
name|NumberOfHeads
decl_stmt|;
name|HPT_U16
name|UnformattedBytesPerTrack
decl_stmt|;
name|HPT_U16
name|UnformattedBytesPerSector
decl_stmt|;
name|HPT_U16
name|SectorsPerTrack
decl_stmt|;
name|HPT_U16
name|VendorUnique1
index|[
literal|3
index|]
decl_stmt|;
name|HPT_U16
name|SerialNumber
index|[
literal|10
index|]
decl_stmt|;
name|HPT_U16
name|BufferType
decl_stmt|;
name|HPT_U16
name|BufferSectorSize
decl_stmt|;
name|HPT_U16
name|NumberOfEccBytes
decl_stmt|;
name|HPT_U16
name|FirmwareRevision
index|[
literal|4
index|]
decl_stmt|;
name|HPT_U16
name|ModelNumber
index|[
literal|20
index|]
decl_stmt|;
name|HPT_U8
name|MaximumBlockTransfer
decl_stmt|;
name|HPT_U8
name|VendorUnique2
decl_stmt|;
name|HPT_U16
name|DoubleWordIo
decl_stmt|;
name|HPT_U16
name|Capabilities
decl_stmt|;
name|HPT_U16
name|Reserved2
decl_stmt|;
name|HPT_U8
name|VendorUnique3
decl_stmt|;
name|HPT_U8
name|PioCycleTimingMode
decl_stmt|;
name|HPT_U8
name|VendorUnique4
decl_stmt|;
name|HPT_U8
name|DmaCycleTimingMode
decl_stmt|;
name|HPT_U16
name|TranslationFieldsValid
decl_stmt|;
name|HPT_U16
name|NumberOfCurrentCylinders
decl_stmt|;
name|HPT_U16
name|NumberOfCurrentHeads
decl_stmt|;
name|HPT_U16
name|CurrentSectorsPerTrack
decl_stmt|;
name|HPT_U32
name|CurrentSectorCapacity
decl_stmt|;
name|HPT_U16
name|CurrentMultiSectorSetting
decl_stmt|;
name|HPT_U32
name|UserAddressableSectors
decl_stmt|;
name|HPT_U8
name|SingleWordDMASupport
decl_stmt|;
name|HPT_U8
name|SingleWordDMAActive
decl_stmt|;
name|HPT_U8
name|MultiWordDMASupport
decl_stmt|;
name|HPT_U8
name|MultiWordDMAActive
decl_stmt|;
name|HPT_U8
name|AdvancedPIOModes
decl_stmt|;
name|HPT_U8
name|Reserved4
decl_stmt|;
name|HPT_U16
name|MinimumMWXferCycleTime
decl_stmt|;
name|HPT_U16
name|RecommendedMWXferCycleTime
decl_stmt|;
name|HPT_U16
name|MinimumPIOCycleTime
decl_stmt|;
name|HPT_U16
name|MinimumPIOCycleTimeIORDY
decl_stmt|;
name|HPT_U16
name|Reserved5
index|[
literal|2
index|]
decl_stmt|;
name|HPT_U16
name|ReleaseTimeOverlapped
decl_stmt|;
name|HPT_U16
name|ReleaseTimeServiceCommand
decl_stmt|;
name|HPT_U16
name|MajorRevision
decl_stmt|;
name|HPT_U16
name|MinorRevision
decl_stmt|;
block|}
name|IDENTIFY_DATA2
operator|,
typedef|*
name|PIDENTIFY_DATA2
typedef|;
endif|#
directive|endif
comment|/*  * physical device information.  * IdentifyData.ModelNumber[] is HPT_U8-swapped from the original identify data.  */
typedef|typedef
struct|struct
name|_DEVICE_INFO
block|{
name|HPT_U8
name|ControllerId
decl_stmt|;
comment|/* controller id */
name|HPT_U8
name|PathId
decl_stmt|;
comment|/* bus */
name|HPT_U8
name|TargetId
decl_stmt|;
comment|/* id */
name|HPT_U8
name|DeviceModeSetting
decl_stmt|;
comment|/* Current Data Transfer mode: 0-4 PIO 0-4 */
comment|/* 5-7 MW DMA0-2, 8-13 UDMA0-5             */
name|HPT_U8
name|DeviceType
decl_stmt|;
comment|/* device type */
name|HPT_U8
name|UsableMode
decl_stmt|;
comment|/* highest usable mode */
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|HPT_U8
name|NCQEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|NCQSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|TCQEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|TCQSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|WriteCacheEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|WriteCacheSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|ReadAheadEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|ReadAheadSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|reserved6
range|:
literal|6
decl_stmt|;
name|HPT_U8
name|SpinUpMode
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|HPT_U8
name|ReadAheadSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|ReadAheadEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|WriteCacheSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|WriteCacheEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|TCQSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|TCQEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|NCQSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|NCQEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|SpinUpMode
range|:
literal|2
decl_stmt|;
name|HPT_U8
name|reserved6
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
name|HPT_U32
name|Flags
decl_stmt|;
comment|/* working flags, see DEVICE_FLAG_XXX */
name|IDENTIFY_DATA2
name|IdentifyData
decl_stmt|;
comment|/* Identify Data of this device */
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|DEVICE_INFO
operator|,
typedef|*
name|PDEVICE_INFO
typedef|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
define|#
directive|define
name|MAX_PARENTS_PER_DISK
value|8
comment|/*  * physical device information.  * IdentifyData.ModelNumber[] is HPT_U8-swapped from the original identify data.  */
typedef|typedef
struct|struct
name|_DEVICE_INFO_V2
block|{
name|HPT_U8
name|ControllerId
decl_stmt|;
comment|/* controller id */
name|HPT_U8
name|PathId
decl_stmt|;
comment|/* bus */
name|HPT_U8
name|TargetId
decl_stmt|;
comment|/* id */
name|HPT_U8
name|DeviceModeSetting
decl_stmt|;
comment|/* Current Data Transfer mode: 0-4 PIO 0-4 */
comment|/* 5-7 MW DMA0-2, 8-13 UDMA0-5             */
name|HPT_U8
name|DeviceType
decl_stmt|;
comment|/* device type */
name|HPT_U8
name|UsableMode
decl_stmt|;
comment|/* highest usable mode */
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|HPT_U8
name|NCQEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|NCQSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|TCQEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|TCQSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|WriteCacheEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|WriteCacheSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|ReadAheadEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|ReadAheadSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|reserved6
range|:
literal|6
decl_stmt|;
name|HPT_U8
name|SpinUpMode
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|HPT_U8
name|ReadAheadSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|ReadAheadEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|WriteCacheSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|WriteCacheEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|TCQSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|TCQEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|NCQSupported
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|NCQEnabled
range|:
literal|1
decl_stmt|;
name|HPT_U8
name|SpinUpMode
range|:
literal|2
decl_stmt|;
name|HPT_U8
name|reserved6
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
name|HPT_U32
name|Flags
decl_stmt|;
comment|/* working flags, see DEVICE_FLAG_XXX */
name|IDENTIFY_DATA2
name|IdentifyData
decl_stmt|;
comment|/* Identify Data of this device */
name|HPT_U64
name|TotalFree
decl_stmt|;
name|HPT_U64
name|MaxFree
decl_stmt|;
name|HPT_U64
name|BadSectors
decl_stmt|;
name|DEVICEID
name|ParentArrays
index|[
name|MAX_PARENTS_PER_DISK
index|]
decl_stmt|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|DEVICE_INFO_V2
operator|,
typedef|*
name|PDEVICE_INFO_V2
operator|,
name|DEVICE_INFO_V3
operator|,
typedef|*
name|PDEVICE_INFO_V3
typedef|;
comment|/*  * HPT601 information  */
endif|#
directive|endif
comment|/*  * HPT601 information  */
define|#
directive|define
name|HPT601_INFO_DEVICEID
value|1
define|#
directive|define
name|HPT601_INFO_TEMPERATURE
value|2
define|#
directive|define
name|HPT601_INFO_FANSTATUS
value|4
define|#
directive|define
name|HPT601_INFO_BEEPERCONTROL
value|8
define|#
directive|define
name|HPT601_INFO_LED1CONTROL
value|0x10
define|#
directive|define
name|HPT601_INFO_LED2CONTROL
value|0x20
define|#
directive|define
name|HPT601_INFO_POWERSTATUS
value|0x40
typedef|typedef
struct|struct
name|_HPT601_INFO_
block|{
name|HPT_U16
name|ValidFields
decl_stmt|;
comment|/* mark valid fields below */
name|HPT_U16
name|DeviceId
decl_stmt|;
comment|/* 0x5A3E */
name|HPT_U16
name|Temperature
decl_stmt|;
comment|/* Read: temperature sensor value. Write: temperature limit */
name|HPT_U16
name|FanStatus
decl_stmt|;
comment|/* Fan status */
name|HPT_U16
name|BeeperControl
decl_stmt|;
comment|/* bit4: beeper control bit. bit0-3: frequency bits */
name|HPT_U16
name|LED1Control
decl_stmt|;
comment|/* bit4: twinkling control bit. bit0-3: frequency bits */
name|HPT_U16
name|LED2Control
decl_stmt|;
comment|/* bit4: twinkling control bit. bit0-3: frequency bits */
name|HPT_U16
name|PowerStatus
decl_stmt|;
comment|/* 1: has power 2: no power */
block|}
name|HPT601_INFO
operator|,
typedef|*
name|PHPT601_INFO
typedef|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
ifndef|#
directive|ifndef
name|__KERNEL__
comment|/* cache policy for each vdev, copied from ldm.h */
define|#
directive|define
name|CACHE_POLICY_NONE
value|0
define|#
directive|define
name|CACHE_POLICY_WRITE_THROUGH
value|1
define|#
directive|define
name|CACHE_POLICY_WRITE_BACK
value|2
endif|#
directive|endif
endif|#
directive|endif
comment|/*  * Logical device information.  * Union of ArrayInfo and DeviceInfo.  * Common properties will be put in logical device information.  */
typedef|typedef
struct|struct
name|_LOGICAL_DEVICE_INFO
block|{
name|HPT_U8
name|Type
decl_stmt|;
comment|/* LDT_ARRAY or LDT_DEVICE */
name|HPT_U8
name|reserved
index|[
literal|3
index|]
decl_stmt|;
name|HPT_U32
name|Capacity
decl_stmt|;
comment|/* array capacity */
name|DEVICEID
name|ParentArray
decl_stmt|;
union|union
block|{
name|HPT_ARRAY_INFO
name|array
decl_stmt|;
name|DEVICE_INFO
name|device
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
name|u
union|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|LOGICAL_DEVICE_INFO
operator|,
typedef|*
name|PLOGICAL_DEVICE_INFO
typedef|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
typedef|typedef
struct|struct
name|_LOGICAL_DEVICE_INFO_V2
block|{
name|HPT_U8
name|Type
decl_stmt|;
comment|/* LDT_ARRAY or LDT_DEVICE */
name|HPT_U8
name|reserved
index|[
literal|3
index|]
decl_stmt|;
name|HPT_U64
name|Capacity
decl_stmt|;
comment|/* array capacity */
name|DEVICEID
name|ParentArray
decl_stmt|;
comment|/* for physical device, Please don't use this field. 										 * use ParentArrays field in DEVICE_INFO_V2 										 */
union|union
block|{
name|HPT_ARRAY_INFO_V2
name|array
decl_stmt|;
name|DEVICE_INFO
name|device
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
name|u
union|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|LOGICAL_DEVICE_INFO_V2
operator|,
typedef|*
name|PLOGICAL_DEVICE_INFO_V2
typedef|;
endif|#
directive|endif
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
define|#
directive|define
name|INVALID_TARGET_ID
value|0xFF
define|#
directive|define
name|INVALID_BUS_ID
value|0xFF
typedef|typedef
struct|struct
name|_LOGICAL_DEVICE_INFO_V3
block|{
name|HPT_U8
name|Type
decl_stmt|;
comment|/* LDT_ARRAY or LDT_DEVICE */
name|HPT_U8
name|CachePolicy
decl_stmt|;
comment|/* refer to CACHE_POLICY_xxx */
name|HPT_U8
name|VBusId
decl_stmt|;
comment|/* vbus sequence in vbus_list */
name|HPT_U8
name|TargetId
decl_stmt|;
comment|/* OS target id. Value 0xFF is invalid */
comment|/* OS disk name: HPT DISK $VBusId_$TargetId */
name|HPT_U64
name|Capacity
decl_stmt|;
comment|/* array capacity */
name|DEVICEID
name|ParentArray
decl_stmt|;
comment|/* for physical device, don't use this field. 										 * use ParentArrays field in DEVICE_INFO_V2 instead. 										 */
name|HPT_U32
name|TotalIOs
decl_stmt|;
name|HPT_U32
name|TobalMBs
decl_stmt|;
name|HPT_U32
name|IOPerSec
decl_stmt|;
name|HPT_U32
name|MBPerSec
decl_stmt|;
union|union
block|{
name|HPT_ARRAY_INFO_V3
name|array
decl_stmt|;
name|DEVICE_INFO_V2
name|device
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
name|u
union|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|LOGICAL_DEVICE_INFO_V3
operator|,
typedef|*
name|PLOGICAL_DEVICE_INFO_V3
typedef|;
endif|#
directive|endif
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000001
typedef|typedef
struct|struct
name|_LOGICAL_DEVICE_INFO_V4
block|{
name|HPT_U32
name|dwSize
decl_stmt|;
name|HPT_U8
name|revision
decl_stmt|;
name|HPT_U8
name|reserved
index|[
literal|7
index|]
decl_stmt|;
name|HPT_U8
name|Type
decl_stmt|;
comment|/* LDT_ARRAY or LDT_DEVICE */
name|HPT_U8
name|CachePolicy
decl_stmt|;
comment|/* refer to CACHE_POLICY_xxx */
name|HPT_U8
name|VBusId
decl_stmt|;
comment|/* vbus sequence in vbus_list */
name|HPT_U8
name|TargetId
decl_stmt|;
comment|/* OS target id. Value 0xFF is invalid */
comment|/* OS disk name: HPT DISK $VBusId_$TargetId */
name|HPT_U64
name|Capacity
decl_stmt|;
comment|/* array capacity */
name|DEVICEID
name|ParentArray
decl_stmt|;
comment|/* for physical device, don't use this field. 										 * use ParentArrays field in DEVICE_INFO_V2 instead. 										 */
name|HPT_U32
name|TotalIOs
decl_stmt|;
name|HPT_U32
name|TobalMBs
decl_stmt|;
name|HPT_U32
name|IOPerSec
decl_stmt|;
name|HPT_U32
name|MBPerSec
decl_stmt|;
union|union
block|{
name|HPT_ARRAY_INFO_V4
name|array
decl_stmt|;
name|DEVICE_INFO_V3
name|device
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
name|u
union|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|LOGICAL_DEVICE_INFO_V4
operator|,
typedef|*
name|PLOGICAL_DEVICE_INFO_V4
typedef|;
comment|/*LOGICAL_DEVICE_INFO_V4 max revision number*/
define|#
directive|define
name|LOGICAL_DEVICE_INFO_V4_REVISION
value|0
comment|/*If new revision was defined please check evey revision size*/
define|#
directive|define
name|LOGICAL_DEVICE_INFO_V4_R0_SIZE
value|(sizeof(LOGICAL_DEVICE_INFO_V4))
endif|#
directive|endif
comment|/*  * ALTERABLE_ARRAY_INFO and ALTERABLE_DEVICE_INFO, used in set_array_info()  * and set_device_info().  * When set_xxx_info() is called, the ValidFields member indicates which  * fields in the structure are valid.  */
comment|/* field masks */
define|#
directive|define
name|AAIF_NAME
value|1
define|#
directive|define
name|AAIF_DESCRIPTION
value|2
define|#
directive|define
name|ADIF_MODE
value|1
define|#
directive|define
name|ADIF_TCQ
value|2
define|#
directive|define
name|ADIF_NCQ
value|4
define|#
directive|define
name|ADIF_WRITE_CACHE
value|8
define|#
directive|define
name|ADIF_READ_AHEAD
value|0x10
define|#
directive|define
name|ADIF_SPIN_UP_MODE
value|0x20
typedef|typedef
struct|struct
name|_ALTERABLE_ARRAY_INFO
block|{
name|HPT_U32
name|ValidFields
decl_stmt|;
comment|/* mark valid fields below */
name|HPT_U8
name|Name
index|[
name|MAX_ARRAYNAME_LEN
index|]
decl_stmt|;
comment|/* array name */
name|HPT_U8
name|Description
index|[
literal|64
index|]
decl_stmt|;
comment|/* array description */
block|}
name|ALTERABLE_ARRAY_INFO
operator|,
typedef|*
name|PALTERABLE_ARRAY_INFO
typedef|;
typedef|typedef
struct|struct
name|_ALTERABLE_DEVICE_INFO
block|{
name|HPT_U32
name|ValidFields
decl_stmt|;
comment|/* mark valid fields below */
name|HPT_U8
name|DeviceModeSetting
decl_stmt|;
comment|/* 0-4 PIO 0-4, 5-7 MW DMA0-2, 8-13 UDMA0-5 */
block|}
name|ALTERABLE_DEVICE_INFO
operator|,
typedef|*
name|PALTERABLE_DEVICE_INFO
typedef|;
typedef|typedef
struct|struct
name|_ALTERABLE_DEVICE_INFO_V2
block|{
name|HPT_U32
name|ValidFields
decl_stmt|;
comment|/* mark valid fields below */
name|HPT_U8
name|DeviceModeSetting
decl_stmt|;
comment|/* 0-4 PIO 0-4, 5-7 MW DMA0-2, 8-13 UDMA0-5 */
name|HPT_U8
name|TCQEnabled
decl_stmt|;
name|HPT_U8
name|NCQEnabled
decl_stmt|;
name|HPT_U8
name|WriteCacheEnabled
decl_stmt|;
name|HPT_U8
name|ReadAheadEnabled
decl_stmt|;
name|HPT_U8
name|SpinUpMode
decl_stmt|;
name|HPT_U8
name|reserve
index|[
literal|2
index|]
decl_stmt|;
name|HPT_U32
name|reserve2
index|[
literal|13
index|]
decl_stmt|;
comment|/* pad to 64 bytes */
block|}
name|ALTERABLE_DEVICE_INFO_V2
operator|,
typedef|*
name|PALTERABLE_DEVICE_INFO_V2
typedef|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
define|#
directive|define
name|TARGET_TYPE_DEVICE
value|0
define|#
directive|define
name|TARGET_TYPE_ARRAY
value|1
define|#
directive|define
name|AIT_NAME
value|0
define|#
directive|define
name|AIT_DESCRIPTION
value|1
define|#
directive|define
name|AIT_CACHE_POLICY
value|2
define|#
directive|define
name|DIT_MODE
value|0
define|#
directive|define
name|DIT_READ_AHEAD
value|1
define|#
directive|define
name|DIT_WRITE_CACHE
value|2
define|#
directive|define
name|DIT_TCQ
value|3
define|#
directive|define
name|DIT_NCQ
value|4
comment|/* param type is determined by target_type and info_type*/
typedef|typedef
struct|struct
name|_SET_DEV_INFO
block|{
name|HPT_U8
name|target_type
decl_stmt|;
name|HPT_U8
name|infor_type
decl_stmt|;
name|HPT_U16
name|param_length
decl_stmt|;
define|#
directive|define
name|SET_VDEV_INFO_param
parameter_list|(
name|p
parameter_list|)
value|((HPT_U8 *)(p)+sizeof(SET_VDEV_INFO))
comment|/* HPT_U8 param[0]; */
block|}
name|SET_VDEV_INFO
operator|,
typedef|*
name|PSET_VDEV_INFO
typedef|;
typedef|typedef
name|HPT_U8
name|PARAM_ARRAY_NAME
index|[
name|MAX_ARRAYNAME_LEN
index|]
typedef|;
typedef|typedef
name|HPT_U8
name|PARAM_ARRAY_DES
index|[
literal|64
index|]
typedef|;
typedef|typedef
name|HPT_U8
name|PARAM_DEVICE_MODE
typedef|,
name|PARAM_TCQ
typedef|,
name|PARAM_NCQ
typedef|,
name|PARAM_READ_AHEAD
typedef|,
name|PARAM_WRITE_CACHE
typedef|,
name|PARAM_CACHE_POLICY
typedef|;
endif|#
directive|endif
comment|/*  * CREATE_ARRAY_PARAMS  *  Param structure used to create an array.  */
typedef|typedef
struct|struct
name|_CREATE_ARRAY_PARAMS
block|{
name|HPT_U8
name|ArrayType
decl_stmt|;
comment|/* 1-level array type */
name|HPT_U8
name|nDisk
decl_stmt|;
comment|/* number of elements in Members[] array */
name|HPT_U8
name|BlockSizeShift
decl_stmt|;
comment|/* Stripe size if ArrayType==AT_RAID0 / AT_RAID5 */
name|HPT_U8
name|CreateFlags
decl_stmt|;
comment|/* See CAF_xxx */
name|HPT_U8
name|ArrayName
index|[
name|MAX_ARRAYNAME_LEN
index|]
decl_stmt|;
comment|/* Array name */
name|HPT_U8
name|Description
index|[
literal|64
index|]
decl_stmt|;
comment|/* array description */
name|HPT_U8
name|CreateManager
index|[
literal|16
index|]
decl_stmt|;
comment|/* who created it */
name|TIME_RECORD
name|CreateTime
decl_stmt|;
comment|/* when created it */
name|HPT_U32
name|Members
index|[
name|MAX_ARRAY_MEMBERS_V1
index|]
decl_stmt|;
comment|/* ID of array members, a member can be an array */
block|}
name|CREATE_ARRAY_PARAMS
operator|,
typedef|*
name|PCREATE_ARRAY_PARAMS
typedef|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
typedef|typedef
struct|struct
name|_CREATE_ARRAY_PARAMS_V2
block|{
name|HPT_U8
name|ArrayType
decl_stmt|;
comment|/* 1-level array type */
name|HPT_U8
name|nDisk
decl_stmt|;
comment|/* number of elements in Members[] array */
name|HPT_U8
name|BlockSizeShift
decl_stmt|;
comment|/* Stripe size if ArrayType==AT_RAID0 / AT_RAID5 */
name|HPT_U8
name|CreateFlags
decl_stmt|;
comment|/* See CAF_xxx */
name|HPT_U8
name|ArrayName
index|[
name|MAX_ARRAYNAME_LEN
index|]
decl_stmt|;
comment|/* Array name */
name|HPT_U8
name|Description
index|[
literal|64
index|]
decl_stmt|;
comment|/* array description */
name|HPT_U8
name|CreateManager
index|[
literal|16
index|]
decl_stmt|;
comment|/* who created it */
name|TIME_RECORD
name|CreateTime
decl_stmt|;
comment|/* when created it */
name|HPT_U64
name|Capacity
decl_stmt|;
name|HPT_U32
name|Members
index|[
name|MAX_ARRAY_MEMBERS_V2
index|]
decl_stmt|;
comment|/* ID of array members, a member can be an array */
block|}
name|CREATE_ARRAY_PARAMS_V2
operator|,
typedef|*
name|PCREATE_ARRAY_PARAMS_V2
typedef|;
endif|#
directive|endif
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000001
typedef|typedef
struct|struct
name|_CREATE_ARRAY_PARAMS_V3
block|{
name|HPT_U32
name|dwSize
decl_stmt|;
name|HPT_U8
name|revision
decl_stmt|;
comment|/*CREATE_ARRAY_PARAMS_V3_REVISION*/
name|HPT_U8
name|reserved
index|[
literal|7
index|]
decl_stmt|;
name|HPT_U8
name|ArrayType
decl_stmt|;
comment|/* 1-level array type */
name|HPT_U8
name|nDisk
decl_stmt|;
comment|/* number of elements in Members[] array */
name|HPT_U8
name|BlockSizeShift
decl_stmt|;
comment|/* Stripe size if ArrayType==AT_RAID0 / AT_RAID5 */
name|HPT_U8
name|CreateFlags
decl_stmt|;
comment|/* See CAF_xxx */
name|HPT_U8
name|ArrayName
index|[
name|MAX_ARRAYNAME_LEN
index|]
decl_stmt|;
comment|/* Array name */
name|HPT_U8
name|Description
index|[
literal|64
index|]
decl_stmt|;
comment|/* array description */
name|HPT_U8
name|CreateManager
index|[
literal|16
index|]
decl_stmt|;
comment|/* who created it */
name|TIME_RECORD
name|CreateTime
decl_stmt|;
comment|/* when created it */
name|HPT_U64
name|Capacity
decl_stmt|;
name|HPT_U32
name|Members
index|[
name|MAX_ARRAY_MEMBERS_V3
index|]
decl_stmt|;
comment|/* ID of array members, a member can be an array */
block|}
name|CREATE_ARRAY_PARAMS_V3
operator|,
typedef|*
name|PCREATE_ARRAY_PARAMS_V3
typedef|;
comment|/*CREATE_ARRAY_PARAMS_V3 current max revision*/
define|#
directive|define
name|CREATE_ARRAY_PARAMS_V3_REVISION
value|0
comment|/*If new revision defined please check evey revision size*/
define|#
directive|define
name|CREATE_ARRAY_PARAMS_V3_R0_SIZE
value|(sizeof(CREATE_ARRAY_PARAMS_V3))
endif|#
directive|endif
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|<
literal|0x01020000
comment|/*  * Flags used for creating an RAID 1 array  *  * CAF_CREATE_AND_DUPLICATE  *    Copy source disk contents to target for RAID 1. If user choose "create and duplicate"  *    to create an array, GUI will call CreateArray() with this flag set. Then GUI should  *    call hpt_get_device_info() with the returned array ID and check returned flags to  *    see if ARRAY_FLAG_REBUILDING is set. If not set, driver does not support rebuilding  *    and GUI must do duplication itself.  * CAF_DUPLICATE_MUST_DONE  *    If the duplication is aborted or fails, do not create the array.  */
define|#
directive|define
name|CAF_CREATE_AND_DUPLICATE
value|1
define|#
directive|define
name|CAF_DUPLICATE_MUST_DONE
value|2
define|#
directive|define
name|CAF_CREATE_AS_RAID15
value|4
comment|/*  * Flags used for creating an RAID 5 array  */
define|#
directive|define
name|CAF_CREATE_R5_NO_BUILD
value|1
define|#
directive|define
name|CAF_CREATE_R5_ZERO_INIT
value|2
define|#
directive|define
name|CAF_CREATE_R5_BUILD_PARITY
value|4
else|#
directive|else
comment|/*  * Flags used for creating  */
define|#
directive|define
name|CAF_FOREGROUND_INITIALIZE
value|1
define|#
directive|define
name|CAF_BACKGROUND_INITIALIZE
value|2
define|#
directive|define
name|CAF_CREATE_R5_WRITE_BACK
value|(CACHE_POLICY_WRITE_BACK<<CAF_CACHE_POLICY_SHIFT)
define|#
directive|define
name|CAF_CACHE_POLICY_MASK
value|0x1C
define|#
directive|define
name|CAF_CACHE_POLICY_SHIFT
value|2
endif|#
directive|endif
define|#
directive|define
name|CAF_KEEP_DATA_ALWAYS
value|0x80
comment|/* Flags used for deleting an array  *  * DAF_KEEP_DATA_IF_POSSIBLE  *    If this flag is set, deleting a RAID 1 array will not destroy the data on both disks.  *    Deleting a JBOD should keep partitions on first disk ( not implement now ).  *    Deleting a RAID 0/1 should result as two RAID 0 array ( not implement now ).  */
define|#
directive|define
name|DAF_KEEP_DATA_IF_POSSIBLE
value|1
define|#
directive|define
name|DAF_KEEP_DATA_ALWAYS
value|2
comment|/*  * event types  */
define|#
directive|define
name|ET_DEVICE_REMOVED
value|1
comment|/* device removed */
define|#
directive|define
name|ET_DEVICE_PLUGGED
value|2
comment|/* device plugged */
define|#
directive|define
name|ET_DEVICE_ERROR
value|3
comment|/* device I/O error */
define|#
directive|define
name|ET_REBUILD_STARTED
value|4
define|#
directive|define
name|ET_REBUILD_ABORTED
value|5
define|#
directive|define
name|ET_REBUILD_FINISHED
value|6
define|#
directive|define
name|ET_SPARE_TOOK_OVER
value|7
define|#
directive|define
name|ET_REBUILD_FAILED
value|8
define|#
directive|define
name|ET_VERIFY_STARTED
value|9
define|#
directive|define
name|ET_VERIFY_ABORTED
value|10
define|#
directive|define
name|ET_VERIFY_FAILED
value|11
define|#
directive|define
name|ET_VERIFY_FINISHED
value|12
define|#
directive|define
name|ET_INITIALIZE_STARTED
value|13
define|#
directive|define
name|ET_INITIALIZE_ABORTED
value|14
define|#
directive|define
name|ET_INITIALIZE_FAILED
value|15
define|#
directive|define
name|ET_INITIALIZE_FINISHED
value|16
define|#
directive|define
name|ET_VERIFY_DATA_ERROR
value|17
define|#
directive|define
name|ET_TRANSFORM_STARTED
value|18
define|#
directive|define
name|ET_TRANSFORM_ABORTED
value|19
define|#
directive|define
name|ET_TRANSFORM_FAILED
value|20
define|#
directive|define
name|ET_TRANSFORM_FINISHED
value|21
define|#
directive|define
name|ET_SMART_FAILED
value|22
define|#
directive|define
name|ET_SMART_PASSED
value|23
define|#
directive|define
name|ET_SECTOR_REPAIR_FAIL
value|24
define|#
directive|define
name|ET_SECTOR_REPAIR_SUCCESS
value|25
comment|/*  * event structure  */
typedef|typedef
struct|struct
name|_HPT_EVENT
block|{
name|TIME_RECORD
name|Time
decl_stmt|;
name|DEVICEID
name|DeviceID
decl_stmt|;
name|HPT_U8
name|EventType
decl_stmt|;
name|HPT_U8
name|reserved
index|[
literal|3
index|]
decl_stmt|;
name|HPT_U8
name|Data
index|[
literal|32
index|]
decl_stmt|;
comment|/* various data depend on EventType */
block|}
name|HPT_EVENT
operator|,
typedef|*
name|PHPT_EVENT
typedef|;
comment|/*  * IDE pass-through command. Use it at your own risk!  */
ifdef|#
directive|ifdef
name|_MSC_VER
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4200
name|)
endif|#
directive|endif
typedef|typedef
struct|struct
name|_IDE_PASS_THROUGH_HEADER
block|{
name|DEVICEID
name|idDisk
decl_stmt|;
comment|/* disk ID */
name|HPT_U8
name|bFeaturesReg
decl_stmt|;
comment|/* feature register */
name|HPT_U8
name|bSectorCountReg
decl_stmt|;
comment|/* IDE sector count register. */
name|HPT_U8
name|bLbaLowReg
decl_stmt|;
comment|/* IDE LBA low value. */
name|HPT_U8
name|bLbaMidReg
decl_stmt|;
comment|/* IDE LBA mid register. */
name|HPT_U8
name|bLbaHighReg
decl_stmt|;
comment|/* IDE LBA high value. */
name|HPT_U8
name|bDriveHeadReg
decl_stmt|;
comment|/* IDE drive/head register. */
name|HPT_U8
name|bCommandReg
decl_stmt|;
comment|/* Actual IDE command. Checked for validity by driver. */
name|HPT_U8
name|nSectors
decl_stmt|;
comment|/* data size in sectors, if the command has data transfer */
name|HPT_U8
name|protocol
decl_stmt|;
comment|/* IO_COMMAND_(READ,WRITE) or zero for non-DATA */
name|HPT_U8
name|reserve
index|[
literal|3
index|]
decl_stmt|;
define|#
directive|define
name|IDE_PASS_THROUGH_buffer
parameter_list|(
name|p
parameter_list|)
value|((HPT_U8 *)(p) + sizeof(IDE_PASS_THROUGH_HEADER))
comment|/* HPT_U8     DataBuffer[0]; */
block|}
name|IDE_PASS_THROUGH_HEADER
operator|,
typedef|*
name|PIDE_PASS_THROUGH_HEADER
typedef|;
comment|/*  * device io packet format  */
typedef|typedef
struct|struct
name|_DEVICE_IO_EX_PARAMS
block|{
name|DEVICEID
name|idDisk
decl_stmt|;
name|HPT_U32
name|Lba
decl_stmt|;
name|HPT_U16
name|nSectors
decl_stmt|;
name|HPT_U8
name|Command
decl_stmt|;
comment|/* IO_COMMAD_xxx */
name|HPT_U8
name|BufferType
decl_stmt|;
comment|/* BUFFER_TYPE_xxx, see below */
name|HPT_U32
name|BufferPtr
decl_stmt|;
block|}
name|DEVICE_IO_EX_PARAMS
operator|,
typedef|*
name|PDEVICE_IO_EX_PARAMS
typedef|;
define|#
directive|define
name|BUFFER_TYPE_LOGICAL
value|1
comment|/* logical pointer to buffer */
define|#
directive|define
name|BUFFER_TYPE_PHYSICAL
value|2
comment|/* physical address of buffer */
define|#
directive|define
name|BUFFER_TYPE_LOGICAL_LOGICAL_SG
value|3
comment|/* logical pointer to logical S/G table */
define|#
directive|define
name|BUFFER_TYPE_LOGICAL_PHYSICAL_SG
value|4
comment|/* logical pointer to physical S/G table */
define|#
directive|define
name|BUFFER_TYPE_PHYSICAL_LOGICAL_SG
value|5
comment|/* physical address to logical S/G table */
define|#
directive|define
name|BUFFER_TYPE_PHYSICAL_PHYSICAL_SG
value|6
comment|/* physical address of physical S/G table */
define|#
directive|define
name|BUFFER_TYPE_PHYSICAL_PHYSICAL_SG_PIO
value|7
comment|/* non DMA capable physical address of physical S/G table */
typedef|typedef
struct|struct
name|_HPT_DRIVER_PARAMETER
block|{
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|HPT_U8
name|value
index|[
literal|32
index|]
decl_stmt|;
name|HPT_U8
name|type
decl_stmt|;
comment|/* HPT_DRIVER_PARAMETER_TYPE_* */
name|HPT_U8
name|persistent
decl_stmt|;
name|HPT_U8
name|reserve2
index|[
literal|2
index|]
decl_stmt|;
name|HPT_U8
name|location
decl_stmt|;
comment|/* 0 - system */
name|HPT_U8
name|controller
decl_stmt|;
name|HPT_U8
name|bus
decl_stmt|;
name|HPT_U8
name|reserve1
decl_stmt|;
name|char
name|desc
index|[
literal|128
index|]
decl_stmt|;
block|}
name|HPT_DRIVER_PARAMETER
operator|,
typedef|*
name|PHPT_DRIVER_PARAMETER
typedef|;
define|#
directive|define
name|HPT_DRIVER_PARAMETER_TYPE_INT
value|1
define|#
directive|define
name|HPT_DRIVER_PARAMETER_TYPE_BOOL
value|2
comment|/*  * ioctl structure  */
define|#
directive|define
name|HPT_IOCTL_MAGIC32
value|0x1A2B3C4D
define|#
directive|define
name|HPT_IOCTL_MAGIC
value|0xA1B2C3D4
typedef|typedef
struct|struct
name|_HPT_IOCTL_PARAM
block|{
name|HPT_U32
name|Magic
decl_stmt|;
comment|/* used to check if it's a valid ioctl packet */
name|HPT_U32
name|dwIoControlCode
decl_stmt|;
comment|/* operation control code */
name|HPT_PTR
name|lpInBuffer
decl_stmt|;
comment|/* input data buffer */
name|HPT_U32
name|nInBufferSize
decl_stmt|;
comment|/* size of input data buffer */
name|HPT_PTR
name|lpOutBuffer
decl_stmt|;
comment|/* output data buffer */
name|HPT_U32
name|nOutBufferSize
decl_stmt|;
comment|/* size of output data buffer */
name|HPT_PTR
name|lpBytesReturned
decl_stmt|;
comment|/* count of HPT_U8s returned */
block|}
name|HPT_IOCTL_PARAM
operator|,
typedef|*
name|PHPT_IOCTL_PARAM
typedef|;
comment|/* for 32-bit app running on 64-bit system */
typedef|typedef
struct|struct
name|_HPT_IOCTL_PARAM32
block|{
name|HPT_U32
name|Magic
decl_stmt|;
name|HPT_U32
name|dwIoControlCode
decl_stmt|;
name|HPT_U32
name|lpInBuffer
decl_stmt|;
name|HPT_U32
name|nInBufferSize
decl_stmt|;
name|HPT_U32
name|lpOutBuffer
decl_stmt|;
name|HPT_U32
name|nOutBufferSize
decl_stmt|;
name|HPT_U32
name|lpBytesReturned
decl_stmt|;
block|}
name|HPT_IOCTL_PARAM32
operator|,
typedef|*
name|PHPT_IOCTL_PARAM32
typedef|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
operator|||
name|defined
argument_list|(
name|SIMULATE
argument_list|)
comment|/*  * User-mode ioctl parameter passing conventions:  *   The ioctl function implementation is platform specific, so we don't  * have forced rules for it. However, it's suggested to use a parameter  * passing method as below  *   1) Put all input data continuously in an input buffer.  *   2) Prepare an output buffer with enough size if needed.  *   3) Fill a HPT_IOCTL_PARAM structure.  *   4) Pass the structure to driver through a platform-specific method.  * This is implemented in the mid-layer user-mode library. The UI  * programmer needn't care about it.  */
comment|/************************************************************************  * User mode functions  ************************************************************************/
comment|/*  * hpt_get_version  * Version compatibility: all versions  * Parameters:  *  None  * Returns:  *  interface version. 0 when fail.  */
name|HPT_U32
name|hpt_get_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * hpt_get_driver_capabilities  * Version compatibility: v1.0.0.2 or later  * Parameters:  *  Pointer to receive a DRIVE_CAPABILITIES structure. The caller must set  *  dwSize member to sizeof(DRIVER_CAPABILITIES). The callee must check this  *  member to see if it's correct.  * Returns:  *  0 - Success  */
name|int
name|hpt_get_driver_capabilities
parameter_list|(
name|PDRIVER_CAPABILITIES
name|cap
parameter_list|)
function_decl|;
name|int
name|hpt_get_driver_capabilities_v2
parameter_list|(
name|PDRIVER_CAPABILITIES_V2
name|cap
parameter_list|)
function_decl|;
comment|/*  * hpt_get_controller_count  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  None  * Returns:  *  number of controllers  */
name|int
name|hpt_get_controller_count
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* hpt_get_controller_info  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  id      Controller id  *  pInfo   pointer to CONTROLLER_INFO buffer  * Returns:  *  0       Success, controller info is put into (*pInfo ).  */
name|int
name|hpt_get_controller_info
parameter_list|(
name|int
name|id
parameter_list|,
name|PCONTROLLER_INFO
name|pInfo
parameter_list|)
function_decl|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
comment|/* hpt_get_controller_info_v2  * Version compatibility: v2.0.0.0 or later  * Parameters:  *  id      Controller id  *  pInfo   pointer to CONTROLLER_INFO_V2 buffer  * Returns:  *  0       Success, controller info is put into (*pInfo ).  */
name|int
name|hpt_get_controller_info_v2
parameter_list|(
name|int
name|id
parameter_list|,
name|PCONTROLLER_INFO_V2
name|pInfo
parameter_list|)
function_decl|;
comment|/* hpt_get_controller_info_v3  * Version compatibility: v2.0.0.0 or later  * Parameters:  *  id      Controller id  *  pInfo   pointer to CONTROLLER_INFO_V3 buffer  * Returns:  *  0       Success, controller info is put into (*pInfo ).  */
name|int
name|hpt_get_controller_info_v3
parameter_list|(
name|int
name|id
parameter_list|,
name|PCONTROLLER_INFO_V3
name|pInfo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_get_channel_info  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  id      Controller id  *  bus     bus number  *  pInfo   pointer to CHANNEL_INFO buffer  * Returns:  *  0       Success, channel info is put into (*pInfo ).  */
name|int
name|hpt_get_channel_info
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|bus
parameter_list|,
name|PCHANNEL_INFO
name|pInfo
parameter_list|)
function_decl|;
comment|/* hpt_get_channel_info_v2  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  id      Controller id  *  bus     bus number  *  pInfo   pointer to CHANNEL_INFO buffer  * Returns:  *  0       Success, channel info is put into (*pInfo ).  */
name|int
name|hpt_get_channel_info_v2
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|bus
parameter_list|,
name|PCHANNEL_INFO_V2
name|pInfo
parameter_list|)
function_decl|;
comment|/* hpt_get_logical_devices  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  pIds        pointer to a DEVICEID array  *  nMaxCount   array size  * Returns:  *  Number of ID returned. All logical device IDs are put into pIds array.  *  Note: A spare disk is not a logical device.  */
name|int
name|hpt_get_logical_devices
parameter_list|(
name|DEVICEID
modifier|*
name|pIds
parameter_list|,
name|int
name|nMaxCount
parameter_list|)
function_decl|;
comment|/* hpt_get_device_info  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  id      logical device id  *  pInfo   pointer to LOGICAL_DEVICE_INFO structure  * Returns:  *  0 - Success  */
name|int
name|hpt_get_device_info
parameter_list|(
name|DEVICEID
name|id
parameter_list|,
name|PLOGICAL_DEVICE_INFO
name|pInfo
parameter_list|)
function_decl|;
comment|/* hpt_create_array  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  pParam      pointer to CREATE_ARRAY_PARAMS structure  * Returns:  *  0   failed  *  else return array id  */
name|DEVICEID
name|hpt_create_array
parameter_list|(
name|PCREATE_ARRAY_PARAMS
name|pParam
parameter_list|)
function_decl|;
comment|/* hpt_delete_array  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  id      array id  * Returns:  *  0   Success  */
name|int
name|hpt_delete_array
parameter_list|(
name|DEVICEID
name|id
parameter_list|,
name|HPT_U32
name|options
parameter_list|)
function_decl|;
comment|/* hpt_device_io  *  Read/write data on array and physcal device.  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  id      device id. If it's an array ID, IO will be performed on the array.  *          If it's a physical device ID, IO will be performed on the device.  *  cmd     IO_COMMAND_READ or IO_COMMAND_WRITE  *  buffer  data buffer  *  length  data size  * Returns:  *  0   Success  */
name|int
name|hpt_device_io
parameter_list|(
name|DEVICEID
name|id
parameter_list|,
name|int
name|cmd
parameter_list|,
name|HPT_U32
name|lba
parameter_list|,
name|HPT_U32
name|nSector
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
function_decl|;
comment|/* hpt_add_disk_to_array  *   Used to dynamicly add a disk to an RAID1, RAID0/1, RAID1/0 or RAID5 array.  *   Auto-rebuild will start.  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  idArray     array id  *  idDisk      disk id  * Returns:  *  0   Success  */
name|int
name|hpt_add_disk_to_array
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|DEVICEID
name|idDisk
parameter_list|)
function_decl|;
comment|/* hpt_add_spare_disk  * Version compatibility: v1.0.0.1 or later  *   Add a disk to spare pool.  * Parameters:  *  idDisk      disk id  * Returns:  *  0   Success  */
name|int
name|hpt_add_spare_disk
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|)
function_decl|;
comment|/* hpt_add_dedicated_spare  * Version compatibility: v1.0.0.3 or later  *   Add a spare disk to an array  * Parameters:  *  idDisk      disk id  *  idArray     array id  * Returns:  *  0   Success  */
name|int
name|hpt_add_dedicated_spare
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|,
name|DEVICEID
name|idArray
parameter_list|)
function_decl|;
comment|/* hpt_remove_spare_disk  *   remove a disk from spare pool.  * Version compatibility: v1.0.0.1 or later  * Parameters:  *  idDisk      disk id  * Returns:  *  0   Success  */
name|int
name|hpt_remove_spare_disk
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|)
function_decl|;
comment|/* hpt_get_event  *   Used to poll events from driver.  * Version compatibility: v1.0.0.1 or later  * Parameters:  *   pEvent    pointer to HPT_EVENT structure  * Returns:  *  0   Success, event info is filled in *pEvent  */
name|int
name|hpt_get_event
parameter_list|(
name|PHPT_EVENT
name|pEvent
parameter_list|)
function_decl|;
comment|/* hpt_rebuild_data_block  *   Used to copy data from source disk and mirror disk.  * Version compatibility: v1.0.0.1 or later  * Parameters:  *   idArray        Array ID (RAID1, 0/1 or RAID5)  *   Lba            Start LBA for each array member  *   nSector        Number of sectors for each array member (RAID 5 will ignore this parameter)  *  * Returns:  *  0   Success, event info is filled in *pEvent  */
name|int
name|hpt_rebuild_data_block
parameter_list|(
name|DEVICEID
name|idMirror
parameter_list|,
name|HPT_U32
name|Lba
parameter_list|,
name|HPT_U8
name|nSector
parameter_list|)
function_decl|;
define|#
directive|define
name|hpt_rebuild_mirror
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|)
value|hpt_rebuild_data_block(p1, p2, p3)
comment|/* hpt_set_array_state  *   set array state.  * Version compatibility: v1.0.0.1 or later  * Parameters:  *   idArray        Array ID  *   state          See above 'array states' constants, possible values are:  *     MIRROR_REBUILD_START  *        Indicate that GUI wants to rebuild a mirror array  *     MIRROR_REBUILD_ABORT  *        GUI wants to abort rebuilding an array  *     MIRROR_REBUILD_COMPLETE  *        GUI finished to rebuild an array. If rebuild is done by driver this  *        state has no use  *  * Returns:  *  0   Success  */
name|int
name|hpt_set_array_state
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|HPT_U32
name|state
parameter_list|)
function_decl|;
comment|/* hpt_set_array_info  *   set array info.  * Version compatibility: v1.0.0.1 or later  * Parameters:  *   idArray        Array ID  *   pInfo          pointer to new info  *  * Returns:  *  0   Success  */
name|int
name|hpt_set_array_info
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|PALTERABLE_ARRAY_INFO
name|pInfo
parameter_list|)
function_decl|;
comment|/* hpt_set_device_info  *   set device info.  * Version compatibility: v1.0.0.1 or later  * Parameters:  *   idDisk         device ID  *   pInfo          pointer to new info  *  * Returns:  *  0   Success  * Additional notes:  *  If idDisk==0, call to this function will stop buzzer on the adapter  *  (if supported by driver).  */
name|int
name|hpt_set_device_info
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|,
name|PALTERABLE_DEVICE_INFO
name|pInfo
parameter_list|)
function_decl|;
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01000004
name|int
name|hpt_set_device_info_v2
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|,
name|PALTERABLE_DEVICE_INFO_V2
name|pInfo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_rescan_devices  *   rescan devices  * Version compatibility: v1.0.0.1 or later  * Parameters:  *   None  * Returns:  *   0  Success  */
name|int
name|hpt_rescan_devices
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* hpt_get_601_info  *   Get HPT601 status  * Version compatibiilty: v1.0.0.3 or later  * Parameters:  *   idDisk - Disk handle  *   PHPT601_INFO - pointer to HPT601 info buffer  * Returns:  *   0  Success  */
name|int
name|hpt_get_601_info
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|,
name|PHPT601_INFO
name|pInfo
parameter_list|)
function_decl|;
comment|/* hpt_set_601_info  *   HPT601 function control  * Version compatibiilty: v1.0.0.3 or later  * Parameters:  *   idDisk - Disk handle  *   PHPT601_INFO - pointer to HPT601 info buffer  * Returns:  *   0  Success  */
name|int
name|hpt_set_601_info
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|,
name|PHPT601_INFO
name|pInfo
parameter_list|)
function_decl|;
comment|/* hpt_lock_device  *   Lock a block on a device (prevent OS accessing it)  * Version compatibiilty: v1.0.0.3 or later  * Parameters:  *   idDisk - Disk handle  *   Lba - Start LBA  *   nSectors - number of sectors  * Returns:  *   0  Success  */
name|int
name|hpt_lock_device
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|,
name|HPT_U32
name|Lba
parameter_list|,
name|HPT_U8
name|nSectors
parameter_list|)
function_decl|;
comment|/* hpt_lock_device  *   Unlock a device  * Version compatibiilty: v1.0.0.3 or later  * Parameters:  *   idDisk - Disk handle  * Returns:  *   0  Success  */
name|int
name|hpt_unlock_device
parameter_list|(
name|DEVICEID
name|idDisk
parameter_list|)
function_decl|;
comment|/* hpt_ide_pass_through  *  directly access controller's command and control registers.  *  Can only call it on physical devices.  * Version compatibility: v1.0.0.3 or later  * Parameters:  *   p - IDE_PASS_THROUGH header pointer  * Returns:  *   0  Success  */
name|int
name|hpt_ide_pass_through
parameter_list|(
name|PIDE_PASS_THROUGH_HEADER
name|p
parameter_list|)
function_decl|;
comment|/* hpt_verify_data_block  *   verify data block on RAID1 or RAID5.  * Version compatibility: v1.0.0.3 or later  * Parameters:  *   idArray - Array ID  *   Lba - block number (on each array member, not logical block!)  *   nSectors - Sectors for each member (RAID 5 will ignore this parameter)  * Returns:  *   0  Success  *   1  Data compare error  *   2  I/O error  */
name|int
name|hpt_verify_data_block
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|HPT_U32
name|Lba
parameter_list|,
name|HPT_U8
name|nSectors
parameter_list|)
function_decl|;
comment|/* hpt_initialize_data_block  *   initialize data block (fill with zero) on RAID5  * Version compatibility: v1.0.0.3 or later  * Parameters:  *   idArray - Array ID  *   Lba - block number (on each array member, not logical block!)  *   nSectors - Sectors for each member (RAID 5 will ignore this parameter)  * Returns:  *   0  Success  */
name|int
name|hpt_initialize_data_block
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|HPT_U32
name|Lba
parameter_list|,
name|HPT_U8
name|nSectors
parameter_list|)
function_decl|;
comment|/* hpt_device_io_ex  *   extended device I/O function  * Version compatibility: v1.0.0.3 or later  * Parameters:  *   idArray - Array ID  *   Lba - block number (on each array member, not logical block!)  *   nSectors - Sectors for each member  *   buffer - I/O buffer or s/g address  * Returns:  *   0  Success  */
name|int
name|hpt_device_io_ex
parameter_list|(
name|PDEVICE_IO_EX_PARAMS
name|param
parameter_list|)
function_decl|;
comment|/* hpt_set_boot_mark  *   select boot device  * Version compatibility: v1.0.0.3 or later  * Parameters:  *   id - logical device ID. If id is 0 the boot mark will be removed.  * Returns:  *   0  Success  */
name|int
name|hpt_set_boot_mark
parameter_list|(
name|DEVICEID
name|id
parameter_list|)
function_decl|;
comment|/* hpt_query_remove  *  check if device can be removed safely  * Version compatibility: v1.0.0.4 or later  * Parameters:  *  ndev - number of devices  *  pIds - device ID list  * Returns:  *  0  - Success  *  -1 - unknown error  *  n  - the n-th device that can't be removed  */
name|int
name|hpt_query_remove
parameter_list|(
name|HPT_U32
name|ndev
parameter_list|,
name|DEVICEID
modifier|*
name|pIds
parameter_list|)
function_decl|;
comment|/* hpt_remove_devices  *  remove a list of devices  * Version compatibility: v1.0.0.4 or later  * Parameters:  *  ndev - number of devices  *  pIds - device ID list  * Returns:  *  0  - Success  *  -1 - unknown error  *  n  - the n-th device that can't be removed  */
name|int
name|hpt_remove_devices
parameter_list|(
name|HPT_U32
name|ndev
parameter_list|,
name|DEVICEID
modifier|*
name|pIds
parameter_list|)
function_decl|;
comment|/* hpt_create_array_v2  * Version compatibility: v1.1.0.0 or later  * Parameters:  *  pParam      pointer to CREATE_ARRAY_PARAMS_V2 structure  * Returns:  *  0   failed  *  else return array id  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
name|DEVICEID
name|hpt_create_array_v2
parameter_list|(
name|PCREATE_ARRAY_PARAMS_V2
name|pParam
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_create_array_v3  * Version compatibility: v2.0.0.1 or later  * Parameters:  *  pParam      pointer to CREATE_ARRAY_PARAMS_V3 structure  * Returns:  *  0   failed  *  else return array id  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000001
name|DEVICEID
name|hpt_create_array_v3
parameter_list|(
name|PCREATE_ARRAY_PARAMS_V3
name|pParam
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_get_device_info_v2  * Version compatibility: v1.1.0.0 or later  * Parameters:  *  id      logical device id  *  pInfo   pointer to LOGICAL_DEVICE_INFO_V2 structure  * Returns:  *  0 - Success  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
name|int
name|hpt_get_device_info_v2
parameter_list|(
name|DEVICEID
name|id
parameter_list|,
name|PLOGICAL_DEVICE_INFO_V2
name|pInfo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_get_device_info_v3  * Version compatibility: v1.2.0.0 or later  * Parameters:  *  id      logical device id  *  pInfo   pointer to LOGICAL_DEVICE_INFO_V3 structure  * Returns:  *  0 - Success  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
name|int
name|hpt_get_device_info_v3
parameter_list|(
name|DEVICEID
name|id
parameter_list|,
name|PLOGICAL_DEVICE_INFO_V3
name|pInfo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_get_device_info_v4  * Version compatibility: v2.0.0.1 or later  * Parameters:  *  id      logical device id  *  pInfo   pointer to LOGICAL_DEVICE_INFO_V4 structure  * Returns:  *  0 - Success  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000001
name|int
name|hpt_get_device_info_v4
parameter_list|(
name|DEVICEID
name|id
parameter_list|,
name|PLOGICAL_DEVICE_INFO_V4
name|pInfo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_create_transform  *  create a transform instance.  * Version compatibility: v2.0.0.0 or later  * Parameters:  *  idArray - source array  *  destInfo - destination array info  * Returns:  *  destination array id  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000000
name|DEVICEID
name|hpt_create_transform
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|PCREATE_ARRAY_PARAMS_V2
name|destInfo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_create_transform_v2  *  create a transform instance.  * Version compatibility: v2.0.0.1 or later  * Parameters:  *  idArray - source array  *  destInfo - destination array info  * Returns:  *  destination array id  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000001
name|DEVICEID
name|hpt_create_transform_v2
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|PCREATE_ARRAY_PARAMS_V3
name|destInfo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_step_transform  *  move a block in a tranform progress.  *  This function is called by mid-layer, not GUI (which uses set_array_state instead).  * Version compatibility: v2.0.0.0 or later  * Parameters:  *  idArray - destination array ID  *            the source ID will be invalid when transform complete.  * Returns:  *  0 - Success  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000000
name|int
name|hpt_step_transform
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_set_vdev_info  *  set information for disk or array  * Version compatibility: v1.2.0.0 or later  * Parameters:  *  dev - destination device  *  * Returns:  *  0 - Success  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
name|int
name|hpt_set_vdev_info
parameter_list|(
name|DEVICEID
name|dev
parameter_list|,
name|PSET_VDEV_INFO
name|pInfo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_init_disks  *  initialize disks for use  * Version compatibility: v2.0.0.0 or later  * Parameters:  *  ndev - number of disks to initialize  *  pIds - array of DEVICEID  *  * Returns:  *  0 - Success  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000000
name|int
name|hpt_init_disks
parameter_list|(
name|HPT_U32
name|ndev
parameter_list|,
name|DEVICEID
modifier|*
name|pIds
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_calc_max_array_capacity  *  cap max capacity of the array user want to create or transform  * Version compatibility: v1.2.0.0 or later  * Parameters:  *  source - if transform, this is the source array, otherwise, it should be zero  *  destInfo - target array params  * Returns:  *  0 - Success  *  cap - max capacity of the target array  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
name|int
name|hpt_calc_max_array_capacity
parameter_list|(
name|DEVICEID
name|source
parameter_list|,
name|PCREATE_ARRAY_PARAMS_V2
name|destInfo
parameter_list|,
name|HPT_U64
modifier|*
name|cap
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_calc_max_array_capacity_v2  *  cap max capacity of the array user want to create or transform  * Version compatibility: v2.0.0.1 or later  * Parameters:  *  source - if transform, this is the source array, otherwise, it should be zero  *  destInfo - target array params  * Returns:  *  0 - Success  *  cap - max capacity of the target array  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x02000001
name|int
name|hpt_calc_max_array_capacity_v2
parameter_list|(
name|DEVICEID
name|source
parameter_list|,
name|PCREATE_ARRAY_PARAMS_V3
name|destInfo
parameter_list|,
name|HPT_U64
modifier|*
name|cap
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_rebuild_data_block2  *   Used to copy data from source disk and mirror disk.  * Version compatibility: v1.1.0.0 or later  * Parameters:  *   idArray        Array ID (RAID1, 0/1 or RAID5)  *   Lba            Start LBA for each array member  *   nSector        Number of sectors for each array member (RAID 5 will ignore this parameter)  *  * Returns:  *  0   Success, event info is filled in *pEvent  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
name|int
name|hpt_rebuild_data_block_v2
parameter_list|(
name|DEVICEID
name|idMirror
parameter_list|,
name|HPT_U64
name|Lba
parameter_list|,
name|HPT_U16
name|nSector
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_verify_data_block2  *   verify data block on RAID1 or RAID5.  * Version compatibility: v1.1.0.0 or later  * Parameters:  *   idArray - Array ID  *   Lba - block number (on each array member, not logical block!)  *   nSectors - Sectors for each member (RAID 5 will ignore this parameter)  * Returns:  *   0  Success  *   1  Data compare error  *   2  I/O error  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
name|int
name|hpt_verify_data_block_v2
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|HPT_U64
name|Lba
parameter_list|,
name|HPT_U16
name|nSectors
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_initialize_data_block2  *   initialize data block (fill with zero) on RAID5  * Version compatibility: v1.1.0.0 or later  * Parameters:  *   idArray - Array ID  *   Lba - block number (on each array member, not logical block!)  *   nSectors - Sectors for each member (RAID 5 will ignore this parameter)  * Returns:  *   0  Success  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01010000
name|int
name|hpt_initialize_data_block_v2
parameter_list|(
name|DEVICEID
name|idArray
parameter_list|,
name|HPT_U64
name|Lba
parameter_list|,
name|HPT_U16
name|nSectors
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_i2c_transaction  *   perform an transaction on i2c bus  * Version compatibility: v2.0.0.0 or later  * Parameters:  *   indata[0] - controller ID  * Returns:  *   0  Success  */
if|#
directive|if
name|HPT_INTERFACE_VERSION
operator|>=
literal|0x01020000
name|int
name|hpt_i2c_transaction
parameter_list|(
name|HPT_U8
modifier|*
name|indata
parameter_list|,
name|HPT_U32
name|inlen
parameter_list|,
name|HPT_U8
modifier|*
name|outdata
parameter_list|,
name|HPT_U32
name|outlen
parameter_list|,
name|HPT_U32
modifier|*
name|poutlen
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* hpt_get_parameter_list  *   get a list of driver parameters.  * Version compatibility: v1.0.0.0 or later  * Parameters:  *   location - parameter location  *   outBuffer - a buffer to hold the output  *   outBufferSize - size of outBuffer  * Returns:  *   0  Success  *      put in outBuffer a list of zero terminated parameter names. the whole list  *      is terminated with an additional zero byte.  */
name|int
name|hpt_get_parameter_list
parameter_list|(
name|HPT_U32
name|location
parameter_list|,
name|char
modifier|*
name|outBuffer
parameter_list|,
name|HPT_U32
name|outBufferSize
parameter_list|)
function_decl|;
comment|/* hpt_{get,set}_parameter  *   get/set a parameter value.  * Version compatibility: v1.0.0.0 or later  * Parameters:  *   pParam - a pointer to HPT_DRIVER_PARAMETER.  * Returns:  *   0  Success  */
name|int
name|hpt_get_parameter
parameter_list|(
name|PHPT_DRIVER_PARAMETER
name|pParam
parameter_list|)
function_decl|;
name|int
name|hpt_set_parameter
parameter_list|(
name|PHPT_DRIVER_PARAMETER
name|pParam
parameter_list|)
function_decl|;
name|int
name|hpt_reenumerate_device
parameter_list|(
name|DEVICEID
name|id
parameter_list|)
function_decl|;
endif|#
directive|endif
pragma|#
directive|pragma
name|pack
name|(
name|)
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

