begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $FreeBSD$  *  * Copyright (c) 2002-2004 David Boggs.<boggs@boggs.palo-alto.ca.us>  * All rights reserved.  *  * BSD License:  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * GNU General Public License:  *  * This program is free software; you can redistribute it and/or modify it   * under the terms of the GNU General Public License as published by the Free   * Software Foundation; either version 2 of the License, or (at your option)   * any later version.  *   * This program is distributed in the hope that it will be useful, but WITHOUT   * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or   * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for   * more details.  *  * You should have received a copy of the GNU General Public License along with  * this program; if not, write to the Free Software Foundation, Inc., 59   * Temple Place - Suite 330, Boston, MA  02111-1307, USA.  *  * Description:  *  * This is an open-source Unix device driver for PCI-bus WAN interface cards.  * It sends and receives packets in HDLC frames over synchronous links.  * A generic PC plus Unix plus some SBE/LMC cards makes an OPEN router.  * This driver works with FreeBSD, NetBSD, OpenBSD, BSD/OS and Linux.  * It has been tested on i386 (32-bit little-end), Sparc (64-bit big-end),  * and Alpha (64-bit little-end) architectures.  *  * History and Authors:  *  * Ron Crane had the neat idea to use a Fast Ethernet chip as a PCI  * interface and add an Ethernet-to-HDLC gate array to make a WAN card.  * David Boggs designed the Ethernet-to-HDLC gate arrays and PC cards.  * We did this at our company, LAN Media Corporation (LMC).  * SBE Corp acquired LMC and continues to make the cards.  *  * Since the cards use Tulip Ethernet chips, we started with Matt Thomas'  * ubiquitous "de" driver.  Michael Graff stripped out the Ethernet stuff  * and added HSSI stuff.  Basil Gunn ported it to Solaris (lost) and  * Rob Braun ported it to Linux.  Andrew Stanley-Jones added support  * for three more cards and wrote the first version of lmcconfig.  * During 2002-5 David Boggs rewrote it and now feels responsible for it.  *  * Responsible Individual:  *  * Send bug reports and improvements to<boggs@boggs.palo-alto.ca.us>.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* OS version */
end_comment

begin_define
define|#
directive|define
name|IFNET
value|1
end_define

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_comment
comment|/* INET */
end_comment

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|"opt_netgraph.h"
end_include

begin_comment
comment|/* NETGRAPH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INET
end_ifndef

begin_define
define|#
directive|define
name|INET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INET6
end_ifndef

begin_define
define|#
directive|define
name|INET6
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NETGRAPH
end_ifndef

begin_define
define|#
directive|define
name|NETGRAPH
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|P2P
value|0
end_define

begin_comment
comment|/* not in FreeBSD */
end_comment

begin_define
define|#
directive|define
name|NSPPP
value|1
end_define

begin_comment
comment|/* No count devices in FreeBSD 5 */
end_comment

begin_include
include|#
directive|include
file|"opt_bpf.h"
end_include

begin_comment
comment|/* DEV_BPF */
end_comment

begin_define
define|#
directive|define
name|NBPFILTER
value|DEV_BPF
end_define

begin_define
define|#
directive|define
name|GEN_HDLC
value|0
end_define

begin_comment
comment|/* not in FreeBSD */
end_comment

begin_empty
empty|#
end_empty

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_if
if|#
directive|if
name|NETGRAPH
end_if

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|INET
operator|||
name|INET6
operator|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NSPPP
end_if

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* and finally... */
end_comment

begin_include
include|#
directive|include
file|<dev/lmc/if_lmc.h>
end_include

begin_comment
comment|/* The SROM is a generic 93C46 serial EEPROM (64 words by 16 bits). */
end_comment

begin_comment
comment|/* Data is set up before the RISING edge of CLK; CLK is parked low. */
end_comment

begin_function
specifier|static
name|void
name|shift_srom_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|u_int32_t
name|csr
init|=
name|READ_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
comment|/* MSB first */
if|if
condition|(
name|data
operator|&
operator|(
literal|1
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
condition|)
name|csr
operator||=
name|TLP_SROM_DIN
expr_stmt|;
comment|/* DIN setup */
else|else
name|csr
operator|&=
operator|~
name|TLP_SROM_DIN
expr_stmt|;
comment|/* DIN setup */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|csr
operator||=
name|TLP_SROM_CLK
expr_stmt|;
comment|/* CLK rising edge */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|TLP_SROM_CLK
expr_stmt|;
comment|/* CLK falling edge */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Data is sampled on the RISING edge of CLK; CLK is parked low. */
end_comment

begin_function
specifier|static
name|u_int16_t
name|read_srom
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|csr
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|;
comment|/* Enable SROM access. */
name|csr
operator|=
operator|(
name|TLP_SROM_SEL
operator||
name|TLP_SROM_RD
operator||
name|TLP_MII_MDOE
operator|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* CS rising edge prepares SROM for a new cycle. */
name|csr
operator||=
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* assert CS */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* issue read cmd */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* issue address */
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|i
operator|=
literal|16
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|/* read ->17<- bits of data */
block|{
comment|/* MSB first */
name|csr
operator|=
name|READ_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|)
expr_stmt|;
comment|/* DOUT sampled */
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|csr
operator|&
name|TLP_SROM_DOUT
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|csr
operator||=
name|TLP_SROM_CLK
expr_stmt|;
comment|/* CLK rising edge */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|TLP_SROM_CLK
expr_stmt|;
comment|/* CLK falling edge */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
block|}
comment|/* Disable SROM access. */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|TLP_MII_MDOE
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/* The SROM is formatted by the mfgr and should NOT be written! */
end_comment

begin_comment
comment|/* But lmcconfig can rewrite it in case it gets overwritten somehow. */
end_comment

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|void
name|write_srom
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|addr
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|u_int32_t
name|csr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Enable SROM access. */
name|csr
operator|=
operator|(
name|TLP_SROM_SEL
operator||
name|TLP_SROM_RD
operator||
name|TLP_MII_MDOE
operator|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* Issue write-enable command. */
name|csr
operator||=
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* assert CS */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* issue write enable cmd */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
literal|63
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* issue address */
name|csr
operator|&=
operator|~
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* deassert CS */
comment|/* Issue erase command. */
name|csr
operator||=
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* assert CS */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
literal|7
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* issue erase cmd */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* issue address */
name|csr
operator|&=
operator|~
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* deassert CS */
comment|/* Issue write command. */
name|csr
operator||=
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* assert CS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
comment|/* 100 ms max wait */
if|if
condition|(
operator|(
name|READ_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|)
operator|&
name|TLP_SROM_DOUT
operator|)
operator|==
literal|0
condition|)
name|SLEEP
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* issue write cmd */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* issue address */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* issue data */
name|csr
operator|&=
operator|~
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* deassert CS */
comment|/* Issue write-disable command. */
name|csr
operator||=
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* assert CS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
comment|/* 100 ms max wait */
if|if
condition|(
operator|(
name|READ_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|)
operator|&
name|TLP_SROM_DOUT
operator|)
operator|==
literal|0
condition|)
name|SLEEP
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* issue write disable cmd */
name|shift_srom_bits
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* issue address */
name|csr
operator|&=
operator|~
name|TLP_SROM_CS
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* deassert CS */
comment|/* Disable SROM access. */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|TLP_MII_MDOE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not all boards have BIOS roms. */
end_comment

begin_comment
comment|/* The BIOS ROM is an AMD 29F010 1Mbit (128K by 8) EEPROM. */
end_comment

begin_function
specifier|static
name|u_int8_t
name|read_bios
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|addr
parameter_list|)
block|{
name|u_int32_t
name|srom_mii
decl_stmt|;
comment|/* Load the BIOS rom address register. */
name|WRITE_CSR
argument_list|(
name|TLP_BIOS_ROM
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Enable the BIOS rom. */
name|srom_mii
operator|=
name|TLP_BIOS_SEL
operator||
name|TLP_BIOS_RD
operator||
name|TLP_MII_MDOE
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|srom_mii
argument_list|)
expr_stmt|;
comment|/* Wait at least 20 PCI cycles. */
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Read the BIOS rom data. */
name|srom_mii
operator|=
name|READ_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|)
expr_stmt|;
comment|/* Disable the BIOS rom. */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|TLP_MII_MDOE
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_int8_t
operator|)
name|srom_mii
operator|&
literal|0xFF
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_bios_phys
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|addr
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|u_int32_t
name|srom_mii
decl_stmt|;
comment|/* Load the BIOS rom address register. */
name|WRITE_CSR
argument_list|(
name|TLP_BIOS_ROM
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Enable the BIOS rom. */
name|srom_mii
operator|=
name|TLP_BIOS_SEL
operator||
name|TLP_BIOS_WR
operator||
name|TLP_MII_MDOE
expr_stmt|;
comment|/* Load the data into the data register. */
name|srom_mii
operator|=
operator|(
name|srom_mii
operator|&
literal|0xFFFFFF00
operator|)
operator||
operator|(
name|data
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|srom_mii
argument_list|)
expr_stmt|;
comment|/* Wait at least 20 PCI cycles. */
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Disable the BIOS rom. */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|TLP_MII_MDOE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|void
name|write_bios
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|addr
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|u_int8_t
name|read_data
decl_stmt|;
comment|/* this sequence enables writing */
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x5555
argument_list|,
literal|0xAA
argument_list|)
expr_stmt|;
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x2AAA
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x5555
argument_list|,
literal|0xA0
argument_list|)
expr_stmt|;
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Wait for the write operation to complete. */
for|for
control|(
init|;
condition|;
control|)
comment|/* interruptable syscall */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|read_data
operator|=
name|read_bios
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|read_data
operator|&
literal|0x80
operator|)
operator|==
operator|(
name|data
operator|&
literal|0x80
operator|)
condition|)
break|break;
if|if
condition|(
name|read_data
operator|&
literal|0x20
condition|)
block|{
comment|/* Data sheet says read it again. */
name|read_data
operator|=
name|read_bios
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|read_data
operator|&
literal|0x80
operator|)
operator|==
operator|(
name|data
operator|&
literal|0x80
operator|)
condition|)
break|break;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: write_bios() failed; rom addr=0x%x\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|read_data
operator|=
name|read_bios
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_data
operator|==
name|data
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|void
name|erase_bios
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|char
name|read_data
decl_stmt|;
comment|/* This sequence enables erasing: */
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x5555
argument_list|,
literal|0xAA
argument_list|)
expr_stmt|;
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x2AAA
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x5555
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x5555
argument_list|,
literal|0xAA
argument_list|)
expr_stmt|;
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x2AAA
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|write_bios_phys
argument_list|(
name|sc
argument_list|,
literal|0x5555
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Wait for the erase operation to complete. */
for|for
control|(
init|;
condition|;
control|)
comment|/* interruptable syscall */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|read_data
operator|=
name|read_bios
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_data
operator|&
literal|0x80
condition|)
break|break;
if|if
condition|(
name|read_data
operator|&
literal|0x20
condition|)
block|{
comment|/* Data sheet says read it again. */
name|read_data
operator|=
name|read_bios
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_data
operator|&
literal|0x80
condition|)
break|break;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: erase_bios() failed\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|read_data
operator|=
name|read_bios
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_data
operator|==
literal|0xFF
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* MDIO is 3-stated between tranactions. */
end_comment

begin_comment
comment|/* MDIO is set up before the RISING edge of MDC; MDC is parked low. */
end_comment

begin_function
specifier|static
name|void
name|shift_mii_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|u_int32_t
name|csr
init|=
name|READ_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
comment|/* MSB first */
if|if
condition|(
name|data
operator|&
operator|(
literal|1
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
condition|)
name|csr
operator||=
name|TLP_MII_MDOUT
expr_stmt|;
comment|/* MDOUT setup */
else|else
name|csr
operator|&=
operator|~
name|TLP_MII_MDOUT
expr_stmt|;
comment|/* MDOUT setup */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|csr
operator||=
name|TLP_MII_MDC
expr_stmt|;
comment|/* MDC rising edge */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|TLP_MII_MDC
expr_stmt|;
comment|/* MDC falling edge */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The specification for the MII is IEEE Std 802.3 clause 22. */
end_comment

begin_comment
comment|/* MDIO is sampled on the RISING edge of MDC; MDC is parked low. */
end_comment

begin_function
specifier|static
name|u_int16_t
name|read_mii
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|regad
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|csr
decl_stmt|;
name|u_int16_t
name|data
init|=
literal|0
decl_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|TLP_MII_MDOUT
argument_list|)
expr_stmt|;
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|0xFFFFF
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* preamble */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|0xFFFFF
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* preamble */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* start symbol */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* read op */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* phyad=0 */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
name|regad
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* regad */
name|csr
operator|=
name|READ_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|)
expr_stmt|;
name|csr
operator||=
name|TLP_MII_MDOE
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* turn-around */
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|/* data */
block|{
comment|/* MSB first */
name|csr
operator|=
name|READ_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|)
expr_stmt|;
comment|/* MDIN sampled */
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|csr
operator|&
name|TLP_MII_MDIN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|csr
operator||=
name|TLP_MII_MDC
expr_stmt|;
comment|/* MDC rising edge */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|TLP_MII_MDC
expr_stmt|;
comment|/* MDC falling edge */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|csr
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_mii
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|regad
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|TLP_MII_MDOUT
argument_list|)
expr_stmt|;
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|0xFFFFF
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* preamble */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|0xFFFFF
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* preamble */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* start symbol */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* write op */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* phyad=0 */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
name|regad
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* regad */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* turn-around */
name|shift_mii_bits
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* data */
name|WRITE_CSR
argument_list|(
name|TLP_SROM_MII
argument_list|,
name|TLP_MII_MDOE
argument_list|)
expr_stmt|;
if|if
condition|(
name|regad
operator|==
literal|16
condition|)
name|sc
operator|->
name|led_state
operator|=
name|data
expr_stmt|;
comment|/* a small optimization */
block|}
end_function

begin_function
specifier|static
name|void
name|set_mii16_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|bits
parameter_list|)
block|{
name|u_int16_t
name|mii16
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|mii16
operator||=
name|bits
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|,
name|mii16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clr_mii16_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|bits
parameter_list|)
block|{
name|u_int16_t
name|mii16
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|mii16
operator|&=
operator|~
name|bits
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|,
name|mii16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mii17_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|bits
parameter_list|)
block|{
name|u_int16_t
name|mii17
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|17
argument_list|)
decl_stmt|;
name|mii17
operator||=
name|bits
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|17
argument_list|,
name|mii17
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clr_mii17_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|bits
parameter_list|)
block|{
name|u_int16_t
name|mii17
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|17
argument_list|)
decl_stmt|;
name|mii17
operator|&=
operator|~
name|bits
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|17
argument_list|,
name|mii17
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Watchdog code is more readable if it refreshes LEDs  *  once a second whether they need it or not.  * But MII refs take 150 uSecs each, so remember the last value  *  written to MII16 and avoid LED writes that do nothing.  */
end_comment

begin_function
specifier|static
name|void
name|led_off
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|led
parameter_list|)
block|{
if|if
condition|(
operator|(
name|led
operator|&
name|sc
operator|->
name|led_state
operator|)
operator|==
name|led
condition|)
return|return;
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|led
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|led_on
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|led
parameter_list|)
block|{
if|if
condition|(
operator|(
name|led
operator|&
name|sc
operator|->
name|led_state
operator|)
operator|==
literal|0
condition|)
return|return;
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|led
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|led_inv
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|led
parameter_list|)
block|{
name|u_int16_t
name|mii16
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|mii16
operator|^=
name|led
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|,
name|mii16
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T1& T3 framer registers are accessed through MII regs 17& 18.  * Write the address to MII reg 17 then R/W data through MII reg 18.  * The hardware interface is an Intel-style 8-bit muxed A/D bus.  */
end_comment

begin_function
specifier|static
name|void
name|write_framer
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|addr
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|17
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|18
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|read_framer
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|addr
parameter_list|)
block|{
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|17
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_int8_t
operator|)
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|18
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Tulip's hardware implementation of General Purpose IO  *   (GPIO) pins makes life difficult for software.  * Bits 7-0 in the Tulip GPIO CSR are used for two purposes  *   depending on the state of bit 8.  * If bit 8 is 0 then bits 7-0 are "data" bits.  * If bit 8 is 1 then bits 7-0 are "direction" bits.  * If a direction bit is one, the data bit is an output.  * The problem is that the direction bits are WRITE-ONLY.  * Software must remember the direction bits in a shadow copy.  * (sc->gpio_dir) in order to change some but not all of the bits.  * All accesses to the Tulip GPIO register use these five procedures.  */
end_comment

begin_function
specifier|static
name|void
name|make_gpio_input
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|bits
parameter_list|)
block|{
name|sc
operator|->
name|gpio_dir
operator|&=
operator|~
name|bits
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_GPIO
argument_list|,
name|TLP_GPIO_DIR
operator||
operator|(
name|sc
operator|->
name|gpio_dir
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_gpio_output
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|bits
parameter_list|)
block|{
name|sc
operator|->
name|gpio_dir
operator||=
name|bits
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_GPIO
argument_list|,
name|TLP_GPIO_DIR
operator||
operator|(
name|sc
operator|->
name|gpio_dir
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|read_gpio
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|READ_CSR
argument_list|(
name|TLP_GPIO
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_gpio_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|bits
parameter_list|)
block|{
name|WRITE_CSR
argument_list|(
name|TLP_GPIO
argument_list|,
operator|(
name|read_gpio
argument_list|(
name|sc
argument_list|)
operator||
name|bits
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clr_gpio_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|bits
parameter_list|)
block|{
name|WRITE_CSR
argument_list|(
name|TLP_GPIO
argument_list|,
operator|(
name|read_gpio
argument_list|(
name|sc
argument_list|)
operator|&
operator|~
name|bits
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset ALL of the flip-flops in the gate array to zero. */
end_comment

begin_comment
comment|/* This does NOT change the gate array programming. */
end_comment

begin_comment
comment|/* Called during initialization so it must not sleep. */
end_comment

begin_function
specifier|static
name|void
name|reset_xilinx
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Drive RESET low to force initialization. */
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_RESET
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_RESET
argument_list|)
expr_stmt|;
comment|/* Hold RESET low for more than 10 uSec. */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Done with RESET; make it an input. */
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load Xilinx gate array program from on-board rom. */
end_comment

begin_comment
comment|/* This changes the gate array programming. */
end_comment

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|void
name|load_xilinx_from_rom
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Drive MODE low to load from ROM rather than GPIO. */
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_MODE
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_MODE
argument_list|)
expr_stmt|;
comment|/* Drive DP& RESET low to force configuration. */
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_RESET
operator||
name|GPIO_DP
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_RESET
operator||
name|GPIO_DP
argument_list|)
expr_stmt|;
comment|/* Hold RESET& DP low for more than 10 uSec. */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Done with RESET& DP; make them inputs. */
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_DP
operator||
name|GPIO_RESET
argument_list|)
expr_stmt|;
comment|/* BUSY-WAIT for Xilinx chip to configure itself from ROM bits. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
comment|/* 1 sec max delay */
if|if
condition|(
operator|(
name|read_gpio
argument_list|(
name|sc
argument_list|)
operator|&
name|GPIO_DP
operator|)
operator|==
literal|0
condition|)
name|SLEEP
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Done with MODE; make it an input. */
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_MODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load the Xilinx gate array program from userland bits. */
end_comment

begin_comment
comment|/* This changes the gate array programming. */
end_comment

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|int
name|load_xilinx_from_file
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|;
comment|/* Get some pages to hold the Xilinx bits; biggest file is< 6 KB. */
if|if
condition|(
name|len
operator|>
literal|8192
condition|)
return|return
name|EFBIG
return|;
comment|/* too big */
name|data
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/* Copy the Xilinx bits from userland. */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Drive MODE high to load from GPIO rather than ROM. */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_MODE
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_MODE
argument_list|)
expr_stmt|;
comment|/* Drive DP& RESET low to force configuration. */
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_RESET
operator||
name|GPIO_DP
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_RESET
operator||
name|GPIO_DP
argument_list|)
expr_stmt|;
comment|/* Hold RESET& DP low for more than 10 uSec. */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Done with RESET& DP; make them inputs. */
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_RESET
operator||
name|GPIO_DP
argument_list|)
expr_stmt|;
comment|/* BUSY-WAIT for Xilinx chip to clear its config memory. */
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_INIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
comment|/* 1 sec max delay */
if|if
condition|(
operator|(
name|read_gpio
argument_list|(
name|sc
argument_list|)
operator|&
name|GPIO_INIT
operator|)
operator|==
literal|0
condition|)
name|SLEEP
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Configure CLK and DATA as outputs. */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* park CLK high */
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
operator||
name|GPIO_DATA
argument_list|)
expr_stmt|;
comment|/* Write bits to Xilinx; CLK is parked HIGH. */
comment|/* DATA is set up before the RISING edge of CLK. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
comment|/* LSB first */
if|if
condition|(
operator|(
name|data
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
argument_list|)
expr_stmt|;
comment|/* DATA setup */
else|else
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
argument_list|)
expr_stmt|;
comment|/* DATA setup */
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* CLK falling edge */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* CLK rising edge */
block|}
comment|/* Stop driving all Xilinx-related signals. */
comment|/* Pullup and pulldown resistors take over. */
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
operator||
name|GPIO_DATA
operator||
name|GPIO_MODE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write fragments of a command into the synthesized oscillator. */
end_comment

begin_comment
comment|/* DATA is set up before the RISING edge of CLK.  CLK is parked low. */
end_comment

begin_function
specifier|static
name|void
name|shift_synth_bits
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* LSB first */
if|if
condition|(
operator|(
name|data
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
argument_list|)
expr_stmt|;
comment|/* DATA setup */
else|else
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
argument_list|)
expr_stmt|;
comment|/* DATA setup */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* CLK rising edge */
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* CLK falling edge */
block|}
block|}
end_function

begin_comment
comment|/* Write a command to the synthesized oscillator on SSI and HSSIc. */
end_comment

begin_function
specifier|static
name|void
name|write_synth
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|synth
modifier|*
name|synth
parameter_list|)
block|{
comment|/* SSI cards have a programmable prescaler */
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|card_type
operator|==
name|TLP_CSID_SSI
condition|)
block|{
if|if
condition|(
name|synth
operator|->
name|prescale
operator|==
literal|9
condition|)
comment|/* divide by 512 */
name|set_mii17_bits
argument_list|(
name|sc
argument_list|,
name|MII17_SSI_PRESCALE
argument_list|)
expr_stmt|;
else|else
comment|/* divide by  32 */
name|clr_mii17_bits
argument_list|(
name|sc
argument_list|,
name|MII17_SSI_PRESCALE
argument_list|)
expr_stmt|;
block|}
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
operator||
name|GPIO_CLK
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
operator||
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* SYNTH is a low-true chip enable for the AV9110 chip. */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_SYNTH
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_SYNTH
argument_list|)
expr_stmt|;
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_SYNTH
argument_list|)
expr_stmt|;
comment|/* Serially shift the command into the AV9110 chip. */
name|shift_synth_bits
argument_list|(
name|sc
argument_list|,
name|synth
operator|->
name|n
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|shift_synth_bits
argument_list|(
name|sc
argument_list|,
name|synth
operator|->
name|m
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|shift_synth_bits
argument_list|(
name|sc
argument_list|,
name|synth
operator|->
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|shift_synth_bits
argument_list|(
name|sc
argument_list|,
name|synth
operator|->
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|shift_synth_bits
argument_list|(
name|sc
argument_list|,
name|synth
operator|->
name|r
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|shift_synth_bits
argument_list|(
name|sc
argument_list|,
literal|0x16
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* enable clk/x output */
comment|/* SYNTH (chip enable) going high ends the command. */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_SYNTH
argument_list|)
expr_stmt|;
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_SYNTH
argument_list|)
expr_stmt|;
comment|/* Stop driving serial-related signals; pullups/pulldowns take over. */
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
operator||
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* remember the new synthesizer parameters */
if|if
condition|(
operator|&
name|sc
operator|->
name|config
operator|.
name|synth
operator|!=
name|synth
condition|)
name|sc
operator|->
name|config
operator|.
name|synth
operator|=
operator|*
name|synth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a command to the DAC controlling the VCXO on some T3 adapters. */
end_comment

begin_comment
comment|/* The DAC is a TI-TLV5636: 12-bit resolution and a serial interface. */
end_comment

begin_comment
comment|/* DATA is set up before the FALLING edge of CLK.  CLK is parked HIGH. */
end_comment

begin_function
specifier|static
name|void
name|write_dac
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Prepare to use DATA and CLK. */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
operator||
name|GPIO_CLK
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
operator||
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* High-to-low transition prepares DAC for new value. */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_T3_DAC
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_T3_DAC
argument_list|)
expr_stmt|;
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_T3_DAC
argument_list|)
expr_stmt|;
comment|/* Serially shift command bits into DAC. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
comment|/* MSB first */
if|if
condition|(
operator|(
name|data
operator|&
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|i
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
argument_list|)
expr_stmt|;
comment|/* DATA setup */
else|else
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
argument_list|)
expr_stmt|;
comment|/* DATA setup */
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* CLK falling edge */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_CLK
argument_list|)
expr_stmt|;
comment|/* CLK rising edge */
block|}
comment|/* Done with DAC; make it an input; loads new value into DAC. */
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_T3_DAC
argument_list|)
expr_stmt|;
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_T3_DAC
argument_list|)
expr_stmt|;
comment|/* Stop driving serial-related signals; pullups/pulldowns take over. */
name|make_gpio_input
argument_list|(
name|sc
argument_list|,
name|GPIO_DATA
operator||
name|GPIO_CLK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* begin HSSI card code */
end_comment

begin_comment
comment|/* Must not sleep. */
end_comment

begin_function
specifier|static
name|void
name|hssi_config
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|card_type
operator|==
literal|0
condition|)
block|{
comment|/* defaults */
name|sc
operator|->
name|status
operator|.
name|card_type
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CSID
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|=
name|CFG_CRC_16
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|=
name|CFG_LOOP_NONE
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|tx_clk_src
operator|=
name|CFG_CLKMUX_ST
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|dte_dce
operator|=
name|CFG_DTE
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|n
operator|=
literal|52
expr_stmt|;
comment|/* 52.000 Mbs */
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|m
operator|=
literal|5
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|r
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|prescale
operator|=
literal|2
expr_stmt|;
block|}
comment|/* set CRC length */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|==
name|CFG_CRC_32
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_CRC32
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_CRC32
argument_list|)
expr_stmt|;
comment|/* Assert pin LA in HSSI conn: ask modem for local loop. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_LL
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LA
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LA
argument_list|)
expr_stmt|;
comment|/* Assert pin LB in HSSI conn: ask modem for remote loop. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_RL
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LB
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LB
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|card_type
operator|==
name|TLP_CSID_HSSI
condition|)
block|{
comment|/* set TXCLK src */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|tx_clk_src
operator|==
name|CFG_CLKMUX_ST
condition|)
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_HSSI_TXCLK
argument_list|)
expr_stmt|;
else|else
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_HSSI_TXCLK
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_HSSI_TXCLK
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|card_type
operator|==
name|TLP_CSID_HSSIc
condition|)
block|{
comment|/* cPCI HSSI rev C has extra features */
comment|/* Set TXCLK source. */
name|u_int16_t
name|mii16
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|mii16
operator|&=
operator|~
name|MII16_HSSI_CLKMUX
expr_stmt|;
name|mii16
operator||=
operator|(
name|sc
operator|->
name|config
operator|.
name|tx_clk_src
operator|&
literal|3
operator|)
operator|<<
literal|13
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|,
name|mii16
argument_list|)
expr_stmt|;
comment|/* cPCI HSSI implements loopback towards the net. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_LINE
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LOOP
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LOOP
argument_list|)
expr_stmt|;
comment|/* Set DTE/DCE mode. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|dte_dce
operator|==
name|CFG_DCE
condition|)
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_HSSI_DCE
argument_list|)
expr_stmt|;
else|else
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_HSSI_DCE
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_HSSI_DCE
argument_list|)
expr_stmt|;
comment|/* Program the synthesized oscillator. */
name|write_synth
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|config
operator|.
name|synth
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hssi_ident
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{   }
end_function

begin_comment
comment|/* Called once a second; must not sleep. */
end_comment

begin_function
specifier|static
name|int
name|hssi_watchdog
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|mii16
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
operator|&
name|MII16_HSSI_MODEM
decl_stmt|;
name|int
name|link_status
init|=
name|STATUS_UP
decl_stmt|;
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LED_UL
argument_list|)
expr_stmt|;
comment|/* Software is alive. */
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LED_LL
argument_list|)
expr_stmt|;
comment|/* always on (SSI cable) */
comment|/* Check the transmit clock. */
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|tx_speed
operator|==
literal|0
condition|)
block|{
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LED_UR
argument_list|)
expr_stmt|;
name|link_status
operator|=
name|STATUS_DOWN
expr_stmt|;
block|}
else|else
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LED_UR
argument_list|)
expr_stmt|;
comment|/* Is the modem ready? */
if|if
condition|(
operator|(
name|mii16
operator|&
name|MII16_HSSI_CA
operator|)
operator|==
literal|0
condition|)
block|{
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LED_LR
argument_list|)
expr_stmt|;
name|link_status
operator|=
name|STATUS_DOWN
expr_stmt|;
block|}
else|else
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_LED_LR
argument_list|)
expr_stmt|;
comment|/* Print the modem control signals if they changed. */
if|if
condition|(
operator|(
name|DRIVER_DEBUG
operator|)
operator|&&
operator|(
name|mii16
operator|!=
name|sc
operator|->
name|last_mii16
operator|)
condition|)
block|{
name|char
modifier|*
name|on
init|=
literal|"ON "
decl_stmt|,
modifier|*
name|off
init|=
literal|"OFF"
decl_stmt|;
name|printf
argument_list|(
literal|"%s: TA=%s CA=%s LA=%s LB=%s LC=%s TM=%s\n"
argument_list|,
name|NAME_UNIT
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_HSSI_TA
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_HSSI_CA
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_HSSI_LA
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_HSSI_LB
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_HSSI_LC
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_HSSI_TM
operator|)
condition|?
name|on
else|:
name|off
argument_list|)
expr_stmt|;
block|}
comment|/* SNMP one-second-report */
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|hssi
operator|.
name|sigs
operator|=
name|mii16
operator|&
name|MII16_HSSI_MODEM
expr_stmt|;
comment|/* Remember this state until next time. */
name|sc
operator|->
name|last_mii16
operator|=
name|mii16
expr_stmt|;
comment|/* If a loop back is in effect, link status is UP */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|!=
name|CFG_LOOP_NONE
condition|)
name|link_status
operator|=
name|STATUS_UP
expr_stmt|;
return|return
name|link_status
return|;
block|}
end_function

begin_comment
comment|/* IOCTL SYSCALL: can sleep (but doesn't). */
end_comment

begin_function
specifier|static
name|int
name|hssi_ioctl
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ioctl
modifier|*
name|ioctl
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_SNMP_SIGS
condition|)
block|{
name|u_int16_t
name|mii16
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|mii16
operator|&=
operator|~
name|MII16_HSSI_MODEM
expr_stmt|;
name|mii16
operator||=
operator|(
name|MII16_HSSI_MODEM
operator|&
name|ioctl
operator|->
name|data
operator|)
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|,
name|mii16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_SET_STATUS
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|data
operator|!=
literal|0
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_TA
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_HSSI_TA
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* begin DS3 card code */
end_comment

begin_comment
comment|/* Must not sleep. */
end_comment

begin_function
specifier|static
name|void
name|t3_config
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|ctl1
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|card_type
operator|==
literal|0
condition|)
block|{
comment|/* defaults */
name|sc
operator|->
name|status
operator|.
name|card_type
operator|=
name|TLP_CSID_T3
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|=
name|CFG_CRC_16
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|=
name|CFG_LOOP_NONE
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|format
operator|=
name|CFG_FORMAT_T3CPAR
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|=
literal|10
expr_stmt|;
comment|/* meters */
name|sc
operator|->
name|config
operator|.
name|scrambler
operator|=
name|CFG_SCRAM_DL_KEN
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|tx_clk_src
operator|=
name|CFG_CLKMUX_INT
expr_stmt|;
comment|/* Center the VCXO -- get within 20 PPM of 44736000. */
name|write_dac
argument_list|(
name|sc
argument_list|,
literal|0x9002
argument_list|)
expr_stmt|;
comment|/* set Vref = 2.048 volts */
name|write_dac
argument_list|(
name|sc
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
comment|/* range is 0..4095 */
block|}
comment|/* Set cable length. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|30
condition|)
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_ZERO
argument_list|)
expr_stmt|;
else|else
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_ZERO
argument_list|)
expr_stmt|;
comment|/* Set payload scrambler polynomial. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|scrambler
operator|==
name|CFG_SCRAM_LARS
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_POLY
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_POLY
argument_list|)
expr_stmt|;
comment|/* Set payload scrambler on/off. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|scrambler
operator|==
name|CFG_SCRAM_OFF
condition|)
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_SCRAM
argument_list|)
expr_stmt|;
else|else
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_SCRAM
argument_list|)
expr_stmt|;
comment|/* Set CRC length. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|==
name|CFG_CRC_32
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_CRC32
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_CRC32
argument_list|)
expr_stmt|;
comment|/* Loopback towards host thru the line interface. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_OTHER
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_TRLBK
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_TRLBK
argument_list|)
expr_stmt|;
comment|/* Loopback towards network thru the line interface. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_LINE
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_DUAL
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
comment|/* Configure T3 framer chip; write EVERY writeable register. */
name|ctl1
operator|=
name|CTL1_SER
operator||
name|CTL1_XTX
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_INWARD
condition|)
name|ctl1
operator||=
name|CTL1_3LOOP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_DUAL
condition|)
name|ctl1
operator||=
name|CTL1_3LOOP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_T3M13
condition|)
name|ctl1
operator||=
name|CTL1_M13MODE
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|,
name|ctl1
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|,
name|CTL5_EMODE
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL8
argument_list|,
name|CTL8_FBEC
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|,
name|CTL12_DLCB1
operator||
name|CTL12_C21
operator||
name|CTL12_MCB1
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_DBL_FEAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL14
argument_list|,
name|CTL14_RGCEN
operator||
name|CTL14_TGCEN
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_INTEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL20
argument_list|,
name|CTL20_CVEN
argument_list|)
expr_stmt|;
comment|/* Clear error counters and latched error bits */
comment|/*  that may have happened while initializing. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|21
condition|;
name|i
operator|++
control|)
name|read_framer
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_ident
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|printf
argument_list|(
literal|", TXC03401 rev B"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called once a second; must not sleep. */
end_comment

begin_function
specifier|static
name|int
name|t3_watchdog
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|CV
decl_stmt|;
name|u_int8_t
name|CERR
decl_stmt|,
name|PERR
decl_stmt|,
name|MERR
decl_stmt|,
name|FERR
decl_stmt|,
name|FEBE
decl_stmt|;
name|u_int8_t
name|ctl1
decl_stmt|,
name|stat16
decl_stmt|,
name|feac
decl_stmt|;
name|int
name|link_status
init|=
name|STATUS_UP
decl_stmt|;
name|u_int16_t
name|mii16
decl_stmt|;
comment|/* Read the alarm registers. */
name|ctl1
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|)
expr_stmt|;
name|stat16
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_STAT16
argument_list|)
expr_stmt|;
name|mii16
operator|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Always ignore the RTLOC alarm bit. */
name|stat16
operator|&=
operator|~
name|STAT16_RTLOC
expr_stmt|;
comment|/* Software is alive. */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_GRN
argument_list|)
expr_stmt|;
comment|/* Receiving Alarm Indication Signal (AIS). */
if|if
condition|(
operator|(
name|stat16
operator|&
name|STAT16_RAIS
operator|)
operator|!=
literal|0
condition|)
comment|/* receiving ais */
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_BLU
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctl1
operator|&
name|CTL1_TXAIS
condition|)
comment|/* sending ais */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_BLU
argument_list|)
expr_stmt|;
else|else
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_BLU
argument_list|)
expr_stmt|;
comment|/* Receiving Remote Alarm Indication (RAI). */
if|if
condition|(
operator|(
name|stat16
operator|&
name|STAT16_XERR
operator|)
operator|!=
literal|0
condition|)
comment|/* receiving rai */
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_YEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ctl1
operator|&
name|CTL1_XTX
operator|)
operator|==
literal|0
condition|)
comment|/* sending rai */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_YEL
argument_list|)
expr_stmt|;
else|else
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_YEL
argument_list|)
expr_stmt|;
comment|/* If certain status bits are set then the link is 'down'. */
comment|/* The bad bits are: rxlos rxoof rxais rxidl xerr. */
if|if
condition|(
operator|(
name|stat16
operator|&
operator|~
operator|(
name|STAT16_FEAC
operator||
name|STAT16_SEF
operator|)
operator|)
operator|!=
literal|0
condition|)
name|link_status
operator|=
name|STATUS_DOWN
expr_stmt|;
comment|/* Declare local Red Alarm if the link is down. */
if|if
condition|(
name|link_status
operator|==
name|STATUS_DOWN
condition|)
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_RED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|loop_timer
operator|!=
literal|0
condition|)
comment|/* loopback is active */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_RED
argument_list|)
expr_stmt|;
else|else
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LED_RED
argument_list|)
expr_stmt|;
comment|/* Print latched error bits if they changed. */
if|if
condition|(
operator|(
name|DRIVER_DEBUG
operator|)
operator|&&
operator|(
operator|(
name|stat16
operator|&
operator|~
name|STAT16_FEAC
operator|)
operator|!=
name|sc
operator|->
name|last_stat16
operator|)
condition|)
block|{
name|char
modifier|*
name|on
init|=
literal|"ON "
decl_stmt|,
modifier|*
name|off
init|=
literal|"OFF"
decl_stmt|;
name|printf
argument_list|(
literal|"%s: RLOS=%s ROOF=%s RAIS=%s RIDL=%s SEF=%s XERR=%s\n"
argument_list|,
name|NAME_UNIT
argument_list|,
operator|(
name|stat16
operator|&
name|STAT16_RLOS
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|stat16
operator|&
name|STAT16_ROOF
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|stat16
operator|&
name|STAT16_RAIS
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|stat16
operator|&
name|STAT16_RIDL
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|stat16
operator|&
name|STAT16_SEF
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|stat16
operator|&
name|STAT16_XERR
operator|)
condition|?
name|on
else|:
name|off
argument_list|)
expr_stmt|;
block|}
comment|/* Check and print error counters if non-zero. */
name|CV
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CVHI
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|CV
operator|+=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CVLO
argument_list|)
expr_stmt|;
name|PERR
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_PERR
argument_list|)
expr_stmt|;
name|CERR
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CERR
argument_list|)
expr_stmt|;
name|FERR
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_FERR
argument_list|)
expr_stmt|;
name|MERR
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_MERR
argument_list|)
expr_stmt|;
name|FEBE
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_FEBE
argument_list|)
expr_stmt|;
comment|/* CV is invalid during LOS. */
if|if
condition|(
operator|(
name|stat16
operator|&
name|STAT16_RLOS
operator|)
operator|!=
literal|0
condition|)
name|CV
operator|=
literal|0
expr_stmt|;
comment|/* CERR& FEBE are invalid in M13 mode */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_T3M13
condition|)
name|CERR
operator|=
name|FEBE
operator|=
literal|0
expr_stmt|;
comment|/* FEBE is invalid during AIS. */
if|if
condition|(
operator|(
name|stat16
operator|&
name|STAT16_RAIS
operator|)
operator|!=
literal|0
condition|)
name|FEBE
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
operator|&&
operator|(
name|CV
operator|||
name|PERR
operator|||
name|CERR
operator|||
name|FERR
operator|||
name|MERR
operator|||
name|FEBE
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: CV=%u PERR=%u CERR=%u FERR=%u MERR=%u FEBE=%u\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|CV
argument_list|,
name|PERR
argument_list|,
name|CERR
argument_list|,
name|FERR
argument_list|,
name|MERR
argument_list|,
name|FEBE
argument_list|)
expr_stmt|;
comment|/* Driver keeps crude link-level error counters (SNMP is better). */
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|lcv_errs
operator|+=
name|CV
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|par_errs
operator|+=
name|PERR
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|cpar_errs
operator|+=
name|CERR
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|frm_errs
operator|+=
name|FERR
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|mfrm_errs
operator|+=
name|MERR
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|febe_errs
operator|+=
name|FEBE
expr_stmt|;
comment|/* Check for FEAC messages (FEAC not defined in M13 mode). */
if|if
condition|(
name|FORMAT_T3CPAR
operator|&&
operator|(
name|stat16
operator|&
name|STAT16_FEAC
operator|)
condition|)
do|do
block|{
name|feac
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_FEAC_STK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|feac
operator|&
name|FEAC_STK_VALID
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* Ignore RxFEACs while a far end loopback has been requested. */
if|if
condition|(
operator|(
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator|&
name|TLOOP_FAR_LINE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|feac
operator|&
name|FEAC_STK_FEAC
condition|)
block|{
case|case
name|T3BOP_LINE_UP
case|:
break|break;
case|case
name|T3BOP_LINE_DOWN
case|:
break|break;
case|case
name|T3BOP_LOOP_DS3
case|:
block|{
if|if
condition|(
name|sc
operator|->
name|last_FEAC
operator|==
name|T3BOP_LINE_DOWN
condition|)
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'line loopback deactivate' FEAC msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|loop_timer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|last_FEAC
operator|==
name|T3BOP_LINE_UP
condition|)
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'line loopback activate' FEAC msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|loop_timer
operator|=
literal|300
expr_stmt|;
block|}
break|break;
block|}
case|case
name|T3BOP_OOF
case|:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'far end LOF' FEAC msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T3BOP_IDLE
case|:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'far end IDL' FEAC msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T3BOP_AIS
case|:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'far end AIS' FEAC msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T3BOP_LOS
case|:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'far end LOS' FEAC msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'type 0x%02X' FEAC msg\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|feac
operator|&
name|FEAC_STK_FEAC
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|last_FEAC
operator|=
name|feac
operator|&
name|FEAC_STK_FEAC
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|feac
operator|&
name|FEAC_STK_MORE
operator|)
operator|!=
literal|0
condition|)
do|;
name|stat16
operator|&=
operator|~
name|STAT16_FEAC
expr_stmt|;
comment|/* Send Service-Affecting priority FEAC messages */
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|last_stat16
operator|^
name|stat16
operator|)
operator|&
literal|0xF0
operator|)
operator|&&
operator|(
name|FORMAT_T3CPAR
operator|)
condition|)
block|{
comment|/* Transmit continuous FEACs */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL14
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL14
argument_list|)
operator|&
operator|~
name|CTL14_FEAC10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat16
operator|&
name|STAT16_RLOS
operator|)
operator|!=
literal|0
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|,
literal|0xC0
operator|+
name|T3BOP_LOS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|stat16
operator|&
name|STAT16_ROOF
operator|)
operator|!=
literal|0
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|,
literal|0xC0
operator|+
name|T3BOP_OOF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|stat16
operator|&
name|STAT16_RAIS
operator|)
operator|!=
literal|0
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|,
literal|0xC0
operator|+
name|T3BOP_AIS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|stat16
operator|&
name|STAT16_RIDL
operator|)
operator|!=
literal|0
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|,
literal|0xC0
operator|+
name|T3BOP_IDLE
argument_list|)
expr_stmt|;
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|,
name|CTL5_EMODE
argument_list|)
expr_stmt|;
block|}
comment|/* Start sending RAI, Remote Alarm Indication. */
if|if
condition|(
operator|(
operator|(
name|stat16
operator|&
name|STAT16_ROOF
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|stat16
operator|&
name|STAT16_RLOS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|last_stat16
operator|&
name|STAT16_ROOF
operator|)
operator|==
literal|0
operator|)
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|,
name|ctl1
operator|&=
operator|~
name|CTL1_XTX
argument_list|)
expr_stmt|;
comment|/* Stop sending RAI, Remote Alarm Indication. */
elseif|else
if|if
condition|(
operator|(
operator|(
name|stat16
operator|&
name|STAT16_ROOF
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|last_stat16
operator|&
name|STAT16_ROOF
operator|)
operator|!=
literal|0
operator|)
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|,
name|ctl1
operator||=
name|CTL1_XTX
argument_list|)
expr_stmt|;
comment|/* Start sending AIS, Alarm Indication Signal */
if|if
condition|(
operator|(
operator|(
name|stat16
operator|&
name|STAT16_RLOS
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|last_stat16
operator|&
name|STAT16_RLOS
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_FRAME
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|,
name|ctl1
operator||
name|CTL1_TXAIS
argument_list|)
expr_stmt|;
block|}
comment|/* Stop sending AIS, Alarm Indication Signal */
elseif|else
if|if
condition|(
operator|(
operator|(
name|stat16
operator|&
name|STAT16_RLOS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|last_stat16
operator|&
name|STAT16_RLOS
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_FRAME
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|,
name|ctl1
operator|&
operator|~
name|CTL1_TXAIS
argument_list|)
expr_stmt|;
block|}
comment|/* Time out loopback requests. */
if|if
condition|(
name|sc
operator|->
name|loop_timer
operator|!=
literal|0
condition|)
if|if
condition|(
operator|--
name|sc
operator|->
name|loop_timer
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|mii16
operator|&
name|MII16_DS3_LNLBK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Timeout: Loop Down after 300 seconds\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
comment|/* line loopback off */
block|}
comment|/* SNMP error counters */
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|lcv
operator|=
name|CV
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|pcv
operator|=
name|PERR
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|ccv
operator|=
name|CERR
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|febe
operator|=
name|FEBE
expr_stmt|;
comment|/* SNMP Line Status */
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ctl1
operator|&
name|CTL1_XTX
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator||=
name|TLINE_TX_RAI
expr_stmt|;
if|if
condition|(
name|stat16
operator|&
name|STAT16_XERR
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator||=
name|TLINE_RX_RAI
expr_stmt|;
if|if
condition|(
name|ctl1
operator|&
name|CTL1_TXAIS
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator||=
name|TLINE_TX_AIS
expr_stmt|;
if|if
condition|(
name|stat16
operator|&
name|STAT16_RAIS
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator||=
name|TLINE_RX_AIS
expr_stmt|;
if|if
condition|(
name|stat16
operator|&
name|STAT16_ROOF
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator||=
name|TLINE_LOF
expr_stmt|;
if|if
condition|(
name|stat16
operator|&
name|STAT16_RLOS
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator||=
name|TLINE_LOS
expr_stmt|;
if|if
condition|(
name|stat16
operator|&
name|STAT16_SEF
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|line
operator||=
name|T3LINE_SEF
expr_stmt|;
comment|/* SNMP Loopback Status */
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|loop
operator|&=
operator|~
name|TLOOP_FAR_LINE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_TULIP
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|loop
operator||=
name|TLOOP_NEAR_OTHER
expr_stmt|;
if|if
condition|(
name|ctl1
operator|&
name|CTL1_3LOOP
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|loop
operator||=
name|TLOOP_NEAR_INWARD
expr_stmt|;
if|if
condition|(
name|mii16
operator|&
name|MII16_DS3_TRLBK
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|loop
operator||=
name|TLOOP_NEAR_OTHER
expr_stmt|;
if|if
condition|(
name|mii16
operator|&
name|MII16_DS3_LNLBK
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|loop
operator||=
name|TLOOP_NEAR_LINE
expr_stmt|;
comment|/*if (ctl12& CTL12_RTPLOOP)   sc->status.snmp.t3.loop |= TLOOP_NEAR_PAYLOAD; */
comment|/* Remember this state until next time. */
name|sc
operator|->
name|last_stat16
operator|=
name|stat16
expr_stmt|;
comment|/* If an INWARD loopback is in effect, link status is UP */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|!=
name|CFG_LOOP_NONE
condition|)
comment|/* XXX INWARD ONLY */
name|link_status
operator|=
name|STATUS_UP
expr_stmt|;
return|return
name|link_status
return|;
block|}
end_function

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|void
name|t3_send_dbl_feac
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|feac1
parameter_list|,
name|int
name|feac2
parameter_list|)
block|{
name|u_int8_t
name|tx_feac
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The FEAC transmitter could be sending a continuous */
comment|/*  FEAC msg when told to send a double FEAC message. */
comment|/* So save the current state of the FEAC transmitter. */
name|tx_feac
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|)
expr_stmt|;
comment|/* Load second FEAC code and stop FEAC transmitter. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|,
name|CTL5_EMODE
operator|+
name|feac2
argument_list|)
expr_stmt|;
comment|/* FEAC transmitter sends 10 more FEACs and then stops. */
name|SLEEP
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
comment|/* sending one FEAC takes 1700 uSecs */
comment|/* Load first FEAC code and start FEAC transmitter. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_DBL_FEAC
argument_list|,
name|CTL13_DFEXEC
operator|+
name|feac1
argument_list|)
expr_stmt|;
comment|/* Wait for double FEAC sequence to complete -- about 70 ms. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
comment|/* max delay 100 ms */
if|if
condition|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_DBL_FEAC
argument_list|)
operator|&
name|CTL13_DFEXEC
condition|)
name|SLEEP
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Flush received FEACS; don't respond to our own loop cmd! */
while|while
condition|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_FEAC_STK
argument_list|)
operator|&
name|FEAC_STK_VALID
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX HANG */
comment|/* Restore previous state of the FEAC transmitter. */
comment|/* If it was sending a continous FEAC, it will resume. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_TX_FEAC
argument_list|,
name|tx_feac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|int
name|t3_ioctl
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ioctl
modifier|*
name|ioctl
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ioctl
operator|->
name|cmd
condition|)
block|{
case|case
name|IOCTL_SNMP_SEND
case|:
comment|/* set opstatus? */
block|{
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|!=
name|CFG_FORMAT_T3CPAR
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|TSEND_LINE
condition|)
block|{
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|loop
operator||=
name|TLOOP_FAR_LINE
expr_stmt|;
name|t3_send_dbl_feac
argument_list|(
name|sc
argument_list|,
name|T3BOP_LINE_UP
argument_list|,
name|T3BOP_LOOP_DS3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|TSEND_RESET
condition|)
block|{
name|t3_send_dbl_feac
argument_list|(
name|sc
argument_list|,
name|T3BOP_LINE_DOWN
argument_list|,
name|T3BOP_LOOP_DS3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t3
operator|.
name|loop
operator|&=
operator|~
name|TLOOP_FAR_LINE
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
case|case
name|IOCTL_SNMP_LOOP
case|:
comment|/* set opstatus = test? */
block|{
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_NONE
condition|)
block|{
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_FRAME
argument_list|)
expr_stmt|;
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_TRLBK
argument_list|)
expr_stmt|;
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|)
operator|&
operator|~
name|CTL1_3LOOP
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|)
operator|&
operator|~
operator|(
name|CTL12_RTPLOOP
operator||
name|CTL12_RTPLLEN
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_LINE
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_OTHER
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_TRLBK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_INWARD
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|)
operator||
name|CTL1_3LOOP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_DUAL
condition|)
block|{
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_LNLBK
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL1
argument_list|)
operator||
name|CTL1_3LOOP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_PAYLOAD
condition|)
block|{
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_DS3_FRAME
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|)
operator||
name|CTL12_RTPLOOP
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|)
operator||
name|CTL12_RTPLLEN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* at least two frames (22 uS) */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|T3CSR_CTL12
argument_list|)
operator|&
operator|~
name|CTL12_RTPLLEN
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* begin SSI card code */
end_comment

begin_comment
comment|/* Must not sleep. */
end_comment

begin_function
specifier|static
name|void
name|ssi_config
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|card_type
operator|==
literal|0
condition|)
block|{
comment|/* defaults */
name|sc
operator|->
name|status
operator|.
name|card_type
operator|=
name|TLP_CSID_SSI
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|=
name|CFG_CRC_16
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|=
name|CFG_LOOP_NONE
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|tx_clk_src
operator|=
name|CFG_CLKMUX_ST
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|dte_dce
operator|=
name|CFG_DTE
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|n
operator|=
literal|51
expr_stmt|;
comment|/* 1.536 MHz */
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|m
operator|=
literal|83
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|v
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|x
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|r
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|synth
operator|.
name|prescale
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Disable the TX clock driver while programming the oscillator. */
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_DCE
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_DCE
argument_list|)
expr_stmt|;
comment|/* Program the synthesized oscillator. */
name|write_synth
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|config
operator|.
name|synth
argument_list|)
expr_stmt|;
comment|/* Set DTE/DCE mode. */
comment|/* If DTE mode then DCD& TXC are received. */
comment|/* If DCE mode then DCD& TXC are driven. */
comment|/* Boards with MII rev=4.0 don't drive DCD. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|dte_dce
operator|==
name|CFG_DCE
condition|)
name|set_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_DCE
argument_list|)
expr_stmt|;
else|else
name|clr_gpio_bits
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_DCE
argument_list|)
expr_stmt|;
name|make_gpio_output
argument_list|(
name|sc
argument_list|,
name|GPIO_SSI_DCE
argument_list|)
expr_stmt|;
comment|/* Set CRC length. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|==
name|CFG_CRC_32
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_CRC32
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_CRC32
argument_list|)
expr_stmt|;
comment|/* Loop towards host thru cable drivers and receivers. */
comment|/* Asserts DCD at the far end of a null modem cable. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_PINS
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LOOP
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LOOP
argument_list|)
expr_stmt|;
comment|/* Assert pin LL in modem conn: ask modem for local loop. */
comment|/* Asserts TM at the far end of a null modem cable. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_LL
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LL
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LL
argument_list|)
expr_stmt|;
comment|/* Assert pin RL in modem conn: ask modem for remote loop. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_RL
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_RL
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_RL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssi_ident
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|printf
argument_list|(
literal|", LTC1343/44"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called once a second; must not sleep. */
end_comment

begin_function
specifier|static
name|int
name|ssi_watchdog
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|cable
decl_stmt|;
name|u_int16_t
name|mii16
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
operator|&
name|MII16_SSI_MODEM
decl_stmt|;
name|int
name|link_status
init|=
name|STATUS_UP
decl_stmt|;
comment|/* Software is alive. */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LED_UL
argument_list|)
expr_stmt|;
comment|/* Check the transmit clock. */
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|tx_speed
operator|==
literal|0
condition|)
block|{
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LED_UR
argument_list|)
expr_stmt|;
name|link_status
operator|=
name|STATUS_DOWN
expr_stmt|;
block|}
else|else
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LED_UR
argument_list|)
expr_stmt|;
comment|/* Check the external cable. */
name|cable
operator|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|cable
operator|=
name|cable
operator|&
name|MII17_SSI_CABLE_MASK
expr_stmt|;
name|cable
operator|=
name|cable
operator|>>
name|MII17_SSI_CABLE_SHIFT
expr_stmt|;
if|if
condition|(
name|cable
operator|==
literal|7
condition|)
block|{
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LED_LL
argument_list|)
expr_stmt|;
comment|/* no cable */
name|link_status
operator|=
name|STATUS_DOWN
expr_stmt|;
block|}
else|else
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LED_LL
argument_list|)
expr_stmt|;
comment|/* The unit at the other end of the cable is ready if: */
comment|/*  DTE mode and DCD pin is asserted */
comment|/*  DCE mode and DSR pin is asserted */
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|config
operator|.
name|dte_dce
operator|==
name|CFG_DTE
operator|)
operator|&&
operator|(
operator|(
name|mii16
operator|&
name|MII16_SSI_DCD
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|sc
operator|->
name|config
operator|.
name|dte_dce
operator|==
name|CFG_DCE
operator|)
operator|&&
operator|(
operator|(
name|mii16
operator|&
name|MII16_SSI_DSR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LED_LR
argument_list|)
expr_stmt|;
name|link_status
operator|=
name|STATUS_DOWN
expr_stmt|;
block|}
else|else
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_SSI_LED_LR
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
operator|&&
operator|(
name|cable
operator|!=
name|sc
operator|->
name|status
operator|.
name|cable_type
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: SSI cable type changed to '%s'\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|ssi_cables
index|[
name|cable
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cable_type
operator|=
name|cable
expr_stmt|;
comment|/* Print the modem control signals if they changed. */
if|if
condition|(
operator|(
name|DRIVER_DEBUG
operator|)
operator|&&
operator|(
name|mii16
operator|!=
name|sc
operator|->
name|last_mii16
operator|)
condition|)
block|{
name|char
modifier|*
name|on
init|=
literal|"ON "
decl_stmt|,
modifier|*
name|off
init|=
literal|"OFF"
decl_stmt|;
name|printf
argument_list|(
literal|"%s: DTR=%s DSR=%s RTS=%s CTS=%s DCD=%s RI=%s LL=%s RL=%s TM=%s\n"
argument_list|,
name|NAME_UNIT
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_DTR
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_DSR
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_RTS
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_CTS
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_DCD
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_RI
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_LL
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_RL
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|mii16
operator|&
name|MII16_SSI_TM
operator|)
condition|?
name|on
else|:
name|off
argument_list|)
expr_stmt|;
block|}
comment|/* SNMP one-second report */
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|ssi
operator|.
name|sigs
operator|=
name|mii16
operator|&
name|MII16_SSI_MODEM
expr_stmt|;
comment|/* Remember this state until next time. */
name|sc
operator|->
name|last_mii16
operator|=
name|mii16
expr_stmt|;
comment|/* If a loop back is in effect, link status is UP */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|!=
name|CFG_LOOP_NONE
condition|)
name|link_status
operator|=
name|STATUS_UP
expr_stmt|;
return|return
name|link_status
return|;
block|}
end_function

begin_comment
comment|/* IOCTL SYSCALL: can sleep (but doesn't). */
end_comment

begin_function
specifier|static
name|int
name|ssi_ioctl
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ioctl
modifier|*
name|ioctl
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_SNMP_SIGS
condition|)
block|{
name|u_int16_t
name|mii16
init|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|mii16
operator|&=
operator|~
name|MII16_SSI_MODEM
expr_stmt|;
name|mii16
operator||=
operator|(
name|MII16_SSI_MODEM
operator|&
name|ioctl
operator|->
name|data
operator|)
expr_stmt|;
name|write_mii
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|,
name|mii16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_SET_STATUS
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|data
operator|!=
literal|0
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
operator|(
name|MII16_SSI_DTR
operator||
name|MII16_SSI_RTS
operator||
name|MII16_SSI_DCD
operator|)
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
operator|(
name|MII16_SSI_DTR
operator||
name|MII16_SSI_RTS
operator||
name|MII16_SSI_DCD
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* begin T1E1 card code */
end_comment

begin_comment
comment|/* Must not sleep. */
end_comment

begin_function
specifier|static
name|void
name|t1_config
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|pulse
decl_stmt|,
name|lbo
decl_stmt|,
name|gain
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|card_type
operator|==
literal|0
condition|)
block|{
comment|/* defaults */
name|sc
operator|->
name|status
operator|.
name|card_type
operator|=
name|TLP_CSID_T1E1
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|=
name|CFG_CRC_16
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|=
name|CFG_LOOP_NONE
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|tx_clk_src
operator|=
name|CFG_CLKMUX_INT
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|format
operator|=
name|CFG_FORMAT_T1ESF
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|=
literal|10
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|time_slots
operator|=
literal|0x01FFFFFE
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|tx_pulse
operator|=
name|CFG_PULSE_AUTO
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|rx_gain
operator|=
name|CFG_GAIN_AUTO
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|tx_lbo
operator|=
name|CFG_LBO_AUTO
expr_stmt|;
comment|/* Bt8370 occasionally powers up in a loopback mode. */
comment|/* Data sheet says zero LOOP reg and do a s/w reset. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* no loopback */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CR0
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* s/w reset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
comment|/* max delay 10 ms */
if|if
condition|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CR0
argument_list|)
operator|&
literal|0x80
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* Set CRC length. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|==
name|CFG_CRC_32
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_T1_CRC32
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_T1_CRC32
argument_list|)
expr_stmt|;
comment|/* Invert HDLC payload data in SF/AMI mode. */
comment|/* HDLC stuff bits satisfy T1 pulse density. */
if|if
condition|(
name|FORMAT_T1SF
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_T1_INVERT
argument_list|)
expr_stmt|;
else|else
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_T1_INVERT
argument_list|)
expr_stmt|;
comment|/* Set the transmitter output impedance. */
if|if
condition|(
name|FORMAT_E1ANY
condition|)
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_T1_Z
argument_list|)
expr_stmt|;
comment|/* 001:CR0 -- Control Register 0 - T1/E1 and frame format */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CR0
argument_list|,
name|sc
operator|->
name|config
operator|.
name|format
argument_list|)
expr_stmt|;
comment|/* 002:JAT_CR -- Jitter Attenuator Control Register */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|tx_clk_src
operator|==
name|CFG_CLKMUX_RT
condition|)
comment|/* loop timing */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_JAT_CR
argument_list|,
literal|0xA3
argument_list|)
expr_stmt|;
comment|/* JAT in RX path */
else|else
block|{
comment|/* 64-bit elastic store; free-running JCLK and CLADO */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_JAT_CR
argument_list|,
literal|0x4B
argument_list|)
expr_stmt|;
comment|/* assert jcenter */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_JAT_CR
argument_list|,
literal|0x43
argument_list|)
expr_stmt|;
comment|/* release jcenter */
block|}
comment|/* 00C-013:IERn -- Interrupt Enable Registers */
for|for
control|(
name|i
operator|=
name|Bt8370_IER7
init|;
name|i
operator|<=
name|Bt8370_IER0
condition|;
name|i
operator|++
control|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* no interrupts; polled */
comment|/* 014:LOOP -- loopbacks */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_PAYLOAD
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|LOOP_PAYLOAD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_LINE
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|LOOP_LINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_OTHER
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|LOOP_ANALOG
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_INWARD
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|LOOP_FRAMER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_DUAL
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|LOOP_DUAL
argument_list|)
expr_stmt|;
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* no loopback */
comment|/* 015:DL3_TS -- Data Link 3 */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_DL3_TS
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* disabled */
comment|/* 018:PIO -- Programmable I/O */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_PIO
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* all pins are outputs */
comment|/* 019:POE -- Programmable Output Enable */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_POE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* all outputs are enabled */
comment|/* 01A;CMUX -- Clock Input Mux */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|tx_clk_src
operator|==
name|CFG_CLKMUX_EXT
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CMUX
argument_list|,
literal|0x0C
argument_list|)
expr_stmt|;
comment|/* external timing */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CMUX
argument_list|,
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* internal timing */
comment|/* 020:LIU_CR -- Line Interface Unit Config Register */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LIU_CR
argument_list|,
literal|0xC1
argument_list|)
expr_stmt|;
comment|/* reset LIU, squelch */
comment|/* 022:RLIU_CR -- RX Line Interface Unit Config Reg */
comment|/* Errata sheet says don't use freeze-short, but we do anyway! */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RLIU_CR
argument_list|,
literal|0xB1
argument_list|)
expr_stmt|;
comment|/* AGC=2048, Long Eye */
comment|/* Select Rx sensitivity based on cable length. */
if|if
condition|(
operator|(
name|gain
operator|=
name|sc
operator|->
name|config
operator|.
name|rx_gain
operator|)
operator|==
name|CFG_GAIN_AUTO
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|2000
condition|)
name|gain
operator|=
name|CFG_GAIN_EXTEND
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|1000
condition|)
name|gain
operator|=
name|CFG_GAIN_LONG
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|100
condition|)
name|gain
operator|=
name|CFG_GAIN_MEDIUM
expr_stmt|;
else|else
name|gain
operator|=
name|CFG_GAIN_SHORT
expr_stmt|;
block|}
comment|/* 024:VGA_MAX -- Variable Gain Amplifier Max gain */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_VGA_MAX
argument_list|,
name|gain
argument_list|)
expr_stmt|;
comment|/* 028:PRE_EQ -- Pre Equalizer */
if|if
condition|(
name|gain
operator|==
name|CFG_GAIN_EXTEND
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_PRE_EQ
argument_list|,
literal|0xE6
argument_list|)
expr_stmt|;
comment|/* ON; thresh 6 */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_PRE_EQ
argument_list|,
literal|0xA6
argument_list|)
expr_stmt|;
comment|/* OFF; thresh 6 */
comment|/* 038-03C:GAINn -- RX Equalizer gain thresholds */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_GAIN0
argument_list|,
literal|0x24
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_GAIN1
argument_list|,
literal|0x28
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_GAIN2
argument_list|,
literal|0x2C
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_GAIN3
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_GAIN4
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
comment|/* 040:RCR0 -- Receiver Control Register 0 */
if|if
condition|(
name|FORMAT_T1ESF
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RCR0
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* B8ZS, 2/5 FErrs */
elseif|else
if|if
condition|(
name|FORMAT_T1SF
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RCR0
argument_list|,
literal|0x84
argument_list|)
expr_stmt|;
comment|/* AMI,  2/5 FErrs */
elseif|else
if|if
condition|(
name|FORMAT_E1NONE
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RCR0
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
comment|/* HDB3, rabort */
elseif|else
if|if
condition|(
name|FORMAT_E1CRC
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RCR0
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
comment|/* HDB3, 3 FErrs or 915 CErrs */
else|else
comment|/* E1 no CRC */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RCR0
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
comment|/* HDB3, 3 FErrs */
comment|/* 041:RPATT -- Receive Test Pattern configuration */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RPATT
argument_list|,
literal|0x3E
argument_list|)
expr_stmt|;
comment|/* looking for framed QRSS */
comment|/* 042:RLB -- Receive Loop Back code detector config */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RLB
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
comment|/* 6 bits down; 5 bits up */
comment|/* 043:LBA -- Loop Back Activate code */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LBA
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* 10000 10000 10000 ... */
comment|/* 044:LBD -- Loop Back Deactivate code */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LBD
argument_list|,
literal|0x24
argument_list|)
expr_stmt|;
comment|/* 100100 100100 100100 ... */
comment|/* 045:RALM -- Receive Alarm signal configuration */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RALM
argument_list|,
literal|0x0C
argument_list|)
expr_stmt|;
comment|/* yel_intg rlof_intg */
comment|/* 046:LATCH -- Alarm/Error/Counter Latch register */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LATCH
argument_list|,
literal|0x1F
argument_list|)
expr_stmt|;
comment|/* stop_cnt latch_{cnt,err,alm} */
comment|/* Select Pulse Shape based on cable length (T1 only). */
if|if
condition|(
operator|(
name|pulse
operator|=
name|sc
operator|->
name|config
operator|.
name|tx_pulse
operator|)
operator|==
name|CFG_PULSE_AUTO
condition|)
block|{
if|if
condition|(
name|FORMAT_T1ANY
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|200
condition|)
name|pulse
operator|=
name|CFG_PULSE_T1CSU
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|160
condition|)
name|pulse
operator|=
name|CFG_PULSE_T1DSX4
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|120
condition|)
name|pulse
operator|=
name|CFG_PULSE_T1DSX3
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|80
condition|)
name|pulse
operator|=
name|CFG_PULSE_T1DSX2
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|40
condition|)
name|pulse
operator|=
name|CFG_PULSE_T1DSX1
expr_stmt|;
else|else
name|pulse
operator|=
name|CFG_PULSE_T1DSX0
expr_stmt|;
block|}
else|else
name|pulse
operator|=
name|CFG_PULSE_E1TWIST
expr_stmt|;
block|}
comment|/* Select Line Build Out based on cable length (T1CSU only). */
if|if
condition|(
operator|(
name|lbo
operator|=
name|sc
operator|->
name|config
operator|.
name|tx_lbo
operator|)
operator|==
name|CFG_LBO_AUTO
condition|)
block|{
if|if
condition|(
name|pulse
operator|==
name|CFG_PULSE_T1CSU
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|1500
condition|)
name|lbo
operator|=
name|CFG_LBO_0DB
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|1000
condition|)
name|lbo
operator|=
name|CFG_LBO_7DB
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|cable_len
operator|>
literal|500
condition|)
name|lbo
operator|=
name|CFG_LBO_15DB
expr_stmt|;
else|else
name|lbo
operator|=
name|CFG_LBO_22DB
expr_stmt|;
block|}
else|else
name|lbo
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 068:TLIU_CR -- Transmit LIU Control Register */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TLIU_CR
argument_list|,
operator|(
literal|0x40
operator||
operator|(
name|lbo
operator|&
literal|0x30
operator|)
operator||
operator|(
name|pulse
operator|&
literal|0x0E
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 070:TCR0 -- Transmit Framer Configuration */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TCR0
argument_list|,
name|sc
operator|->
name|config
operator|.
name|format
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* 071:TCR1 -- Transmitter Configuration */
if|if
condition|(
name|FORMAT_T1SF
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TCR1
argument_list|,
literal|0x43
argument_list|)
expr_stmt|;
comment|/* tabort, AMI PDV enforced */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TCR1
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
comment|/* tabort, B8ZS or HDB3 */
comment|/* 072:TFRM -- Transmit Frame format       MYEL YEL MF FE CRC FBIT */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_T1ESF
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TFRM
argument_list|,
literal|0x0B
argument_list|)
expr_stmt|;
comment|/*  -   YEL MF -  CRC FBIT */
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_T1SF
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TFRM
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
comment|/*  -   YEL MF -   -  FBIT */
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_E1FAS
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TFRM
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/*  -   YEL -  -   -  FBIT */
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_E1FASCRC
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TFRM
argument_list|,
literal|0x1F
argument_list|)
expr_stmt|;
comment|/*  -   YEL MF FE CRC FBIT */
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_E1FASCAS
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TFRM
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
comment|/* MYEL YEL -  -   -  FBIT */
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_E1FASCRCCAS
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TFRM
argument_list|,
literal|0x3F
argument_list|)
expr_stmt|;
comment|/* MYEL YEL MF FE CRC FBIT */
elseif|else
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|format
operator|==
name|CFG_FORMAT_E1NONE
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TFRM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* NO FRAMING BITS AT ALL! */
comment|/* 073:TERROR -- Transmit Error Insert */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TERROR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* no errors, please! */
comment|/* 074:TMAN -- Transmit Manual Sa-byte/FEBE configuration */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TMAN
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* none */
comment|/* 075:TALM -- Transmit Alarm Signal Configuration */
if|if
condition|(
name|FORMAT_E1ANY
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TALM
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
comment|/* auto_myel auto_yel auto_ais */
elseif|else
if|if
condition|(
name|FORMAT_T1ANY
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TALM
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
comment|/* auto_yel auto_ais */
comment|/* 076:TPATT -- Transmit Test Pattern Configuration */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TPATT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* disabled */
comment|/* 077:TLB -- Transmit Inband Loopback Code Configuration */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TLB
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* disabled */
comment|/* 090:CLAD_CR -- Clack Rate Adapter Configuration */
if|if
condition|(
name|FORMAT_T1ANY
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CLAD_CR
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
comment|/* loop filter gain 1/2^6 */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CLAD_CR
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* loop filter gain 1/2^8 */
comment|/* 091:CSEL -- CLAD frequency Select */
if|if
condition|(
name|FORMAT_T1ANY
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CSEL
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
comment|/* 1544 kHz */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CSEL
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* 2048 kHz */
comment|/* 092:CPHASE -- CLAD Phase detector */
if|if
condition|(
name|FORMAT_T1ANY
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CPHASE
argument_list|,
literal|0x22
argument_list|)
expr_stmt|;
comment|/* phase compare @  386 kHz */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CPHASE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* phase compare @ 2048 kHz */
if|if
condition|(
name|FORMAT_T1ESF
condition|)
comment|/* BOP& PRM are enabled in T1ESF mode only. */
block|{
comment|/* 0A0:BOP -- Bit Oriented Protocol messages */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP
argument_list|,
name|RBOP_25
operator||
name|TBOP_OFF
argument_list|)
expr_stmt|;
comment|/* 0A4:DL1_TS -- Data Link 1 Time Slot Enable */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_DL1_TS
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* FDL bits in odd frames */
comment|/* 0A6:DL1_CTL -- Data Link 1 Control */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_DL1_CTL
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* FCS mode, TX on, RX on */
comment|/* 0A7:RDL1_FFC -- Rx Data Link 1 Fifo Fill Control */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RDL1_FFC
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* assert "near full" at 48 */
comment|/* 0AA:PRM -- Performance Report Messages */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_PRM
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
block|}
comment|/* 0D0:SBI_CR -- System Bus Interface Configuration Register */
if|if
condition|(
name|FORMAT_T1ANY
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_SBI_CR
argument_list|,
literal|0x47
argument_list|)
expr_stmt|;
comment|/* 1.544 with 24 TS +Fbits */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_SBI_CR
argument_list|,
literal|0x46
argument_list|)
expr_stmt|;
comment|/* 2.048 with 32 TS */
comment|/* 0D1:RSB_CR -- Receive System Bus Configuration Register */
comment|/* Change RINDO& RFSYNC on falling edge of RSBCLKI. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RSB_CR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* 0D2,0D3:RSYNC_{TS,BIT} -- Receive frame Sync offset */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RSYNC_BIT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RSYNC_TS
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 0D4:TSB_CR -- Transmit System Bus Configuration Register */
comment|/* Change TINDO& TFSYNC on falling edge of TSBCLKI. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TSB_CR
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* 0D5,0D6:TSYNC_{TS,BIT} -- Transmit frame Sync offset */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TSYNC_BIT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TSYNC_TS
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 0D7:RSIG_CR -- Receive SIGnalling Configuratin Register */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RSIG_CR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Assign and configure 64Kb TIME SLOTS. */
comment|/* TS24..TS1 must be assigned for T1, TS31..TS0 for E1. */
comment|/* Timeslots with no user data have RINDO and TINDO off. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* 0E0-0FF:SBCn -- System Bus Per-Channel Control */
if|if
condition|(
name|FORMAT_T1ANY
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|i
operator|>
literal|24
operator|)
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_SBCn
operator|+
name|i
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* not assigned in T1 mode */
elseif|else
if|if
condition|(
name|FORMAT_E1ANY
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|!
name|FORMAT_E1NONE
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_SBCn
operator|+
name|i
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* assigned, TS0  o/h bits */
elseif|else
if|if
condition|(
name|FORMAT_E1CAS
operator|&&
operator|(
name|i
operator|==
literal|16
operator|)
operator|&&
operator|!
name|FORMAT_E1NONE
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_SBCn
operator|+
name|i
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* assigned, TS16 o/h bits */
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|time_slots
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_SBCn
operator|+
name|i
argument_list|,
literal|0x0D
argument_list|)
expr_stmt|;
comment|/* assigned, RINDO, TINDO */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_SBCn
operator|+
name|i
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* assigned, idle */
comment|/* 100-11F:TPCn -- Transmit Per-Channel Control */
if|if
condition|(
name|FORMAT_E1CAS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TPCn
operator|+
name|i
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* tidle, sig=0000 (MAS) */
elseif|else
if|if
condition|(
name|FORMAT_E1CAS
operator|&&
operator|(
name|i
operator|==
literal|16
operator|)
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TPCn
operator|+
name|i
argument_list|,
literal|0x3B
argument_list|)
expr_stmt|;
comment|/* tidle, sig=1011 (XYXX) */
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|time_slots
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TPCn
operator|+
name|i
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* tidle: use TSLIP_LOn */
else|else
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TPCn
operator|+
name|i
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* nothing special */
comment|/* 140-15F:TSLIP_LOn -- Transmit PCM Slip Buffer */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TSLIP_LOn
operator|+
name|i
argument_list|,
literal|0x7F
argument_list|)
expr_stmt|;
comment|/* idle chan data */
comment|/* 180-19F:RPCn -- Receive Per-Channel Control */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RPCn
operator|+
name|i
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* nothing special */
block|}
comment|/* Enable transmitter output drivers. */
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_T1_XOE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|t1_ident
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|printf
argument_list|(
literal|", Bt837%x rev %x"
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_DID
argument_list|)
operator|>>
literal|4
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_DID
argument_list|)
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called once a second; must not sleep. */
end_comment

begin_function
specifier|static
name|int
name|t1_watchdog
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|LCV
init|=
literal|0
decl_stmt|,
name|FERR
init|=
literal|0
decl_stmt|,
name|CRC
init|=
literal|0
decl_stmt|,
name|FEBE
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|alm1
decl_stmt|,
name|alm3
decl_stmt|,
name|loop
decl_stmt|,
name|isr0
decl_stmt|;
name|int
name|link_status
init|=
name|STATUS_UP
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Read the alarm registers */
name|alm1
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_ALM1
argument_list|)
expr_stmt|;
name|alm3
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_ALM3
argument_list|)
expr_stmt|;
name|loop
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|)
expr_stmt|;
name|isr0
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_ISR0
argument_list|)
expr_stmt|;
comment|/* Always ignore the SIGFRZ alarm bit, */
name|alm1
operator|&=
operator|~
name|ALM1_SIGFRZ
expr_stmt|;
if|if
condition|(
name|FORMAT_T1ANY
condition|)
comment|/* ignore RYEL in T1 modes */
name|alm1
operator|&=
operator|~
name|ALM1_RYEL
expr_stmt|;
elseif|else
if|if
condition|(
name|FORMAT_E1NONE
condition|)
comment|/* ignore all alarms except LOS */
name|alm1
operator|&=
name|ALM1_RLOS
expr_stmt|;
comment|/* Software is alive. */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_GRN
argument_list|)
expr_stmt|;
comment|/* Receiving Alarm Indication Signal (AIS). */
if|if
condition|(
operator|(
name|alm1
operator|&
name|ALM1_RAIS
operator|)
operator|!=
literal|0
condition|)
comment|/* receiving ais */
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_BLU
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|alm1
operator|&
name|ALM1_RLOS
operator|)
operator|!=
literal|0
condition|)
comment|/* sending ais */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_BLU
argument_list|)
expr_stmt|;
else|else
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_BLU
argument_list|)
expr_stmt|;
comment|/* Receiving Remote Alarm Indication (RAI). */
if|if
condition|(
operator|(
name|alm1
operator|&
operator|(
name|ALM1_RMYEL
operator||
name|ALM1_RYEL
operator|)
operator|)
operator|!=
literal|0
condition|)
comment|/* receiving rai */
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_YEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|alm1
operator|&
name|ALM1_RLOF
operator|)
operator|!=
literal|0
condition|)
comment|/* sending rai */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_YEL
argument_list|)
expr_stmt|;
else|else
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_YEL
argument_list|)
expr_stmt|;
comment|/* If any alarm bits are set then the link is 'down'. */
comment|/* The bad bits are: rmyel ryel rais ralos rlos rlof. */
comment|/* Some alarm bits have been masked by this point. */
if|if
condition|(
name|alm1
operator|!=
literal|0
condition|)
name|link_status
operator|=
name|STATUS_DOWN
expr_stmt|;
comment|/* Declare local Red Alarm if the link is down. */
if|if
condition|(
name|link_status
operator|==
name|STATUS_DOWN
condition|)
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_RED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|loop_timer
operator|!=
literal|0
condition|)
comment|/* loopback is active */
name|led_inv
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_RED
argument_list|)
expr_stmt|;
else|else
name|led_off
argument_list|(
name|sc
argument_list|,
name|MII16_T1_LED_RED
argument_list|)
expr_stmt|;
comment|/* Print latched error bits if they changed. */
if|if
condition|(
operator|(
name|DRIVER_DEBUG
operator|)
operator|&&
operator|(
name|alm1
operator|!=
name|sc
operator|->
name|last_alm1
operator|)
condition|)
block|{
name|char
modifier|*
name|on
init|=
literal|"ON "
decl_stmt|,
modifier|*
name|off
init|=
literal|"OFF"
decl_stmt|;
name|printf
argument_list|(
literal|"%s: RLOF=%s RLOS=%s RALOS=%s RAIS=%s RYEL=%s RMYEL=%s\n"
argument_list|,
name|NAME_UNIT
argument_list|,
operator|(
name|alm1
operator|&
name|ALM1_RLOF
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|alm1
operator|&
name|ALM1_RLOS
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|alm1
operator|&
name|ALM1_RALOS
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|alm1
operator|&
name|ALM1_RAIS
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|alm1
operator|&
name|ALM1_RYEL
operator|)
condition|?
name|on
else|:
name|off
argument_list|,
operator|(
name|alm1
operator|&
name|ALM1_RMYEL
operator|)
condition|?
name|on
else|:
name|off
argument_list|)
expr_stmt|;
block|}
comment|/* Check and print error counters if non-zero. */
name|LCV
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LCV_LO
argument_list|)
operator|+
operator|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LCV_HI
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|FORMAT_E1NONE
condition|)
name|FERR
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_FERR_LO
argument_list|)
operator|+
operator|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_FERR_HI
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|FORMAT_E1CRC
operator|||
name|FORMAT_T1ESF
condition|)
name|CRC
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CRC_LO
argument_list|)
operator|+
operator|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_CRC_HI
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|FORMAT_E1CRC
condition|)
name|FEBE
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_FEBE_LO
argument_list|)
operator|+
operator|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_FEBE_HI
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Only LCV is valid if Out-Of-Frame */
if|if
condition|(
name|FORMAT_E1NONE
condition|)
name|FERR
operator|=
name|CRC
operator|=
name|FEBE
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|DRIVER_DEBUG
operator|)
operator|&&
operator|(
name|LCV
operator|||
name|FERR
operator|||
name|CRC
operator|||
name|FEBE
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: LCV=%u FERR=%u CRC=%u FEBE=%u\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|LCV
argument_list|,
name|FERR
argument_list|,
name|CRC
argument_list|,
name|FEBE
argument_list|)
expr_stmt|;
comment|/* Driver keeps crude link-level error counters (SNMP is better). */
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|lcv_errs
operator|+=
name|LCV
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|frm_errs
operator|+=
name|FERR
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|crc_errs
operator|+=
name|CRC
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|febe_errs
operator|+=
name|FEBE
expr_stmt|;
comment|/* Check for BOP messages in the ESF Facility Data Link. */
if|if
condition|(
operator|(
name|FORMAT_T1ESF
operator|)
operator|&&
operator|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_ISR1
argument_list|)
operator|&
literal|0x80
operator|)
condition|)
block|{
name|u_int8_t
name|bop_code
init|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RBOP
argument_list|)
operator|&
literal|0x3F
decl_stmt|;
switch|switch
condition|(
name|bop_code
condition|)
block|{
case|case
name|T1BOP_OOF
case|:
block|{
if|if
condition|(
operator|(
name|DRIVER_DEBUG
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|last_alm1
operator|&
name|ALM1_RMYEL
operator|)
operator|==
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: Receiving a 'yellow alarm' BOP msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T1BOP_LINE_UP
case|:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'line loopback activate' BOP msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|LOOP_LINE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|loop_timer
operator|=
literal|305
expr_stmt|;
break|break;
block|}
case|case
name|T1BOP_LINE_DOWN
case|:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'line loopback deactivate' BOP msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|)
operator|&
operator|~
name|LOOP_LINE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|loop_timer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|T1BOP_PAY_UP
case|:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'payload loopback activate' BOP msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|LOOP_PAYLOAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|loop_timer
operator|=
literal|305
expr_stmt|;
break|break;
block|}
case|case
name|T1BOP_PAY_DOWN
case|:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'payload loopback deactivate' BOP msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|)
operator|&
operator|~
name|LOOP_PAYLOAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|loop_timer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a type 0x%02X BOP msg\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|bop_code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Check for HDLC pkts in the ESF Facility Data Link. */
if|if
condition|(
operator|(
name|FORMAT_T1ESF
operator|)
operator|&&
operator|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_ISR2
argument_list|)
operator|&
literal|0x70
operator|)
condition|)
block|{
comment|/* while (not fifo-empty&& not start-of-msg) flush fifo */
while|while
condition|(
operator|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RDL1_STAT
argument_list|)
operator|&
literal|0x0C
operator|)
operator|==
literal|0
condition|)
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RDL1
argument_list|)
expr_stmt|;
comment|/* If (not fifo-empty), then begin processing fifo contents. */
if|if
condition|(
operator|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RDL1_STAT
argument_list|)
operator|&
literal|0x0C
operator|)
operator|==
literal|0x08
condition|)
block|{
name|u_int8_t
name|msg
index|[
literal|64
index|]
decl_stmt|;
name|u_int8_t
name|stat
init|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RDL1
argument_list|)
decl_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|fdl_pkts
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|stat
operator|&
literal|0x3F
operator|)
condition|;
name|i
operator|++
control|)
name|msg
index|[
name|i
index|]
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RDL1
argument_list|)
expr_stmt|;
comment|/* Is this FDL message a T1.403 performance report? */
if|if
condition|(
operator|(
operator|(
name|stat
operator|&
literal|0x3F
operator|)
operator|==
literal|11
operator|)
operator|&&
operator|(
operator|(
name|msg
index|[
literal|0
index|]
operator|==
literal|0x38
operator|)
operator|||
operator|(
name|msg
index|[
literal|0
index|]
operator|==
literal|0x3A
operator|)
operator|)
operator|&&
operator|(
name|msg
index|[
literal|1
index|]
operator|==
literal|1
operator|)
operator|&&
operator|(
name|msg
index|[
literal|2
index|]
operator|==
literal|3
operator|)
condition|)
comment|/* Copy 4 PRs from FDL pkt to SNMP struct. */
name|memcpy
argument_list|(
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|prm
argument_list|,
name|msg
operator|+
literal|3
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for inband loop up/down commands. */
if|if
condition|(
name|FORMAT_T1ANY
condition|)
block|{
name|u_int8_t
name|isr6
init|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_ISR6
argument_list|)
decl_stmt|;
name|u_int8_t
name|alarm2
init|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_ALM2
argument_list|)
decl_stmt|;
name|u_int8_t
name|tlb
init|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TLB
argument_list|)
decl_stmt|;
comment|/* Inband Code == Loop Up&& On Transition&& Inband Tx Inactive */
if|if
condition|(
operator|(
name|isr6
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|alarm2
operator|&
literal|0x40
operator|)
operator|&&
operator|(
operator|(
name|tlb
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* CSU loop up is 10000 10000 ... */
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'CSU Loop Up' inband msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|LOOP_LINE
argument_list|)
expr_stmt|;
comment|/* Loop up */
name|sc
operator|->
name|loop_timer
operator|=
literal|305
expr_stmt|;
block|}
comment|/* Inband Code == Loop Down&& On Transition&& Inband Tx Inactive */
if|if
condition|(
operator|(
name|isr6
operator|&
literal|0x80
operator|)
operator|&&
operator|(
name|alarm2
operator|&
literal|0x80
operator|)
operator|&&
operator|(
operator|(
name|tlb
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* CSU loop down is 100 100 100 ... */
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Received a 'CSU Loop Down' inband msg\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|)
operator|&
operator|~
name|LOOP_LINE
argument_list|)
expr_stmt|;
comment|/* loop down */
name|sc
operator|->
name|loop_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Manually send Yellow Alarm BOP msgs. */
if|if
condition|(
name|FORMAT_T1ESF
condition|)
block|{
name|u_int8_t
name|isr7
init|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_ISR7
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|isr7
operator|&
literal|0x02
operator|)
operator|&&
operator|(
name|alm1
operator|&
literal|0x02
operator|)
condition|)
comment|/* RLOF on-transition */
block|{
comment|/* Start sending continuous Yellow Alarm BOP messages. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP
argument_list|,
name|RBOP_25
operator||
name|TBOP_CONT
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TBOP
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* send BOP; order matters */
block|}
elseif|else
if|if
condition|(
operator|(
name|isr7
operator|&
literal|0x02
operator|)
operator|&&
operator|(
operator|(
name|alm1
operator|&
literal|0x02
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* RLOF off-transition */
block|{
comment|/* Stop sending continuous Yellow Alarm BOP messages. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP
argument_list|,
name|RBOP_25
operator||
name|TBOP_OFF
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Time out loopback requests. */
if|if
condition|(
name|sc
operator|->
name|loop_timer
operator|!=
literal|0
condition|)
if|if
condition|(
operator|--
name|sc
operator|->
name|loop_timer
operator|==
literal|0
condition|)
if|if
condition|(
name|loop
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: Timeout: Loop Down after 300 seconds\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|loop
operator|&
operator|~
operator|(
name|LOOP_PAYLOAD
operator||
name|LOOP_LINE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* RX Test Pattern status */
if|if
condition|(
operator|(
name|DRIVER_DEBUG
operator|)
operator|&&
operator|(
name|isr0
operator|&
literal|0x10
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: RX Test Pattern Sync\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
comment|/* SNMP Error Counters */
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|lcv
operator|=
name|LCV
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|fe
operator|=
name|FERR
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|crc
operator|=
name|CRC
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|febe
operator|=
name|FEBE
expr_stmt|;
comment|/* SNMP Line Status */
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alm1
operator|&
name|ALM1_RMYEL
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|TLINE_RX_RAI
expr_stmt|;
if|if
condition|(
name|alm1
operator|&
name|ALM1_RYEL
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|TLINE_RX_RAI
expr_stmt|;
if|if
condition|(
name|alm1
operator|&
name|ALM1_RLOF
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|TLINE_TX_RAI
expr_stmt|;
if|if
condition|(
name|alm1
operator|&
name|ALM1_RAIS
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|TLINE_RX_AIS
expr_stmt|;
if|if
condition|(
name|alm1
operator|&
name|ALM1_RLOS
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|TLINE_TX_AIS
expr_stmt|;
if|if
condition|(
name|alm1
operator|&
name|ALM1_RLOF
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|TLINE_LOF
expr_stmt|;
if|if
condition|(
name|alm1
operator|&
name|ALM1_RLOS
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|TLINE_LOS
expr_stmt|;
if|if
condition|(
name|alm3
operator|&
name|ALM3_RMAIS
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|T1LINE_RX_TS16_AIS
expr_stmt|;
if|if
condition|(
name|alm3
operator|&
name|ALM3_SRED
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|T1LINE_TX_TS16_LOMF
expr_stmt|;
if|if
condition|(
name|alm3
operator|&
name|ALM3_SEF
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|T1LINE_SEF
expr_stmt|;
if|if
condition|(
name|isr0
operator|&
literal|0x10
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|T1LINE_RX_TEST
expr_stmt|;
if|if
condition|(
operator|(
name|alm1
operator|&
name|ALM1_RMYEL
operator|)
operator|&&
operator|(
name|FORMAT_E1CAS
operator|)
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|line
operator||=
name|T1LINE_RX_TS16_LOMF
expr_stmt|;
comment|/* SNMP Loopback Status */
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator|&=
operator|~
operator|(
name|TLOOP_FAR_LINE
operator||
name|TLOOP_FAR_PAYLOAD
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_TULIP
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator||=
name|TLOOP_NEAR_OTHER
expr_stmt|;
if|if
condition|(
name|loop
operator|&
name|LOOP_PAYLOAD
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator||=
name|TLOOP_NEAR_PAYLOAD
expr_stmt|;
if|if
condition|(
name|loop
operator|&
name|LOOP_LINE
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator||=
name|TLOOP_NEAR_LINE
expr_stmt|;
if|if
condition|(
name|loop
operator|&
name|LOOP_ANALOG
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator||=
name|TLOOP_NEAR_OTHER
expr_stmt|;
if|if
condition|(
name|loop
operator|&
name|LOOP_FRAMER
condition|)
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator||=
name|TLOOP_NEAR_INWARD
expr_stmt|;
comment|/* Remember this state until next time. */
name|sc
operator|->
name|last_alm1
operator|=
name|alm1
expr_stmt|;
comment|/* If an INWARD loopback is in effect, link status is UP */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|!=
name|CFG_LOOP_NONE
condition|)
comment|/* XXX INWARD ONLY */
name|link_status
operator|=
name|STATUS_UP
expr_stmt|;
return|return
name|link_status
return|;
block|}
end_function

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|void
name|t1_send_bop
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|bop_code
parameter_list|)
block|{
name|u_int8_t
name|bop
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The BOP transmitter could be sending a continuous */
comment|/*  BOP msg when told to send this BOP_25 message. */
comment|/* So save and restore the state of the BOP machine. */
name|bop
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP
argument_list|,
name|RBOP_OFF
operator||
name|TBOP_OFF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|++
control|)
comment|/* max delay 400 ms. */
if|if
condition|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP_STAT
argument_list|)
operator|&
literal|0x80
condition|)
name|SLEEP
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* send 25 repetitions of bop_code */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP
argument_list|,
name|RBOP_OFF
operator||
name|TBOP_25
argument_list|)
expr_stmt|;
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TBOP
argument_list|,
name|bop_code
argument_list|)
expr_stmt|;
comment|/* order matters */
comment|/* wait for tx to stop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|++
control|)
comment|/* max delay 400 ms. */
if|if
condition|(
name|read_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP_STAT
argument_list|)
operator|&
literal|0x80
condition|)
name|SLEEP
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Restore previous state of the BOP machine. */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_BOP
argument_list|,
name|bop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* IOCTL SYSCALL: can sleep. */
end_comment

begin_function
specifier|static
name|int
name|t1_ioctl
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ioctl
modifier|*
name|ioctl
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ioctl
operator|->
name|cmd
condition|)
block|{
case|case
name|IOCTL_SNMP_SEND
case|:
comment|/* set opstatus? */
block|{
switch|switch
condition|(
name|ioctl
operator|->
name|data
condition|)
block|{
case|case
name|TSEND_NORMAL
case|:
block|{
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TPATT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* tx pattern generator off */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_RPATT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* rx pattern detector off */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TLB
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* tx inband generator off */
break|break;
block|}
case|case
name|TSEND_LINE
case|:
block|{
if|if
condition|(
name|FORMAT_T1ESF
condition|)
name|t1_send_bop
argument_list|(
name|sc
argument_list|,
name|T1BOP_LINE_UP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FORMAT_T1SF
condition|)
block|{
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LBP
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* 10000 10000 ... */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TLB
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* 5 bits, framed, start */
block|}
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator||=
name|TLOOP_FAR_LINE
expr_stmt|;
break|break;
block|}
case|case
name|TSEND_PAYLOAD
case|:
block|{
name|t1_send_bop
argument_list|(
name|sc
argument_list|,
name|T1BOP_PAY_UP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator||=
name|TLOOP_FAR_PAYLOAD
expr_stmt|;
break|break;
block|}
case|case
name|TSEND_RESET
case|:
block|{
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator|==
name|TLOOP_FAR_LINE
condition|)
block|{
if|if
condition|(
name|FORMAT_T1ESF
condition|)
name|t1_send_bop
argument_list|(
name|sc
argument_list|,
name|T1BOP_LINE_DOWN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FORMAT_T1SF
condition|)
block|{
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LBP
argument_list|,
literal|0x24
argument_list|)
expr_stmt|;
comment|/* 100100 100100 ... */
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TLB
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
comment|/* 6 bits, framed, start */
block|}
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator|&=
operator|~
name|TLOOP_FAR_LINE
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator|==
name|TLOOP_FAR_PAYLOAD
condition|)
block|{
name|t1_send_bop
argument_list|(
name|sc
argument_list|,
name|T1BOP_PAY_DOWN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|snmp
operator|.
name|t1
operator|.
name|loop
operator|&=
operator|~
name|TLOOP_FAR_PAYLOAD
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TSEND_QRS
case|:
block|{
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_TPATT
argument_list|,
literal|0x1E
argument_list|)
expr_stmt|;
comment|/* framed QRSS */
break|break;
block|}
default|default:
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
name|IOCTL_SNMP_LOOP
case|:
comment|/* set opstatus = test? */
block|{
name|u_int8_t
name|new_loop
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_NONE
condition|)
name|new_loop
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_PAYLOAD
condition|)
name|new_loop
operator|=
name|LOOP_PAYLOAD
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_LINE
condition|)
name|new_loop
operator|=
name|LOOP_LINE
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_OTHER
condition|)
name|new_loop
operator|=
name|LOOP_ANALOG
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_INWARD
condition|)
name|new_loop
operator|=
name|LOOP_FRAMER
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|data
operator|==
name|CFG_LOOP_DUAL
condition|)
name|new_loop
operator|=
name|LOOP_DUAL
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|write_framer
argument_list|(
name|sc
argument_list|,
name|Bt8370_LOOP
argument_list|,
name|new_loop
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|=
name|ioctl
operator|->
name|data
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|card
name|hssi_card
init|=
block|{
operator|.
name|config
operator|=
name|hssi_config
block|,
operator|.
name|ident
operator|=
name|hssi_ident
block|,
operator|.
name|watchdog
operator|=
name|hssi_watchdog
block|,
operator|.
name|ioctl
operator|=
name|hssi_ioctl
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|card
name|t3_card
init|=
block|{
operator|.
name|config
operator|=
name|t3_config
block|,
operator|.
name|ident
operator|=
name|t3_ident
block|,
operator|.
name|watchdog
operator|=
name|t3_watchdog
block|,
operator|.
name|ioctl
operator|=
name|t3_ioctl
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|card
name|ssi_card
init|=
block|{
operator|.
name|config
operator|=
name|ssi_config
block|,
operator|.
name|ident
operator|=
name|ssi_ident
block|,
operator|.
name|watchdog
operator|=
name|ssi_watchdog
block|,
operator|.
name|ioctl
operator|=
name|ssi_ioctl
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|card
name|t1_card
init|=
block|{
operator|.
name|config
operator|=
name|t1_config
block|,
operator|.
name|ident
operator|=
name|t1_ident
block|,
operator|.
name|watchdog
operator|=
name|t1_watchdog
block|,
operator|.
name|ioctl
operator|=
name|t1_ioctl
block|,   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RAWIP is raw IP packets (v4 or v6) in HDLC frames with NO HEADERS. */
end_comment

begin_comment
comment|/* No HDLC Address/Control fields!  No line control protocol at all!  */
end_comment

begin_comment
comment|/* rxintr_cleanup calls this to give a newly arrived pkt to higher levels. */
end_comment

begin_function
specifier|static
name|void
name|lmc_raw_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|IFP2SC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|M_SETFIB
argument_list|(
name|mbuf
argument_list|,
name|ifp
operator|->
name|if_fib
argument_list|)
expr_stmt|;
if|#
directive|if
name|INET
if|if
condition|(
name|mbuf
operator|->
name|m_data
index|[
literal|0
index|]
operator|>>
literal|4
operator|==
literal|4
condition|)
name|netisr_dispatch
argument_list|(
name|NETISR_IP
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|#
directive|if
name|INET6
if|if
condition|(
name|mbuf
operator|->
name|m_data
index|[
literal|0
index|]
operator|>>
literal|4
operator|==
literal|6
condition|)
name|netisr_dispatch
argument_list|(
name|NETISR_IPV6
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|idiscards
operator|++
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: lmc_raw_input: rx pkt discarded: not IPv4 or IPv6\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * We are "standing on the head of a pin" in these routines.  * Tulip CSRs can be accessed, but nothing else is interrupt-safe!  * Do NOT access: MII, GPIO, SROM, BIOSROM, XILINX, SYNTH, or DAC.  */
end_comment

begin_comment
comment|/* Singly-linked tail-queues hold mbufs with active DMA.  * For RX, single mbuf clusters; for TX, mbuf chains are queued.  * NB: mbufs are linked through their m_nextpkt field.  * Callers must hold sc->bottom_lock; not otherwise locked.  */
end_comment

begin_comment
comment|/* Put an mbuf (chain) on the tail of the descriptor ring queue. */
end_comment

begin_function
specifier|static
name|void
comment|/* BSD version */
name|mbuf_enqueue
parameter_list|(
name|struct
name|desc_ring
modifier|*
name|ring
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|tail
operator|==
name|NULL
condition|)
name|ring
operator|->
name|head
operator|=
name|m
expr_stmt|;
else|else
name|ring
operator|->
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get an mbuf (chain) from the head of the descriptor ring queue. */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
comment|/* BSD version */
name|mbuf_dequeue
parameter_list|(
name|struct
name|desc_ring
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|ring
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|ring
operator|->
name|head
operator|=
name|m
operator|->
name|m_nextpkt
operator|)
operator|==
name|NULL
condition|)
name|ring
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|void
comment|/* *** FreeBSD ONLY *** Callout from bus_dmamap_load() */
name|fbsd_dmamap_load
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|desc_ring
modifier|*
name|ring
init|=
name|arg
decl_stmt|;
name|ring
operator|->
name|nsegs
operator|=
name|error
condition|?
literal|0
else|:
name|nsegs
expr_stmt|;
name|ring
operator|->
name|segs
index|[
literal|0
index|]
operator|=
name|segs
index|[
literal|0
index|]
expr_stmt|;
name|ring
operator|->
name|segs
index|[
literal|1
index|]
operator|=
name|segs
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a DMA descriptor ring. */
end_comment

begin_function
specifier|static
name|int
comment|/* BSD version */
name|create_ring
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|desc_ring
modifier|*
name|ring
parameter_list|,
name|int
name|num_descs
parameter_list|)
block|{
name|struct
name|dma_desc
modifier|*
name|descs
decl_stmt|;
name|int
name|size_descs
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dma_desc
argument_list|)
operator|*
name|num_descs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* The DMA descriptor array must not cross a page boundary. */
if|if
condition|(
name|size_descs
operator|>
name|PAGE_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: DMA descriptor array> PAGE_SIZE (%d)\n"
argument_list|,
name|NAME_UNIT
argument_list|,
operator|(
name|u_int
operator|)
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Create a DMA tag for descriptors and buffers. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|2
argument_list|,
name|PAGE_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|tag
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bus_dma_tag_create() failed: error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Allocate wired physical memory for DMA descriptor array */
comment|/*  and map physical address to kernel virtual address. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|first
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|ring
operator|->
name|map
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bus_dmamem_alloc() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|descs
operator|=
name|ring
operator|->
name|first
expr_stmt|;
comment|/* Map kernel virtual address to PCI address for DMA descriptor array. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
name|ring
operator|->
name|map
argument_list|,
name|descs
argument_list|,
name|size_descs
argument_list|,
name|fbsd_dmamap_load
argument_list|,
name|ring
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bus_dmamap_load() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ring
operator|->
name|dma_addr
operator|=
name|ring
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
comment|/* Allocate dmamaps for each DMA descriptor. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_descs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
literal|0
argument_list|,
operator|&
name|descs
index|[
name|i
index|]
operator|.
name|map
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bus_dmamap_create() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ring
operator|->
name|read
operator|=
name|descs
expr_stmt|;
name|ring
operator|->
name|write
operator|=
name|descs
expr_stmt|;
name|ring
operator|->
name|first
operator|=
name|descs
expr_stmt|;
name|ring
operator|->
name|last
operator|=
name|descs
operator|+
name|num_descs
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|last
operator|->
name|control
operator|=
name|TLP_DCTL_END_RING
expr_stmt|;
name|ring
operator|->
name|num_descs
operator|=
name|num_descs
expr_stmt|;
name|ring
operator|->
name|size_descs
operator|=
name|size_descs
expr_stmt|;
name|ring
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Destroy a DMA descriptor ring */
end_comment

begin_function
specifier|static
name|void
comment|/* BSD version */
name|destroy_ring
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|desc_ring
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|dma_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* Free queued mbufs. */
while|while
condition|(
operator|(
name|m
operator|=
name|mbuf_dequeue
argument_list|(
name|ring
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* TX may have one pkt that is not on any queue. */
if|if
condition|(
name|sc
operator|->
name|tx_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Unmap active DMA descriptors. */
while|while
condition|(
name|ring
operator|->
name|read
operator|!=
name|ring
operator|->
name|write
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
name|ring
operator|->
name|read
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|read
operator|++
operator|==
name|ring
operator|->
name|last
condition|)
name|ring
operator|->
name|read
operator|=
name|ring
operator|->
name|first
expr_stmt|;
block|}
comment|/* Free the dmamaps of all DMA descriptors. */
for|for
control|(
name|desc
operator|=
name|ring
operator|->
name|first
init|;
name|desc
operator|!=
name|ring
operator|->
name|last
operator|+
literal|1
condition|;
name|desc
operator|++
control|)
if|if
condition|(
name|desc
operator|->
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
name|desc
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* Unmap PCI address for DMA descriptor array. */
if|if
condition|(
name|ring
operator|->
name|dma_addr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
name|ring
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* Free kernel memory for DMA descriptor array. */
if|if
condition|(
name|ring
operator|->
name|first
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
name|ring
operator|->
name|first
argument_list|,
name|ring
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* Free the DMA tag created for this ring. */
if|if
condition|(
name|ring
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after a packet has been received. */
end_comment

begin_function
specifier|static
name|int
comment|/* BSD version */
name|rxintr_cleanup
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|desc_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxring
decl_stmt|;
name|struct
name|dma_desc
modifier|*
name|first_desc
decl_stmt|,
modifier|*
name|last_desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|first_mbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|last_mbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|new_mbuf
decl_stmt|;
name|int
name|pkt_len
decl_stmt|,
name|desc_len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEVICE_POLLING
argument_list|)
comment|/* Input packet flow control (livelock prevention): */
comment|/* Give pkts to higher levels only if quota is> 0. */
if|if
condition|(
name|sc
operator|->
name|quota
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* This looks complicated, but remember: typically packets up */
comment|/*  to 2048 bytes long fit in one mbuf and use one descriptor. */
name|first_desc
operator|=
name|last_desc
operator|=
name|ring
operator|->
name|read
expr_stmt|;
comment|/* ASSERTION: If there is a descriptor in the ring and the hardware has */
comment|/*  finished with it, then that descriptor will have RX_FIRST_DESC set. */
if|if
condition|(
operator|(
name|ring
operator|->
name|read
operator|!=
name|ring
operator|->
name|write
operator|)
operator|&&
comment|/* descriptor ring not empty */
operator|(
operator|(
name|ring
operator|->
name|read
operator|->
name|status
operator|&
name|TLP_DSTS_OWNER
operator|)
operator|==
literal|0
operator|)
operator|&&
comment|/* hardware done */
operator|(
operator|(
name|ring
operator|->
name|read
operator|->
name|status
operator|&
name|TLP_DSTS_RX_FIRST_DESC
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* should be set */
name|panic
argument_list|(
literal|"%s: rxintr_cleanup: rx-first-descriptor not set.\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
comment|/* First decide if a complete packet has arrived. */
comment|/* Run down DMA descriptors looking for one marked "last". */
comment|/* Bail out if an active descriptor is encountered. */
comment|/* Accumulate most significant bits of packet length. */
name|pkt_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|last_desc
operator|==
name|ring
operator|->
name|write
condition|)
return|return
literal|0
return|;
comment|/* no more descs */
if|if
condition|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_OWNER
condition|)
return|return
literal|0
return|;
comment|/* still active */
if|if
condition|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_RX_LAST_DESC
condition|)
break|break;
comment|/* end of packet */
name|pkt_len
operator|+=
name|last_desc
operator|->
name|length1
operator|+
name|last_desc
operator|->
name|length2
expr_stmt|;
comment|/* entire desc filled */
if|if
condition|(
name|last_desc
operator|++
operator|->
name|control
operator|&
name|TLP_DCTL_END_RING
condition|)
name|last_desc
operator|=
name|ring
operator|->
name|first
expr_stmt|;
comment|/* ring wrap */
block|}
comment|/* A complete packet has arrived; how long is it? */
comment|/* H/w ref man shows RX pkt length as a 14-bit field. */
comment|/* An experiment found that only the 12 LSBs work. */
if|if
condition|(
operator|(
operator|(
name|last_desc
operator|->
name|status
operator|>>
literal|16
operator|)
operator|&
literal|0xFFF
operator|)
operator|==
literal|0
condition|)
name|pkt_len
operator|+=
literal|4096
expr_stmt|;
comment|/* carry-bit */
name|pkt_len
operator|=
operator|(
name|pkt_len
operator|&
literal|0xF000
operator|)
operator|+
operator|(
operator|(
name|last_desc
operator|->
name|status
operator|>>
literal|16
operator|)
operator|&
literal|0x0FFF
operator|)
expr_stmt|;
comment|/* Subtract the CRC length unless doing so would underflow. */
if|if
condition|(
name|pkt_len
operator|>=
name|sc
operator|->
name|config
operator|.
name|crc_len
condition|)
name|pkt_len
operator|-=
name|sc
operator|->
name|config
operator|.
name|crc_len
expr_stmt|;
comment|/* Run down DMA descriptors again doing the following:    *  1) put pkt info in pkthdr of first mbuf,    *  2) link mbufs,    *  3) set mbuf lengths.    */
name|first_desc
operator|=
name|ring
operator|->
name|read
expr_stmt|;
do|do
block|{
comment|/* Read a DMA descriptor from the ring. */
name|last_desc
operator|=
name|ring
operator|->
name|read
expr_stmt|;
comment|/* Advance the ring read pointer. */
if|if
condition|(
name|ring
operator|->
name|read
operator|++
operator|==
name|ring
operator|->
name|last
condition|)
name|ring
operator|->
name|read
operator|=
name|ring
operator|->
name|first
expr_stmt|;
comment|/* Dequeue the corresponding cluster mbuf. */
name|new_mbuf
operator|=
name|mbuf_dequeue
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mbuf
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: rxintr_cleanup: expected an mbuf\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|desc_len
operator|=
name|last_desc
operator|->
name|length1
operator|+
name|last_desc
operator|->
name|length2
expr_stmt|;
comment|/* If bouncing, copy bounce buf to mbuf. */
name|DMA_SYNC
argument_list|(
name|last_desc
operator|->
name|map
argument_list|,
name|desc_len
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Unmap kernel virtual address to PCI address. */
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
name|last_desc
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* 1) Put pkt info in pkthdr of first mbuf. */
if|if
condition|(
name|last_desc
operator|==
name|first_desc
condition|)
block|{
name|first_mbuf
operator|=
name|new_mbuf
expr_stmt|;
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
expr_stmt|;
comment|/* total pkt length */
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
comment|/* how it got here */
block|}
else|else
comment|/* 2) link mbufs. */
block|{
name|last_mbuf
operator|->
name|m_next
operator|=
name|new_mbuf
expr_stmt|;
comment|/* M_PKTHDR should be set in the first mbuf only. */
name|new_mbuf
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
block|}
name|last_mbuf
operator|=
name|new_mbuf
expr_stmt|;
comment|/* 3) Set mbuf lengths. */
name|new_mbuf
operator|->
name|m_len
operator|=
operator|(
name|pkt_len
operator|>=
name|desc_len
operator|)
condition|?
name|desc_len
else|:
name|pkt_len
expr_stmt|;
name|pkt_len
operator|-=
name|new_mbuf
operator|->
name|m_len
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_RX_LAST_DESC
operator|)
operator|==
literal|0
condition|)
do|;
comment|/* Decide whether to accept or to discard this packet. */
comment|/* RxHDLC sets MIIERR for bad CRC, abort and partial byte at pkt end. */
if|if
condition|(
operator|(
operator|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_RX_BAD
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|==
name|STATUS_UP
operator|)
operator|&&
operator|(
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Optimization: copy a small pkt into a small mbuf. */
if|if
condition|(
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|COPY_BREAK
condition|)
block|{
name|MGETHDR
argument_list|(
name|new_mbuf
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mbuf
operator|!=
name|NULL
condition|)
block|{
name|new_mbuf
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|new_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|new_mbuf
operator|->
name|m_len
operator|=
name|first_mbuf
operator|->
name|m_len
expr_stmt|;
name|memcpy
argument_list|(
name|new_mbuf
operator|->
name|m_data
argument_list|,
name|first_mbuf
operator|->
name|m_data
argument_list|,
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|first_mbuf
argument_list|)
expr_stmt|;
name|first_mbuf
operator|=
name|new_mbuf
expr_stmt|;
block|}
block|}
comment|/* Include CRC and one flag byte in input byte count. */
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|ibytes
operator|+=
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|ipackets
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LMC_BPF_MTAP
argument_list|(
name|first_mbuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEVICE_POLLING
argument_list|)
name|sc
operator|->
name|quota
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* Give this good packet to the network stacks. */
if|#
directive|if
name|NETGRAPH
if|if
condition|(
name|sc
operator|->
name|ng_hook
operator|!=
name|NULL
condition|)
comment|/* is hook connected? */
block|{
name|int
name|error
decl_stmt|;
comment|/* ignore error */
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|sc
operator|->
name|ng_hook
argument_list|,
name|first_mbuf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* did something */
block|}
endif|#
directive|endif
comment|/* NETGRAPH */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|line_pkg
operator|==
name|PKG_RAWIP
condition|)
name|lmc_raw_input
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|first_mbuf
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|NSPPP
name|sppp_input
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|first_mbuf
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|P2P
name|new_mbuf
operator|=
name|first_mbuf
expr_stmt|;
while|while
condition|(
name|new_mbuf
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|p2p
operator|->
name|p2p_hdrinput
argument_list|(
name|sc
operator|->
name|p2p
argument_list|,
name|new_mbuf
operator|->
name|m_data
argument_list|,
name|new_mbuf
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|new_mbuf
operator|=
name|new_mbuf
operator|->
name|m_next
expr_stmt|;
block|}
name|sc
operator|->
name|p2p
operator|->
name|p2p_input
argument_list|(
name|sc
operator|->
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|first_mbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|m_freem
argument_list|(
name|first_mbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|idiscards
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|!=
name|STATUS_UP
condition|)
block|{
comment|/* If the link is down, this packet is probably noise. */
name|m_freem
argument_list|(
name|first_mbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|idiscards
operator|++
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: rxintr_cleanup: rx pkt discarded: link down\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Log and discard this bad packet. */
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: RX bad pkt; len=%d %s%s%s%s\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|first_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_RX_MII_ERR
operator|)
condition|?
literal|" miierr"
else|:
literal|""
argument_list|,
operator|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_RX_DRIBBLE
operator|)
condition|?
literal|" dribble"
else|:
literal|""
argument_list|,
operator|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_RX_DESC_ERR
operator|)
condition|?
literal|" descerr"
else|:
literal|""
argument_list|,
operator|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_RX_OVERRUN
operator|)
condition|?
literal|" overrun"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_desc
operator|->
name|status
operator|&
name|TLP_DSTS_RX_OVERRUN
condition|)
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|fifo_over
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|first_mbuf
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* did something */
block|}
end_function

begin_comment
comment|/* Setup (prepare) to receive a packet. */
end_comment

begin_comment
comment|/* Try to keep the RX descriptor ring full of empty buffers. */
end_comment

begin_function
specifier|static
name|int
comment|/* BSD version */
name|rxintr_setup
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|desc_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxring
decl_stmt|;
name|struct
name|dma_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|desc_len
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Ring is full if (wrap(write+1)==read) */
if|if
condition|(
operator|(
operator|(
name|ring
operator|->
name|write
operator|==
name|ring
operator|->
name|last
operator|)
condition|?
name|ring
operator|->
name|first
else|:
name|ring
operator|->
name|write
operator|+
literal|1
operator|)
operator|==
name|ring
operator|->
name|read
condition|)
return|return
literal|0
return|;
comment|/* ring is full; nothing to do */
comment|/* Allocate a small mbuf and attach an mbuf cluster. */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|rxdma
operator|++
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: rxintr_setup: MGETHDR() failed\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|rxdma
operator|++
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: rxintr_setup: MCLGET() failed\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Queue the mbuf for later processing by rxintr_cleanup. */
name|mbuf_enqueue
argument_list|(
name|ring
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Write a DMA descriptor into the ring. */
comment|/* Hardware won't see it until the OWNER bit is set. */
name|desc
operator|=
name|ring
operator|->
name|write
expr_stmt|;
comment|/* Advance the ring write pointer. */
if|if
condition|(
name|ring
operator|->
name|write
operator|++
operator|==
name|ring
operator|->
name|last
condition|)
name|ring
operator|->
name|write
operator|=
name|ring
operator|->
name|first
expr_stmt|;
name|desc_len
operator|=
operator|(
name|MCLBYTES
operator|<
name|MAX_DESC_LEN
operator|)
condition|?
name|MCLBYTES
else|:
name|MAX_DESC_LEN
expr_stmt|;
comment|/* Map kernel virtual address to PCI address. */
if|if
condition|(
operator|(
name|error
operator|=
name|DMA_LOAD
argument_list|(
name|desc
operator|->
name|map
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|desc_len
argument_list|)
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: bus_dmamap_load(rx) failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Invalidate the cache for this mbuf. */
name|DMA_SYNC
argument_list|(
name|desc
operator|->
name|map
argument_list|,
name|desc_len
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Set up the DMA descriptor. */
name|desc
operator|->
name|address1
operator|=
name|ring
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|desc
operator|->
name|length1
operator|=
name|desc_len
operator|>>
literal|1
expr_stmt|;
name|desc
operator|->
name|address2
operator|=
name|desc
operator|->
name|address1
operator|+
name|desc
operator|->
name|length1
expr_stmt|;
name|desc
operator|->
name|length2
operator|=
name|desc_len
operator|>>
literal|1
expr_stmt|;
comment|/* Before setting the OWNER bit, flush the cache (memory barrier). */
name|DMA_SYNC
argument_list|(
name|ring
operator|->
name|map
argument_list|,
name|ring
operator|->
name|size_descs
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Commit the DMA descriptor to the hardware. */
name|desc
operator|->
name|status
operator|=
name|TLP_DSTS_OWNER
expr_stmt|;
comment|/* Notify the receiver that there is another buffer available. */
name|WRITE_CSR
argument_list|(
name|TLP_RX_POLL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* did something */
block|}
end_function

begin_comment
comment|/* Clean up after a packet has been transmitted. */
end_comment

begin_comment
comment|/* Free the mbuf chain and update the DMA descriptor ring. */
end_comment

begin_function
specifier|static
name|int
comment|/* BSD version */
name|txintr_cleanup
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|desc_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txring
decl_stmt|;
name|struct
name|dma_desc
modifier|*
name|desc
decl_stmt|;
while|while
condition|(
operator|(
name|ring
operator|->
name|read
operator|!=
name|ring
operator|->
name|write
operator|)
operator|&&
comment|/* while ring is not empty */
operator|(
operator|(
name|ring
operator|->
name|read
operator|->
name|status
operator|&
name|TLP_DSTS_OWNER
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Read a DMA descriptor from the ring. */
name|desc
operator|=
name|ring
operator|->
name|read
expr_stmt|;
comment|/* Advance the ring read pointer. */
if|if
condition|(
name|ring
operator|->
name|read
operator|++
operator|==
name|ring
operator|->
name|last
condition|)
name|ring
operator|->
name|read
operator|=
name|ring
operator|->
name|first
expr_stmt|;
comment|/* This is a no-op on most architectures. */
name|DMA_SYNC
argument_list|(
name|desc
operator|->
name|map
argument_list|,
name|desc
operator|->
name|length1
operator|+
name|desc
operator|->
name|length2
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* Unmap kernel virtual address to PCI address. */
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
name|desc
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* If this descriptor is the last segment of a packet, */
comment|/*  then dequeue and free the corresponding mbuf chain. */
if|if
condition|(
operator|(
name|desc
operator|->
name|control
operator|&
name|TLP_DCTL_TX_LAST_SEG
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|mbuf_dequeue
argument_list|(
name|ring
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: txintr_cleanup: expected an mbuf\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
comment|/* Include CRC and one flag byte in output byte count. */
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|opackets
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LMC_BPF_MTAP
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* The only bad TX status is fifo underrun. */
if|if
condition|(
operator|(
name|desc
operator|->
name|status
operator|&
name|TLP_DSTS_TX_UNDERRUN
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|fifo_under
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* did something */
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build DMA descriptors for a transmit packet mbuf chain. */
end_comment

begin_function
specifier|static
name|int
comment|/* 0=success; 1=error */
comment|/* BSD version */
name|txintr_setup_mbuf
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|desc_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txring
decl_stmt|;
name|struct
name|dma_desc
modifier|*
name|desc
decl_stmt|;
name|unsigned
name|int
name|desc_len
decl_stmt|;
comment|/* build DMA descriptors for a chain of mbufs. */
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|data
init|=
name|m
operator|->
name|m_data
decl_stmt|;
name|int
name|length
init|=
name|m
operator|->
name|m_len
decl_stmt|;
comment|/* zero length mbufs happen! */
comment|/* Build DMA descriptors for one mbuf. */
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Ring is full if (wrap(write+1)==read) */
if|if
condition|(
operator|(
operator|(
name|ring
operator|->
name|temp
operator|==
name|ring
operator|->
name|last
operator|)
condition|?
name|ring
operator|->
name|first
else|:
name|ring
operator|->
name|temp
operator|+
literal|1
operator|)
operator|==
name|ring
operator|->
name|read
condition|)
block|{
comment|/* Not enough DMA descriptors; try later. */
for|for
control|(
init|;
name|ring
operator|->
name|temp
operator|!=
name|ring
operator|->
name|write
condition|;
name|ring
operator|->
name|temp
operator|=
operator|(
name|ring
operator|->
name|temp
operator|==
name|ring
operator|->
name|first
operator|)
condition|?
name|ring
operator|->
name|last
else|:
name|ring
operator|->
name|temp
operator|-
literal|1
control|)
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|tag
argument_list|,
name|ring
operator|->
name|temp
operator|->
name|map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|txdma
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Provisionally, write a descriptor into the ring. */
comment|/* But don't change the REAL ring write pointer. */
comment|/* Hardware won't see it until the OWNER bit is set. */
name|desc
operator|=
name|ring
operator|->
name|temp
expr_stmt|;
comment|/* Advance the temporary ring write pointer. */
if|if
condition|(
name|ring
operator|->
name|temp
operator|++
operator|==
name|ring
operator|->
name|last
condition|)
name|ring
operator|->
name|temp
operator|=
name|ring
operator|->
name|first
expr_stmt|;
comment|/* Clear all control bits except the END_RING bit. */
name|desc
operator|->
name|control
operator|&=
name|TLP_DCTL_END_RING
expr_stmt|;
comment|/* Don't pad short packets up to 64 bytes. */
name|desc
operator|->
name|control
operator||=
name|TLP_DCTL_TX_NO_PAD
expr_stmt|;
comment|/* Use Tulip's CRC-32 generator, if appropriate. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|crc_len
operator|!=
name|CFG_CRC_32
condition|)
name|desc
operator|->
name|control
operator||=
name|TLP_DCTL_TX_NO_CRC
expr_stmt|;
comment|/* Set the OWNER bit, except in the first descriptor. */
if|if
condition|(
name|desc
operator|!=
name|ring
operator|->
name|write
condition|)
name|desc
operator|->
name|status
operator|=
name|TLP_DSTS_OWNER
expr_stmt|;
name|desc_len
operator|=
operator|(
name|length
operator|>
name|MAX_CHUNK_LEN
operator|)
condition|?
name|MAX_CHUNK_LEN
else|:
name|length
expr_stmt|;
comment|/* Map kernel virtual address to PCI address. */
if|if
condition|(
operator|(
name|error
operator|=
name|DMA_LOAD
argument_list|(
name|desc
operator|->
name|map
argument_list|,
name|data
argument_list|,
name|desc_len
argument_list|)
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: bus_dmamap_load(tx) failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Flush the cache and if bouncing, copy mbuf to bounce buf. */
name|DMA_SYNC
argument_list|(
name|desc
operator|->
name|map
argument_list|,
name|desc_len
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Prevent wild fetches if mapping fails (nsegs==0). */
name|desc
operator|->
name|length1
operator|=
name|desc
operator|->
name|length2
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|address1
operator|=
name|desc
operator|->
name|address2
operator|=
literal|0
expr_stmt|;
block|{
name|bus_dma_segment_t
modifier|*
name|segs
init|=
name|ring
operator|->
name|segs
decl_stmt|;
name|int
name|nsegs
init|=
name|ring
operator|->
name|nsegs
decl_stmt|;
if|if
condition|(
name|nsegs
operator|>=
literal|1
condition|)
block|{
name|desc
operator|->
name|address1
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|desc
operator|->
name|length1
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
if|if
condition|(
name|nsegs
operator|==
literal|2
condition|)
block|{
name|desc
operator|->
name|address2
operator|=
name|segs
index|[
literal|1
index|]
operator|.
name|ds_addr
expr_stmt|;
name|desc
operator|->
name|length2
operator|=
name|segs
index|[
literal|1
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
block|}
name|data
operator|+=
name|desc_len
expr_stmt|;
name|length
operator|-=
name|desc_len
expr_stmt|;
block|}
comment|/* while (length> 0) */
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* while (m != NULL) */
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/* Setup (prepare) to transmit a packet. */
end_comment

begin_comment
comment|/* Select a packet, build DMA descriptors and give packet to hardware. */
end_comment

begin_comment
comment|/* If DMA descriptors run out, abandon the attempt and return 0. */
end_comment

begin_function
specifier|static
name|int
comment|/* BSD version */
name|txintr_setup
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|desc_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txring
decl_stmt|;
name|struct
name|dma_desc
modifier|*
name|first_desc
decl_stmt|,
modifier|*
name|last_desc
decl_stmt|;
comment|/* Protect against half-up links: Don't transmit */
comment|/*  if the receiver can't hear the far end. */
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|!=
name|STATUS_UP
condition|)
return|return
literal|0
return|;
comment|/* Pick a packet to transmit. */
if|#
directive|if
name|NETGRAPH
if|if
condition|(
operator|(
name|sc
operator|->
name|ng_hook
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sc
operator|->
name|tx_mbuf
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|ng_fastq
argument_list|)
condition|)
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ng_fastq
argument_list|,
name|sc
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
else|else
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ng_sndq
argument_list|,
name|sc
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tx_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|line_pkg
operator|==
name|PKG_RAWIP
condition|)
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|sc
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|NSPPP
name|sc
operator|->
name|tx_mbuf
operator|=
name|sppp_dequeue
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|P2P
if|if
condition|(
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|p2p
operator|->
name|p2p_isnd
argument_list|)
condition|)
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|p2p
operator|->
name|p2p_isnd
argument_list|,
name|sc
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
else|else
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|sc
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|tx_mbuf
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* no pkt to transmit */
comment|/* Build DMA descriptors for an outgoing mbuf chain. */
name|ring
operator|->
name|temp
operator|=
name|ring
operator|->
name|write
expr_stmt|;
comment|/* temporary ring write pointer */
if|if
condition|(
name|txintr_setup_mbuf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tx_mbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Enqueue the mbuf; txintr_cleanup will free it. */
name|mbuf_enqueue
argument_list|(
name|ring
argument_list|,
name|sc
operator|->
name|tx_mbuf
argument_list|)
expr_stmt|;
comment|/* The transmitter has room for another packet. */
name|sc
operator|->
name|tx_mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* Set first& last segment bits. */
comment|/* last_desc is the desc BEFORE the one pointed to by ring->temp. */
name|first_desc
operator|=
name|ring
operator|->
name|write
expr_stmt|;
name|first_desc
operator|->
name|control
operator||=
name|TLP_DCTL_TX_FIRST_SEG
expr_stmt|;
name|last_desc
operator|=
operator|(
name|ring
operator|->
name|temp
operator|==
name|ring
operator|->
name|first
operator|)
condition|?
name|ring
operator|->
name|last
else|:
name|ring
operator|->
name|temp
operator|-
literal|1
expr_stmt|;
name|last_desc
operator|->
name|control
operator||=
name|TLP_DCTL_TX_LAST_SEG
expr_stmt|;
comment|/* Interrupt at end-of-transmission?  Why bother the poor computer! */
comment|/* last_desc->control |= TLP_DCTL_TX_INTERRUPT; */
comment|/* Make sure the OWNER bit is not set in the next descriptor. */
comment|/* The OWNER bit may have been set if a previous call aborted. */
name|ring
operator|->
name|temp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Commit the DMA descriptors to the software. */
name|ring
operator|->
name|write
operator|=
name|ring
operator|->
name|temp
expr_stmt|;
comment|/* Before setting the OWNER bit, flush the cache (memory barrier). */
name|DMA_SYNC
argument_list|(
name|ring
operator|->
name|map
argument_list|,
name|ring
operator|->
name|size_descs
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Commit the DMA descriptors to the hardware. */
name|first_desc
operator|->
name|status
operator|=
name|TLP_DSTS_OWNER
expr_stmt|;
comment|/* Notify the transmitter that there is another packet to send. */
name|WRITE_CSR
argument_list|(
name|TLP_TX_POLL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* did something */
block|}
end_function

begin_function
specifier|static
name|void
name|check_intr_status
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|,
name|cfcs
decl_stmt|,
name|op_mode
decl_stmt|;
name|u_int32_t
name|missed
decl_stmt|,
name|overruns
decl_stmt|;
comment|/* Check for four unusual events:    *  1) fatal PCI bus errors       - some are recoverable    *  2) transmitter FIFO underruns - increase fifo threshold    *  3) receiver FIFO overruns     - clear potential hangup    *  4) no receive descs or bufs   - count missed packets    */
comment|/* 1) A fatal bus error causes a Tulip to stop initiating bus cycles. */
comment|/* Module unload/load or boot are the only fixes for Parity Errors. */
comment|/* Master and Target Aborts can be cleared and life may continue. */
name|status
operator|=
name|READ_CSR
argument_list|(
name|TLP_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|TLP_STAT_FATAL_ERROR
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int32_t
name|fatal
init|=
operator|(
name|status
operator|&
name|TLP_STAT_FATAL_BITS
operator|)
operator|>>
name|TLP_STAT_FATAL_SHIFT
decl_stmt|;
name|printf
argument_list|(
literal|"%s: FATAL PCI BUS ERROR: %s%s%s%s\n"
argument_list|,
name|NAME_UNIT
argument_list|,
operator|(
name|fatal
operator|==
literal|0
operator|)
condition|?
literal|"PARITY ERROR"
else|:
literal|""
argument_list|,
operator|(
name|fatal
operator|==
literal|1
operator|)
condition|?
literal|"MASTER ABORT"
else|:
literal|""
argument_list|,
operator|(
name|fatal
operator|==
literal|2
operator|)
condition|?
literal|"TARGET ABORT"
else|:
literal|""
argument_list|,
operator|(
name|fatal
operator|>=
literal|3
operator|)
condition|?
literal|"RESERVED (?)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|cfcs
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFCS
argument_list|)
expr_stmt|;
comment|/* try to clear it */
name|cfcs
operator|&=
operator|~
operator|(
name|TLP_CFCS_MSTR_ABORT
operator||
name|TLP_CFCS_TARG_ABORT
operator|)
expr_stmt|;
name|WRITE_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFCS
argument_list|,
name|cfcs
argument_list|)
expr_stmt|;
block|}
comment|/* 2) If the transmitter fifo underruns, increase the transmit fifo */
comment|/*  threshold: the number of bytes required to be in the fifo */
comment|/*  before starting the transmitter (cost: increased tx delay). */
comment|/* The TX_FSM must be stopped to change this parameter. */
if|if
condition|(
operator|(
name|status
operator|&
name|TLP_STAT_TX_UNDERRUN
operator|)
operator|!=
literal|0
condition|)
block|{
name|op_mode
operator|=
name|READ_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|)
expr_stmt|;
comment|/* enable store-and-forward mode if tx_threshold tops out? */
if|if
condition|(
operator|(
name|op_mode
operator|&
name|TLP_OP_TX_THRESH
operator|)
operator|<
name|TLP_OP_TX_THRESH
condition|)
block|{
name|op_mode
operator|+=
literal|0x4000
expr_stmt|;
comment|/* increment TX_THRESH field; can't overflow */
name|WRITE_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|,
name|op_mode
operator|&
operator|~
name|TLP_OP_TX_RUN
argument_list|)
expr_stmt|;
comment|/* Wait for the TX FSM to stop; it might be processing a pkt. */
while|while
condition|(
name|READ_CSR
argument_list|(
name|TLP_STATUS
argument_list|)
operator|&
name|TLP_STAT_TX_FSM
condition|)
empty_stmt|;
comment|/* XXX HANG */
name|WRITE_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
comment|/* restart tx */
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: tx underrun; tx fifo threshold now %d bytes\n"
argument_list|,
name|NAME_UNIT
argument_list|,
literal|128
operator|<<
operator|(
operator|(
name|op_mode
operator|>>
name|TLP_OP_TR_SHIFT
operator|)
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 3) Errata memo from Digital Equipment Corp warns that 21140A */
comment|/* receivers through rev 2.2 can hang if the fifo overruns. */
comment|/* Recommended fix: stop and start the RX FSM after an overrun. */
name|missed
operator|=
name|READ_CSR
argument_list|(
name|TLP_MISSED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|overruns
operator|=
operator|(
operator|(
name|missed
operator|&
name|TLP_MISS_OVERRUN
operator|)
operator|>>
name|TLP_OVERRUN_SHIFT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: rx overrun cntr=%d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|overruns
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|overruns
operator|+=
name|overruns
expr_stmt|;
if|if
condition|(
operator|(
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFRV
argument_list|)
operator|&
literal|0xFF
operator|)
operator|<=
literal|0x22
condition|)
block|{
name|op_mode
operator|=
name|READ_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|,
name|op_mode
operator|&
operator|~
name|TLP_OP_RX_RUN
argument_list|)
expr_stmt|;
comment|/* Wait for the RX FSM to stop; it might be processing a pkt. */
while|while
condition|(
name|READ_CSR
argument_list|(
name|TLP_STATUS
argument_list|)
operator|&
name|TLP_STAT_RX_FSM
condition|)
empty_stmt|;
comment|/* XXX HANG */
name|WRITE_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
comment|/* restart rx */
block|}
block|}
comment|/* 4) When the receiver is enabled and a packet arrives, but no DMA */
comment|/*  descriptor is available, the packet is counted as 'missed'. */
comment|/* The receiver should never miss packets; warn if it happens. */
if|if
condition|(
operator|(
name|missed
operator|=
operator|(
name|missed
operator|&
name|TLP_MISS_MISSED
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: rx missed %d pkts\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|missed
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|missed
operator|+=
name|missed
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
comment|/* This is where the work gets done. */
name|core_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|check_status
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|activity
decl_stmt|;
comment|/* If any CPU is inside this critical section, then */
comment|/* other CPUs should go away without doing anything. */
if|if
condition|(
name|BOTTOM_TRYLOCK
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|lck_intr
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Clear pending card interrupts. */
name|WRITE_CSR
argument_list|(
name|TLP_STATUS
argument_list|,
name|READ_CSR
argument_list|(
name|TLP_STATUS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In Linux, pci_alloc_consistent() means DMA descriptors */
comment|/*  don't need explicit syncing. */
block|{
name|struct
name|desc_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txring
decl_stmt|;
name|DMA_SYNC
argument_list|(
name|sc
operator|->
name|txring
operator|.
name|map
argument_list|,
name|sc
operator|->
name|txring
operator|.
name|size_descs
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|rxring
expr_stmt|;
name|DMA_SYNC
argument_list|(
name|sc
operator|->
name|rxring
operator|.
name|map
argument_list|,
name|sc
operator|->
name|rxring
operator|.
name|size_descs
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
do|do
comment|/* This is the main loop for interrupt processing. */
block|{
name|activity
operator|=
name|txintr_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|activity
operator|+=
name|txintr_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|activity
operator|+=
name|rxintr_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|activity
operator|+=
name|rxintr_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|activity
condition|)
do|;
block|{
name|struct
name|desc_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txring
decl_stmt|;
name|DMA_SYNC
argument_list|(
name|sc
operator|->
name|txring
operator|.
name|map
argument_list|,
name|sc
operator|->
name|txring
operator|.
name|size_descs
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|rxring
expr_stmt|;
name|DMA_SYNC
argument_list|(
name|sc
operator|->
name|rxring
operator|.
name|map
argument_list|,
name|sc
operator|->
name|rxring
operator|.
name|size_descs
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* As the interrupt is dismissed, check for four unusual events. */
if|if
condition|(
name|check_status
condition|)
name|check_intr_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BOTTOM_UNLOCK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* user_interrupt() may be called from a syscall or a softirq */
end_comment

begin_function
specifier|static
name|void
name|user_interrupt
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|check_status
parameter_list|)
block|{
name|DISABLE_INTR
expr_stmt|;
comment|/* noop on FreeBSD-5 and Linux */
name|core_interrupt
argument_list|(
name|sc
argument_list|,
name|check_status
argument_list|)
expr_stmt|;
name|ENABLE_INTR
expr_stmt|;
comment|/* noop on FreeBSD-5 and Linux */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEVICE_POLLING
argument_list|)
end_if

begin_comment
comment|/* Service the card from the kernel idle loop without interrupts. */
end_comment

begin_function
specifier|static
name|int
name|fbsd_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|IFP2SC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|sc
operator|->
name|quota
operator|=
name|count
expr_stmt|;
name|core_interrupt
argument_list|(
name|sc
argument_list|,
operator|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_comment
comment|/* BSD kernels call this procedure when an interrupt happens. */
end_comment

begin_function
specifier|static
name|intr_return_t
name|bsd_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
comment|/* Cut losses early if this is not our interrupt. */
if|if
condition|(
operator|(
name|READ_CSR
argument_list|(
name|TLP_STATUS
argument_list|)
operator|&
name|TLP_INT_TXRX
operator|)
operator|==
literal|0
condition|)
return|return
name|IRQ_NONE
return|;
if|#
directive|if
name|defined
argument_list|(
name|DEVICE_POLLING
argument_list|)
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
return|return
name|IRQ_NONE
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_POLLING
operator|)
operator|&&
operator|(
name|ether_poll_register
argument_list|(
name|fbsd_poll
argument_list|,
name|sc
operator|->
name|ifp
argument_list|)
operator|)
condition|)
block|{
name|WRITE_CSR
argument_list|(
name|TLP_INT_ENBL
argument_list|,
name|TLP_INT_DISABLE
argument_list|)
expr_stmt|;
return|return
name|IRQ_NONE
return|;
block|}
else|else
name|sc
operator|->
name|quota
operator|=
name|sc
operator|->
name|rxring
operator|.
name|num_descs
expr_stmt|;
comment|/* input flow control */
endif|#
directive|endif
comment|/* DEVICE_POLLING */
comment|/* Disable card interrupts. */
name|WRITE_CSR
argument_list|(
name|TLP_INT_ENBL
argument_list|,
name|TLP_INT_DISABLE
argument_list|)
expr_stmt|;
name|core_interrupt
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable card interrupts. */
name|WRITE_CSR
argument_list|(
name|TLP_INT_ENBL
argument_list|,
name|TLP_INT_TXRX
argument_list|)
expr_stmt|;
return|return
name|IRQ_HANDLED
return|;
block|}
end_function

begin_comment
comment|/* Administrative status of the driver (UP or DOWN) has changed. */
end_comment

begin_comment
comment|/* A card-specific action may be required: T1 and T3 cards: no-op. */
end_comment

begin_comment
comment|/* HSSI and SSI cards change the state of modem ready signals. */
end_comment

begin_function
specifier|static
name|void
name|set_status
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ioctl
name|ioctl
decl_stmt|;
name|ioctl
operator|.
name|cmd
operator|=
name|IOCTL_SET_STATUS
expr_stmt|;
name|ioctl
operator|.
name|data
operator|=
name|status
expr_stmt|;
name|sc
operator|->
name|card
operator|->
name|ioctl
argument_list|(
name|sc
argument_list|,
operator|&
name|ioctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|P2P
end_if

begin_comment
comment|/* Callout from P2P: */
end_comment

begin_comment
comment|/* Get the state of DCD (Data Carrier Detect). */
end_comment

begin_function
specifier|static
name|int
name|p2p_getmdm
parameter_list|(
name|struct
name|p2pcom
modifier|*
name|p2p
parameter_list|,
name|caddr_t
name|result
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|IFP2SC
argument_list|(
operator|&
name|p2p
operator|->
name|p2p_if
argument_list|)
decl_stmt|;
comment|/* Non-zero isn't good enough; TIOCM_CAR is 0x40. */
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
operator|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|==
name|STATUS_UP
operator|)
condition|?
name|TIOCM_CAR
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Callout from P2P: */
end_comment

begin_comment
comment|/* Set the state of DTR (Data Terminal Ready). */
end_comment

begin_function
specifier|static
name|int
name|p2p_mdmctl
parameter_list|(
name|struct
name|p2pcom
modifier|*
name|p2p
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|IFP2SC
argument_list|(
operator|&
name|p2p
operator|->
name|p2p_if
argument_list|)
decl_stmt|;
name|set_status
argument_list|(
name|sc
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* P2P */
end_comment

begin_if
if|#
directive|if
name|NSPPP
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|PP_FR
end_ifndef

begin_define
define|#
directive|define
name|PP_FR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Callout from SPPP: */
end_comment

begin_function
specifier|static
name|void
name|sppp_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sppp
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|sppp
operator|->
name|pp_mode
operator|&
name|IFF_LINK2
operator|)
operator|&&
operator|!
operator|(
name|sppp
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
condition|)
name|sppp
operator|->
name|pp_up
argument_list|(
name|sppp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callout from SPPP: */
end_comment

begin_function
specifier|static
name|void
name|sppp_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sppp
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|sppp
operator|->
name|pp_mode
operator|&
name|IFF_LINK2
operator|)
operator|&&
operator|!
operator|(
name|sppp
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
condition|)
name|sppp
operator|->
name|pp_down
argument_list|(
name|sppp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSPPP */
end_comment

begin_comment
comment|/* Configure line protocol stuff.  * Called by attach_card() during module init.  * Called by core_ioctl()  when lmcconfig writes sc->config.  * Called by detach_card() during module shutdown.  */
end_comment

begin_function
specifier|static
name|void
name|config_proto
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|config
modifier|*
name|config
parameter_list|)
block|{
comment|/* Use line protocol stack instead of RAWIP mode. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|line_pkg
operator|==
name|PKG_RAWIP
operator|)
operator|&&
operator|(
name|config
operator|->
name|line_pkg
operator|!=
name|PKG_RAWIP
operator|)
condition|)
block|{
if|#
directive|if
name|NSPPP
name|LMC_BPF_DETACH
expr_stmt|;
name|sppp_attach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|LMC_BPF_ATTACH
argument_list|(
name|DLT_PPP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sppp
operator|->
name|pp_tls
operator|=
name|sppp_tls
expr_stmt|;
name|sc
operator|->
name|sppp
operator|->
name|pp_tlf
operator|=
name|sppp_tlf
expr_stmt|;
comment|/* Force reconfiguration of SPPP params. */
name|sc
operator|->
name|config
operator|.
name|line_prot
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|keep_alive
operator|=
name|config
operator|->
name|keep_alive
condition|?
literal|0
else|:
literal|1
expr_stmt|;
elif|#
directive|elif
name|P2P
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|p2p
operator|->
name|p2p_proto
operator|=
literal|0
expr_stmt|;
comment|/* force p2p_attach */
if|if
condition|(
operator|(
name|error
operator|=
name|p2p_attach
argument_list|(
name|sc
operator|->
name|p2p
argument_list|)
operator|)
condition|)
comment|/* calls bpfattach() */
block|{
name|printf
argument_list|(
literal|"%s: p2p_attach() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|config
operator|->
name|line_pkg
operator|=
name|PKG_RAWIP
expr_stmt|;
comment|/* still in RAWIP mode */
block|}
else|else
block|{
name|sc
operator|->
name|p2p
operator|->
name|p2p_mdmctl
operator|=
name|p2p_mdmctl
expr_stmt|;
comment|/* set DTR */
name|sc
operator|->
name|p2p
operator|->
name|p2p_getmdm
operator|=
name|p2p_getmdm
expr_stmt|;
comment|/* get DCD */
block|}
elif|#
directive|elif
name|GEN_HDLC
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|net_dev
operator|->
name|mtu
operator|=
name|HDLC_MAX_MTU
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|hdlc_open
argument_list|(
name|sc
operator|->
name|net_dev
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: hdlc_open() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Try 'sethdlc %s ppp'\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|config
operator|->
name|line_pkg
operator|=
name|PKG_RAWIP
expr_stmt|;
comment|/* still in RAWIP mode */
block|}
else|#
directive|else
comment|/* no line protocol stack was configured */
name|config
operator|->
name|line_pkg
operator|=
name|PKG_RAWIP
expr_stmt|;
comment|/* still in RAWIP mode */
endif|#
directive|endif
block|}
comment|/* Bypass line protocol stack and return to RAWIP mode. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|line_pkg
operator|!=
name|PKG_RAWIP
operator|)
operator|&&
operator|(
name|config
operator|->
name|line_pkg
operator|==
name|PKG_RAWIP
operator|)
condition|)
block|{
if|#
directive|if
name|NSPPP
name|LMC_BPF_DETACH
expr_stmt|;
name|sppp_flush
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|sppp_detach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|setup_ifnet
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|LMC_BPF_ATTACH
argument_list|(
name|DLT_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|P2P
name|int
name|error
init|=
literal|0
decl_stmt|;
name|if_qflush
argument_list|(
operator|&
name|sc
operator|->
name|p2p
operator|->
name|p2p_isnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|p2p_detach
argument_list|(
name|sc
operator|->
name|p2p
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: p2p_detach() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Try 'ifconfig %s down -remove'\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|config
operator|->
name|line_pkg
operator|=
name|PKG_P2P
expr_stmt|;
comment|/* not in RAWIP mode; still attached to P2P */
block|}
else|else
block|{
name|setup_ifnet
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|LMC_BPF_ATTACH
argument_list|(
name|DLT_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|GEN_HDLC
name|hdlc_proto_detach
argument_list|(
name|sc
operator|->
name|hdlc_dev
argument_list|)
expr_stmt|;
name|hdlc_close
argument_list|(
name|sc
operator|->
name|net_dev
argument_list|)
expr_stmt|;
name|setup_netdev
argument_list|(
name|sc
operator|->
name|net_dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|NSPPP
if|if
condition|(
name|config
operator|->
name|line_pkg
operator|!=
name|PKG_RAWIP
condition|)
block|{
comment|/* Check for change to PPP protocol. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|line_prot
operator|!=
name|PROT_PPP
operator|)
operator|&&
operator|(
name|config
operator|->
name|line_prot
operator|==
name|PROT_PPP
operator|)
condition|)
block|{
name|LMC_BPF_DETACH
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_LINK2
expr_stmt|;
name|sc
operator|->
name|sppp
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_FR
expr_stmt|;
name|LMC_BPF_ATTACH
argument_list|(
name|DLT_PPP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sppp_ioctl
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DLT_C_HDLC
define|#
directive|define
name|DLT_C_HDLC
value|DLT_PPP
endif|#
directive|endif
comment|/* Check for change to C_HDLC protocol. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|line_prot
operator|!=
name|PROT_C_HDLC
operator|)
operator|&&
operator|(
name|config
operator|->
name|line_prot
operator|==
name|PROT_C_HDLC
operator|)
condition|)
block|{
name|LMC_BPF_DETACH
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK2
expr_stmt|;
name|sc
operator|->
name|sppp
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_FR
expr_stmt|;
name|LMC_BPF_ATTACH
argument_list|(
name|DLT_C_HDLC
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sppp_ioctl
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Check for change to Frame Relay protocol. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|line_prot
operator|!=
name|PROT_FRM_RLY
operator|)
operator|&&
operator|(
name|config
operator|->
name|line_prot
operator|==
name|PROT_FRM_RLY
operator|)
condition|)
block|{
name|LMC_BPF_DETACH
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_LINK2
expr_stmt|;
name|sc
operator|->
name|sppp
operator|->
name|pp_flags
operator||=
name|PP_FR
expr_stmt|;
name|LMC_BPF_ATTACH
argument_list|(
name|DLT_FRELAY
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sppp_ioctl
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Check for disabling keep-alives. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|keep_alive
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|config
operator|->
name|keep_alive
operator|==
literal|0
operator|)
condition|)
name|sc
operator|->
name|sppp
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
comment|/* Check for enabling keep-alives. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|keep_alive
operator|==
literal|0
operator|)
operator|&&
operator|(
name|config
operator|->
name|keep_alive
operator|!=
literal|0
operator|)
condition|)
name|sc
operator|->
name|sppp
operator|->
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NSPPP */
comment|/* Loop back through the TULIP Ethernet chip; (no CRC). */
comment|/* Data sheet says stop DMA before changing OPMODE register. */
comment|/* But that's not as simple as it sounds; works anyway. */
comment|/* Check for enabling loopback thru Tulip chip. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|!=
name|CFG_LOOP_TULIP
operator|)
operator|&&
operator|(
name|config
operator|->
name|loop_back
operator|==
name|CFG_LOOP_TULIP
operator|)
condition|)
block|{
name|u_int32_t
name|op_mode
init|=
name|READ_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|)
decl_stmt|;
name|op_mode
operator||=
name|TLP_OP_INT_LOOP
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
name|config
operator|->
name|crc_len
operator|=
name|CFG_CRC_0
expr_stmt|;
block|}
comment|/* Check for disabling loopback thru Tulip chip. */
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|.
name|loop_back
operator|==
name|CFG_LOOP_TULIP
operator|)
operator|&&
operator|(
name|config
operator|->
name|loop_back
operator|!=
name|CFG_LOOP_TULIP
operator|)
condition|)
block|{
name|u_int32_t
name|op_mode
init|=
name|READ_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|)
decl_stmt|;
name|op_mode
operator|&=
operator|~
name|TLP_OP_LOOP_MODE
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
name|config
operator|->
name|crc_len
operator|=
name|CFG_CRC_16
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the core ioctl procedure. */
end_comment

begin_comment
comment|/* It handles IOCTLs from lmcconfig(8). */
end_comment

begin_comment
comment|/* It must not run when card watchdogs run. */
end_comment

begin_comment
comment|/* Called from a syscall (user context; no spinlocks). */
end_comment

begin_comment
comment|/* This procedure can SLEEP. */
end_comment

begin_function
specifier|static
name|int
name|core_ioctl
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|iohdr
modifier|*
name|iohdr
init|=
operator|(
expr|struct
name|iohdr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ioctl
modifier|*
name|ioctl
init|=
operator|(
expr|struct
name|ioctl
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|status
modifier|*
name|status
init|=
operator|(
expr|struct
name|status
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|config
modifier|*
name|config
init|=
operator|(
expr|struct
name|config
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* All structs start with a string and a cookie. */
if|if
condition|(
operator|(
operator|(
expr|struct
name|iohdr
operator|*
operator|)
name|data
operator|)
operator|->
name|cookie
operator|!=
name|NGM_LMC_COOKIE
condition|)
return|return
name|EINVAL
return|;
while|while
condition|(
name|TOP_TRYLOCK
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|lck_ioctl
operator|++
expr_stmt|;
name|SLEEP
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* yield? */
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LMCIOCGSTAT
case|:
block|{
operator|*
name|status
operator|=
name|sc
operator|->
name|status
expr_stmt|;
name|iohdr
operator|->
name|cookie
operator|=
name|NGM_LMC_COOKIE
expr_stmt|;
break|break;
block|}
case|case
name|LMCIOCGCFG
case|:
block|{
operator|*
name|config
operator|=
name|sc
operator|->
name|config
expr_stmt|;
name|iohdr
operator|->
name|cookie
operator|=
name|NGM_LMC_COOKIE
expr_stmt|;
break|break;
block|}
case|case
name|LMCIOCSCFG
case|:
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|CHECK_CAP
operator|)
condition|)
break|break;
name|config_proto
argument_list|(
name|sc
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|=
operator|*
name|config
expr_stmt|;
name|sc
operator|->
name|card
operator|->
name|config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LMCIOCREAD
case|:
block|{
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_PCI
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|address
operator|>
literal|252
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|ioctl
operator|->
name|data
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_CSR
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|address
operator|>
literal|15
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|ioctl
operator|->
name|data
operator|=
name|READ_CSR
argument_list|(
name|ioctl
operator|->
name|address
operator|*
name|TLP_CSR_STRIDE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_SROM
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|address
operator|>
literal|63
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|ioctl
operator|->
name|data
operator|=
name|read_srom
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_BIOS
condition|)
name|ioctl
operator|->
name|data
operator|=
name|read_bios
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_MII
condition|)
name|ioctl
operator|->
name|data
operator|=
name|read_mii
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_FRAME
condition|)
name|ioctl
operator|->
name|data
operator|=
name|read_framer
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
case|case
name|LMCIOCWRITE
case|:
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|CHECK_CAP
operator|)
condition|)
break|break;
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_PCI
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|address
operator|>
literal|252
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|WRITE_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|,
name|ioctl
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_CSR
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|address
operator|>
literal|15
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|WRITE_CSR
argument_list|(
name|ioctl
operator|->
name|address
operator|*
name|TLP_CSR_STRIDE
argument_list|,
name|ioctl
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_SROM
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|address
operator|>
literal|63
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|write_srom
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|,
name|ioctl
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* can sleep */
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_BIOS
condition|)
block|{
if|if
condition|(
name|ioctl
operator|->
name|address
operator|==
literal|0
condition|)
name|erase_bios
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|write_bios
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|,
name|ioctl
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* can sleep */
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_MII
condition|)
name|write_mii
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|,
name|ioctl
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RW_FRAME
condition|)
name|write_framer
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|address
argument_list|,
name|ioctl
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_WO_SYNTH
condition|)
name|write_synth
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|synth
operator|*
operator|)
operator|&
name|ioctl
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_WO_DAC
condition|)
block|{
name|write_dac
argument_list|(
name|sc
argument_list|,
literal|0x9002
argument_list|)
expr_stmt|;
comment|/* set Vref = 2.048 volts */
name|write_dac
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|data
operator|&
literal|0xFFF
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
case|case
name|LMCIOCTL
case|:
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|CHECK_CAP
operator|)
condition|)
break|break;
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_XILINX_RESET
condition|)
block|{
name|reset_xilinx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|card
operator|->
name|config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_XILINX_ROM
condition|)
block|{
name|load_xilinx_from_rom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* can sleep */
name|sc
operator|->
name|card
operator|->
name|config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_XILINX_FILE
condition|)
block|{
comment|/* load_xilinx_from_file() can sleep. */
name|error
operator|=
name|load_xilinx_from_file
argument_list|(
name|sc
argument_list|,
name|ioctl
operator|->
name|ucode
argument_list|,
name|ioctl
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|load_xilinx_from_rom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* try the rom */
name|sc
operator|->
name|card
operator|->
name|config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|set_status
argument_list|(
name|sc
argument_list|,
operator|(
name|error
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
elseif|else
if|if
condition|(
name|ioctl
operator|->
name|cmd
operator|==
name|IOCTL_RESET_CNTRS
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|status
operator|.
name|cntrs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event_cntrs
argument_list|)
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|reset_time
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|sc
operator|->
name|card
operator|->
name|ioctl
argument_list|(
name|sc
argument_list|,
name|ioctl
argument_list|)
expr_stmt|;
comment|/* can sleep */
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|TOP_UNLOCK
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* This is the core watchdog procedure. */
end_comment

begin_comment
comment|/* It calculates link speed, and calls the card-specific watchdog code. */
end_comment

begin_comment
comment|/* Calls interrupt() in case one got lost; also kick-starts the device. */
end_comment

begin_comment
comment|/* ioctl syscalls and card watchdog routines must be interlocked.       */
end_comment

begin_comment
comment|/* This procedure must not sleep. */
end_comment

begin_function
specifier|static
name|void
name|core_watchdog
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Read and restart the Tulip timer. */
name|u_int32_t
name|tx_speed
init|=
name|READ_CSR
argument_list|(
name|TLP_TIMER
argument_list|)
decl_stmt|;
name|WRITE_CSR
argument_list|(
name|TLP_TIMER
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* Measure MII clock using a timer in the Tulip chip.    * This timer counts transmitter bits divided by 4096.    * Since this is called once a second the math is easy.    * This is only correct when the link is NOT sending pkts.    * On a fully-loaded link, answer will be HALF actual rate.    * Clock rate during pkt is HALF clk rate between pkts.    * Measuring clock rate really measures link utilization!    */
name|sc
operator|->
name|status
operator|.
name|tx_speed
operator|=
operator|(
literal|0xFFFF
operator|-
operator|(
name|tx_speed
operator|&
literal|0xFFFF
operator|)
operator|)
operator|<<
literal|12
expr_stmt|;
comment|/* The first status reset time is when the calendar clock is set. */
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|reset_time
operator|.
name|tv_sec
operator|<
literal|1000
condition|)
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|reset_time
argument_list|)
expr_stmt|;
comment|/* Update hardware (operational) status. */
comment|/* Call the card-specific watchdog routines. */
if|if
condition|(
name|TOP_TRYLOCK
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|=
name|sc
operator|->
name|card
operator|->
name|watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Increment a counter which tells user-land */
comment|/*  observers that SNMP state has been updated. */
name|sc
operator|->
name|status
operator|.
name|ticks
operator|++
expr_stmt|;
name|TOP_UNLOCK
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|lck_watch
operator|++
expr_stmt|;
comment|/* In case an interrupt gets lost... */
name|user_interrupt
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from a syscall (user context; no spinlocks). */
end_comment

begin_function
specifier|static
name|int
name|lmc_raw_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCAIFADDR
case|:
case|case
name|SIOCSIFFLAGS
case|:
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
comment|/* a Unix tradition */
break|break;
case|case
name|SIOCSIFMTU
case|:
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Called from a syscall (user context; no spinlocks). */
end_comment

begin_function
specifier|static
name|int
name|lmc_ifnet_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|IFP2SC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* Catch the IOCTLs used by lmcconfig. */
case|case
name|LMCIOCGSTAT
case|:
case|case
name|LMCIOCGCFG
case|:
case|case
name|LMCIOCSCFG
case|:
case|case
name|LMCIOCREAD
case|:
case|case
name|LMCIOCWRITE
case|:
case|case
name|LMCIOCTL
case|:
name|error
operator|=
name|core_ioctl
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* Pass the rest to the line protocol. */
default|default:
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|line_pkg
operator|==
name|PKG_RAWIP
condition|)
name|error
operator|=
name|lmc_raw_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
if|#
directive|if
name|NSPPP
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|P2P
name|error
operator|=
name|p2p_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|DRIVER_DEBUG
operator|&&
operator|(
name|error
operator|!=
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: lmc_ifnet_ioctl; cmd=0x%08lx error=%d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|cmd
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Called from a syscall (user context; no spinlocks). */
end_comment

begin_function
specifier|static
name|void
name|lmc_ifnet_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|IFP2SC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* Start the transmitter; incoming pkts are NOT processed. */
name|user_interrupt
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sppp and p2p replace this with their own proc. */
end_comment

begin_comment
comment|/* RAWIP mode is the only time this is used. */
end_comment

begin_comment
comment|/* Called from a syscall (user context; no spinlocks). */
end_comment

begin_function
specifier|static
name|int
name|lmc_raw_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|IFP2SC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Fail if the link is down. */
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|!=
name|STATUS_UP
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|odiscards
operator|++
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: lmc_raw_output: tx pkt discarded: link down\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
if|#
directive|if
name|NETGRAPH
comment|/* Netgraph has priority over the ifnet kernel interface. */
if|if
condition|(
name|sc
operator|->
name|ng_hook
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|odiscards
operator|++
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: lmc_raw_output: tx pkt discarded: netgraph active\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
endif|#
directive|endif
comment|/* lmc_raw_output() ENQUEUEs in a syscall or softirq. */
comment|/* txintr_setup() DEQUEUEs in a hard interrupt. */
comment|/* Some BSD QUEUE routines are not interrupt-safe. */
block|{
name|DISABLE_INTR
expr_stmt|;
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENABLE_INTR
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|user_interrupt
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start the transmitter */
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|odiscards
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OQDROPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: lmc_raw_output: IFQ_ENQUEUE() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Called from a softirq once a second. */
end_comment

begin_function
specifier|static
name|void
name|lmc_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
decl_stmt|;
name|softc_t
modifier|*
name|sc
init|=
name|IFP2SC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u_int8_t
name|old_oper_status
init|=
name|sc
operator|->
name|status
operator|.
name|oper_status
decl_stmt|;
name|core_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* updates oper_status */
if|#
directive|if
name|NETGRAPH
if|if
condition|(
name|sc
operator|->
name|ng_hook
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|status
operator|.
name|line_pkg
operator|=
name|PKG_NG
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|line_pkg
operator|==
name|PKG_RAWIP
condition|)
block|{
name|sc
operator|->
name|status
operator|.
name|line_pkg
operator|=
name|PKG_RAWIP
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
name|PROT_IP_HDLC
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|P2P
comment|/* Notice change in link status. */
if|if
condition|(
operator|(
name|old_oper_status
operator|!=
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|)
operator|&&
operator|(
name|sc
operator|->
name|p2p
operator|->
name|p2p_modem
operator|)
condition|)
call|(
modifier|*
name|sc
operator|->
name|p2p
operator|->
name|p2p_modem
call|)
argument_list|(
name|sc
operator|->
name|p2p
argument_list|,
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|==
name|STATUS_UP
argument_list|)
expr_stmt|;
comment|/* Notice change in line protocol. */
name|sc
operator|->
name|status
operator|.
name|line_pkg
operator|=
name|PKG_P2P
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_PPP
case|:
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
name|PROT_PPP
expr_stmt|;
break|break;
case|case
name|IFT_PTPSERIAL
case|:
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
name|PROT_C_HDLC
expr_stmt|;
break|break;
case|case
name|IFT_FRELAY
case|:
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
name|PROT_FRM_RLY
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elif|#
directive|elif
name|NSPPP
comment|/* Notice change in link status. */
if|if
condition|(
operator|(
name|old_oper_status
operator|!=
name|STATUS_UP
operator|)
operator|&&
operator|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|==
name|STATUS_UP
operator|)
condition|)
comment|/* link came up */
name|sppp_tls
argument_list|(
name|sc
operator|->
name|sppp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_oper_status
operator|==
name|STATUS_UP
operator|)
operator|&&
operator|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|!=
name|STATUS_UP
operator|)
condition|)
comment|/* link went down */
name|sppp_tlf
argument_list|(
name|sc
operator|->
name|sppp
argument_list|)
expr_stmt|;
comment|/* Notice change in line protocol. */
name|sc
operator|->
name|status
operator|.
name|line_pkg
operator|=
name|PKG_SPPP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sppp
operator|->
name|pp_flags
operator|&
name|PP_FR
condition|)
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
name|PROT_FRM_RLY
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
name|PROT_C_HDLC
expr_stmt|;
else|else
name|sc
operator|->
name|status
operator|.
name|line_prot
operator|=
name|PROT_PPP
expr_stmt|;
else|#
directive|else
comment|/* Suppress compiler warning. */
if|if
condition|(
name|old_oper_status
operator|==
name|STATUS_UP
condition|)
empty_stmt|;
endif|#
directive|endif
block|}
name|ifp
operator|->
name|if_baudrate
operator|=
name|sc
operator|->
name|status
operator|.
name|tx_speed
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|==
name|STATUS_UP
condition|)
name|ifp
operator|->
name|if_link_state
operator|=
name|LINK_STATE_UP
expr_stmt|;
else|else
name|ifp
operator|->
name|if_link_state
operator|=
name|LINK_STATE_DOWN
expr_stmt|;
comment|/* Call this procedure again after one second. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|,
name|hz
argument_list|,
name|lmc_watchdog
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|lmc_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|event_cntrs
modifier|*
name|cntrs
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|cntrs
operator|=
operator|&
name|sc
operator|->
name|status
operator|.
name|cntrs
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|cntrs
operator|->
name|ipackets
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|cntrs
operator|->
name|opackets
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|cntrs
operator|->
name|ibytes
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|cntrs
operator|->
name|obytes
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|cntrs
operator|->
name|ierrors
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|cntrs
operator|->
name|oerrors
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|cntrs
operator|->
name|idiscards
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|setup_ifnet
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* Initialize the generic network interface. */
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_POINTOPOINT
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lmc_ifnet_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|lmc_ifnet_start
expr_stmt|;
comment|/* sppp changes this */
name|ifp
operator|->
name|if_output
operator|=
name|lmc_raw_output
expr_stmt|;
comment|/* sppp& p2p change this */
name|ifp
operator|->
name|if_input
operator|=
name|lmc_raw_input
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|lmc_get_counter
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|MAX_DESC_LEN
expr_stmt|;
comment|/* sppp& p2p change this */
name|ifp
operator|->
name|if_type
operator|=
name|IFT_PTPSERIAL
expr_stmt|;
comment|/* p2p changes this */
if|#
directive|if
name|defined
argument_list|(
name|DEVICE_POLLING
argument_list|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING_NOCOUNT
expr_stmt|;
endif|#
directive|endif
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lmc_ifnet_attach
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|NSPPP
condition|?
name|IFT_PPP
else|:
name|IFT_OTHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
if|#
directive|if
name|NSPPP
name|sc
operator|->
name|sppp
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_l2com
expr_stmt|;
elif|#
directive|elif
name|P2P
name|sc
operator|->
name|ifp
operator|=
operator|&
name|sc
operator|->
name|p2pcom
operator|.
name|p2p_if
expr_stmt|;
name|sc
operator|->
name|p2p
operator|=
operator|&
name|sc
operator|->
name|p2pcom
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize the network interface struct. */
name|sc
operator|->
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|setup_ifnet
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* ALTQ output queue initialization. */
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|SNDQ_MAXLEN
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* Attach to the ifnet kernel interface. */
name|if_attach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* Attach Berkeley Packet Filter. */
name|LMC_BPF_ATTACH
argument_list|(
name|DLT_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|,
name|hz
argument_list|,
name|lmc_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_ifnet_detach
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEVICE_POLLING
argument_list|)
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Detach Berkeley Packet Filter. */
name|LMC_BPF_DETACH
expr_stmt|;
comment|/* Detach from the ifnet kernel interface. */
name|if_detach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NETGRAPH
end_if

begin_comment
comment|/* These next two macros should be added to netgraph */
end_comment

begin_define
define|#
directive|define
name|NG_TYPE_REF
parameter_list|(
name|type
parameter_list|)
value|atomic_add_int(&(type)->refs, 1)
end_define

begin_define
define|#
directive|define
name|NG_TYPE_UNREF
parameter_list|(
name|type
parameter_list|)
define|\
value|do {				\   if ((type)->refs == 1)	\     ng_rmtype(type);		\   else				\     atomic_subtract_int(&(type)->refs, 1); \    } while (0)
end_define

begin_comment
comment|/* It is an error to construct new copies of this Netgraph node. */
end_comment

begin_comment
comment|/* All instances are constructed by ng_attach and are persistent. */
end_comment

begin_function
specifier|static
name|int
name|ng_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/* Incoming Netgraph control message. */
end_comment

begin_function
specifier|static
name|int
name|ng_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|softc_t
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_LMC_COOKIE
condition|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|LMCIOCGSTAT
case|:
case|case
name|LMCIOCGCFG
case|:
case|case
name|LMCIOCSCFG
case|:
case|case
name|LMCIOCREAD
case|:
case|case
name|LMCIOCWRITE
case|:
case|case
name|LMCIOCTL
case|:
block|{
comment|/* Call the core ioctl procedure. */
name|error
operator|=
name|core_ioctl
argument_list|(
name|sc
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmd
argument_list|,
name|msg
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|&
name|IOC_OUT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* synchronous response */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
name|IOCPARM_LEN
argument_list|(
name|msg
operator|->
name|header
operator|.
name|cmd
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|resp
operator|->
name|data
argument_list|,
name|msg
operator|->
name|data
argument_list|,
name|IOCPARM_LEN
argument_list|(
name|msg
operator|->
name|header
operator|.
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_GENERIC_COOKIE
operator|)
operator|&&
operator|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_TEXT_STATUS
operator|)
condition|)
block|{
comment|/* synchronous response */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
name|NG_TEXTRESPONSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|s
init|=
name|resp
operator|->
name|data
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"Card type =<%s>\n"
literal|"This driver considers the link to be %s.\n"
literal|"Use lmcconfig to configure this interface.\n"
argument_list|,
name|sc
operator|->
name|dev_desc
argument_list|,
operator|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|==
name|STATUS_UP
operator|)
condition|?
literal|"UP"
else|:
literal|"DOWN"
argument_list|)
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|arglen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* Netgraph should be able to read and write these  *  parameters with text-format control messages:  *  SSI	     HSSI     T1E1     T3  *  crc	     crc      crc      crc        *  loop     loop     loop     loop  *           clksrc   clksrc  *  dte	     dte      format   format  *  synth    synth    cablen   cablen  *  cable             timeslot scram  *                    gain  *                    pulse  *                    lbo  * Someday I'll implement this...  */
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* Handle synchronous response. */
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* This is a persistent netgraph node. */
end_comment

begin_function
specifier|static
name|int
name|ng_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
comment|/* unless told to really die, bounce back to life */
if|if
condition|(
operator|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_REALLY_DIE
operator|)
operator|==
literal|0
condition|)
name|node
operator|->
name|nd_flags
operator|&=
operator|~
name|NG_INVALID
expr_stmt|;
comment|/* bounce back to life */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ng_disconnect is the opposite of this procedure. */
end_comment

begin_function
specifier|static
name|int
name|ng_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Hook name must be 'rawdata'. */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"rawdata"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* Is our hook connected? */
if|if
condition|(
name|sc
operator|->
name|ng_hook
operator|!=
name|NULL
condition|)
return|return
name|EBUSY
return|;
comment|/* Accept the hook. */
name|sc
operator|->
name|ng_hook
operator|=
name|hook
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Both ends have accepted their hooks and the links have been made. */
end_comment

begin_comment
comment|/* This is the last chance to reject the connection request. */
end_comment

begin_function
specifier|static
name|int
name|ng_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
comment|/* Probably not at splnet, force outward queueing. (huh?) */
name|NG_HOOK_FORCE_QUEUE
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* always accept */
block|}
end_function

begin_comment
comment|/* Receive data in mbufs from another Netgraph node. */
end_comment

begin_comment
comment|/* Transmit an mbuf-chain on the communication link. */
end_comment

begin_comment
comment|/* This procedure is very similar to lmc_raw_output(). */
end_comment

begin_comment
comment|/* Called from a syscall (user context; no spinlocks). */
end_comment

begin_function
specifier|static
name|int
name|ng_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
init|=
name|NULL
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* This macro must not store into meta! */
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
comment|/* Fail if the link is down. */
if|if
condition|(
name|sc
operator|->
name|status
operator|.
name|oper_status
operator|!=
name|STATUS_UP
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|odiscards
operator|++
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: ng_rcvdata: tx pkt discarded: link down\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
comment|/* ng_rcvdata() ENQUEUEs in a syscall or softirq. */
comment|/* txintr_setup() DEQUEUEs in a hard interrupt. */
comment|/* Some BSD QUEUE routines are not interrupt-safe. */
block|{
name|DISABLE_INTR
expr_stmt|;
if|if
condition|(
name|meta
operator|==
name|NULL
condition|)
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ng_sndq
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ng_fastq
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENABLE_INTR
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|user_interrupt
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start the transmitter */
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|cntrs
operator|.
name|odiscards
operator|++
expr_stmt|;
if|if
condition|(
name|DRIVER_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: ng_rcvdata: IFQ_ENQUEUE() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ng_newhook is the opposite of this procedure, not */
end_comment

begin_comment
comment|/*  ng_connect, as you might expect from the names. */
end_comment

begin_function
specifier|static
name|int
name|ng_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Disconnect the hook. */
name|sc
operator|->
name|ng_hook
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_type
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_LMC_NODE_TYPE
block|,
operator|.
name|mod_event
operator|=
name|NULL
block|,
operator|.
name|constructor
operator|=
name|ng_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_rcvmsg
block|,
operator|.
name|close
operator|=
name|NULL
block|,
operator|.
name|shutdown
operator|=
name|ng_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_newhook
block|,
operator|.
name|findhook
operator|=
name|NULL
block|,
operator|.
name|connect
operator|=
name|ng_connect
block|,
operator|.
name|rcvdata
operator|=
name|ng_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_disconnect
block|,   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Attach to the Netgraph kernel interface (/sys/netgraph).  * It is called once for each physical card during device attach.  * This is effectively ng_constructor.  */
end_comment

begin_function
specifier|static
name|int
name|ng_attach
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* If this node type is not known to Netgraph then register it. */
if|if
condition|(
name|ng_type
operator|.
name|refs
operator|==
literal|0
condition|)
comment|/* or: if (ng_findtype(&ng_type) == NULL) */
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ng_newtype
argument_list|(
operator|&
name|ng_type
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ng_newtype() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
else|else
name|NG_TYPE_REF
argument_list|(
operator|&
name|ng_type
argument_list|)
expr_stmt|;
comment|/* Call the superclass node constructor. */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|ng_type
argument_list|,
operator|&
name|sc
operator|->
name|ng_node
argument_list|)
operator|)
condition|)
block|{
name|NG_TYPE_UNREF
argument_list|(
operator|&
name|ng_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: ng_make_node_common() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Associate a name with this netgraph node. */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_name_node
argument_list|(
name|sc
operator|->
name|ng_node
argument_list|,
name|NAME_UNIT
argument_list|)
operator|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|ng_node
argument_list|)
expr_stmt|;
name|NG_TYPE_UNREF
argument_list|(
operator|&
name|ng_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: ng_name_node() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Initialize the send queue mutexes. */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|ng_sndq
operator|.
name|ifq_mtx
argument_list|,
name|NAME_UNIT
argument_list|,
literal|"sndq"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|ng_fastq
operator|.
name|ifq_mtx
argument_list|,
name|NAME_UNIT
argument_list|,
literal|"fastq"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Put a backpointer to the softc in the netgraph node. */
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|ng_node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* ALTQ output queue initialization. */
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|sc
operator|->
name|ng_fastq
argument_list|,
name|SNDQ_MAXLEN
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|sc
operator|->
name|ng_fastq
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|sc
operator|->
name|ng_sndq
argument_list|,
name|SNDQ_MAXLEN
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|sc
operator|->
name|ng_sndq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_detach
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|ng_sndq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|ng_fastq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|ng_rmnode_self
argument_list|(
name|sc
operator|->
name|ng_node
argument_list|)
expr_stmt|;
comment|/* free hook */
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|ng_node
argument_list|)
expr_stmt|;
comment|/* free node */
name|NG_TYPE_UNREF
argument_list|(
operator|&
name|ng_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETGRAPH */
end_comment

begin_comment
comment|/* The next few procedures initialize the card. */
end_comment

begin_comment
comment|/* Returns 0 on success; error code on failure. */
end_comment

begin_function
specifier|static
name|int
name|startup_card
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|num_rx_descs
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|tlp_bus_pbl
decl_stmt|,
name|tlp_bus_cal
decl_stmt|,
name|tlp_op_tr
decl_stmt|;
name|u_int32_t
name|tlp_cfdd
decl_stmt|,
name|tlp_cfcs
decl_stmt|;
name|u_int32_t
name|tlp_cflt
decl_stmt|,
name|tlp_csid
decl_stmt|,
name|tlp_cfit
decl_stmt|;
comment|/* Make sure the COMMAND bits are reasonable. */
name|tlp_cfcs
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFCS
argument_list|)
expr_stmt|;
name|tlp_cfcs
operator|&=
operator|~
name|TLP_CFCS_MWI_ENABLE
expr_stmt|;
name|tlp_cfcs
operator||=
name|TLP_CFCS_BUS_MASTER
expr_stmt|;
name|tlp_cfcs
operator||=
name|TLP_CFCS_MEM_ENABLE
expr_stmt|;
name|tlp_cfcs
operator||=
name|TLP_CFCS_IO_ENABLE
expr_stmt|;
name|tlp_cfcs
operator||=
name|TLP_CFCS_PAR_ERROR
expr_stmt|;
name|tlp_cfcs
operator||=
name|TLP_CFCS_SYS_ERROR
expr_stmt|;
name|WRITE_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFCS
argument_list|,
name|tlp_cfcs
argument_list|)
expr_stmt|;
comment|/* Set the LATENCY TIMER to the recommended value, */
comment|/*  and make sure the CACHE LINE SIZE is reasonable. */
name|tlp_cfit
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFIT
argument_list|)
expr_stmt|;
name|tlp_cflt
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFLT
argument_list|)
expr_stmt|;
name|tlp_cflt
operator|&=
operator|~
name|TLP_CFLT_LATENCY
expr_stmt|;
name|tlp_cflt
operator||=
operator|(
name|tlp_cfit
operator|&
name|TLP_CFIT_MAX_LAT
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* "prgmbl burst length" and "cache alignment" used below. */
switch|switch
condition|(
name|tlp_cflt
operator|&
name|TLP_CFLT_CACHE
condition|)
block|{
case|case
literal|8
case|:
comment|/* 8 bytes per cache line */
block|{
name|tlp_bus_pbl
operator|=
literal|32
expr_stmt|;
name|tlp_bus_cal
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
literal|16
case|:
block|{
name|tlp_bus_pbl
operator|=
literal|32
expr_stmt|;
name|tlp_bus_cal
operator|=
literal|2
expr_stmt|;
break|break;
block|}
case|case
literal|32
case|:
block|{
name|tlp_bus_pbl
operator|=
literal|32
expr_stmt|;
name|tlp_bus_cal
operator|=
literal|3
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|tlp_bus_pbl
operator|=
literal|32
expr_stmt|;
name|tlp_bus_cal
operator|=
literal|1
expr_stmt|;
name|tlp_cflt
operator|&=
operator|~
name|TLP_CFLT_CACHE
expr_stmt|;
name|tlp_cflt
operator||=
literal|8
expr_stmt|;
break|break;
block|}
block|}
name|WRITE_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFLT
argument_list|,
name|tlp_cflt
argument_list|)
expr_stmt|;
comment|/* Make sure SNOOZE and SLEEP modes are disabled. */
name|tlp_cfdd
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFDD
argument_list|)
expr_stmt|;
name|tlp_cfdd
operator|&=
operator|~
name|TLP_CFDD_SLEEP
expr_stmt|;
name|tlp_cfdd
operator|&=
operator|~
name|TLP_CFDD_SNOOZE
expr_stmt|;
name|WRITE_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFDD
argument_list|,
name|tlp_cfdd
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|11
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Tulip wakes up in 10 ms max */
comment|/* Software Reset the Tulip chip; stops DMA and Interrupts. */
comment|/* This does not change the PCI config regs just set above. */
name|WRITE_CSR
argument_list|(
name|TLP_BUS_MODE
argument_list|,
name|TLP_BUS_RESET
argument_list|)
expr_stmt|;
comment|/* self-clearing */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Tulip is dead for 50 PCI cycles after reset. */
comment|/* Reset the Xilinx Field Programmable Gate Array. */
name|reset_xilinx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* side effect: turns on all four LEDs */
comment|/* Configure card-specific stuff (framers, line interfaces, etc.). */
name|sc
operator|->
name|card
operator|->
name|config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initializing cards can glitch clocks and upset fifos. */
comment|/* Reset the FIFOs between the Tulip and Xilinx chips. */
name|set_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_FIFO
argument_list|)
expr_stmt|;
name|clr_mii16_bits
argument_list|(
name|sc
argument_list|,
name|MII16_FIFO
argument_list|)
expr_stmt|;
comment|/* Initialize the PCI busmode register. */
comment|/* The PCI bus cycle type "Memory Write and Invalidate" does NOT */
comment|/*  work cleanly in any version of the 21140A, so don't enable it! */
name|WRITE_CSR
argument_list|(
name|TLP_BUS_MODE
argument_list|,
operator|(
name|tlp_bus_cal
condition|?
name|TLP_BUS_READ_LINE
else|:
literal|0
operator|)
operator||
operator|(
name|tlp_bus_cal
condition|?
name|TLP_BUS_READ_MULT
else|:
literal|0
operator|)
operator||
operator|(
name|tlp_bus_pbl
operator|<<
name|TLP_BUS_PBL_SHIFT
operator|)
operator||
operator|(
name|tlp_bus_cal
operator|<<
name|TLP_BUS_CAL_SHIFT
operator|)
operator||
operator|(
operator|(
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
condition|?
name|TLP_BUS_DESC_BIGEND
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
condition|?
name|TLP_BUS_DATA_BIGEND
else|:
literal|0
operator|)
operator||
name|TLP_BUS_DSL_VAL
operator||
name|TLP_BUS_ARB
argument_list|)
expr_stmt|;
comment|/* Pick number of RX descriptors and TX fifo threshold. */
comment|/* tx_threshold in bytes: 0=128, 1=256, 2=512, 3=1024 */
name|tlp_csid
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CSID
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tlp_csid
condition|)
block|{
case|case
name|TLP_CSID_HSSI
case|:
comment|/* 52 Mb/s */
case|case
name|TLP_CSID_HSSIc
case|:
comment|/* 52 Mb/s */
case|case
name|TLP_CSID_T3
case|:
comment|/* 45 Mb/s */
block|{
name|num_rx_descs
operator|=
literal|48
expr_stmt|;
name|tlp_op_tr
operator|=
literal|2
expr_stmt|;
break|break;
block|}
case|case
name|TLP_CSID_SSI
case|:
comment|/* 10 Mb/s */
block|{
name|num_rx_descs
operator|=
literal|32
expr_stmt|;
name|tlp_op_tr
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|TLP_CSID_T1E1
case|:
comment|/*  2 Mb/s */
block|{
name|num_rx_descs
operator|=
literal|16
expr_stmt|;
name|tlp_op_tr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|num_rx_descs
operator|=
literal|16
expr_stmt|;
name|tlp_op_tr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* Create DMA descriptors and initialize list head registers. */
if|if
condition|(
operator|(
name|error
operator|=
name|create_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txring
argument_list|,
name|NUM_TX_DESCS
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|WRITE_CSR
argument_list|(
name|TLP_TX_LIST
argument_list|,
name|sc
operator|->
name|txring
operator|.
name|dma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|create_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxring
argument_list|,
name|num_rx_descs
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|WRITE_CSR
argument_list|(
name|TLP_RX_LIST
argument_list|,
name|sc
operator|->
name|rxring
operator|.
name|dma_addr
argument_list|)
expr_stmt|;
comment|/* Initialize the operating mode register. */
name|WRITE_CSR
argument_list|(
name|TLP_OP_MODE
argument_list|,
name|TLP_OP_INIT
operator||
operator|(
name|tlp_op_tr
operator|<<
name|TLP_OP_TR_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Read the missed frame register (result ignored) to zero it. */
name|error
operator|=
name|READ_CSR
argument_list|(
name|TLP_MISSED
argument_list|)
expr_stmt|;
comment|/* error is used as a bit-dump */
comment|/* Disable rx watchdog and tx jabber features. */
name|WRITE_CSR
argument_list|(
name|TLP_WDOG
argument_list|,
name|TLP_WDOG_INIT
argument_list|)
expr_stmt|;
comment|/* Enable card interrupts. */
name|WRITE_CSR
argument_list|(
name|TLP_INT_ENBL
argument_list|,
name|TLP_INT_TXRX
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Stop DMA and Interrupts; free descriptors and buffers. */
end_comment

begin_function
specifier|static
name|void
name|shutdown_card
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
comment|/* Leave the LEDs in the state they were in after power-on. */
name|led_on
argument_list|(
name|sc
argument_list|,
name|MII16_LED_ALL
argument_list|)
expr_stmt|;
comment|/* Software reset the Tulip chip; stops DMA and Interrupts */
name|WRITE_CSR
argument_list|(
name|TLP_BUS_MODE
argument_list|,
name|TLP_BUS_RESET
argument_list|)
expr_stmt|;
comment|/* self-clearing */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Tulip is dead for 50 PCI cycles after reset. */
comment|/* Disconnect from the PCI bus except for config cycles. */
comment|/* Hmmm; Linux syslogs a warning that IO and MEM are disabled. */
name|WRITE_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFCS
argument_list|,
name|TLP_CFCS_MEM_ENABLE
operator||
name|TLP_CFCS_IO_ENABLE
argument_list|)
expr_stmt|;
comment|/* Free the DMA descriptor rings. */
name|destroy_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txring
argument_list|)
expr_stmt|;
name|destroy_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxring
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start the card and attach a kernel interface and line protocol. */
end_comment

begin_function
specifier|static
name|int
name|attach_card
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|intrstr
parameter_list|)
block|{
name|struct
name|config
name|config
decl_stmt|;
name|u_int32_t
name|tlp_cfrv
decl_stmt|;
name|u_int16_t
name|mii3
decl_stmt|;
name|u_int8_t
modifier|*
name|ieee
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* Start the card. */
if|if
condition|(
operator|(
name|error
operator|=
name|startup_card
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Attach a kernel interface. */
if|#
directive|if
name|NETGRAPH
if|if
condition|(
operator|(
name|error
operator|=
name|ng_attach
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|flags
operator||=
name|FLAG_NETGRAPH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|lmc_ifnet_attach
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|flags
operator||=
name|FLAG_IFNET
expr_stmt|;
comment|/* Attach a line protocol stack. */
name|sc
operator|->
name|config
operator|.
name|line_pkg
operator|=
name|PKG_RAWIP
expr_stmt|;
name|config
operator|=
name|sc
operator|->
name|config
expr_stmt|;
comment|/* get current config */
name|config
operator|.
name|line_pkg
operator|=
literal|0
expr_stmt|;
comment|/* select external stack */
name|config
operator|.
name|line_prot
operator|=
name|PROT_C_HDLC
expr_stmt|;
name|config
operator|.
name|keep_alive
operator|=
literal|1
expr_stmt|;
name|config_proto
argument_list|(
name|sc
argument_list|,
operator|&
name|config
argument_list|)
expr_stmt|;
comment|/* reconfigure */
name|sc
operator|->
name|config
operator|=
name|config
expr_stmt|;
comment|/* save new configuration */
comment|/* Print interesting hardware-related things. */
name|mii3
operator|=
name|read_mii
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tlp_cfrv
operator|=
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CFRV
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: PCI rev %d.%d, MII rev %d.%d"
argument_list|,
name|NAME_UNIT
argument_list|,
operator|(
name|tlp_cfrv
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|,
name|tlp_cfrv
operator|&
literal|0xF
argument_list|,
operator|(
name|mii3
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|,
name|mii3
operator|&
literal|0xF
argument_list|)
expr_stmt|;
name|ieee
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|status
operator|.
name|ieee
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|status
operator|.
name|ieee
index|[
name|i
index|]
operator|=
name|read_srom
argument_list|(
name|sc
argument_list|,
literal|10
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", IEEE addr %02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|ieee
index|[
literal|0
index|]
argument_list|,
name|ieee
index|[
literal|1
index|]
argument_list|,
name|ieee
index|[
literal|2
index|]
argument_list|,
name|ieee
index|[
literal|3
index|]
argument_list|,
name|ieee
index|[
literal|4
index|]
argument_list|,
name|ieee
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|card
operator|->
name|ident
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
comment|/* Print interesting software-related things. */
name|printf
argument_list|(
literal|"%s: Driver rev %d.%d.%d"
argument_list|,
name|NAME_UNIT
argument_list|,
name|DRIVER_MAJOR_VERSION
argument_list|,
name|DRIVER_MINOR_VERSION
argument_list|,
name|DRIVER_SUB_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", Options %s%s%s%s%s%s%s%s%s\n"
argument_list|,
name|NETGRAPH
condition|?
literal|"NETGRAPH "
else|:
literal|""
argument_list|,
name|GEN_HDLC
condition|?
literal|"GEN_HDLC "
else|:
literal|""
argument_list|,
name|NSPPP
condition|?
literal|"SPPP "
else|:
literal|""
argument_list|,
name|P2P
condition|?
literal|"P2P "
else|:
literal|""
argument_list|,
name|ALTQ_PRESENT
condition|?
literal|"ALTQ "
else|:
literal|""
argument_list|,
name|NBPFILTER
condition|?
literal|"BPF "
else|:
literal|""
argument_list|,
name|DEV_POLL
condition|?
literal|"POLL "
else|:
literal|""
argument_list|,
name|IOREF_CSR
condition|?
literal|"IO_CSR "
else|:
literal|"MEM_CSR "
argument_list|,
operator|(
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
condition|?
literal|"BIG_END "
else|:
literal|"LITTLE_END "
argument_list|)
expr_stmt|;
comment|/* Make the local hardware ready. */
name|set_status
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Detach from the kernel in all ways. */
end_comment

begin_function
specifier|static
name|void
name|detach_card
parameter_list|(
name|softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|config
name|config
decl_stmt|;
comment|/* Make the local hardware NOT ready. */
name|set_status
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Detach external line protocol stack. */
if|if
condition|(
name|sc
operator|->
name|config
operator|.
name|line_pkg
operator|!=
name|PKG_RAWIP
condition|)
block|{
name|config
operator|=
name|sc
operator|->
name|config
expr_stmt|;
name|config
operator|.
name|line_pkg
operator|=
name|PKG_RAWIP
expr_stmt|;
name|config_proto
argument_list|(
name|sc
argument_list|,
operator|&
name|config
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|=
name|config
expr_stmt|;
block|}
comment|/* Detach kernel interfaces. */
if|#
directive|if
name|NETGRAPH
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FLAG_NETGRAPH
condition|)
block|{
name|IFQ_PURGE
argument_list|(
operator|&
name|sc
operator|->
name|ng_fastq
argument_list|)
expr_stmt|;
name|IFQ_PURGE
argument_list|(
operator|&
name|sc
operator|->
name|ng_sndq
argument_list|)
expr_stmt|;
name|ng_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FLAG_NETGRAPH
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FLAG_IFNET
condition|)
block|{
name|IFQ_PURGE
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|lmc_ifnet_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FLAG_IFNET
expr_stmt|;
block|}
comment|/* Reset the Tulip chip; stops DMA and Interrupts. */
name|shutdown_card
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the I/O configuration interface for FreeBSD */
end_comment

begin_function
specifier|static
name|int
name|fbsd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|cfid
init|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|TLP_CFID
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|u_int32_t
name|csid
init|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|TLP_CSID
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|/* Looking for a DEC 21140A chip on any Lan Media Corp card. */
if|if
condition|(
name|cfid
operator|!=
name|TLP_CFID_TULIP
condition|)
return|return
name|ENXIO
return|;
switch|switch
condition|(
name|csid
condition|)
block|{
case|case
name|TLP_CSID_HSSI
case|:
case|case
name|TLP_CSID_HSSIc
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|HSSI_DESC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLP_CSID_T3
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|T3_DESC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLP_CSID_SSI
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|SSI_DESC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLP_CSID_T1E1
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|T1E1_DESC
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Stop the card and detach from the kernel. */
name|detach_card
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Release resources. */
if|if
condition|(
name|sc
operator|->
name|irq_cookie
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|irq_cookie
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_cookie
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_res_id
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|csr_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|csr_res_type
argument_list|,
name|sc
operator|->
name|csr_res_id
argument_list|,
name|sc
operator|->
name|csr_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|csr_res
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|top_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|bottom_mtx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* no error */
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|shutdown_card
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* READ/WRITE_PCI_CFG need this. */
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* What kind of card are we driving? */
switch|switch
condition|(
name|READ_PCI_CFG
argument_list|(
name|sc
argument_list|,
name|TLP_CSID
argument_list|)
condition|)
block|{
case|case
name|TLP_CSID_HSSI
case|:
case|case
name|TLP_CSID_HSSIc
case|:
name|sc
operator|->
name|card
operator|=
operator|&
name|hssi_card
expr_stmt|;
break|break;
case|case
name|TLP_CSID_T3
case|:
name|sc
operator|->
name|card
operator|=
operator|&
name|t3_card
expr_stmt|;
break|break;
case|case
name|TLP_CSID_SSI
case|:
name|sc
operator|->
name|card
operator|=
operator|&
name|ssi_card
expr_stmt|;
break|break;
case|case
name|TLP_CSID_T1E1
case|:
name|sc
operator|->
name|card
operator|=
operator|&
name|t1_card
expr_stmt|;
break|break;
default|default:
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|dev_desc
operator|=
name|device_get_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate PCI memory or IO resources to access the Tulip chip CSRs. */
if|#
directive|if
name|IOREF_CSR
name|sc
operator|->
name|csr_res_id
operator|=
name|TLP_CBIO
expr_stmt|;
name|sc
operator|->
name|csr_res_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|csr_res_id
operator|=
name|TLP_CBMA
expr_stmt|;
name|sc
operator|->
name|csr_res_type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|csr_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|csr_res_type
argument_list|,
operator|&
name|sc
operator|->
name|csr_res_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|csr_res
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bus_alloc_resource(csr) failed.\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|csr_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|csr_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|csr_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|csr_res
argument_list|)
expr_stmt|;
comment|/* Allocate PCI interrupt resources for the card. */
name|sc
operator|->
name|irq_res_id
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_res_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bus_alloc_resource(irq) failed.\n"
argument_list|,
name|NAME_UNIT
argument_list|)
expr_stmt|;
name|fbsd_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bsd_interrupt
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_cookie
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bus_setup_intr() failed; error %d\n"
argument_list|,
name|NAME_UNIT
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|fbsd_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Initialize the top-half and bottom-half locks. */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|top_mtx
argument_list|,
name|NAME_UNIT
argument_list|,
literal|"top half lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|bottom_mtx
argument_list|,
name|NAME_UNIT
argument_list|,
literal|"bottom half lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Start the card and attach a kernel interface and line protocol. */
if|if
condition|(
operator|(
name|error
operator|=
name|attach_card
argument_list|(
name|sc
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
name|detach_card
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fbsd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fbsd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fbsd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|fbsd_shutdown
argument_list|)
block|,
comment|/* This driver does not suspend and resume. */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|driver
init|=
block|{
operator|.
name|name
operator|=
name|DEVICE_NAME
block|,
operator|.
name|methods
operator|=
name|methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|softc_t
argument_list|)
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|lmc
argument_list|,
name|pci
argument_list|,
name|driver
argument_list|,
name|devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|lmc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|lmc
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|NETGRAPH
end_if

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|lmc
argument_list|,
name|netgraph
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NSPPP
end_if

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|lmc
argument_list|,
name|sppp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the I/O configuration interface for NetBSD. */
end_comment

begin_comment
comment|/* This is the I/O configuration interface for OpenBSD. */
end_comment

begin_comment
comment|/* This is the I/O configuration interface for BSD/OS. */
end_comment

end_unit

