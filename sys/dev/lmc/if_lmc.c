begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*      From NetBSD: if_de.c,v 1.56.2.1 1997/10/27 02:13:25 thorpej Exp    */
end_comment

begin_comment
comment|/*	$Id: if_lmc.c,v 1.9 1999/02/19 15:08:42 explorer Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1994-1997 Matt Thomas (matt@3am-software.com)  * Copyright (c) LAN Media Corporation 1998, 1999.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_decl_stmt
name|char
name|lmc_version
index|[]
init|=
literal|"BSD 1.1"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* only for declaration of wakeup() used by vm.h */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/pci/pcidevs.h>
end_include

begin_include
include|#
directive|include
file|"rnd.h"
end_include

begin_if
if|#
directive|if
name|NRND
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/rnd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_p2p.h>
end_include

begin_include
include|#
directive|include
file|<net/if_c_hdlc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/dc21040reg.h>
end_include

begin_define
define|#
directive|define
name|INCLUDE_PATH_PREFIX
value|"pci/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/pci/ic/dc21040.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/dma.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<i386/pci/pci.h>
end_include

begin_define
define|#
directive|define
name|INCLUDE_PATH_PREFIX
value|"i386/pci/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __bsdi__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/dc21040reg.h>
end_include

begin_define
define|#
directive|define
name|INCLUDE_PATH_PREFIX
value|"dev/pci/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_comment
comment|/*  * Intel CPUs should use I/O mapped access.  XXXMLG Is this true on NetBSD  * too?  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_define
define|#
directive|define
name|LMC_IOMAPPED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This turns on all sort of debugging stuff and make the  * driver much larger.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|LMC_DEBUG
end_define

begin_define
define|#
directive|define
name|DP
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DP
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LMC_HZ
value|10
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TULIP_GP_PINSET
end_ifndef

begin_define
define|#
directive|define
name|TULIP_GP_PINSET
value|0x00000100L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TULIP_BUSMODE_READMULTIPLE
end_ifndef

begin_define
define|#
directive|define
name|TULIP_BUSMODE_READMULTIPLE
value|0x00200000L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * C sucks  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|lmc___softc
name|lmc_softc_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|lmc___media
name|lmc_media_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|lmc___ctl
name|lmc_ctl_t
typedef|;
end_typedef

begin_comment
comment|/*  * Sigh.  Every OS puts these in different places.  NetBSD and FreeBSD use  * a C preprocessor that allows this hack, but BSDI does not.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
include|INCLUDE_PATH_PREFIX "if_lmcioctl.h"
end_include

begin_include
include|#
directive|include
include|INCLUDE_PATH_PREFIX "if_lmcvar.h"
end_include

begin_include
include|#
directive|include
include|INCLUDE_PATH_PREFIX "if_lmc_common.c"
end_include

begin_include
include|#
directive|include
include|INCLUDE_PATH_PREFIX "if_lmc_media.c"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BSDI */
end_comment

begin_include
include|#
directive|include
file|"i386/pci/if_lmcioctl.h"
end_include

begin_include
include|#
directive|include
file|"i386/pci/if_lmcvar.h"
end_include

begin_include
include|#
directive|include
file|"i386/pci/if_lmc_common.c"
end_include

begin_include
include|#
directive|include
file|"i386/pci/if_lmc_media.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This module supports  *	the DEC 21140A pass 2.2 PCI Fast Ethernet Controller.  */
end_comment

begin_function_decl
specifier|static
name|lmc_intrfunc_t
name|lmc_intr_normal
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ifnet_ret_t
name|lmc_ifstart_one
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ifnet_ret_t
name|lmc_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lmc_txput
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lmc_rx_intr
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|lmc_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|lmc_watchdog
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|lmc_ifup
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lmc_ifdown
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  * Code the read the SROM and MII bit streams (I2C)  */
end_comment

begin_function
specifier|static
name|void
name|lmc_delay_300ns
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
operator|(
literal|300
operator|/
literal|33
operator|)
operator|+
literal|1
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
operator|(
name|void
operator|)
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|EMIT
define|\
value|do { \ 	LMC_CSR_WRITE(sc, csr_srom_mii, csr); \ 	lmc_delay_300ns(sc); \ } while (0)
end_define

begin_function
specifier|static
name|void
name|lmc_srom_idle
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|bit
decl_stmt|,
name|csr
decl_stmt|;
name|csr
operator|=
name|SROMSEL
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCS
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* 	 * Write 25 cycles of 0 which will force the SROM to be idle. 	 */
for|for
control|(
name|bit
operator|=
literal|3
operator|+
name|SROM_BITWIDTH
operator|+
literal|16
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|--
control|)
block|{
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; data not valid */
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock high; data valid */
block|}
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCS
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
name|EMIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_srom_read
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|idx
decl_stmt|;
specifier|const
name|unsigned
name|bitwidth
init|=
name|SROM_BITWIDTH
decl_stmt|;
specifier|const
name|unsigned
name|cmdmask
init|=
operator|(
name|SROMCMD_RD
operator|<<
name|bitwidth
operator|)
decl_stmt|;
specifier|const
name|unsigned
name|msb
init|=
literal|1
operator|<<
operator|(
name|bitwidth
operator|+
literal|3
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|lastidx
init|=
operator|(
literal|1
operator|<<
name|bitwidth
operator|)
operator|-
literal|1
decl_stmt|;
name|lmc_srom_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<=
name|lastidx
condition|;
name|idx
operator|++
control|)
block|{
name|unsigned
name|lastbit
decl_stmt|,
name|data
decl_stmt|,
name|bits
decl_stmt|,
name|bit
decl_stmt|,
name|csr
decl_stmt|;
name|csr
operator|=
name|SROMSEL
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCSON
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
name|lastbit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bits
operator|=
name|idx
operator||
name|cmdmask
operator|,
name|bit
operator|=
name|bitwidth
operator|+
literal|3
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|--
operator|,
name|bits
operator|<<=
literal|1
control|)
block|{
specifier|const
name|unsigned
name|thisbit
init|=
name|bits
operator|&
name|msb
decl_stmt|;
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock L data invalid */
if|if
condition|(
name|thisbit
operator|!=
name|lastbit
condition|)
block|{
name|csr
operator|^=
name|SROMDOUT
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock L invert data */
block|}
else|else
block|{
name|EMIT
expr_stmt|;
block|}
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock H data valid */
name|lastbit
operator|=
name|thisbit
expr_stmt|;
block|}
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|bits
operator|=
literal|0
init|;
name|bits
operator|<
literal|16
condition|;
name|bits
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock H data valid */
name|data
operator||=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
name|SROMDIN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock L data invalid */
block|}
name|sc
operator|->
name|lmc_rombuf
index|[
name|idx
operator|*
literal|2
index|]
operator|=
name|data
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|lmc_rombuf
index|[
name|idx
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|data
operator|>>
literal|8
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
name|EMIT
expr_stmt|;
block|}
name|lmc_srom_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MII_EMIT
value|do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)
end_define

begin_function
specifier|static
name|void
name|lmc_mii_writebits
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|data
parameter_list|,
name|unsigned
name|bits
parameter_list|)
block|{
name|unsigned
name|msb
init|=
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|unsigned
name|lastbit
init|=
operator|(
name|csr
operator|&
name|MII_DOUT
operator|)
condition|?
name|msb
else|:
literal|0
decl_stmt|;
name|csr
operator||=
name|MII_WR
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; assert write */
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
operator|,
name|data
operator|<<=
literal|1
control|)
block|{
specifier|const
name|unsigned
name|thisbit
init|=
name|data
operator|&
name|msb
decl_stmt|;
if|if
condition|(
name|thisbit
operator|!=
name|lastbit
condition|)
block|{
name|csr
operator|^=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; invert data */
block|}
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|lastbit
operator|=
name|thisbit
expr_stmt|;
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_mii_turnaround
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|cmd
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MII_WRCMD
condition|)
block|{
name|csr
operator||=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; change data */
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
name|csr
operator|^=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; change data */
block|}
else|else
block|{
name|csr
operator||=
name|MII_RD
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; switch to read */
block|}
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
end_function

begin_function
specifier|static
name|unsigned
name|lmc_mii_readbits
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|data
decl_stmt|;
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|data
operator|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
comment|/* this is NOOP on the first pass through */
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
if|if
condition|(
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
name|MII_DIN
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
name|csr
operator|^=
name|MII_RD
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; turn off read */
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|lmc_mii_readreg
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|unsigned
name|data
decl_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|MII_RD
operator||
name|MII_CLK
operator|)
expr_stmt|;
name|MII_EMIT
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_PREAMBLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_RDCMD
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lmc_mii_turnaround
argument_list|(
name|sc
argument_list|,
name|MII_RDCMD
argument_list|)
expr_stmt|;
name|data
operator|=
name|lmc_mii_readbits
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_mii_writereg
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|,
name|unsigned
name|data
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|MII_RD
operator||
name|MII_CLK
operator|)
expr_stmt|;
name|MII_EMIT
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_PREAMBLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_WRCMD
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lmc_mii_turnaround
argument_list|(
name|sc
argument_list|,
name|MII_WRCMD
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|lmc_read_macaddr
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|lmc_srom_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|lmc_rombuf
operator|+
literal|20
argument_list|,
name|sc
operator|->
name|lmc_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Check to make certain there is a signal from the modem, and flicker  * lights as needed.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|lmc_watchdog
argument_list|(
expr|struct
name|ifnet
operator|*
name|ifp
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
decl|static
name|int
name|lmc_watchdog
argument_list|(
name|int
name|unit
argument_list|)
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|lmc_softc_t
modifier|*
specifier|const
name|sc
init|=
name|LMC_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|lmc_softc_t
modifier|*
specifier|const
name|sc
init|=
name|LMC_UNIT_TO_SOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|lmc_if
decl_stmt|;
endif|#
directive|endif
name|int
name|state
decl_stmt|;
name|u_int32_t
name|ostatus
decl_stmt|;
name|u_int32_t
name|link_status
decl_stmt|;
name|u_int32_t
name|ticks
decl_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|link_status
operator|=
name|sc
operator|->
name|lmc_media
operator|->
name|get_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ostatus
operator|=
operator|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_MODEMOK
operator|)
operator|==
name|LMC_MODEMOK
operator|)
expr_stmt|;
comment|/* 	 * hardware level link lost, but the interface is marked as up. 	 * Mark it as down. 	 */
if|if
condition|(
name|link_status
operator|==
literal|0
operator|&&
name|ostatus
condition|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": physical link down\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_MODEMOK
expr_stmt|;
name|lmc_led_off
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * hardware link is up, but the interface is marked as down. 	 * Bring it back up again. 	 */
if|if
condition|(
name|link_status
operator|!=
literal|0
operator|&&
operator|!
name|ostatus
condition|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": physical link up\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
condition|)
name|lmc_ifup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_MODEMOK
expr_stmt|;
name|lmc_led_on
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * remember the timer value 	 */
name|ticks
operator|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|0xffffffffUL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ictl
operator|.
name|ticks
operator|=
literal|0x0000ffff
operator|-
operator|(
name|ticks
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Mark the interface as "up" and enable TX/RX and TX/RX interrupts.  * This also does a full software reset.  */
end_comment

begin_function
specifier|static
name|void
name|lmc_ifup
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|lmc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|lmc_dec_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lmc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_link_status
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_status
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_IFUP
expr_stmt|;
name|lmc_led_on
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED1
argument_list|)
expr_stmt|;
comment|/* 	 * select what interrupts we want to get 	 */
name|sc
operator|->
name|lmc_intrmask
operator||=
operator|(
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_TXINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_SYSERROR
operator||
name|TULIP_STS_TXSTOPPED
operator||
name|TULIP_STS_TXUNDERFLOW
operator||
name|TULIP_STS_RXSTOPPED
operator|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|lmc_intrmask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_cmdmode
operator||=
name|TULIP_CMD_TXRUN
expr_stmt|;
name|sc
operator|->
name|lmc_cmdmode
operator||=
name|TULIP_CMD_RXRUN
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_if
operator|.
name|if_timer
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark the interface as "down" and disable TX/RX and TX/RX interrupts.  * This is done by performing a full reset on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|lmc_ifdown
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|lmc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_IFUP
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_link_status
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lmc_led_off
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED1
argument_list|)
expr_stmt|;
name|lmc_dec_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lmc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_status
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_rx_intr
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|lmc_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|lmc_rxinfo
decl_stmt|;
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
init|=
operator|&
name|sc
operator|->
name|lmc_if
decl_stmt|;
name|int
name|fillok
init|=
literal|1
decl_stmt|;
name|sc
operator|->
name|lmc_rxtick
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tulip_desc_t
modifier|*
name|eop
init|=
name|ri
operator|->
name|ri_nextin
decl_stmt|;
name|int
name|total_len
init|=
literal|0
decl_stmt|,
name|last_offset
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ms
init|=
name|NULL
decl_stmt|,
modifier|*
name|me
init|=
name|NULL
decl_stmt|;
name|int
name|accept
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fillok
operator|&&
name|sc
operator|->
name|lmc_rxq
operator|.
name|ifq_len
operator|<
name|LMC_RXQ_TARGET
condition|)
goto|goto
name|queue_mbuf
goto|;
comment|/* 		 * If the TULIP has no descriptors, there can't be any receive 		 * descriptors to process. 		 */
if|if
condition|(
name|eop
operator|==
name|ri
operator|->
name|ri_nextout
condition|)
break|break;
comment|/* 		 * 90% of the packets will fit in one descriptor.  So we 		 * optimize for that case. 		 */
if|if
condition|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
operator|(
name|TULIP_DSTS_OWNER
operator||
name|TULIP_DSTS_RxFIRSTDESC
operator||
name|TULIP_DSTS_RxLASTDESC
operator|)
operator|)
operator|==
operator|(
name|TULIP_DSTS_RxFIRSTDESC
operator||
name|TULIP_DSTS_RxLASTDESC
operator|)
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|me
operator|=
name|ms
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If still owned by the TULIP, don't touch it. 			 */
if|if
condition|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
comment|/* 			 * It is possible (though improbable unless the 			 * BIG_PACKET support is enabled or MCLBYTES< 1518) 			 * for a received packet to cross more than one 			 * receive descriptor. 			 */
while|while
condition|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxLASTDESC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
if|if
condition|(
name|eop
operator|==
name|ri
operator|->
name|ri_nextout
operator|||
operator|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
operator|)
operator|)
condition|)
block|{
return|return;
block|}
name|total_len
operator|++
expr_stmt|;
block|}
comment|/* 			 * Dequeue the first buffer for the start of the 			 * packet.  Hopefully this will be the only one we 			 * need to dequeue.  However, if the packet consumed 			 * multiple descriptors, then we need to dequeue 			 * those buffers and chain to the starting mbuf. 			 * All buffers but the last buffer have the same 			 * length so we can set that now. (we add to 			 * last_offset instead of multiplying since we 			 * normally won't go into the loop and thereby 			 * saving a ourselves from doing a multiplication 			 * by 0 in the normal case). 			 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
for|for
control|(
name|me
operator|=
name|ms
init|;
name|total_len
operator|>
literal|0
condition|;
name|total_len
operator|--
control|)
block|{
name|me
operator|->
name|m_len
operator|=
name|LMC_RX_BUFLEN
expr_stmt|;
name|last_offset
operator|+=
name|LMC_RX_BUFLEN
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|me
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|me
operator|=
name|me
operator|->
name|m_next
expr_stmt|;
block|}
block|}
comment|/* 		 *  Now get the size of received packet (minus the CRC). 		 */
name|total_len
operator|=
operator|(
operator|(
name|eop
operator|->
name|d_status
operator|>>
literal|16
operator|)
operator|&
literal|0x7FFF
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ictl
operator|.
name|crc_length
operator|==
literal|16
condition|)
name|total_len
operator|-=
literal|2
expr_stmt|;
else|else
name|total_len
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_RXIGNORE
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|eop
operator|->
name|d_status
operator|&
name|LMC_DSTS_ERRSUM
operator|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|BIG_PACKET
operator|||
operator|(
name|total_len
operator|<=
name|sc
operator|->
name|lmc_if
operator|.
name|if_mtu
operator|+
name|PPP_HEADER_LEN
operator|&&
operator|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxOVERFLOW
operator|)
operator|==
literal|0
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|me
operator|->
name|m_len
operator|=
name|total_len
operator|-
name|last_offset
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|lmc_bpf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|me
operator|==
name|ms
condition|)
name|LMC_BPF_TAP
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|ms
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
else|else
name|LMC_BPF_MTAP
argument_list|(
name|sc
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_RXACT
expr_stmt|;
name|accept
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxOVERFLOW
condition|)
block|{
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|eop
expr_stmt|;
name|queue_mbuf
label|:
comment|/* 		 * Either we are priming the TULIP with mbufs (m == NULL) 		 * or we are about to accept an mbuf for the upper layers 		 * so we need to allocate an mbuf to replace it.  If we 		 * can't replace it, send up it anyways.  This may cause 		 * us to drop packets in the future but that's better than 		 * being caught in livelock. 		 * 		 * Note that if this packet crossed multiple descriptors 		 * we don't even try to reallocate all the mbufs here. 		 * Instead we rely on the test of the beginning of 		 * the loop to refill for the extra consumed mbufs. 		 */
if|if
condition|(
name|accept
operator|||
name|ms
operator|==
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|accept
condition|)
block|{
name|ms
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|total_len
expr_stmt|;
name|ms
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sppp_input
argument_list|(
name|ifp
argument_list|,
name|ms
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|sc
operator|->
name|lmc_p2pcom
operator|.
name|p2p_input
argument_list|(
operator|&
name|sc
operator|->
name|lmc_p2pcom
argument_list|,
name|ms
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ms
operator|=
name|m0
expr_stmt|;
block|}
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Couldn't allocate a new buffer.  Don't bother  			 * trying to replenish the receive queue. 			 */
name|fillok
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_RXBUFSLOW
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Now give the buffer(s) to the TULIP and save in our 		 * receive queue. 		 */
do|do
block|{
name|ri
operator|->
name|ri_nextout
operator|->
name|d_length1
operator|=
name|LMC_RX_BUFLEN
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_addr1
operator|=
name|LMC_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|ms
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|me
operator|=
name|ms
operator|->
name|m_next
expr_stmt|;
name|ms
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ms
operator|=
name|me
operator|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|sc
operator|->
name|lmc_rxq
operator|.
name|ifq_len
operator|>=
name|LMC_RXQ_TARGET
condition|)
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_RXBUFSLOW
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|lmc_tx_intr
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|lmc_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|lmc_txinfo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|xmits
init|=
literal|0
decl_stmt|;
name|int
name|descs
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|lmc_txtick
operator|++
expr_stmt|;
while|while
condition|(
name|ri
operator|->
name|ri_free
operator|<
name|ri
operator|->
name|ri_max
condition|)
block|{
name|u_int32_t
name|d_flag
decl_stmt|;
if|if
condition|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|ri
operator|->
name|ri_nextin
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
name|d_flag
operator|=
name|ri
operator|->
name|ri_nextin
operator|->
name|d_flag
expr_stmt|;
if|if
condition|(
name|d_flag
operator|&
name|TULIP_DFLAG_TxLASTSEG
condition|)
block|{
specifier|const
name|u_int32_t
name|d_status
init|=
name|ri
operator|->
name|ri_nextin
operator|->
name|d_status
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|lmc_bpf
operator|!=
name|NULL
condition|)
name|LMC_BPF_MTAP
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LMC_DEBUG
argument_list|)
block|}
else|else
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": tx_intr: failed to dequeue mbuf?!?\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|xmits
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|LMC_DSTS_ERRSUM
condition|)
block|{
name|sc
operator|->
name|lmc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxUNDERFLOW
condition|)
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsInternalTransmitUnderflows
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxDEFERRED
condition|)
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsDeferredTransmissions
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextin
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|++
expr_stmt|;
name|descs
operator|++
expr_stmt|;
name|sc
operator|->
name|lmc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
comment|/*      * If nothing left to transmit, disable the timer.      * Else if progress, reset the timer back to 2 ticks.      */
name|sc
operator|->
name|lmc_if
operator|.
name|if_opackets
operator|+=
name|xmits
expr_stmt|;
return|return
name|descs
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|lmc_print_abnormal_interrupt
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|u_int32_t
name|csr
parameter_list|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": Abnormal interrupt\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_intr_handler
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|int
modifier|*
name|progress_p
parameter_list|)
block|{
name|u_int32_t
name|csr
decl_stmt|;
while|while
condition|(
operator|(
name|csr
operator|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
operator|)
operator|&
name|sc
operator|->
name|lmc_intrmask
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|#
directive|if
name|NRND
operator|>
literal|0
name|rnd_add_uint32
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rndsource
argument_list|,
name|csr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|*
name|progress_p
operator|=
literal|1
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_SYSERROR
condition|)
block|{
name|sc
operator|->
name|lmc_last_system_error
operator|=
operator|(
name|csr
operator|&
name|TULIP_STS_ERRORMASK
operator|)
operator|>>
name|TULIP_STS_ERR_SHIFT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_NOMESSAGES
condition|)
block|{
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_SYSTEMERROR
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": system error: %s\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|,
name|lmc_system_errors
index|[
name|sc
operator|->
name|lmc_last_system_error
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_NEEDRESET
expr_stmt|;
name|sc
operator|->
name|lmc_system_errors
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csr
operator|&
operator|(
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_RXNOBUF
operator|)
condition|)
block|{
name|u_int32_t
name|misses
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_missed_frames
argument_list|)
decl_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_RXNOBUF
condition|)
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsMissedFrames
operator|+=
name|misses
operator|&
literal|0xFFFF
expr_stmt|;
comment|/* 	     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data 	     * on receive overflows. 	     */
if|if
condition|(
operator|(
name|misses
operator|&
literal|0x0FFE0000
operator|)
operator|&&
operator|(
name|sc
operator|->
name|lmc_features
operator|&
name|LMC_HAVE_RXBADOVRFLW
operator|)
condition|)
block|{
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
comment|/* 		 * Stop the receiver process and spin until it's stopped. 		 * Tell rx_intr to drop the packets it dequeues. 		 */
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
operator|&
operator|~
name|TULIP_CMD_RXRUN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
operator|&
name|TULIP_STS_RXSTOPPED
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|TULIP_STS_RXSTOPPED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_RXIGNORE
expr_stmt|;
block|}
name|lmc_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_RXIGNORE
condition|)
block|{
comment|/* 		 * Restart the receiver. 		 */
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_RXIGNORE
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_ABNRMLINTR
condition|)
block|{
name|u_int32_t
name|tmp
init|=
name|csr
operator|&
name|sc
operator|->
name|lmc_intrmask
operator|&
operator|~
operator|(
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator|)
decl_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_TXUNDERFLOW
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_cmdmode
operator|&
name|TULIP_CMD_THRESHOLDCTL
operator|)
operator|!=
name|TULIP_CMD_THRSHLD160
condition|)
block|{
name|sc
operator|->
name|lmc_cmdmode
operator|+=
name|TULIP_CMD_THRSHLD96
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_NEWTXTHRESH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|lmc_features
operator|&
name|LMC_HAVE_STOREFWD
condition|)
block|{
name|sc
operator|->
name|lmc_cmdmode
operator||=
name|TULIP_CMD_STOREFWD
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_NEWTXTHRESH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_NOMESSAGES
condition|)
block|{
name|sc
operator|->
name|lmc_statusbits
operator||=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|lmc_print_abnormal_interrupt
argument_list|(
name|sc
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_NOMESSAGES
expr_stmt|;
block|}
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_TXINTR
condition|)
name|lmc_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_WANTTXSTART
condition|)
name|lmc_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|lmc_if
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|lmc_intrfunc_t
name|lmc_intr_normal
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
operator|(
name|lmc_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|progress
init|=
literal|0
decl_stmt|;
name|lmc_intr_handler
argument_list|(
name|sc
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LMC_VOID_INTRFUNC
argument_list|)
return|return
name|progress
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lmc_mbuf_compress
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|#
directive|if
name|MCLBYTES
operator|>=
name|LMC_MTU
operator|+
name|PPP_HEADER_LEN
operator|&&
operator|!
name|defined
argument_list|(
name|BIG_PACKET
argument_list|)
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
else|#
directive|else
name|int
name|mlen
init|=
name|MHLEN
decl_stmt|;
name|int
name|len
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
init|=
operator|&
name|m0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mlen
operator|==
name|MHLEN
condition|)
block|{
name|MGETHDR
argument_list|(
operator|*
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
operator|*
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
operator|*
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
operator|(
name|len
operator|<=
name|MCLBYTES
condition|?
name|len
else|:
name|MCLBYTES
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
operator|(
name|len
operator|<=
name|mlen
condition|?
name|len
else|:
name|mlen
operator|)
expr_stmt|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|len
argument_list|,
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
operator|(
operator|*
name|mp
operator|)
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
expr_stmt|;
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
name|mlen
operator|=
name|MLEN
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|m0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * queue the mbuf handed to us for the interface.  If we cannot  * queue it, return the mbuf.  Return NULL if the mbuf was queued.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lmc_txput
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|lmc_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|lmc_txinfo
decl_stmt|;
name|tulip_desc_t
modifier|*
name|eop
decl_stmt|,
modifier|*
name|nextout
decl_stmt|;
name|int
name|segcnt
decl_stmt|,
name|free
decl_stmt|;
name|u_int32_t
name|d_status
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LMC_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_cmdmode
operator|&
name|TULIP_CMD_TXRUN
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": txput: tx not running\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_WANTTXSTART
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
endif|#
directive|endif
comment|/* 	 * Now we try to fill in our transmit descriptors.  This is 	 * a bit reminiscent of going on the Ark two by two 	 * since each descriptor for the TULIP can describe 	 * two buffers.  So we advance through packet filling 	 * each of the two entries at a time to fill each 	 * descriptor.  Clear the first and last segment bits 	 * in each descriptor (actually just clear everything 	 * but the end-of-ring or chain bits) to make sure 	 * we don't get messed up by previously sent packets. 	 * 	 * We may fail to put the entire packet on the ring if 	 * there is either not enough ring entries free or if the 	 * packet has more than MAX_TXSEG segments.  In the former 	 * case we will just wait for the ring to empty.  In the 	 * latter case we have to recopy. 	 */
name|again
label|:
name|d_status
operator|=
literal|0
expr_stmt|;
name|eop
operator|=
name|nextout
operator|=
name|ri
operator|->
name|ri_nextout
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|segcnt
operator|=
literal|0
expr_stmt|;
name|free
operator|=
name|ri
operator|->
name|ri_free
expr_stmt|;
do|do
block|{
name|int
name|len
init|=
name|m0
operator|->
name|m_len
decl_stmt|;
name|caddr_t
name|addr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
name|unsigned
name|clsize
init|=
name|CLBYTES
operator|-
operator|(
operator|(
operator|(
name|u_long
operator|)
name|addr
operator|)
operator|&
operator|(
name|CLBYTES
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|unsigned
name|slen
init|=
name|min
argument_list|(
name|len
argument_list|,
name|clsize
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
name|int
name|partial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|slen
operator|>=
literal|2048
condition|)
name|slen
operator|=
literal|2040
operator|,
name|partial
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|segcnt
operator|++
expr_stmt|;
if|if
condition|(
name|segcnt
operator|>
name|LMC_MAX_TXSEG
condition|)
block|{
comment|/* 				 * The packet exceeds the number of transmit 				 * buffer entries that we can use for one 				 * packet, so we have recopy it into one mbuf 				 * and then try again. 				 */
name|m
operator|=
name|lmc_mbuf_compress
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|finish
goto|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|segcnt
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|--
name|free
operator|==
literal|0
condition|)
block|{
comment|/* 					 * See if there's any unclaimed space 					 * in the transmit ring. 					 */
if|if
condition|(
operator|(
name|free
operator|+=
name|lmc_tx_intr
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 						 * There's no more room but 						 * since nothing has been 						 * committed at this point, 						 * just show output is active, 						 * put back the mbuf and 						 * return. 						 */
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_WANTTXSTART
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
name|eop
operator|=
name|nextout
expr_stmt|;
if|if
condition|(
operator|++
name|nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|eop
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
expr_stmt|;
name|eop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxNOPADDING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ictl
operator|.
name|crc_length
operator|==
literal|16
condition|)
name|eop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxHASCRC
expr_stmt|;
name|eop
operator|->
name|d_status
operator|=
name|d_status
expr_stmt|;
name|eop
operator|->
name|d_addr1
operator|=
name|LMC_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eop
operator|->
name|d_length1
operator|=
name|slen
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 *  Fill in second half of descriptor 				 */
name|eop
operator|->
name|d_addr2
operator|=
name|LMC_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eop
operator|->
name|d_length2
operator|=
name|slen
expr_stmt|;
block|}
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|len
operator|-=
name|slen
expr_stmt|;
name|addr
operator|+=
name|slen
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
if|if
condition|(
name|partial
condition|)
continue|continue;
endif|#
directive|endif
name|clsize
operator|=
name|CLBYTES
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|m0
operator|=
name|m0
operator|->
name|m_next
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* 	 * The descriptors have been filled in.  Now get ready 	 * to transmit. 	 */
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Make sure the next descriptor after this packet is owned 	 * by us since it may have been set up above if we ran out 	 * of room in the ring. 	 */
name|nextout
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we only used the first segment of the last descriptor, 	 * make sure the second segment will not be used. 	 */
if|if
condition|(
name|segcnt
operator|&
literal|1
condition|)
block|{
name|eop
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
name|eop
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Mark the last and first segments, indicate we want a transmit 	 * complete interrupt, and tell it to transmit! 	 */
name|eop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxLASTSEG
operator||
name|TULIP_DFLAG_TxWANTINTR
expr_stmt|;
comment|/* 	 * Note that ri->ri_nextout is still the start of the packet 	 * and until we set the OWNER bit, we can still back out of 	 * everything we have done. 	 */
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxFIRSTSEG
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * This advances the ring for us. 	 */
name|ri
operator|->
name|ri_nextout
operator|=
name|nextout
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|free
expr_stmt|;
comment|/* 	 * switch back to the single queueing ifstart. 	 */
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_WANTTXSTART
expr_stmt|;
name|sc
operator|->
name|lmc_if
operator|.
name|if_start
operator|=
name|lmc_ifstart_one
expr_stmt|;
comment|/* 	 * If we want a txstart, there must be not enough space in the 	 * transmit ring.  So we want to enable transmit done interrupts 	 * so we can immediately reclaim some space.  When the transmit 	 * interrupt is posted, the interrupt handler will call tx_intr 	 * to reclaim space and then txstart (since WANTTXSTART is set). 	 * txstart will move the packet into the transmit ring and clear 	 * WANTTXSTART thereby causing TXINTR to be cleared. 	 */
name|finish
label|:
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_WANTTXSTART
condition|)
block|{
name|sc
operator|->
name|lmc_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|lmc_if
operator|.
name|if_start
operator|=
name|lmc_ifstart
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This routine is entered at splnet() (splsoftnet() on NetBSD)  */
end_comment

begin_function
specifier|static
name|int
name|lmc_ifioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ioctl_cmd_t
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
specifier|const
name|sc
init|=
name|LMC_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|lmc_spl_t
name|s
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|u_int32_t
name|new_state
decl_stmt|;
name|u_int32_t
name|old_state
decl_stmt|;
name|lmc_ctl_t
name|ctl
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|s
operator|=
name|LMC_RAISESPL
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LMCIOCGINFO
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|ictl
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|lmc_ctl_t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
case|case
name|LMCIOCSINFO
case|:
if|#
directive|if
literal|0
comment|/* XXX */
block|error = suser(p->p_ucred,&p->p_acflag); 		if (error) 			goto out;
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|ctl
argument_list|,
sizeof|sizeof
argument_list|(
name|lmc_ctl_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_status
argument_list|(
name|sc
argument_list|,
operator|&
name|ctl
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Don't allow the MTU to get larger than we can handle 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|LMC_MTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* 	 * call the sppp ioctl layer 	 */
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|error
operator|=
name|p2p_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* 	 * If we are transitioning from up to down or down to up, call 	 * our init routine. 	 */
name|new_state
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
expr_stmt|;
name|old_state
operator|=
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
expr_stmt|;
if|if
condition|(
name|new_state
operator|&&
operator|!
name|old_state
condition|)
name|lmc_ifup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|new_state
operator|&&
name|old_state
condition|)
name|lmc_ifdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|LMC_RESTORESPL
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * These routines gets called at device spl (from sppp_output).  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
specifier|static
name|ifnet_ret_t
name|lmc_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
specifier|const
name|sc
init|=
name|LMC_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
condition|)
block|{
while|while
condition|(
name|sppp_isempty
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|sppp_dequeue
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|lmc_txput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sppp
operator|*
operator|)
name|ifp
operator|)
operator|->
name|pp_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|ifnet_ret_t
name|lmc_ifstart_one
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
specifier|const
name|sc
init|=
name|LMC_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
operator|)
operator|&&
operator|(
name|sppp_isempty
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m
operator|=
name|sppp_dequeue
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|lmc_txput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sppp
operator|*
operator|)
name|ifp
operator|)
operator|->
name|pp_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function
specifier|static
name|ifnet_ret_t
name|lmc_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
specifier|const
name|sc
init|=
name|LMC_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ifq
operator|=
operator|&
name|sc
operator|->
name|lmc_p2pcom
operator|.
name|p2p_isnd
expr_stmt|;
name|m
operator|=
name|ifq
operator|->
name|ifq_head
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifq
operator|=
operator|&
name|sc
operator|->
name|lmc_if
operator|.
name|if_snd
expr_stmt|;
name|m
operator|=
name|ifq
operator|->
name|ifq_head
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|IF_DEQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|lmc_txput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|IF_PREPEND
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ifnet_ret_t
name|lmc_ifstart_one
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
specifier|const
name|sc
init|=
name|LMC_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
operator|)
operator|==
literal|0
condition|)
return|return;
name|ifq
operator|=
operator|&
name|sc
operator|->
name|lmc_p2pcom
operator|.
name|p2p_isnd
expr_stmt|;
name|m
operator|=
name|ifq
operator|->
name|ifq_head
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifq
operator|=
operator|&
name|sc
operator|->
name|lmc_if
operator|.
name|if_snd
expr_stmt|;
name|m
operator|=
name|ifq
operator|->
name|ifq_head
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|IF_DEQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|lmc_txput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|IF_PREPEND
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function
name|int
name|lmc_getmdm
parameter_list|(
name|struct
name|p2pcom
modifier|*
name|pp
parameter_list|,
name|caddr_t
name|b
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
name|LMC_UNIT_TO_SOFTC
argument_list|(
name|pp
operator|->
name|p2p_if
operator|.
name|if_unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_media
operator|->
name|get_link_status
argument_list|(
name|sc
argument_list|)
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|b
operator|=
name|TIOCM_CAR
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|b
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lmc_mdmctl
parameter_list|(
name|struct
name|p2pcom
modifier|*
name|pp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
name|LMC_UNIT_TO_SOFTC
argument_list|(
name|pp
operator|->
name|p2p_if
operator|.
name|if_unit
argument_list|)
decl_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_link_status
argument_list|(
name|sc
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
operator|)
operator|==
literal|0
condition|)
name|lmc_ifup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
operator|)
operator|==
name|LMC_IFUP
condition|)
name|lmc_ifdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set up the OS interface magic and attach to the operating system  * network services.  */
end_comment

begin_function
specifier|static
name|void
name|lmc_attach
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
init|=
operator|&
name|sc
operator|->
name|lmc_if
decl_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lmc_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|lmc_ifstart
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|lmc_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|LMC_MTU
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|ifp
operator|->
name|if_type
operator|=
name|IFT_NONE
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
operator|(
name|sc
operator|->
name|lmc_dev
operator|.
name|dv_unit
operator|)
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sppp_attach
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|&
name|sc
operator|->
name|lmc_sppp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_sppp
operator|.
name|pp_flags
operator|=
name|PP_CISCO
operator||
name|PP_KEEPALIVE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|sc
operator|->
name|lmc_p2pcom
operator|.
name|p2p_mdmctl
operator|=
name|lmc_mdmctl
expr_stmt|;
name|sc
operator|->
name|lmc_p2pcom
operator|.
name|p2p_getmdm
operator|=
name|lmc_getmdm
expr_stmt|;
name|p2p_attach
argument_list|(
operator|&
name|sc
operator|->
name|lmc_p2pcom
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|LMC_BPF_ATTACH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
name|NRND
operator|>
literal|0
name|rnd_attach_source
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rndsource
argument_list|,
name|sc
operator|->
name|lmc_dev
operator|.
name|dv_xname
argument_list|,
name|RND_TYPE_NET
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * turn off those LEDs... 	 */
name|sc
operator|->
name|lmc_miireg16
operator||=
name|LMC_MII16_LED_ALL
expr_stmt|;
name|lmc_led_on
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|lmc_initring
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|lmc_ringinfo_t
modifier|*
specifier|const
name|ri
parameter_list|,
name|tulip_desc_t
modifier|*
name|descs
parameter_list|,
name|int
name|ndescs
parameter_list|)
block|{
name|ri
operator|->
name|ri_max
operator|=
name|ndescs
expr_stmt|;
name|ri
operator|->
name|ri_first
operator|=
name|descs
expr_stmt|;
name|ri
operator|->
name|ri_last
operator|=
name|ri
operator|->
name|ri_first
operator|+
name|ri
operator|->
name|ri_max
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ri
operator|->
name|ri_first
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|->
name|ri_first
index|[
literal|0
index|]
argument_list|)
operator|*
name|ri
operator|->
name|ri_max
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_last
index|[
operator|-
literal|1
index|]
operator|.
name|d_flag
operator|=
name|TULIP_DFLAG_ENDRING
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This is the PCI configuration support.  */
end_comment

begin_define
define|#
directive|define
name|PCI_CFID
value|0x00
end_define

begin_comment
comment|/* Configuration ID */
end_comment

begin_define
define|#
directive|define
name|PCI_CFCS
value|0x04
end_define

begin_comment
comment|/* Configurtion Command/Status */
end_comment

begin_define
define|#
directive|define
name|PCI_CFRV
value|0x08
end_define

begin_comment
comment|/* Configuration Revision */
end_comment

begin_define
define|#
directive|define
name|PCI_CFLT
value|0x0c
end_define

begin_comment
comment|/* Configuration Latency Timer */
end_comment

begin_define
define|#
directive|define
name|PCI_CBIO
value|0x10
end_define

begin_comment
comment|/* Configuration Base IO Address */
end_comment

begin_define
define|#
directive|define
name|PCI_CBMA
value|0x14
end_define

begin_comment
comment|/* Configuration Base Memory Address */
end_comment

begin_define
define|#
directive|define
name|PCI_SSID
value|0x2c
end_define

begin_comment
comment|/* subsystem config register */
end_comment

begin_define
define|#
directive|define
name|PCI_CFIT
value|0x3c
end_define

begin_comment
comment|/* Configuration Interrupt */
end_comment

begin_define
define|#
directive|define
name|PCI_CFDA
value|0x40
end_define

begin_comment
comment|/* Configuration Driver Area */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dev/pci/if_lmc_nbsd.c"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"pci/if_lmc_fbsd.c"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"i386/pci/if_lmc_bsdi.c"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"This driver only works on NetBSD, FreeBSD, or BSDi"
end_error

begin_endif
endif|#
directive|endif
end_endif

end_unit

