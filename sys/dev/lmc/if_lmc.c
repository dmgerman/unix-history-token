begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994-1997 Matt Thomas (matt@3am-software.com)  * Copyright (c) LAN Media Corporation 1998, 1999.  * Copyright (c) 2000 Stephen Kiernan (sk-ports@vegamuse.org)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *      From NetBSD: if_de.c,v 1.56.2.1 1997/10/27 02:13:25 thorpej Exp  *	$Id: if_lmc.c,v 1.9 1999/02/19 15:08:42 explorer Exp $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILING_LINT
end_ifdef

begin_warning
warning|#
directive|warning
literal|"The lmc driver is broken and is not compiled with LINT"
end_warning

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|lmc_version
index|[]
init|=
literal|"BSD 1.1"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"opt_netgraph.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/dc21040reg.h>
end_include

begin_define
define|#
directive|define
name|INCLUDE_PATH_PREFIX
value|"dev/lmc/"
end_define

begin_comment
comment|/* Intel CPUs should use I/O mapped access.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_define
define|#
directive|define
name|LMC_IOMAPPED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This turns on all sort of debugging stuff and make the  * driver much larger.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LMC_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DP
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DP
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LMC_HZ
value|10
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TULIP_GP_PINSET
end_ifndef

begin_define
define|#
directive|define
name|TULIP_GP_PINSET
value|0x00000100L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TULIP_BUSMODE_READMULTIPLE
end_ifndef

begin_define
define|#
directive|define
name|TULIP_BUSMODE_READMULTIPLE
value|0x00200000L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * C sucks  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|lmc___softc
name|lmc_softc_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|lmc___media
name|lmc_media_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|lmc___ctl
name|lmc_ctl_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"dev/lmc/if_lmcioctl.h"
end_include

begin_include
include|#
directive|include
file|"dev/lmc/if_lmcvar.h"
end_include

begin_include
include|#
directive|include
file|"dev/lmc/if_lmc_common.c"
end_include

begin_include
include|#
directive|include
file|"dev/lmc/if_lmc_media.c"
end_include

begin_comment
comment|/*  * This module supports  *	the DEC 21140A pass 2.2 PCI Fast Ethernet Controller.  */
end_comment

begin_function_decl
specifier|static
name|lmc_intrfunc_t
name|lmc_intr_normal
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ifnet_ret_t
name|lmc_ifstart
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ifnet_ret_t
name|lmc_ifstart_one
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lmc_txput
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lmc_rx_intr
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lmc_watchdog
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lmc_ifup
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lmc_ifdown
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LMC_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|ng_lmc_dump_packet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LMC_DEBUG */
end_comment

begin_function_decl
specifier|static
name|void
name|ng_lmc_watchdog_frame
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_lmc_init
parameter_list|(
name|void
modifier|*
name|ignored
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_lmc_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_lmc_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_lmc_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_lmc_newhook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static ng_findhook_t  ng_lmc_findhook; */
end_comment

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ng_lmc_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_lmc_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_lmc_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct lmc_ctl */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_fixedarray_info
name|ng_lmc_ctl_cardspec_info
init|=
block|{
operator|&
name|ng_parse_int32_type
block|,
literal|7
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_lmc_ctl_cardspec_type
init|=
block|{
operator|&
name|ng_parse_fixedarray_type
block|,
operator|&
name|ng_lmc_ctl_cardspec_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_lmc_ctl_type_info
init|=
block|{
block|{
block|{
literal|"cardtype"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"clock_source"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"clock_rate"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"crc_length"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"cable_length"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"scrambler_onoff"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"cable_type"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"keepalive_onoff"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"ticks"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
literal|"cardspec"
block|,
operator|&
name|ng_lmc_ctl_cardspec_type
block|}
block|,
block|{
literal|"circuit_type"
block|,
operator|&
name|ng_parse_int32_type
block|}
block|,
block|{
name|NULL
block|}
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_lmc_ctl_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_lmc_ctl_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_lmc_cmdlist
index|[]
init|=
block|{
block|{
name|NG_LMC_COOKIE
block|,
name|NGM_LMC_GET_CTL
block|,
literal|"getctl"
block|,
name|NULL
block|,
operator|&
name|ng_lmc_ctl_type
block|,         }
block|,
block|{
name|NG_LMC_COOKIE
block|,
name|NGM_LMC_SET_CTL
block|,
literal|"setctl"
block|,
operator|&
name|ng_lmc_ctl_type
block|,
name|NULL
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
name|NG_ABI_VERSION
block|,
name|NG_LMC_NODE_TYPE
block|,
name|NULL
block|,
name|ng_lmc_constructor
block|,
name|ng_lmc_rcvmsg
block|,
name|ng_lmc_rmnode
block|,
name|ng_lmc_newhook
block|,
name|NULL
block|,
name|ng_lmc_connect
block|,
name|ng_lmc_rcvdata
block|,
name|ng_lmc_disconnect
block|,
name|ng_lmc_cmdlist
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ng_lmc_done_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Code the read the SROM and MII bit streams (I2C)  */
end_comment

begin_function
specifier|static
name|void
name|lmc_delay_300ns
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
operator|(
literal|300
operator|/
literal|33
operator|)
operator|+
literal|1
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
operator|(
name|void
operator|)
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|EMIT
define|\
value|do { \ 	LMC_CSR_WRITE(sc, csr_srom_mii, csr); \ 	lmc_delay_300ns(sc); \ } while (0)
end_define

begin_function
specifier|static
name|void
name|lmc_srom_idle
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|bit
decl_stmt|,
name|csr
decl_stmt|;
name|csr
operator|=
name|SROMSEL
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCS
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* 	 * Write 25 cycles of 0 which will force the SROM to be idle. 	 */
for|for
control|(
name|bit
operator|=
literal|3
operator|+
name|SROM_BITWIDTH
operator|+
literal|16
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|--
control|)
block|{
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; data not valid */
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock high; data valid */
block|}
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCS
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
name|EMIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_srom_read
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|idx
decl_stmt|;
specifier|const
name|unsigned
name|bitwidth
init|=
name|SROM_BITWIDTH
decl_stmt|;
specifier|const
name|unsigned
name|cmdmask
init|=
operator|(
name|SROMCMD_RD
operator|<<
name|bitwidth
operator|)
decl_stmt|;
specifier|const
name|unsigned
name|msb
init|=
literal|1
operator|<<
operator|(
name|bitwidth
operator|+
literal|3
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|lastidx
init|=
operator|(
literal|1
operator|<<
name|bitwidth
operator|)
operator|-
literal|1
decl_stmt|;
name|lmc_srom_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<=
name|lastidx
condition|;
name|idx
operator|++
control|)
block|{
name|unsigned
name|lastbit
decl_stmt|,
name|data
decl_stmt|,
name|bits
decl_stmt|,
name|bit
decl_stmt|,
name|csr
decl_stmt|;
name|csr
operator|=
name|SROMSEL
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCSON
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
name|lastbit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bits
operator|=
name|idx
operator||
name|cmdmask
operator|,
name|bit
operator|=
name|bitwidth
operator|+
literal|3
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|--
operator|,
name|bits
operator|<<=
literal|1
control|)
block|{
specifier|const
name|unsigned
name|thisbit
init|=
name|bits
operator|&
name|msb
decl_stmt|;
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock L data invalid */
if|if
condition|(
name|thisbit
operator|!=
name|lastbit
condition|)
block|{
name|csr
operator|^=
name|SROMDOUT
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock L invert data */
block|}
else|else
block|{
name|EMIT
expr_stmt|;
block|}
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock H data valid */
name|lastbit
operator|=
name|thisbit
expr_stmt|;
block|}
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|bits
operator|=
literal|0
init|;
name|bits
operator|<
literal|16
condition|;
name|bits
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock H data valid */
name|data
operator||=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
name|SROMDIN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock L data invalid */
block|}
name|sc
operator|->
name|lmc_rombuf
index|[
name|idx
operator|*
literal|2
index|]
operator|=
name|data
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|lmc_rombuf
index|[
name|idx
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|data
operator|>>
literal|8
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
name|EMIT
expr_stmt|;
block|}
name|lmc_srom_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MII_EMIT
value|do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)
end_define

begin_function
specifier|static
name|void
name|lmc_mii_writebits
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|data
parameter_list|,
name|unsigned
name|bits
parameter_list|)
block|{
name|unsigned
name|msb
init|=
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|unsigned
name|lastbit
init|=
operator|(
name|csr
operator|&
name|MII_DOUT
operator|)
condition|?
name|msb
else|:
literal|0
decl_stmt|;
name|csr
operator||=
name|MII_WR
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; assert write */
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
operator|,
name|data
operator|<<=
literal|1
control|)
block|{
specifier|const
name|unsigned
name|thisbit
init|=
name|data
operator|&
name|msb
decl_stmt|;
if|if
condition|(
name|thisbit
operator|!=
name|lastbit
condition|)
block|{
name|csr
operator|^=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; invert data */
block|}
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|lastbit
operator|=
name|thisbit
expr_stmt|;
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_mii_turnaround
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|cmd
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MII_WRCMD
condition|)
block|{
name|csr
operator||=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; change data */
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
name|csr
operator|^=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; change data */
block|}
else|else
block|{
name|csr
operator||=
name|MII_RD
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; switch to read */
block|}
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
end_function

begin_function
specifier|static
name|unsigned
name|lmc_mii_readbits
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|data
decl_stmt|;
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|data
operator|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
comment|/* this is NOOP on the first pass through */
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
if|if
condition|(
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
name|MII_DIN
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
name|csr
operator|^=
name|MII_RD
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; turn off read */
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|lmc_mii_readreg
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|unsigned
name|data
decl_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|MII_RD
operator||
name|MII_CLK
operator|)
expr_stmt|;
name|MII_EMIT
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_PREAMBLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_RDCMD
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lmc_mii_turnaround
argument_list|(
name|sc
argument_list|,
name|MII_RDCMD
argument_list|)
expr_stmt|;
name|data
operator|=
name|lmc_mii_readbits
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_mii_writereg
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|,
name|unsigned
name|data
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|MII_RD
operator||
name|MII_CLK
operator|)
expr_stmt|;
name|MII_EMIT
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_PREAMBLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|MII_WRCMD
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|lmc_mii_turnaround
argument_list|(
name|sc
argument_list|,
name|MII_WRCMD
argument_list|)
expr_stmt|;
name|lmc_mii_writebits
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|lmc_read_macaddr
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|lmc_srom_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|lmc_rombuf
operator|+
literal|20
argument_list|,
name|sc
operator|->
name|lmc_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Check to make certain there is a signal from the modem, and flicker  * lights as needed.  */
end_comment

begin_function
specifier|static
name|void
name|lmc_watchdog
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|state
decl_stmt|;
name|u_int32_t
name|ostatus
decl_stmt|;
name|u_int32_t
name|link_status
decl_stmt|;
name|u_int32_t
name|ticks
decl_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|link_status
operator|=
name|sc
operator|->
name|lmc_media
operator|->
name|get_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ostatus
operator|=
operator|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_MODEMOK
operator|)
operator|==
name|LMC_MODEMOK
operator|)
expr_stmt|;
comment|/* 	 * hardware level link lost, but the interface is marked as up. 	 * Mark it as down. 	 */
if|if
condition|(
name|link_status
operator|==
literal|0
operator|&&
name|ostatus
condition|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": physical link down\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_MODEMOK
expr_stmt|;
name|lmc_led_off
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * hardware link is up, but the interface is marked as down. 	 * Bring it back up again. 	 */
if|if
condition|(
name|link_status
operator|!=
literal|0
operator|&&
operator|!
name|ostatus
condition|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": physical link up\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
condition|)
name|lmc_ifup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * remember the timer value 	 */
name|ticks
operator|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|0xffffffffUL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ictl
operator|.
name|ticks
operator|=
literal|0x0000ffff
operator|-
operator|(
name|ticks
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|sc
operator|->
name|lmc_out_dog
operator|=
name|LMC_DOG_HOLDOFF
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark the interface as "up" and enable TX/RX and TX/RX interrupts.  * This also does a full software reset.  */
end_comment

begin_function
specifier|static
name|void
name|lmc_ifup
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|untimeout
argument_list|(
name|ng_lmc_watchdog_frame
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|lmc_handle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_running
operator|=
literal|0
expr_stmt|;
name|lmc_dec_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lmc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_link_status
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_status
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_IFUP
expr_stmt|;
comment|/* 	 * select what interrupts we want to get 	 */
name|sc
operator|->
name|lmc_intrmask
operator||=
operator|(
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_TXINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_SYSERROR
operator||
name|TULIP_STS_TXSTOPPED
operator||
name|TULIP_STS_TXUNDERFLOW
operator||
name|TULIP_STS_RXSTOPPED
operator|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|lmc_intrmask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_cmdmode
operator||=
name|TULIP_CMD_TXRUN
expr_stmt|;
name|sc
operator|->
name|lmc_cmdmode
operator||=
name|TULIP_CMD_RXRUN
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ng_lmc_watchdog_frame
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|lmc_handle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_handle
operator|=
name|timeout
argument_list|(
name|ng_lmc_watchdog_frame
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_running
operator|=
literal|1
expr_stmt|;
comment|/* 	 * check if the physical link is up 	 */
if|if
condition|(
name|sc
operator|->
name|lmc_media
operator|->
name|get_link_status
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_MODEMOK
expr_stmt|;
name|lmc_led_on
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Mark the interface as "down" and disable TX/RX and TX/RX interrupts.  * This is done by performing a full reset on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|lmc_ifdown
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|untimeout
argument_list|(
name|ng_lmc_watchdog_frame
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|lmc_handle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_running
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_IFUP
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_link_status
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lmc_led_off
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED1
argument_list|)
expr_stmt|;
name|lmc_dec_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lmc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_status
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_rx_intr
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|lmc_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|lmc_rxinfo
decl_stmt|;
name|int
name|fillok
init|=
literal|1
decl_stmt|;
name|sc
operator|->
name|lmc_rxtick
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tulip_desc_t
modifier|*
name|eop
init|=
name|ri
operator|->
name|ri_nextin
decl_stmt|;
name|int
name|total_len
init|=
literal|0
decl_stmt|,
name|last_offset
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ms
init|=
name|NULL
decl_stmt|,
modifier|*
name|me
init|=
name|NULL
decl_stmt|;
name|int
name|accept
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fillok
operator|&&
name|sc
operator|->
name|lmc_rxq
operator|.
name|ifq_len
operator|<
name|LMC_RXQ_TARGET
condition|)
goto|goto
name|queue_mbuf
goto|;
comment|/* 		 * If the TULIP has no descriptors, there can't be any receive 		 * descriptors to process. 		 */
if|if
condition|(
name|eop
operator|==
name|ri
operator|->
name|ri_nextout
condition|)
break|break;
comment|/* 		 * 90% of the packets will fit in one descriptor.  So we 		 * optimize for that case. 		 */
if|if
condition|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
operator|(
name|TULIP_DSTS_OWNER
operator||
name|TULIP_DSTS_RxFIRSTDESC
operator||
name|TULIP_DSTS_RxLASTDESC
operator|)
operator|)
operator|==
operator|(
name|TULIP_DSTS_RxFIRSTDESC
operator||
name|TULIP_DSTS_RxLASTDESC
operator|)
condition|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|me
operator|=
name|ms
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If still owned by the TULIP, don't touch it. 			 */
if|if
condition|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
comment|/* 			 * It is possible (though improbable unless the 			 * BIG_PACKET support is enabled or MCLBYTES< 1518) 			 * for a received packet to cross more than one 			 * receive descriptor. 			 */
while|while
condition|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxLASTDESC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
if|if
condition|(
name|eop
operator|==
name|ri
operator|->
name|ri_nextout
operator|||
operator|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
operator|)
operator|)
condition|)
block|{
return|return;
block|}
name|total_len
operator|++
expr_stmt|;
block|}
comment|/* 			 * Dequeue the first buffer for the start of the 			 * packet.  Hopefully this will be the only one we 			 * need to dequeue.  However, if the packet consumed 			 * multiple descriptors, then we need to dequeue 			 * those buffers and chain to the starting mbuf. 			 * All buffers but the last buffer have the same 			 * length so we can set that now. (we add to 			 * last_offset instead of multiplying since we 			 * normally won't go into the loop and thereby 			 * saving a ourselves from doing a multiplication 			 * by 0 in the normal case). 			 */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
for|for
control|(
name|me
operator|=
name|ms
init|;
name|total_len
operator|>
literal|0
condition|;
name|total_len
operator|--
control|)
block|{
name|me
operator|->
name|m_len
operator|=
name|LMC_RX_BUFLEN
expr_stmt|;
name|last_offset
operator|+=
name|LMC_RX_BUFLEN
expr_stmt|;
name|_IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|me
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|me
operator|=
name|me
operator|->
name|m_next
expr_stmt|;
block|}
block|}
comment|/* 		 *  Now get the size of received packet (minus the CRC). 		 */
name|total_len
operator|=
operator|(
operator|(
name|eop
operator|->
name|d_status
operator|>>
literal|16
operator|)
operator|&
literal|0x7FFF
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ictl
operator|.
name|crc_length
operator|==
literal|16
condition|)
name|total_len
operator|-=
literal|2
expr_stmt|;
else|else
name|total_len
operator|-=
literal|4
expr_stmt|;
name|sc
operator|->
name|lmc_inbytes
operator|+=
name|total_len
expr_stmt|;
name|sc
operator|->
name|lmc_inlast
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_RXIGNORE
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|eop
operator|->
name|d_status
operator|&
name|LMC_DSTS_ERRSUM
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|me
operator|->
name|m_len
operator|=
name|total_len
operator|-
name|last_offset
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_RXACT
expr_stmt|;
name|accept
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|lmc_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxOVERFLOW
condition|)
block|{
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|lmc_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|eop
expr_stmt|;
name|queue_mbuf
label|:
comment|/* 		 * Either we are priming the TULIP with mbufs (m == NULL) 		 * or we are about to accept an mbuf for the upper layers 		 * so we need to allocate an mbuf to replace it.  If we 		 * can't replace it, send up it anyways.  This may cause 		 * us to drop packets in the future but that's better than 		 * being caught in livelock. 		 * 		 * Note that if this packet crossed multiple descriptors 		 * we don't even try to reallocate all the mbufs here. 		 * Instead we rely on the test of the beginning of 		 * the loop to refill for the extra consumed mbufs. 		 */
if|if
condition|(
name|accept
operator|||
name|ms
operator|==
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|accept
condition|)
block|{
name|int
name|error
decl_stmt|;
name|ms
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|total_len
expr_stmt|;
name|ms
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|sc
operator|->
name|lmc_hook
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
name|ms
operator|=
name|m0
expr_stmt|;
block|}
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Couldn't allocate a new buffer.  Don't bother  			 * trying to replenish the receive queue. 			 */
name|fillok
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_RXBUFSLOW
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Now give the buffer(s) to the TULIP and save in our 		 * receive queue. 		 */
do|do
block|{
name|ri
operator|->
name|ri_nextout
operator|->
name|d_length1
operator|=
name|LMC_RX_BUFLEN
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_addr1
operator|=
name|LMC_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|ms
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|me
operator|=
name|ms
operator|->
name|m_next
expr_stmt|;
name|ms
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ms
operator|=
name|me
operator|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|sc
operator|->
name|lmc_rxq
operator|.
name|ifq_len
operator|>=
name|LMC_RXQ_TARGET
condition|)
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_RXBUFSLOW
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|lmc_tx_intr
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|lmc_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|lmc_txinfo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|xmits
init|=
literal|0
decl_stmt|;
name|int
name|descs
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|lmc_txtick
operator|++
expr_stmt|;
while|while
condition|(
name|ri
operator|->
name|ri_free
operator|<
name|ri
operator|->
name|ri_max
condition|)
block|{
name|u_int32_t
name|d_flag
decl_stmt|;
if|if
condition|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|ri
operator|->
name|ri_nextin
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
name|d_flag
operator|=
name|ri
operator|->
name|ri_nextin
operator|->
name|d_flag
expr_stmt|;
if|if
condition|(
name|d_flag
operator|&
name|TULIP_DFLAG_TxLASTSEG
condition|)
block|{
specifier|const
name|u_int32_t
name|d_status
init|=
name|ri
operator|->
name|ri_nextin
operator|->
name|d_status
decl_stmt|;
name|_IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|lmc_bpf
operator|!=
name|NULL
condition|)
name|LMC_BPF_MTAP
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LMC_DEBUG
argument_list|)
block|}
else|else
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": tx_intr: failed to dequeue mbuf?!?\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|xmits
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|LMC_DSTS_ERRSUM
condition|)
block|{
name|sc
operator|->
name|lmc_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxUNDERFLOW
condition|)
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsInternalTransmitUnderflows
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d_status
operator|&
name|TULIP_DSTS_TxDEFERRED
condition|)
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsDeferredTransmissions
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextin
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|++
expr_stmt|;
name|descs
operator|++
expr_stmt|;
comment|/*sc->lmc_if.if_flags&= ~IFF_OACTIVE;*/
name|sc
operator|->
name|lmc_out_deficit
operator|++
expr_stmt|;
block|}
comment|/*      * If nothing left to transmit, disable the timer.      * Else if progress, reset the timer back to 2 ticks.      */
name|sc
operator|->
name|lmc_opackets
operator|+=
name|xmits
expr_stmt|;
return|return
name|descs
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|lmc_print_abnormal_interrupt
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|u_int32_t
name|csr
parameter_list|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": Abnormal interrupt\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_intr_handler
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|int
modifier|*
name|progress_p
parameter_list|)
block|{
name|u_int32_t
name|csr
decl_stmt|;
while|while
condition|(
operator|(
name|csr
operator|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
operator|)
operator|&
name|sc
operator|->
name|lmc_intrmask
condition|)
block|{
operator|*
name|progress_p
operator|=
literal|1
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_SYSERROR
condition|)
block|{
name|sc
operator|->
name|lmc_last_system_error
operator|=
operator|(
name|csr
operator|&
name|TULIP_STS_ERRORMASK
operator|)
operator|>>
name|TULIP_STS_ERR_SHIFT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_NOMESSAGES
condition|)
block|{
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_SYSTEMERROR
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": system error: %s\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|,
name|lmc_system_errors
index|[
name|sc
operator|->
name|lmc_last_system_error
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_NEEDRESET
expr_stmt|;
name|sc
operator|->
name|lmc_system_errors
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csr
operator|&
operator|(
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_RXNOBUF
operator|)
condition|)
block|{
name|u_int32_t
name|misses
init|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_missed_frames
argument_list|)
decl_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_RXNOBUF
condition|)
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsMissedFrames
operator|+=
name|misses
operator|&
literal|0xFFFF
expr_stmt|;
comment|/* 	     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data 	     * on receive overflows. 	     */
if|if
condition|(
operator|(
name|misses
operator|&
literal|0x0FFE0000
operator|)
operator|&&
operator|(
name|sc
operator|->
name|lmc_features
operator|&
name|LMC_HAVE_RXBADOVRFLW
operator|)
condition|)
block|{
name|sc
operator|->
name|lmc_dot3stats
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
comment|/* 		 * Stop the receiver process and spin until it's stopped. 		 * Tell rx_intr to drop the packets it dequeues. 		 */
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
operator|&
operator|~
name|TULIP_CMD_RXRUN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
operator|&
name|TULIP_STS_RXSTOPPED
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|TULIP_STS_RXSTOPPED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_RXIGNORE
expr_stmt|;
block|}
name|lmc_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_RXIGNORE
condition|)
block|{
comment|/* 		 * Restart the receiver. 		 */
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_RXIGNORE
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_ABNRMLINTR
condition|)
block|{
name|u_int32_t
name|tmp
init|=
name|csr
operator|&
name|sc
operator|->
name|lmc_intrmask
operator|&
operator|~
operator|(
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator|)
decl_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_TXUNDERFLOW
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_cmdmode
operator|&
name|TULIP_CMD_THRESHOLDCTL
operator|)
operator|!=
name|TULIP_CMD_THRSHLD160
condition|)
block|{
name|sc
operator|->
name|lmc_cmdmode
operator|+=
name|TULIP_CMD_THRSHLD96
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_NEWTXTHRESH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|lmc_features
operator|&
name|LMC_HAVE_STOREFWD
condition|)
block|{
name|sc
operator|->
name|lmc_cmdmode
operator||=
name|TULIP_CMD_STOREFWD
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_NEWTXTHRESH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_NOMESSAGES
condition|)
block|{
name|sc
operator|->
name|lmc_statusbits
operator||=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|lmc_print_abnormal_interrupt
argument_list|(
name|sc
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_NOMESSAGES
expr_stmt|;
block|}
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_TXINTR
condition|)
name|lmc_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_WANTTXSTART
condition|)
name|lmc_ifstart
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|lmc_intrfunc_t
name|lmc_intr_normal
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
operator|(
name|lmc_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|progress
init|=
literal|0
decl_stmt|;
name|lmc_intr_handler
argument_list|(
name|sc
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LMC_VOID_INTRFUNC
argument_list|)
return|return
name|progress
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lmc_mbuf_compress
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|#
directive|if
name|MCLBYTES
operator|>=
name|LMC_MTU
operator|+
name|PPP_HEADER_LEN
operator|&&
operator|!
name|defined
argument_list|(
name|BIG_PACKET
argument_list|)
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
else|#
directive|else
name|int
name|mlen
init|=
name|MHLEN
decl_stmt|;
name|int
name|len
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
init|=
operator|&
name|m0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mlen
operator|==
name|MHLEN
condition|)
block|{
name|MGETHDR
argument_list|(
operator|*
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
operator|*
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
operator|*
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
operator|(
name|len
operator|<=
name|MCLBYTES
condition|?
name|len
else|:
name|MCLBYTES
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
operator|(
name|len
operator|<=
name|mlen
condition|?
name|len
else|:
name|mlen
operator|)
expr_stmt|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|len
argument_list|,
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
operator|(
operator|*
name|mp
operator|)
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
expr_stmt|;
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
name|mlen
operator|=
name|MLEN
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|m0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * queue the mbuf handed to us for the interface.  If we cannot  * queue it, return the mbuf.  Return NULL if the mbuf was queued.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lmc_txput
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|lmc_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|lmc_txinfo
decl_stmt|;
name|tulip_desc_t
modifier|*
name|eop
decl_stmt|,
modifier|*
name|nextout
decl_stmt|;
name|int
name|segcnt
decl_stmt|,
name|free
decl_stmt|;
name|u_int32_t
name|d_status
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LMC_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_cmdmode
operator|&
name|TULIP_CMD_TXRUN
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": txput: tx not running\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_WANTTXSTART
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
endif|#
directive|endif
comment|/* 	 * Now we try to fill in our transmit descriptors.  This is 	 * a bit reminiscent of going on the Ark two by two 	 * since each descriptor for the TULIP can describe 	 * two buffers.  So we advance through packet filling 	 * each of the two entries at a time to fill each 	 * descriptor.  Clear the first and last segment bits 	 * in each descriptor (actually just clear everything 	 * but the end-of-ring or chain bits) to make sure 	 * we don't get messed up by previously sent packets. 	 * 	 * We may fail to put the entire packet on the ring if 	 * there is either not enough ring entries free or if the 	 * packet has more than MAX_TXSEG segments.  In the former 	 * case we will just wait for the ring to empty.  In the 	 * latter case we have to recopy. 	 */
name|again
label|:
name|d_status
operator|=
literal|0
expr_stmt|;
name|eop
operator|=
name|nextout
operator|=
name|ri
operator|->
name|ri_nextout
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|segcnt
operator|=
literal|0
expr_stmt|;
name|free
operator|=
name|ri
operator|->
name|ri_free
expr_stmt|;
do|do
block|{
name|int
name|len
init|=
name|m0
operator|->
name|m_len
decl_stmt|;
name|caddr_t
name|addr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
name|unsigned
name|clsize
init|=
name|CLBYTES
operator|-
operator|(
operator|(
operator|(
name|u_long
operator|)
name|addr
operator|)
operator|&
operator|(
name|CLBYTES
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|unsigned
name|slen
init|=
name|min
argument_list|(
name|len
argument_list|,
name|clsize
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
name|int
name|partial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|slen
operator|>=
literal|2048
condition|)
name|slen
operator|=
literal|2040
operator|,
name|partial
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|segcnt
operator|++
expr_stmt|;
if|if
condition|(
name|segcnt
operator|>
name|LMC_MAX_TXSEG
condition|)
block|{
comment|/* 				 * The packet exceeds the number of transmit 				 * buffer entries that we can use for one 				 * packet, so we have recopy it into one mbuf 				 * and then try again. 				 */
name|m
operator|=
name|lmc_mbuf_compress
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|finish
goto|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|segcnt
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|--
name|free
operator|==
literal|0
condition|)
block|{
comment|/* 					 * See if there's any unclaimed space 					 * in the transmit ring. 					 */
if|if
condition|(
operator|(
name|free
operator|+=
name|lmc_tx_intr
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 						 * There's no more room but 						 * since nothing has been 						 * committed at this point, 						 * just show output is active, 						 * put back the mbuf and 						 * return. 						 */
name|sc
operator|->
name|lmc_flags
operator||=
name|LMC_WANTTXSTART
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
name|eop
operator|=
name|nextout
expr_stmt|;
if|if
condition|(
operator|++
name|nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|eop
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
expr_stmt|;
name|eop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxNOPADDING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ictl
operator|.
name|crc_length
operator|==
literal|16
condition|)
name|eop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxHASCRC
expr_stmt|;
name|eop
operator|->
name|d_status
operator|=
name|d_status
expr_stmt|;
name|eop
operator|->
name|d_addr1
operator|=
name|LMC_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eop
operator|->
name|d_length1
operator|=
name|slen
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 *  Fill in second half of descriptor 				 */
name|eop
operator|->
name|d_addr2
operator|=
name|LMC_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eop
operator|->
name|d_length2
operator|=
name|slen
expr_stmt|;
block|}
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|len
operator|-=
name|slen
expr_stmt|;
name|addr
operator|+=
name|slen
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
if|if
condition|(
name|partial
condition|)
continue|continue;
endif|#
directive|endif
name|clsize
operator|=
name|CLBYTES
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|m0
operator|=
name|m0
operator|->
name|m_next
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* 	 * The descriptors have been filled in.  Now get ready 	 * to transmit. 	 */
name|_IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Make sure the next descriptor after this packet is owned 	 * by us since it may have been set up above if we ran out 	 * of room in the ring. 	 */
name|nextout
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we only used the first segment of the last descriptor, 	 * make sure the second segment will not be used. 	 */
if|if
condition|(
name|segcnt
operator|&
literal|1
condition|)
block|{
name|eop
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
name|eop
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Mark the last and first segments, indicate we want a transmit 	 * complete interrupt, and tell it to transmit! 	 */
name|eop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxLASTSEG
operator||
name|TULIP_DFLAG_TxWANTINTR
expr_stmt|;
comment|/* 	 * Note that ri->ri_nextout is still the start of the packet 	 * and until we set the OWNER bit, we can still back out of 	 * everything we have done. 	 */
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxFIRSTSEG
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * This advances the ring for us. 	 */
name|ri
operator|->
name|ri_nextout
operator|=
name|nextout
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|free
expr_stmt|;
comment|/* 	 * switch back to the single queueing ifstart. 	 */
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
name|LMC_WANTTXSTART
expr_stmt|;
name|sc
operator|->
name|lmc_xmit_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|lmc_out_dog
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we want a txstart, there must be not enough space in the 	 * transmit ring.  So we want to enable transmit done interrupts 	 * so we can immediately reclaim some space.  When the transmit 	 * interrupt is posted, the interrupt handler will call tx_intr 	 * to reclaim space and then txstart (since WANTTXSTART is set). 	 * txstart will move the packet into the transmit ring and clear 	 * WANTTXSTART thereby causing TXINTR to be cleared. 	 */
name|finish
label|:
return|return
name|m
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * These routines gets called at device spl  */
end_comment

begin_function
specifier|static
name|ifnet_ret_t
name|lmc_ifstart
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
condition|)
block|{
name|sc
operator|->
name|lmc_xmit_busy
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|ifqueue
modifier|*
name|q
init|=
operator|&
name|sc
operator|->
name|lmc_xmitq_hipri
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
operator|&
name|sc
operator|->
name|lmc_xmitq
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|sc
operator|->
name|lmc_outbytes
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sc
operator|->
name|lmc_opackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|lmc_txput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|IF_PREPEND
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": lmc_txput failed\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
break|break;
block|}
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|ifnet_ret_t
name|lmc_ifstart_one
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_flags
operator|&
name|LMC_IFUP
operator|)
condition|)
block|{
name|struct
name|ifqueue
modifier|*
name|q
init|=
operator|&
name|sc
operator|->
name|lmc_xmitq_hipri
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
operator|&
name|sc
operator|->
name|lmc_xmitq
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|sc
operator|->
name|lmc_outbytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sc
operator|->
name|lmc_opackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|lmc_txput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|IF_PREPEND
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set up the OS interface magic and attach to the operating system  * network services.  */
end_comment

begin_function
specifier|static
name|int
name|lmc_attach
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
comment|/* 	 * we have found a node, make sure our 'type' is availabe. 	 */
if|if
condition|(
name|ng_lmc_done_init
operator|==
literal|0
condition|)
name|ng_lmc_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|sc
operator|->
name|lmc_node
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sprintf
argument_list|(
name|sc
operator|->
name|lmc_nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_LMC_NODE_TYPE
argument_list|,
name|sc
operator|->
name|lmc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|sc
operator|->
name|lmc_node
argument_list|,
name|sc
operator|->
name|lmc_nodename
argument_list|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|lmc_node
argument_list|)
expr_stmt|;
comment|/* make it go away again */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|lmc_node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|lmc_handle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_xmitq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|lmc_xmitq_hipri
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|lmc_xmitq
operator|.
name|ifq_mtx
argument_list|,
literal|"lmc_xmitq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|lmc_xmitq_hipri
operator|.
name|ifq_mtx
argument_list|,
literal|"lmc_xmitq_hipri"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_running
operator|=
literal|0
expr_stmt|;
comment|/* 	 * turn off those LEDs... 	 */
name|sc
operator|->
name|lmc_miireg16
operator||=
name|LMC_MII16_LED_ALL
expr_stmt|;
name|lmc_led_on
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|lmc_initring
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|lmc_ringinfo_t
modifier|*
specifier|const
name|ri
parameter_list|,
name|tulip_desc_t
modifier|*
name|descs
parameter_list|,
name|int
name|ndescs
parameter_list|)
block|{
name|ri
operator|->
name|ri_max
operator|=
name|ndescs
expr_stmt|;
name|ri
operator|->
name|ri_first
operator|=
name|descs
expr_stmt|;
name|ri
operator|->
name|ri_last
operator|=
name|ri
operator|->
name|ri_first
operator|+
name|ri
operator|->
name|ri_max
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ri
operator|->
name|ri_first
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|->
name|ri_first
index|[
literal|0
index|]
argument_list|)
operator|*
name|ri
operator|->
name|ri_max
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_last
index|[
operator|-
literal|1
index|]
operator|.
name|d_flag
operator|=
name|TULIP_DFLAG_ENDRING
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|LMC_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ng_lmc_dump_packet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"mbuf: %d bytes, %s packet\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
operator|(
name|m
operator|->
name|m_type
operator|==
name|MT_DATA
operator|)
condition|?
literal|"data"
else|:
literal|"other"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|m_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%02x"
argument_list|,
name|m
operator|->
name|m_dat
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LMC_DEBUG */
end_comment

begin_comment
comment|/* Device timeout/watchdog routine */
end_comment

begin_function
specifier|static
name|void
name|ng_lmc_watchdog_frame
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
operator|(
name|lmc_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|speed
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_running
operator|==
literal|0
condition|)
return|return;
comment|/* if we are not running let timeouts die */
comment|/*           * calculate the apparent throughputs          *  XXX a real hack          */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|speed
operator|=
name|sc
operator|->
name|lmc_inbytes
operator|-
name|sc
operator|->
name|lmc_lastinbytes
expr_stmt|;
name|sc
operator|->
name|lmc_lastinbytes
operator|=
name|sc
operator|->
name|lmc_inbytes
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_inrate
operator|<
name|speed
condition|)
name|sc
operator|->
name|lmc_inrate
operator|=
name|speed
expr_stmt|;
name|speed
operator|=
name|sc
operator|->
name|lmc_outbytes
operator|-
name|sc
operator|->
name|lmc_lastoutbytes
expr_stmt|;
name|sc
operator|->
name|lmc_lastoutbytes
operator|=
name|sc
operator|->
name|lmc_outbytes
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_outrate
operator|<
name|speed
condition|)
name|sc
operator|->
name|lmc_outrate
operator|=
name|speed
expr_stmt|;
name|sc
operator|->
name|lmc_inlast
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|lmc_inlast
operator|>
name|LMC_QUITE_A_WHILE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|lmc_out_deficit
operator|>
name|LMC_LOTS_OF_PACKETS
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: No response from remote end\n"
argument_list|,
name|sc
operator|->
name|lmc_name
argument_list|,
name|sc
operator|->
name|lmc_unit
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|lmc_ifdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lmc_ifup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_inlast
operator|=
name|sc
operator|->
name|lmc_out_deficit
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|lmc_xmit_busy
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|lmc_out_dog
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ar%d: Transmit failure.. no clock?\n"
argument_list|,
name|sc
operator|->
name|lmc_unit
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|lmc_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|lmc_ifdown(sc);                         lmc_ifup(sc);
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_inlast
operator|=
name|sc
operator|->
name|lmc_out_deficit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|lmc_out_dog
operator|--
expr_stmt|;
block|}
block|}
name|lmc_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_handle
operator|=
name|timeout
argument_list|(
name|ng_lmc_watchdog_frame
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * This section contains the methods for the Netgraph interface  ***********************************************************************/
end_comment

begin_comment
comment|/*  * It is not possible or allowable to create a node of this type.  * If the hardware exists, it will already have created it.  */
end_comment

begin_function
specifier|static
name|int
name|ng_lmc_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * give our ok for a hook to be added...  * If we are not running this should kick the device into life.  * We allow hooks called "control", "rawdata", and "debug".  * The hook's private info points to our stash of info about that  * device.  */
end_comment

begin_function
specifier|static
name|int
name|ng_lmc_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/*          * check if it's our friend the debug hook          */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_LMC_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* paranoid */
name|sc
operator|->
name|lmc_debug_hook
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*          * Check for raw mode hook.          */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_LMC_HOOK_RAW
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_hook
operator|=
name|hook
expr_stmt|;
name|sc
operator|->
name|lmc_datahooks
operator|++
expr_stmt|;
name|lmc_ifup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * incoming messages.  * Just respond to the generic TEXT_STATUS message  */
end_comment

begin_function
specifier|static
name|int
name|ng_lmc_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NG_LMC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_LMC_GET_CTL
case|:
block|{
name|lmc_ctl_t
modifier|*
name|ctl
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctl
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|ctl
operator|=
operator|(
name|lmc_ctl_t
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|memcpy
argument_list|(
name|ctl
argument_list|,
operator|&
name|sc
operator|->
name|ictl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_LMC_SET_CTL
case|:
block|{
name|lmc_ctl_t
modifier|*
name|ctl
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ctl
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ctl
operator|=
operator|(
name|lmc_ctl_t
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_status
argument_list|(
name|sc
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* unknown command */
break|break;
block|}
break|break;
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_TEXT_STATUS
case|:
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|resplen
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
literal|512
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|resplen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|arg
operator|=
operator|(
name|resp
operator|)
operator|->
name|data
expr_stmt|;
comment|/* 			 * Put in the throughput information. 			 */
name|pos
operator|=
name|sprintf
argument_list|(
name|arg
argument_list|,
literal|"%ld bytes in, %ld bytes out\n"
literal|"highest rate seen: %ld B/S in, "
literal|"%ld B/S out\n"
argument_list|,
name|sc
operator|->
name|lmc_inbytes
argument_list|,
name|sc
operator|->
name|lmc_outbytes
argument_list|,
name|sc
operator|->
name|lmc_inrate
argument_list|,
name|sc
operator|->
name|lmc_outrate
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"%ld output errors\n"
argument_list|,
name|sc
operator|->
name|lmc_oerrors
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"%ld input errors\n"
argument_list|,
name|sc
operator|->
name|lmc_ierrors
argument_list|)
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|arglen
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Take care of synchronous response, if any */
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get data from another node and transmit it to the line  */
end_comment

begin_function
specifier|static
name|int
name|ng_lmc_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|lmc_softc_t
modifier|*
name|sc
init|=
operator|(
name|lmc_softc_t
operator|*
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|xmitq_p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
comment|/* Unpack all the data components */
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/*          * data doesn't come in from just anywhere (e.g control hook)          */
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*          * Now queue the data for when it can be sent          */
if|if
condition|(
name|meta
operator|&&
name|meta
operator|->
name|priority
operator|>
literal|0
condition|)
block|{
name|xmitq_p
operator|=
operator|(
operator|&
name|sc
operator|->
name|lmc_xmitq_hipri
operator|)
expr_stmt|;
block|}
else|else
block|{
name|xmitq_p
operator|=
operator|(
operator|&
name|sc
operator|->
name|lmc_xmitq
operator|)
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_LOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|xmitq_p
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|_IF_ENQUEUE
argument_list|(
name|xmitq_p
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
name|lmc_ifstart_one
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
comment|/*          * It was an error case.          * check if we need to free the mbuf, and then return the error          */
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * do local shutdown processing..  * this node will refuse to go away, unless the hardware says to..  * don't unref the node, or remove our name. just clear our links up.  */
end_comment

begin_function
specifier|static
name|int
name|ng_lmc_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|lmc_ifdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of the old node. 	 */
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new node. This is basically what a device 	 * driver would do in the attach routine. So let's just do that.. 	 * The node is dead, long live the node! 	 */
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|sc
operator|->
name|lmc_node
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sprintf
argument_list|(
name|sc
operator|->
name|lmc_nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_LMC_NODE_TYPE
argument_list|,
name|sc
operator|->
name|lmc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|sc
operator|->
name|lmc_node
argument_list|,
name|sc
operator|->
name|lmc_nodename
argument_list|)
condition|)
block|{
name|sc
operator|->
name|lmc_node
operator|=
name|NULL
expr_stmt|;
comment|/* to be sure */
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|lmc_node
argument_list|)
expr_stmt|;
comment|/* make it go away */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|lmc_node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|lmc_handle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_running
operator|=
literal|0
expr_stmt|;
comment|/* 	 * turn off those LEDs... 	 */
name|sc
operator|->
name|lmc_miireg16
operator||=
name|LMC_MII16_LED_ALL
expr_stmt|;
name|lmc_led_on
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* already linked */
end_comment

begin_function
specifier|static
name|int
name|ng_lmc_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
comment|/* We are probably not at splnet.. force outward queueing */
name|NG_HOOK_FORCE_QUEUE
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
comment|/* be really amiable and just say "YUP that's OK by me! " */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * notify on hook disconnection (destruction)  *  * For this type, removal of the last link resets tries to destroy the node.  * As the device still exists, the shutdown method will not actually  * destroy the node, but reset the device and leave it 'fresh' :)  *  * The node removal code will remove all references except that owned by the  * driver.  */
end_comment

begin_function
specifier|static
name|int
name|ng_lmc_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
init|=
operator|(
name|lmc_softc_t
operator|*
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/*          * If it's the data hook, then free resources etc.          */
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|lmc_datahooks
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_datahooks
operator|==
literal|0
condition|)
name|lmc_ifdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|lmc_debug_hook
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * called during bootup  * or LKM loading to put this type into the list of known modules  */
end_comment

begin_function
specifier|static
name|void
name|ng_lmc_init
parameter_list|(
name|void
modifier|*
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|ng_newtype
argument_list|(
operator|&
name|typestruct
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ng_lmc install failed\n"
argument_list|)
expr_stmt|;
name|ng_lmc_done_init
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This is the PCI configuration support.  */
end_comment

begin_define
define|#
directive|define
name|PCI_CFID
value|0x00
end_define

begin_comment
comment|/* Configuration ID */
end_comment

begin_define
define|#
directive|define
name|PCI_CFCS
value|0x04
end_define

begin_comment
comment|/* Configurtion Command/Status */
end_comment

begin_define
define|#
directive|define
name|PCI_CFRV
value|0x08
end_define

begin_comment
comment|/* Configuration Revision */
end_comment

begin_define
define|#
directive|define
name|PCI_CFLT
value|0x0c
end_define

begin_comment
comment|/* Configuration Latency Timer */
end_comment

begin_define
define|#
directive|define
name|PCI_CBIO
value|0x10
end_define

begin_comment
comment|/* Configuration Base IO Address */
end_comment

begin_define
define|#
directive|define
name|PCI_CBMA
value|0x14
end_define

begin_comment
comment|/* Configuration Base Memory Address */
end_comment

begin_define
define|#
directive|define
name|PCI_SSID
value|0x2c
end_define

begin_comment
comment|/* subsystem config register */
end_comment

begin_define
define|#
directive|define
name|PCI_CFIT
value|0x3c
end_define

begin_comment
comment|/* Configuration Interrupt */
end_comment

begin_define
define|#
directive|define
name|PCI_CFDA
value|0x40
end_define

begin_comment
comment|/* Configuration Driver Area */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"dev/lmc/if_lmc_fbsd3.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

end_unit

