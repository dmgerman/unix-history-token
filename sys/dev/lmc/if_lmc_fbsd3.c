begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994-1997 Matt Thomas (matt@3am-software.com)  * Copyright (c) LAN Media Corporation 1998, 1999.  * Copyright (c) 2000 Stephen Kiernan (sk-ports@vegamuse.org)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: if_lmc_fbsd.c,v 1.3 1999/01/12 13:27:42 explorer Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This file is INCLUDED (gross, I know, but...)  */
end_comment

begin_define
define|#
directive|define
name|PCI_CONF_WRITE
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|pci_conf_write(config_id, (r), (v))
end_define

begin_define
define|#
directive|define
name|PCI_CONF_READ
parameter_list|(
name|r
parameter_list|)
value|pci_conf_read(config_id, (r))
end_define

begin_define
define|#
directive|define
name|PCI_GETBUSDEVINFO
parameter_list|(
name|sc
parameter_list|)
value|(sc)->lmc_pci_busno = (config_id->bus), \ 			      (sc)->lmc_pci_devno = (config_id->slot)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_OLDPCI
end_ifndef

begin_error
error|#
directive|error
literal|"The lmc device requires the old pci compatibility shims"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void lmc_shutdown(int howto, void * arg);
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LMC_DEVCONF
argument_list|)
end_if

begin_function
specifier|static
name|int
name|lmc_pci_shutdown
parameter_list|(
name|struct
name|kern_devconf
modifier|*
specifier|const
name|kdc
parameter_list|,
name|int
name|force
parameter_list|)
block|{
if|if
condition|(
name|kdc
operator|->
name|kdc_unit
operator|<
name|LMC_MAX_DEVICES
condition|)
block|{
name|lmc_softc_t
modifier|*
specifier|const
name|sc
init|=
name|LMC_UNIT_TO_SOFTC
argument_list|(
name|kdc
operator|->
name|kdc_unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|lmc_shutdown
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lmc_pci_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
block|{
name|u_int32_t
name|id
decl_stmt|;
comment|/* 	 * check first for the DEC chip we expect to find.  We expect 	 * 21140A, pass 2.2 or higher. 	 */
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|device_id
argument_list|)
operator|!=
name|DEC_VENDORID
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|device_id
argument_list|)
operator|!=
name|CHIPID_21140
condition|)
return|return
name|NULL
return|;
name|id
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_CFRV
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0x22
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Next, check the subsystem ID and see if it matches what we 	 * expect. 	 */
name|id
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_SSID
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|id
argument_list|)
operator|!=
name|PCI_VENDOR_LMC
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|id
argument_list|)
operator|==
name|PCI_PRODUCT_LMC_HSSI
condition|)
block|{
return|return
literal|"Lan Media Corporation HSSI"
return|;
block|}
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|id
argument_list|)
operator|==
name|PCI_PRODUCT_LMC_DS3
condition|)
block|{
return|return
literal|"Lan Media Corporation DS3"
return|;
block|}
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|id
argument_list|)
operator|==
name|PCI_PRODUCT_LMC_SSI
condition|)
block|{
return|return
literal|"Lan Media Corporation SSI"
return|;
block|}
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|id
argument_list|)
operator|==
name|PCI_PRODUCT_LMC_T1
condition|)
block|{
return|return
literal|"Lan Media Coporation T1"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|lmc_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|lmc_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pci_device
name|lmcdevice
init|=
block|{
literal|"lmc"
block|,
name|lmc_pci_probe
block|,
name|lmc_pci_attach
block|,
operator|&
name|lmc_pci_count
block|,
if|#
directive|if
name|defined
argument_list|(
name|LMC_DEVCONF
argument_list|)
name|lmc_pci_shutdown
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_PCI_DRIVER
end_ifdef

begin_expr_stmt
name|COMPAT_PCI_DRIVER
argument_list|(
name|ti
argument_list|,
name|lmcdevice
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|lmcdevice
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_PCI_DRIVER */
end_comment

begin_function
specifier|static
name|void
name|lmc_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|lmc_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|u_int32_t
name|revinfo
decl_stmt|,
name|cfdainfo
decl_stmt|,
name|id
decl_stmt|,
name|ssid
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LMC_IOMAPPED
argument_list|)
name|vm_offset_t
name|pa_csrs
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|csroffset
init|=
name|LMC_PCI_CSROFFSET
decl_stmt|;
name|unsigned
name|csrsize
init|=
name|LMC_PCI_CSRSIZE
decl_stmt|;
name|lmc_csrptr_t
name|csr_base
decl_stmt|;
name|lmc_spl_t
name|s
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|LMC_MAX_DEVICES
condition|)
block|{
name|printf
argument_list|(
literal|"lmc%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": not configured; limit of %d reached or exceeded\n"
argument_list|,
name|LMC_MAX_DEVICES
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * allocate memory for the softc 	 */
name|sc
operator|=
operator|(
name|lmc_softc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|revinfo
operator|=
name|PCI_CONF_READ
argument_list|(
name|PCI_CFRV
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|id
operator|=
name|PCI_CONF_READ
argument_list|(
name|PCI_CFID
argument_list|)
expr_stmt|;
name|cfdainfo
operator|=
name|PCI_CONF_READ
argument_list|(
name|PCI_CFDA
argument_list|)
expr_stmt|;
name|ssid
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_SSID
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|PCI_CHIPID
argument_list|(
name|ssid
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_LMC_HSSI
case|:
name|sc
operator|->
name|lmc_media
operator|=
operator|&
name|lmc_hssi_media
expr_stmt|;
break|break;
case|case
name|PCI_PRODUCT_LMC_DS3
case|:
name|sc
operator|->
name|lmc_media
operator|=
operator|&
name|lmc_ds3_media
expr_stmt|;
break|break;
case|case
name|PCI_PRODUCT_LMC_SSI
case|:
name|sc
operator|->
name|lmc_media
operator|=
operator|&
name|lmc_ssi_media
expr_stmt|;
break|break;
case|case
name|PCI_PRODUCT_LMC_T1
case|:
name|sc
operator|->
name|lmc_media
operator|=
operator|&
name|lmc_t1_media
expr_stmt|;
break|break;
block|}
comment|/* 	 * allocate memory for the device descriptors 	 */
name|sc
operator|->
name|lmc_rxdescs
operator|=
operator|(
name|tulip_desc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tulip_desc_t
argument_list|)
operator|*
name|LMC_RXDESCS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_txdescs
operator|=
operator|(
name|tulip_desc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tulip_desc_t
argument_list|)
operator|*
name|LMC_TXDESCS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_rxdescs
operator|==
name|NULL
operator|||
name|sc
operator|->
name|lmc_txdescs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|lmc_rxdescs
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|lmc_rxdescs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_txdescs
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|lmc_txdescs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|PCI_GETBUSDEVINFO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_chipid
operator|=
name|LMC_21140A
expr_stmt|;
name|sc
operator|->
name|lmc_features
operator||=
name|LMC_HAVE_STOREFWD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmc_chipid
operator|==
name|LMC_21140A
operator|&&
name|revinfo
operator|<=
literal|0x22
condition|)
name|sc
operator|->
name|lmc_features
operator||=
name|LMC_HAVE_RXBADOVRFLW
expr_stmt|;
if|if
condition|(
name|cfdainfo
operator|&
operator|(
name|TULIP_CFDA_SLEEP
operator||
name|TULIP_CFDA_SNOOZE
operator|)
condition|)
block|{
name|cfdainfo
operator|&=
operator|~
operator|(
name|TULIP_CFDA_SLEEP
operator||
name|TULIP_CFDA_SNOOZE
operator|)
expr_stmt|;
name|PCI_CONF_WRITE
argument_list|(
name|PCI_CFDA
argument_list|,
name|cfdainfo
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|11
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|lmc_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|lmc_name
operator|=
literal|"lmc"
expr_stmt|;
name|sc
operator|->
name|lmc_revinfo
operator|=
name|revinfo
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LMC_IOMAPPED
argument_list|)
name|retval
operator|=
name|pci_map_port
argument_list|(
name|config_id
argument_list|,
name|PCI_CBIO
argument_list|,
operator|&
name|csr_base
argument_list|)
expr_stmt|;
else|#
directive|else
name|retval
operator|=
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCI_CBMA
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|csr_base
argument_list|,
operator|&
name|pa_csrs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|lmc_rxdescs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|lmc_txdescs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|tulips
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|lmc_initcsrs
argument_list|(
name|sc
argument_list|,
name|csr_base
operator|+
name|csroffset
argument_list|,
name|csrsize
argument_list|)
expr_stmt|;
name|lmc_initring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|lmc_rxinfo
argument_list|,
name|sc
operator|->
name|lmc_rxdescs
argument_list|,
name|LMC_RXDESCS
argument_list|)
expr_stmt|;
name|lmc_initring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|lmc_txinfo
argument_list|,
name|sc
operator|->
name|lmc_txdescs
argument_list|,
name|LMC_TXDESCS
argument_list|)
expr_stmt|;
name|lmc_gpio_mkinput
argument_list|(
name|sc
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_gpio
operator|=
literal|0
expr_stmt|;
comment|/* drive no signals yet */
name|sc
operator|->
name|lmc_media
operator|->
name|defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_media
operator|->
name|set_link_status
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* down */
comment|/* 	 * Make sure there won't be any interrupts or such... 	 */
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
comment|/* 	 * Wait 10 microseconds (actually 50 PCI cycles but at  	 * 33MHz that comes to two microseconds but wait a 	 * bit longer anyways) 	 */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|ictl
operator|.
name|cardtype
condition|)
block|{
case|case
name|LMC_CARDTYPE_HSSI
case|:
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": HSSI, "
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
break|break;
case|case
name|LMC_CARDTYPE_DS3
case|:
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": DS3, "
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
break|break;
case|case
name|LMC_CARDTYPE_SSI
case|:
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": SSI, "
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
break|break;
block|}
name|lmc_read_macaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lmc%d: pass %d.%d, serial "
name|LMC_EADDR_FMT
literal|"\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|sc
operator|->
name|lmc_revinfo
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|lmc_revinfo
operator|&
literal|0x0F
argument_list|,
name|LMC_EADDR_ARGS
argument_list|(
name|sc
operator|->
name|lmc_enaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|lmc_intr_normal
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|LMC_PRINTF_FMT
literal|": couldn't map interrupt\n"
argument_list|,
name|LMC_PRINTF_ARGS
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LMC_DEVCONF
argument_list|)
block|at_shutdown(lmc_shutdown, sc, SHUTDOWN_POST_SYNC);
endif|#
directive|endif
endif|#
directive|endif
name|s
operator|=
name|LMC_RAISESPL
argument_list|()
expr_stmt|;
name|lmc_dec_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lmc_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lmc_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LMC_RESTORESPL
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void lmc_shutdown(int howto, void * arg) { 	lmc_softc_t * const sc = arg; 	LMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET); 	DELAY(10);  	sc->lmc_miireg16 = 0;
comment|/* deassert ready, and all others too */
end_comment

begin_endif
unit|printf("lmc: 5\n"); 	lmc_led_on(sc, LMC_MII16_LED_ALL); }
endif|#
directive|endif
end_endif

end_unit

