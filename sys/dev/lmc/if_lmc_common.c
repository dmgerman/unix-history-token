begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994-1997 Matt Thomas (matt@3am-software.com)  * Copyright (c) LAN Media Corporation 1998, 1999.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *      From NetBSD: if_de.c,v 1.56.2.1 1997/10/27 02:13:25 thorpej Exp  *	$Id: if_lmc_common.c,v 1.12 1999/03/01 15:22:37 explorer Exp $  */
end_comment

begin_comment
comment|/*  * the dec chip has its own idea of what a receive error is, but we don't  * want to use it, as it will get the crc error wrong when 16-bit  * crcs are used.  So, we only care about certain conditions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TULIP_DSTS_RxMIIERR
end_ifndef

begin_define
define|#
directive|define
name|TULIP_DSTS_RxMIIERR
value|0x00000008
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LMC_DSTS_ERRSUM
value|(TULIP_DSTS_RxMIIERR)
end_define

begin_function
specifier|static
name|void
name|lmc_gpio_mkinput
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|u_int32_t
name|bits
parameter_list|)
block|{
name|sc
operator|->
name|lmc_gpio_io
operator|&=
operator|~
name|bits
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_PINSET
operator||
operator|(
name|sc
operator|->
name|lmc_gpio_io
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_gpio_mkoutput
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|u_int32_t
name|bits
parameter_list|)
block|{
name|sc
operator|->
name|lmc_gpio_io
operator||=
name|bits
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_PINSET
operator||
operator|(
name|sc
operator|->
name|lmc_gpio_io
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_led_on
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|u_int32_t
name|led
parameter_list|)
block|{
name|sc
operator|->
name|lmc_miireg16
operator|&=
operator|~
name|led
expr_stmt|;
name|lmc_mii_writereg
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|sc
operator|->
name|lmc_miireg16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_led_off
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|u_int32_t
name|led
parameter_list|)
block|{
name|sc
operator|->
name|lmc_miireg16
operator||=
name|led
expr_stmt|;
name|lmc_mii_writereg
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|sc
operator|->
name|lmc_miireg16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_reset
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|lmc_miireg16
operator||=
name|LMC_MII16_FIFO_RESET
expr_stmt|;
name|lmc_mii_writereg
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|sc
operator|->
name|lmc_miireg16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_miireg16
operator|&=
operator|~
name|LMC_MII16_FIFO_RESET
expr_stmt|;
name|lmc_mii_writereg
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|sc
operator|->
name|lmc_miireg16
argument_list|)
expr_stmt|;
comment|/* 	 * make some of the GPIO pins be outputs 	 */
name|lmc_gpio_mkoutput
argument_list|(
name|sc
argument_list|,
name|LMC_GEP_DP
operator||
name|LMC_GEP_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * drive DP and RESET low to force configuration.  This also forces 	 * the transmitter clock to be internal, but we expect to reset 	 * that later anyway. 	 */
name|sc
operator|->
name|lmc_gpio
operator|&=
operator|~
operator|(
name|LMC_GEP_DP
operator||
name|LMC_GEP_RESET
operator|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|sc
operator|->
name|lmc_gpio
argument_list|)
expr_stmt|;
comment|/* 	 * hold for more than 10 microseconds 	 */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * stop driving Xilinx-related signals 	 */
name|lmc_gpio_mkinput
argument_list|(
name|sc
argument_list|,
name|LMC_GEP_DP
operator||
name|LMC_GEP_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * busy wait for the chip to reset 	 */
while|while
condition|(
operator|(
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
operator|&
name|LMC_GEP_DP
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* 	 * Call media specific init routine 	 */
name|sc
operator|->
name|lmc_media
operator|->
name|init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_dec_reset
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__linux__
name|lmc_ringinfo_t
modifier|*
name|ri
decl_stmt|;
name|tulip_desc_t
modifier|*
name|di
decl_stmt|;
endif|#
directive|endif
name|u_int32_t
name|val
decl_stmt|;
comment|/* 	 * disable all interrupts 	 */
name|sc
operator|->
name|lmc_intrmask
operator|=
literal|0
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|lmc_intrmask
argument_list|)
expr_stmt|;
comment|/* 	 * we are, obviously, down. 	 */
ifndef|#
directive|ifndef
name|__linux__
name|sc
operator|->
name|lmc_flags
operator|&=
operator|~
operator|(
name|LMC_IFUP
operator||
name|LMC_MODEMOK
operator|)
expr_stmt|;
name|DP
argument_list|(
operator|(
literal|"lmc_dec_reset\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Reset the chip with a software reset command. 	 * Wait 10 microseconds (actually 50 PCI cycles but at  	 * 33MHz that comes to two microseconds but wait a 	 * bit longer anyways) 	 */
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_cmdmode
operator|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
expr_stmt|;
comment|/* 	 * We want: 	 *   no ethernet address in frames we write 	 *   disable padding (txdesc, padding disable) 	 *   ignore runt frames (rdes0 bit 15) 	 *   no receiver watchdog or transmitter jabber timer 	 *       (csr15 bit 0,14 == 1) 	 *   if using 16-bit CRC, turn off CRC (trans desc, crc disable) 	 */
ifndef|#
directive|ifndef
name|TULIP_CMD_RECEIVEALL
define|#
directive|define
name|TULIP_CMD_RECEIVEALL
value|0x40000000L
endif|#
directive|endif
name|sc
operator|->
name|lmc_cmdmode
operator||=
operator|(
name|TULIP_CMD_PROMISCUOUS
operator||
name|TULIP_CMD_FULLDUPLEX
operator||
name|TULIP_CMD_PASSBADPKT
operator||
name|TULIP_CMD_NOHEARTBEAT
operator||
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_RECEIVEALL
operator||
name|TULIP_CMD_MUSTBEONE
operator|)
expr_stmt|;
name|sc
operator|->
name|lmc_cmdmode
operator|&=
operator|~
operator|(
name|TULIP_CMD_OPERMODE
operator||
name|TULIP_CMD_THRESHOLDCTL
operator||
name|TULIP_CMD_STOREFWD
operator||
name|TULIP_CMD_TXTHRSHLDCTL
operator|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|lmc_cmdmode
argument_list|)
expr_stmt|;
comment|/* 	 * disable receiver watchdog and transmit jabber 	 */
name|val
operator|=
name|LMC_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|TULIP_WATCHDOG_TXDISABLE
operator||
name|TULIP_WATCHDOG_RXDISABLE
operator|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * turn off those LEDs... 	 */
name|sc
operator|->
name|lmc_miireg16
operator||=
name|LMC_MII16_LED_ALL
expr_stmt|;
name|lmc_led_on
argument_list|(
name|sc
argument_list|,
name|LMC_MII16_LED0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__linux__
comment|/* 	 * reprogram the tx desc, rx desc, and PCI bus options 	 */
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txlist
argument_list|,
name|LMC_KVATOPHYS
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|lmc_txinfo
operator|.
name|ri_first
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_rxlist
argument_list|,
name|LMC_KVATOPHYS
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|lmc_rxinfo
operator|.
name|ri_first
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|LMC_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
operator|(
literal|1
operator|<<
operator|(
name|LMC_BURSTSIZE
argument_list|(
name|sc
operator|->
name|lmc_unit
argument_list|)
operator|+
literal|8
operator|)
operator|)
operator||
name|TULIP_BUSMODE_CACHE_ALIGN8
operator||
name|TULIP_BUSMODE_READMULTIPLE
operator||
operator|(
name|BYTE_ORDER
operator|!=
name|LITTLE_ENDIAN
condition|?
name|TULIP_BUSMODE_BIGENDIAN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lmc_txq
operator|.
name|ifq_maxlen
operator|=
name|LMC_TXDESCS
expr_stmt|;
comment|/* 	 * Free all the mbufs that were on the transmit ring. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * reset descriptor state and reclaim all descriptors. 	 */
name|ri
operator|=
operator|&
name|sc
operator|->
name|lmc_txinfo
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|ri
operator|->
name|ri_max
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
name|di
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We need to collect all the mbufs were on the  	 * receive ring before we reinit it either to put 	 * them back on or to know if we have to allocate 	 * more. 	 */
name|ri
operator|=
operator|&
name|sc
operator|->
name|lmc_rxinfo
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|ri
operator|->
name|ri_max
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
block|{
name|di
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_length1
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_addr1
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|lmc_rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|lmc_initcsrs
parameter_list|(
name|lmc_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|lmc_csrptr_t
name|csr_base
parameter_list|,
name|size_t
name|csr_size
parameter_list|)
block|{
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_busmode
operator|=
name|csr_base
operator|+
literal|0
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_txpoll
operator|=
name|csr_base
operator|+
literal|1
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_rxpoll
operator|=
name|csr_base
operator|+
literal|2
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_rxlist
operator|=
name|csr_base
operator|+
literal|3
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_txlist
operator|=
name|csr_base
operator|+
literal|4
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_status
operator|=
name|csr_base
operator|+
literal|5
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_command
operator|=
name|csr_base
operator|+
literal|6
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_intr
operator|=
name|csr_base
operator|+
literal|7
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_missed_frames
operator|=
name|csr_base
operator|+
literal|8
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_9
operator|=
name|csr_base
operator|+
literal|9
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_10
operator|=
name|csr_base
operator|+
literal|10
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_11
operator|=
name|csr_base
operator|+
literal|11
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_12
operator|=
name|csr_base
operator|+
literal|12
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_13
operator|=
name|csr_base
operator|+
literal|13
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_14
operator|=
name|csr_base
operator|+
literal|14
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|lmc_csrs
operator|.
name|csr_15
operator|=
name|csr_base
operator|+
literal|15
operator|*
name|csr_size
expr_stmt|;
block|}
end_function

end_unit

