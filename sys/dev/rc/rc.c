begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1995 by Pavel Antonov, Moscow, Russia.  * Copyright (C) 1995 by Andrey A. Chernov, Moscow, Russia.  * Copyright (C) 2002 by John Baldwin<jhb@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * SDL Communications Riscom/8 (based on Cirrus Logic CL-CD180) driver  *  */
end_comment

begin_comment
comment|/*#define RCDEBUG*/
end_comment

begin_include
include|#
directive|include
file|"opt_tty.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/serial.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/cd180.h>
end_include

begin_include
include|#
directive|include
file|<dev/rc/rcreg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_define
define|#
directive|define
name|IOBASE_ADDRS
value|14
end_define

begin_define
define|#
directive|define
name|rcin
parameter_list|(
name|sc
parameter_list|,
name|port
parameter_list|)
value|RC_IN(sc, port)
end_define

begin_define
define|#
directive|define
name|rcout
parameter_list|(
name|sc
parameter_list|,
name|port
parameter_list|,
name|v
parameter_list|)
value|RC_OUT(sc, port, v)
end_define

begin_define
define|#
directive|define
name|WAITFORCCR
parameter_list|(
name|sc
parameter_list|,
name|chan
parameter_list|)
value|rc_wait0((sc), (chan), __LINE__)
end_define

begin_define
define|#
directive|define
name|CCRCMD
parameter_list|(
name|sc
parameter_list|,
name|chan
parameter_list|,
name|cmd
parameter_list|)
value|do {					\ 	WAITFORCCR((sc), (chan));					\ 	rcout((sc), CD180_CCR, (cmd));					\ } while (0)
end_define

begin_define
define|#
directive|define
name|RC_IBUFSIZE
value|256
end_define

begin_define
define|#
directive|define
name|RB_I_HIGH_WATER
value|(TTYHOG - 2 * RC_IBUFSIZE)
end_define

begin_define
define|#
directive|define
name|RC_OBUFSIZE
value|512
end_define

begin_define
define|#
directive|define
name|RC_IHIGHWATER
value|(3 * RC_IBUFSIZE / 4)
end_define

begin_define
define|#
directive|define
name|INPUT_FLAGS_SHIFT
value|(2 * RC_IBUFSIZE)
end_define

begin_define
define|#
directive|define
name|LOTS_OF_EVENTS
value|64
end_define

begin_define
define|#
directive|define
name|RC_FAKEID
value|0x10
end_define

begin_comment
comment|/* Per-channel structure */
end_comment

begin_struct
struct|struct
name|rc_chans
block|{
name|struct
name|rc_softc
modifier|*
name|rc_rcb
decl_stmt|;
comment|/* back ptr             */
name|u_short
name|rc_flags
decl_stmt|;
comment|/* Misc. flags          */
name|int
name|rc_chan
decl_stmt|;
comment|/* Channel #            */
name|u_char
name|rc_ier
decl_stmt|;
comment|/* intr. enable reg     */
name|u_char
name|rc_msvr
decl_stmt|;
comment|/* modem sig. status    */
name|u_char
name|rc_cor2
decl_stmt|;
comment|/* options reg          */
name|u_char
name|rc_pendcmd
decl_stmt|;
comment|/* special cmd pending  */
name|u_int
name|rc_dcdwaits
decl_stmt|;
comment|/* how many waits DCD in open */
name|struct
name|tty
modifier|*
name|rc_tp
decl_stmt|;
comment|/* tty struct           */
name|u_char
modifier|*
name|rc_iptr
decl_stmt|;
comment|/* Chars input buffer         */
name|u_char
modifier|*
name|rc_hiwat
decl_stmt|;
comment|/* hi-water mark        */
name|u_char
modifier|*
name|rc_bufend
decl_stmt|;
comment|/* end of buffer        */
name|u_char
modifier|*
name|rc_optr
decl_stmt|;
comment|/* ptr in output buf    */
name|u_char
modifier|*
name|rc_obufend
decl_stmt|;
comment|/* end of output buf    */
name|u_char
name|rc_ibuf
index|[
literal|4
operator|*
name|RC_IBUFSIZE
index|]
decl_stmt|;
comment|/* input buffer         */
name|u_char
name|rc_obuf
index|[
name|RC_OBUFSIZE
index|]
decl_stmt|;
comment|/* output buffer        */
name|struct
name|callout
name|rc_dtrcallout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Per-board structure */
end_comment

begin_struct
struct|struct
name|rc_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_irq
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_port
index|[
name|IOBASE_ADDRS
index|]
decl_stmt|;
name|int
name|sc_irqrid
decl_stmt|;
name|void
modifier|*
name|sc_hwicookie
decl_stmt|;
name|bus_space_tag_t
name|sc_bt
decl_stmt|;
name|bus_space_handle_t
name|sc_bh
decl_stmt|;
name|u_int
name|sc_unit
decl_stmt|;
comment|/* unit #               */
name|u_char
name|sc_dtr
decl_stmt|;
comment|/* DTR status           */
name|int
name|sc_scheduled_event
decl_stmt|;
name|void
modifier|*
name|sc_swicookie
decl_stmt|;
name|struct
name|rc_chans
name|sc_channels
index|[
name|CD180_NCHAN
index|]
decl_stmt|;
comment|/* channels */
block|}
struct|;
end_struct

begin_comment
comment|/* Static prototypes */
end_comment

begin_decl_stmt
specifier|static
name|t_close_t
name|rc_close
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rc_break
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rc_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rc_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rc_hwreset
parameter_list|(
name|struct
name|rc_softc
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rc_test
parameter_list|(
name|struct
name|rc_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rc_discard_output
parameter_list|(
name|struct
name|rc_chans
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rc_modem
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rc_start
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rc_stop
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
name|rw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rc_param
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rc_pollcard
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rc_reinit
parameter_list|(
name|struct
name|rc_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|RCDEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|printrcflags
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|rc_wait0
parameter_list|(
name|struct
name|rc_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chan
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|devclass_t
name|rc_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags */
end_comment

begin_define
define|#
directive|define
name|RC_DTR_OFF
value|0x0001
end_define

begin_comment
comment|/* DTR wait, for close/open     */
end_comment

begin_define
define|#
directive|define
name|RC_ACTOUT
value|0x0002
end_define

begin_comment
comment|/* Dial-out port active         */
end_comment

begin_define
define|#
directive|define
name|RC_RTSFLOW
value|0x0004
end_define

begin_comment
comment|/* RTS flow ctl enabled         */
end_comment

begin_define
define|#
directive|define
name|RC_CTSFLOW
value|0x0008
end_define

begin_comment
comment|/* CTS flow ctl enabled         */
end_comment

begin_define
define|#
directive|define
name|RC_DORXFER
value|0x0010
end_define

begin_comment
comment|/* RXFER event planned          */
end_comment

begin_define
define|#
directive|define
name|RC_DOXXFER
value|0x0020
end_define

begin_comment
comment|/* XXFER event planned          */
end_comment

begin_define
define|#
directive|define
name|RC_MODCHG
value|0x0040
end_define

begin_comment
comment|/* Modem status changed         */
end_comment

begin_define
define|#
directive|define
name|RC_OSUSP
value|0x0080
end_define

begin_comment
comment|/* Output suspended             */
end_comment

begin_define
define|#
directive|define
name|RC_OSBUSY
value|0x0100
end_define

begin_comment
comment|/* start() routine in progress  */
end_comment

begin_define
define|#
directive|define
name|RC_WAS_BUFOVFL
value|0x0200
end_define

begin_comment
comment|/* low-level buffer ovferflow   */
end_comment

begin_define
define|#
directive|define
name|RC_WAS_SILOVFL
value|0x0400
end_define

begin_comment
comment|/* silo buffer overflow         */
end_comment

begin_define
define|#
directive|define
name|RC_SEND_RDY
value|0x0800
end_define

begin_comment
comment|/* ready to send */
end_comment

begin_comment
comment|/* Table for translation of RCSR status bits to internal form */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rc_rcsrt
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
name|TTY_OE
block|,
name|TTY_FE
block|,
name|TTY_FE
operator||
name|TTY_OE
block|,
name|TTY_PE
block|,
name|TTY_PE
operator||
name|TTY_OE
block|,
name|TTY_PE
operator||
name|TTY_FE
block|,
name|TTY_PE
operator||
name|TTY_FE
operator||
name|TTY_OE
block|,
name|TTY_BI
block|,
name|TTY_BI
operator||
name|TTY_OE
block|,
name|TTY_BI
operator||
name|TTY_FE
block|,
name|TTY_BI
operator||
name|TTY_FE
operator||
name|TTY_OE
block|,
name|TTY_BI
operator||
name|TTY_PE
block|,
name|TTY_BI
operator||
name|TTY_PE
operator||
name|TTY_OE
block|,
name|TTY_BI
operator||
name|TTY_PE
operator||
name|TTY_FE
block|,
name|TTY_BI
operator||
name|TTY_PE
operator||
name|TTY_FE
operator||
name|TTY_OE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rc_ports
index|[]
init|=
block|{
literal|0x220
block|,
literal|0x240
block|,
literal|0x250
block|,
literal|0x260
block|,
literal|0x2a0
block|,
literal|0x2b0
block|,
literal|0x300
block|,
literal|0x320
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iobase_addrs
index|[
name|IOBASE_ADDRS
index|]
init|=
block|{
literal|0
block|,
literal|0x400
block|,
literal|0x800
block|,
literal|0xc00
block|,
literal|0x1400
block|,
literal|0x1800
block|,
literal|0x1c00
block|,
literal|0x2000
block|,
literal|0x3000
block|,
literal|0x3400
block|,
literal|0x3800
block|,
literal|0x3c00
block|,
literal|0x4000
block|,
literal|0x8000
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************************************/
end_comment

begin_function
specifier|static
name|int
name|rc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int
name|port
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
comment|/* 	 * We don't know of any PnP ID's for these cards. 	 */
if|if
condition|(
name|isa_get_logicalid
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * We have to have an IO port hint that is valid. 	 */
name|port
operator|=
name|isa_get_port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rc_ports
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rc_ports
index|[
name|i
index|]
operator|==
name|port
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * We have to have an IRQ hint. 	 */
if|if
condition|(
name|isa_get_irq
argument_list|(
name|dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"SDL Riscom/8"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|port
decl_stmt|;
name|int
name|base
decl_stmt|,
name|chan
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|x
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* 	 * We need to have IO ports.  Lots of them.  We need 	 * the following ranges relative to the base port: 	 * 0x0    -   0x10 	 * 0x400  -  0x410 	 * 0x800  -  0x810 	 * 0xc00  -  0xc10 	 * 0x1400 - 0x1410 	 * 0x1800 - 0x1810 	 * 0x1c00 - 0x1c10 	 * 0x2000 - 0x2010 	 * 0x3000 - 0x3010 	 * 0x3400 - 0x3410 	 * 0x3800 - 0x3810 	 * 0x3c00 - 0x3c10 	 * 0x4000 - 0x4010 	 * 0x8000 - 0x8010 	 */
name|port
operator|=
name|isa_get_port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IOBASE_ADDRS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|i
argument_list|,
name|port
operator|+
name|iobase_addrs
index|[
name|i
index|]
argument_list|,
literal|0x10
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IOBASE_ADDRS
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_port
index|[
name|i
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|x
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|0x10
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|i
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ioport %d was rid %d\n"
argument_list|,
name|i
argument_list|,
name|x
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_port
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to alloc ioports %x-%x\n"
argument_list|,
name|port
operator|+
name|iobase_addrs
index|[
name|i
index|]
argument_list|,
name|port
operator|+
name|iobase_addrs
index|[
name|i
index|]
operator|+
literal|0x10
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|sc
operator|->
name|sc_bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_port
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_port
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_irqrid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to alloc IRQ\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Now do some actual tests to make sure it works. 	 */
name|error
operator|=
name|ENXIO
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_PPRL
argument_list|,
literal|0x22
argument_list|)
expr_stmt|;
comment|/* Random values to Prescale reg. */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_PPRH
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_PPRL
argument_list|)
operator|!=
literal|0x22
operator|||
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_PPRH
argument_list|)
operator|!=
literal|0x11
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|rc_test
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Ok, start actually hooking things up. 	 */
name|sc
operator|->
name|sc_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*sc->sc_chipid = 0x10 + device_get_unit(dev);*/
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%d chans, firmware rev. %c\n"
argument_list|,
name|CD180_NCHAN
argument_list|,
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_GFRCR
argument_list|)
operator|&
literal|0xF
operator|)
operator|+
literal|'A'
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sc
operator|->
name|sc_channels
expr_stmt|;
name|base
operator|=
name|CD180_NCHAN
operator|*
name|sc
operator|->
name|sc_unit
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|CD180_NCHAN
condition|;
name|chan
operator|++
operator|,
name|rc
operator|++
control|)
block|{
name|rc
operator|->
name|rc_rcb
operator|=
name|sc
expr_stmt|;
name|rc
operator|->
name|rc_chan
operator|=
name|chan
expr_stmt|;
name|rc
operator|->
name|rc_iptr
operator|=
name|rc
operator|->
name|rc_ibuf
expr_stmt|;
name|rc
operator|->
name|rc_bufend
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IBUFSIZE
index|]
expr_stmt|;
name|rc
operator|->
name|rc_hiwat
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IHIGHWATER
index|]
expr_stmt|;
name|rc
operator|->
name|rc_optr
operator|=
name|rc
operator|->
name|rc_obufend
operator|=
name|rc
operator|->
name|rc_obuf
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|rc
operator|->
name|rc_dtrcallout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|=
name|rc
operator|->
name|rc_tp
operator|=
name|ttyalloc
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|rc
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|rc_start
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|rc_param
expr_stmt|;
name|tp
operator|->
name|t_modem
operator|=
name|rc_modem
expr_stmt|;
name|tp
operator|->
name|t_break
operator|=
name|rc_break
expr_stmt|;
name|tp
operator|->
name|t_close
operator|=
name|rc_close
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|rc_stop
expr_stmt|;
name|ttycreate
argument_list|(
name|tp
argument_list|,
name|TS_CALLOUT
argument_list|,
literal|"m%d"
argument_list|,
name|chan
operator|+
name|base
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_TTY
argument_list|,
name|NULL
argument_list|,
name|rc_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hwicookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to register interrupt handler\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|swi_add
argument_list|(
operator|&
name|tty_intr_event
argument_list|,
literal|"rc"
argument_list|,
name|rc_pollcard
argument_list|,
name|sc
argument_list|,
name|SWI_TTY
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_swicookie
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|rc_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sc
operator|->
name|sc_channels
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CD180_NCHAN
condition|;
name|i
operator|++
operator|,
name|rc
operator|++
control|)
name|ttyfree
argument_list|(
name|rc
operator|->
name|rc_tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_hwicookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to deregister interrupt handler\n"
argument_list|)
expr_stmt|;
name|swi_remove
argument_list|(
name|sc
operator|->
name|sc_swicookie
argument_list|)
expr_stmt|;
name|rc_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rc_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|sc_irqrid
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IOBASE_ADDRS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_port
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|sc_port
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_port
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* RC interrupt handling */
end_comment

begin_function
specifier|static
name|void
name|rc_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|int
name|resid
decl_stmt|,
name|chan
decl_stmt|;
name|u_char
name|val
decl_stmt|,
name|iack
decl_stmt|,
name|bsr
decl_stmt|,
name|ucnt
decl_stmt|,
modifier|*
name|optr
decl_stmt|;
name|int
name|good_data
decl_stmt|,
name|t_state
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|rc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|bsr
operator|=
operator|~
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_BSR
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bsr
operator|&
operator|(
name|RC_BSR_TOUT
operator||
name|RC_BSR_RXINT
operator||
name|RC_BSR_TXINT
operator||
name|RC_BSR_MOINT
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"extra interrupt\n"
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_EOIR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|bsr
operator|&
operator|(
name|RC_BSR_TOUT
operator||
name|RC_BSR_RXINT
operator||
name|RC_BSR_TXINT
operator||
name|RC_BSR_MOINT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RCDEBUG_DETAILED
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"intr (%p) %s%s%s%s\n"
argument_list|,
name|arg
argument_list|,
name|bsr
argument_list|,
operator|(
name|bsr
operator|&
name|RC_BSR_TOUT
operator|)
condition|?
literal|"TOUT "
else|:
literal|""
argument_list|,
operator|(
name|bsr
operator|&
name|RC_BSR_RXINT
operator|)
condition|?
literal|"RXINT "
else|:
literal|""
argument_list|,
operator|(
name|bsr
operator|&
name|RC_BSR_TXINT
operator|)
condition|?
literal|"TXINT "
else|:
literal|""
argument_list|,
operator|(
name|bsr
operator|&
name|RC_BSR_MOINT
operator|)
condition|?
literal|"MOINT"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bsr
operator|&
name|RC_BSR_TOUT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hardware failure, reset board\n"
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|RC_CTOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bsr
operator|&
name|RC_BSR_RXINT
condition|)
block|{
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_PILR_RX
argument_list|)
expr_stmt|;
name|good_data
operator|=
operator|(
name|iack
operator|==
operator|(
name|GIVR_IT_RGDI
operator||
name|RC_FAKEID
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|good_data
operator|&&
name|iack
operator|!=
operator|(
name|GIVR_IT_REI
operator||
name|RC_FAKEID
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"fake rxint: %02x\n"
argument_list|,
name|iack
argument_list|)
expr_stmt|;
goto|goto
name|more_intrs
goto|;
block|}
name|chan
operator|=
operator|(
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_GICR
argument_list|)
operator|&
name|GICR_CHAN
operator|)
operator|>>
name|GICR_LSH
operator|)
expr_stmt|;
name|rc
operator|=
operator|&
name|sc
operator|->
name|sc_channels
index|[
name|chan
index|]
expr_stmt|;
name|t_state
operator|=
name|rc
operator|->
name|rc_tp
operator|->
name|t_state
expr_stmt|;
comment|/* Do RTS flow control stuff */
if|if
condition|(
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_RTSFLOW
operator|)
operator|||
operator|!
operator|(
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|||
operator|(
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|)
operator|&&
operator|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_RTS
operator|)
condition|)
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|,
name|rc
operator|->
name|rc_msvr
operator|&=
operator|~
name|MSVR_RTS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_RTS
operator|)
condition|)
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|,
name|rc
operator|->
name|rc_msvr
operator||=
name|MSVR_RTS
argument_list|)
expr_stmt|;
block|}
name|ucnt
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RDCR
argument_list|)
operator|&
literal|0xF
expr_stmt|;
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
comment|/* check for input buffer overflow */
if|if
condition|(
operator|(
name|rc
operator|->
name|rc_iptr
operator|+
name|ucnt
operator|)
operator|>=
name|rc
operator|->
name|rc_bufend
condition|)
block|{
name|resid
operator|=
name|ucnt
expr_stmt|;
name|ucnt
operator|=
name|rc
operator|->
name|rc_bufend
operator|-
name|rc
operator|->
name|rc_iptr
expr_stmt|;
name|resid
operator|-=
name|ucnt
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_WAS_BUFOVFL
operator|)
condition|)
block|{
name|rc
operator|->
name|rc_flags
operator||=
name|RC_WAS_BUFOVFL
expr_stmt|;
name|sc
operator|->
name|sc_scheduled_event
operator|++
expr_stmt|;
block|}
block|}
name|optr
operator|=
name|rc
operator|->
name|rc_iptr
expr_stmt|;
comment|/* check foor good data */
if|if
condition|(
name|good_data
condition|)
block|{
while|while
condition|(
name|ucnt
operator|--
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RDR
argument_list|)
expr_stmt|;
name|optr
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|optr
index|[
name|INPUT_FLAGS_SHIFT
index|]
operator|=
literal|0
expr_stmt|;
name|optr
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_scheduled_event
operator|++
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|val
operator|==
name|rc
operator|->
name|rc_tp
operator|->
name|t_hotchar
condition|)
name|swi_sched
argument_list|(
name|sc
operator|->
name|sc_swicookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Store also status data */
while|while
condition|(
name|ucnt
operator|--
operator|>
literal|0
condition|)
block|{
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RCSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|iack
operator|&
name|RCSR_Timeout
condition|)
break|break;
if|if
condition|(
operator|(
name|iack
operator|&
name|RCSR_OE
operator|)
operator|&&
operator|!
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_WAS_SILOVFL
operator|)
condition|)
block|{
name|rc
operator|->
name|rc_flags
operator||=
name|RC_WAS_SILOVFL
expr_stmt|;
name|sc
operator|->
name|sc_scheduled_event
operator|++
expr_stmt|;
block|}
name|val
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RDR
argument_list|)
expr_stmt|;
comment|/* 						  Don't store PE if IGNPAR and BREAK if IGNBRK, 						  this hack allows "raw" tty optimization 						  works even if IGN* is set. 						*/
if|if
condition|(
operator|!
operator|(
name|iack
operator|&
operator|(
name|RCSR_PE
operator||
name|RCSR_FE
operator||
name|RCSR_Break
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
operator|(
name|iack
operator|&
operator|(
name|RCSR_PE
operator||
name|RCSR_FE
operator|)
operator|)
operator|||
operator|!
operator|(
name|rc
operator|->
name|rc_tp
operator|->
name|t_iflag
operator|&
name|IGNPAR
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|iack
operator|&
name|RCSR_Break
operator|)
operator|||
operator|!
operator|(
name|rc
operator|->
name|rc_tp
operator|->
name|t_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|iack
operator|&
operator|(
name|RCSR_PE
operator||
name|RCSR_FE
operator|)
operator|)
operator|&&
operator|(
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
operator|)
operator|&&
operator|(
operator|(
name|iack
operator|&
name|RCSR_FE
operator|)
operator|||
operator|(
operator|(
name|iack
operator|&
name|RCSR_PE
operator|)
operator|&&
operator|(
name|rc
operator|->
name|rc_tp
operator|->
name|t_iflag
operator|&
name|INPCK
operator|)
operator|)
operator|)
condition|)
name|val
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|val
operator|==
name|rc
operator|->
name|rc_tp
operator|->
name|t_hotchar
condition|)
name|swi_sched
argument_list|(
name|sc
operator|->
name|sc_swicookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|optr
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|optr
index|[
name|INPUT_FLAGS_SHIFT
index|]
operator|=
name|iack
expr_stmt|;
name|optr
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_scheduled_event
operator|++
expr_stmt|;
block|}
block|}
block|}
name|rc
operator|->
name|rc_iptr
operator|=
name|optr
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator||=
name|RC_DORXFER
expr_stmt|;
block|}
else|else
name|resid
operator|=
name|ucnt
expr_stmt|;
comment|/* Clear FIFO if necessary */
while|while
condition|(
name|resid
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|good_data
condition|)
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RCSR
argument_list|)
expr_stmt|;
else|else
name|iack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iack
operator|&
name|RCSR_Timeout
condition|)
break|break;
operator|(
name|void
operator|)
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RDR
argument_list|)
expr_stmt|;
block|}
goto|goto
name|more_intrs
goto|;
block|}
if|if
condition|(
name|bsr
operator|&
name|RC_BSR_MOINT
condition|)
block|{
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_PILR_MODEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|iack
operator|!=
operator|(
name|GIVR_IT_MSCI
operator||
name|RC_FAKEID
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"fake moint: %02x\n"
argument_list|,
name|iack
argument_list|)
expr_stmt|;
goto|goto
name|more_intrs
goto|;
block|}
name|chan
operator|=
operator|(
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_GICR
argument_list|)
operator|&
name|GICR_CHAN
operator|)
operator|>>
name|GICR_LSH
operator|)
expr_stmt|;
name|rc
operator|=
operator|&
name|sc
operator|->
name|sc_channels
index|[
name|chan
index|]
expr_stmt|;
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_MCR
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_msvr
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RCDEBUG
name|printrcflags
argument_list|(
name|rc
argument_list|,
literal|"moint"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_CTSFLOW
condition|)
block|{
if|if
condition|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_CTS
condition|)
name|rc
operator|->
name|rc_flags
operator||=
name|RC_SEND_RDY
expr_stmt|;
else|else
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_SEND_RDY
expr_stmt|;
block|}
else|else
name|rc
operator|->
name|rc_flags
operator||=
name|RC_SEND_RDY
expr_stmt|;
if|if
condition|(
operator|(
name|iack
operator|&
name|MCR_CDchg
operator|)
operator|&&
operator|!
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_MODCHG
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_scheduled_event
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator||=
name|RC_MODCHG
expr_stmt|;
name|swi_sched
argument_list|(
name|sc
operator|->
name|sc_swicookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|more_intrs
goto|;
block|}
if|if
condition|(
name|bsr
operator|&
name|RC_BSR_TXINT
condition|)
block|{
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_PILR_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|iack
operator|!=
operator|(
name|GIVR_IT_TDI
operator||
name|RC_FAKEID
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"fake txint: %02x\n"
argument_list|,
name|iack
argument_list|)
expr_stmt|;
goto|goto
name|more_intrs
goto|;
block|}
name|chan
operator|=
operator|(
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_GICR
argument_list|)
operator|&
name|GICR_CHAN
operator|)
operator|>>
name|GICR_LSH
operator|)
expr_stmt|;
name|rc
operator|=
operator|&
name|sc
operator|->
name|sc_channels
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_OSUSP
operator|)
operator|||
operator|!
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_SEND_RDY
operator|)
condition|)
goto|goto
name|more_intrs
goto|;
comment|/* Handle breaks and other stuff */
if|if
condition|(
name|rc
operator|->
name|rc_pendcmd
condition|)
block|{
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_COR2
argument_list|,
name|rc
operator|->
name|rc_cor2
operator||=
name|COR2_ETC
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_TDR
argument_list|,
name|CD180_C_ESC
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_TDR
argument_list|,
name|rc
operator|->
name|rc_pendcmd
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_COR2
argument_list|,
name|rc
operator|->
name|rc_cor2
operator|&=
operator|~
name|COR2_ETC
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_pendcmd
operator|=
literal|0
expr_stmt|;
goto|goto
name|more_intrs
goto|;
block|}
name|optr
operator|=
name|rc
operator|->
name|rc_optr
expr_stmt|;
name|resid
operator|=
name|rc
operator|->
name|rc_obufend
operator|-
name|optr
expr_stmt|;
if|if
condition|(
name|resid
operator|>
name|CD180_NFIFO
condition|)
name|resid
operator|=
name|CD180_NFIFO
expr_stmt|;
while|while
condition|(
name|resid
operator|--
operator|>
literal|0
condition|)
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_TDR
argument_list|,
operator|*
name|optr
operator|++
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_optr
operator|=
name|optr
expr_stmt|;
comment|/* output completed? */
if|if
condition|(
name|optr
operator|>=
name|rc
operator|->
name|rc_obufend
condition|)
block|{
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_IER
argument_list|,
name|rc
operator|->
name|rc_ier
operator|&=
operator|~
name|IER_TxRdy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RCDEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"channel %d: output completed\n"
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_DOXXFER
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_scheduled_event
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator||=
name|RC_DOXXFER
expr_stmt|;
name|swi_sched
argument_list|(
name|sc
operator|->
name|sc_swicookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|more_intrs
label|:
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_EOIR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* end of interrupt */
name|rcout
argument_list|(
name|sc
argument_list|,
name|RC_CTOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bsr
operator|=
operator|~
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_BSR
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Feed characters to output buffer */
end_comment

begin_function
specifier|static
name|void
name|rc_start
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|rc
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_OSBUSY
condition|)
return|return;
name|sc
operator|=
name|rc
operator|->
name|rc_rcb
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator||=
name|RC_OSBUSY
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
condition|)
name|rc
operator|->
name|rc_flags
operator||=
name|RC_OSUSP
expr_stmt|;
else|else
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_OSUSP
expr_stmt|;
comment|/* Do RTS flow control stuff */
if|if
condition|(
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_RTSFLOW
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|&&
operator|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_RTS
operator|)
condition|)
block|{
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|,
name|rc
operator|->
name|rc_msvr
operator|&=
operator|~
name|MSVR_RTS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_RTS
operator|)
condition|)
block|{
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|,
name|rc
operator|->
name|rc_msvr
operator||=
name|MSVR_RTS
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
ifdef|#
directive|ifdef
name|RCDEBUG
name|printrcflags
argument_list|(
name|rc
argument_list|,
literal|"rcstart"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RCDEBUG
name|printf
argument_list|(
literal|"rcstart: outq = %d obuf = %d\n"
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
argument_list|,
name|rc
operator|->
name|rc_obufend
operator|-
name|rc
operator|->
name|rc_optr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
goto|goto
name|out
goto|;
comment|/* output still in progress ... */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
condition|)
block|{
name|u_int
name|ocnt
decl_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|ocnt
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|rc
operator|->
name|rc_obuf
argument_list|,
sizeof|sizeof
name|rc
operator|->
name|rc_obuf
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|rc
operator|->
name|rc_optr
operator|=
name|rc
operator|->
name|rc_obuf
expr_stmt|;
name|rc
operator|->
name|rc_obufend
operator|=
name|rc
operator|->
name|rc_optr
operator|+
name|ocnt
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rc
operator|->
name|rc_ier
operator|&
name|IER_TxRdy
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RCDEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"channel %d: rcstart enable txint\n"
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_IER
argument_list|,
name|rc
operator|->
name|rc_ier
operator||=
name|IER_TxRdy
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_OSBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle delayed events. */
end_comment

begin_function
name|void
name|rc_pollcard
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_char
modifier|*
name|tptr
decl_stmt|,
modifier|*
name|eptr
decl_stmt|;
name|int
name|chan
decl_stmt|,
name|icnt
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|rc_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_scheduled_event
operator|==
literal|0
condition|)
return|return;
do|do
block|{
name|rc
operator|=
name|sc
operator|->
name|sc_channels
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|CD180_NCHAN
condition|;
name|rc
operator|++
operator|,
name|chan
operator|++
control|)
block|{
name|tp
operator|=
name|rc
operator|->
name|rc_tp
expr_stmt|;
ifdef|#
directive|ifdef
name|RCDEBUG
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
operator|(
name|RC_DORXFER
operator||
name|RC_DOXXFER
operator||
name|RC_MODCHG
operator||
name|RC_WAS_BUFOVFL
operator||
name|RC_WAS_SILOVFL
operator|)
condition|)
name|printrcflags
argument_list|(
name|rc
argument_list|,
literal|"rcevent"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_WAS_BUFOVFL
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_WAS_BUFOVFL
expr_stmt|;
name|sc
operator|->
name|sc_scheduled_event
operator|--
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"channel %d: interrupt-level buffer overflow\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_WAS_SILOVFL
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_WAS_SILOVFL
expr_stmt|;
name|sc
operator|->
name|sc_scheduled_event
operator|--
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"channel %d: silo overflow\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_MODCHG
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_MODCHG
expr_stmt|;
name|sc
operator|->
name|sc_scheduled_event
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|ttyld_modem
argument_list|(
name|tp
argument_list|,
operator|!
operator|!
operator|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_CD
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_DORXFER
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_DORXFER
expr_stmt|;
name|eptr
operator|=
name|rc
operator|->
name|rc_iptr
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_bufend
operator|==
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
literal|2
operator|*
name|RC_IBUFSIZE
index|]
condition|)
name|tptr
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IBUFSIZE
index|]
expr_stmt|;
else|else
name|tptr
operator|=
name|rc
operator|->
name|rc_ibuf
expr_stmt|;
name|icnt
operator|=
name|eptr
operator|-
name|tptr
expr_stmt|;
if|if
condition|(
name|icnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|->
name|rc_bufend
operator|==
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
literal|2
operator|*
name|RC_IBUFSIZE
index|]
condition|)
block|{
name|rc
operator|->
name|rc_iptr
operator|=
name|rc
operator|->
name|rc_ibuf
expr_stmt|;
name|rc
operator|->
name|rc_bufend
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IBUFSIZE
index|]
expr_stmt|;
name|rc
operator|->
name|rc_hiwat
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IHIGHWATER
index|]
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|->
name|rc_iptr
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IBUFSIZE
index|]
expr_stmt|;
name|rc
operator|->
name|rc_bufend
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
literal|2
operator|*
name|RC_IBUFSIZE
index|]
expr_stmt|;
name|rc
operator|->
name|rc_hiwat
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IBUFSIZE
operator|+
name|RC_IHIGHWATER
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_RTSFLOW
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|&&
operator|!
operator|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_RTS
operator|)
condition|)
block|{
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|,
name|rc
operator|->
name|rc_msvr
operator||=
name|MSVR_RTS
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_scheduled_event
operator|-=
name|icnt
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|icnt
operator|<=
literal|0
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
goto|goto
name|done1
goto|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_LOCAL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|icnt
operator|)
operator|>=
name|RB_I_HIGH_WATER
operator|&&
operator|(
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_RTSFLOW
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
name|ttyblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tk_nin
operator|+=
name|icnt
expr_stmt|;
name|tk_rawcc
operator|+=
name|icnt
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|icnt
expr_stmt|;
if|if
condition|(
name|b_to_q
argument_list|(
name|tptr
argument_list|,
name|icnt
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"channel %d: tty-level buffer overflow\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXANY
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
name|rc_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
name|tptr
operator|<
name|eptr
condition|;
name|tptr
operator|++
control|)
name|ttyld_rint
argument_list|(
name|tp
argument_list|,
operator|(
name|tptr
index|[
literal|0
index|]
operator||
name|rc_rcsrt
index|[
name|tptr
index|[
name|INPUT_FLAGS_SHIFT
index|]
operator|&
literal|0xF
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|done1
label|:
empty_stmt|;
block|}
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_DOXXFER
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_scheduled_event
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_DOXXFER
expr_stmt|;
name|rc
operator|->
name|rc_tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|ttyld_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_scheduled_event
operator|==
literal|0
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|sc
operator|->
name|sc_scheduled_event
operator|>=
name|LOTS_OF_EVENTS
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|rc_stop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|u_char
modifier|*
name|tptr
decl_stmt|,
modifier|*
name|eptr
decl_stmt|;
name|rc
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|sc
operator|=
name|rc
operator|->
name|rc_rcb
expr_stmt|;
ifdef|#
directive|ifdef
name|RCDEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"channel %d: rc_stop %s%s\n"
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|,
operator|(
name|rw
operator|&
name|FWRITE
operator|)
condition|?
literal|"FWRITE "
else|:
literal|""
argument_list|,
operator|(
name|rw
operator|&
name|FREAD
operator|)
condition|?
literal|"FREAD"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
name|rc_discard_output
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|FREAD
condition|)
block|{
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_DORXFER
expr_stmt|;
name|eptr
operator|=
name|rc
operator|->
name|rc_iptr
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_bufend
operator|==
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
literal|2
operator|*
name|RC_IBUFSIZE
index|]
condition|)
block|{
name|tptr
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IBUFSIZE
index|]
expr_stmt|;
name|rc
operator|->
name|rc_iptr
operator|=
operator|&
name|rc
operator|->
name|rc_ibuf
index|[
name|RC_IBUFSIZE
index|]
expr_stmt|;
block|}
else|else
block|{
name|tptr
operator|=
name|rc
operator|->
name|rc_ibuf
expr_stmt|;
name|rc
operator|->
name|rc_iptr
operator|=
name|rc
operator|->
name|rc_ibuf
expr_stmt|;
block|}
name|sc
operator|->
name|sc_scheduled_event
operator|-=
name|eptr
operator|-
name|tptr
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
condition|)
name|rc
operator|->
name|rc_flags
operator||=
name|RC_OSUSP
expr_stmt|;
else|else
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_OSUSP
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rc_close
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|rc
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|sc
operator|=
name|rc
operator|->
name|rc_rcb
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
comment|/* Disable rx/tx intrs */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_IER
argument_list|,
name|rc
operator|->
name|rc_ier
operator|=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|)
operator|||
operator|(
operator|!
operator|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_ACTOUT
operator|)
operator|&&
operator|!
operator|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_CD
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|)
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|CCRCMD
argument_list|(
name|sc
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|,
name|CCR_ResetChan
argument_list|)
expr_stmt|;
name|WAITFORCCR
argument_list|(
name|sc
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rc_modem
argument_list|(
name|tp
argument_list|,
name|SER_RTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttydtrwaitstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_ACTOUT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|rc
operator|->
name|rc_rcb
argument_list|)
expr_stmt|;
comment|/* wake bi */
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the bastard */
end_comment

begin_function
specifier|static
name|void
name|rc_hwreset
parameter_list|(
name|struct
name|rc_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|chipid
parameter_list|)
block|{
name|CCRCMD
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|,
name|CCR_HWRESET
argument_list|)
expr_stmt|;
comment|/* Hardware reset */
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
name|WAITFORCCR
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|RC_CTOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear timeout  */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_GIVR
argument_list|,
name|chipid
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_GICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set Prescaler Registers (1 msec) */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_PPRL
argument_list|,
operator|(
operator|(
name|RC_OSCFREQ
operator|+
literal|999
operator|)
operator|/
literal|1000
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_PPRH
argument_list|,
operator|(
operator|(
name|RC_OSCFREQ
operator|+
literal|999
operator|)
operator|/
literal|1000
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Initialize Priority Interrupt Level Registers */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_PILR1
argument_list|,
name|RC_PILR_MODEM
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_PILR2
argument_list|,
name|RC_PILR_TX
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_PILR3
argument_list|,
name|RC_PILR_RX
argument_list|)
expr_stmt|;
comment|/* Reset DTR */
name|rcout
argument_list|(
name|sc
argument_list|,
name|RC_DTREG
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set channel parameters */
end_comment

begin_function
specifier|static
name|int
name|rc_param
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|int
name|idivs
decl_stmt|,
name|odivs
decl_stmt|,
name|s
decl_stmt|,
name|val
decl_stmt|,
name|cflag
decl_stmt|,
name|iflag
decl_stmt|,
name|lflag
decl_stmt|,
name|inpflow
decl_stmt|;
if|if
condition|(
name|ts
operator|->
name|c_ospeed
operator|<
literal|0
operator|||
name|ts
operator|->
name|c_ospeed
operator|>
literal|76800
operator|||
name|ts
operator|->
name|c_ispeed
operator|<
literal|0
operator|||
name|ts
operator|->
name|c_ispeed
operator|>
literal|76800
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ts
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|ts
operator|->
name|c_ispeed
operator|=
name|ts
operator|->
name|c_ospeed
expr_stmt|;
name|odivs
operator|=
name|RC_BRD
argument_list|(
name|ts
operator|->
name|c_ospeed
argument_list|)
expr_stmt|;
name|idivs
operator|=
name|RC_BRD
argument_list|(
name|ts
operator|->
name|c_ispeed
argument_list|)
expr_stmt|;
name|rc
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|sc
operator|=
name|rc
operator|->
name|rc_rcb
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Select channel */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
comment|/* If speed == 0, hangup line */
if|if
condition|(
name|ts
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
name|CCRCMD
argument_list|(
name|sc
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|,
name|CCR_ResetChan
argument_list|)
expr_stmt|;
name|WAITFORCCR
argument_list|(
name|sc
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rc_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_DTR
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
name|cflag
operator|=
name|ts
operator|->
name|c_cflag
expr_stmt|;
name|iflag
operator|=
name|ts
operator|->
name|c_iflag
expr_stmt|;
name|lflag
operator|=
name|ts
operator|->
name|c_lflag
expr_stmt|;
if|if
condition|(
name|idivs
operator|>
literal|0
condition|)
block|{
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_RBPRL
argument_list|,
name|idivs
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_RBPRH
argument_list|,
name|idivs
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|odivs
operator|>
literal|0
condition|)
block|{
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_TBPRL
argument_list|,
name|odivs
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_TBPRH
argument_list|,
name|odivs
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* set timeout value */
if|if
condition|(
name|ts
operator|->
name|c_ispeed
operator|>
literal|0
condition|)
block|{
name|int
name|itm
init|=
name|ts
operator|->
name|c_ispeed
operator|>
literal|2400
condition|?
literal|5
else|:
literal|10000
operator|/
name|ts
operator|->
name|c_ispeed
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|lflag
operator|&
name|ICANON
operator|)
operator|&&
name|ts
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|!=
literal|0
operator|&&
name|ts
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|!=
literal|0
operator|&&
name|ts
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
operator|>
name|itm
condition|)
name|itm
operator|=
name|ts
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_RTPR
argument_list|,
name|itm
operator|<=
literal|255
condition|?
name|itm
else|:
literal|255
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|val
operator|=
name|COR1_5BITS
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|val
operator|=
name|COR1_6BITS
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|val
operator|=
name|COR1_7BITS
expr_stmt|;
break|break;
default|default:
case|case
name|CS8
case|:
name|val
operator|=
name|COR1_8BITS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
name|val
operator||=
name|COR1_NORMPAR
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
name|val
operator||=
name|COR1_ODDP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cflag
operator|&
name|INPCK
operator|)
condition|)
name|val
operator||=
name|COR1_Ignore
expr_stmt|;
block|}
else|else
name|val
operator||=
name|COR1_Ignore
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
name|val
operator||=
name|COR1_2SB
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_COR1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set FIFO threshold */
name|val
operator|=
name|ts
operator|->
name|c_ospeed
operator|<=
literal|4800
condition|?
literal|1
else|:
name|CD180_NFIFO
operator|/
literal|2
expr_stmt|;
name|inpflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|iflag
operator|&
name|IXOFF
operator|)
operator|&&
operator|(
name|ts
operator|->
name|c_cc
index|[
name|VSTOP
index|]
operator|!=
name|_POSIX_VDISABLE
operator|&&
operator|(
name|ts
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|!=
name|_POSIX_VDISABLE
operator|||
operator|(
name|iflag
operator|&
name|IXANY
operator|)
operator|)
operator|)
condition|)
block|{
name|inpflow
operator|=
literal|1
expr_stmt|;
name|val
operator||=
name|COR3_SCDE
operator||
name|COR3_FCT
expr_stmt|;
block|}
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_COR3
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Initialize on-chip automatic flow control */
name|val
operator|=
literal|0
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
operator|(
name|RC_CTSFLOW
operator||
name|RC_SEND_RDY
operator|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
block|{
name|rc
operator|->
name|rc_flags
operator||=
name|RC_CTSFLOW
expr_stmt|;
name|val
operator||=
name|COR2_CtsAE
expr_stmt|;
block|}
else|else
name|rc
operator|->
name|rc_flags
operator||=
name|RC_SEND_RDY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
condition|)
name|rc
operator|->
name|rc_flags
operator||=
name|RC_OSUSP
expr_stmt|;
else|else
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_OSUSP
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
name|rc
operator|->
name|rc_flags
operator||=
name|RC_RTSFLOW
expr_stmt|;
else|else
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_RTSFLOW
expr_stmt|;
if|if
condition|(
name|inpflow
condition|)
block|{
if|if
condition|(
name|ts
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_SCHR1
argument_list|,
name|ts
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_SCHR2
argument_list|,
name|ts
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
name|val
operator||=
name|COR2_TxIBE
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXANY
condition|)
name|val
operator||=
name|COR2_IXM
expr_stmt|;
block|}
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_COR2
argument_list|,
name|rc
operator|->
name|rc_cor2
operator|=
name|val
argument_list|)
expr_stmt|;
name|CCRCMD
argument_list|(
name|sc
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|,
name|CCR_CORCHG1
operator||
name|CCR_CORCHG2
operator||
name|CCR_CORCHG3
argument_list|)
expr_stmt|;
name|ttyldoptim
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* modem ctl */
name|val
operator|=
name|cflag
operator|&
name|CLOCAL
condition|?
literal|0
else|:
name|MCOR1_CDzd
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|val
operator||=
name|MCOR1_CTSzd
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MCOR1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|cflag
operator|&
name|CLOCAL
condition|?
literal|0
else|:
name|MCOR2_CDod
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|val
operator||=
name|MCOR2_CTSod
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MCOR2
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* enable i/o and interrupts */
name|CCRCMD
argument_list|(
name|sc
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|,
name|CCR_XMTREN
operator||
operator|(
operator|(
name|cflag
operator|&
name|CREAD
operator|)
condition|?
name|CCR_RCVREN
else|:
name|CCR_RCVRDIS
operator|)
argument_list|)
expr_stmt|;
name|WAITFORCCR
argument_list|(
name|sc
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_ier
operator|=
name|cflag
operator|&
name|CLOCAL
condition|?
literal|0
else|:
name|IER_CD
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|rc
operator|->
name|rc_ier
operator||=
name|IER_CTS
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CREAD
condition|)
name|rc
operator|->
name|rc_ier
operator||=
name|IER_RxData
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
name|rc
operator|->
name|rc_ier
operator||=
name|IER_TxRdy
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|rc_modem
argument_list|(
name|tp
argument_list|,
name|SER_DTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CCTS_OFLOW
operator|)
operator|&&
operator|(
name|rc
operator|->
name|rc_msvr
operator|&
name|MSVR_CTS
operator|)
condition|)
name|rc
operator|->
name|rc_flags
operator||=
name|RC_SEND_RDY
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_IER
argument_list|,
name|rc
operator|->
name|rc_ier
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Re-initialize board after bogus interrupts */
end_comment

begin_function
specifier|static
name|void
name|rc_reinit
parameter_list|(
name|struct
name|rc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rc_hwreset
argument_list|(
name|sc
argument_list|,
name|RC_FAKEID
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sc
operator|->
name|sc_channels
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CD180_NCHAN
condition|;
name|i
operator|++
operator|,
name|rc
operator|++
control|)
operator|(
name|void
operator|)
name|rc_param
argument_list|(
name|rc
operator|->
name|rc_tp
argument_list|,
operator|&
name|rc
operator|->
name|rc_tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Modem control routines */
end_comment

begin_function
specifier|static
name|int
name|rc_modem
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|biton
parameter_list|,
name|int
name|bitoff
parameter_list|)
block|{
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
modifier|*
name|dtr
decl_stmt|;
name|u_char
name|msvr
decl_stmt|;
name|rc
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|sc
operator|=
name|rc
operator|->
name|rc_rcb
expr_stmt|;
name|dtr
operator|=
operator|&
name|sc
operator|->
name|sc_dtr
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|biton
operator|==
literal|0
operator|&&
name|bitoff
operator|==
literal|0
condition|)
block|{
name|msvr
operator|=
name|rc
operator|->
name|rc_msvr
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|)
expr_stmt|;
if|if
condition|(
name|msvr
operator|&
name|MSVR_RTS
condition|)
name|biton
operator||=
name|SER_RTS
expr_stmt|;
if|if
condition|(
name|msvr
operator|&
name|MSVR_CTS
condition|)
name|biton
operator||=
name|SER_CTS
expr_stmt|;
if|if
condition|(
name|msvr
operator|&
name|MSVR_DSR
condition|)
name|biton
operator||=
name|SER_DSR
expr_stmt|;
if|if
condition|(
name|msvr
operator|&
name|MSVR_DTR
condition|)
name|biton
operator||=
name|SER_DTR
expr_stmt|;
if|if
condition|(
name|msvr
operator|&
name|MSVR_CD
condition|)
name|biton
operator||=
name|SER_DCD
expr_stmt|;
if|if
condition|(
operator|~
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_RIREG
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|rc
operator|->
name|rc_chan
operator|)
condition|)
name|biton
operator||=
name|SER_RI
expr_stmt|;
return|return
name|biton
return|;
block|}
if|if
condition|(
name|biton
operator|&
name|SER_DTR
condition|)
name|rcout
argument_list|(
name|sc
argument_list|,
name|RC_DTREG
argument_list|,
operator|~
operator|(
operator|*
name|dtr
operator||=
literal|1
operator|<<
name|rc
operator|->
name|rc_chan
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitoff
operator|&
name|SER_DTR
condition|)
name|rcout
argument_list|(
name|sc
argument_list|,
name|RC_DTREG
argument_list|,
operator|~
operator|(
operator|*
name|dtr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|rc
operator|->
name|rc_chan
operator|)
operator|)
argument_list|)
expr_stmt|;
name|msvr
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|)
expr_stmt|;
if|if
condition|(
name|biton
operator|&
name|SER_DTR
condition|)
name|msvr
operator||=
name|MSVR_DTR
expr_stmt|;
if|if
condition|(
name|bitoff
operator|&
name|SER_DTR
condition|)
name|msvr
operator|&=
operator|~
name|MSVR_DTR
expr_stmt|;
if|if
condition|(
name|biton
operator|&
name|SER_RTS
condition|)
name|msvr
operator||=
name|MSVR_RTS
expr_stmt|;
if|if
condition|(
name|bitoff
operator|&
name|SER_RTS
condition|)
name|msvr
operator|&=
operator|~
name|MSVR_RTS
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|,
name|msvr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rc_break
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|brk
parameter_list|)
block|{
name|struct
name|rc_chans
modifier|*
name|rc
decl_stmt|;
name|rc
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|brk
condition|)
name|rc
operator|->
name|rc_pendcmd
operator|=
name|CD180_C_SBRK
expr_stmt|;
else|else
name|rc
operator|->
name|rc_pendcmd
operator|=
name|CD180_C_EBRK
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|s
parameter_list|)
value|do {							\ 	device_printf(sc->sc_dev, "%s", "");				\ 	printf s ;							\ 	printf("\n");							\ 	(void) splx(old_level);						\ 	return 1;							\ } while (0)
end_define

begin_comment
comment|/* Test the board. */
end_comment

begin_function
name|int
name|rc_test
parameter_list|(
name|struct
name|rc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|chan
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|rcnt
decl_stmt|,
name|old_level
decl_stmt|;
name|unsigned
name|int
name|iack
decl_stmt|,
name|chipid
decl_stmt|;
name|unsigned
name|short
name|divs
decl_stmt|;
specifier|static
name|u_char
name|ctest
index|[]
init|=
literal|"\377\125\252\045\244\0\377"
decl_stmt|;
define|#
directive|define
name|CTLEN
value|8
struct|struct
name|rtest
block|{
name|u_char
name|txbuf
index|[
name|CD180_NFIFO
index|]
decl_stmt|;
comment|/* TX buffer  */
name|u_char
name|rxbuf
index|[
name|CD180_NFIFO
index|]
decl_stmt|;
comment|/* RX buffer  */
name|int
name|rxptr
decl_stmt|;
comment|/* RX pointer */
name|int
name|txptr
decl_stmt|;
comment|/* TX pointer */
block|}
name|tchans
index|[
name|CD180_NCHAN
index|]
struct|;
name|old_level
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chipid
operator|=
name|RC_FAKEID
expr_stmt|;
comment|/* First, reset board to inital state */
name|rc_hwreset
argument_list|(
name|sc
argument_list|,
name|chipid
argument_list|)
expr_stmt|;
name|divs
operator|=
name|RC_BRD
argument_list|(
literal|19200
argument_list|)
expr_stmt|;
comment|/* Initialize channels */
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|CD180_NCHAN
condition|;
name|chan
operator|++
control|)
block|{
comment|/* Select and reset channel */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|CCRCMD
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|CCR_ResetChan
argument_list|)
expr_stmt|;
name|WAITFORCCR
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Set speed */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_RBPRL
argument_list|,
name|divs
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_RBPRH
argument_list|,
name|divs
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_TBPRL
argument_list|,
name|divs
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_TBPRH
argument_list|,
name|divs
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set timeout value */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_RTPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Establish local loopback */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_COR1
argument_list|,
name|COR1_NOPAR
operator||
name|COR1_8BITS
operator||
name|COR1_1SB
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_COR2
argument_list|,
name|COR2_LLM
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_COR3
argument_list|,
name|CD180_NFIFO
argument_list|)
expr_stmt|;
name|CCRCMD
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|CCR_CORCHG1
operator||
name|CCR_CORCHG2
operator||
name|CCR_CORCHG3
argument_list|)
expr_stmt|;
name|CCRCMD
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|CCR_RCVREN
operator||
name|CCR_XMTREN
argument_list|)
expr_stmt|;
name|WAITFORCCR
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|,
name|MSVR_RTS
argument_list|)
expr_stmt|;
comment|/* Fill TXBUF with test data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CD180_NFIFO
condition|;
name|i
operator|++
control|)
block|{
name|tchans
index|[
name|chan
index|]
operator|.
name|txbuf
index|[
name|i
index|]
operator|=
name|ctest
index|[
name|i
index|]
expr_stmt|;
name|tchans
index|[
name|chan
index|]
operator|.
name|rxbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|tchans
index|[
name|chan
index|]
operator|.
name|txptr
operator|=
name|tchans
index|[
name|chan
index|]
operator|.
name|rxptr
operator|=
literal|0
expr_stmt|;
comment|/* Now, start transmit */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_IER
argument_list|,
name|IER_TxMpty
operator||
name|IER_RxData
argument_list|)
expr_stmt|;
block|}
comment|/* Pseudo-interrupt poll stuff */
for|for
control|(
name|rcnt
operator|=
literal|10000
init|;
name|rcnt
operator|--
operator|>
literal|0
condition|;
name|rcnt
operator|--
control|)
block|{
name|i
operator|=
operator|~
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_BSR
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|RC_BSR_TOUT
condition|)
name|ERR
argument_list|(
operator|(
literal|"BSR timeout bit set\n"
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|&
name|RC_BSR_TXINT
condition|)
block|{
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_PILR_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|iack
operator|!=
operator|(
name|GIVR_IT_TDI
operator||
name|chipid
operator|)
condition|)
name|ERR
argument_list|(
operator|(
literal|"Bad TX intr ack (%02x != %02x)\n"
operator|,
name|iack
operator|,
name|GIVR_IT_TDI
operator||
name|chipid
operator|)
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_GICR
argument_list|)
operator|&
name|GICR_CHAN
operator|)
operator|>>
name|GICR_LSH
expr_stmt|;
comment|/* If no more data to transmit, disable TX intr */
if|if
condition|(
name|tchans
index|[
name|chan
index|]
operator|.
name|txptr
operator|>=
name|CD180_NFIFO
condition|)
block|{
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_IER
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_IER
argument_list|,
name|iack
operator|&
operator|~
name|IER_TxMpty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|iack
operator|=
name|tchans
index|[
name|chan
index|]
operator|.
name|txptr
init|;
name|iack
operator|<
name|CD180_NFIFO
condition|;
name|iack
operator|++
control|)
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_TDR
argument_list|,
name|tchans
index|[
name|chan
index|]
operator|.
name|txbuf
index|[
name|iack
index|]
argument_list|)
expr_stmt|;
name|tchans
index|[
name|chan
index|]
operator|.
name|txptr
operator|=
name|iack
expr_stmt|;
block|}
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_EOIR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|&
name|RC_BSR_RXINT
condition|)
block|{
name|u_char
name|ucnt
decl_stmt|;
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|RC_PILR_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|iack
operator|!=
operator|(
name|GIVR_IT_RGDI
operator||
name|chipid
operator|)
operator|&&
name|iack
operator|!=
operator|(
name|GIVR_IT_REI
operator||
name|chipid
operator|)
condition|)
name|ERR
argument_list|(
operator|(
literal|"Bad RX intr ack (%02x != %02x)\n"
operator|,
name|iack
operator|,
name|GIVR_IT_RGDI
operator||
name|chipid
operator|)
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|(
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_GICR
argument_list|)
operator|&
name|GICR_CHAN
operator|)
operator|>>
name|GICR_LSH
expr_stmt|;
name|ucnt
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RDCR
argument_list|)
operator|&
literal|0xF
expr_stmt|;
while|while
condition|(
name|ucnt
operator|--
operator|>
literal|0
condition|)
block|{
name|iack
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RCSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|iack
operator|&
name|RCSR_Timeout
condition|)
break|break;
if|if
condition|(
name|iack
operator|&
literal|0xF
condition|)
name|ERR
argument_list|(
operator|(
literal|"Bad char chan %d (RCSR = %02X)\n"
operator|,
name|chan
operator|,
name|iack
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tchans
index|[
name|chan
index|]
operator|.
name|rxptr
operator|>
name|CD180_NFIFO
condition|)
name|ERR
argument_list|(
operator|(
literal|"Got extra chars chan %d\n"
operator|,
name|chan
operator|)
argument_list|)
expr_stmt|;
name|tchans
index|[
name|chan
index|]
operator|.
name|rxbuf
index|[
name|tchans
index|[
name|chan
index|]
operator|.
name|rxptr
operator|++
index|]
operator|=
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_RDR
argument_list|)
expr_stmt|;
block|}
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_EOIR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rcout
argument_list|(
name|sc
argument_list|,
name|RC_CTOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|iack
operator|=
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|CD180_NCHAN
condition|;
name|chan
operator|++
control|)
if|if
condition|(
name|tchans
index|[
name|chan
index|]
operator|.
name|rxptr
operator|>=
name|CD180_NFIFO
condition|)
name|iack
operator|++
expr_stmt|;
if|if
condition|(
name|iack
operator|==
name|CD180_NCHAN
condition|)
break|break;
block|}
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|CD180_NCHAN
condition|;
name|chan
operator|++
control|)
block|{
comment|/* Select and reset channel */
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|CCRCMD
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|CCR_ResetChan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rcnt
condition|)
name|ERR
argument_list|(
operator|(
literal|"looses characters during local loopback\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Now, check data */
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|CD180_NCHAN
condition|;
name|chan
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CD180_NFIFO
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ctest
index|[
name|i
index|]
operator|!=
name|tchans
index|[
name|chan
index|]
operator|.
name|rxbuf
index|[
name|i
index|]
condition|)
name|ERR
argument_list|(
operator|(
literal|"data mismatch chan %d ptr %d (%d != %d)\n"
operator|,
name|chan
operator|,
name|i
operator|,
name|ctest
index|[
name|i
index|]
operator|,
name|tchans
index|[
name|chan
index|]
operator|.
name|rxbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|old_level
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RCDEBUG
end_ifdef

begin_function
specifier|static
name|void
name|printrcflags
parameter_list|(
name|struct
name|rc_chans
modifier|*
name|rc
parameter_list|,
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|struct
name|rc_softc
modifier|*
name|sc
decl_stmt|;
name|u_short
name|f
init|=
name|rc
operator|->
name|rc_flags
decl_stmt|;
name|sc
operator|=
name|rc
operator|->
name|rc_rcb
expr_stmt|;
name|printf
argument_list|(
literal|"rc%d/%d: %s flags: %s%s%s%s%s%s%s%s%s%s%s%s\n"
argument_list|,
name|rc
operator|->
name|rc_rcb
operator|->
name|rcb_unit
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|,
name|comment
argument_list|,
operator|(
name|f
operator|&
name|RC_DTR_OFF
operator|)
condition|?
literal|"DTR_OFF "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_ACTOUT
operator|)
condition|?
literal|"ACTOUT "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_RTSFLOW
operator|)
condition|?
literal|"RTSFLOW "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_CTSFLOW
operator|)
condition|?
literal|"CTSFLOW "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_DORXFER
operator|)
condition|?
literal|"DORXFER "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_DOXXFER
operator|)
condition|?
literal|"DOXXFER "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_MODCHG
operator|)
condition|?
literal|"MODCHG "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_OSUSP
operator|)
condition|?
literal|"OSUSP "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_OSBUSY
operator|)
condition|?
literal|"OSBUSY "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_WAS_BUFOVFL
operator|)
condition|?
literal|"BUFOVFL "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_WAS_SILOVFL
operator|)
condition|?
literal|"SILOVFL "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
name|RC_SEND_RDY
operator|)
condition|?
literal|"SEND_RDY"
else|:
literal|""
argument_list|)
expr_stmt|;
name|rcout
argument_list|(
name|sc
argument_list|,
name|CD180_CAR
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rc%d/%d: msvr %02x ier %02x ccsr %02x\n"
argument_list|,
name|rc
operator|->
name|rc_rcb
operator|->
name|rcb_unit
argument_list|,
name|rc
operator|->
name|rc_chan
argument_list|,
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_MSVR
argument_list|)
argument_list|,
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_IER
argument_list|)
argument_list|,
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_CCSR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RCDEBUG */
end_comment

begin_function
specifier|static
name|void
name|rc_discard_output
parameter_list|(
name|struct
name|rc_chans
modifier|*
name|rc
parameter_list|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_flags
operator|&
name|RC_DOXXFER
condition|)
block|{
name|rc
operator|->
name|rc_rcb
operator|->
name|sc_scheduled_event
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|rc
operator|->
name|rc_flags
operator|&=
operator|~
name|RC_DOXXFER
expr_stmt|;
block|}
name|rc
operator|->
name|rc_optr
operator|=
name|rc
operator|->
name|rc_obufend
expr_stmt|;
name|rc
operator|->
name|rc_tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|ttwwakeup
argument_list|(
name|rc
operator|->
name|rc_tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rc_wait0
parameter_list|(
name|struct
name|rc_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chan
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|rcnt
decl_stmt|;
for|for
control|(
name|rcnt
operator|=
literal|50
init|;
name|rcnt
operator|&&
name|rcin
argument_list|(
name|sc
argument_list|,
name|CD180_CCR
argument_list|)
condition|;
name|rcnt
operator|--
control|)
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcnt
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"channel %d command timeout, rc.c line: %d\n"
argument_list|,
name|chan
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|rc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|rc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|rc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|rc_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|rc_driver
init|=
block|{
literal|"rc"
block|,
name|rc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|rc
argument_list|,
name|isa
argument_list|,
name|rc_driver
argument_list|,
name|rc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

