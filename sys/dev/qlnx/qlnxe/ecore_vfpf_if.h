begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__ECORE_VF_PF_IF_H__
end_ifndef

begin_define
define|#
directive|define
name|__ECORE_VF_PF_IF_H__
end_define

begin_define
define|#
directive|define
name|T_ETH_INDIRECTION_TABLE_SIZE
value|128
end_define

begin_comment
comment|/* @@@ TBD MichalK this should be HSI? */
end_comment

begin_define
define|#
directive|define
name|T_ETH_RSS_KEY_SIZE
value|10
end_define

begin_comment
comment|/* @@@ TBD this should be HSI? */
end_comment

begin_define
define|#
directive|define
name|ETH_ALEN
value|6
end_define

begin_comment
comment|/* @@@ TBD MichalK - should this be defined here?*/
end_comment

begin_comment
comment|/***********************************************  *  * Common definitions for all HVs  *  **/
end_comment

begin_struct
struct|struct
name|vf_pf_resc_request
block|{
name|u8
name|num_rxqs
decl_stmt|;
name|u8
name|num_txqs
decl_stmt|;
name|u8
name|num_sbs
decl_stmt|;
name|u8
name|num_mac_filters
decl_stmt|;
name|u8
name|num_vlan_filters
decl_stmt|;
name|u8
name|num_mc_filters
decl_stmt|;
comment|/* No limit  so superfluous */
name|u8
name|num_cids
decl_stmt|;
name|u8
name|padding
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hw_sb_info
block|{
name|u16
name|hw_sb_id
decl_stmt|;
comment|/* aka absolute igu id, used to ack the sb */
name|u8
name|sb_qid
decl_stmt|;
comment|/* used to update DHC for sb */
name|u8
name|padding
index|[
literal|5
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/***********************************************  *  * HW VF-PF channel definitions  *  * A.K.A VF-PF mailbox  *  **/
end_comment

begin_define
define|#
directive|define
name|TLV_BUFFER_SIZE
value|1024
end_define

begin_comment
comment|/* vf pf channel tlvs */
end_comment

begin_comment
comment|/* general tlv header (used for both vf->pf request and pf->vf response) */
end_comment

begin_struct
struct|struct
name|channel_tlv
block|{
name|u16
name|type
decl_stmt|;
name|u16
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* header of first vf->pf tlv carries the offset used to calculate reponse  * buffer address  */
end_comment

begin_struct
struct|struct
name|vfpf_first_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u32
name|padding
decl_stmt|;
name|u64
name|reply_address
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* header of pf->vf tlvs, carries the status of handling the request */
end_comment

begin_struct
struct|struct
name|pfvf_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|u8
name|padding
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* response tlv used for most tlvs */
end_comment

begin_struct
struct|struct
name|pfvf_def_resp_tlv
block|{
name|struct
name|pfvf_tlv
name|hdr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* used to terminate and pad a tlv list */
end_comment

begin_struct
struct|struct
name|channel_list_end_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|padding
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Acquire */
end_comment

begin_struct
struct|struct
name|vfpf_acquire_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
struct|struct
name|vf_pf_vfdev_info
block|{
comment|/* First bit was used on 8.7.x and 8.8.x versions, which had different 	 * FWs used but with the same faspath HSI. As this was prior to the 	 * fastpath versioning, wanted to have ability to override fw matching 	 * and allow them to interact. 	 */
define|#
directive|define
name|VFPF_ACQUIRE_CAP_PRE_FP_HSI
value|(1<< 0)
comment|/* VF pre-FP hsi version */
define|#
directive|define
name|VFPF_ACQUIRE_CAP_100G
value|(1<< 1)
comment|/* VF can support 100g */
comment|/* A requirement for supporting multi-Tx queues on a single queue-zone, 	 * VF would pass qids as additional information whenever passing queue 	 * references. 	 * TODO - due to the CID limitations in Bar0, VFs currently don't pass 	 * this, and use the legacy CID scheme. 	 */
define|#
directive|define
name|VFPF_ACQUIRE_CAP_QUEUE_QIDS
value|(1<< 2)
name|u64
name|capabilities
decl_stmt|;
name|u8
name|fw_major
decl_stmt|;
name|u8
name|fw_minor
decl_stmt|;
name|u8
name|fw_revision
decl_stmt|;
name|u8
name|fw_engineering
decl_stmt|;
name|u32
name|driver_version
decl_stmt|;
name|u16
name|opaque_fid
decl_stmt|;
comment|/* ME register value */
name|u8
name|os_type
decl_stmt|;
comment|/* VFPF_ACQUIRE_OS_* value */
name|u8
name|eth_fp_hsi_major
decl_stmt|;
name|u8
name|eth_fp_hsi_minor
decl_stmt|;
name|u8
name|padding
index|[
literal|3
index|]
decl_stmt|;
block|}
name|vfdev_info
struct|;
name|struct
name|vf_pf_resc_request
name|resc_request
decl_stmt|;
name|u64
name|bulletin_addr
decl_stmt|;
name|u32
name|bulletin_size
decl_stmt|;
name|u32
name|padding
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* receive side scaling tlv */
end_comment

begin_struct
struct|struct
name|vfpf_vport_update_rss_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|update_rss_flags
decl_stmt|;
define|#
directive|define
name|VFPF_UPDATE_RSS_CONFIG_FLAG
value|(1<< 0)
define|#
directive|define
name|VFPF_UPDATE_RSS_CAPS_FLAG
value|(1<< 1)
define|#
directive|define
name|VFPF_UPDATE_RSS_IND_TABLE_FLAG
value|(1<< 2)
define|#
directive|define
name|VFPF_UPDATE_RSS_KEY_FLAG
value|(1<< 3)
name|u8
name|rss_enable
decl_stmt|;
name|u8
name|rss_caps
decl_stmt|;
name|u8
name|rss_table_size_log
decl_stmt|;
comment|/* The table size is 2 ^ rss_table_size_log */
name|u16
name|rss_ind_table
index|[
name|T_ETH_INDIRECTION_TABLE_SIZE
index|]
decl_stmt|;
name|u32
name|rss_key
index|[
name|T_ETH_RSS_KEY_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pfvf_storm_stats
block|{
name|u32
name|address
decl_stmt|;
name|u32
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pfvf_stats_info
block|{
name|struct
name|pfvf_storm_stats
name|mstats
decl_stmt|;
name|struct
name|pfvf_storm_stats
name|pstats
decl_stmt|;
name|struct
name|pfvf_storm_stats
name|tstats
decl_stmt|;
name|struct
name|pfvf_storm_stats
name|ustats
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* acquire response tlv - carries the allocated resources */
end_comment

begin_struct
struct|struct
name|pfvf_acquire_resp_tlv
block|{
name|struct
name|pfvf_tlv
name|hdr
decl_stmt|;
struct|struct
name|pf_vf_pfdev_info
block|{
name|u32
name|chip_num
decl_stmt|;
name|u32
name|mfw_ver
decl_stmt|;
name|u16
name|fw_major
decl_stmt|;
name|u16
name|fw_minor
decl_stmt|;
name|u16
name|fw_rev
decl_stmt|;
name|u16
name|fw_eng
decl_stmt|;
name|u64
name|capabilities
decl_stmt|;
define|#
directive|define
name|PFVF_ACQUIRE_CAP_DEFAULT_UNTAGGED
value|(1<< 0)
define|#
directive|define
name|PFVF_ACQUIRE_CAP_100G
value|(1<< 1)
comment|/* If set, 100g PF */
comment|/* There are old PF versions where the PF might mistakenly override the sanity  * mechanism [version-based] and allow a VF that can't be supported to pass  * the acquisition phase.  * To overcome this, PFs now indicate that they're past that point and the new  * VFs would fail probe on the older PFs that fail to do so.  */
define|#
directive|define
name|PFVF_ACQUIRE_CAP_POST_FW_OVERRIDE
value|(1<< 2)
comment|/* PF expects queues to be received with additional qids */
define|#
directive|define
name|PFVF_ACQUIRE_CAP_QUEUE_QIDS
value|(1<< 3)
name|u16
name|db_size
decl_stmt|;
name|u8
name|indices_per_sb
decl_stmt|;
name|u8
name|os_type
decl_stmt|;
comment|/* These should match the PF's ecore_dev values */
name|u16
name|chip_rev
decl_stmt|;
name|u8
name|dev_type
decl_stmt|;
name|u8
name|padding
decl_stmt|;
name|struct
name|pfvf_stats_info
name|stats_info
decl_stmt|;
name|u8
name|port_mac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
comment|/* It's possible PF had to configure an older fastpath HSI 		 * [in case VF is newer than PF]. This is communicated back 		 * to the VF. It can also be used in case of error due to 		 * non-matching versions to shed light in VF about failure. 		 */
name|u8
name|major_fp_hsi
decl_stmt|;
name|u8
name|minor_fp_hsi
decl_stmt|;
block|}
name|pfdev_info
struct|;
struct|struct
name|pf_vf_resc
block|{
comment|/* in case of status NO_RESOURCE in message hdr, pf will fill 		 * this struct with suggested amount of resources for next 		 * acquire request 		 */
define|#
directive|define
name|PFVF_MAX_QUEUES_PER_VF
value|16
define|#
directive|define
name|PFVF_MAX_SBS_PER_VF
value|16
name|struct
name|hw_sb_info
name|hw_sbs
index|[
name|PFVF_MAX_SBS_PER_VF
index|]
decl_stmt|;
name|u8
name|hw_qid
index|[
name|PFVF_MAX_QUEUES_PER_VF
index|]
decl_stmt|;
name|u8
name|cid
index|[
name|PFVF_MAX_QUEUES_PER_VF
index|]
decl_stmt|;
name|u8
name|num_rxqs
decl_stmt|;
name|u8
name|num_txqs
decl_stmt|;
name|u8
name|num_sbs
decl_stmt|;
name|u8
name|num_mac_filters
decl_stmt|;
name|u8
name|num_vlan_filters
decl_stmt|;
name|u8
name|num_mc_filters
decl_stmt|;
name|u8
name|num_cids
decl_stmt|;
name|u8
name|padding
decl_stmt|;
block|}
name|resc
struct|;
name|u32
name|bulletin_size
decl_stmt|;
name|u32
name|padding
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pfvf_start_queue_resp_tlv
block|{
name|struct
name|pfvf_tlv
name|hdr
decl_stmt|;
name|u32
name|offset
decl_stmt|;
comment|/* offset to consumer/producer of queue */
name|u8
name|padding
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Extended queue information - additional index for reference inside qzone.  * If commmunicated between VF/PF, each TLV relating to queues should be  * extended by one such [or have a future base TLV that already contains info].  */
end_comment

begin_struct
struct|struct
name|vfpf_qid_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|qid
decl_stmt|;
name|u8
name|padding
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Setup Queue */
end_comment

begin_struct
struct|struct
name|vfpf_start_rxq_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
comment|/* physical addresses */
name|u64
name|rxq_addr
decl_stmt|;
name|u64
name|deprecated_sge_addr
decl_stmt|;
name|u64
name|cqe_pbl_addr
decl_stmt|;
name|u16
name|cqe_pbl_size
decl_stmt|;
name|u16
name|hw_sb
decl_stmt|;
name|u16
name|rx_qid
decl_stmt|;
name|u16
name|hc_rate
decl_stmt|;
comment|/* desired interrupts per sec. */
name|u16
name|bd_max_bytes
decl_stmt|;
name|u16
name|stat_id
decl_stmt|;
name|u8
name|sb_index
decl_stmt|;
name|u8
name|padding
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_start_txq_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
comment|/* physical addresses */
name|u64
name|pbl_addr
decl_stmt|;
name|u16
name|pbl_size
decl_stmt|;
name|u16
name|stat_id
decl_stmt|;
name|u16
name|tx_qid
decl_stmt|;
name|u16
name|hw_sb
decl_stmt|;
name|u32
name|flags
decl_stmt|;
comment|/* VFPF_QUEUE_FLG_X flags */
name|u16
name|hc_rate
decl_stmt|;
comment|/* desired interrupts per sec. */
name|u8
name|sb_index
decl_stmt|;
name|u8
name|padding
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Stop RX Queue */
end_comment

begin_struct
struct|struct
name|vfpf_stop_rxqs_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
name|u16
name|rx_qid
decl_stmt|;
comment|/* While the API supports multiple Rx-queues on a single TLV 	 * message, in practice older VFs always used it as one [ecore]. 	 * And there are PFs [starting with the CHANNEL_TLV_QID] which 	 * would start assuming this is always a '1'. So in practice this 	 * field should be considered deprecated and *Always* set to '1'. 	 */
name|u8
name|num_rxqs
decl_stmt|;
name|u8
name|cqe_completion
decl_stmt|;
name|u8
name|padding
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Stop TX Queues */
end_comment

begin_struct
struct|struct
name|vfpf_stop_txqs_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
name|u16
name|tx_qid
decl_stmt|;
comment|/* While the API supports multiple Tx-queues on a single TLV 	 * message, in practice older VFs always used it as one [ecore]. 	 * And there are PFs [starting with the CHANNEL_TLV_QID] which 	 * would start assuming this is always a '1'. So in practice this 	 * field should be considered deprecated and *Always* set to '1'. 	 */
name|u8
name|num_txqs
decl_stmt|;
name|u8
name|padding
index|[
literal|5
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_update_rxq_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
name|u64
name|deprecated_sge_addr
index|[
name|PFVF_MAX_QUEUES_PER_VF
index|]
decl_stmt|;
name|u16
name|rx_qid
decl_stmt|;
name|u8
name|num_rxqs
decl_stmt|;
name|u8
name|flags
decl_stmt|;
define|#
directive|define
name|VFPF_RXQ_UPD_INIT_SGE_DEPRECATE_FLAG
value|(1<< 0)
define|#
directive|define
name|VFPF_RXQ_UPD_COMPLETE_CQE_FLAG
value|(1<< 1)
define|#
directive|define
name|VFPF_RXQ_UPD_COMPLETE_EVENT_FLAG
value|(1<< 2)
name|u8
name|padding
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Set Queue Filters */
end_comment

begin_struct
struct|struct
name|vfpf_q_mac_vlan_filter
block|{
name|u32
name|flags
decl_stmt|;
define|#
directive|define
name|VFPF_Q_FILTER_DEST_MAC_VALID
value|0x01
define|#
directive|define
name|VFPF_Q_FILTER_VLAN_TAG_VALID
value|0x02
define|#
directive|define
name|VFPF_Q_FILTER_SET_MAC
value|0x100
comment|/* set/clear */
name|u8
name|mac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|u16
name|vlan_tag
decl_stmt|;
name|u8
name|padding
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Start a vport */
end_comment

begin_struct
struct|struct
name|vfpf_vport_start_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
name|u64
name|sb_addr
index|[
name|PFVF_MAX_SBS_PER_VF
index|]
decl_stmt|;
name|u32
name|tpa_mode
decl_stmt|;
name|u16
name|dep1
decl_stmt|;
name|u16
name|mtu
decl_stmt|;
name|u8
name|vport_id
decl_stmt|;
name|u8
name|inner_vlan_removal
decl_stmt|;
name|u8
name|only_untagged
decl_stmt|;
name|u8
name|max_buffers_per_cqe
decl_stmt|;
name|u8
name|padding
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Extended tlvs - need to add rss, mcast, accept mode tlvs */
end_comment

begin_struct
struct|struct
name|vfpf_vport_update_activate_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|update_rx
decl_stmt|;
name|u8
name|update_tx
decl_stmt|;
name|u8
name|active_rx
decl_stmt|;
name|u8
name|active_tx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_vport_update_tx_switch_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|tx_switching
decl_stmt|;
name|u8
name|padding
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_vport_update_vlan_strip_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|remove_vlan
decl_stmt|;
name|u8
name|padding
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_vport_update_mcast_bin_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|padding
index|[
literal|4
index|]
decl_stmt|;
name|u64
name|bins
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_vport_update_accept_param_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|update_rx_mode
decl_stmt|;
name|u8
name|update_tx_mode
decl_stmt|;
name|u8
name|rx_accept_filter
decl_stmt|;
name|u8
name|tx_accept_filter
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_vport_update_accept_any_vlan_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u8
name|update_accept_any_vlan_flg
decl_stmt|;
name|u8
name|accept_any_vlan
decl_stmt|;
name|u8
name|padding
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_vport_update_sge_tpa_tlv
block|{
name|struct
name|channel_tlv
name|tl
decl_stmt|;
name|u16
name|sge_tpa_flags
decl_stmt|;
define|#
directive|define
name|VFPF_TPA_IPV4_EN_FLAG
value|(1<< 0)
define|#
directive|define
name|VFPF_TPA_IPV6_EN_FLAG
value|(1<< 1)
define|#
directive|define
name|VFPF_TPA_PKT_SPLIT_FLAG
value|(1<< 2)
define|#
directive|define
name|VFPF_TPA_HDR_DATA_SPLIT_FLAG
value|(1<< 3)
define|#
directive|define
name|VFPF_TPA_GRO_CONSIST_FLAG
value|(1<< 4)
name|u8
name|update_sge_tpa_flags
decl_stmt|;
define|#
directive|define
name|VFPF_UPDATE_SGE_DEPRECATED_FLAG
value|(1<< 0)
define|#
directive|define
name|VFPF_UPDATE_TPA_EN_FLAG
value|(1<< 1)
define|#
directive|define
name|VFPF_UPDATE_TPA_PARAM_FLAG
value|(1<< 2)
name|u8
name|max_buffers_per_cqe
decl_stmt|;
name|u16
name|deprecated_sge_buff_size
decl_stmt|;
name|u16
name|tpa_max_size
decl_stmt|;
name|u16
name|tpa_min_size_to_start
decl_stmt|;
name|u16
name|tpa_min_size_to_cont
decl_stmt|;
name|u8
name|tpa_max_aggs_num
decl_stmt|;
name|u8
name|padding
index|[
literal|7
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Primary tlv as a header for various extended tlvs for  * various functionalities in vport update ramrod.  */
end_comment

begin_struct
struct|struct
name|vfpf_vport_update_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_ucast_filter_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
name|u8
name|opcode
decl_stmt|;
name|u8
name|type
decl_stmt|;
name|u8
name|mac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|u16
name|vlan
decl_stmt|;
name|u16
name|padding
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* tunnel update param tlv */
end_comment

begin_struct
struct|struct
name|vfpf_update_tunn_param_tlv
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
name|u8
name|tun_mode_update_mask
decl_stmt|;
name|u8
name|tunn_mode
decl_stmt|;
name|u8
name|update_tun_cls
decl_stmt|;
name|u8
name|vxlan_clss
decl_stmt|;
name|u8
name|l2gre_clss
decl_stmt|;
name|u8
name|ipgre_clss
decl_stmt|;
name|u8
name|l2geneve_clss
decl_stmt|;
name|u8
name|ipgeneve_clss
decl_stmt|;
name|u8
name|update_geneve_port
decl_stmt|;
name|u8
name|update_vxlan_port
decl_stmt|;
name|u16
name|geneve_port
decl_stmt|;
name|u16
name|vxlan_port
decl_stmt|;
name|u8
name|padding
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pfvf_update_tunn_param_tlv
block|{
name|struct
name|pfvf_tlv
name|hdr
decl_stmt|;
name|u16
name|tunn_feature_mask
decl_stmt|;
name|u8
name|vxlan_mode
decl_stmt|;
name|u8
name|l2geneve_mode
decl_stmt|;
name|u8
name|ipgeneve_mode
decl_stmt|;
name|u8
name|l2gre_mode
decl_stmt|;
name|u8
name|ipgre_mode
decl_stmt|;
name|u8
name|vxlan_clss
decl_stmt|;
name|u8
name|l2gre_clss
decl_stmt|;
name|u8
name|ipgre_clss
decl_stmt|;
name|u8
name|l2geneve_clss
decl_stmt|;
name|u8
name|ipgeneve_clss
decl_stmt|;
name|u16
name|vxlan_udp_port
decl_stmt|;
name|u16
name|geneve_udp_port
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tlv_buffer_size
block|{
name|u8
name|tlv_buffer
index|[
name|TLV_BUFFER_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfpf_update_coalesce
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
name|u16
name|rx_coal
decl_stmt|;
name|u16
name|tx_coal
decl_stmt|;
name|u16
name|qid
decl_stmt|;
name|u8
name|padding
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|vfpf_tlvs
block|{
name|struct
name|vfpf_first_tlv
name|first_tlv
decl_stmt|;
name|struct
name|vfpf_acquire_tlv
name|acquire
decl_stmt|;
name|struct
name|vfpf_start_rxq_tlv
name|start_rxq
decl_stmt|;
name|struct
name|vfpf_start_txq_tlv
name|start_txq
decl_stmt|;
name|struct
name|vfpf_stop_rxqs_tlv
name|stop_rxqs
decl_stmt|;
name|struct
name|vfpf_stop_txqs_tlv
name|stop_txqs
decl_stmt|;
name|struct
name|vfpf_update_rxq_tlv
name|update_rxq
decl_stmt|;
name|struct
name|vfpf_vport_start_tlv
name|start_vport
decl_stmt|;
name|struct
name|vfpf_vport_update_tlv
name|vport_update
decl_stmt|;
name|struct
name|vfpf_ucast_filter_tlv
name|ucast_filter
decl_stmt|;
name|struct
name|vfpf_update_tunn_param_tlv
name|tunn_param_update
decl_stmt|;
name|struct
name|vfpf_update_coalesce
name|update_coalesce
decl_stmt|;
name|struct
name|tlv_buffer_size
name|tlv_buf_size
decl_stmt|;
block|}
union|;
end_union

begin_union
union|union
name|pfvf_tlvs
block|{
name|struct
name|pfvf_def_resp_tlv
name|default_resp
decl_stmt|;
name|struct
name|pfvf_acquire_resp_tlv
name|acquire_resp
decl_stmt|;
name|struct
name|tlv_buffer_size
name|tlv_buf_size
decl_stmt|;
name|struct
name|pfvf_start_queue_resp_tlv
name|queue_start
decl_stmt|;
name|struct
name|pfvf_update_tunn_param_tlv
name|tunn_param_resp
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* This is a structure which is allocated in the VF, which the PF may update  * when it deems it necessary to do so. The bulletin board is sampled  * periodically by the VF. A copy per VF is maintained in the PF (to prevent  * loss of data upon multiple updates (or the need for read modify write)).  */
end_comment

begin_enum
enum|enum
name|ecore_bulletin_bit
block|{
comment|/* Alert the VF that a forced MAC was set by the PF */
name|MAC_ADDR_FORCED
init|=
literal|0
block|,
comment|/* The VF should not access the vfpf channel */
name|VFPF_CHANNEL_INVALID
init|=
literal|1
block|,
comment|/* Alert the VF that a forced VLAN was set by the PF */
name|VLAN_ADDR_FORCED
init|=
literal|2
block|,
comment|/* Indicate that `default_only_untagged' contains actual data */
name|VFPF_BULLETIN_UNTAGGED_DEFAULT
init|=
literal|3
block|,
name|VFPF_BULLETIN_UNTAGGED_DEFAULT_FORCED
init|=
literal|4
block|,
comment|/* Alert the VF that suggested mac was sent by the PF. 	 * MAC_ADDR will be disabled in case MAC_ADDR_FORCED is set 	 */
name|VFPF_BULLETIN_MAC_ADDR
init|=
literal|5
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ecore_bulletin_content
block|{
comment|/* crc of structure to ensure is not in mid-update */
name|u32
name|crc
decl_stmt|;
name|u32
name|version
decl_stmt|;
comment|/* bitmap indicating which fields hold valid values */
name|u64
name|valid_bitmap
decl_stmt|;
comment|/* used for MAC_ADDR or MAC_ADDR_FORCED */
name|u8
name|mac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
comment|/* If valid, 1 => only untagged Rx if no vlan is configured */
name|u8
name|default_only_untagged
decl_stmt|;
name|u8
name|padding
decl_stmt|;
comment|/* The following is a 'copy' of ecore_mcp_link_state, 	 * ecore_mcp_link_params and ecore_mcp_link_capabilities. Since it's 	 * possible the structs will increase further along the road we cannot 	 * have it here; Instead we need to have all of its fields. 	 */
name|u8
name|req_autoneg
decl_stmt|;
name|u8
name|req_autoneg_pause
decl_stmt|;
name|u8
name|req_forced_rx
decl_stmt|;
name|u8
name|req_forced_tx
decl_stmt|;
name|u8
name|padding2
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|req_adv_speed
decl_stmt|;
name|u32
name|req_forced_speed
decl_stmt|;
name|u32
name|req_loopback
decl_stmt|;
name|u32
name|padding3
decl_stmt|;
name|u8
name|link_up
decl_stmt|;
name|u8
name|full_duplex
decl_stmt|;
name|u8
name|autoneg
decl_stmt|;
name|u8
name|autoneg_complete
decl_stmt|;
name|u8
name|parallel_detection
decl_stmt|;
name|u8
name|pfc_enabled
decl_stmt|;
name|u8
name|partner_tx_flow_ctrl_en
decl_stmt|;
name|u8
name|partner_rx_flow_ctrl_en
decl_stmt|;
name|u8
name|partner_adv_pause
decl_stmt|;
name|u8
name|sfp_tx_fault
decl_stmt|;
name|u16
name|vxlan_udp_port
decl_stmt|;
name|u16
name|geneve_udp_port
decl_stmt|;
name|u8
name|padding4
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|speed
decl_stmt|;
name|u32
name|partner_adv_speed
decl_stmt|;
name|u32
name|capability_speed
decl_stmt|;
comment|/* Forced vlan */
name|u16
name|pvid
decl_stmt|;
name|u16
name|padding5
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_bulletin
block|{
name|dma_addr_t
name|phys
decl_stmt|;
name|struct
name|ecore_bulletin_content
modifier|*
name|p_virt
decl_stmt|;
name|u32
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
comment|/*!!!!! Make sure to update STRINGS structure accordingly !!!!!*/
name|CHANNEL_TLV_NONE
block|,
comment|/* ends tlv sequence */
name|CHANNEL_TLV_ACQUIRE
block|,
name|CHANNEL_TLV_VPORT_START
block|,
name|CHANNEL_TLV_VPORT_UPDATE
block|,
name|CHANNEL_TLV_VPORT_TEARDOWN
block|,
name|CHANNEL_TLV_START_RXQ
block|,
name|CHANNEL_TLV_START_TXQ
block|,
name|CHANNEL_TLV_STOP_RXQS
block|,
name|CHANNEL_TLV_STOP_TXQS
block|,
name|CHANNEL_TLV_UPDATE_RXQ
block|,
name|CHANNEL_TLV_INT_CLEANUP
block|,
name|CHANNEL_TLV_CLOSE
block|,
name|CHANNEL_TLV_RELEASE
block|,
name|CHANNEL_TLV_LIST_END
block|,
name|CHANNEL_TLV_UCAST_FILTER
block|,
name|CHANNEL_TLV_VPORT_UPDATE_ACTIVATE
block|,
name|CHANNEL_TLV_VPORT_UPDATE_TX_SWITCH
block|,
name|CHANNEL_TLV_VPORT_UPDATE_VLAN_STRIP
block|,
name|CHANNEL_TLV_VPORT_UPDATE_MCAST
block|,
name|CHANNEL_TLV_VPORT_UPDATE_ACCEPT_PARAM
block|,
name|CHANNEL_TLV_VPORT_UPDATE_RSS
block|,
name|CHANNEL_TLV_VPORT_UPDATE_ACCEPT_ANY_VLAN
block|,
name|CHANNEL_TLV_VPORT_UPDATE_SGE_TPA
block|,
name|CHANNEL_TLV_UPDATE_TUNN_PARAM
block|,
name|CHANNEL_TLV_COALESCE_UPDATE
block|,
name|CHANNEL_TLV_QID
block|,
name|CHANNEL_TLV_MAX
block|,
comment|/* Required for iterating over vport-update tlvs. 	 * Will break in case non-sequential vport-update tlvs. 	 */
name|CHANNEL_TLV_VPORT_UPDATE_MAX
init|=
name|CHANNEL_TLV_VPORT_UPDATE_SGE_TPA
operator|+
literal|1
block|,
comment|/*!!!!! Make sure to update STRINGS structure accordingly !!!!!*/
block|}
enum|;
end_enum

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|ecore_channel_tlvs_string
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __ECORE_VF_PF_IF_H__ */
end_comment

end_unit

