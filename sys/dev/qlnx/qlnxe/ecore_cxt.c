begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * File : ecore_cxt.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bcm_osal.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"common_hsi.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_common.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_eth.h"
end_include

begin_include
include|#
directive|include
file|"tcp_common.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_iscsi.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_fcoe.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_roce.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_iwarp.h"
end_include

begin_include
include|#
directive|include
file|"ecore_rt_defs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_status.h"
end_include

begin_include
include|#
directive|include
file|"ecore.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_ops.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_fw_funcs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_cxt.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw.h"
end_include

begin_include
include|#
directive|include
file|"ecore_dev_api.h"
end_include

begin_include
include|#
directive|include
file|"ecore_sriov.h"
end_include

begin_include
include|#
directive|include
file|"ecore_roce.h"
end_include

begin_include
include|#
directive|include
file|"ecore_mcp.h"
end_include

begin_comment
comment|/* Max number of connection types in HW (DQ/CDU etc.) */
end_comment

begin_define
define|#
directive|define
name|MAX_CONN_TYPES
value|PROTOCOLID_COMMON
end_define

begin_define
define|#
directive|define
name|NUM_TASK_TYPES
value|2
end_define

begin_define
define|#
directive|define
name|NUM_TASK_PF_SEGMENTS
value|4
end_define

begin_define
define|#
directive|define
name|NUM_TASK_VF_SEGMENTS
value|1
end_define

begin_comment
comment|/* Doorbell-Queue constants */
end_comment

begin_define
define|#
directive|define
name|DQ_RANGE_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|DQ_RANGE_ALIGN
value|(1<< DQ_RANGE_SHIFT)
end_define

begin_comment
comment|/* Searcher constants */
end_comment

begin_define
define|#
directive|define
name|SRC_MIN_NUM_ELEMS
value|256
end_define

begin_comment
comment|/* Timers constants */
end_comment

begin_define
define|#
directive|define
name|TM_SHIFT
value|7
end_define

begin_define
define|#
directive|define
name|TM_ALIGN
value|(1<< TM_SHIFT)
end_define

begin_define
define|#
directive|define
name|TM_ELEM_SIZE
value|4
end_define

begin_comment
comment|/* ILT constants */
end_comment

begin_define
define|#
directive|define
name|ILT_DEFAULT_HW_P_SIZE
value|4
end_define

begin_define
define|#
directive|define
name|ILT_PAGE_IN_BYTES
parameter_list|(
name|hw_p_size
parameter_list|)
value|(1U<< ((hw_p_size) + 12))
end_define

begin_define
define|#
directive|define
name|ILT_CFG_REG
parameter_list|(
name|cli
parameter_list|,
name|reg
parameter_list|)
value|PSWRQ2_REG_##cli##_##reg##_RT_OFFSET
end_define

begin_comment
comment|/* ILT entry structure */
end_comment

begin_define
define|#
directive|define
name|ILT_ENTRY_PHY_ADDR_MASK
value|0x000FFFFFFFFFFFULL
end_define

begin_define
define|#
directive|define
name|ILT_ENTRY_PHY_ADDR_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|ILT_ENTRY_VALID_MASK
value|0x1ULL
end_define

begin_define
define|#
directive|define
name|ILT_ENTRY_VALID_SHIFT
value|52
end_define

begin_define
define|#
directive|define
name|ILT_ENTRY_IN_REGS
value|2
end_define

begin_define
define|#
directive|define
name|ILT_REG_SIZE_IN_BYTES
value|4
end_define

begin_comment
comment|/* connection context union */
end_comment

begin_union
union|union
name|conn_context
block|{
name|struct
name|e4_core_conn_context
name|core_ctx
decl_stmt|;
name|struct
name|e4_eth_conn_context
name|eth_ctx
decl_stmt|;
name|struct
name|e4_iscsi_conn_context
name|iscsi_ctx
decl_stmt|;
name|struct
name|e4_fcoe_conn_context
name|fcoe_ctx
decl_stmt|;
name|struct
name|e4_roce_conn_context
name|roce_ctx
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* TYPE-0 task context - iSCSI, FCOE */
end_comment

begin_union
union|union
name|type0_task_context
block|{
name|struct
name|e4_iscsi_task_context
name|iscsi_ctx
decl_stmt|;
name|struct
name|e4_fcoe_task_context
name|fcoe_ctx
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* TYPE-1 task context - ROCE */
end_comment

begin_union
union|union
name|type1_task_context
block|{
name|struct
name|e4_rdma_task_context
name|roce_ctx
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|src_ent
block|{
name|u8
name|opaque
index|[
literal|56
index|]
decl_stmt|;
name|u64
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CDUT_SEG_ALIGNMET
value|3
end_define

begin_comment
comment|/* in 4k chunks */
end_comment

begin_define
define|#
directive|define
name|CDUT_SEG_ALIGNMET_IN_BYTES
value|(1<< (CDUT_SEG_ALIGNMET + 12))
end_define

begin_define
define|#
directive|define
name|CONN_CXT_SIZE
parameter_list|(
name|p_hwfn
parameter_list|)
define|\
value|ALIGNED_TYPE_SIZE(union conn_context, p_hwfn)
end_define

begin_define
define|#
directive|define
name|SRQ_CXT_SIZE
value|(sizeof(struct rdma_srq_context))
end_define

begin_define
define|#
directive|define
name|TYPE0_TASK_CXT_SIZE
parameter_list|(
name|p_hwfn
parameter_list|)
define|\
value|ALIGNED_TYPE_SIZE(union type0_task_context, p_hwfn)
end_define

begin_comment
comment|/* Alignment is inherent to the type1_task_context structure */
end_comment

begin_define
define|#
directive|define
name|TYPE1_TASK_CXT_SIZE
parameter_list|(
name|p_hwfn
parameter_list|)
value|sizeof(union type1_task_context)
end_define

begin_comment
comment|/* PF per protocl configuration object */
end_comment

begin_define
define|#
directive|define
name|TASK_SEGMENTS
value|(NUM_TASK_PF_SEGMENTS + NUM_TASK_VF_SEGMENTS)
end_define

begin_define
define|#
directive|define
name|TASK_SEGMENT_VF
value|(NUM_TASK_PF_SEGMENTS)
end_define

begin_struct
struct|struct
name|ecore_tid_seg
block|{
name|u32
name|count
decl_stmt|;
name|u8
name|type
decl_stmt|;
name|bool
name|has_fl_mem
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_conn_type_cfg
block|{
name|u32
name|cid_count
decl_stmt|;
name|u32
name|cids_per_vf
decl_stmt|;
name|struct
name|ecore_tid_seg
name|tid_seg
index|[
name|TASK_SEGMENTS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ILT Client configuration,  * Per connection type (protocol) resources (cids, tis, vf cids etc.)  * 1 - for connection context (CDUC) and for each task context we need two  * values, for regular task context and for force load memory  */
end_comment

begin_define
define|#
directive|define
name|ILT_CLI_PF_BLOCKS
value|(1 + NUM_TASK_PF_SEGMENTS * 2)
end_define

begin_define
define|#
directive|define
name|ILT_CLI_VF_BLOCKS
value|(1 + NUM_TASK_VF_SEGMENTS * 2)
end_define

begin_define
define|#
directive|define
name|CDUC_BLK
value|(0)
end_define

begin_define
define|#
directive|define
name|SRQ_BLK
value|(0)
end_define

begin_define
define|#
directive|define
name|CDUT_SEG_BLK
parameter_list|(
name|n
parameter_list|)
value|(1 + (u8)(n))
end_define

begin_define
define|#
directive|define
name|CDUT_FL_SEG_BLK
parameter_list|(
name|n
parameter_list|,
name|X
parameter_list|)
value|(1 + (n) + NUM_TASK_##X##_SEGMENTS)
end_define

begin_enum
enum|enum
name|ilt_clients
block|{
name|ILT_CLI_CDUC
block|,
name|ILT_CLI_CDUT
block|,
name|ILT_CLI_QM
block|,
name|ILT_CLI_TM
block|,
name|ILT_CLI_SRC
block|,
name|ILT_CLI_TSDM
block|,
name|ILT_CLI_MAX
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ilt_cfg_pair
block|{
name|u32
name|reg
decl_stmt|;
name|u32
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_ilt_cli_blk
block|{
name|u32
name|total_size
decl_stmt|;
comment|/* 0 means not active */
name|u32
name|real_size_in_page
decl_stmt|;
name|u32
name|start_line
decl_stmt|;
name|u32
name|dynamic_line_cnt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_ilt_client_cfg
block|{
name|bool
name|active
decl_stmt|;
comment|/* ILT boundaries */
name|struct
name|ilt_cfg_pair
name|first
decl_stmt|;
name|struct
name|ilt_cfg_pair
name|last
decl_stmt|;
name|struct
name|ilt_cfg_pair
name|p_size
decl_stmt|;
comment|/* ILT client blocks for PF */
name|struct
name|ecore_ilt_cli_blk
name|pf_blks
index|[
name|ILT_CLI_PF_BLOCKS
index|]
decl_stmt|;
name|u32
name|pf_total_lines
decl_stmt|;
comment|/* ILT client blocks for VFs */
name|struct
name|ecore_ilt_cli_blk
name|vf_blks
index|[
name|ILT_CLI_VF_BLOCKS
index|]
decl_stmt|;
name|u32
name|vf_total_lines
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Per Path -  *      ILT shadow table  *      Protocol acquired CID lists  *      PF start line in ILT  */
end_comment

begin_struct
struct|struct
name|ecore_dma_mem
block|{
name|dma_addr_t
name|p_phys
decl_stmt|;
name|void
modifier|*
name|p_virt
decl_stmt|;
name|osal_size_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAP_WORD_SIZE
value|sizeof(unsigned long)
end_define

begin_define
define|#
directive|define
name|BITS_PER_MAP_WORD
value|(MAP_WORD_SIZE * 8)
end_define

begin_struct
struct|struct
name|ecore_cid_acquired_map
block|{
name|u32
name|start_cid
decl_stmt|;
name|u32
name|max_count
decl_stmt|;
name|unsigned
name|long
modifier|*
name|cid_map
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_cxt_mngr
block|{
comment|/* Per protocl configuration */
name|struct
name|ecore_conn_type_cfg
name|conn_cfg
index|[
name|MAX_CONN_TYPES
index|]
decl_stmt|;
comment|/* computed ILT structure */
name|struct
name|ecore_ilt_client_cfg
name|clients
index|[
name|ILT_CLI_MAX
index|]
decl_stmt|;
comment|/* Task type sizes */
name|u32
name|task_type_size
index|[
name|NUM_TASK_TYPES
index|]
decl_stmt|;
comment|/* total number of VFs for this hwfn - 	 * ALL VFs are symmetric in terms of HW resources 	 */
name|u32
name|vf_count
decl_stmt|;
comment|/* Acquired CIDs */
name|struct
name|ecore_cid_acquired_map
name|acquired
index|[
name|MAX_CONN_TYPES
index|]
decl_stmt|;
comment|/* TBD - do we want this allocated to reserve space? */
name|struct
name|ecore_cid_acquired_map
name|acquired_vf
index|[
name|MAX_CONN_TYPES
index|]
index|[
name|COMMON_MAX_NUM_VFS
index|]
decl_stmt|;
comment|/* ILT shadow table */
name|struct
name|ecore_dma_mem
modifier|*
name|ilt_shadow
decl_stmt|;
name|u32
name|pf_start_line
decl_stmt|;
comment|/* Mutex for a dynamic ILT allocation */
name|osal_mutex_t
name|mutex
decl_stmt|;
comment|/* SRC T2 */
name|struct
name|ecore_dma_mem
modifier|*
name|t2
decl_stmt|;
name|u32
name|t2_num_pages
decl_stmt|;
name|u64
name|first_free
decl_stmt|;
name|u64
name|last_free
decl_stmt|;
comment|/* The infrastructure originally was very generic and context/task 	 * oriented - per connection-type we would set how many of those 	 * are needed, and later when determining how much memory we're 	 * needing for a given block we'd iterate over all the relevant 	 * connection-types. 	 * But since then we've had some additional resources, some of which 	 * require memory which is indepent of the general context/task 	 * scheme. We add those here explicitly per-feature. 	 */
comment|/* total number of SRQ's for this hwfn */
name|u32
name|srq_count
decl_stmt|;
comment|/* Maximal number of L2 steering filters */
name|u32
name|arfs_count
decl_stmt|;
comment|/* TODO - VF arfs filters ? */
block|}
struct|;
end_struct

begin_comment
comment|/* check if resources/configuration is required according to protocol type */
end_comment

begin_function
specifier|static
name|bool
name|src_proto
parameter_list|(
name|enum
name|protocol_type
name|type
parameter_list|)
block|{
return|return
name|type
operator|==
name|PROTOCOLID_ISCSI
operator|||
name|type
operator|==
name|PROTOCOLID_FCOE
operator|||
name|type
operator|==
name|PROTOCOLID_IWARP
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|tm_cid_proto
parameter_list|(
name|enum
name|protocol_type
name|type
parameter_list|)
block|{
return|return
name|type
operator|==
name|PROTOCOLID_ISCSI
operator|||
name|type
operator|==
name|PROTOCOLID_FCOE
operator|||
name|type
operator|==
name|PROTOCOLID_ROCE
operator|||
name|type
operator|==
name|PROTOCOLID_IWARP
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|tm_tid_proto
parameter_list|(
name|enum
name|protocol_type
name|type
parameter_list|)
block|{
return|return
name|type
operator|==
name|PROTOCOLID_FCOE
return|;
block|}
end_function

begin_comment
comment|/* counts the iids for the CDU/CDUC ILT client configuration */
end_comment

begin_struct
struct|struct
name|ecore_cdu_iids
block|{
name|u32
name|pf_cids
decl_stmt|;
name|u32
name|per_vf_cids
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|ecore_cxt_cdu_iids
parameter_list|(
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
parameter_list|,
name|struct
name|ecore_cdu_iids
modifier|*
name|iids
parameter_list|)
block|{
name|u32
name|type
decl_stmt|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|MAX_CONN_TYPES
condition|;
name|type
operator|++
control|)
block|{
name|iids
operator|->
name|pf_cids
operator|+=
name|p_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
operator|.
name|cid_count
expr_stmt|;
name|iids
operator|->
name|per_vf_cids
operator|+=
name|p_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
operator|.
name|cids_per_vf
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* counts the iids for the Searcher block configuration */
end_comment

begin_struct
struct|struct
name|ecore_src_iids
block|{
name|u32
name|pf_cids
decl_stmt|;
name|u32
name|per_vf_cids
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|ecore_cxt_src_iids
parameter_list|(
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
parameter_list|,
name|struct
name|ecore_src_iids
modifier|*
name|iids
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CONN_TYPES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|src_proto
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|iids
operator|->
name|pf_cids
operator|+=
name|p_mngr
operator|->
name|conn_cfg
index|[
name|i
index|]
operator|.
name|cid_count
expr_stmt|;
name|iids
operator|->
name|per_vf_cids
operator|+=
name|p_mngr
operator|->
name|conn_cfg
index|[
name|i
index|]
operator|.
name|cids_per_vf
expr_stmt|;
block|}
comment|/* Add L2 filtering filters in addition */
name|iids
operator|->
name|pf_cids
operator|+=
name|p_mngr
operator|->
name|arfs_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* counts the iids for the Timers block configuration */
end_comment

begin_struct
struct|struct
name|ecore_tm_iids
block|{
name|u32
name|pf_cids
decl_stmt|;
name|u32
name|pf_tids
index|[
name|NUM_TASK_PF_SEGMENTS
index|]
decl_stmt|;
comment|/* per segment */
name|u32
name|pf_tids_total
decl_stmt|;
name|u32
name|per_vf_cids
decl_stmt|;
name|u32
name|per_vf_tids
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|ecore_cxt_tm_iids
parameter_list|(
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
parameter_list|,
name|struct
name|ecore_tm_iids
modifier|*
name|iids
parameter_list|)
block|{
name|bool
name|tm_vf_required
init|=
name|false
decl_stmt|;
name|bool
name|tm_required
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Timers is a special case -> we don't count how many cids require 	 * timers but what's the max cid that will be used by the timer block. 	 * therefore we traverse in reverse order, and once we hit a protocol 	 * that requires the timers memory, we'll sum all the protocols up 	 * to that one. 	 */
for|for
control|(
name|i
operator|=
name|MAX_CONN_TYPES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|ecore_conn_type_cfg
modifier|*
name|p_cfg
init|=
operator|&
name|p_mngr
operator|->
name|conn_cfg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tm_cid_proto
argument_list|(
name|i
argument_list|)
operator|||
name|tm_required
condition|)
block|{
if|if
condition|(
name|p_cfg
operator|->
name|cid_count
condition|)
name|tm_required
operator|=
name|true
expr_stmt|;
name|iids
operator|->
name|pf_cids
operator|+=
name|p_cfg
operator|->
name|cid_count
expr_stmt|;
block|}
if|if
condition|(
name|tm_cid_proto
argument_list|(
name|i
argument_list|)
operator|||
name|tm_vf_required
condition|)
block|{
if|if
condition|(
name|p_cfg
operator|->
name|cids_per_vf
condition|)
name|tm_vf_required
operator|=
name|true
expr_stmt|;
name|iids
operator|->
name|per_vf_cids
operator|+=
name|p_cfg
operator|->
name|cids_per_vf
expr_stmt|;
block|}
if|if
condition|(
name|tm_tid_proto
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|struct
name|ecore_tid_seg
modifier|*
name|segs
init|=
name|p_cfg
operator|->
name|tid_seg
decl_stmt|;
comment|/* for each segment there is at most one 			 * protocol for which count is not 0. 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_TASK_PF_SEGMENTS
condition|;
name|j
operator|++
control|)
name|iids
operator|->
name|pf_tids
index|[
name|j
index|]
operator|+=
name|segs
index|[
name|j
index|]
operator|.
name|count
expr_stmt|;
comment|/* The last array elelment is for the VFs. As for PF 			 * segments there can be only one protocol for 			 * which this value is not 0. 			 */
name|iids
operator|->
name|per_vf_tids
operator|+=
name|segs
index|[
name|NUM_TASK_PF_SEGMENTS
index|]
operator|.
name|count
expr_stmt|;
block|}
block|}
name|iids
operator|->
name|pf_cids
operator|=
name|ROUNDUP
argument_list|(
name|iids
operator|->
name|pf_cids
argument_list|,
name|TM_ALIGN
argument_list|)
expr_stmt|;
name|iids
operator|->
name|per_vf_cids
operator|=
name|ROUNDUP
argument_list|(
name|iids
operator|->
name|per_vf_cids
argument_list|,
name|TM_ALIGN
argument_list|)
expr_stmt|;
name|iids
operator|->
name|per_vf_tids
operator|=
name|ROUNDUP
argument_list|(
name|iids
operator|->
name|per_vf_tids
argument_list|,
name|TM_ALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|iids
operator|->
name|pf_tids_total
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_TASK_PF_SEGMENTS
condition|;
name|j
operator|++
control|)
block|{
name|iids
operator|->
name|pf_tids
index|[
name|j
index|]
operator|=
name|ROUNDUP
argument_list|(
name|iids
operator|->
name|pf_tids
index|[
name|j
index|]
argument_list|,
name|TM_ALIGN
argument_list|)
expr_stmt|;
name|iids
operator|->
name|pf_tids_total
operator|+=
name|iids
operator|->
name|pf_tids
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_cxt_qm_iids
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_qm_iids
modifier|*
name|iids
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_tid_seg
modifier|*
name|segs
decl_stmt|;
name|u32
name|vf_cids
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|,
name|j
decl_stmt|;
name|u32
name|vf_tids
init|=
literal|0
decl_stmt|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|MAX_CONN_TYPES
condition|;
name|type
operator|++
control|)
block|{
name|iids
operator|->
name|cids
operator|+=
name|p_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
operator|.
name|cid_count
expr_stmt|;
name|vf_cids
operator|+=
name|p_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
operator|.
name|cids_per_vf
expr_stmt|;
name|segs
operator|=
name|p_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
operator|.
name|tid_seg
expr_stmt|;
comment|/* for each segment there is at most one 		 * protocol for which count is not 0. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_TASK_PF_SEGMENTS
condition|;
name|j
operator|++
control|)
name|iids
operator|->
name|tids
operator|+=
name|segs
index|[
name|j
index|]
operator|.
name|count
expr_stmt|;
comment|/* The last array elelment is for the VFs. As for PF 		 * segments there can be only one protocol for 		 * which this value is not 0. 		 */
name|vf_tids
operator|+=
name|segs
index|[
name|NUM_TASK_PF_SEGMENTS
index|]
operator|.
name|count
expr_stmt|;
block|}
name|iids
operator|->
name|vf_cids
operator|+=
name|vf_cids
operator|*
name|p_mngr
operator|->
name|vf_count
expr_stmt|;
name|iids
operator|->
name|tids
operator|+=
name|vf_tids
operator|*
name|p_mngr
operator|->
name|vf_count
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_ILT
argument_list|,
literal|"iids: CIDS %08x vf_cids %08x tids %08x vf_tids %08x\n"
argument_list|,
name|iids
operator|->
name|cids
argument_list|,
name|iids
operator|->
name|vf_cids
argument_list|,
name|iids
operator|->
name|tids
argument_list|,
name|vf_tids
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ecore_tid_seg
modifier|*
name|ecore_cxt_tid_seg_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|seg
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_cfg
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|i
decl_stmt|;
comment|/* Find the protocol with tid count> 0 for this segment. 	   Note: there can only be one and this is already validated. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CONN_TYPES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_cfg
operator|->
name|conn_cfg
index|[
name|i
index|]
operator|.
name|tid_seg
index|[
name|seg
index|]
operator|.
name|count
condition|)
return|return
operator|&
name|p_cfg
operator|->
name|conn_cfg
index|[
name|i
index|]
operator|.
name|tid_seg
index|[
name|seg
index|]
return|;
block|}
return|return
name|OSAL_NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_cxt_set_srq_count
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|num_srqs
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mgr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|p_mgr
operator|->
name|srq_count
operator|=
name|num_srqs
expr_stmt|;
block|}
end_function

begin_function
name|u32
name|ecore_cxt_get_srq_count
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mgr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
return|return
name|p_mgr
operator|->
name|srq_count
return|;
block|}
end_function

begin_comment
comment|/* set the iids (cid/tid) count per protocol */
end_comment

begin_function
specifier|static
name|void
name|ecore_cxt_set_proto_cid_count
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|protocol_type
name|type
parameter_list|,
name|u32
name|cid_count
parameter_list|,
name|u32
name|vf_cid_cnt
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mgr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_conn_type_cfg
modifier|*
name|p_conn
init|=
operator|&
name|p_mgr
operator|->
name|conn_cfg
index|[
name|type
index|]
decl_stmt|;
name|p_conn
operator|->
name|cid_count
operator|=
name|ROUNDUP
argument_list|(
name|cid_count
argument_list|,
name|DQ_RANGE_ALIGN
argument_list|)
expr_stmt|;
name|p_conn
operator|->
name|cids_per_vf
operator|=
name|ROUNDUP
argument_list|(
name|vf_cid_cnt
argument_list|,
name|DQ_RANGE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PROTOCOLID_ROCE
condition|)
block|{
name|u32
name|page_sz
init|=
name|p_mgr
operator|->
name|clients
index|[
name|ILT_CLI_CDUC
index|]
operator|.
name|p_size
operator|.
name|val
decl_stmt|;
name|u32
name|cxt_size
init|=
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
name|u32
name|elems_per_page
init|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|page_sz
argument_list|)
operator|/
name|cxt_size
decl_stmt|;
name|u32
name|align
init|=
name|elems_per_page
operator|*
name|DQ_RANGE_ALIGN
decl_stmt|;
name|p_conn
operator|->
name|cid_count
operator|=
name|ROUNDUP
argument_list|(
name|p_conn
operator|->
name|cid_count
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|u32
name|ecore_cxt_get_proto_cid_count
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|protocol_type
name|type
parameter_list|,
name|u32
modifier|*
name|vf_cid
parameter_list|)
block|{
if|if
condition|(
name|vf_cid
condition|)
operator|*
name|vf_cid
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
operator|.
name|cids_per_vf
expr_stmt|;
return|return
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
operator|.
name|cid_count
return|;
block|}
end_function

begin_function
name|u32
name|ecore_cxt_get_proto_cid_start
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|protocol_type
name|type
parameter_list|)
block|{
return|return
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|acquired
index|[
name|type
index|]
operator|.
name|start_cid
return|;
block|}
end_function

begin_function
name|u32
name|ecore_cxt_get_proto_tid_count
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|protocol_type
name|type
parameter_list|)
block|{
name|u32
name|cnt
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TASK_SEGMENTS
condition|;
name|i
operator|++
control|)
name|cnt
operator|+=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
operator|.
name|tid_seg
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_cxt_set_proto_tid_count
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|protocol_type
name|proto
parameter_list|,
name|u8
name|seg
parameter_list|,
name|u8
name|seg_type
parameter_list|,
name|u32
name|count
parameter_list|,
name|bool
name|has_fl
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_tid_seg
modifier|*
name|p_seg
init|=
operator|&
name|p_mngr
operator|->
name|conn_cfg
index|[
name|proto
index|]
operator|.
name|tid_seg
index|[
name|seg
index|]
decl_stmt|;
name|p_seg
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|p_seg
operator|->
name|has_fl_mem
operator|=
name|has_fl
expr_stmt|;
name|p_seg
operator|->
name|type
operator|=
name|seg_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* the *p_line parameter must be either 0 for the first invocation or the    value returned in the previous invocation.  */
end_comment

begin_function
specifier|static
name|void
name|ecore_ilt_cli_blk_fill
parameter_list|(
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
parameter_list|,
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_blk
parameter_list|,
name|u32
name|start_line
parameter_list|,
name|u32
name|total_size
parameter_list|,
name|u32
name|elem_size
parameter_list|)
block|{
name|u32
name|ilt_size
init|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
decl_stmt|;
comment|/* verify that it's called once for each block */
if|if
condition|(
name|p_blk
operator|->
name|total_size
condition|)
return|return;
name|p_blk
operator|->
name|total_size
operator|=
name|total_size
expr_stmt|;
name|p_blk
operator|->
name|real_size_in_page
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|elem_size
condition|)
name|p_blk
operator|->
name|real_size_in_page
operator|=
operator|(
name|ilt_size
operator|/
name|elem_size
operator|)
operator|*
name|elem_size
expr_stmt|;
name|p_blk
operator|->
name|start_line
operator|=
name|start_line
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_cli_adv_line
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
parameter_list|,
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_blk
parameter_list|,
name|u32
modifier|*
name|p_line
parameter_list|,
name|enum
name|ilt_clients
name|client_id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_blk
operator|->
name|total_size
condition|)
return|return;
if|if
condition|(
operator|!
name|p_cli
operator|->
name|active
condition|)
name|p_cli
operator|->
name|first
operator|.
name|val
operator|=
operator|*
name|p_line
expr_stmt|;
name|p_cli
operator|->
name|active
operator|=
name|true
expr_stmt|;
operator|*
name|p_line
operator|+=
name|DIV_ROUND_UP
argument_list|(
name|p_blk
operator|->
name|total_size
argument_list|,
name|p_blk
operator|->
name|real_size_in_page
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|last
operator|.
name|val
operator|=
operator|*
name|p_line
operator|-
literal|1
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_ILT
argument_list|,
literal|"ILT[Client %d] - Lines: [%08x - %08x]. Block - Size %08x [Real %08x] Start line %d\n"
argument_list|,
name|client_id
argument_list|,
name|p_cli
operator|->
name|first
operator|.
name|val
argument_list|,
name|p_cli
operator|->
name|last
operator|.
name|val
argument_list|,
name|p_blk
operator|->
name|total_size
argument_list|,
name|p_blk
operator|->
name|real_size_in_page
argument_list|,
name|p_blk
operator|->
name|start_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|ecore_ilt_get_dynamic_line_cnt
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ilt_clients
name|ilt_client
parameter_list|)
block|{
name|u32
name|cid_count
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|conn_cfg
index|[
name|PROTOCOLID_ROCE
index|]
operator|.
name|cid_count
decl_stmt|;
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|u32
name|lines_to_skip
init|=
literal|0
decl_stmt|;
name|u32
name|cxts_per_p
decl_stmt|;
comment|/* TBD MK: ILT code should be simplified once PROTO enum is changed */
if|if
condition|(
name|ilt_client
operator|==
name|ILT_CLI_CDUC
condition|)
block|{
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUC
index|]
expr_stmt|;
name|cxts_per_p
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
operator|/
operator|(
name|u32
operator|)
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|lines_to_skip
operator|=
name|cid_count
operator|/
name|cxts_per_p
expr_stmt|;
block|}
return|return
name|lines_to_skip
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|ecore_cxt_set_cli
parameter_list|(
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
parameter_list|)
block|{
name|p_cli
operator|->
name|active
operator|=
name|false
expr_stmt|;
name|p_cli
operator|->
name|first
operator|.
name|val
operator|=
literal|0
expr_stmt|;
name|p_cli
operator|->
name|last
operator|.
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|p_cli
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|ecore_cxt_set_blk
parameter_list|(
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_blk
parameter_list|)
block|{
name|p_blk
operator|->
name|total_size
operator|=
literal|0
expr_stmt|;
return|return
name|p_blk
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_cfg_ilt_compute
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
modifier|*
name|line_count
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|curr_line
decl_stmt|,
name|total
decl_stmt|,
name|i
decl_stmt|,
name|task_size
decl_stmt|,
name|line
decl_stmt|;
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_blk
decl_stmt|;
name|struct
name|ecore_cdu_iids
name|cdu_iids
decl_stmt|;
name|struct
name|ecore_src_iids
name|src_iids
decl_stmt|;
name|struct
name|ecore_qm_iids
name|qm_iids
decl_stmt|;
name|struct
name|ecore_tm_iids
name|tm_iids
decl_stmt|;
name|struct
name|ecore_tid_seg
modifier|*
name|p_seg
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|qm_iids
argument_list|,
sizeof|sizeof
argument_list|(
name|qm_iids
argument_list|)
argument_list|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|cdu_iids
argument_list|,
sizeof|sizeof
argument_list|(
name|cdu_iids
argument_list|)
argument_list|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|src_iids
argument_list|,
sizeof|sizeof
argument_list|(
name|src_iids
argument_list|)
argument_list|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|tm_iids
argument_list|,
sizeof|sizeof
argument_list|(
name|tm_iids
argument_list|)
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|pf_start_line
operator|=
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_ILT
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_ILT
argument_list|,
literal|"hwfn [%d] - Set context manager starting line to be 0x%08x\n"
argument_list|,
name|p_hwfn
operator|->
name|my_id
argument_list|,
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|pf_start_line
argument_list|)
expr_stmt|;
comment|/* CDUC */
name|p_cli
operator|=
name|ecore_cxt_set_cli
argument_list|(
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUC
index|]
argument_list|)
expr_stmt|;
name|curr_line
operator|=
name|p_mngr
operator|->
name|pf_start_line
expr_stmt|;
comment|/* CDUC PF */
name|p_cli
operator|->
name|pf_total_lines
operator|=
literal|0
expr_stmt|;
comment|/* get the counters for the CDUC,CDUC and QM clients  */
name|ecore_cxt_cdu_iids
argument_list|(
name|p_mngr
argument_list|,
operator|&
name|cdu_iids
argument_list|)
expr_stmt|;
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUC_BLK
index|]
argument_list|)
expr_stmt|;
name|total
operator|=
name|cdu_iids
operator|.
name|pf_cids
operator|*
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
argument_list|,
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUC
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|pf_total_lines
operator|=
name|curr_line
operator|-
name|p_blk
operator|->
name|start_line
expr_stmt|;
name|p_blk
operator|->
name|dynamic_line_cnt
operator|=
name|ecore_ilt_get_dynamic_line_cnt
argument_list|(
name|p_hwfn
argument_list|,
name|ILT_CLI_CDUC
argument_list|)
expr_stmt|;
comment|/* CDUC VF */
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|vf_blks
index|[
name|CDUC_BLK
index|]
argument_list|)
expr_stmt|;
name|total
operator|=
name|cdu_iids
operator|.
name|per_vf_cids
operator|*
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
argument_list|,
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUC
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|vf_total_lines
operator|=
name|curr_line
operator|-
name|p_blk
operator|->
name|start_line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|p_mngr
operator|->
name|vf_count
condition|;
name|i
operator|++
control|)
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUC
argument_list|)
expr_stmt|;
comment|/* CDUT PF */
name|p_cli
operator|=
name|ecore_cxt_set_cli
argument_list|(
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|first
operator|.
name|val
operator|=
name|curr_line
expr_stmt|;
comment|/* first the 'working' task memory */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TASK_PF_SEGMENTS
condition|;
name|i
operator|++
control|)
block|{
name|p_seg
operator|=
name|ecore_cxt_tid_seg_info
argument_list|(
name|p_hwfn
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_seg
operator|||
name|p_seg
operator|->
name|count
operator|==
literal|0
condition|)
continue|continue;
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|total
operator|=
name|p_seg
operator|->
name|count
operator|*
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg
operator|->
name|type
index|]
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
argument_list|,
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUT
argument_list|)
expr_stmt|;
block|}
comment|/* next the 'init' task memory (forced load memory) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TASK_PF_SEGMENTS
condition|;
name|i
operator|++
control|)
block|{
name|p_seg
operator|=
name|ecore_cxt_tid_seg_info
argument_list|(
name|p_hwfn
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_seg
operator|||
name|p_seg
operator|->
name|count
operator|==
literal|0
condition|)
continue|continue;
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_FL_SEG_BLK
argument_list|(
name|i
argument_list|,
name|PF
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_seg
operator|->
name|has_fl_mem
condition|)
block|{
comment|/* The segment is active (total size pf 'working' 			 * memory is> 0) but has no FL (forced-load, Init) 			 * memory. Thus: 			 * 			 * 1.   The total-size in the corrsponding FL block of 			 *      the ILT client is set to 0 - No ILT line are 			 *      provisioned and no ILT memory allocated. 			 * 			 * 2.   The start-line of said block is set to the 			 *      start line of the matching working memory 			 *      block in the ILT client. This is later used to 			 *      configure the CDU segment offset registers and 			 *      results in an FL command for TIDs of this 			 *      segement behaves as regular load commands 			 *      (loading TIDs from the working memory). 			 */
name|line
operator|=
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
name|i
argument_list|)
index|]
operator|.
name|start_line
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|total
operator|=
name|p_seg
operator|->
name|count
operator|*
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg
operator|->
name|type
index|]
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
argument_list|,
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUT
argument_list|)
expr_stmt|;
block|}
name|p_cli
operator|->
name|pf_total_lines
operator|=
name|curr_line
operator|-
name|p_cli
operator|->
name|pf_blks
index|[
literal|0
index|]
operator|.
name|start_line
expr_stmt|;
comment|/* CDUT VF */
name|p_seg
operator|=
name|ecore_cxt_tid_seg_info
argument_list|(
name|p_hwfn
argument_list|,
name|TASK_SEGMENT_VF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_seg
operator|&&
name|p_seg
operator|->
name|count
condition|)
block|{
comment|/* Stricly speaking we need to iterate over all VF 		 * task segment types, but a VF has only 1 segment 		 */
comment|/* 'working' memory */
name|total
operator|=
name|p_seg
operator|->
name|count
operator|*
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg
operator|->
name|type
index|]
expr_stmt|;
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|vf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
literal|0
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
argument_list|,
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUT
argument_list|)
expr_stmt|;
comment|/* 'init' memory */
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|vf_blks
index|[
name|CDUT_FL_SEG_BLK
argument_list|(
literal|0
argument_list|,
name|VF
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_seg
operator|->
name|has_fl_mem
condition|)
block|{
comment|/* see comment above */
name|line
operator|=
name|p_cli
operator|->
name|vf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
literal|0
argument_list|)
index|]
operator|.
name|start_line
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|task_size
operator|=
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg
operator|->
name|type
index|]
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
argument_list|,
name|task_size
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUT
argument_list|)
expr_stmt|;
block|}
name|p_cli
operator|->
name|vf_total_lines
operator|=
name|curr_line
operator|-
name|p_cli
operator|->
name|vf_blks
index|[
literal|0
index|]
operator|.
name|start_line
expr_stmt|;
comment|/* Now for the rest of the VFs */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|p_mngr
operator|->
name|vf_count
condition|;
name|i
operator|++
control|)
block|{
comment|/* don't set p_blk i.e. don't clear total_size */
name|p_blk
operator|=
operator|&
name|p_cli
operator|->
name|vf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
literal|0
argument_list|)
index|]
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUT
argument_list|)
expr_stmt|;
comment|/* don't set p_blk i.e. don't clear total_size */
name|p_blk
operator|=
operator|&
name|p_cli
operator|->
name|vf_blks
index|[
name|CDUT_FL_SEG_BLK
argument_list|(
literal|0
argument_list|,
name|VF
argument_list|)
index|]
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_CDUT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* QM */
name|p_cli
operator|=
name|ecore_cxt_set_cli
argument_list|(
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_QM
index|]
argument_list|)
expr_stmt|;
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ecore_cxt_qm_iids
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|qm_iids
argument_list|)
expr_stmt|;
name|total
operator|=
name|ecore_qm_pf_mem_size
argument_list|(
name|qm_iids
operator|.
name|cids
argument_list|,
name|qm_iids
operator|.
name|vf_cids
argument_list|,
name|qm_iids
operator|.
name|tids
argument_list|,
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_pqs
argument_list|,
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_vf_pqs
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_ILT
argument_list|,
literal|"QM ILT Info, (cids=%d, vf_cids=%d, tids=%d, num_pqs=%d, num_vf_pqs=%d, memory_size=%d)\n"
argument_list|,
name|qm_iids
operator|.
name|cids
argument_list|,
name|qm_iids
operator|.
name|vf_cids
argument_list|,
name|qm_iids
operator|.
name|tids
argument_list|,
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_pqs
argument_list|,
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_vf_pqs
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
operator|*
literal|0x1000
argument_list|,
name|QM_PQ_ELEMENT_SIZE
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_QM
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|pf_total_lines
operator|=
name|curr_line
operator|-
name|p_blk
operator|->
name|start_line
expr_stmt|;
comment|/* SRC */
name|p_cli
operator|=
name|ecore_cxt_set_cli
argument_list|(
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_SRC
index|]
argument_list|)
expr_stmt|;
name|ecore_cxt_src_iids
argument_list|(
name|p_mngr
argument_list|,
operator|&
name|src_iids
argument_list|)
expr_stmt|;
comment|/* Both the PF and VFs searcher connections are stored in the per PF 	 * database. Thus sum the PF searcher cids and all the VFs searcher 	 * cids. 	 */
name|total
operator|=
name|src_iids
operator|.
name|pf_cids
operator|+
name|src_iids
operator|.
name|per_vf_cids
operator|*
name|p_mngr
operator|->
name|vf_count
expr_stmt|;
if|if
condition|(
name|total
condition|)
block|{
name|u32
name|local_max
init|=
name|OSAL_MAX_T
argument_list|(
name|u32
argument_list|,
name|total
argument_list|,
name|SRC_MIN_NUM_ELEMS
argument_list|)
decl_stmt|;
name|total
operator|=
name|OSAL_ROUNDUP_POW_OF_TWO
argument_list|(
name|local_max
argument_list|)
expr_stmt|;
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_SRC
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|pf_total_lines
operator|=
name|curr_line
operator|-
name|p_blk
operator|->
name|start_line
expr_stmt|;
block|}
comment|/* TM PF */
name|p_cli
operator|=
name|ecore_cxt_set_cli
argument_list|(
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_TM
index|]
argument_list|)
expr_stmt|;
name|ecore_cxt_tm_iids
argument_list|(
name|p_mngr
argument_list|,
operator|&
name|tm_iids
argument_list|)
expr_stmt|;
name|total
operator|=
name|tm_iids
operator|.
name|pf_cids
operator|+
name|tm_iids
operator|.
name|pf_tids_total
expr_stmt|;
if|if
condition|(
name|total
condition|)
block|{
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
operator|*
name|TM_ELEM_SIZE
argument_list|,
name|TM_ELEM_SIZE
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_TM
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|pf_total_lines
operator|=
name|curr_line
operator|-
name|p_blk
operator|->
name|start_line
expr_stmt|;
block|}
comment|/* TM VF */
name|total
operator|=
name|tm_iids
operator|.
name|per_vf_cids
operator|+
name|tm_iids
operator|.
name|per_vf_tids
expr_stmt|;
if|if
condition|(
name|total
condition|)
block|{
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|vf_blks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
operator|*
name|TM_ELEM_SIZE
argument_list|,
name|TM_ELEM_SIZE
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_TM
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|vf_total_lines
operator|=
name|curr_line
operator|-
name|p_blk
operator|->
name|start_line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|p_mngr
operator|->
name|vf_count
condition|;
name|i
operator|++
control|)
block|{
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_TM
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* TSDM (SRQ CONTEXT) */
name|total
operator|=
name|ecore_cxt_get_srq_count
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
condition|)
block|{
name|p_cli
operator|=
name|ecore_cxt_set_cli
argument_list|(
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_TSDM
index|]
argument_list|)
expr_stmt|;
name|p_blk
operator|=
name|ecore_cxt_set_blk
argument_list|(
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|SRQ_BLK
index|]
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_blk_fill
argument_list|(
name|p_cli
argument_list|,
name|p_blk
argument_list|,
name|curr_line
argument_list|,
name|total
operator|*
name|SRQ_CXT_SIZE
argument_list|,
name|SRQ_CXT_SIZE
argument_list|)
expr_stmt|;
name|ecore_ilt_cli_adv_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_cli
argument_list|,
name|p_blk
argument_list|,
operator|&
name|curr_line
argument_list|,
name|ILT_CLI_TSDM
argument_list|)
expr_stmt|;
name|p_cli
operator|->
name|pf_total_lines
operator|=
name|curr_line
operator|-
name|p_blk
operator|->
name|start_line
expr_stmt|;
block|}
operator|*
name|line_count
operator|=
name|curr_line
operator|-
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|pf_start_line
expr_stmt|;
if|if
condition|(
name|curr_line
operator|-
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|pf_start_line
operator|>
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_ILT
argument_list|)
condition|)
block|{
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|u32
name|ecore_cxt_cfg_ilt_compute_excess
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|used_lines
parameter_list|)
block|{
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|u32
name|excess_lines
decl_stmt|,
name|available_lines
decl_stmt|;
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
decl_stmt|;
name|u32
name|ilt_page_size
decl_stmt|,
name|elem_size
decl_stmt|;
name|struct
name|ecore_tid_seg
modifier|*
name|p_seg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|available_lines
operator|=
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_ILT
argument_list|)
expr_stmt|;
name|excess_lines
operator|=
name|used_lines
operator|-
name|available_lines
expr_stmt|;
if|if
condition|(
operator|!
name|excess_lines
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ECORE_IS_RDMA_PERSONALITY
argument_list|(
name|p_hwfn
argument_list|)
condition|)
return|return
literal|0
return|;
name|p_mngr
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
expr_stmt|;
name|p_cli
operator|=
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
expr_stmt|;
name|ilt_page_size
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TASK_PF_SEGMENTS
condition|;
name|i
operator|++
control|)
block|{
name|p_seg
operator|=
name|ecore_cxt_tid_seg_info
argument_list|(
name|p_hwfn
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_seg
operator|||
name|p_seg
operator|->
name|count
operator|==
literal|0
condition|)
continue|continue;
name|elem_size
operator|=
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg
operator|->
name|type
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|elem_size
condition|)
continue|continue;
return|return
operator|(
name|ilt_page_size
operator|/
name|elem_size
operator|)
operator|*
name|excess_lines
return|;
block|}
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"failed computing excess ILT lines\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_cxt_src_t2_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_mngr
operator|->
name|t2
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_mngr
operator|->
name|t2_num_pages
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|p_virt
condition|)
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|p_virt
argument_list|,
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|p_phys
argument_list|,
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_mngr
operator|->
name|t2
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|t2
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_cxt_src_t2_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|conn_num
decl_stmt|,
name|total_size
decl_stmt|,
name|ent_per_page
decl_stmt|,
name|psz
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_src
decl_stmt|;
name|struct
name|ecore_src_iids
name|src_iids
decl_stmt|;
name|struct
name|ecore_dma_mem
modifier|*
name|p_t2
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|src_iids
argument_list|,
sizeof|sizeof
argument_list|(
name|src_iids
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if the SRC ILT client is inactive - there are no connection 	 * requiring the searcer, leave. 	 */
name|p_src
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_SRC
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p_src
operator|->
name|active
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|ecore_cxt_src_iids
argument_list|(
name|p_mngr
argument_list|,
operator|&
name|src_iids
argument_list|)
expr_stmt|;
name|conn_num
operator|=
name|src_iids
operator|.
name|pf_cids
operator|+
name|src_iids
operator|.
name|per_vf_cids
operator|*
name|p_mngr
operator|->
name|vf_count
expr_stmt|;
name|total_size
operator|=
name|conn_num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
expr_stmt|;
comment|/* use the same page size as the SRC ILT client */
name|psz
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_src
operator|->
name|p_size
operator|.
name|val
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|t2_num_pages
operator|=
name|DIV_ROUND_UP
argument_list|(
name|total_size
argument_list|,
name|psz
argument_list|)
expr_stmt|;
comment|/* allocate t2 */
name|p_mngr
operator|->
name|t2
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
name|p_mngr
operator|->
name|t2_num_pages
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_dma_mem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mngr
operator|->
name|t2
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate t2 table\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_NOMEM
expr_stmt|;
goto|goto
name|t2_fail
goto|;
block|}
comment|/* allocate t2 pages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_mngr
operator|->
name|t2_num_pages
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|size
init|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|total_size
argument_list|,
name|psz
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|p_virt
init|=
operator|&
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|p_virt
decl_stmt|;
operator|*
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|p_phys
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|p_virt
condition|)
block|{
name|rc
operator|=
name|ECORE_NOMEM
expr_stmt|;
goto|goto
name|t2_fail
goto|;
block|}
name|OSAL_MEM_ZERO
argument_list|(
operator|*
name|p_virt
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|total_size
operator|-=
name|size
expr_stmt|;
block|}
comment|/* Set the t2 pointers */
comment|/* entries per page - must be a power of two */
name|ent_per_page
operator|=
name|psz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|first_free
operator|=
operator|(
name|u64
operator|)
name|p_mngr
operator|->
name|t2
index|[
literal|0
index|]
operator|.
name|p_phys
expr_stmt|;
name|p_t2
operator|=
operator|&
name|p_mngr
operator|->
name|t2
index|[
operator|(
name|conn_num
operator|-
literal|1
operator|)
operator|/
name|ent_per_page
index|]
expr_stmt|;
name|p_mngr
operator|->
name|last_free
operator|=
operator|(
name|u64
operator|)
name|p_t2
operator|->
name|p_phys
operator|+
operator|(
operator|(
name|conn_num
operator|-
literal|1
operator|)
operator|&
operator|(
name|ent_per_page
operator|-
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_mngr
operator|->
name|t2_num_pages
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|ent_num
init|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|ent_per_page
argument_list|,
name|conn_num
argument_list|)
decl_stmt|;
name|struct
name|src_ent
modifier|*
name|entries
init|=
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|p_virt
decl_stmt|;
name|u64
name|p_ent_phys
init|=
operator|(
name|u64
operator|)
name|p_mngr
operator|->
name|t2
index|[
name|i
index|]
operator|.
name|p_phys
decl_stmt|,
name|val
decl_stmt|;
name|u32
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ent_num
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|val
operator|=
name|p_ent_phys
operator|+
operator|(
name|j
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
expr_stmt|;
name|entries
index|[
name|j
index|]
operator|.
name|next
operator|=
name|OSAL_CPU_TO_BE64
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|p_mngr
operator|->
name|t2_num_pages
operator|-
literal|1
condition|)
name|val
operator|=
operator|(
name|u64
operator|)
name|p_mngr
operator|->
name|t2
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p_phys
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|entries
index|[
name|j
index|]
operator|.
name|next
operator|=
name|OSAL_CPU_TO_BE64
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|conn_num
operator|-=
name|ent_num
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
name|t2_fail
label|:
name|ecore_cxt_src_t2_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_define
define|#
directive|define
name|for_each_ilt_valid_client
parameter_list|(
name|pos
parameter_list|,
name|clients
parameter_list|)
define|\
value|for (pos = 0; pos< ILT_CLI_MAX; pos++)	\ 		if (!clients[pos].active) {	\ 			continue;		\ 		} else
end_define

begin_comment
unit|\
comment|/* Total number of ILT lines used by this PF */
end_comment

begin_function
specifier|static
name|u32
name|ecore_cxt_ilt_shadow_size
parameter_list|(
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|ilt_clients
parameter_list|)
block|{
name|u32
name|size
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|for_each_ilt_valid_client
argument_list|(
argument|i
argument_list|,
argument|ilt_clients
argument_list|)
name|size
operator|+=
operator|(
name|ilt_clients
index|[
name|i
index|]
operator|.
name|last
operator|.
name|val
operator|-
name|ilt_clients
index|[
name|i
index|]
operator|.
name|first
operator|.
name|val
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_shadow_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
decl_stmt|;
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|ilt_size
decl_stmt|,
name|i
decl_stmt|;
name|ilt_size
operator|=
name|ecore_cxt_ilt_shadow_size
argument_list|(
name|p_cli
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p_mngr
operator|->
name|ilt_shadow
operator|&&
name|i
operator|<
name|ilt_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ecore_dma_mem
modifier|*
name|p_dma
init|=
operator|&
name|p_mngr
operator|->
name|ilt_shadow
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|p_dma
operator|->
name|p_virt
condition|)
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_dma
operator|->
name|p_virt
argument_list|,
name|p_dma
operator|->
name|p_phys
argument_list|,
name|p_dma
operator|->
name|size
argument_list|)
expr_stmt|;
name|p_dma
operator|->
name|p_virt
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_mngr
operator|->
name|ilt_shadow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_ilt_blk_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_blk
parameter_list|,
name|enum
name|ilt_clients
name|ilt_client
parameter_list|,
name|u32
name|start_line_offset
parameter_list|)
block|{
name|struct
name|ecore_dma_mem
modifier|*
name|ilt_shadow
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
decl_stmt|;
name|u32
name|lines
decl_stmt|,
name|line
decl_stmt|,
name|sz_left
decl_stmt|,
name|lines_to_skip
init|=
literal|0
decl_stmt|;
comment|/* Special handling for RoCE that supports dynamic allocation */
if|if
condition|(
name|ECORE_IS_RDMA_PERSONALITY
argument_list|(
name|p_hwfn
argument_list|)
operator|&&
operator|(
operator|(
name|ilt_client
operator|==
name|ILT_CLI_CDUT
operator|)
operator|||
name|ilt_client
operator|==
name|ILT_CLI_TSDM
operator|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|lines_to_skip
operator|=
name|p_blk
operator|->
name|dynamic_line_cnt
expr_stmt|;
if|if
condition|(
operator|!
name|p_blk
operator|->
name|total_size
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|sz_left
operator|=
name|p_blk
operator|->
name|total_size
expr_stmt|;
name|lines
operator|=
name|DIV_ROUND_UP
argument_list|(
name|sz_left
argument_list|,
name|p_blk
operator|->
name|real_size_in_page
argument_list|)
operator|-
name|lines_to_skip
expr_stmt|;
name|line
operator|=
name|p_blk
operator|->
name|start_line
operator|+
name|start_line_offset
operator|-
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|pf_start_line
operator|+
name|lines_to_skip
expr_stmt|;
for|for
control|(
init|;
name|lines
condition|;
name|lines
operator|--
control|)
block|{
name|dma_addr_t
name|p_phys
decl_stmt|;
name|void
modifier|*
name|p_virt
decl_stmt|;
name|u32
name|size
decl_stmt|;
name|size
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|sz_left
argument_list|,
name|p_blk
operator|->
name|real_size_in_page
argument_list|)
expr_stmt|;
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_phys
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
return|return
name|ECORE_NOMEM
return|;
name|OSAL_MEM_ZERO
argument_list|(
name|p_virt
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ilt_shadow
index|[
name|line
index|]
operator|.
name|p_phys
operator|=
name|p_phys
expr_stmt|;
name|ilt_shadow
index|[
name|line
index|]
operator|.
name|p_virt
operator|=
name|p_virt
expr_stmt|;
name|ilt_shadow
index|[
name|line
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_ILT
argument_list|,
literal|"ILT shadow: Line [%d] Physical 0x%llx Virtual %p Size %d\n"
argument_list|,
name|line
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|p_phys
argument_list|,
name|p_virt
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sz_left
operator|-=
name|size
expr_stmt|;
name|line
operator|++
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_ilt_shadow_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|clients
init|=
name|p_mngr
operator|->
name|clients
decl_stmt|;
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_blk
decl_stmt|;
name|u32
name|size
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|size
operator|=
name|ecore_cxt_ilt_shadow_size
argument_list|(
name|clients
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|ilt_shadow
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_dma_mem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mngr
operator|->
name|ilt_shadow
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate ilt shadow table\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_NOMEM
expr_stmt|;
goto|goto
name|ilt_shadow_fail
goto|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_ILT
argument_list|,
literal|"Allocated 0x%x bytes for ilt shadow\n"
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_dma_mem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|for_each_ilt_valid_client
argument_list|(
argument|i
argument_list|,
argument|clients
argument_list|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ILT_CLI_PF_BLOCKS
condition|;
name|j
operator|++
control|)
block|{
name|p_blk
operator|=
operator|&
name|clients
index|[
name|i
index|]
operator|.
name|pf_blks
index|[
name|j
index|]
expr_stmt|;
name|rc
operator|=
name|ecore_ilt_blk_alloc
argument_list|(
name|p_hwfn
argument_list|,
name|p_blk
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
goto|goto
name|ilt_shadow_fail
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|p_mngr
operator|->
name|vf_count
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ILT_CLI_VF_BLOCKS
condition|;
name|j
operator|++
control|)
block|{
name|u32
name|lines
init|=
name|clients
index|[
name|i
index|]
operator|.
name|vf_total_lines
operator|*
name|k
decl_stmt|;
name|p_blk
operator|=
operator|&
name|clients
index|[
name|i
index|]
operator|.
name|vf_blks
index|[
name|j
index|]
expr_stmt|;
name|rc
operator|=
name|ecore_ilt_blk_alloc
argument_list|(
name|p_hwfn
argument_list|,
name|p_blk
argument_list|,
name|i
argument_list|,
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
goto|goto
name|ilt_shadow_fail
goto|;
block|}
block|}
block|}
return|return
name|ECORE_SUCCESS
return|;
name|ilt_shadow_fail
label|:
name|ecore_ilt_shadow_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_cid_map_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|type
decl_stmt|,
name|vf
decl_stmt|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|MAX_CONN_TYPES
condition|;
name|type
operator|++
control|)
block|{
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_mngr
operator|->
name|acquired
index|[
name|type
index|]
operator|.
name|cid_map
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|acquired
index|[
name|type
index|]
operator|.
name|max_count
operator|=
literal|0
expr_stmt|;
name|p_mngr
operator|->
name|acquired
index|[
name|type
index|]
operator|.
name|start_cid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vf
operator|=
literal|0
init|;
name|vf
operator|<
name|COMMON_MAX_NUM_VFS
condition|;
name|vf
operator|++
control|)
block|{
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_mngr
operator|->
name|acquired_vf
index|[
name|type
index|]
index|[
name|vf
index|]
operator|.
name|cid_map
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|acquired_vf
index|[
name|type
index|]
index|[
name|vf
index|]
operator|.
name|max_count
operator|=
literal|0
expr_stmt|;
name|p_mngr
operator|->
name|acquired_vf
index|[
name|type
index|]
index|[
name|vf
index|]
operator|.
name|start_cid
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_cid_map_alloc_single
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|type
parameter_list|,
name|u32
name|cid_start
parameter_list|,
name|u32
name|cid_count
parameter_list|,
name|struct
name|ecore_cid_acquired_map
modifier|*
name|p_map
parameter_list|)
block|{
name|u32
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|cid_count
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|size
operator|=
name|MAP_WORD_SIZE
operator|*
name|DIV_ROUND_UP
argument_list|(
name|cid_count
argument_list|,
name|BITS_PER_MAP_WORD
argument_list|)
expr_stmt|;
name|p_map
operator|->
name|cid_map
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_map
operator|->
name|cid_map
operator|==
name|OSAL_NULL
condition|)
return|return
name|ECORE_NOMEM
return|;
name|p_map
operator|->
name|max_count
operator|=
name|cid_count
expr_stmt|;
name|p_map
operator|->
name|start_cid
operator|=
name|cid_start
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_CXT
argument_list|,
literal|"Type %08x start: %08x count %08x\n"
argument_list|,
name|type
argument_list|,
name|p_map
operator|->
name|start_cid
argument_list|,
name|p_map
operator|->
name|max_count
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_cid_map_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|start_cid
init|=
literal|0
decl_stmt|,
name|vf_start_cid
init|=
literal|0
decl_stmt|;
name|u32
name|type
decl_stmt|,
name|vf
decl_stmt|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|MAX_CONN_TYPES
condition|;
name|type
operator|++
control|)
block|{
name|struct
name|ecore_conn_type_cfg
modifier|*
name|p_cfg
init|=
operator|&
name|p_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
decl_stmt|;
name|struct
name|ecore_cid_acquired_map
modifier|*
name|p_map
decl_stmt|;
comment|/* Handle PF maps */
name|p_map
operator|=
operator|&
name|p_mngr
operator|->
name|acquired
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|ecore_cid_map_alloc_single
argument_list|(
name|p_hwfn
argument_list|,
name|type
argument_list|,
name|start_cid
argument_list|,
name|p_cfg
operator|->
name|cid_count
argument_list|,
name|p_map
argument_list|)
condition|)
goto|goto
name|cid_map_fail
goto|;
comment|/* Handle VF maps */
for|for
control|(
name|vf
operator|=
literal|0
init|;
name|vf
operator|<
name|COMMON_MAX_NUM_VFS
condition|;
name|vf
operator|++
control|)
block|{
name|p_map
operator|=
operator|&
name|p_mngr
operator|->
name|acquired_vf
index|[
name|type
index|]
index|[
name|vf
index|]
expr_stmt|;
if|if
condition|(
name|ecore_cid_map_alloc_single
argument_list|(
name|p_hwfn
argument_list|,
name|type
argument_list|,
name|vf_start_cid
argument_list|,
name|p_cfg
operator|->
name|cids_per_vf
argument_list|,
name|p_map
argument_list|)
condition|)
goto|goto
name|cid_map_fail
goto|;
block|}
name|start_cid
operator|+=
name|p_cfg
operator|->
name|cid_count
expr_stmt|;
name|vf_start_cid
operator|+=
name|p_cfg
operator|->
name|cids_per_vf
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
name|cid_map_fail
label|:
name|ecore_cid_map_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_mngr_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|clients
decl_stmt|;
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|p_mngr
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_mngr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mngr
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `struct ecore_cxt_mngr'\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* Initialize ILT client registers */
name|clients
operator|=
name|p_mngr
operator|->
name|clients
expr_stmt|;
name|clients
index|[
name|ILT_CLI_CDUC
index|]
operator|.
name|first
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|CDUC
argument_list|,
name|FIRST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_CDUC
index|]
operator|.
name|last
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|CDUC
argument_list|,
name|LAST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_CDUC
index|]
operator|.
name|p_size
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|CDUC
argument_list|,
name|P_SIZE
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_QM
index|]
operator|.
name|first
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|QM
argument_list|,
name|FIRST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_QM
index|]
operator|.
name|last
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|QM
argument_list|,
name|LAST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_QM
index|]
operator|.
name|p_size
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|QM
argument_list|,
name|P_SIZE
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_TM
index|]
operator|.
name|first
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|TM
argument_list|,
name|FIRST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_TM
index|]
operator|.
name|last
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|TM
argument_list|,
name|LAST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_TM
index|]
operator|.
name|p_size
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|TM
argument_list|,
name|P_SIZE
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_SRC
index|]
operator|.
name|first
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|SRC
argument_list|,
name|FIRST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_SRC
index|]
operator|.
name|last
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|SRC
argument_list|,
name|LAST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_SRC
index|]
operator|.
name|p_size
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|SRC
argument_list|,
name|P_SIZE
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_CDUT
index|]
operator|.
name|first
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|CDUT
argument_list|,
name|FIRST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_CDUT
index|]
operator|.
name|last
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|CDUT
argument_list|,
name|LAST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_CDUT
index|]
operator|.
name|p_size
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|CDUT
argument_list|,
name|P_SIZE
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_TSDM
index|]
operator|.
name|first
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|TSDM
argument_list|,
name|FIRST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_TSDM
index|]
operator|.
name|last
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|TSDM
argument_list|,
name|LAST_ILT
argument_list|)
expr_stmt|;
name|clients
index|[
name|ILT_CLI_TSDM
index|]
operator|.
name|p_size
operator|.
name|reg
operator|=
name|ILT_CFG_REG
argument_list|(
name|TSDM
argument_list|,
name|P_SIZE
argument_list|)
expr_stmt|;
comment|/* default ILT page size for all clients is 64K */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ILT_CLI_MAX
condition|;
name|i
operator|++
control|)
name|p_mngr
operator|->
name|clients
index|[
name|i
index|]
operator|.
name|p_size
operator|.
name|val
operator|=
name|ILT_DEFAULT_HW_P_SIZE
expr_stmt|;
comment|/* Initialize task sizes */
name|p_mngr
operator|->
name|task_type_size
index|[
literal|0
index|]
operator|=
name|TYPE0_TASK_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|p_mngr
operator|->
name|task_type_size
index|[
literal|1
index|]
operator|=
name|TYPE1_TASK_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
condition|)
name|p_mngr
operator|->
name|vf_count
operator|=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
operator|->
name|total_vfs
expr_stmt|;
comment|/* Initialize the dynamic ILT allocation mutex */
ifdef|#
directive|ifdef
name|CONFIG_ECORE_LOCK_ALLOC
name|OSAL_MUTEX_ALLOC
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_mngr
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OSAL_MUTEX_INIT
argument_list|(
operator|&
name|p_mngr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* Set the cxt mangr pointer priori to further allocations */
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|=
name|p_mngr
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_tables_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* Allocate the ILT shadow table */
name|rc
operator|=
name|ecore_ilt_shadow_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate ilt memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|tables_alloc_fail
goto|;
block|}
comment|/* Allocate the T2  table */
name|rc
operator|=
name|ecore_cxt_src_t2_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate T2 memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|tables_alloc_fail
goto|;
block|}
comment|/* Allocate and initialize the acquired cids bitmaps */
name|rc
operator|=
name|ecore_cid_map_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate cid maps\n"
argument_list|)
expr_stmt|;
goto|goto
name|tables_alloc_fail
goto|;
block|}
return|return
name|ECORE_SUCCESS
return|;
name|tables_alloc_fail
label|:
name|ecore_cxt_mngr_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_cxt_mngr_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_cxt_mngr
condition|)
return|return;
name|ecore_cid_map_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_cxt_src_t2_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_ilt_shadow_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_LOCK_ALLOC
name|OSAL_MUTEX_DEALLOC
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|p_cxt_mngr
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_cxt_mngr_setup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_cid_acquired_map
modifier|*
name|p_map
decl_stmt|;
name|struct
name|ecore_conn_type_cfg
modifier|*
name|p_cfg
decl_stmt|;
name|int
name|type
decl_stmt|;
name|u32
name|len
decl_stmt|;
comment|/* Reset acquired cids */
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|MAX_CONN_TYPES
condition|;
name|type
operator|++
control|)
block|{
name|u32
name|vf
decl_stmt|;
name|p_cfg
operator|=
operator|&
name|p_mngr
operator|->
name|conn_cfg
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|p_cfg
operator|->
name|cid_count
condition|)
block|{
name|p_map
operator|=
operator|&
name|p_mngr
operator|->
name|acquired
index|[
name|type
index|]
expr_stmt|;
name|len
operator|=
name|DIV_ROUND_UP
argument_list|(
name|p_map
operator|->
name|max_count
argument_list|,
name|BITS_PER_MAP_WORD
argument_list|)
operator|*
name|MAP_WORD_SIZE
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
name|p_map
operator|->
name|cid_map
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p_cfg
operator|->
name|cids_per_vf
condition|)
continue|continue;
for|for
control|(
name|vf
operator|=
literal|0
init|;
name|vf
operator|<
name|COMMON_MAX_NUM_VFS
condition|;
name|vf
operator|++
control|)
block|{
name|p_map
operator|=
operator|&
name|p_mngr
operator|->
name|acquired_vf
index|[
name|type
index|]
index|[
name|vf
index|]
expr_stmt|;
name|len
operator|=
name|DIV_ROUND_UP
argument_list|(
name|p_map
operator|->
name|max_count
argument_list|,
name|BITS_PER_MAP_WORD
argument_list|)
operator|*
name|MAP_WORD_SIZE
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
name|p_map
operator|->
name|cid_map
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* HW initialization helper (per Block, per phase) */
end_comment

begin_comment
comment|/* CDU Common */
end_comment

begin_define
define|#
directive|define
name|CDUC_CXT_SIZE_SHIFT
define|\
value|CDU_REG_CID_ADDR_PARAMS_CONTEXT_SIZE_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUC_CXT_SIZE_MASK
define|\
value|(CDU_REG_CID_ADDR_PARAMS_CONTEXT_SIZE>> CDUC_CXT_SIZE_SHIFT)
end_define

begin_define
define|#
directive|define
name|CDUC_BLOCK_WASTE_SHIFT
define|\
value|CDU_REG_CID_ADDR_PARAMS_BLOCK_WASTE_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUC_BLOCK_WASTE_MASK
define|\
value|(CDU_REG_CID_ADDR_PARAMS_BLOCK_WASTE>> CDUC_BLOCK_WASTE_SHIFT)
end_define

begin_define
define|#
directive|define
name|CDUC_NCIB_SHIFT
define|\
value|CDU_REG_CID_ADDR_PARAMS_NCIB_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUC_NCIB_MASK
define|\
value|(CDU_REG_CID_ADDR_PARAMS_NCIB>> CDUC_NCIB_SHIFT)
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE0_CXT_SIZE_SHIFT
define|\
value|CDU_REG_SEGMENT0_PARAMS_T0_TID_SIZE_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE0_CXT_SIZE_MASK
define|\
value|(CDU_REG_SEGMENT0_PARAMS_T0_TID_SIZE>>				\ 	CDUT_TYPE0_CXT_SIZE_SHIFT)
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE0_BLOCK_WASTE_SHIFT
define|\
value|CDU_REG_SEGMENT0_PARAMS_T0_TID_BLOCK_WASTE_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE0_BLOCK_WASTE_MASK
define|\
value|(CDU_REG_SEGMENT0_PARAMS_T0_TID_BLOCK_WASTE>>			\ 	CDUT_TYPE0_BLOCK_WASTE_SHIFT)
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE0_NCIB_SHIFT
define|\
value|CDU_REG_SEGMENT0_PARAMS_T0_NUM_TIDS_IN_BLOCK_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE0_NCIB_MASK
define|\
value|(CDU_REG_SEGMENT0_PARAMS_T0_NUM_TIDS_IN_BLOCK>>		\ 	CDUT_TYPE0_NCIB_SHIFT)
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE1_CXT_SIZE_SHIFT
define|\
value|CDU_REG_SEGMENT1_PARAMS_T1_TID_SIZE_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE1_CXT_SIZE_MASK
define|\
value|(CDU_REG_SEGMENT1_PARAMS_T1_TID_SIZE>>				\ 	CDUT_TYPE1_CXT_SIZE_SHIFT)
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE1_BLOCK_WASTE_SHIFT
define|\
value|CDU_REG_SEGMENT1_PARAMS_T1_TID_BLOCK_WASTE_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE1_BLOCK_WASTE_MASK
define|\
value|(CDU_REG_SEGMENT1_PARAMS_T1_TID_BLOCK_WASTE>>			\ 	CDUT_TYPE1_BLOCK_WASTE_SHIFT)
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE1_NCIB_SHIFT
define|\
value|CDU_REG_SEGMENT1_PARAMS_T1_NUM_TIDS_IN_BLOCK_SHIFT
end_define

begin_define
define|#
directive|define
name|CDUT_TYPE1_NCIB_MASK
define|\
value|(CDU_REG_SEGMENT1_PARAMS_T1_NUM_TIDS_IN_BLOCK>>		\ 	CDUT_TYPE1_NCIB_SHIFT)
end_define

begin_function
specifier|static
name|void
name|ecore_cdu_init_common
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|page_sz
decl_stmt|,
name|elems_per_page
decl_stmt|,
name|block_waste
decl_stmt|,
name|cxt_size
decl_stmt|,
name|cdu_params
init|=
literal|0
decl_stmt|;
comment|/* CDUC - connection configuration */
name|page_sz
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUC
index|]
operator|.
name|p_size
operator|.
name|val
expr_stmt|;
name|cxt_size
operator|=
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|elems_per_page
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|page_sz
argument_list|)
operator|/
name|cxt_size
expr_stmt|;
name|block_waste
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|page_sz
argument_list|)
operator|-
name|elems_per_page
operator|*
name|cxt_size
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
name|CDUC_CXT_SIZE
argument_list|,
name|cxt_size
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
name|CDUC_BLOCK_WASTE
argument_list|,
name|block_waste
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
operator|(
name|u32
operator|)
name|CDUC_NCIB
argument_list|,
name|elems_per_page
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|CDU_REG_CID_ADDR_PARAMS_RT_OFFSET
argument_list|,
name|cdu_params
argument_list|)
expr_stmt|;
comment|/* CDUT - type-0 tasks configuration */
name|page_sz
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
operator|.
name|p_size
operator|.
name|val
expr_stmt|;
name|cxt_size
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|task_type_size
index|[
literal|0
index|]
expr_stmt|;
name|elems_per_page
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|page_sz
argument_list|)
operator|/
name|cxt_size
expr_stmt|;
name|block_waste
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|page_sz
argument_list|)
operator|-
name|elems_per_page
operator|*
name|cxt_size
expr_stmt|;
comment|/* cxt size and block-waste are multipes of 8 */
name|cdu_params
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
operator|(
name|u32
operator|)
name|CDUT_TYPE0_CXT_SIZE
argument_list|,
operator|(
name|cxt_size
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
name|CDUT_TYPE0_BLOCK_WASTE
argument_list|,
operator|(
name|block_waste
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
name|CDUT_TYPE0_NCIB
argument_list|,
name|elems_per_page
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|CDU_REG_SEGMENT0_PARAMS_RT_OFFSET
argument_list|,
name|cdu_params
argument_list|)
expr_stmt|;
comment|/* CDUT - type-1 tasks configuration */
name|cxt_size
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|task_type_size
index|[
literal|1
index|]
expr_stmt|;
name|elems_per_page
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|page_sz
argument_list|)
operator|/
name|cxt_size
expr_stmt|;
name|block_waste
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|page_sz
argument_list|)
operator|-
name|elems_per_page
operator|*
name|cxt_size
expr_stmt|;
comment|/* cxt size and block-waste are multipes of 8 */
name|cdu_params
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
operator|(
name|u32
operator|)
name|CDUT_TYPE1_CXT_SIZE
argument_list|,
operator|(
name|cxt_size
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
name|CDUT_TYPE1_BLOCK_WASTE
argument_list|,
operator|(
name|block_waste
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_params
argument_list|,
name|CDUT_TYPE1_NCIB
argument_list|,
name|elems_per_page
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|CDU_REG_SEGMENT1_PARAMS_RT_OFFSET
argument_list|,
name|cdu_params
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CDU PF */
end_comment

begin_define
define|#
directive|define
name|CDU_SEG_REG_TYPE_SHIFT
value|CDU_SEG_TYPE_OFFSET_REG_TYPE_SHIFT
end_define

begin_define
define|#
directive|define
name|CDU_SEG_REG_TYPE_MASK
value|0x1
end_define

begin_define
define|#
directive|define
name|CDU_SEG_REG_OFFSET_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|CDU_SEG_REG_OFFSET_MASK
value|CDU_SEG_TYPE_OFFSET_REG_OFFSET_MASK
end_define

begin_function
specifier|static
name|void
name|ecore_cdu_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|struct
name|ecore_tid_seg
modifier|*
name|p_seg
decl_stmt|;
name|u32
name|cdu_seg_params
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|u32
name|rt_type_offset_arr
index|[]
init|=
block|{
name|CDU_REG_PF_SEG0_TYPE_OFFSET_RT_OFFSET
block|,
name|CDU_REG_PF_SEG1_TYPE_OFFSET_RT_OFFSET
block|,
name|CDU_REG_PF_SEG2_TYPE_OFFSET_RT_OFFSET
block|,
name|CDU_REG_PF_SEG3_TYPE_OFFSET_RT_OFFSET
block|}
decl_stmt|;
specifier|static
specifier|const
name|u32
name|rt_type_offset_fl_arr
index|[]
init|=
block|{
name|CDU_REG_PF_FL_SEG0_TYPE_OFFSET_RT_OFFSET
block|,
name|CDU_REG_PF_FL_SEG1_TYPE_OFFSET_RT_OFFSET
block|,
name|CDU_REG_PF_FL_SEG2_TYPE_OFFSET_RT_OFFSET
block|,
name|CDU_REG_PF_FL_SEG3_TYPE_OFFSET_RT_OFFSET
block|}
decl_stmt|;
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
expr_stmt|;
comment|/* There are initializations only for CDUT during pf Phase */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TASK_PF_SEGMENTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Segment 0*/
name|p_seg
operator|=
name|ecore_cxt_tid_seg_info
argument_list|(
name|p_hwfn
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_seg
condition|)
continue|continue;
comment|/* Note: start_line is already adjusted for the CDU 		 * segment register granularity, so we just need to 		 * divide. Adjustment is implicit as we assume ILT 		 * Page size is larger than 32K! 		 */
name|offset
operator|=
operator|(
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
operator|*
operator|(
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
name|i
argument_list|)
index|]
operator|.
name|start_line
operator|-
name|p_cli
operator|->
name|first
operator|.
name|val
operator|)
operator|)
operator|/
name|CDUT_SEG_ALIGNMET_IN_BYTES
expr_stmt|;
name|cdu_seg_params
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_seg_params
argument_list|,
name|CDU_SEG_REG_TYPE
argument_list|,
name|p_seg
operator|->
name|type
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_seg_params
argument_list|,
name|CDU_SEG_REG_OFFSET
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|rt_type_offset_arr
index|[
name|i
index|]
argument_list|,
name|cdu_seg_params
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
operator|*
operator|(
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_FL_SEG_BLK
argument_list|(
name|i
argument_list|,
name|PF
argument_list|)
index|]
operator|.
name|start_line
operator|-
name|p_cli
operator|->
name|first
operator|.
name|val
operator|)
operator|)
operator|/
name|CDUT_SEG_ALIGNMET_IN_BYTES
expr_stmt|;
name|cdu_seg_params
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_seg_params
argument_list|,
name|CDU_SEG_REG_TYPE
argument_list|,
name|p_seg
operator|->
name|type
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cdu_seg_params
argument_list|,
name|CDU_SEG_REG_OFFSET
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|rt_type_offset_fl_arr
index|[
name|i
index|]
argument_list|,
name|cdu_seg_params
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_qm_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|struct
name|ecore_qm_iids
name|iids
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|iids
argument_list|,
sizeof|sizeof
argument_list|(
name|iids
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_cxt_qm_iids
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|iids
argument_list|)
expr_stmt|;
name|ecore_qm_pf_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|port_id
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|,
name|qm_info
operator|->
name|max_phys_tcs_per_port
argument_list|,
name|iids
operator|.
name|cids
argument_list|,
name|iids
operator|.
name|vf_cids
argument_list|,
name|iids
operator|.
name|tids
argument_list|,
name|qm_info
operator|->
name|start_pq
argument_list|,
name|qm_info
operator|->
name|num_pqs
operator|-
name|qm_info
operator|->
name|num_vf_pqs
argument_list|,
name|qm_info
operator|->
name|num_vf_pqs
argument_list|,
name|qm_info
operator|->
name|start_vport
argument_list|,
name|qm_info
operator|->
name|num_vports
argument_list|,
name|qm_info
operator|->
name|pf_wfq
argument_list|,
name|qm_info
operator|->
name|pf_rl
argument_list|,
name|p_hwfn
operator|->
name|qm_info
operator|.
name|qm_pq_params
argument_list|,
name|p_hwfn
operator|->
name|qm_info
operator|.
name|qm_vport_params
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CM PF */
end_comment

begin_function
specifier|static
name|void
name|ecore_cm_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|XCM_REG_CON_PHY_Q3_RT_OFFSET
argument_list|,
name|ecore_get_cm_pq_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_LB
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DQ PF */
end_comment

begin_function
specifier|static
name|void
name|ecore_dq_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|dq_pf_max_cid
init|=
literal|0
decl_stmt|,
name|dq_vf_max_cid
init|=
literal|0
decl_stmt|;
name|dq_pf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|0
index|]
operator|.
name|cid_count
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_PF_MAX_ICID_0_RT_OFFSET
argument_list|,
name|dq_pf_max_cid
argument_list|)
expr_stmt|;
name|dq_vf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|0
index|]
operator|.
name|cids_per_vf
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_VF_MAX_ICID_0_RT_OFFSET
argument_list|,
name|dq_vf_max_cid
argument_list|)
expr_stmt|;
name|dq_pf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|1
index|]
operator|.
name|cid_count
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_PF_MAX_ICID_1_RT_OFFSET
argument_list|,
name|dq_pf_max_cid
argument_list|)
expr_stmt|;
name|dq_vf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|1
index|]
operator|.
name|cids_per_vf
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_VF_MAX_ICID_1_RT_OFFSET
argument_list|,
name|dq_vf_max_cid
argument_list|)
expr_stmt|;
name|dq_pf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|2
index|]
operator|.
name|cid_count
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_PF_MAX_ICID_2_RT_OFFSET
argument_list|,
name|dq_pf_max_cid
argument_list|)
expr_stmt|;
name|dq_vf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|2
index|]
operator|.
name|cids_per_vf
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_VF_MAX_ICID_2_RT_OFFSET
argument_list|,
name|dq_vf_max_cid
argument_list|)
expr_stmt|;
name|dq_pf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|3
index|]
operator|.
name|cid_count
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_PF_MAX_ICID_3_RT_OFFSET
argument_list|,
name|dq_pf_max_cid
argument_list|)
expr_stmt|;
name|dq_vf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|3
index|]
operator|.
name|cids_per_vf
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_VF_MAX_ICID_3_RT_OFFSET
argument_list|,
name|dq_vf_max_cid
argument_list|)
expr_stmt|;
name|dq_pf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|4
index|]
operator|.
name|cid_count
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_PF_MAX_ICID_4_RT_OFFSET
argument_list|,
name|dq_pf_max_cid
argument_list|)
expr_stmt|;
name|dq_vf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|4
index|]
operator|.
name|cids_per_vf
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_VF_MAX_ICID_4_RT_OFFSET
argument_list|,
name|dq_vf_max_cid
argument_list|)
expr_stmt|;
name|dq_pf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|5
index|]
operator|.
name|cid_count
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_PF_MAX_ICID_5_RT_OFFSET
argument_list|,
name|dq_pf_max_cid
argument_list|)
expr_stmt|;
name|dq_vf_max_cid
operator|+=
operator|(
name|p_mngr
operator|->
name|conn_cfg
index|[
literal|5
index|]
operator|.
name|cids_per_vf
operator|>>
name|DQ_RANGE_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_VF_MAX_ICID_5_RT_OFFSET
argument_list|,
name|dq_vf_max_cid
argument_list|)
expr_stmt|;
comment|/* Connection types 6& 7 are not in use, yet they must be configured 	 * as the highest possible connection. Not configuring them means the 	 * defaults will be  used, and with a large number of cids a bug may 	 * occur, if the defaults will be smaller than dq_pf_max_cid / 	 * dq_vf_max_cid. 	 */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_PF_MAX_ICID_6_RT_OFFSET
argument_list|,
name|dq_pf_max_cid
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_VF_MAX_ICID_6_RT_OFFSET
argument_list|,
name|dq_vf_max_cid
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_PF_MAX_ICID_7_RT_OFFSET
argument_list|,
name|dq_pf_max_cid
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_VF_MAX_ICID_7_RT_OFFSET
argument_list|,
name|dq_vf_max_cid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_bounds_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|ilt_clients
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ilt_clients
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
expr_stmt|;
name|for_each_ilt_valid_client
argument_list|(
argument|i
argument_list|,
argument|ilt_clients
argument_list|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|ilt_clients
index|[
name|i
index|]
operator|.
name|first
operator|.
name|reg
argument_list|,
name|ilt_clients
index|[
name|i
index|]
operator|.
name|first
operator|.
name|val
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|ilt_clients
index|[
name|i
index|]
operator|.
name|last
operator|.
name|reg
argument_list|,
name|ilt_clients
index|[
name|i
index|]
operator|.
name|last
operator|.
name|val
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|ilt_clients
index|[
name|i
index|]
operator|.
name|p_size
operator|.
name|reg
argument_list|,
name|ilt_clients
index|[
name|i
index|]
operator|.
name|p_size
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_vf_bounds_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|u32
name|blk_factor
decl_stmt|;
comment|/* For simplicty  we set the 'block' to be an ILT page */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
condition|)
block|{
name|struct
name|ecore_hw_sriov_info
modifier|*
name|p_iov
init|=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
decl_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_VF_BASE_RT_OFFSET
argument_list|,
name|p_iov
operator|->
name|first_vf_in_pf
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_VF_LAST_ILT_RT_OFFSET
argument_list|,
name|p_iov
operator|->
name|first_vf_in_pf
operator|+
name|p_iov
operator|->
name|total_vfs
argument_list|)
expr_stmt|;
block|}
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUC
index|]
expr_stmt|;
name|blk_factor
operator|=
name|OSAL_LOG2
argument_list|(
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_cli
operator|->
name|active
condition|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_CDUC_BLOCKS_FACTOR_RT_OFFSET
argument_list|,
name|blk_factor
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_CDUC_NUMBER_OF_PF_BLOCKS_RT_OFFSET
argument_list|,
name|p_cli
operator|->
name|pf_total_lines
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_CDUC_VF_BLOCKS_RT_OFFSET
argument_list|,
name|p_cli
operator|->
name|vf_total_lines
argument_list|)
expr_stmt|;
block|}
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
expr_stmt|;
name|blk_factor
operator|=
name|OSAL_LOG2
argument_list|(
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_cli
operator|->
name|active
condition|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_CDUT_BLOCKS_FACTOR_RT_OFFSET
argument_list|,
name|blk_factor
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_CDUT_NUMBER_OF_PF_BLOCKS_RT_OFFSET
argument_list|,
name|p_cli
operator|->
name|pf_total_lines
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_CDUT_VF_BLOCKS_RT_OFFSET
argument_list|,
name|p_cli
operator|->
name|vf_total_lines
argument_list|)
expr_stmt|;
block|}
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_TM
index|]
expr_stmt|;
name|blk_factor
operator|=
name|OSAL_LOG2
argument_list|(
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_cli
operator|->
name|active
condition|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_TM_BLOCKS_FACTOR_RT_OFFSET
argument_list|,
name|blk_factor
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_TM_NUMBER_OF_PF_BLOCKS_RT_OFFSET
argument_list|,
name|p_cli
operator|->
name|pf_total_lines
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PSWRQ2_REG_TM_VF_BLOCKS_RT_OFFSET
argument_list|,
name|p_cli
operator|->
name|vf_total_lines
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ILT (PSWRQ2) PF */
end_comment

begin_function
specifier|static
name|void
name|ecore_ilt_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|clients
decl_stmt|;
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
decl_stmt|;
name|struct
name|ecore_dma_mem
modifier|*
name|p_shdw
decl_stmt|;
name|u32
name|line
decl_stmt|,
name|rt_offst
decl_stmt|,
name|i
decl_stmt|;
name|ecore_ilt_bounds_init
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_ilt_vf_bounds_init
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|p_mngr
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
expr_stmt|;
name|p_shdw
operator|=
name|p_mngr
operator|->
name|ilt_shadow
expr_stmt|;
name|clients
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
expr_stmt|;
name|for_each_ilt_valid_client
argument_list|(
argument|i
argument_list|,
argument|clients
argument_list|)
block|{
comment|/* Client's 1st val and RT array are absolute, ILT shadows' 		 * lines are relative. 		 */
name|line
operator|=
name|clients
index|[
name|i
index|]
operator|.
name|first
operator|.
name|val
operator|-
name|p_mngr
operator|->
name|pf_start_line
expr_stmt|;
name|rt_offst
operator|=
name|PSWRQ2_REG_ILT_MEMORY_RT_OFFSET
operator|+
name|clients
index|[
name|i
index|]
operator|.
name|first
operator|.
name|val
operator|*
name|ILT_ENTRY_IN_REGS
expr_stmt|;
for|for
control|(
init|;
name|line
operator|<=
name|clients
index|[
name|i
index|]
operator|.
name|last
operator|.
name|val
operator|-
name|p_mngr
operator|->
name|pf_start_line
condition|;
name|line
operator|++
operator|,
name|rt_offst
operator|+=
name|ILT_ENTRY_IN_REGS
control|)
block|{
name|u64
name|ilt_hw_entry
init|=
literal|0
decl_stmt|;
comment|/** p_virt could be OSAL_NULL incase of dynamic 			 *  allocation 			 */
if|if
condition|(
name|p_shdw
index|[
name|line
index|]
operator|.
name|p_virt
operator|!=
name|OSAL_NULL
condition|)
block|{
name|SET_FIELD
argument_list|(
name|ilt_hw_entry
argument_list|,
name|ILT_ENTRY_VALID
argument_list|,
literal|1ULL
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ilt_hw_entry
argument_list|,
name|ILT_ENTRY_PHY_ADDR
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|p_shdw
index|[
name|line
index|]
operator|.
name|p_phys
operator|>>
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_ILT
argument_list|,
literal|"Setting RT[0x%08x] from ILT[0x%08x] [Client is %d] to Physical addr: 0x%llx\n"
argument_list|,
name|rt_offst
argument_list|,
name|line
argument_list|,
name|i
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|p_shdw
index|[
name|line
index|]
operator|.
name|p_phys
operator|>>
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|rt_offst
argument_list|,
name|ilt_hw_entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* SRC (Searcher) PF */
end_comment

begin_function
specifier|static
name|void
name|ecore_src_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|rounded_conn_num
decl_stmt|,
name|conn_num
decl_stmt|,
name|conn_max
decl_stmt|;
name|struct
name|ecore_src_iids
name|src_iids
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|src_iids
argument_list|,
sizeof|sizeof
argument_list|(
name|src_iids
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_cxt_src_iids
argument_list|(
name|p_mngr
argument_list|,
operator|&
name|src_iids
argument_list|)
expr_stmt|;
name|conn_num
operator|=
name|src_iids
operator|.
name|pf_cids
operator|+
name|src_iids
operator|.
name|per_vf_cids
operator|*
name|p_mngr
operator|->
name|vf_count
expr_stmt|;
if|if
condition|(
operator|!
name|conn_num
condition|)
return|return;
name|conn_max
operator|=
name|OSAL_MAX_T
argument_list|(
name|u32
argument_list|,
name|conn_num
argument_list|,
name|SRC_MIN_NUM_ELEMS
argument_list|)
expr_stmt|;
name|rounded_conn_num
operator|=
name|OSAL_ROUNDUP_POW_OF_TWO
argument_list|(
name|conn_max
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|SRC_REG_COUNTFREE_RT_OFFSET
argument_list|,
name|conn_num
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|SRC_REG_NUMBER_HASH_BITS_RT_OFFSET
argument_list|,
name|OSAL_LOG2
argument_list|(
name|rounded_conn_num
argument_list|)
argument_list|)
expr_stmt|;
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|SRC_REG_FIRSTFREE_RT_OFFSET
argument_list|,
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|first_free
argument_list|)
expr_stmt|;
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|SRC_REG_LASTFREE_RT_OFFSET
argument_list|,
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|last_free
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_ILT
argument_list|,
literal|"Configured SEARCHER for 0x%08x connections\n"
argument_list|,
name|conn_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Timers PF */
end_comment

begin_define
define|#
directive|define
name|TM_CFG_NUM_IDS_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|TM_CFG_NUM_IDS_MASK
value|0xFFFFULL
end_define

begin_define
define|#
directive|define
name|TM_CFG_PRE_SCAN_OFFSET_SHIFT
value|16
end_define

begin_define
define|#
directive|define
name|TM_CFG_PRE_SCAN_OFFSET_MASK
value|0x1FFULL
end_define

begin_define
define|#
directive|define
name|TM_CFG_PARENT_PF_SHIFT
value|25
end_define

begin_define
define|#
directive|define
name|TM_CFG_PARENT_PF_MASK
value|0x7ULL
end_define

begin_define
define|#
directive|define
name|TM_CFG_CID_PRE_SCAN_ROWS_SHIFT
value|30
end_define

begin_define
define|#
directive|define
name|TM_CFG_CID_PRE_SCAN_ROWS_MASK
value|0x1FFULL
end_define

begin_define
define|#
directive|define
name|TM_CFG_TID_OFFSET_SHIFT
value|30
end_define

begin_define
define|#
directive|define
name|TM_CFG_TID_OFFSET_MASK
value|0x7FFFFULL
end_define

begin_define
define|#
directive|define
name|TM_CFG_TID_PRE_SCAN_ROWS_SHIFT
value|49
end_define

begin_define
define|#
directive|define
name|TM_CFG_TID_PRE_SCAN_ROWS_MASK
value|0x1FFULL
end_define

begin_function
specifier|static
name|void
name|ecore_tm_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|active_seg_mask
init|=
literal|0
decl_stmt|,
name|tm_offset
decl_stmt|,
name|rt_reg
decl_stmt|;
name|struct
name|ecore_tm_iids
name|tm_iids
decl_stmt|;
name|u64
name|cfg_word
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|tm_iids
argument_list|,
sizeof|sizeof
argument_list|(
name|tm_iids
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_cxt_tm_iids
argument_list|(
name|p_mngr
argument_list|,
operator|&
name|tm_iids
argument_list|)
expr_stmt|;
comment|/* @@@TBD No pre-scan for now */
comment|/* Note: We assume consecutive VFs for a PF */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_mngr
operator|->
name|vf_count
condition|;
name|i
operator|++
control|)
block|{
name|cfg_word
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_NUM_IDS
argument_list|,
name|tm_iids
operator|.
name|per_vf_cids
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_PRE_SCAN_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_PARENT_PF
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_CID_PRE_SCAN_ROWS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* scan all */
name|rt_reg
operator|=
name|TM_REG_CONFIG_CONN_MEM_RT_OFFSET
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|cfg_word
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|*
operator|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
operator|->
name|first_vf_in_pf
operator|+
name|i
operator|)
expr_stmt|;
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|rt_reg
argument_list|,
name|cfg_word
argument_list|)
expr_stmt|;
block|}
name|cfg_word
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_NUM_IDS
argument_list|,
name|tm_iids
operator|.
name|pf_cids
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_PRE_SCAN_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_PARENT_PF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* n/a for PF */
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_CID_PRE_SCAN_ROWS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* scan all   */
name|rt_reg
operator|=
name|TM_REG_CONFIG_CONN_MEM_RT_OFFSET
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|cfg_word
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|*
operator|(
name|NUM_OF_VFS
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|+
name|p_hwfn
operator|->
name|rel_pf_id
operator|)
expr_stmt|;
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|rt_reg
argument_list|,
name|cfg_word
argument_list|)
expr_stmt|;
comment|/* enale scan */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|TM_REG_PF_ENABLE_CONN_RT_OFFSET
argument_list|,
name|tm_iids
operator|.
name|pf_cids
condition|?
literal|0x1
else|:
literal|0x0
argument_list|)
expr_stmt|;
comment|/* @@@TBD how to enable the scan for the VFs */
name|tm_offset
operator|=
name|tm_iids
operator|.
name|per_vf_cids
expr_stmt|;
comment|/* Note: We assume consecutive VFs for a PF */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_mngr
operator|->
name|vf_count
condition|;
name|i
operator|++
control|)
block|{
name|cfg_word
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_NUM_IDS
argument_list|,
name|tm_iids
operator|.
name|per_vf_tids
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_PRE_SCAN_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_PARENT_PF
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_TID_OFFSET
argument_list|,
name|tm_offset
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_TID_PRE_SCAN_ROWS
argument_list|,
operator|(
name|u64
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rt_reg
operator|=
name|TM_REG_CONFIG_TASK_MEM_RT_OFFSET
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|cfg_word
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|*
operator|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
operator|->
name|first_vf_in_pf
operator|+
name|i
operator|)
expr_stmt|;
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|rt_reg
argument_list|,
name|cfg_word
argument_list|)
expr_stmt|;
block|}
name|tm_offset
operator|=
name|tm_iids
operator|.
name|pf_cids
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TASK_PF_SEGMENTS
condition|;
name|i
operator|++
control|)
block|{
name|cfg_word
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_NUM_IDS
argument_list|,
name|tm_iids
operator|.
name|pf_tids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_PRE_SCAN_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_PARENT_PF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_TID_OFFSET
argument_list|,
name|tm_offset
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cfg_word
argument_list|,
name|TM_CFG_TID_PRE_SCAN_ROWS
argument_list|,
operator|(
name|u64
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rt_reg
operator|=
name|TM_REG_CONFIG_TASK_MEM_RT_OFFSET
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|cfg_word
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|*
operator|(
name|NUM_OF_VFS
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|+
name|p_hwfn
operator|->
name|rel_pf_id
operator|*
name|NUM_TASK_PF_SEGMENTS
operator|+
name|i
operator|)
expr_stmt|;
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|rt_reg
argument_list|,
name|cfg_word
argument_list|)
expr_stmt|;
name|active_seg_mask
operator||=
operator|(
name|tm_iids
operator|.
name|pf_tids
index|[
name|i
index|]
condition|?
operator|(
literal|1
operator|<<
name|i
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|tm_offset
operator|+=
name|tm_iids
operator|.
name|pf_tids
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ECORE_IS_RDMA_PERSONALITY
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|active_seg_mask
operator|=
literal|0
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|TM_REG_PF_ENABLE_TASK_RT_OFFSET
argument_list|,
name|active_seg_mask
argument_list|)
expr_stmt|;
comment|/* @@@TBD how to enable the scan for the VFs */
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_prs_init_common
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_FCOE
operator|)
operator|&&
name|p_hwfn
operator|->
name|pf_params
operator|.
name|fcoe_pf_params
operator|.
name|is_target
condition|)
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PRS_REG_SEARCH_RESP_INITIATOR_TYPE_RT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_prs_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_conn_type_cfg
modifier|*
name|p_fcoe
decl_stmt|;
name|struct
name|ecore_tid_seg
modifier|*
name|p_tid
decl_stmt|;
name|p_fcoe
operator|=
operator|&
name|p_mngr
operator|->
name|conn_cfg
index|[
name|PROTOCOLID_FCOE
index|]
expr_stmt|;
comment|/* If FCoE is active set the MAX OX_ID (tid) in the Parser */
if|if
condition|(
operator|!
name|p_fcoe
operator|->
name|cid_count
condition|)
return|return;
name|p_tid
operator|=
operator|&
name|p_fcoe
operator|->
name|tid_seg
index|[
name|ECORE_CXT_FCOE_TID_SEG
index|]
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|pf_params
operator|.
name|fcoe_pf_params
operator|.
name|is_target
condition|)
block|{
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|PRS_REG_TASK_ID_MAX_TARGET_PF_RT_OFFSET
argument_list|,
name|p_tid
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|PRS_REG_TASK_ID_MAX_INITIATOR_PF_RT_OFFSET
argument_list|,
name|p_tid
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_cxt_hw_init_common
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
comment|/* CDU configuration */
name|ecore_cdu_init_common
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_prs_init_common
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_cxt_hw_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|ecore_qm_init_pf
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_cm_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_dq_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_cdu_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_ilt_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_src_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_tm_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_prs_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|_ecore_cxt_acquire_cid
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|protocol_type
name|type
parameter_list|,
name|u32
modifier|*
name|p_cid
parameter_list|,
name|u8
name|vfid
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_cid_acquired_map
modifier|*
name|p_map
decl_stmt|;
name|u32
name|rel_cid
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|MAX_CONN_TYPES
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid protocol type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|vfid
operator|>=
name|COMMON_MAX_NUM_VFS
operator|&&
name|vfid
operator|!=
name|ECORE_CXT_PF_CID
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"VF [%02x] is out of range\n"
argument_list|,
name|vfid
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Determine the right map to take this CID from */
if|if
condition|(
name|vfid
operator|==
name|ECORE_CXT_PF_CID
condition|)
name|p_map
operator|=
operator|&
name|p_mngr
operator|->
name|acquired
index|[
name|type
index|]
expr_stmt|;
else|else
name|p_map
operator|=
operator|&
name|p_mngr
operator|->
name|acquired_vf
index|[
name|type
index|]
index|[
name|vfid
index|]
expr_stmt|;
if|if
condition|(
name|p_map
operator|->
name|cid_map
operator|==
name|OSAL_NULL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid protocol type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|rel_cid
operator|=
name|OSAL_FIND_FIRST_ZERO_BIT
argument_list|(
name|p_map
operator|->
name|cid_map
argument_list|,
name|p_map
operator|->
name|max_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_cid
operator|>=
name|p_map
operator|->
name|max_count
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"no CID available for protocol %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|ECORE_NORESOURCES
return|;
block|}
name|OSAL_SET_BIT
argument_list|(
name|rel_cid
argument_list|,
name|p_map
operator|->
name|cid_map
argument_list|)
expr_stmt|;
operator|*
name|p_cid
operator|=
name|rel_cid
operator|+
name|p_map
operator|->
name|start_cid
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_CXT
argument_list|,
literal|"Acquired cid 0x%08x [rel. %08x] vfid %02x type %d\n"
argument_list|,
operator|*
name|p_cid
argument_list|,
name|rel_cid
argument_list|,
name|vfid
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_acquire_cid
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|protocol_type
name|type
parameter_list|,
name|u32
modifier|*
name|p_cid
parameter_list|)
block|{
return|return
name|_ecore_cxt_acquire_cid
argument_list|(
name|p_hwfn
argument_list|,
name|type
argument_list|,
name|p_cid
argument_list|,
name|ECORE_CXT_PF_CID
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_cxt_test_cid_acquired
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|cid
parameter_list|,
name|u8
name|vfid
parameter_list|,
name|enum
name|protocol_type
modifier|*
name|p_type
parameter_list|,
name|struct
name|ecore_cid_acquired_map
modifier|*
modifier|*
name|pp_map
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|rel_cid
decl_stmt|;
comment|/* Iterate over protocols and find matching cid range */
for|for
control|(
operator|*
name|p_type
operator|=
literal|0
init|;
operator|*
name|p_type
operator|<
name|MAX_CONN_TYPES
condition|;
operator|(
operator|*
name|p_type
operator|)
operator|++
control|)
block|{
if|if
condition|(
name|vfid
operator|==
name|ECORE_CXT_PF_CID
condition|)
operator|*
name|pp_map
operator|=
operator|&
name|p_mngr
operator|->
name|acquired
index|[
operator|*
name|p_type
index|]
expr_stmt|;
else|else
operator|*
name|pp_map
operator|=
operator|&
name|p_mngr
operator|->
name|acquired_vf
index|[
operator|*
name|p_type
index|]
index|[
name|vfid
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|pp_map
operator|)
operator|->
name|cid_map
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cid
operator|>=
operator|(
operator|*
name|pp_map
operator|)
operator|->
name|start_cid
operator|&&
name|cid
operator|<
operator|(
operator|*
name|pp_map
operator|)
operator|->
name|start_cid
operator|+
operator|(
operator|*
name|pp_map
operator|)
operator|->
name|max_count
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p_type
operator|==
name|MAX_CONN_TYPES
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid CID %d vfid %02x"
argument_list|,
name|cid
argument_list|,
name|vfid
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rel_cid
operator|=
name|cid
operator|-
operator|(
operator|*
name|pp_map
operator|)
operator|->
name|start_cid
expr_stmt|;
if|if
condition|(
operator|!
name|OSAL_TEST_BIT
argument_list|(
name|rel_cid
argument_list|,
operator|(
operator|*
name|pp_map
operator|)
operator|->
name|cid_map
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"CID %d [vifd %02x] not acquired"
argument_list|,
name|cid
argument_list|,
name|vfid
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
name|true
return|;
name|fail
label|:
operator|*
name|p_type
operator|=
name|MAX_CONN_TYPES
expr_stmt|;
operator|*
name|pp_map
operator|=
name|OSAL_NULL
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|_ecore_cxt_release_cid
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|cid
parameter_list|,
name|u8
name|vfid
parameter_list|)
block|{
name|struct
name|ecore_cid_acquired_map
modifier|*
name|p_map
init|=
name|OSAL_NULL
decl_stmt|;
name|enum
name|protocol_type
name|type
decl_stmt|;
name|bool
name|b_acquired
decl_stmt|;
name|u32
name|rel_cid
decl_stmt|;
if|if
condition|(
name|vfid
operator|!=
name|ECORE_CXT_PF_CID
operator|&&
name|vfid
operator|>
name|COMMON_MAX_NUM_VFS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Trying to return incorrect CID belonging to VF %02x\n"
argument_list|,
name|vfid
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Test acquired and find matching per-protocol map */
name|b_acquired
operator|=
name|ecore_cxt_test_cid_acquired
argument_list|(
name|p_hwfn
argument_list|,
name|cid
argument_list|,
name|vfid
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|p_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_acquired
condition|)
return|return;
name|rel_cid
operator|=
name|cid
operator|-
name|p_map
operator|->
name|start_cid
expr_stmt|;
name|OSAL_CLEAR_BIT
argument_list|(
name|rel_cid
argument_list|,
name|p_map
operator|->
name|cid_map
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_CXT
argument_list|,
literal|"Released CID 0x%08x [rel. %08x] vfid %02x type %d\n"
argument_list|,
name|cid
argument_list|,
name|rel_cid
argument_list|,
name|vfid
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_cxt_release_cid
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|cid
parameter_list|)
block|{
name|_ecore_cxt_release_cid
argument_list|(
name|p_hwfn
argument_list|,
name|cid
argument_list|,
name|ECORE_CXT_PF_CID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_get_cid_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_cxt_info
modifier|*
name|p_info
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_cid_acquired_map
modifier|*
name|p_map
init|=
name|OSAL_NULL
decl_stmt|;
name|u32
name|conn_cxt_size
decl_stmt|,
name|hw_p_size
decl_stmt|,
name|cxts_per_p
decl_stmt|,
name|line
decl_stmt|;
name|enum
name|protocol_type
name|type
decl_stmt|;
name|bool
name|b_acquired
decl_stmt|;
comment|/* Test acquired and find matching per-protocol map */
name|b_acquired
operator|=
name|ecore_cxt_test_cid_acquired
argument_list|(
name|p_hwfn
argument_list|,
name|p_info
operator|->
name|iid
argument_list|,
name|ECORE_CXT_PF_CID
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|p_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_acquired
condition|)
return|return
name|ECORE_INVAL
return|;
comment|/* set the protocl type */
name|p_info
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* compute context virtual pointer */
name|hw_p_size
operator|=
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUC
index|]
operator|.
name|p_size
operator|.
name|val
expr_stmt|;
name|conn_cxt_size
operator|=
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|cxts_per_p
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|hw_p_size
argument_list|)
operator|/
name|conn_cxt_size
expr_stmt|;
name|line
operator|=
name|p_info
operator|->
name|iid
operator|/
name|cxts_per_p
expr_stmt|;
comment|/* Make sure context is allocated (dynamic allocation) */
if|if
condition|(
operator|!
name|p_mngr
operator|->
name|ilt_shadow
index|[
name|line
index|]
operator|.
name|p_virt
condition|)
return|return
name|ECORE_INVAL
return|;
name|p_info
operator|->
name|p_cxt
operator|=
operator|(
name|u8
operator|*
operator|)
name|p_mngr
operator|->
name|ilt_shadow
index|[
name|line
index|]
operator|.
name|p_virt
operator|+
name|p_info
operator|->
name|iid
operator|%
name|cxts_per_p
operator|*
name|conn_cxt_size
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_ILT
operator||
name|ECORE_MSG_CXT
operator|)
argument_list|,
literal|"Accessing ILT shadow[%d]: CXT pointer is at %p (for iid %d)\n"
argument_list|,
operator|(
name|p_info
operator|->
name|iid
operator|/
name|cxts_per_p
operator|)
argument_list|,
name|p_info
operator|->
name|p_cxt
argument_list|,
name|p_info
operator|->
name|iid
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_rdma_set_pf_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_rdma_pf_params
modifier|*
name|p_params
parameter_list|,
name|u32
name|num_tasks
parameter_list|)
block|{
name|u32
name|num_cons
decl_stmt|,
name|num_qps
decl_stmt|,
name|num_srqs
decl_stmt|;
name|enum
name|protocol_type
name|proto
decl_stmt|;
comment|/* Override personality with rdma flavor */
name|num_srqs
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|ECORE_RDMA_MAX_SRQS
argument_list|,
name|p_params
operator|->
name|num_srqs
argument_list|)
expr_stmt|;
comment|/* The only case RDMA personality can be overriden is if NVRAM is 	 * configured with ETH_RDMA or if no rdma protocol was requested 	 */
switch|switch
condition|(
name|p_params
operator|->
name|rdma_protocol
condition|)
block|{
case|case
name|ECORE_RDMA_PROTOCOL_DEFAULT
case|:
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|protocol
operator|==
name|ECORE_PCI_ETH_RDMA
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Current day drivers don't support RoCE& iWARP. Default to RoCE-only\n"
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|=
name|ECORE_PCI_ETH_ROCE
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_RDMA_PROTOCOL_NONE
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|=
name|ECORE_PCI_ETH
expr_stmt|;
return|return;
comment|/* intentional... nothing left to do... */
case|case
name|ECORE_RDMA_PROTOCOL_ROCE
case|:
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|protocol
operator|==
name|ECORE_PCI_ETH_RDMA
condition|)
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|=
name|ECORE_PCI_ETH_ROCE
expr_stmt|;
break|break;
case|case
name|ECORE_RDMA_PROTOCOL_IWARP
case|:
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|protocol
operator|==
name|ECORE_PCI_ETH_RDMA
condition|)
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|=
name|ECORE_PCI_ETH_IWARP
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
condition|)
block|{
case|case
name|ECORE_PCI_ETH_IWARP
case|:
comment|/* Each QP requires one connection */
name|num_cons
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|IWARP_MAX_QPS
argument_list|,
name|p_params
operator|->
name|num_qps
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_IWARP
comment|/* required for the define */
comment|/* additional connections required for passive tcp handling */
name|num_cons
operator|+=
name|ECORE_IWARP_PREALLOC_CNT
expr_stmt|;
endif|#
directive|endif
name|proto
operator|=
name|PROTOCOLID_IWARP
expr_stmt|;
name|p_params
operator|->
name|roce_edpm_mode
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|ECORE_PCI_ETH_ROCE
case|:
name|num_qps
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|ROCE_MAX_QPS
argument_list|,
name|p_params
operator|->
name|num_qps
argument_list|)
expr_stmt|;
name|num_cons
operator|=
name|num_qps
operator|*
literal|2
expr_stmt|;
comment|/* each QP requires two connections */
name|proto
operator|=
name|PROTOCOLID_ROCE
expr_stmt|;
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|num_cons
operator|&&
name|num_tasks
condition|)
block|{
name|ecore_cxt_set_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|proto
argument_list|,
name|num_cons
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Deliberatly passing ROCE for tasks id. This is because 		 * iWARP / RoCE share the task id. 		 */
name|ecore_cxt_set_proto_tid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_ROCE
argument_list|,
name|ECORE_CXT_ROCE_TID_SEG
argument_list|,
literal|1
argument_list|,
comment|/* RoCE segment type */
name|num_tasks
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* !force load */
name|ecore_cxt_set_srq_count
argument_list|(
name|p_hwfn
argument_list|,
name|num_srqs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"RDMA personality used without setting params!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_set_pf_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|rdma_tasks
parameter_list|)
block|{
comment|/* Set the number of required CORE connections */
name|u32
name|core_cids
init|=
literal|1
decl_stmt|;
comment|/* SPQ */
if|if
condition|(
name|p_hwfn
operator|->
name|using_ll2
condition|)
name|core_cids
operator|+=
literal|4
expr_stmt|;
comment|/* @@@TBD Use the proper #define */
name|ecore_cxt_set_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_CORE
argument_list|,
name|core_cids
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
condition|)
block|{
case|case
name|ECORE_PCI_ETH_RDMA
case|:
case|case
name|ECORE_PCI_ETH_IWARP
case|:
case|case
name|ECORE_PCI_ETH_ROCE
case|:
block|{
name|ecore_rdma_set_pf_params
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_hwfn
operator|->
name|pf_params
operator|.
name|rdma_pf_params
argument_list|,
name|rdma_tasks
argument_list|)
expr_stmt|;
comment|/* no need for break since RoCE coexist with Ethernet */
block|}
case|case
name|ECORE_PCI_ETH
case|:
block|{
name|struct
name|ecore_eth_pf_params
modifier|*
name|p_params
init|=
operator|&
name|p_hwfn
operator|->
name|pf_params
operator|.
name|eth_pf_params
decl_stmt|;
if|if
condition|(
operator|!
name|p_params
operator|->
name|num_vf_cons
condition|)
name|p_params
operator|->
name|num_vf_cons
operator|=
name|ETH_PF_PARAMS_VF_CONS_DEFAULT
expr_stmt|;
name|ecore_cxt_set_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_ETH
argument_list|,
name|p_params
operator|->
name|num_cons
argument_list|,
name|p_params
operator|->
name|num_vf_cons
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|arfs_count
operator|=
name|p_params
operator|->
name|num_arfs_filters
expr_stmt|;
break|break;
block|}
case|case
name|ECORE_PCI_FCOE
case|:
block|{
name|struct
name|ecore_fcoe_pf_params
modifier|*
name|p_params
decl_stmt|;
name|p_params
operator|=
operator|&
name|p_hwfn
operator|->
name|pf_params
operator|.
name|fcoe_pf_params
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|num_cons
operator|&&
name|p_params
operator|->
name|num_tasks
condition|)
block|{
name|ecore_cxt_set_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_FCOE
argument_list|,
name|p_params
operator|->
name|num_cons
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_cxt_set_proto_tid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_FCOE
argument_list|,
name|ECORE_CXT_FCOE_TID_SEG
argument_list|,
literal|0
argument_list|,
comment|/* segment type */
name|p_params
operator|->
name|num_tasks
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Fcoe personality used without setting params!\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ECORE_PCI_ISCSI
case|:
block|{
name|struct
name|ecore_iscsi_pf_params
modifier|*
name|p_params
decl_stmt|;
name|p_params
operator|=
operator|&
name|p_hwfn
operator|->
name|pf_params
operator|.
name|iscsi_pf_params
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|num_cons
operator|&&
name|p_params
operator|->
name|num_tasks
condition|)
block|{
name|ecore_cxt_set_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_ISCSI
argument_list|,
name|p_params
operator|->
name|num_cons
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_cxt_set_proto_tid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_ISCSI
argument_list|,
name|ECORE_CXT_ISCSI_TID_SEG
argument_list|,
literal|0
argument_list|,
comment|/* segment type */
name|p_params
operator|->
name|num_tasks
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Iscsi personality used without setting params!\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_get_tid_mem_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_tid_mem
modifier|*
name|p_info
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|u32
name|proto
decl_stmt|,
name|seg
decl_stmt|,
name|total_lines
decl_stmt|,
name|i
decl_stmt|,
name|shadow_line
decl_stmt|;
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_fl_seg
decl_stmt|;
name|struct
name|ecore_tid_seg
modifier|*
name|p_seg_info
decl_stmt|;
comment|/* Verify the personality */
switch|switch
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
condition|)
block|{
case|case
name|ECORE_PCI_FCOE
case|:
name|proto
operator|=
name|PROTOCOLID_FCOE
expr_stmt|;
name|seg
operator|=
name|ECORE_CXT_FCOE_TID_SEG
expr_stmt|;
break|break;
case|case
name|ECORE_PCI_ISCSI
case|:
name|proto
operator|=
name|PROTOCOLID_ISCSI
expr_stmt|;
name|seg
operator|=
name|ECORE_CXT_ISCSI_TID_SEG
expr_stmt|;
break|break;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
name|p_cli
operator|=
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p_cli
operator|->
name|active
condition|)
block|{
return|return
name|ECORE_INVAL
return|;
block|}
name|p_seg_info
operator|=
operator|&
name|p_mngr
operator|->
name|conn_cfg
index|[
name|proto
index|]
operator|.
name|tid_seg
index|[
name|seg
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p_seg_info
operator|->
name|has_fl_mem
condition|)
return|return
name|ECORE_INVAL
return|;
name|p_fl_seg
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_FL_SEG_BLK
argument_list|(
name|seg
argument_list|,
name|PF
argument_list|)
index|]
expr_stmt|;
name|total_lines
operator|=
name|DIV_ROUND_UP
argument_list|(
name|p_fl_seg
operator|->
name|total_size
argument_list|,
name|p_fl_seg
operator|->
name|real_size_in_page
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_lines
condition|;
name|i
operator|++
control|)
block|{
name|shadow_line
operator|=
name|i
operator|+
name|p_fl_seg
operator|->
name|start_line
operator|-
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|pf_start_line
expr_stmt|;
name|p_info
operator|->
name|blocks
index|[
name|i
index|]
operator|=
name|p_mngr
operator|->
name|ilt_shadow
index|[
name|shadow_line
index|]
operator|.
name|p_virt
expr_stmt|;
block|}
name|p_info
operator|->
name|waste
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|p_cli
operator|->
name|p_size
operator|.
name|val
argument_list|)
operator|-
name|p_fl_seg
operator|->
name|real_size_in_page
expr_stmt|;
name|p_info
operator|->
name|tid_size
operator|=
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg_info
operator|->
name|type
index|]
expr_stmt|;
name|p_info
operator|->
name|num_tids_per_block
operator|=
name|p_fl_seg
operator|->
name|real_size_in_page
operator|/
name|p_info
operator|->
name|tid_size
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* This function is very RoCE oriented, if another protocol in the future  * will want this feature we'll need to modify the function to be more generic  */
end_comment

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_dynamic_ilt_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_cxt_elem_type
name|elem_type
parameter_list|,
name|u32
name|iid
parameter_list|)
block|{
name|u32
name|reg_offset
decl_stmt|,
name|shadow_line
decl_stmt|,
name|elem_size
decl_stmt|,
name|hw_p_size
decl_stmt|,
name|elems_per_p
decl_stmt|,
name|line
decl_stmt|;
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_blk
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|dma_addr_t
name|p_phys
decl_stmt|;
name|u64
name|ilt_hw_entry
decl_stmt|;
name|void
modifier|*
name|p_virt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
switch|switch
condition|(
name|elem_type
condition|)
block|{
case|case
name|ECORE_ELEM_CXT
case|:
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUC
index|]
expr_stmt|;
name|elem_size
operator|=
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|p_blk
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUC_BLK
index|]
expr_stmt|;
break|break;
case|case
name|ECORE_ELEM_SRQ
case|:
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_TSDM
index|]
expr_stmt|;
name|elem_size
operator|=
name|SRQ_CXT_SIZE
expr_stmt|;
name|p_blk
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|SRQ_BLK
index|]
expr_stmt|;
break|break;
case|case
name|ECORE_ELEM_TASK
case|:
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
expr_stmt|;
name|elem_size
operator|=
name|TYPE1_TASK_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|p_blk
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
name|ECORE_CXT_ROCE_TID_SEG
argument_list|)
index|]
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"ECORE_INVALID elem type = %d"
argument_list|,
name|elem_type
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Calculate line in ilt */
name|hw_p_size
operator|=
name|p_cli
operator|->
name|p_size
operator|.
name|val
expr_stmt|;
name|elems_per_p
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|hw_p_size
argument_list|)
operator|/
name|elem_size
expr_stmt|;
name|line
operator|=
name|p_blk
operator|->
name|start_line
operator|+
operator|(
name|iid
operator|/
name|elems_per_p
operator|)
expr_stmt|;
name|shadow_line
operator|=
name|line
operator|-
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|pf_start_line
expr_stmt|;
comment|/* If line is already allocated, do nothing, otherwise allocate it and 	 * write it to the PSWRQ2 registers. 	 * This section can be run in parallel from different contexts and thus 	 * a mutex protection is needed. 	 */
name|OSAL_MUTEX_ACQUIRE
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|shadow_line
index|]
operator|.
name|p_virt
condition|)
goto|goto
name|out0
goto|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"ECORE_TIME_OUT on ptt acquire - dynamic allocation"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_TIMEOUT
expr_stmt|;
goto|goto
name|out0
goto|;
block|}
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_phys
argument_list|,
name|p_blk
operator|->
name|real_size_in_page
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
block|{
name|rc
operator|=
name|ECORE_NOMEM
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|OSAL_MEM_ZERO
argument_list|(
name|p_virt
argument_list|,
name|p_blk
operator|->
name|real_size_in_page
argument_list|)
expr_stmt|;
comment|/* configuration of refTagMask to 0xF is required for RoCE DIF MR only, 	 * to compensate for a HW bug, but it is configured even if DIF is not 	 * enabled. This is harmless and allows us to avoid a dedicated API. We 	 * configure the field for all of the contexts on the newly allocated 	 * page. 	 */
if|if
condition|(
name|elem_type
operator|==
name|ECORE_ELEM_TASK
condition|)
block|{
name|u32
name|elem_i
decl_stmt|;
name|u8
modifier|*
name|elem_start
init|=
operator|(
name|u8
operator|*
operator|)
name|p_virt
decl_stmt|;
name|union
name|type1_task_context
modifier|*
name|elem
decl_stmt|;
for|for
control|(
name|elem_i
operator|=
literal|0
init|;
name|elem_i
operator|<
name|elems_per_p
condition|;
name|elem_i
operator|++
control|)
block|{
name|elem
operator|=
operator|(
expr|union
name|type1_task_context
operator|*
operator|)
name|elem_start
expr_stmt|;
name|SET_FIELD
argument_list|(
name|elem
operator|->
name|roce_ctx
operator|.
name|tdif_context
operator|.
name|flags1
argument_list|,
name|TDIF_TASK_CONTEXT_REFTAGMASK
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
name|elem_start
operator|+=
name|TYPE1_TASK_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
block|}
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|shadow_line
index|]
operator|.
name|p_virt
operator|=
name|p_virt
expr_stmt|;
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|shadow_line
index|]
operator|.
name|p_phys
operator|=
name|p_phys
expr_stmt|;
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|shadow_line
index|]
operator|.
name|size
operator|=
name|p_blk
operator|->
name|real_size_in_page
expr_stmt|;
comment|/* compute absolute offset */
name|reg_offset
operator|=
name|PSWRQ2_REG_ILT_MEMORY
operator|+
operator|(
name|line
operator|*
name|ILT_REG_SIZE_IN_BYTES
operator|*
name|ILT_ENTRY_IN_REGS
operator|)
expr_stmt|;
name|ilt_hw_entry
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ilt_hw_entry
argument_list|,
name|ILT_ENTRY_VALID
argument_list|,
literal|1ULL
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ilt_hw_entry
argument_list|,
name|ILT_ENTRY_PHY_ADDR
argument_list|,
operator|(
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|shadow_line
index|]
operator|.
name|p_phys
operator|>>
literal|12
operator|)
argument_list|)
expr_stmt|;
comment|/* Write via DMAE since the PSWRQ2_REG_ILT_MEMORY line is a wide-bus */
name|ecore_dmae_host2grc
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
operator|&
name|ilt_hw_entry
argument_list|,
name|reg_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|ilt_hw_entry
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
comment|/* no flags */
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem_type
operator|==
name|ECORE_ELEM_CXT
condition|)
block|{
name|u32
name|last_cid_allocated
init|=
operator|(
literal|1
operator|+
operator|(
name|iid
operator|/
name|elems_per_p
operator|)
operator|)
operator|*
name|elems_per_p
decl_stmt|;
comment|/* Update the relevant register in the parser */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ROCE_DEST_QP_MAX_PF
argument_list|,
name|last_cid_allocated
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* RoCE w/a -> we don't write to the prs search reg until first 		 * cid is allocated. This is because the prs checks 		 * last_cid-1>=0 making 0 a valid value... this will cause 		 * the a context load to occur on a RoCE packet received with 		 * cid=0 even before context was initialized, can happen with a 		 * stray packet from switch or a packet with crc-error 		 */
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|b_rdma_enabled_in_prs
condition|)
block|{
comment|/* Enable Rdma search */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|rdma_prs_search_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|b_rdma_enabled_in_prs
operator|=
name|true
expr_stmt|;
block|}
block|}
name|out1
label|:
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|out0
label|:
name|OSAL_MUTEX_RELEASE
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* This function is very RoCE oriented, if another protocol in the future  * will want this feature we'll need to modify the function to be more generic  */
end_comment

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_free_ilt_range
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_cxt_elem_type
name|elem_type
parameter_list|,
name|u32
name|start_iid
parameter_list|,
name|u32
name|count
parameter_list|)
block|{
name|u32
name|start_line
decl_stmt|,
name|end_line
decl_stmt|,
name|shadow_start_line
decl_stmt|,
name|shadow_end_line
decl_stmt|;
name|u32
name|reg_offset
decl_stmt|,
name|elem_size
decl_stmt|,
name|hw_p_size
decl_stmt|,
name|elems_per_p
decl_stmt|;
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_blk
decl_stmt|;
name|u32
name|end_iid
init|=
name|start_iid
operator|+
name|count
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|u64
name|ilt_hw_entry
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
switch|switch
condition|(
name|elem_type
condition|)
block|{
case|case
name|ECORE_ELEM_CXT
case|:
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUC
index|]
expr_stmt|;
name|elem_size
operator|=
name|CONN_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|p_blk
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUC_BLK
index|]
expr_stmt|;
break|break;
case|case
name|ECORE_ELEM_SRQ
case|:
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_TSDM
index|]
expr_stmt|;
name|elem_size
operator|=
name|SRQ_CXT_SIZE
expr_stmt|;
name|p_blk
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|SRQ_BLK
index|]
expr_stmt|;
break|break;
case|case
name|ECORE_ELEM_TASK
case|:
name|p_cli
operator|=
operator|&
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
expr_stmt|;
name|elem_size
operator|=
name|TYPE1_TASK_CXT_SIZE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|p_blk
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
name|ECORE_CXT_ROCE_TID_SEG
argument_list|)
index|]
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"ECORE_INVALID elem type = %d"
argument_list|,
name|elem_type
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Calculate line in ilt */
name|hw_p_size
operator|=
name|p_cli
operator|->
name|p_size
operator|.
name|val
expr_stmt|;
name|elems_per_p
operator|=
name|ILT_PAGE_IN_BYTES
argument_list|(
name|hw_p_size
argument_list|)
operator|/
name|elem_size
expr_stmt|;
name|start_line
operator|=
name|p_blk
operator|->
name|start_line
operator|+
operator|(
name|start_iid
operator|/
name|elems_per_p
operator|)
expr_stmt|;
name|end_line
operator|=
name|p_blk
operator|->
name|start_line
operator|+
operator|(
name|end_iid
operator|/
name|elems_per_p
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|end_iid
operator|+
literal|1
operator|)
operator|/
name|elems_per_p
operator|)
operator|!=
operator|(
name|end_iid
operator|/
name|elems_per_p
operator|)
condition|)
name|end_line
operator|--
expr_stmt|;
name|shadow_start_line
operator|=
name|start_line
operator|-
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|pf_start_line
expr_stmt|;
name|shadow_end_line
operator|=
name|end_line
operator|-
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|pf_start_line
expr_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"ECORE_TIME_OUT on ptt acquire - dynamic allocation"
argument_list|)
expr_stmt|;
return|return
name|ECORE_TIMEOUT
return|;
block|}
for|for
control|(
name|i
operator|=
name|shadow_start_line
init|;
name|i
operator|<
name|shadow_end_line
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|i
index|]
operator|.
name|p_virt
condition|)
continue|continue;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|i
index|]
operator|.
name|p_virt
argument_list|,
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|i
index|]
operator|.
name|p_phys
argument_list|,
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|i
index|]
operator|.
name|p_virt
operator|=
name|OSAL_NULL
expr_stmt|;
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|i
index|]
operator|.
name|p_phys
operator|=
literal|0
expr_stmt|;
name|p_hwfn
operator|->
name|p_cxt_mngr
operator|->
name|ilt_shadow
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
comment|/* compute absolute offset */
name|reg_offset
operator|=
name|PSWRQ2_REG_ILT_MEMORY
operator|+
operator|(
operator|(
name|start_line
operator|++
operator|)
operator|*
name|ILT_REG_SIZE_IN_BYTES
operator|*
name|ILT_ENTRY_IN_REGS
operator|)
expr_stmt|;
comment|/* Write via DMAE since the PSWRQ2_REG_ILT_MEMORY line is a 		 * wide-bus. 		 */
name|ecore_dmae_host2grc
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
operator|&
name|ilt_hw_entry
argument_list|,
name|reg_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|ilt_hw_entry
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
comment|/* no flags */
argument_list|)
expr_stmt|;
block|}
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_cxt_get_task_ctx
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|tid
parameter_list|,
name|u8
name|ctx_type
parameter_list|,
name|void
modifier|*
modifier|*
name|pp_task_ctx
parameter_list|)
block|{
name|struct
name|ecore_cxt_mngr
modifier|*
name|p_mngr
init|=
name|p_hwfn
operator|->
name|p_cxt_mngr
decl_stmt|;
name|struct
name|ecore_ilt_client_cfg
modifier|*
name|p_cli
decl_stmt|;
name|struct
name|ecore_tid_seg
modifier|*
name|p_seg_info
decl_stmt|;
name|struct
name|ecore_ilt_cli_blk
modifier|*
name|p_seg
decl_stmt|;
name|u32
name|num_tids_per_block
decl_stmt|;
name|u32
name|tid_size
decl_stmt|,
name|ilt_idx
decl_stmt|;
name|u32
name|total_lines
decl_stmt|;
name|u32
name|proto
decl_stmt|,
name|seg
decl_stmt|;
comment|/* Verify the personality */
switch|switch
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
condition|)
block|{
case|case
name|ECORE_PCI_FCOE
case|:
name|proto
operator|=
name|PROTOCOLID_FCOE
expr_stmt|;
name|seg
operator|=
name|ECORE_CXT_FCOE_TID_SEG
expr_stmt|;
break|break;
case|case
name|ECORE_PCI_ISCSI
case|:
name|proto
operator|=
name|PROTOCOLID_ISCSI
expr_stmt|;
name|seg
operator|=
name|ECORE_CXT_ISCSI_TID_SEG
expr_stmt|;
break|break;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
name|p_cli
operator|=
operator|&
name|p_mngr
operator|->
name|clients
index|[
name|ILT_CLI_CDUT
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p_cli
operator|->
name|active
condition|)
block|{
return|return
name|ECORE_INVAL
return|;
block|}
name|p_seg_info
operator|=
operator|&
name|p_mngr
operator|->
name|conn_cfg
index|[
name|proto
index|]
operator|.
name|tid_seg
index|[
name|seg
index|]
expr_stmt|;
if|if
condition|(
name|ctx_type
operator|==
name|ECORE_CTX_WORKING_MEM
condition|)
block|{
name|p_seg
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_SEG_BLK
argument_list|(
name|seg
argument_list|)
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx_type
operator|==
name|ECORE_CTX_FL_MEM
condition|)
block|{
if|if
condition|(
operator|!
name|p_seg_info
operator|->
name|has_fl_mem
condition|)
block|{
return|return
name|ECORE_INVAL
return|;
block|}
name|p_seg
operator|=
operator|&
name|p_cli
operator|->
name|pf_blks
index|[
name|CDUT_FL_SEG_BLK
argument_list|(
name|seg
argument_list|,
name|PF
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
name|ECORE_INVAL
return|;
block|}
name|total_lines
operator|=
name|DIV_ROUND_UP
argument_list|(
name|p_seg
operator|->
name|total_size
argument_list|,
name|p_seg
operator|->
name|real_size_in_page
argument_list|)
expr_stmt|;
name|tid_size
operator|=
name|p_mngr
operator|->
name|task_type_size
index|[
name|p_seg_info
operator|->
name|type
index|]
expr_stmt|;
name|num_tids_per_block
operator|=
name|p_seg
operator|->
name|real_size_in_page
operator|/
name|tid_size
expr_stmt|;
if|if
condition|(
name|total_lines
operator|<
name|tid
operator|/
name|num_tids_per_block
condition|)
return|return
name|ECORE_INVAL
return|;
name|ilt_idx
operator|=
name|tid
operator|/
name|num_tids_per_block
operator|+
name|p_seg
operator|->
name|start_line
operator|-
name|p_mngr
operator|->
name|pf_start_line
expr_stmt|;
operator|*
name|pp_task_ctx
operator|=
operator|(
name|u8
operator|*
operator|)
name|p_mngr
operator|->
name|ilt_shadow
index|[
name|ilt_idx
index|]
operator|.
name|p_virt
operator|+
operator|(
name|tid
operator|%
name|num_tids_per_block
operator|)
operator|*
name|tid_size
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

end_unit

