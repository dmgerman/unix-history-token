begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * File : ecore_dev.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bcm_osal.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_gtt_reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore.h"
end_include

begin_include
include|#
directive|include
file|"ecore_chain.h"
end_include

begin_include
include|#
directive|include
file|"ecore_status.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw.h"
end_include

begin_include
include|#
directive|include
file|"ecore_rt_defs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_ops.h"
end_include

begin_include
include|#
directive|include
file|"ecore_int.h"
end_include

begin_include
include|#
directive|include
file|"ecore_cxt.h"
end_include

begin_include
include|#
directive|include
file|"ecore_spq.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_fw_funcs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_sp_commands.h"
end_include

begin_include
include|#
directive|include
file|"ecore_dev_api.h"
end_include

begin_include
include|#
directive|include
file|"ecore_sriov.h"
end_include

begin_include
include|#
directive|include
file|"ecore_vf.h"
end_include

begin_include
include|#
directive|include
file|"ecore_ll2.h"
end_include

begin_include
include|#
directive|include
file|"ecore_fcoe.h"
end_include

begin_include
include|#
directive|include
file|"ecore_iscsi.h"
end_include

begin_include
include|#
directive|include
file|"ecore_ooo.h"
end_include

begin_include
include|#
directive|include
file|"ecore_mcp.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw_defs.h"
end_include

begin_include
include|#
directive|include
file|"mcp_public.h"
end_include

begin_include
include|#
directive|include
file|"ecore_roce.h"
end_include

begin_include
include|#
directive|include
file|"ecore_iro.h"
end_include

begin_include
include|#
directive|include
file|"nvm_cfg.h"
end_include

begin_include
include|#
directive|include
file|"ecore_dev_api.h"
end_include

begin_include
include|#
directive|include
file|"ecore_dcbx.h"
end_include

begin_include
include|#
directive|include
file|"pcics_reg_driver.h"
end_include

begin_include
include|#
directive|include
file|"ecore_l2.h"
end_include

begin_comment
comment|/* TODO - there's a bug in DCBx re-configuration flows in MF, as the QM  * registers involved are not split and thus configuration is a race where  * some of the PFs configuration might be lost.  * Eventually, this needs to move into a MFW-covered HW-lock as arbitration  * mechanism as this doesn't cover some cases [E.g., PDA or scenarios where  * there's more than a single compiled ecore component in system].  */
end_comment

begin_decl_stmt
specifier|static
name|osal_spinlock_t
name|qm_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|qm_lock_init
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configurable */
end_comment

begin_define
define|#
directive|define
name|ECORE_MIN_DPIS
value|(4)
end_define

begin_comment
comment|/* The minimal number of DPIs required to 				      * load the driver. The number was 				      * arbitrarily set. 				      */
end_comment

begin_comment
comment|/* Derived */
end_comment

begin_define
define|#
directive|define
name|ECORE_MIN_PWM_REGION
value|((ECORE_WID_SIZE) * (ECORE_MIN_DPIS))
end_define

begin_enum
enum|enum
name|BAR_ID
block|{
name|BAR_ID_0
block|,
comment|/* used for GRC */
name|BAR_ID_1
comment|/* Used for doorbells */
block|}
enum|;
end_enum

begin_function
specifier|static
name|u32
name|ecore_hw_bar_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|BAR_ID
name|bar_id
parameter_list|)
block|{
name|u32
name|bar_reg
init|=
operator|(
name|bar_id
operator|==
name|BAR_ID_0
condition|?
name|PGLUE_B_REG_PF_BAR0_SIZE
else|:
name|PGLUE_B_REG_PF_BAR1_SIZE
operator|)
decl_stmt|;
name|u32
name|val
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
comment|/* TODO - assume each VF hwfn has 64Kb for Bar0; Bar1 can be 		 * read from actual register, but we're currently not using 		 * it for actual doorbelling. 		 */
return|return
literal|1
operator|<<
literal|17
return|;
block|}
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|bar_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
literal|1
operator|<<
operator|(
name|val
operator|+
literal|15
operator|)
return|;
comment|/* The above registers were updated in the past only in CMT mode. Since 	 * they were found to be useful MFW started updating them from 8.7.7.0. 	 * In older MFW versions they are set to 0 which means disabled. 	 */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"BAR size not configured. Assuming BAR size of 256kB for GRC and 512kB for DB\n"
argument_list|)
expr_stmt|;
return|return
name|BAR_ID_0
condition|?
literal|256
operator|*
literal|1024
else|:
literal|512
operator|*
literal|1024
return|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"BAR size not configured. Assuming BAR size of 512kB for GRC and 512kB for DB\n"
argument_list|)
expr_stmt|;
return|return
literal|512
operator|*
literal|1024
return|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_dp
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
name|dp_module
parameter_list|,
name|u8
name|dp_level
parameter_list|,
name|void
modifier|*
name|dp_ctx
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|p_dev
operator|->
name|dp_level
operator|=
name|dp_level
expr_stmt|;
name|p_dev
operator|->
name|dp_module
operator|=
name|dp_module
expr_stmt|;
name|p_dev
operator|->
name|dp_ctx
operator|=
name|dp_ctx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_HWFNS_PER_DEVICE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|p_hwfn
operator|->
name|dp_level
operator|=
name|dp_level
expr_stmt|;
name|p_hwfn
operator|->
name|dp_module
operator|=
name|dp_module
expr_stmt|;
name|p_hwfn
operator|->
name|dp_ctx
operator|=
name|dp_ctx
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_struct
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|u8
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_HWFNS_PER_DEVICE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|p_hwfn
operator|->
name|p_dev
operator|=
name|p_dev
expr_stmt|;
name|p_hwfn
operator|->
name|my_id
operator|=
name|i
expr_stmt|;
name|p_hwfn
operator|->
name|b_active
operator|=
name|false
expr_stmt|;
name|OSAL_MUTEX_ALLOC
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|OSAL_MUTEX_INIT
argument_list|(
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
comment|/* hwfn 0 is always active */
name|p_dev
operator|->
name|hwfns
index|[
literal|0
index|]
operator|.
name|b_active
operator|=
name|true
expr_stmt|;
comment|/* set the default cache alignment to 128 (may be overridden later) */
name|p_dev
operator|->
name|cache_shift
operator|=
literal|7
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_qm_info_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|qm_info
operator|->
name|qm_pq_params
argument_list|)
expr_stmt|;
name|qm_info
operator|->
name|qm_pq_params
operator|=
name|OSAL_NULL
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|qm_info
operator|->
name|qm_vport_params
argument_list|)
expr_stmt|;
name|qm_info
operator|->
name|qm_vport_params
operator|=
name|OSAL_NULL
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|qm_info
operator|->
name|qm_port_params
argument_list|)
expr_stmt|;
name|qm_info
operator|->
name|qm_port_params
operator|=
name|OSAL_NULL
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|qm_info
operator|->
name|wfq_data
argument_list|)
expr_stmt|;
name|qm_info
operator|->
name|wfq_data
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_resc_free
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
name|ecore_l2_free
argument_list|(
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|OSAL_FREE
argument_list|(
name|p_dev
argument_list|,
name|p_dev
operator|->
name|fw_data
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|fw_data
operator|=
name|OSAL_NULL
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_dev
argument_list|,
name|p_dev
operator|->
name|reset_stats
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|reset_stats
operator|=
name|OSAL_NULL
expr_stmt|;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|ecore_cxt_mngr_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_qm_info_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_spq_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_eq_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_consq_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_int_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_LL2
name|ecore_ll2_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_FCOE
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_FCOE
condition|)
name|ecore_fcoe_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ISCSI
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_ISCSI
condition|)
block|{
name|ecore_iscsi_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_ooo_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ecore_iov_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_l2_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_dmae_info_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_dcbx_info_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* @@@TBD Flush work-queue ?*/
block|}
block|}
end_function

begin_comment
comment|/******************** QM initialization *******************/
end_comment

begin_comment
comment|/* bitmaps for indicating active traffic classes. Special case for Arrowhead 4 port */
end_comment

begin_define
define|#
directive|define
name|ACTIVE_TCS_BMAP
value|0x9f
end_define

begin_comment
comment|/* 0..3 actualy used, 4 serves OOO, 7 serves high priority stuff (e.g. DCQCN) */
end_comment

begin_define
define|#
directive|define
name|ACTIVE_TCS_BMAP_4PORT_K2
value|0xf
end_define

begin_comment
comment|/* 0..3 actually used, OOO and high priority stuff all use 3 */
end_comment

begin_comment
comment|/* determines the physical queue flags for a given PF. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_get_pq_flags
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|flags
decl_stmt|;
comment|/* common flags */
name|flags
operator|=
name|PQ_FLAGS_LB
expr_stmt|;
comment|/* feature flags */
if|if
condition|(
name|IS_ECORE_SRIOV
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|flags
operator||=
name|PQ_FLAGS_VFS
expr_stmt|;
if|if
condition|(
name|IS_ECORE_DCQCN
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|flags
operator||=
name|PQ_FLAGS_RLS
expr_stmt|;
comment|/* protocol flags */
switch|switch
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
condition|)
block|{
case|case
name|ECORE_PCI_ETH
case|:
name|flags
operator||=
name|PQ_FLAGS_MCOS
expr_stmt|;
break|break;
case|case
name|ECORE_PCI_FCOE
case|:
name|flags
operator||=
name|PQ_FLAGS_OFLD
expr_stmt|;
break|break;
case|case
name|ECORE_PCI_ISCSI
case|:
name|flags
operator||=
name|PQ_FLAGS_ACK
operator||
name|PQ_FLAGS_OOO
operator||
name|PQ_FLAGS_OFLD
expr_stmt|;
break|break;
case|case
name|ECORE_PCI_ETH_ROCE
case|:
name|flags
operator||=
name|PQ_FLAGS_MCOS
operator||
name|PQ_FLAGS_OFLD
operator||
name|PQ_FLAGS_LLT
expr_stmt|;
break|break;
case|case
name|ECORE_PCI_ETH_IWARP
case|:
name|flags
operator||=
name|PQ_FLAGS_MCOS
operator||
name|PQ_FLAGS_ACK
operator||
name|PQ_FLAGS_OOO
operator||
name|PQ_FLAGS_OFLD
expr_stmt|;
break|break;
default|default:
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"unknown personality %d\n"
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Getters for resource amounts necessary for qm initialization */
end_comment

begin_function
name|u8
name|ecore_init_qm_get_num_tcs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
return|return
name|p_hwfn
operator|->
name|hw_info
operator|.
name|num_hw_tc
return|;
block|}
end_function

begin_function
name|u16
name|ecore_init_qm_get_num_vfs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
return|return
name|IS_ECORE_SRIOV
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|?
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
operator|->
name|total_vfs
else|:
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NUM_DEFAULT_RLS
value|1
end_define

begin_function
name|u16
name|ecore_init_qm_get_num_pf_rls
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u16
name|num_pf_rls
decl_stmt|,
name|num_vfs
init|=
name|ecore_init_qm_get_num_vfs
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
comment|/* num RLs can't exceed resource amount of rls or vports or the dcqcn qps */
name|num_pf_rls
operator|=
operator|(
name|u16
operator|)
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_RL
argument_list|)
argument_list|,
operator|(
name|u16
operator|)
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VPORT
argument_list|)
argument_list|,
name|ROCE_DCQCN_RP_MAX_QPS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure after we reserve the default and VF rls we'll have something left */
if|if
condition|(
name|num_pf_rls
operator|<
name|num_vfs
operator|+
name|NUM_DEFAULT_RLS
condition|)
block|{
if|if
condition|(
name|IS_ECORE_DCQCN
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"no rate limiters left for PF rate limiting [num_pf_rls %d num_vfs %d]\n"
argument_list|,
name|num_pf_rls
argument_list|,
name|num_vfs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* subtract rls necessary for VFs and one default one for the PF */
name|num_pf_rls
operator|-=
name|num_vfs
operator|+
name|NUM_DEFAULT_RLS
expr_stmt|;
return|return
name|num_pf_rls
return|;
block|}
end_function

begin_function
name|u16
name|ecore_init_qm_get_num_vports
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|pq_flags
init|=
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
comment|/* all pqs share the same vport (hence the 1 below), except for vfs and pf_rl pqs */
return|return
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_RLS
operator|&
name|pq_flags
operator|)
operator|)
operator|*
name|ecore_init_qm_get_num_pf_rls
argument_list|(
name|p_hwfn
argument_list|)
operator|+
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_VFS
operator|&
name|pq_flags
operator|)
operator|)
operator|*
name|ecore_init_qm_get_num_vfs
argument_list|(
name|p_hwfn
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* calc amount of PQs according to the requested flags */
end_comment

begin_function
name|u16
name|ecore_init_qm_get_num_pqs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|pq_flags
init|=
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
return|return
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_RLS
operator|&
name|pq_flags
operator|)
operator|)
operator|*
name|ecore_init_qm_get_num_pf_rls
argument_list|(
name|p_hwfn
argument_list|)
operator|+
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_MCOS
operator|&
name|pq_flags
operator|)
operator|)
operator|*
name|ecore_init_qm_get_num_tcs
argument_list|(
name|p_hwfn
argument_list|)
operator|+
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_LB
operator|&
name|pq_flags
operator|)
operator|)
operator|+
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_OOO
operator|&
name|pq_flags
operator|)
operator|)
operator|+
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_ACK
operator|&
name|pq_flags
operator|)
operator|)
operator|+
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_OFLD
operator|&
name|pq_flags
operator|)
operator|)
operator|+
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_LLT
operator|&
name|pq_flags
operator|)
operator|)
operator|+
operator|(
operator|!
operator|!
operator|(
name|PQ_FLAGS_VFS
operator|&
name|pq_flags
operator|)
operator|)
operator|*
name|ecore_init_qm_get_num_vfs
argument_list|(
name|p_hwfn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* initialize the top level QM params */
end_comment

begin_function
specifier|static
name|void
name|ecore_init_qm_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|bool
name|four_port
decl_stmt|;
comment|/* pq and vport bases for this PF */
name|qm_info
operator|->
name|start_pq
operator|=
operator|(
name|u16
operator|)
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_PQ
argument_list|)
expr_stmt|;
name|qm_info
operator|->
name|start_vport
operator|=
operator|(
name|u8
operator|)
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VPORT
argument_list|)
expr_stmt|;
comment|/* rate limiting and weighted fair queueing are always enabled */
name|qm_info
operator|->
name|vport_rl_en
operator|=
literal|1
expr_stmt|;
name|qm_info
operator|->
name|vport_wfq_en
operator|=
literal|1
expr_stmt|;
comment|/* TC config is different for AH 4 port */
name|four_port
operator|=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|==
name|MAX_NUM_PORTS_K2
expr_stmt|;
comment|/* in AH 4 port we have fewer TCs per port */
name|qm_info
operator|->
name|max_phys_tcs_per_port
operator|=
name|four_port
condition|?
name|NUM_PHYS_TCS_4PORT_K2
else|:
name|NUM_OF_PHYS_TCS
expr_stmt|;
comment|/* unless MFW indicated otherwise, ooo_tc should be 3 for AH 4 port and 4 otherwise */
if|if
condition|(
operator|!
name|qm_info
operator|->
name|ooo_tc
condition|)
name|qm_info
operator|->
name|ooo_tc
operator|=
name|four_port
condition|?
name|DCBX_TCP_OOO_K2_4PORT_TC
else|:
name|DCBX_TCP_OOO_TC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize qm vport params */
end_comment

begin_function
specifier|static
name|void
name|ecore_init_qm_vport_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|u8
name|i
decl_stmt|;
comment|/* all vports participate in weighted fair queueing */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ecore_init_qm_get_num_vports
argument_list|(
name|p_hwfn
argument_list|)
condition|;
name|i
operator|++
control|)
name|qm_info
operator|->
name|qm_vport_params
index|[
name|i
index|]
operator|.
name|vport_wfq
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize qm port params */
end_comment

begin_function
specifier|static
name|void
name|ecore_init_qm_port_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
comment|/* Initialize qm port parameters */
name|u8
name|i
decl_stmt|,
name|active_phys_tcs
decl_stmt|,
name|num_ports
init|=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
decl_stmt|;
comment|/* indicate how ooo and high pri traffic is dealt with */
name|active_phys_tcs
operator|=
name|num_ports
operator|==
name|MAX_NUM_PORTS_K2
condition|?
name|ACTIVE_TCS_BMAP_4PORT_K2
else|:
name|ACTIVE_TCS_BMAP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|init_qm_port_params
modifier|*
name|p_qm_port
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
operator|.
name|qm_port_params
index|[
name|i
index|]
decl_stmt|;
name|p_qm_port
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|p_qm_port
operator|->
name|active_phys_tcs
operator|=
name|active_phys_tcs
expr_stmt|;
name|p_qm_port
operator|->
name|num_pbf_cmd_lines
operator|=
name|PBF_MAX_CMD_LINES
operator|/
name|num_ports
expr_stmt|;
name|p_qm_port
operator|->
name|num_btb_blocks
operator|=
name|BTB_MAX_BLOCKS
operator|/
name|num_ports
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reset the params which must be reset for qm init. QM init may be called as  * a result of flows other than driver load (e.g. dcbx renegotiation). Other  * params may be affected by the init but would simply recalculate to the same  * values. The allocations made for QM init, ports, vports, pqs and vfqs are not  * affected as these amounts stay the same.  */
end_comment

begin_function
specifier|static
name|void
name|ecore_init_qm_reset_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|qm_info
operator|->
name|num_pqs
operator|=
literal|0
expr_stmt|;
name|qm_info
operator|->
name|num_vports
operator|=
literal|0
expr_stmt|;
name|qm_info
operator|->
name|num_pf_rls
operator|=
literal|0
expr_stmt|;
name|qm_info
operator|->
name|num_vf_pqs
operator|=
literal|0
expr_stmt|;
name|qm_info
operator|->
name|first_vf_pq
operator|=
literal|0
expr_stmt|;
name|qm_info
operator|->
name|first_mcos_pq
operator|=
literal|0
expr_stmt|;
name|qm_info
operator|->
name|first_rl_pq
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_advance_vport
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|qm_info
operator|->
name|num_vports
operator|++
expr_stmt|;
if|if
condition|(
name|qm_info
operator|->
name|num_vports
operator|>
name|ecore_init_qm_get_num_vports
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"vport overflow! qm_info->num_vports %d, qm_init_get_num_vports() %d\n"
argument_list|,
name|qm_info
operator|->
name|num_vports
argument_list|,
name|ecore_init_qm_get_num_vports
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize a single pq and manage qm_info resources accounting.  * The pq_init_flags param determines whether the PQ is rate limited (for VF or PF)  * and whether a new vport is allocated to the pq or not (i.e. vport will be shared)  */
end_comment

begin_comment
comment|/* flags for pq init */
end_comment

begin_define
define|#
directive|define
name|PQ_INIT_SHARE_VPORT
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|PQ_INIT_PF_RL
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|PQ_INIT_VF_RL
value|(1<< 2)
end_define

begin_comment
comment|/* defines for pq init */
end_comment

begin_define
define|#
directive|define
name|PQ_INIT_DEFAULT_WRR_GROUP
value|1
end_define

begin_define
define|#
directive|define
name|PQ_INIT_DEFAULT_TC
value|0
end_define

begin_define
define|#
directive|define
name|PQ_INIT_OFLD_TC
value|(p_hwfn->hw_info.offload_tc)
end_define

begin_function
specifier|static
name|void
name|ecore_init_qm_pq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
parameter_list|,
name|u8
name|tc
parameter_list|,
name|u32
name|pq_init_flags
parameter_list|)
block|{
name|u16
name|pq_idx
init|=
name|qm_info
operator|->
name|num_pqs
decl_stmt|,
name|max_pq
init|=
name|ecore_init_qm_get_num_pqs
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pq_idx
operator|>
name|max_pq
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"pq overflow! pq %d, max pq %d\n"
argument_list|,
name|pq_idx
argument_list|,
name|max_pq
argument_list|)
expr_stmt|;
comment|/* init pq params */
name|qm_info
operator|->
name|qm_pq_params
index|[
name|pq_idx
index|]
operator|.
name|vport_id
operator|=
name|qm_info
operator|->
name|start_vport
operator|+
name|qm_info
operator|->
name|num_vports
expr_stmt|;
name|qm_info
operator|->
name|qm_pq_params
index|[
name|pq_idx
index|]
operator|.
name|tc_id
operator|=
name|tc
expr_stmt|;
name|qm_info
operator|->
name|qm_pq_params
index|[
name|pq_idx
index|]
operator|.
name|wrr_group
operator|=
name|PQ_INIT_DEFAULT_WRR_GROUP
expr_stmt|;
name|qm_info
operator|->
name|qm_pq_params
index|[
name|pq_idx
index|]
operator|.
name|rl_valid
operator|=
operator|(
name|pq_init_flags
operator|&
name|PQ_INIT_PF_RL
operator|||
name|pq_init_flags
operator|&
name|PQ_INIT_VF_RL
operator|)
expr_stmt|;
comment|/* qm params accounting */
name|qm_info
operator|->
name|num_pqs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pq_init_flags
operator|&
name|PQ_INIT_SHARE_VPORT
operator|)
condition|)
name|qm_info
operator|->
name|num_vports
operator|++
expr_stmt|;
if|if
condition|(
name|pq_init_flags
operator|&
name|PQ_INIT_PF_RL
condition|)
name|qm_info
operator|->
name|num_pf_rls
operator|++
expr_stmt|;
if|if
condition|(
name|qm_info
operator|->
name|num_vports
operator|>
name|ecore_init_qm_get_num_vports
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"vport overflow! qm_info->num_vports %d, qm_init_get_num_vports() %d\n"
argument_list|,
name|qm_info
operator|->
name|num_vports
argument_list|,
name|ecore_init_qm_get_num_vports
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qm_info
operator|->
name|num_pf_rls
operator|>
name|ecore_init_qm_get_num_pf_rls
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"rl overflow! qm_info->num_pf_rls %d, qm_init_get_num_pf_rls() %d\n"
argument_list|,
name|qm_info
operator|->
name|num_pf_rls
argument_list|,
name|ecore_init_qm_get_num_pf_rls
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get pq index according to PQ_FLAGS */
end_comment

begin_function
specifier|static
name|u16
modifier|*
name|ecore_init_qm_get_idx_from_flags
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|pq_flags
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
comment|/* Can't have multiple flags set here */
if|if
condition|(
name|OSAL_BITMAP_WEIGHT
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|pq_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|pq_flags
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
goto|goto
name|err
goto|;
switch|switch
condition|(
name|pq_flags
condition|)
block|{
case|case
name|PQ_FLAGS_RLS
case|:
return|return
operator|&
name|qm_info
operator|->
name|first_rl_pq
return|;
case|case
name|PQ_FLAGS_MCOS
case|:
return|return
operator|&
name|qm_info
operator|->
name|first_mcos_pq
return|;
case|case
name|PQ_FLAGS_LB
case|:
return|return
operator|&
name|qm_info
operator|->
name|pure_lb_pq
return|;
case|case
name|PQ_FLAGS_OOO
case|:
return|return
operator|&
name|qm_info
operator|->
name|ooo_pq
return|;
case|case
name|PQ_FLAGS_ACK
case|:
return|return
operator|&
name|qm_info
operator|->
name|pure_ack_pq
return|;
case|case
name|PQ_FLAGS_OFLD
case|:
return|return
operator|&
name|qm_info
operator|->
name|offload_pq
return|;
case|case
name|PQ_FLAGS_LLT
case|:
return|return
operator|&
name|qm_info
operator|->
name|low_latency_pq
return|;
case|case
name|PQ_FLAGS_VFS
case|:
return|return
operator|&
name|qm_info
operator|->
name|first_vf_pq
return|;
default|default:
goto|goto
name|err
goto|;
block|}
name|err
label|:
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"BAD pq flags %d\n"
argument_list|,
name|pq_flags
argument_list|)
expr_stmt|;
return|return
name|OSAL_NULL
return|;
block|}
end_function

begin_comment
comment|/* save pq index in qm info */
end_comment

begin_function
specifier|static
name|void
name|ecore_init_qm_set_idx
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|pq_flags
parameter_list|,
name|u16
name|pq_val
parameter_list|)
block|{
name|u16
modifier|*
name|base_pq_idx
init|=
name|ecore_init_qm_get_idx_from_flags
argument_list|(
name|p_hwfn
argument_list|,
name|pq_flags
argument_list|)
decl_stmt|;
operator|*
name|base_pq_idx
operator|=
name|p_hwfn
operator|->
name|qm_info
operator|.
name|start_pq
operator|+
name|pq_val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get tx pq index, with the PQ TX base already set (ready for context init) */
end_comment

begin_function
name|u16
name|ecore_get_cm_pq_idx
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|pq_flags
parameter_list|)
block|{
name|u16
modifier|*
name|base_pq_idx
init|=
name|ecore_init_qm_get_idx_from_flags
argument_list|(
name|p_hwfn
argument_list|,
name|pq_flags
argument_list|)
decl_stmt|;
return|return
operator|*
name|base_pq_idx
operator|+
name|CM_TX_PQ_BASE
return|;
block|}
end_function

begin_function
name|u16
name|ecore_get_cm_pq_idx_mcos
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|tc
parameter_list|)
block|{
name|u8
name|max_tc
init|=
name|ecore_init_qm_get_num_tcs
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
if|if
condition|(
name|tc
operator|>
name|max_tc
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"tc %d must be smaller than %d\n"
argument_list|,
name|tc
argument_list|,
name|max_tc
argument_list|)
expr_stmt|;
return|return
name|ecore_get_cm_pq_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_MCOS
argument_list|)
operator|+
name|tc
return|;
block|}
end_function

begin_function
name|u16
name|ecore_get_cm_pq_idx_vf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|vf
parameter_list|)
block|{
name|u16
name|max_vf
init|=
name|ecore_init_qm_get_num_vfs
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
if|if
condition|(
name|vf
operator|>
name|max_vf
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"vf %d must be smaller than %d\n"
argument_list|,
name|vf
argument_list|,
name|max_vf
argument_list|)
expr_stmt|;
return|return
name|ecore_get_cm_pq_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_VFS
argument_list|)
operator|+
name|vf
return|;
block|}
end_function

begin_function
name|u16
name|ecore_get_cm_pq_idx_rl
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|rl
parameter_list|)
block|{
name|u16
name|max_rl
init|=
name|ecore_init_qm_get_num_pf_rls
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|>
name|max_rl
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"rl %d must be smaller than %d\n"
argument_list|,
name|rl
argument_list|,
name|max_rl
argument_list|)
expr_stmt|;
return|return
name|ecore_get_cm_pq_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_RLS
argument_list|)
operator|+
name|rl
return|;
block|}
end_function

begin_comment
comment|/* Functions for creating specific types of pqs */
end_comment

begin_function
specifier|static
name|void
name|ecore_init_qm_lb_pq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
operator|&
name|PQ_FLAGS_LB
operator|)
condition|)
return|return;
name|ecore_init_qm_set_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_LB
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
name|ecore_init_qm_pq
argument_list|(
name|p_hwfn
argument_list|,
name|qm_info
argument_list|,
name|PURE_LB_TC
argument_list|,
name|PQ_INIT_SHARE_VPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_ooo_pq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
operator|&
name|PQ_FLAGS_OOO
operator|)
condition|)
return|return;
name|ecore_init_qm_set_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_OOO
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
name|ecore_init_qm_pq
argument_list|(
name|p_hwfn
argument_list|,
name|qm_info
argument_list|,
name|qm_info
operator|->
name|ooo_tc
argument_list|,
name|PQ_INIT_SHARE_VPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_pure_ack_pq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
operator|&
name|PQ_FLAGS_ACK
operator|)
condition|)
return|return;
name|ecore_init_qm_set_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_ACK
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
name|ecore_init_qm_pq
argument_list|(
name|p_hwfn
argument_list|,
name|qm_info
argument_list|,
name|PQ_INIT_OFLD_TC
argument_list|,
name|PQ_INIT_SHARE_VPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_offload_pq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
operator|&
name|PQ_FLAGS_OFLD
operator|)
condition|)
return|return;
name|ecore_init_qm_set_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_OFLD
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
name|ecore_init_qm_pq
argument_list|(
name|p_hwfn
argument_list|,
name|qm_info
argument_list|,
name|PQ_INIT_OFLD_TC
argument_list|,
name|PQ_INIT_SHARE_VPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_low_latency_pq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
operator|&
name|PQ_FLAGS_LLT
operator|)
condition|)
return|return;
name|ecore_init_qm_set_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_LLT
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
name|ecore_init_qm_pq
argument_list|(
name|p_hwfn
argument_list|,
name|qm_info
argument_list|,
name|PQ_INIT_OFLD_TC
argument_list|,
name|PQ_INIT_SHARE_VPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_mcos_pqs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|u8
name|tc_idx
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
operator|&
name|PQ_FLAGS_MCOS
operator|)
condition|)
return|return;
name|ecore_init_qm_set_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_MCOS
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
for|for
control|(
name|tc_idx
operator|=
literal|0
init|;
name|tc_idx
operator|<
name|ecore_init_qm_get_num_tcs
argument_list|(
name|p_hwfn
argument_list|)
condition|;
name|tc_idx
operator|++
control|)
name|ecore_init_qm_pq
argument_list|(
name|p_hwfn
argument_list|,
name|qm_info
argument_list|,
name|tc_idx
argument_list|,
name|PQ_INIT_SHARE_VPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_vf_pqs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|u16
name|vf_idx
decl_stmt|,
name|num_vfs
init|=
name|ecore_init_qm_get_num_vfs
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
operator|&
name|PQ_FLAGS_VFS
operator|)
condition|)
return|return;
name|ecore_init_qm_set_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_VFS
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
name|qm_info
operator|->
name|num_vf_pqs
operator|=
name|num_vfs
expr_stmt|;
for|for
control|(
name|vf_idx
operator|=
literal|0
init|;
name|vf_idx
operator|<
name|num_vfs
condition|;
name|vf_idx
operator|++
control|)
name|ecore_init_qm_pq
argument_list|(
name|p_hwfn
argument_list|,
name|qm_info
argument_list|,
name|PQ_INIT_DEFAULT_TC
argument_list|,
name|PQ_INIT_VF_RL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_rl_pqs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u16
name|pf_rls_idx
decl_stmt|,
name|num_pf_rls
init|=
name|ecore_init_qm_get_num_pf_rls
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
operator|&
name|PQ_FLAGS_RLS
operator|)
condition|)
return|return;
name|ecore_init_qm_set_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_RLS
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
for|for
control|(
name|pf_rls_idx
operator|=
literal|0
init|;
name|pf_rls_idx
operator|<
name|num_pf_rls
condition|;
name|pf_rls_idx
operator|++
control|)
name|ecore_init_qm_pq
argument_list|(
name|p_hwfn
argument_list|,
name|qm_info
argument_list|,
name|PQ_INIT_OFLD_TC
argument_list|,
name|PQ_INIT_PF_RL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_pq_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
comment|/* rate limited pqs, must come first (FW assumption) */
name|ecore_init_qm_rl_pqs
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* pqs for multi cos */
name|ecore_init_qm_mcos_pqs
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* pure loopback pq */
name|ecore_init_qm_lb_pq
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* out of order pq */
name|ecore_init_qm_ooo_pq
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* pure ack pq */
name|ecore_init_qm_pure_ack_pq
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* pq for offloaded protocol */
name|ecore_init_qm_offload_pq
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* low latency pq */
name|ecore_init_qm_low_latency_pq
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* done sharing vports */
name|ecore_init_qm_advance_vport
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* pqs for vfs */
name|ecore_init_qm_vf_pqs
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compare values of getters against resources amounts */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_init_qm_sanity
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
name|ecore_init_qm_get_num_vports
argument_list|(
name|p_hwfn
argument_list|)
operator|>
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VPORT
argument_list|)
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"requested amount of vports exceeds resource\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|ecore_init_qm_get_num_pqs
argument_list|(
name|p_hwfn
argument_list|)
operator|>
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_PQ
argument_list|)
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"requested amount of pqs exceeds resource\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * Function for verbose printing of the qm initialization results  */
end_comment

begin_function
specifier|static
name|void
name|ecore_dp_init_qm_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|struct
name|init_qm_vport_params
modifier|*
name|vport
decl_stmt|;
name|struct
name|init_qm_port_params
modifier|*
name|port
decl_stmt|;
name|struct
name|init_qm_pq_params
modifier|*
name|pq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tc
decl_stmt|;
comment|/* top level params */
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"qm init top level params: start_pq %d, start_vport %d, pure_lb_pq %d, offload_pq %d, pure_ack_pq %d\n"
argument_list|,
name|qm_info
operator|->
name|start_pq
argument_list|,
name|qm_info
operator|->
name|start_vport
argument_list|,
name|qm_info
operator|->
name|pure_lb_pq
argument_list|,
name|qm_info
operator|->
name|offload_pq
argument_list|,
name|qm_info
operator|->
name|pure_ack_pq
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"ooo_pq %d, first_vf_pq %d, num_pqs %d, num_vf_pqs %d, num_vports %d, max_phys_tcs_per_port %d\n"
argument_list|,
name|qm_info
operator|->
name|ooo_pq
argument_list|,
name|qm_info
operator|->
name|first_vf_pq
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|,
name|qm_info
operator|->
name|num_vf_pqs
argument_list|,
name|qm_info
operator|->
name|num_vports
argument_list|,
name|qm_info
operator|->
name|max_phys_tcs_per_port
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"pf_rl_en %d, pf_wfq_en %d, vport_rl_en %d, vport_wfq_en %d, pf_wfq %d, pf_rl %d, num_pf_rls %d, pq_flags %x\n"
argument_list|,
name|qm_info
operator|->
name|pf_rl_en
argument_list|,
name|qm_info
operator|->
name|pf_wfq_en
argument_list|,
name|qm_info
operator|->
name|vport_rl_en
argument_list|,
name|qm_info
operator|->
name|vport_wfq_en
argument_list|,
name|qm_info
operator|->
name|pf_wfq
argument_list|,
name|qm_info
operator|->
name|pf_rl
argument_list|,
name|qm_info
operator|->
name|num_pf_rls
argument_list|,
name|ecore_get_pq_flags
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* port table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|=
operator|&
operator|(
name|qm_info
operator|->
name|qm_port_params
index|[
name|i
index|]
operator|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"port idx %d, active %d, active_phys_tcs %d, num_pbf_cmd_lines %d, num_btb_blocks %d, reserved %d\n"
argument_list|,
name|i
argument_list|,
name|port
operator|->
name|active
argument_list|,
name|port
operator|->
name|active_phys_tcs
argument_list|,
name|port
operator|->
name|num_pbf_cmd_lines
argument_list|,
name|port
operator|->
name|num_btb_blocks
argument_list|,
name|port
operator|->
name|reserved
argument_list|)
expr_stmt|;
block|}
comment|/* vport table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qm_info
operator|->
name|num_vports
condition|;
name|i
operator|++
control|)
block|{
name|vport
operator|=
operator|&
operator|(
name|qm_info
operator|->
name|qm_vport_params
index|[
name|i
index|]
operator|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"vport idx %d, vport_rl %d, wfq %d, first_tx_pq_id [ "
argument_list|,
name|qm_info
operator|->
name|start_vport
operator|+
name|i
argument_list|,
name|vport
operator|->
name|vport_rl
argument_list|,
name|vport
operator|->
name|vport_wfq
argument_list|)
expr_stmt|;
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_TCS
condition|;
name|tc
operator|++
control|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"%d "
argument_list|,
name|vport
operator|->
name|first_tx_pq_id
index|[
name|tc
index|]
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
comment|/* pq table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qm_info
operator|->
name|num_pqs
condition|;
name|i
operator|++
control|)
block|{
name|pq
operator|=
operator|&
operator|(
name|qm_info
operator|->
name|qm_pq_params
index|[
name|i
index|]
operator|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"pq idx %d, vport_id %d, tc %d, wrr_grp %d, rl_valid %d\n"
argument_list|,
name|qm_info
operator|->
name|start_pq
operator|+
name|i
argument_list|,
name|pq
operator|->
name|vport_id
argument_list|,
name|pq
operator|->
name|tc_id
argument_list|,
name|pq
operator|->
name|wrr_group
argument_list|,
name|pq
operator|->
name|rl_valid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_qm_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
comment|/* reset params required for init run */
name|ecore_init_qm_reset_params
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* init QM top level params */
name|ecore_init_qm_params
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* init QM port params */
name|ecore_init_qm_port_params
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* init QM vport params */
name|ecore_init_qm_vport_params
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* init QM physical queue params */
name|ecore_init_qm_pq_params
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* display all that init */
name|ecore_dp_init_qm_params
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function reconfigures the QM pf on the fly.  * For this purpose we:  * 1. reconfigure the QM database  * 2. set new values to runtime array  * 3. send an sdm_qm_cmd through the rbc interface to stop the QM  * 4. activate init tool in QM_PF stage  * 5. send an sdm_qm_cmd through rbc interface to release the QM  */
end_comment

begin_function
name|enum
name|_ecore_status_t
name|ecore_qm_reconf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|bool
name|b_rc
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* initialize ecore's qm data structure */
name|ecore_init_qm_info
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* stop PF's qm queues */
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|qm_lock
argument_list|)
expr_stmt|;
name|b_rc
operator|=
name|ecore_send_qm_stop_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
name|qm_info
operator|->
name|start_pq
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|qm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_rc
condition|)
return|return
name|ECORE_INVAL
return|;
comment|/* clear the QM_PF runtime phase leftovers from previous init */
name|ecore_init_clear_rt_data
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* prepare QM portion of runtime array */
name|ecore_qm_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* activate init tool on runtime array */
name|rc
operator|=
name|ecore_init_run
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PHASE_QM_PF
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* start PF's qm queues */
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|qm_lock
argument_list|)
expr_stmt|;
name|b_rc
operator|=
name|ecore_send_qm_stop_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|qm_info
operator|->
name|start_pq
argument_list|,
name|qm_info
operator|->
name|num_pqs
argument_list|)
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|qm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_rc
condition|)
return|return
name|ECORE_INVAL
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_alloc_qm_data
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_init_qm_sanity
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
goto|goto
name|alloc_err
goto|;
name|qm_info
operator|->
name|qm_pq_params
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|init_qm_pq_params
argument_list|)
operator|*
name|ecore_init_qm_get_num_pqs
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qm_info
operator|->
name|qm_pq_params
condition|)
goto|goto
name|alloc_err
goto|;
name|qm_info
operator|->
name|qm_vport_params
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|init_qm_vport_params
argument_list|)
operator|*
name|ecore_init_qm_get_num_vports
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qm_info
operator|->
name|qm_vport_params
condition|)
goto|goto
name|alloc_err
goto|;
name|qm_info
operator|->
name|qm_port_params
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|init_qm_port_params
argument_list|)
operator|*
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qm_info
operator|->
name|qm_port_params
condition|)
goto|goto
name|alloc_err
goto|;
name|qm_info
operator|->
name|wfq_data
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_wfq_data
argument_list|)
operator|*
name|ecore_init_qm_get_num_vports
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qm_info
operator|->
name|wfq_data
condition|)
goto|goto
name|alloc_err
goto|;
return|return
name|ECORE_SUCCESS
return|;
name|alloc_err
label|:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to allocate memory for QM params\n"
argument_list|)
expr_stmt|;
name|ecore_qm_info_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
end_function

begin_comment
comment|/******************** End QM initialization ***************/
end_comment

begin_function
name|enum
name|_ecore_status_t
name|ecore_resc_alloc
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u32
name|rdma_tasks
decl_stmt|,
name|excess_tasks
decl_stmt|;
name|u32
name|line_count
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|rc
operator|=
name|ecore_l2_alloc
argument_list|(
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
block|}
return|return
name|rc
return|;
block|}
name|p_dev
operator|->
name|fw_data
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_dev
operator|->
name|fw_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_dev
operator|->
name|fw_data
condition|)
return|return
name|ECORE_NOMEM
return|;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|u32
name|n_eqes
decl_stmt|,
name|num_cons
decl_stmt|;
comment|/* First allocate the context manager structure */
name|rc
operator|=
name|ecore_cxt_mngr_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
comment|/* Set the HW cid/tid numbers (in the contest manager) 		 * Must be done prior to any further computations. 		 */
name|rc
operator|=
name|ecore_cxt_set_pf_params
argument_list|(
name|p_hwfn
argument_list|,
name|RDMA_MAX_TIDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
name|rc
operator|=
name|ecore_alloc_qm_data
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
comment|/* init qm info */
name|ecore_init_qm_info
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* Compute the ILT client partition */
name|rc
operator|=
name|ecore_cxt_cfg_ilt_compute
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|line_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"too many ILT lines; re-computing with less lines\n"
argument_list|)
expr_stmt|;
comment|/* In case there are not enough ILT lines we reduce the 			 * number of RDMA tasks and re-compute. 			 */
name|excess_tasks
operator|=
name|ecore_cxt_cfg_ilt_compute_excess
argument_list|(
name|p_hwfn
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|excess_tasks
condition|)
goto|goto
name|alloc_err
goto|;
name|rdma_tasks
operator|=
name|RDMA_MAX_TIDS
operator|-
name|excess_tasks
expr_stmt|;
name|rc
operator|=
name|ecore_cxt_set_pf_params
argument_list|(
name|p_hwfn
argument_list|,
name|rdma_tasks
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
name|rc
operator|=
name|ecore_cxt_cfg_ilt_compute
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|line_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"failed ILT compute. Requested too many lines: %u\n"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
goto|goto
name|alloc_err
goto|;
block|}
block|}
comment|/* CID map / ILT shadow table / T2 		 * The talbes sizes are determined by the computations above 		 */
name|rc
operator|=
name|ecore_cxt_tables_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
comment|/* SPQ, must follow ILT because initializes SPQ context */
name|rc
operator|=
name|ecore_spq_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
comment|/* SP status block allocation */
name|p_hwfn
operator|->
name|p_dpc_ptt
operator|=
name|ecore_get_reserved_ptt
argument_list|(
name|p_hwfn
argument_list|,
name|RESERVED_PTT_DPC
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_int_alloc
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
name|rc
operator|=
name|ecore_iov_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
comment|/* EQ */
name|n_eqes
operator|=
name|ecore_chain_get_capacity
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECORE_IS_RDMA_PERSONALITY
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
comment|/* Calculate the EQ size 			 * --------------------- 			 * Each ICID may generate up to one event at a time i.e. 			 * the event must be handled/cleared before a new one 			 * can be generated. We calculate the sum of events per 			 * protocol and create an EQ deep enough to handle the 			 * worst case: 			 * - Core - according to SPQ. 			 * - RoCE - per QP there are a couple of ICIDs, one 			 *	  responder and one requester, each can 			 *	  generate an EQE => n_eqes_qp = 2 * n_qp. 			 *	  Each CQ can generate an EQE. There are 2 CQs 			 *	  per QP => n_eqes_cq = 2 * n_qp. 			 *	  Hence the RoCE total is 4 * n_qp or 			 *	  2 * num_cons. 			 * - ENet - There can be up to two events per VF. One 			 *	  for VF-PF channel and another for VF FLR 			 *	  initial cleanup. The number of VFs is 			 *	  bounded by MAX_NUM_VFS_BB, and is much 			 *	  smaller than RoCE's so we avoid exact 			 *	  calculation. 			 */
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_ETH_ROCE
condition|)
block|{
name|num_cons
operator|=
name|ecore_cxt_get_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_ROCE
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
name|num_cons
operator|*=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|num_cons
operator|=
name|ecore_cxt_get_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_IWARP
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
block|}
name|n_eqes
operator|+=
name|num_cons
operator|+
literal|2
operator|*
name|MAX_NUM_VFS_BB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_ISCSI
condition|)
block|{
name|num_cons
operator|=
name|ecore_cxt_get_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_ISCSI
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
name|n_eqes
operator|+=
literal|2
operator|*
name|num_cons
expr_stmt|;
block|}
if|if
condition|(
name|n_eqes
operator|>
literal|0xFFFF
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Cannot allocate 0x%x EQ elements. The maximum of a u16 chain is 0x%x\n"
argument_list|,
name|n_eqes
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
goto|goto
name|alloc_no_mem
goto|;
block|}
name|rc
operator|=
name|ecore_eq_alloc
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|u16
operator|)
name|n_eqes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
name|rc
operator|=
name|ecore_consq_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
name|rc
operator|=
name|ecore_l2_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
goto|goto
name|alloc_err
goto|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_LL2
if|if
condition|(
name|p_hwfn
operator|->
name|using_ll2
condition|)
block|{
name|rc
operator|=
name|ecore_ll2_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_FCOE
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_FCOE
condition|)
block|{
name|rc
operator|=
name|ecore_fcoe_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ISCSI
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_ISCSI
condition|)
block|{
name|rc
operator|=
name|ecore_iscsi_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
name|rc
operator|=
name|ecore_ooo_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|alloc_err
goto|;
block|}
endif|#
directive|endif
comment|/* DMA info initialization */
name|rc
operator|=
name|ecore_dmae_info_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate memory for dmae_info structure\n"
argument_list|)
expr_stmt|;
goto|goto
name|alloc_err
goto|;
block|}
comment|/* DCBX initialization */
name|rc
operator|=
name|ecore_dcbx_info_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate memory for dcbx structure\n"
argument_list|)
expr_stmt|;
goto|goto
name|alloc_err
goto|;
block|}
block|}
name|p_dev
operator|->
name|reset_stats
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_dev
operator|->
name|reset_stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_dev
operator|->
name|reset_stats
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate reset statistics\n"
argument_list|)
expr_stmt|;
goto|goto
name|alloc_no_mem
goto|;
block|}
return|return
name|ECORE_SUCCESS
return|;
name|alloc_no_mem
label|:
name|rc
operator|=
name|ECORE_NOMEM
expr_stmt|;
name|alloc_err
label|:
name|ecore_resc_free
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_resc_setup
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
name|ecore_l2_setup
argument_list|(
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|ecore_cxt_mngr_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_spq_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_eq_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_consq_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* Read shadow of current MFW mailbox */
name|ecore_mcp_read_mb
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
name|OSAL_MEMCPY
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_shadow
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_cur
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_length
argument_list|)
expr_stmt|;
name|ecore_int_setup
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
name|ecore_l2_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_iov_setup
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_LL2
if|if
condition|(
name|p_hwfn
operator|->
name|using_ll2
condition|)
name|ecore_ll2_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_FCOE
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_FCOE
condition|)
name|ecore_fcoe_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ISCSI
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_ISCSI
condition|)
block|{
name|ecore_iscsi_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_ooo_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_define
define|#
directive|define
name|FINAL_CLEANUP_POLL_CNT
value|(100)
end_define

begin_define
define|#
directive|define
name|FINAL_CLEANUP_POLL_TIME
value|(10)
end_define

begin_function
name|enum
name|_ecore_status_t
name|ecore_final_cleanup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|id
parameter_list|,
name|bool
name|is_vf
parameter_list|)
block|{
name|u32
name|command
init|=
literal|0
decl_stmt|,
name|addr
decl_stmt|,
name|count
init|=
name|FINAL_CLEANUP_POLL_CNT
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_TIMEOUT
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_TEDIBEAR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Skipping final cleanup for non-ASIC\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
endif|#
directive|endif
name|addr
operator|=
name|GTT_BAR0_MAP_REG_USDM_RAM
operator|+
name|USTORM_FLR_FINAL_ACK_OFFSET
argument_list|(
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_vf
condition|)
name|id
operator|+=
literal|0x10
expr_stmt|;
name|command
operator||=
name|X_FINAL_CLEANUP_AGG_INT
operator|<<
name|SDM_AGG_INT_COMP_PARAMS_AGG_INT_INDEX_SHIFT
expr_stmt|;
name|command
operator||=
literal|1
operator|<<
name|SDM_AGG_INT_COMP_PARAMS_AGG_VECTOR_ENABLE_SHIFT
expr_stmt|;
name|command
operator||=
name|id
operator|<<
name|SDM_AGG_INT_COMP_PARAMS_AGG_VECTOR_BIT_SHIFT
expr_stmt|;
name|command
operator||=
name|SDM_COMP_TYPE_AGG_INT
operator|<<
name|SDM_OP_GEN_COMP_TYPE_SHIFT
expr_stmt|;
comment|/* Make sure notification is not set before initiating final cleanup */
if|if
condition|(
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Unexpected; Found final cleanup notification before initiating final cleanup\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IOV
argument_list|,
literal|"Sending final cleanup for PFVF[%d] [Command %08x\n]"
argument_list|,
name|id
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XSDM_REG_OPERATION_GEN
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* Poll until completion */
while|while
condition|(
operator|!
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|addr
argument_list|)
operator|&&
name|count
operator|--
condition|)
name|OSAL_MSLEEP
argument_list|(
name|FINAL_CLEANUP_POLL_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|addr
argument_list|)
condition|)
name|rc
operator|=
name|ECORE_SUCCESS
expr_stmt|;
else|else
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to receive FW final cleanup notification\n"
argument_list|)
expr_stmt|;
comment|/* Cleanup afterwards */
name|REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_calc_hw_mode
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|int
name|hw_mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ECORE_IS_BB_B0
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_BB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_K2
expr_stmt|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unknown chip type %#x\n"
argument_list|,
name|p_hwfn
operator|->
name|p_dev
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Ports per engine is based on the values in CNIG_REG_NW_PORT_MODE*/
switch|switch
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
condition|)
block|{
case|case
literal|1
case|:
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_PORTS_PER_ENG_1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_PORTS_PER_ENG_2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_PORTS_PER_ENG_4
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"num_ports_in_engine = %d not supported\n"
argument_list|,
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
switch|switch
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|mf_mode
condition|)
block|{
case|case
name|ECORE_MF_DEFAULT
case|:
case|case
name|ECORE_MF_NPAR
case|:
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_MF_SI
expr_stmt|;
break|break;
case|case
name|ECORE_MF_OVLAN
case|:
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_MF_SD
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unsupported MF mode, init as DEFAULT\n"
argument_list|)
expr_stmt|;
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_MF_SI
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_FPGA
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|b_is_emul_full
condition|)
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_EMUL_FULL
expr_stmt|;
else|else
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_EMUL_REDUCED
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_ASIC
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
name|hw_mode
operator||=
literal|1
operator|<<
name|MODE_100G
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mode
operator|=
name|hw_mode
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_PROBE
operator||
name|ECORE_MSG_IFUP
operator|)
argument_list|,
literal|"Configuring function for hw_mode: 0x%08x\n"
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mode
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ASIC_ONLY
end_ifndef

begin_comment
comment|/* MFW-replacement initializations for non-ASIC */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_init_chip
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_dev
modifier|*
name|p_dev
init|=
name|p_hwfn
operator|->
name|p_dev
decl_stmt|;
name|u32
name|pl_hv
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|ECORE_IS_AH
argument_list|(
name|p_dev
argument_list|)
condition|)
name|pl_hv
operator||=
literal|0x600
expr_stmt|;
elseif|else
if|if
condition|(
name|ECORE_IS_E5
argument_list|(
name|p_dev
argument_list|)
condition|)
name|ECORE_E5_MISSING_CODE
expr_stmt|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_RESET_PL_HV
operator|+
literal|4
argument_list|,
name|pl_hv
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_dev
argument_list|)
operator|&&
operator|(
name|ECORE_IS_AH
argument_list|(
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_E5
argument_list|(
name|p_dev
argument_list|)
operator|)
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_RESET_PL_HV_2_K2_E5
argument_list|,
literal|0x3ffffff
argument_list|)
expr_stmt|;
comment|/* initialize port mode to 4x10G_E (10G with 4x10 SERDES) */
comment|/* CNIG_REG_NW_PORT_MODE is same for A0 and B0 */
if|if
condition|(
operator|!
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_NW_PORT_MODE_BB
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|ECORE_IS_AH
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
comment|/* 2 for 4-port, 1 for 2-port, 0 for 1-port */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_PORT_MODE
argument_list|,
operator|(
name|p_dev
operator|->
name|num_ports_in_engines
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_BLOCK_256B_EN
argument_list|,
name|p_dev
operator|->
name|num_ports_in_engines
operator|==
literal|4
condition|?
literal|0
else|:
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ECORE_IS_E5
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|ECORE_E5_MISSING_CODE
expr_stmt|;
block|}
block|}
comment|/* Poll on RBC */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PSWRQ2_REG_RBC_DONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|OSAL_UDELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PSWRQ2_REG_CFG_DONE
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|100
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"RBC done failed to complete in PSWRQ2\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Init run time data for all PFs and their VFs on an engine.  * TBD - for VFs - Once we have parent PF info for each VF in  * shmem available as CAU requires knowledge of parent PF for each VF.  */
end_comment

begin_function
specifier|static
name|void
name|ecore_init_cau_rt_data
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|u32
name|offset
init|=
name|CAU_REG_SB_VAR_MEMORY_RT_OFFSET
decl_stmt|;
name|int
name|i
decl_stmt|,
name|igu_sb_id
decl_stmt|;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ecore_igu_info
modifier|*
name|p_igu_info
decl_stmt|;
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|struct
name|cau_sb_entry
name|sb_entry
decl_stmt|;
name|p_igu_info
operator|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
expr_stmt|;
for|for
control|(
name|igu_sb_id
operator|=
literal|0
init|;
name|igu_sb_id
operator|<
name|ECORE_MAPPING_MEMORY_SIZE
argument_list|(
name|p_dev
argument_list|)
condition|;
name|igu_sb_id
operator|++
control|)
block|{
name|p_block
operator|=
operator|&
name|p_igu_info
operator|->
name|entry
index|[
name|igu_sb_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p_block
operator|->
name|is_pf
condition|)
continue|continue;
name|ecore_init_cau_sb_entry
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|sb_entry
argument_list|,
name|p_block
operator|->
name|function_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|offset
operator|+
name|igu_sb_id
operator|*
literal|2
argument_list|,
name|sb_entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_cache_line_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|val
decl_stmt|,
name|wr_mbs
decl_stmt|,
name|cache_line_size
decl_stmt|;
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PSWRQ2_REG_WR_MBS0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|0
case|:
name|wr_mbs
operator|=
literal|128
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|wr_mbs
operator|=
literal|256
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|wr_mbs
operator|=
literal|512
expr_stmt|;
break|break;
default|default:
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Unexpected value of PSWRQ2_REG_WR_MBS0 [0x%x]. Avoid configuring PGLUE_B_REG_CACHE_LINE_SIZE.\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|cache_line_size
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|OSAL_CACHE_LINE_SIZE
argument_list|,
name|wr_mbs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cache_line_size
condition|)
block|{
case|case
literal|32
case|:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|val
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|val
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Unexpected value of cache line size [0x%x]. Avoid configuring PGLUE_B_REG_CACHE_LINE_SIZE.\n"
argument_list|,
name|cache_line_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OSAL_CACHE_LINE_SIZE
operator|>
name|wr_mbs
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"The cache line size for padding is suboptimal for performance [OS cache line size 0x%x, wr mbs 0x%x]\n"
argument_list|,
name|OSAL_CACHE_LINE_SIZE
argument_list|,
name|wr_mbs
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PGLUE_REG_B_CACHE_LINE_SIZE_RT_OFFSET
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_init_common
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|int
name|hw_mode
parameter_list|)
block|{
name|struct
name|ecore_qm_info
modifier|*
name|qm_info
init|=
operator|&
name|p_hwfn
operator|->
name|qm_info
decl_stmt|;
name|struct
name|ecore_dev
modifier|*
name|p_dev
init|=
name|p_hwfn
operator|->
name|p_dev
decl_stmt|;
name|u8
name|vf_id
decl_stmt|,
name|max_num_vfs
decl_stmt|;
name|u16
name|num_pfs
decl_stmt|,
name|pf_id
decl_stmt|;
name|u32
name|concrete_fid
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|ecore_init_cau_rt_data
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
comment|/* Program GTT windows */
name|ecore_gtt_init
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ecore_hw_init_chip
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
condition|)
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|bandwidth_max
condition|)
name|qm_info
operator|->
name|pf_rl_en
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|bandwidth_min
condition|)
name|qm_info
operator|->
name|pf_wfq_en
operator|=
literal|1
expr_stmt|;
block|}
name|ecore_qm_common_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_dev
operator|->
name|num_ports_in_engines
argument_list|,
name|qm_info
operator|->
name|max_phys_tcs_per_port
argument_list|,
name|qm_info
operator|->
name|pf_rl_en
argument_list|,
name|qm_info
operator|->
name|pf_wfq_en
argument_list|,
name|qm_info
operator|->
name|vport_rl_en
argument_list|,
name|qm_info
operator|->
name|vport_wfq_en
argument_list|,
name|qm_info
operator|->
name|qm_port_params
argument_list|)
expr_stmt|;
name|ecore_cxt_hw_init_common
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_init_cache_line_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_init_run
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PHASE_ENGINE
argument_list|,
name|ANY_PHASE_ID
argument_list|,
name|hw_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* @@TBD MichalK - should add VALIDATE_VFID to init tool... 	 * need to decide with which value, maybe runtime 	 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PSWRQ2_REG_L2P_VALIDATE_VFID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PGLUE_B_REG_USE_CLIENTID_IN_TAG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
comment|/* Workaround clears ROCE search for all functions to prevent 		 * involving non intialized function in processing ROCE packet. 		 */
name|num_pfs
operator|=
name|NUM_OF_ENG_PFS
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
for|for
control|(
name|pf_id
operator|=
literal|0
init|;
name|pf_id
operator|<
name|num_pfs
condition|;
name|pf_id
operator|++
control|)
block|{
name|ecore_fid_pretend
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|pf_id
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_ROCE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_TCP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* pretend to original PF */
name|ecore_fid_pretend
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|)
expr_stmt|;
block|}
comment|/* Workaround for avoiding CCFC execution error when getting packets 	 * with CRC errors, and allowing instead the invoking of the FW error 	 * handler. 	 * This is not done inside the init tool since it currently can't 	 * perform a pretending to VFs. 	 */
name|max_num_vfs
operator|=
name|ECORE_IS_AH
argument_list|(
name|p_dev
argument_list|)
condition|?
name|MAX_NUM_VFS_K2
else|:
name|MAX_NUM_VFS_BB
expr_stmt|;
for|for
control|(
name|vf_id
operator|=
literal|0
init|;
name|vf_id
operator|<
name|max_num_vfs
condition|;
name|vf_id
operator|++
control|)
block|{
name|concrete_fid
operator|=
name|ecore_vfid_to_concrete
argument_list|(
name|p_hwfn
argument_list|,
name|vf_id
argument_list|)
expr_stmt|;
name|ecore_fid_pretend
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|u16
operator|)
name|concrete_fid
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CCFC_REG_STRONG_ENABLE_VF
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CCFC_REG_WEAK_ENABLE_VF
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TCFC_REG_STRONG_ENABLE_VF
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TCFC_REG_WEAK_ENABLE_VF
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* pretend to original PF */
name|ecore_fid_pretend
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ASIC_ONLY
end_ifndef

begin_define
define|#
directive|define
name|MISC_REG_RESET_REG_2_XMAC_BIT
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|MISC_REG_RESET_REG_2_XMAC_SOFT_BIT
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|PMEG_IF_BYTE_COUNT
value|8
end_define

begin_function
specifier|static
name|void
name|ecore_wr_nw_port
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u64
name|data
parameter_list|,
name|u8
name|reg_type
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"CMD: %08x, ADDR: 0x%08x, DATA: %08x:%08x\n"
argument_list|,
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_PMEG_IF_CMD_BB
argument_list|)
operator||
operator|(
literal|8
operator|<<
name|PMEG_IF_BYTE_COUNT
operator|)
argument_list|,
operator|(
name|reg_type
operator|<<
literal|25
operator|)
operator||
operator|(
name|addr
operator|<<
literal|8
operator|)
operator||
name|port
argument_list|,
call|(
name|u32
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|data
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_PMEG_IF_CMD_BB
argument_list|,
operator|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_PMEG_IF_CMD_BB
argument_list|)
operator|&
literal|0xffff00fe
operator|)
operator||
operator|(
literal|8
operator|<<
name|PMEG_IF_BYTE_COUNT
operator|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_PMEG_IF_ADDR_BB
argument_list|,
operator|(
name|reg_type
operator|<<
literal|25
operator|)
operator||
operator|(
name|addr
operator|<<
literal|8
operator|)
operator||
name|port
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_PMEG_IF_WRDATA_BB
argument_list|,
name|data
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_PMEG_IF_WRDATA_BB
argument_list|,
operator|(
name|data
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|XLPORT_MODE_REG
value|(0x20a)
end_define

begin_define
define|#
directive|define
name|XLPORT_MAC_CONTROL
value|(0x210)
end_define

begin_define
define|#
directive|define
name|XLPORT_FLOW_CONTROL_CONFIG
value|(0x207)
end_define

begin_define
define|#
directive|define
name|XLPORT_ENABLE_REG
value|(0x20b)
end_define

begin_define
define|#
directive|define
name|XLMAC_CTRL
value|(0x600)
end_define

begin_define
define|#
directive|define
name|XLMAC_MODE
value|(0x601)
end_define

begin_define
define|#
directive|define
name|XLMAC_RX_MAX_SIZE
value|(0x608)
end_define

begin_define
define|#
directive|define
name|XLMAC_TX_CTRL
value|(0x604)
end_define

begin_define
define|#
directive|define
name|XLMAC_PAUSE_CTRL
value|(0x60d)
end_define

begin_define
define|#
directive|define
name|XLMAC_PFC_CTRL
value|(0x60e)
end_define

begin_function
specifier|static
name|void
name|ecore_emul_link_init_bb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u8
name|loopback
init|=
literal|0
decl_stmt|,
name|port
init|=
name|p_hwfn
operator|->
name|port_id
operator|*
literal|2
decl_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Configurating Emulation Link %02x\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLPORT_MODE_REG
argument_list|,
operator|(
literal|0x4
operator|<<
literal|4
operator|)
operator||
literal|0x4
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* XLPORT MAC MODE */
comment|/* 0 Quad, 4 Single... */
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLPORT_MAC_CONTROL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLMAC_CTRL
argument_list|,
literal|0x40
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*XLMAC: SOFT RESET */
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLMAC_MODE
argument_list|,
literal|0x40
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*XLMAC: Port Speed>= 10Gbps */
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLMAC_RX_MAX_SIZE
argument_list|,
literal|0x3fff
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* XLMAC: Max Size */
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLMAC_TX_CTRL
argument_list|,
literal|0x01000000800ULL
operator||
operator|(
literal|0xa
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
literal|38
operator|)
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLMAC_PAUSE_CTRL
argument_list|,
literal|0x7c000
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLMAC_PFC_CTRL
argument_list|,
literal|0x30ffffc000ULL
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLMAC_CTRL
argument_list|,
literal|0x3
operator||
operator|(
name|loopback
operator|<<
literal|2
operator|)
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* XLMAC: TX_EN, RX_EN */
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLMAC_CTRL
argument_list|,
literal|0x1003
operator||
operator|(
name|loopback
operator|<<
literal|2
operator|)
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* XLMAC: TX_EN, RX_EN, SW_LINK_STATUS */
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLPORT_FLOW_CONTROL_CONFIG
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* Enabled Parallel PFC interface */
name|ecore_wr_nw_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XLPORT_ENABLE_REG
argument_list|,
literal|0xf
argument_list|,
literal|1
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* XLPORT port enable */
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_emul_link_init_ah_e5
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u8
name|port
init|=
name|p_hwfn
operator|->
name|port_id
decl_stmt|;
name|u32
name|mac_base
init|=
name|NWM_REG_MAC0_K2_E5
operator|+
operator|(
name|port
operator|<<
literal|2
operator|)
operator|*
name|NWM_REG_MAC0_SIZE
decl_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Configurating Emulation Link %02x\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_NIG_PORT0_CONF_K2_E5
operator|+
operator|(
name|port
operator|<<
literal|2
operator|)
argument_list|,
operator|(
literal|1
operator|<<
name|CNIG_REG_NIG_PORT0_CONF_NIG_PORT_ENABLE_0_K2_E5_SHIFT
operator|)
operator||
operator|(
name|port
operator|<<
name|CNIG_REG_NIG_PORT0_CONF_NIG_PORT_NWM_PORT_MAP_0_K2_E5_SHIFT
operator|)
operator||
operator|(
literal|0
operator|<<
name|CNIG_REG_NIG_PORT0_CONF_NIG_PORT_RATE_0_K2_E5_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|mac_base
operator|+
name|ETH_MAC_REG_XIF_MODE_K2_E5
argument_list|,
literal|1
operator|<<
name|ETH_MAC_REG_XIF_MODE_XGMII_K2_E5_SHIFT
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|mac_base
operator|+
name|ETH_MAC_REG_FRM_LENGTH_K2_E5
argument_list|,
literal|9018
operator|<<
name|ETH_MAC_REG_FRM_LENGTH_FRM_LENGTH_K2_E5_SHIFT
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|mac_base
operator|+
name|ETH_MAC_REG_TX_IPG_LENGTH_K2_E5
argument_list|,
literal|0xc
operator|<<
name|ETH_MAC_REG_TX_IPG_LENGTH_TXIPG_K2_E5_SHIFT
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|mac_base
operator|+
name|ETH_MAC_REG_RX_FIFO_SECTIONS_K2_E5
argument_list|,
literal|8
operator|<<
name|ETH_MAC_REG_RX_FIFO_SECTIONS_RX_SECTION_FULL_K2_E5_SHIFT
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|mac_base
operator|+
name|ETH_MAC_REG_TX_FIFO_SECTIONS_K2_E5
argument_list|,
operator|(
literal|0xA
operator|<<
name|ETH_MAC_REG_TX_FIFO_SECTIONS_TX_SECTION_EMPTY_K2_E5_SHIFT
operator|)
operator||
operator|(
literal|8
operator|<<
name|ETH_MAC_REG_TX_FIFO_SECTIONS_TX_SECTION_FULL_K2_E5_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|mac_base
operator|+
name|ETH_MAC_REG_COMMAND_CONFIG_K2_E5
argument_list|,
literal|0xa853
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_emul_link_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
if|if
condition|(
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_E5
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|ecore_emul_link_init_ah_e5
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
else|else
comment|/* BB */
name|ecore_emul_link_init_bb
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_link_init_bb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
name|int
name|port_offset
init|=
name|port
condition|?
literal|0x800
else|:
literal|0
decl_stmt|;
name|u32
name|xmac_rxctrl
init|=
literal|0
decl_stmt|;
comment|/* Reset of XMAC */
comment|/* FIXME: move to common start */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_RESET_PL_PDA_VAUX
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|MISC_REG_RESET_REG_2_XMAC_BIT
argument_list|)
expr_stmt|;
comment|/* Clear */
name|OSAL_MSLEEP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_RESET_PL_PDA_VAUX
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|MISC_REG_RESET_REG_2_XMAC_BIT
argument_list|)
expr_stmt|;
comment|/* Set */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_XMAC_CORE_PORT_MODE_BB
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set the number of ports on the Warp Core to 10G */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_XMAC_PHY_PORT_MODE_BB
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Soft reset of XMAC */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_RESET_PL_PDA_VAUX
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|MISC_REG_RESET_REG_2_XMAC_SOFT_BIT
argument_list|)
expr_stmt|;
name|OSAL_MSLEEP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_RESET_PL_PDA_VAUX
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|MISC_REG_RESET_REG_2_XMAC_SOFT_BIT
argument_list|)
expr_stmt|;
comment|/* FIXME: move to common end */
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XMAC_REG_MODE_BB
operator|+
name|port_offset
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Set Max packet size: initialize XMAC block register for port 0 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XMAC_REG_RX_MAX_SIZE_BB
operator|+
name|port_offset
argument_list|,
literal|0x2710
argument_list|)
expr_stmt|;
comment|/* CRC append for Tx packets: init XMAC block register for port 1 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XMAC_REG_TX_CTRL_LO_BB
operator|+
name|port_offset
argument_list|,
literal|0xC800
argument_list|)
expr_stmt|;
comment|/* Enable TX and RX: initialize XMAC block register for port 1 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XMAC_REG_CTRL_BB
operator|+
name|port_offset
argument_list|,
name|XMAC_REG_CTRL_TX_EN_BB
operator||
name|XMAC_REG_CTRL_RX_EN_BB
argument_list|)
expr_stmt|;
name|xmac_rxctrl
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XMAC_REG_RX_CTRL_BB
operator|+
name|port_offset
argument_list|)
expr_stmt|;
name|xmac_rxctrl
operator||=
name|XMAC_REG_RX_CTRL_PROCESS_VARIABLE_PREAMBLE_BB
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|XMAC_REG_RX_CTRL_BB
operator|+
name|port_offset
argument_list|,
name|xmac_rxctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_init_dpi_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|pwm_region_size
parameter_list|,
name|u32
name|n_cpus
parameter_list|)
block|{
name|u32
name|dpi_page_size_1
decl_stmt|,
name|dpi_page_size_2
decl_stmt|,
name|dpi_page_size
decl_stmt|;
name|u32
name|dpi_bit_shift
decl_stmt|,
name|dpi_count
decl_stmt|;
name|u32
name|min_dpis
decl_stmt|;
comment|/* Calculate DPI size 	 * ------------------ 	 * The PWM region contains Doorbell Pages. The first is reserverd for 	 * the kernel for, e.g, L2. The others are free to be used by non- 	 * trusted applications, typically from user space. Each page, called a 	 * doorbell page is sectioned into windows that allow doorbells to be 	 * issued in parallel by the kernel/application. The size of such a 	 * window (a.k.a. WID) is 1kB. 	 * Summary: 	 *    1kB WID x N WIDS = DPI page size 	 *    DPI page size x N DPIs = PWM region size 	 * Notes: 	 * The size of the DPI page size must be in multiples of OSAL_PAGE_SIZE 	 * in order to ensure that two applications won't share the same page. 	 * It also must contain at least one WID per CPU to allow parallelism. 	 * It also must be a power of 2, since it is stored as a bit shift. 	 * 	 * The DPI page size is stored in a register as 'dpi_bit_shift' so that 	 * 0 is 4kB, 1 is 8kB and etc. Hence the minimum size is 4,096 	 * containing 4 WIDs. 	 */
name|dpi_page_size_1
operator|=
name|ECORE_WID_SIZE
operator|*
name|n_cpus
expr_stmt|;
name|dpi_page_size_2
operator|=
name|OSAL_MAX_T
argument_list|(
name|u32
argument_list|,
name|ECORE_WID_SIZE
argument_list|,
name|OSAL_PAGE_SIZE
argument_list|)
expr_stmt|;
name|dpi_page_size
operator|=
name|OSAL_MAX_T
argument_list|(
name|u32
argument_list|,
name|dpi_page_size_1
argument_list|,
name|dpi_page_size_2
argument_list|)
expr_stmt|;
name|dpi_page_size
operator|=
name|OSAL_ROUNDUP_POW_OF_TWO
argument_list|(
name|dpi_page_size
argument_list|)
expr_stmt|;
name|dpi_bit_shift
operator|=
name|OSAL_LOG2
argument_list|(
name|dpi_page_size
operator|/
literal|4096
argument_list|)
expr_stmt|;
name|dpi_count
operator|=
name|pwm_region_size
operator|/
name|dpi_page_size
expr_stmt|;
name|min_dpis
operator|=
name|p_hwfn
operator|->
name|pf_params
operator|.
name|rdma_pf_params
operator|.
name|min_dpis
expr_stmt|;
name|min_dpis
operator|=
name|OSAL_MAX_T
argument_list|(
name|u32
argument_list|,
name|ECORE_MIN_DPIS
argument_list|,
name|min_dpis
argument_list|)
expr_stmt|;
comment|/* Update hwfn */
name|p_hwfn
operator|->
name|dpi_size
operator|=
name|dpi_page_size
expr_stmt|;
name|p_hwfn
operator|->
name|dpi_count
operator|=
name|dpi_count
expr_stmt|;
comment|/* Update registers */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_PF_DPI_BIT_SHIFT
argument_list|,
name|dpi_bit_shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpi_count
operator|<
name|min_dpis
condition|)
return|return
name|ECORE_NORESOURCES
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_enum
enum|enum
name|ECORE_ROCE_EDPM_MODE
block|{
name|ECORE_ROCE_EDPM_MODE_ENABLE
init|=
literal|0
block|,
name|ECORE_ROCE_EDPM_MODE_FORCE_ON
init|=
literal|1
block|,
name|ECORE_ROCE_EDPM_MODE_DISABLE
init|=
literal|2
block|, }
enum|;
end_enum

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_init_pf_doorbell_bar
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|pwm_regsize
decl_stmt|,
name|norm_regsize
decl_stmt|;
name|u32
name|non_pwm_conn
decl_stmt|,
name|min_addr_reg1
decl_stmt|;
name|u32
name|db_bar_size
decl_stmt|,
name|n_cpus
init|=
literal|1
decl_stmt|;
name|u32
name|roce_edpm_mode
decl_stmt|;
name|u32
name|pf_dems_shift
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u8
name|cond
decl_stmt|;
name|db_bar_size
operator|=
name|ecore_hw_bar_size
argument_list|(
name|p_hwfn
argument_list|,
name|BAR_ID_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
name|db_bar_size
operator|/=
literal|2
expr_stmt|;
comment|/* Calculate doorbell regions 	 * ----------------------------------- 	 * The doorbell BAR is made of two regions. The first is called normal 	 * region and the second is called PWM region. In the normal region 	 * each ICID has its own set of addresses so that writing to that 	 * specific address identifies the ICID. In the Process Window Mode 	 * region the ICID is given in the data written to the doorbell. The 	 * above per PF register denotes the offset in the doorbell BAR in which 	 * the PWM region begins. 	 * The normal region has ECORE_PF_DEMS_SIZE bytes per ICID, that is per 	 * non-PWM connection. The calculation below computes the total non-PWM 	 * connections. The DORQ_REG_PF_MIN_ADDR_REG1 register is 	 * in units of 4,096 bytes. 	 */
name|non_pwm_conn
operator|=
name|ecore_cxt_get_proto_cid_start
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_CORE
argument_list|)
operator|+
name|ecore_cxt_get_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_CORE
argument_list|,
name|OSAL_NULL
argument_list|)
operator|+
name|ecore_cxt_get_proto_cid_count
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_ETH
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
name|norm_regsize
operator|=
name|ROUNDUP
argument_list|(
name|ECORE_PF_DEMS_SIZE
operator|*
name|non_pwm_conn
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|min_addr_reg1
operator|=
name|norm_regsize
operator|/
literal|4096
expr_stmt|;
name|pwm_regsize
operator|=
name|db_bar_size
operator|-
name|norm_regsize
expr_stmt|;
comment|/* Check that the normal and PWM sizes are valid */
if|if
condition|(
name|db_bar_size
operator|<
name|norm_regsize
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Doorbell BAR size 0x%x is too small (normal region is 0x%0x )\n"
argument_list|,
name|db_bar_size
argument_list|,
name|norm_regsize
argument_list|)
expr_stmt|;
return|return
name|ECORE_NORESOURCES
return|;
block|}
if|if
condition|(
name|pwm_regsize
operator|<
name|ECORE_MIN_PWM_REGION
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"PWM region size 0x%0x is too small. Should be at least 0x%0x (Doorbell BAR size is 0x%x and normal region size is 0x%0x)\n"
argument_list|,
name|pwm_regsize
argument_list|,
name|ECORE_MIN_PWM_REGION
argument_list|,
name|db_bar_size
argument_list|,
name|norm_regsize
argument_list|)
expr_stmt|;
return|return
name|ECORE_NORESOURCES
return|;
block|}
comment|/* Calculate number of DPIs */
name|roce_edpm_mode
operator|=
name|p_hwfn
operator|->
name|pf_params
operator|.
name|rdma_pf_params
operator|.
name|roce_edpm_mode
expr_stmt|;
if|if
condition|(
operator|(
name|roce_edpm_mode
operator|==
name|ECORE_ROCE_EDPM_MODE_ENABLE
operator|)
operator|||
operator|(
operator|(
name|roce_edpm_mode
operator|==
name|ECORE_ROCE_EDPM_MODE_FORCE_ON
operator|)
operator|)
condition|)
block|{
comment|/* Either EDPM is mandatory, or we are attempting to allocate a 		 * WID per CPU. 		 */
name|n_cpus
operator|=
name|OSAL_NUM_ACTIVE_CPU
argument_list|()
expr_stmt|;
name|rc
operator|=
name|ecore_hw_init_dpi_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|pwm_regsize
argument_list|,
name|n_cpus
argument_list|)
expr_stmt|;
block|}
name|cond
operator|=
operator|(
operator|(
name|rc
operator|!=
name|ECORE_SUCCESS
operator|)
operator|&&
operator|(
name|roce_edpm_mode
operator|==
name|ECORE_ROCE_EDPM_MODE_ENABLE
operator|)
operator|)
operator|||
operator|(
name|roce_edpm_mode
operator|==
name|ECORE_ROCE_EDPM_MODE_DISABLE
operator|)
expr_stmt|;
if|if
condition|(
name|cond
operator|||
name|p_hwfn
operator|->
name|dcbx_no_edpm
condition|)
block|{
comment|/* Either EDPM is disabled from user configuration, or it is 		 * disabled via DCBx, or it is not mandatory and we failed to 		 * allocated a WID per CPU. 		 */
name|n_cpus
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|ecore_hw_init_dpi_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|pwm_regsize
argument_list|,
name|n_cpus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ROCE
comment|/* If we entered this flow due to DCBX then the DPM register is 		 * already configured. 		 */
if|if
condition|(
name|cond
condition|)
name|ecore_rdma_dpm_bar
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|p_hwfn
operator|->
name|wid_count
operator|=
operator|(
name|u16
operator|)
name|n_cpus
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"doorbell bar: normal_region_size=%d, pwm_region_size=%d, dpi_size=%d, dpi_count=%d, roce_edpm=%s\n"
argument_list|,
name|norm_regsize
argument_list|,
name|pwm_regsize
argument_list|,
name|p_hwfn
operator|->
name|dpi_size
argument_list|,
name|p_hwfn
operator|->
name|dpi_count
argument_list|,
operator|(
operator|(
name|p_hwfn
operator|->
name|dcbx_no_edpm
operator|)
operator|||
operator|(
name|p_hwfn
operator|->
name|db_bar_no_edpm
operator|)
operator|)
condition|?
literal|"disabled"
else|:
literal|"enabled"
argument_list|)
expr_stmt|;
comment|/* Check return codes from above calls */
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to allocate enough DPIs. Allocated %d but the current minimum is %d. You can try reducing this down to %d via user configuration n_dpi or by disabling EDPM via user configuration roce_edpm\n"
argument_list|,
name|p_hwfn
operator|->
name|dpi_count
argument_list|,
name|p_hwfn
operator|->
name|pf_params
operator|.
name|rdma_pf_params
operator|.
name|min_dpis
argument_list|,
name|ECORE_MIN_DPIS
argument_list|)
expr_stmt|;
return|return
name|ECORE_NORESOURCES
return|;
block|}
comment|/* Update hwfn */
name|p_hwfn
operator|->
name|dpi_start_offset
operator|=
name|norm_regsize
expr_stmt|;
comment|/* this is later used to 						      * calculate the doorbell 						      * address 						      */
comment|/* Update registers */
comment|/* DEMS size is configured log2 of DWORDs, hence the division by 4 */
name|pf_dems_shift
operator|=
name|OSAL_LOG2
argument_list|(
name|ECORE_PF_DEMS_SIZE
operator|/
literal|4
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_PF_ICID_BIT_SHIFT_NORM
argument_list|,
name|pf_dems_shift
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_PF_MIN_ADDR_REG1
argument_list|,
name|min_addr_reg1
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_init_port
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|int
name|hw_mode
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|rc
operator|=
name|ecore_init_run
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PHASE_PORT
argument_list|,
name|p_hwfn
operator|->
name|port_id
argument_list|,
name|hw_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|#
directive|if
literal|0
comment|/* FW 8.10.5.0 requires us to configure PF_VECTOR and DUALMODE in LLH. 	 * This would hopefully be moved to MFW. 	 */
block|if (IS_MF_DEFAULT(p_hwfn) || IS_MF_SI(p_hwfn)) { 		u8 pf_id = 0;  		if (ecore_hw_init_first_eth(p_hwfn, p_ptt,&pf_id) == 		    ECORE_SUCCESS) { 			DP_VERBOSE(p_hwfn, ECORE_MSG_IFUP, 				   "PF[%08x] is first eth on engine\n", 				   pf_id);
comment|/* We should have configured BIT for ppfid, i.e., the 			 * relative function number in the port. But there's a 			 * bug in LLH in BB where the ppfid is actually engine 			 * based, so we need to take this into account. 			 */
block|if (!ECORE_IS_BB(p_hwfn->p_dev)) 				pf_id /= p_hwfn->p_dev->num_ports_in_engines;  			ecore_wr(p_hwfn, p_ptt, 				 NIG_REG_LLH_TAGMAC_DEF_PF_VECTOR, 1<< pf_id); 		}
comment|/* Take the protocol-based hit vector if there is a hit, 		 * otherwise take the other vector. 		 */
block|ecore_wr(p_hwfn, p_ptt, NIG_REG_LLH_CLS_TYPE_DUALMODE, 0x2); 	}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_ASIC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
elseif|else
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|ecore_link_init_bb
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|port_id
argument_list|)
expr_stmt|;
else|else
comment|/* E5 */
name|ECORE_E5_MISSING_CODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
block|{
comment|/* Activate OPTE in CMT */
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_RESET_PL_HV
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x10
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_RESET_PL_HV
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_CLK_100G_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_CLK_100G_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_OPTE_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_ENG_CLS_TCP_4_TUPLE_SEARCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_ENG_CLS_ENG_ID_TBL
argument_list|,
literal|0x55555555
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_ENG_CLS_ENG_ID_TBL
operator|+
literal|0x4
argument_list|,
literal|0x55555555
argument_list|)
expr_stmt|;
block|}
name|ecore_emul_link_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"link is not being configured\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_init_pf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_tunnel_info
modifier|*
name|p_tunn
parameter_list|,
name|int
name|hw_mode
parameter_list|,
name|bool
name|b_hw_start
parameter_list|,
name|enum
name|ecore_int_mode
name|int_mode
parameter_list|,
name|bool
name|allow_npar_tx_switch
parameter_list|)
block|{
name|u8
name|rel_pf_id
init|=
name|p_hwfn
operator|->
name|rel_pf_id
decl_stmt|;
name|u32
name|prs_reg
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u16
name|ctrl
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
condition|)
block|{
name|struct
name|ecore_mcp_function_info
modifier|*
name|p_info
decl_stmt|;
name|p_info
operator|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
expr_stmt|;
if|if
condition|(
name|p_info
operator|->
name|bandwidth_min
condition|)
name|p_hwfn
operator|->
name|qm_info
operator|.
name|pf_wfq
operator|=
name|p_info
operator|->
name|bandwidth_min
expr_stmt|;
comment|/* Update rate limit once we'll actually have a link */
name|p_hwfn
operator|->
name|qm_info
operator|.
name|pf_rl
operator|=
literal|100000
expr_stmt|;
block|}
name|ecore_cxt_hw_init_pf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_int_igu_init_rt
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* Set VLAN in NIG if needed */
if|if
condition|(
name|hw_mode
operator|&
operator|(
literal|1
operator|<<
name|MODE_MF_SD
operator|)
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"Configuring LLH_FUNC_TAG\n"
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|NIG_REG_LLH_FUNC_TAG_EN_RT_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|NIG_REG_LLH_FUNC_TAG_VALUE_RT_OFFSET
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|ovlan
argument_list|)
expr_stmt|;
block|}
comment|/* Enable classification by MAC if needed */
if|if
condition|(
name|hw_mode
operator|&
operator|(
literal|1
operator|<<
name|MODE_MF_SI
operator|)
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"Configuring TAGMAC_CLS_TYPE\n"
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|NIG_REG_LLH_FUNC_TAGMAC_CLS_TYPE_RT_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Protocl Configuration  - @@@TBD - should we set 0 otherwise?*/
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PRS_REG_SEARCH_TCP_RT_OFFSET
argument_list|,
operator|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_ISCSI
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PRS_REG_SEARCH_FCOE_RT_OFFSET
argument_list|,
operator|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_FCOE
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PRS_REG_SEARCH_ROCE_RT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* perform debug configuration when chip is out of reset */
name|OSAL_BEFORE_PF_START
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|my_id
argument_list|)
expr_stmt|;
comment|/* Cleanup chip from previous driver if such remains exist */
name|rc
operator|=
name|ecore_final_cleanup
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|rel_pf_id
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|ecore_hw_err_notify
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_ERR_RAMROD_FAIL
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* PF Init sequence */
name|rc
operator|=
name|ecore_init_run
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PHASE_PF
argument_list|,
name|rel_pf_id
argument_list|,
name|hw_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* QM_PF Init sequence (may be invoked separately e.g. for DCB) */
name|rc
operator|=
name|ecore_init_run
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PHASE_QM_PF
argument_list|,
name|rel_pf_id
argument_list|,
name|hw_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* Pure runtime initializations - directly to the HW  */
name|ecore_int_igu_init_pure_rt
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* PCI relaxed ordering causes a decrease in the performance on some 	 * systems. Till a root cause is found, disable this attribute in the 	 * PCI config space. 	 */
name|pos
operator|=
name|OSAL_PCI_FIND_CAPABILITY
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to find the PCI Express Capability structure in the PCI config space\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_IO
return|;
block|}
name|OSAL_PCI_READ_CONFIG_WORD
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|pos
operator|+
name|PCI_EXP_DEVCTL
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|PCI_EXP_DEVCTL_RELAX_EN
expr_stmt|;
name|OSAL_PCI_WRITE_CONFIG_WORD
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|pos
operator|+
name|PCI_EXP_DEVCTL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_hw_init_pf_doorbell_bar
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
if|#
directive|if
literal|0
comment|/* FW 8.10.5.0 requires us to configure MSG_INFO in PRS. 	 * This would hopefully be moved to MFW. 	 */
block|if (IS_MF_SI(p_hwfn)) { 		u8 pf_id = 0; 		u32 val;  		if (ecore_hw_init_first_eth(p_hwfn, p_ptt,&pf_id) == 		    ECORE_SUCCESS) { 			if (p_hwfn->rel_pf_id == pf_id) { 				DP_VERBOSE(p_hwfn, ECORE_MSG_IFUP, 					   "PF[%d] is first ETH on engine\n", 					   pf_id); 				val = 1; 			} 			ecore_wr(p_hwfn, p_ptt, PRS_REG_MSG_INFO, val); 		} 	}
endif|#
directive|endif
comment|/* Add an LLH filter with the primary MAC address.  */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
operator|&&
name|IS_LEAD_HWFN
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ecore_llh_add_mac_filter
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mac_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to add an LLH filter with the primary MAC\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b_hw_start
condition|)
block|{
comment|/* enable interrupts */
name|rc
operator|=
name|ecore_int_igu_enable
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|int_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* send function start command */
name|rc
operator|=
name|ecore_sp_pf_start
argument_list|(
name|p_hwfn
argument_list|,
name|p_tunn
argument_list|,
name|p_hwfn
operator|->
name|p_dev
operator|->
name|mf_mode
argument_list|,
name|allow_npar_tx_switch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Function start ramrod failed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prs_reg
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_TAG1
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"PRS_REG_SEARCH_TAG1: %x\n"
argument_list|,
name|prs_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_FCOE
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_TAG1
argument_list|,
operator|(
literal|1
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_PKT_LEN_STAT_TAGS_NOT_COUNTED_FIRST
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"PRS_REG_SEARCH registers after start PFn\n"
argument_list|)
expr_stmt|;
name|prs_reg
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_TCP
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"PRS_REG_SEARCH_TCP: %x\n"
argument_list|,
name|prs_reg
argument_list|)
expr_stmt|;
name|prs_reg
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_UDP
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"PRS_REG_SEARCH_UDP: %x\n"
argument_list|,
name|prs_reg
argument_list|)
expr_stmt|;
name|prs_reg
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_FCOE
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"PRS_REG_SEARCH_FCOE: %x\n"
argument_list|,
name|prs_reg
argument_list|)
expr_stmt|;
name|prs_reg
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_ROCE
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"PRS_REG_SEARCH_ROCE: %x\n"
argument_list|,
name|prs_reg
argument_list|)
expr_stmt|;
name|prs_reg
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_TCP_FIRST_FRAG
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"PRS_REG_SEARCH_TCP_FIRST_FRAG: %x\n"
argument_list|,
name|prs_reg
argument_list|)
expr_stmt|;
name|prs_reg
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_TAG1
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"PRS_REG_SEARCH_TAG1: %x\n"
argument_list|,
name|prs_reg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_change_pci_hwfn
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|enable
parameter_list|)
block|{
name|u32
name|delay_idx
init|=
literal|0
decl_stmt|,
name|val
decl_stmt|,
name|set_val
init|=
name|enable
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* Change PF in PXP */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER
argument_list|,
name|set_val
argument_list|)
expr_stmt|;
comment|/* wait until value is set - try for 1 second every 50us */
for|for
control|(
name|delay_idx
operator|=
literal|0
init|;
name|delay_idx
operator|<
literal|20000
condition|;
name|delay_idx
operator|++
control|)
block|{
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|set_val
condition|)
break|break;
name|OSAL_UDELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
name|set_val
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"PFID_ENABLE_MASTER wasn't changed after a second\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_UNKNOWN_ERROR
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_reset_mb_shadow
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_main_ptt
parameter_list|)
block|{
comment|/* Read shadow of current MFW mailbox */
name|ecore_mcp_read_mb
argument_list|(
name|p_hwfn
argument_list|,
name|p_main_ptt
argument_list|)
expr_stmt|;
name|OSAL_MEMCPY
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_shadow
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_cur
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_vf_start
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_hw_init_params
modifier|*
name|p_params
parameter_list|)
block|{
if|if
condition|(
name|p_params
operator|->
name|p_tunn
condition|)
block|{
name|ecore_vf_set_vf_start_tunn_update_param
argument_list|(
name|p_params
operator|->
name|p_tunn
argument_list|)
expr_stmt|;
name|ecore_vf_pf_tunnel_param_update
argument_list|(
name|p_hwfn
argument_list|,
name|p_params
operator|->
name|p_tunn
argument_list|)
expr_stmt|;
block|}
name|p_hwfn
operator|->
name|b_int_enabled
operator|=
literal|1
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_fill_load_req_params
parameter_list|(
name|struct
name|ecore_load_req_params
modifier|*
name|p_load_req
parameter_list|,
name|struct
name|ecore_drv_load_params
modifier|*
name|p_drv_load
parameter_list|)
block|{
name|OSAL_MEM_ZERO
argument_list|(
name|p_load_req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_load_req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_drv_load
operator|!=
name|OSAL_NULL
condition|)
block|{
name|p_load_req
operator|->
name|drv_role
operator|=
name|p_drv_load
operator|->
name|is_crash_kernel
condition|?
name|ECORE_DRV_ROLE_KDUMP
else|:
name|ECORE_DRV_ROLE_OS
expr_stmt|;
name|p_load_req
operator|->
name|timeout_val
operator|=
name|p_drv_load
operator|->
name|mfw_timeout_val
expr_stmt|;
name|p_load_req
operator|->
name|avoid_eng_reset
operator|=
name|p_drv_load
operator|->
name|avoid_eng_reset
expr_stmt|;
name|p_load_req
operator|->
name|override_force_load
operator|=
name|p_drv_load
operator|->
name|override_force_load
expr_stmt|;
block|}
else|else
block|{
name|p_load_req
operator|->
name|drv_role
operator|=
name|ECORE_DRV_ROLE_OS
expr_stmt|;
name|p_load_req
operator|->
name|timeout_val
operator|=
name|ECORE_LOAD_REQ_LOCK_TO_DEFAULT
expr_stmt|;
name|p_load_req
operator|->
name|avoid_eng_reset
operator|=
name|false
expr_stmt|;
name|p_load_req
operator|->
name|override_force_load
operator|=
name|ECORE_OVERRIDE_FORCE_LOAD_NONE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_hw_init
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_hw_init_params
modifier|*
name|p_params
parameter_list|)
block|{
name|struct
name|ecore_load_req_params
name|load_req_params
decl_stmt|;
name|u32
name|load_code
decl_stmt|,
name|param
decl_stmt|,
name|drv_mb_param
decl_stmt|;
name|bool
name|b_default_mtu
init|=
name|true
decl_stmt|;
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|,
name|mfw_rc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|p_params
operator|->
name|int_mode
operator|==
name|ECORE_INT_MODE_MSI
operator|)
operator|&&
operator|(
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
operator|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"MSI mode is not supported for CMT devices\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ecore_init_fw_data
argument_list|(
name|p_dev
argument_list|,
name|p_params
operator|->
name|bin_fw_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
block|}
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
comment|/* If management didn't provide a default, set one of our own */
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|hw_info
operator|.
name|mtu
condition|)
block|{
name|p_hwfn
operator|->
name|hw_info
operator|.
name|mtu
operator|=
literal|1500
expr_stmt|;
name|b_default_mtu
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_vf_start
argument_list|(
name|p_hwfn
argument_list|,
name|p_params
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Enable DMAE in PXP */
name|rc
operator|=
name|ecore_change_pci_hwfn
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|rc
operator|=
name|ecore_calc_hw_mode
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|ecore_fill_load_req_params
argument_list|(
operator|&
name|load_req_params
argument_list|,
name|p_params
operator|->
name|p_drv_load_params
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_load_req
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
operator|&
name|load_req_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed sending a LOAD_REQ command\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|load_code
operator|=
name|load_req_params
operator|.
name|load_code
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Load request was sent. Load code: 0x%x\n"
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
name|ecore_mcp_set_capabilities
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
comment|/* CQ75580: 		 * When comming back from hiberbate state, the registers from 		 * which shadow is read initially are not initialized. It turns 		 * out that these registers get initialized during the call to 		 * ecore_mcp_load_req request. So we need to reread them here 		 * to get the proper shadow register value. 		 * Note: This is a workaround for the missing MFW 		 * initialization. It may be removed once the implementation 		 * is done. 		 */
name|ecore_reset_mb_shadow
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
comment|/* Only relevant for recovery: 		 * Clear the indication after the LOAD_REQ command is responded 		 * by the MFW. 		 */
name|p_dev
operator|->
name|recov_in_prog
operator|=
name|false
expr_stmt|;
name|p_hwfn
operator|->
name|first_on_engine
operator|=
operator|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_ENGINE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|qm_lock_init
condition|)
block|{
name|OSAL_SPIN_LOCK_INIT
argument_list|(
operator|&
name|qm_lock
argument_list|)
expr_stmt|;
name|qm_lock_init
operator|=
name|true
expr_stmt|;
block|}
switch|switch
condition|(
name|load_code
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_LOAD_ENGINE
case|:
name|rc
operator|=
name|ecore_hw_init_common
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
break|break;
comment|/* Fall into */
case|case
name|FW_MSG_CODE_DRV_LOAD_PORT
case|:
name|rc
operator|=
name|ecore_hw_init_port
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
break|break;
comment|/* Fall into */
case|case
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
case|:
name|rc
operator|=
name|ecore_hw_init_pf
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|p_params
operator|->
name|p_tunn
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mode
argument_list|,
name|p_params
operator|->
name|b_hw_start
argument_list|,
name|p_params
operator|->
name|int_mode
argument_list|,
name|p_params
operator|->
name|allow_npar_tx_switch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Unexpected load code [0x%08x]"
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_NOTIMPL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"init phase failed for loadcode 0x%x (rc %d)\n"
argument_list|,
name|load_code
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* ACK mfw regardless of success or failure of initialization */
name|mfw_rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|DRV_MSG_CODE_LOAD_DONE
argument_list|,
literal|0
argument_list|,
operator|&
name|load_code
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
comment|/* Check the return value of the ecore_hw_init_*() function */
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* Check the return value of the LOAD_DONE command */
if|if
condition|(
name|mfw_rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed sending a LOAD_DONE command\n"
argument_list|)
expr_stmt|;
return|return
name|mfw_rc
return|;
block|}
comment|/* Check if there is a DID mismatch between nvm-cfg/efuse */
if|if
condition|(
name|param
operator|&
name|FW_MB_PARAM_LOAD_DONE_DID_EFUSE_ERROR
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"warning: device configuration is not supported on this board type. The device may not function as expected.\n"
argument_list|)
expr_stmt|;
comment|/* send DCBX attention request command */
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DCB
argument_list|,
literal|"sending phony dcbx set command to trigger DCBx attention handling\n"
argument_list|)
expr_stmt|;
name|mfw_rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|DRV_MSG_CODE_SET_DCBX
argument_list|,
literal|1
operator|<<
name|DRV_MB_PARAM_DCBX_NOTIFY_SHIFT
argument_list|,
operator|&
name|load_code
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfw_rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to send DCBX attention request\n"
argument_list|)
expr_stmt|;
return|return
name|mfw_rc
return|;
block|}
name|p_hwfn
operator|->
name|hw_init_done
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|p_hwfn
operator|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
name|drv_mb_param
operator|=
name|STORM_FW_VERSION
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|DRV_MSG_CODE_OV_UPDATE_STORM_FW_VER
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|load_code
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to update firmware version\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_default_mtu
condition|)
block|{
name|rc
operator|=
name|ecore_mcp_ov_update_mtu
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to update default mtu\n"
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|ecore_mcp_ov_update_driver_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|ECORE_OV_DRIVER_STATE_DISABLED
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to update driver state\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_ov_update_eswitch
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|ECORE_OV_ESWITCH_VEB
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to update eswitch mode\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ECORE_HW_STOP_RETRY_LIMIT
value|(10)
end_define

begin_function
specifier|static
name|void
name|ecore_hw_timers_stop
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* close timers */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TM_REG_PF_ENABLE_CONN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TM_REG_PF_ENABLE_TASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ECORE_HW_STOP_RETRY_LIMIT
operator|&&
operator|!
name|p_dev
operator|->
name|recov_in_prog
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TM_REG_PF_SCAN_ACTIVE_CONN
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TM_REG_PF_SCAN_ACTIVE_TASK
argument_list|)
operator|)
condition|)
break|break;
comment|/* Dependent on number of connection/tasks, possibly 		 * 1ms sleep is required between polls 		 */
name|OSAL_MSLEEP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|ECORE_HW_STOP_RETRY_LIMIT
condition|)
return|return;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Timers linear scans are not over [Connection %02x Tasks %02x]\n"
argument_list|,
operator|(
name|u8
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TM_REG_PF_SCAN_ACTIVE_CONN
argument_list|)
argument_list|,
operator|(
name|u8
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TM_REG_PF_SCAN_ACTIVE_TASK
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_hw_timers_stop_all
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|j
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|j
index|]
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
init|=
name|p_hwfn
operator|->
name|p_main_ptt
decl_stmt|;
name|ecore_hw_timers_stop
argument_list|(
name|p_dev
argument_list|,
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_verify_reg_val
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|expected_val
parameter_list|)
block|{
name|u32
name|val
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|expected_val
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Value at address 0x%08x is 0x%08x while the expected value is 0x%08x\n"
argument_list|,
name|addr
argument_list|,
name|val
argument_list|,
name|expected_val
argument_list|)
expr_stmt|;
return|return
name|ECORE_UNKNOWN_ERROR
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_hw_stop
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|,
name|rc2
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|int
name|j
decl_stmt|;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|j
argument_list|)
block|{
name|p_hwfn
operator|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|j
index|]
expr_stmt|;
name|p_ptt
operator|=
name|p_hwfn
operator|->
name|p_main_ptt
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IFDOWN
argument_list|,
literal|"Stopping hw/fw\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_vf_pf_int_cleanup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_vf_pf_reset
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"ecore_vf_pf_reset failed. rc = %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc2
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* mark the hw as uninitialized... */
name|p_hwfn
operator|->
name|hw_init_done
operator|=
name|false
expr_stmt|;
comment|/* Send unload command to MCP */
if|if
condition|(
operator|!
name|p_dev
operator|->
name|recov_in_prog
condition|)
block|{
name|rc
operator|=
name|ecore_mcp_unload_req
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed sending a UNLOAD_REQ command. rc = %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc2
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
block|}
block|}
name|OSAL_DPC_SYNC
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* After this point no MFW attentions are expected, e.g. prevent 		 * race between pf stop and dcbx pf update. 		 */
name|rc
operator|=
name|ecore_sp_pf_stop
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to close PF against FW [rc = %d]. Continue to stop HW to prevent illegal host access by the device.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc2
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
block|}
comment|/* perform debug action after PF stop was sent */
name|OSAL_AFTER_PF_STOP
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|my_id
argument_list|)
expr_stmt|;
comment|/* close NIG to BRB gate */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_RX_LLH_BRB_GATE_DNTFWD_PERPF
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* close parser */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_TCP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_UDP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_FCOE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_ROCE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_OPENFLOW
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* @@@TBD - clean transmission queues (5.b) */
comment|/* @@@TBD - clean BTB (5.c) */
name|ecore_hw_timers_stop
argument_list|(
name|p_dev
argument_list|,
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* @@@TBD - verify DMAE requests are done (8) */
comment|/* Disable Attention Generation */
name|ecore_int_igu_disable_int
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_LEADING_EDGE_LATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_TRAILING_EDGE_LATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_int_igu_init_pure_rt
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_int_igu_reset_cam_default
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to return IGU CAM to default\n"
argument_list|)
expr_stmt|;
name|rc2
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
block|}
comment|/* Need to wait 1ms to guarantee SBs are cleared */
name|OSAL_MSLEEP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_dev
operator|->
name|recov_in_prog
condition|)
block|{
name|ecore_verify_reg_val
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_USG_CNT_PF_TX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_verify_reg_val
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_USG_CNT_PF_OTHER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* @@@TBD - assert on incorrect xCFC values (10.b) */
block|}
comment|/* Disable PF in HW blocks */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_PF_DB_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_PF_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_dev
operator|->
name|recov_in_prog
condition|)
block|{
name|ecore_mcp_unload_done
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed sending a UNLOAD_DONE command. rc = %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc2
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
block|}
block|}
comment|/* remove the LLH filter with the primary MAC addres */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
operator|&&
name|IS_LEAD_HWFN
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|ecore_llh_remove_mac_filter
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mac_addr
argument_list|)
expr_stmt|;
block|}
comment|/* hwfn loop */
if|if
condition|(
name|IS_PF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|p_hwfn
operator|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
name|p_ptt
operator|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
operator|->
name|p_main_ptt
expr_stmt|;
comment|/* Disable DMAE in PXP - in CMT, this should only be done for 		 * first hw-function, and only after all transactions have 		 * stopped for all active hw-functions. 		 */
name|rc
operator|=
name|ecore_change_pci_hwfn
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"ecore_change_pci_hwfn failed. rc = %d.\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc2
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
block|}
block|}
return|return
name|rc2
return|;
block|}
end_function

begin_function
name|void
name|ecore_hw_stop_fastpath
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|j
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|j
index|]
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
init|=
name|p_hwfn
operator|->
name|p_main_ptt
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_vf_pf_int_cleanup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IFDOWN
argument_list|,
literal|"Shutting down the fastpath\n"
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_RX_LLH_BRB_GATE_DNTFWD_PERPF
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_TCP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_UDP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_FCOE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_ROCE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_OPENFLOW
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* @@@TBD - clean transmission queues (5.b) */
comment|/* @@@TBD - clean BTB (5.c) */
comment|/* @@@TBD - verify DMAE requests are done (8) */
name|ecore_int_igu_init_pure_rt
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Need to wait 1ms to guarantee SBs are cleared */
name|OSAL_MSLEEP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_hw_start_fastpath
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
init|=
name|p_hwfn
operator|->
name|p_main_ptt
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return;
comment|/* If roce info is allocated it means roce is initialized and should 	 * be enabled in searcher. 	 */
if|if
condition|(
name|p_hwfn
operator|->
name|p_rdma_info
condition|)
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|b_rdma_enabled_in_prs
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|rdma_prs_search_reg
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|TM_REG_PF_ENABLE_CONN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
comment|/* Re-open incoming traffic */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|NIG_REG_RX_LLH_BRB_GATE_DNTFWD_PERPF
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TEMP macro to be removed when wol code revisted */
end_comment

begin_define
define|#
directive|define
name|ECORE_WOL_WR
parameter_list|(
name|_p_hwfn
parameter_list|,
name|_p_ptt
parameter_list|,
name|_offset
parameter_list|,
name|_val
parameter_list|)
value|ECORE_IS_BB(_p_hwfn->p_dev) ? \ 	ecore_wr(_p_hwfn, _p_ptt, _offset, _val) : \ 	ecore_mcp_wol_wr(_p_hwfn, _p_ptt, _offset, _val);
end_define

begin_function
name|enum
name|_ecore_status_t
name|ecore_set_nwuf_reg
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
specifier|const
name|bool
name|b_enable
parameter_list|,
name|u32
name|reg_idx
parameter_list|,
name|u32
name|pattern_size
parameter_list|,
name|u32
name|crc
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
literal|0
index|]
decl_stmt|;
name|u32
name|reg_len
init|=
literal|0
decl_stmt|;
name|u32
name|reg_crc
init|=
literal|0
decl_stmt|;
comment|/* Get length and CRC register offsets */
switch|switch
condition|(
name|reg_idx
condition|)
block|{
case|case
literal|0
case|:
name|reg_len
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_0_LEN_BB
else|:
name|WOL_REG_ACPI_PAT_0_LEN_K2_E5
expr_stmt|;
name|reg_crc
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_0_CRC_BB
else|:
name|WOL_REG_ACPI_PAT_0_CRC_K2_E5
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|reg_len
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_1_LEN_BB
else|:
name|WOL_REG_ACPI_PAT_1_LEN_K2_E5
expr_stmt|;
name|reg_crc
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_1_CRC_BB
else|:
name|WOL_REG_ACPI_PAT_1_CRC_K2_E5
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|reg_len
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_2_LEN_BB
else|:
name|WOL_REG_ACPI_PAT_2_LEN_K2_E5
expr_stmt|;
name|reg_crc
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_2_CRC_BB
else|:
name|WOL_REG_ACPI_PAT_2_CRC_K2_E5
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|reg_len
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_3_LEN_BB
else|:
name|WOL_REG_ACPI_PAT_3_LEN_K2_E5
expr_stmt|;
name|reg_crc
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_3_CRC_BB
else|:
name|WOL_REG_ACPI_PAT_3_CRC_K2_E5
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|reg_len
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_4_LEN_BB
else|:
name|WOL_REG_ACPI_PAT_4_LEN_K2_E5
expr_stmt|;
name|reg_crc
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_4_CRC_BB
else|:
name|WOL_REG_ACPI_PAT_4_CRC_K2_E5
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|reg_len
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_5_LEN_BB
else|:
name|WOL_REG_ACPI_PAT_5_LEN_K2_E5
expr_stmt|;
name|reg_crc
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_5_CRC_BB
else|:
name|WOL_REG_ACPI_PAT_5_CRC_K2_E5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|reg_len
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_6_LEN_BB
else|:
name|WOL_REG_ACPI_PAT_6_LEN_K2_E5
expr_stmt|;
name|reg_crc
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_6_CRC_BB
else|:
name|WOL_REG_ACPI_PAT_6_CRC_K2_E5
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|reg_len
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_7_LEN_BB
else|:
name|WOL_REG_ACPI_PAT_7_LEN_K2_E5
expr_stmt|;
name|reg_crc
operator|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_ACPI_PAT_7_CRC_BB
else|:
name|WOL_REG_ACPI_PAT_7_CRC_K2_E5
expr_stmt|;
break|break;
default|default:
return|return
name|ECORE_UNKNOWN_ERROR
return|;
block|}
comment|/* Allign pattern size to 4 */
while|while
condition|(
name|pattern_size
operator|%
literal|4
condition|)
block|{
name|pattern_size
operator|++
expr_stmt|;
block|}
comment|/* write pattern length */
name|ECORE_WOL_WR
argument_list|(
name|hwfn
argument_list|,
name|hwfn
operator|->
name|p_main_ptt
argument_list|,
name|reg_len
argument_list|,
name|pattern_size
argument_list|)
expr_stmt|;
comment|/* write crc value*/
name|ECORE_WOL_WR
argument_list|(
name|hwfn
argument_list|,
name|hwfn
operator|->
name|p_main_ptt
argument_list|,
name|reg_crc
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_dev
argument_list|,
literal|"ecore_set_nwuf_reg: idx[%d] reg_crc[0x%x=0x%08x] "
literal|"reg_len[0x%x=0x%x]\n"
argument_list|,
name|reg_idx
argument_list|,
name|reg_crc
argument_list|,
name|crc
argument_list|,
name|reg_len
argument_list|,
name|pattern_size
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|ecore_wol_buffer_clear
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|u32
name|wake_buffer_clear_offset
init|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_WAKE_BUFFER_CLEAR_BB
else|:
name|WOL_REG_WAKE_BUFFER_CLEAR_K2_E5
decl_stmt|;
name|DP_INFO
argument_list|(
name|p_dev
argument_list|,
literal|"ecore_wol_buffer_clear: reset "
literal|"REG_WAKE_BUFFER_CLEAR offset=0x%08x\n"
argument_list|,
name|wake_buffer_clear_offset
argument_list|)
expr_stmt|;
name|ECORE_WOL_WR
argument_list|(
name|hwfn
argument_list|,
name|hwfn
operator|->
name|p_main_ptt
argument_list|,
name|wake_buffer_clear_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ECORE_WOL_WR
argument_list|(
name|hwfn
argument_list|,
name|hwfn
operator|->
name|p_main_ptt
argument_list|,
name|wake_buffer_clear_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_get_wake_info
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_wake_info
modifier|*
name|wake_info
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
literal|0
index|]
decl_stmt|;
name|u32
modifier|*
name|buf
init|=
name|OSAL_NULL
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|u32
name|reg_wake_buffer_offest
init|=
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_WAKE_BUFFER_BB
else|:
name|WOL_REG_WAKE_BUFFER_K2_E5
decl_stmt|;
name|wake_info
operator|->
name|wk_info
operator|=
name|ecore_rd
argument_list|(
name|hwfn
argument_list|,
name|hwfn
operator|->
name|p_main_ptt
argument_list|,
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_WAKE_INFO_BB
else|:
name|WOL_REG_WAKE_INFO_K2_E5
argument_list|)
expr_stmt|;
name|wake_info
operator|->
name|wk_details
operator|=
name|ecore_rd
argument_list|(
name|hwfn
argument_list|,
name|hwfn
operator|->
name|p_main_ptt
argument_list|,
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_WAKE_DETAILS_BB
else|:
name|WOL_REG_WAKE_DETAILS_K2_E5
argument_list|)
expr_stmt|;
name|wake_info
operator|->
name|wk_pkt_len
operator|=
name|ecore_rd
argument_list|(
name|hwfn
argument_list|,
name|hwfn
operator|->
name|p_main_ptt
argument_list|,
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
name|NIG_REG_WAKE_PKT_LEN_BB
else|:
name|WOL_REG_WAKE_PKT_LEN_K2_E5
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_dev
argument_list|,
literal|"ecore_get_wake_info: REG_WAKE_INFO=0x%08x "
literal|"REG_WAKE_DETAILS=0x%08x "
literal|"REG_WAKE_PKT_LEN=0x%08x\n"
argument_list|,
name|wake_info
operator|->
name|wk_info
argument_list|,
name|wake_info
operator|->
name|wk_details
argument_list|,
name|wake_info
operator|->
name|wk_pkt_len
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|u32
operator|*
operator|)
name|wake_info
operator|->
name|wk_buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|wake_info
operator|->
name|wk_pkt_len
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|wake_info
operator|->
name|wk_buffer
argument_list|)
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_dev
argument_list|,
literal|"ecore_get_wake_info: i index to 0 high=%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
name|ecore_rd
argument_list|(
name|hwfn
argument_list|,
name|hwfn
operator|->
name|p_main_ptt
argument_list|,
name|reg_wake_buffer_offest
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_dev
argument_list|,
literal|"ecore_get_wake_info: wk_buffer[%u]: 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ecore_wol_buffer_clear
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Free hwfn memory and resources acquired in hw_hwfn_prepare */
end_comment

begin_function
specifier|static
name|void
name|ecore_hw_hwfn_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|ecore_ptt_pool_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Setup bar access */
end_comment

begin_function
specifier|static
name|void
name|ecore_hw_hwfn_prepare
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
comment|/* clear indirect access */
if|if
condition|(
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_E5
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_PGL_ADDR_E8_F0_K2_E5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_PGL_ADDR_EC_F0_K2_E5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_PGL_ADDR_F0_F0_K2_E5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_PGL_ADDR_F4_F0_K2_E5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_PGL_ADDR_88_F0_BB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_PGL_ADDR_8C_F0_BB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_PGL_ADDR_90_F0_BB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_PGL_ADDR_94_F0_BB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clean Previous errors if such exist */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_WAS_ERROR_PF_31_0_CLR
argument_list|,
literal|1
operator|<<
name|p_hwfn
operator|->
name|abs_pf_id
argument_list|)
expr_stmt|;
comment|/* enable internal target-read */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_TARGET_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_function_id
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
comment|/* ME Register */
name|p_hwfn
operator|->
name|hw_info
operator|.
name|opaque_fid
operator|=
operator|(
name|u16
operator|)
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|PXP_PF_ME_OPAQUE_ADDR
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|concrete_fid
operator|=
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|PXP_PF_ME_CONCRETE_ADDR
argument_list|)
expr_stmt|;
comment|/* Bits 16-19 from the ME registers are the pf_num */
name|p_hwfn
operator|->
name|abs_pf_id
operator|=
operator|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|concrete_fid
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
name|p_hwfn
operator|->
name|rel_pf_id
operator|=
name|GET_FIELD
argument_list|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|concrete_fid
argument_list|,
name|PXP_CONCRETE_FID_PFID
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|port_id
operator|=
name|GET_FIELD
argument_list|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|concrete_fid
argument_list|,
name|PXP_CONCRETE_FID_PORT
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_PROBE
argument_list|,
literal|"Read ME register: Concrete 0x%08x Opaque 0x%04x\n"
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|concrete_fid
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|opaque_fid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_hw_set_feat
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
modifier|*
name|feat_num
init|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|feat_num
decl_stmt|;
name|struct
name|ecore_sb_cnt_info
name|sb_cnt
decl_stmt|;
name|u32
name|non_l2_sbs
init|=
literal|0
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|sb_cnt
argument_list|,
sizeof|sizeof
argument_list|(
name|sb_cnt
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_int_get_num_sbs
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|sb_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ROCE
comment|/* Roce CNQ require each: 1 status block. 1 CNQ, we divide the 	 * status blocks equally between L2 / RoCE but with consideration as 	 * to how many l2 queues / cnqs we have 	 */
if|if
condition|(
name|ECORE_IS_RDMA_PERSONALITY
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|u32
name|max_cnqs
decl_stmt|;
name|feat_num
index|[
name|ECORE_RDMA_CNQ
index|]
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|sb_cnt
operator|.
name|cnt
operator|/
literal|2
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_RDMA_CNQ_RAM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Upper layer might require less */
name|max_cnqs
operator|=
operator|(
name|u32
operator|)
name|p_hwfn
operator|->
name|pf_params
operator|.
name|rdma_pf_params
operator|.
name|max_cnqs
expr_stmt|;
if|if
condition|(
name|max_cnqs
condition|)
block|{
if|if
condition|(
name|max_cnqs
operator|==
name|ECORE_RDMA_PF_PARAMS_CNQS_NONE
condition|)
name|max_cnqs
operator|=
literal|0
expr_stmt|;
name|feat_num
index|[
name|ECORE_RDMA_CNQ
index|]
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|feat_num
index|[
name|ECORE_RDMA_CNQ
index|]
argument_list|,
name|max_cnqs
argument_list|)
expr_stmt|;
block|}
name|non_l2_sbs
operator|=
name|feat_num
index|[
name|ECORE_RDMA_CNQ
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* L2 Queues require each: 1 status block. 1 L2 queue */
if|if
condition|(
name|ECORE_IS_L2_PERSONALITY
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
comment|/* Start by allocating VF queues, then PF's */
name|feat_num
index|[
name|ECORE_VF_L2_QUE
index|]
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_L2_QUEUE
argument_list|)
argument_list|,
name|sb_cnt
operator|.
name|iov_cnt
argument_list|)
expr_stmt|;
name|feat_num
index|[
name|ECORE_PF_L2_QUE
index|]
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|sb_cnt
operator|.
name|cnt
operator|-
name|non_l2_sbs
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_L2_QUEUE
argument_list|)
operator|-
name|FEAT_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VF_L2_QUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ECORE_IS_FCOE_PERSONALITY
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|feat_num
index|[
name|ECORE_FCOE_CQ
index|]
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|sb_cnt
operator|.
name|cnt
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_CMDQS_CQS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECORE_IS_ISCSI_PERSONALITY
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|feat_num
index|[
name|ECORE_ISCSI_CQ
index|]
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|sb_cnt
operator|.
name|cnt
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_CMDQS_CQS
argument_list|)
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_PROBE
argument_list|,
literal|"#PF_L2_QUEUE=%d VF_L2_QUEUES=%d #ROCE_CNQ=%d #FCOE_CQ=%d #ISCSI_CQ=%d #SB=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|FEAT_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_PF_L2_QUE
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FEAT_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VF_L2_QUE
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FEAT_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_RDMA_CNQ
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FEAT_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_FCOE_CQ
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FEAT_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_ISCSI_CQ
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|sb_cnt
operator|.
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ecore_hw_get_resc_name
parameter_list|(
name|enum
name|ecore_resources
name|res_id
parameter_list|)
block|{
switch|switch
condition|(
name|res_id
condition|)
block|{
case|case
name|ECORE_L2_QUEUE
case|:
return|return
literal|"L2_QUEUE"
return|;
case|case
name|ECORE_VPORT
case|:
return|return
literal|"VPORT"
return|;
case|case
name|ECORE_RSS_ENG
case|:
return|return
literal|"RSS_ENG"
return|;
case|case
name|ECORE_PQ
case|:
return|return
literal|"PQ"
return|;
case|case
name|ECORE_RL
case|:
return|return
literal|"RL"
return|;
case|case
name|ECORE_MAC
case|:
return|return
literal|"MAC"
return|;
case|case
name|ECORE_VLAN
case|:
return|return
literal|"VLAN"
return|;
case|case
name|ECORE_RDMA_CNQ_RAM
case|:
return|return
literal|"RDMA_CNQ_RAM"
return|;
case|case
name|ECORE_ILT
case|:
return|return
literal|"ILT"
return|;
case|case
name|ECORE_LL2_QUEUE
case|:
return|return
literal|"LL2_QUEUE"
return|;
case|case
name|ECORE_CMDQS_CQS
case|:
return|return
literal|"CMDQS_CQS"
return|;
case|case
name|ECORE_RDMA_STATS_QUEUE
case|:
return|return
literal|"RDMA_STATS_QUEUE"
return|;
case|case
name|ECORE_BDQ
case|:
return|return
literal|"BDQ"
return|;
case|case
name|ECORE_SB
case|:
return|return
literal|"SB"
return|;
default|default:
return|return
literal|"UNKNOWN_RESOURCE"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|__ecore_hw_set_soft_resc_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_resources
name|res_id
parameter_list|,
name|u32
name|resc_max_val
parameter_list|,
name|u32
modifier|*
name|p_mcp_resp
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_set_resc_max_val
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|res_id
argument_list|,
name|resc_max_val
argument_list|,
name|p_mcp_resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"MFW response failure for a max value setting of resource %d [%s]\n"
argument_list|,
name|res_id
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|res_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
if|if
condition|(
operator|*
name|p_mcp_resp
operator|!=
name|FW_MSG_CODE_RESOURCE_ALLOC_OK
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to set the max value of resource %d [%s]. mcp_resp = 0x%08x.\n"
argument_list|,
name|res_id
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|res_id
argument_list|)
argument_list|,
operator|*
name|p_mcp_resp
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_set_soft_resc_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|bool
name|b_ah
init|=
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
decl_stmt|;
name|u32
name|resc_max_val
decl_stmt|,
name|mcp_resp
decl_stmt|;
name|u8
name|res_id
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
for|for
control|(
name|res_id
operator|=
literal|0
init|;
name|res_id
operator|<
name|ECORE_MAX_RESC
condition|;
name|res_id
operator|++
control|)
block|{
switch|switch
condition|(
name|res_id
condition|)
block|{
case|case
name|ECORE_LL2_QUEUE
case|:
name|resc_max_val
operator|=
name|MAX_NUM_LL2_RX_QUEUES
expr_stmt|;
break|break;
case|case
name|ECORE_RDMA_CNQ_RAM
case|:
comment|/* No need for a case for ECORE_CMDQS_CQS since 			 * CNQ/CMDQS are the same resource. 			 */
name|resc_max_val
operator|=
name|NUM_OF_GLOBAL_QUEUES
expr_stmt|;
break|break;
case|case
name|ECORE_RDMA_STATS_QUEUE
case|:
name|resc_max_val
operator|=
name|b_ah
condition|?
name|RDMA_NUM_STATISTIC_COUNTERS_K2
else|:
name|RDMA_NUM_STATISTIC_COUNTERS_BB
expr_stmt|;
break|break;
case|case
name|ECORE_BDQ
case|:
name|resc_max_val
operator|=
name|BDQ_NUM_RESOURCES
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|rc
operator|=
name|__ecore_hw_set_soft_resc_size
argument_list|(
name|p_hwfn
argument_list|,
name|res_id
argument_list|,
name|resc_max_val
argument_list|,
operator|&
name|mcp_resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* There's no point to continue to the next resource if the 		 * command is not supported by the MFW. 		 * We do continue if the command is supported but the resource 		 * is unknown to the MFW. Such a resource will be later 		 * configured with the default allocation values. 		 */
if|if
condition|(
name|mcp_resp
operator|==
name|FW_MSG_CODE_UNSUPPORTED
condition|)
return|return
name|ECORE_NOTIMPL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_get_dflt_resc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_resources
name|res_id
parameter_list|,
name|u32
modifier|*
name|p_resc_num
parameter_list|,
name|u32
modifier|*
name|p_resc_start
parameter_list|)
block|{
name|u8
name|num_funcs
init|=
name|p_hwfn
operator|->
name|num_funcs_on_engine
decl_stmt|;
name|bool
name|b_ah
init|=
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|res_id
condition|)
block|{
case|case
name|ECORE_L2_QUEUE
case|:
operator|*
name|p_resc_num
operator|=
operator|(
name|b_ah
condition|?
name|MAX_NUM_L2_QUEUES_K2
else|:
name|MAX_NUM_L2_QUEUES_BB
operator|)
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_VPORT
case|:
operator|*
name|p_resc_num
operator|=
operator|(
name|b_ah
condition|?
name|MAX_NUM_VPORTS_K2
else|:
name|MAX_NUM_VPORTS_BB
operator|)
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_RSS_ENG
case|:
operator|*
name|p_resc_num
operator|=
operator|(
name|b_ah
condition|?
name|ETH_RSS_ENGINE_NUM_K2
else|:
name|ETH_RSS_ENGINE_NUM_BB
operator|)
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_PQ
case|:
operator|*
name|p_resc_num
operator|=
operator|(
name|b_ah
condition|?
name|MAX_QM_TX_QUEUES_K2
else|:
name|MAX_QM_TX_QUEUES_BB
operator|)
operator|/
name|num_funcs
expr_stmt|;
operator|*
name|p_resc_num
operator|&=
operator|~
literal|0x7
expr_stmt|;
comment|/* The granularity of the PQs is 8 */
break|break;
case|case
name|ECORE_RL
case|:
operator|*
name|p_resc_num
operator|=
name|MAX_QM_GLOBAL_RLS
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_MAC
case|:
case|case
name|ECORE_VLAN
case|:
comment|/* Each VFC resource can accommodate both a MAC and a VLAN */
operator|*
name|p_resc_num
operator|=
name|ETH_NUM_MAC_FILTERS
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_ILT
case|:
operator|*
name|p_resc_num
operator|=
operator|(
name|b_ah
condition|?
name|PXP_NUM_ILT_RECORDS_K2
else|:
name|PXP_NUM_ILT_RECORDS_BB
operator|)
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_LL2_QUEUE
case|:
operator|*
name|p_resc_num
operator|=
name|MAX_NUM_LL2_RX_QUEUES
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_RDMA_CNQ_RAM
case|:
case|case
name|ECORE_CMDQS_CQS
case|:
comment|/* CNQ/CMDQS are the same resource */
operator|*
name|p_resc_num
operator|=
name|NUM_OF_GLOBAL_QUEUES
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_RDMA_STATS_QUEUE
case|:
operator|*
name|p_resc_num
operator|=
operator|(
name|b_ah
condition|?
name|RDMA_NUM_STATISTIC_COUNTERS_K2
else|:
name|RDMA_NUM_STATISTIC_COUNTERS_BB
operator|)
operator|/
name|num_funcs
expr_stmt|;
break|break;
case|case
name|ECORE_BDQ
case|:
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|!=
name|ECORE_PCI_ISCSI
operator|&&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|!=
name|ECORE_PCI_FCOE
condition|)
operator|*
name|p_resc_num
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|p_resc_num
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ECORE_SB
case|:
comment|/* Since we want its value to reflect whether MFW supports 		 * the new scheme, have a default of 0. 		 */
operator|*
name|p_resc_num
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
switch|switch
condition|(
name|res_id
condition|)
block|{
case|case
name|ECORE_BDQ
case|:
if|if
condition|(
operator|!
operator|*
name|p_resc_num
condition|)
operator|*
name|p_resc_start
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|==
literal|4
condition|)
operator|*
name|p_resc_start
operator|=
name|p_hwfn
operator|->
name|port_id
expr_stmt|;
elseif|else
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_ISCSI
condition|)
operator|*
name|p_resc_start
operator|=
name|p_hwfn
operator|->
name|port_id
expr_stmt|;
elseif|else
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|==
name|ECORE_PCI_FCOE
condition|)
operator|*
name|p_resc_start
operator|=
name|p_hwfn
operator|->
name|port_id
operator|+
literal|2
expr_stmt|;
break|break;
default|default:
operator|*
name|p_resc_start
operator|=
operator|*
name|p_resc_num
operator|*
name|p_hwfn
operator|->
name|enabled_func_idx
expr_stmt|;
break|break;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|__ecore_hw_set_resc_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_resources
name|res_id
parameter_list|,
name|bool
name|drv_resc_alloc
parameter_list|)
block|{
name|u32
name|dflt_resc_num
init|=
literal|0
decl_stmt|,
name|dflt_resc_start
init|=
literal|0
decl_stmt|;
name|u32
name|mcp_resp
decl_stmt|,
modifier|*
name|p_resc_num
decl_stmt|,
modifier|*
name|p_resc_start
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|p_resc_num
operator|=
operator|&
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|res_id
argument_list|)
expr_stmt|;
name|p_resc_start
operator|=
operator|&
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|res_id
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_hw_get_dflt_resc
argument_list|(
name|p_hwfn
argument_list|,
name|res_id
argument_list|,
operator|&
name|dflt_resc_num
argument_list|,
operator|&
name|dflt_resc_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to get default amount for resource %d [%s]\n"
argument_list|,
name|res_id
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|res_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
operator|*
name|p_resc_num
operator|=
name|dflt_resc_num
expr_stmt|;
operator|*
name|p_resc_start
operator|=
name|dflt_resc_start
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|rc
operator|=
name|ecore_mcp_get_resc_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|res_id
argument_list|,
operator|&
name|mcp_resp
argument_list|,
name|p_resc_num
argument_list|,
name|p_resc_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"MFW response failure for an allocation request for resource %d [%s]\n"
argument_list|,
name|res_id
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|res_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* Default driver values are applied in the following cases: 	 * - The resource allocation MB command is not supported by the MFW 	 * - There is an internal error in the MFW while processing the request 	 * - The resource ID is unknown to the MFW 	 */
if|if
condition|(
name|mcp_resp
operator|!=
name|FW_MSG_CODE_RESOURCE_ALLOC_OK
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to receive allocation info for resource %d [%s]. mcp_resp = 0x%x. Applying default values [%d,%d].\n"
argument_list|,
name|res_id
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|res_id
argument_list|)
argument_list|,
name|mcp_resp
argument_list|,
name|dflt_resc_num
argument_list|,
name|dflt_resc_start
argument_list|)
expr_stmt|;
operator|*
name|p_resc_num
operator|=
name|dflt_resc_num
expr_stmt|;
operator|*
name|p_resc_start
operator|=
name|dflt_resc_start
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
operator|*
name|p_resc_num
operator|!=
name|dflt_resc_num
operator|||
operator|*
name|p_resc_start
operator|!=
name|dflt_resc_start
operator|)
operator|&&
name|res_id
operator|!=
name|ECORE_SB
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"MFW allocation for resource %d [%s] differs from default values [%d,%d vs. %d,%d]%s\n"
argument_list|,
name|res_id
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|res_id
argument_list|)
argument_list|,
operator|*
name|p_resc_num
argument_list|,
operator|*
name|p_resc_start
argument_list|,
name|dflt_resc_num
argument_list|,
name|dflt_resc_start
argument_list|,
name|drv_resc_alloc
condition|?
literal|" - Applying default values"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv_resc_alloc
condition|)
block|{
operator|*
name|p_resc_num
operator|=
name|dflt_resc_num
expr_stmt|;
operator|*
name|p_resc_start
operator|=
name|dflt_resc_start
expr_stmt|;
block|}
block|}
name|out
label|:
comment|/* PQs have to divide by 8 [that's the HW granularity]. 	 * Reduce number so it would fit. 	 */
if|if
condition|(
operator|(
name|res_id
operator|==
name|ECORE_PQ
operator|)
operator|&&
operator|(
operator|(
operator|*
name|p_resc_num
operator|%
literal|8
operator|)
operator|||
operator|(
operator|*
name|p_resc_start
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"PQs need to align by 8; Number %08x --> %08x, Start %08x --> %08x\n"
argument_list|,
operator|*
name|p_resc_num
argument_list|,
operator|(
operator|*
name|p_resc_num
operator|)
operator|&
operator|~
literal|0x7
argument_list|,
operator|*
name|p_resc_start
argument_list|,
operator|(
operator|*
name|p_resc_start
operator|)
operator|&
operator|~
literal|0x7
argument_list|)
expr_stmt|;
operator|*
name|p_resc_num
operator|&=
operator|~
literal|0x7
expr_stmt|;
operator|*
name|p_resc_start
operator|&=
operator|~
literal|0x7
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_set_resc_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|bool
name|drv_resc_alloc
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u8
name|res_id
decl_stmt|;
for|for
control|(
name|res_id
operator|=
literal|0
init|;
name|res_id
operator|<
name|ECORE_MAX_RESC
condition|;
name|res_id
operator|++
control|)
block|{
name|rc
operator|=
name|__ecore_hw_set_resc_info
argument_list|(
name|p_hwfn
argument_list|,
name|res_id
argument_list|,
name|drv_resc_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ECORE_RESC_ALLOC_LOCK_RETRY_CNT
value|10
end_define

begin_define
define|#
directive|define
name|ECORE_RESC_ALLOC_LOCK_RETRY_INTVL_US
value|10000
end_define

begin_comment
comment|/* 10 msec */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_get_resc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|bool
name|drv_resc_alloc
parameter_list|)
block|{
name|struct
name|ecore_resc_unlock_params
name|resc_unlock_params
decl_stmt|;
name|struct
name|ecore_resc_lock_params
name|resc_lock_params
decl_stmt|;
name|bool
name|b_ah
init|=
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
decl_stmt|;
name|u8
name|res_id
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
name|u32
modifier|*
name|resc_start
init|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|resc_start
decl_stmt|;
name|u32
modifier|*
name|resc_num
init|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|resc_num
decl_stmt|;
comment|/* For AH, an equal share of the ILT lines between the maximal number of 	 * PFs is not enough for RoCE. This would be solved by the future 	 * resource allocation scheme, but isn't currently present for 	 * FPGA/emulation. For now we keep a number that is sufficient for RoCE 	 * to work - the BB number of ILT lines divided by its max PFs number. 	 */
name|u32
name|roce_min_ilt_lines
init|=
name|PXP_NUM_ILT_RECORDS_BB
operator|/
name|MAX_NUM_PFS_BB
decl_stmt|;
endif|#
directive|endif
comment|/* Setting the max values of the soft resources and the following 	 * resources allocation queries should be atomic. Since several PFs can 	 * run in parallel - a resource lock is needed. 	 * If either the resource lock or resource set value commands are not 	 * supported - skip the the max values setting, release the lock if 	 * needed, and proceed to the queries. Other failures, including a 	 * failure to acquire the lock, will cause this function to fail. 	 * Old drivers that don't acquire the lock can run in parallel, and 	 * their allocation values won't be affected by the updated max values. 	 */
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|resc_lock_params
argument_list|,
sizeof|sizeof
argument_list|(
name|resc_lock_params
argument_list|)
argument_list|)
expr_stmt|;
name|resc_lock_params
operator|.
name|resource
operator|=
name|ECORE_RESC_LOCK_RESC_ALLOC
expr_stmt|;
name|resc_lock_params
operator|.
name|retry_num
operator|=
name|ECORE_RESC_ALLOC_LOCK_RETRY_CNT
expr_stmt|;
name|resc_lock_params
operator|.
name|retry_interval
operator|=
name|ECORE_RESC_ALLOC_LOCK_RETRY_INTVL_US
expr_stmt|;
name|resc_lock_params
operator|.
name|sleep_b4_retry
operator|=
name|true
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|resc_unlock_params
argument_list|,
sizeof|sizeof
argument_list|(
name|resc_unlock_params
argument_list|)
argument_list|)
expr_stmt|;
name|resc_unlock_params
operator|.
name|resource
operator|=
name|ECORE_RESC_LOCK_RESC_ALLOC
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_resc_lock
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
operator|&
name|resc_lock_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
operator|&&
name|rc
operator|!=
name|ECORE_NOTIMPL
condition|)
block|{
return|return
name|rc
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|ECORE_NOTIMPL
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Skip the max values setting of the soft resources since the resource lock is not supported by the MFW\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
operator|&&
operator|!
name|resc_lock_params
operator|.
name|b_granted
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to acquire the resource lock for the resource allocation commands\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
block|}
else|else
block|{
name|rc
operator|=
name|ecore_hw_set_soft_resc_size
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
operator|&&
name|rc
operator|!=
name|ECORE_NOTIMPL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to set the max values of the soft resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|unlock_and_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|ECORE_NOTIMPL
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Skip the max values setting of the soft resources since it is not supported by the MFW\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_resc_unlock
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
operator|&
name|resc_unlock_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to release the resource lock for the resource allocation commands\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|ecore_hw_set_resc_info
argument_list|(
name|p_hwfn
argument_list|,
name|drv_resc_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
goto|goto
name|unlock_and_exit
goto|;
if|if
condition|(
name|resc_lock_params
operator|.
name|b_granted
operator|&&
operator|!
name|resc_unlock_params
operator|.
name|b_released
condition|)
block|{
name|rc
operator|=
name|ecore_mcp_resc_unlock
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
operator|&
name|resc_unlock_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to release the resource lock for the resource allocation commands\n"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
comment|/* Reduced build contains less PQs */
if|if
condition|(
operator|!
operator|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|b_is_emul_full
operator|)
condition|)
block|{
name|resc_num
index|[
name|ECORE_PQ
index|]
operator|=
literal|32
expr_stmt|;
name|resc_start
index|[
name|ECORE_PQ
index|]
operator|=
name|resc_num
index|[
name|ECORE_PQ
index|]
operator|*
name|p_hwfn
operator|->
name|enabled_func_idx
expr_stmt|;
block|}
comment|/* For AH emulation, since we have a possible maximal number of 		 * 16 enabled PFs, in case there are not enough ILT lines - 		 * allocate only first PF as RoCE and have all the other ETH 		 * only with less ILT lines. 		 */
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|rel_pf_id
operator|&&
name|p_hwfn
operator|->
name|p_dev
operator|->
name|b_is_emul_full
condition|)
name|resc_num
index|[
name|ECORE_ILT
index|]
operator|=
name|OSAL_MAX_T
argument_list|(
name|u32
argument_list|,
name|resc_num
index|[
name|ECORE_ILT
index|]
argument_list|,
name|roce_min_ilt_lines
argument_list|)
expr_stmt|;
block|}
comment|/* Correct the common ILT calculation if PF0 has more */
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|&&
name|p_hwfn
operator|->
name|p_dev
operator|->
name|b_is_emul_full
operator|&&
name|p_hwfn
operator|->
name|rel_pf_id
operator|&&
name|resc_num
index|[
name|ECORE_ILT
index|]
operator|<
name|roce_min_ilt_lines
condition|)
name|resc_start
index|[
name|ECORE_ILT
index|]
operator|+=
name|roce_min_ilt_lines
operator|-
name|resc_num
index|[
name|ECORE_ILT
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Sanity for ILT */
if|if
condition|(
operator|(
name|b_ah
operator|&&
operator|(
name|RESC_END
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_ILT
argument_list|)
operator|>
name|PXP_NUM_ILT_RECORDS_K2
operator|)
operator|)
operator|||
operator|(
operator|!
name|b_ah
operator|&&
operator|(
name|RESC_END
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_ILT
argument_list|)
operator|>
name|PXP_NUM_ILT_RECORDS_BB
operator|)
operator|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Can't assign ILT pages [%08x,...,%08x]\n"
argument_list|,
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_ILT
argument_list|)
argument_list|,
name|RESC_END
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_ILT
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* This will also learn the number of SBs from MFW */
if|if
condition|(
name|ecore_int_igu_reset_cam
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
name|ecore_hw_set_feat
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_PROBE
argument_list|,
literal|"The numbers for each resource are:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|res_id
operator|=
literal|0
init|;
name|res_id
operator|<
name|ECORE_MAX_RESC
condition|;
name|res_id
operator|++
control|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_PROBE
argument_list|,
literal|"%s = %d start = %d\n"
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|res_id
argument_list|)
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|res_id
argument_list|)
argument_list|,
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|res_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
name|unlock_and_exit
label|:
if|if
condition|(
name|resc_lock_params
operator|.
name|b_granted
operator|&&
operator|!
name|resc_unlock_params
operator|.
name|b_released
condition|)
name|ecore_mcp_resc_unlock
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
operator|&
name|resc_unlock_params
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_get_nvm_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_hw_prepare_params
modifier|*
name|p_params
parameter_list|)
block|{
name|u32
name|nvm_cfg1_offset
decl_stmt|,
name|mf_mode
decl_stmt|,
name|addr
decl_stmt|,
name|generic_cont0
decl_stmt|,
name|core_cfg
decl_stmt|,
name|dcbx_mode
decl_stmt|;
name|u32
name|port_cfg_addr
decl_stmt|,
name|link_temp
decl_stmt|,
name|nvm_cfg_addr
decl_stmt|,
name|device_capabilities
decl_stmt|;
name|struct
name|ecore_mcp_link_capabilities
modifier|*
name|p_caps
decl_stmt|;
name|struct
name|ecore_mcp_link_params
modifier|*
name|link
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* Read global nvm_cfg address */
name|nvm_cfg_addr
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_GEN_PURP_CR0
argument_list|)
expr_stmt|;
comment|/* Verify MCP has initialized it */
if|if
condition|(
operator|!
name|nvm_cfg_addr
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Shared memory not initialized\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_FAILED_NVM
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Read nvm_cfg1  (Notice this is just offset, and not offsize (TBD) */
name|nvm_cfg1_offset
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|nvm_cfg_addr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|addr
operator|=
name|MCP_REG_SCRATCH
operator|+
name|nvm_cfg1_offset
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1
argument_list|,
name|glob
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1_glob
argument_list|,
name|core_cfg
argument_list|)
expr_stmt|;
name|core_cfg
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|core_cfg
operator|&
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_MASK
operator|)
operator|>>
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_OFFSET
condition|)
block|{
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_BB_2X40G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_2X40G
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_2X50G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_2X50G
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_BB_1X100G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_1X100G
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_4X10G_F
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_4X10G_F
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_BB_4X10G_E
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_4X10G_E
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_BB_4X20G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_4X20G
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_1X40G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_1X40G
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_2X25G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_2X25G
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_2X10G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_2X10G
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_1X25G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_1X25G
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_NETWORK_PORT_MODE_4X25G
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|port_mode
operator|=
name|ECORE_PORT_MODE_DE_4X25G
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unknown port mode in 0x%08x\n"
argument_list|,
name|core_cfg
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Read DCBX configuration */
name|port_cfg_addr
operator|=
name|MCP_REG_SCRATCH
operator|+
name|nvm_cfg1_offset
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1
argument_list|,
name|port
index|[
name|MFW_PORT
argument_list|(
name|p_hwfn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|dcbx_mode
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|port_cfg_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1_port
argument_list|,
name|generic_cont0
argument_list|)
argument_list|)
expr_stmt|;
name|dcbx_mode
operator|=
operator|(
name|dcbx_mode
operator|&
name|NVM_CFG1_PORT_DCBX_MODE_MASK
operator|)
operator|>>
name|NVM_CFG1_PORT_DCBX_MODE_OFFSET
expr_stmt|;
switch|switch
condition|(
name|dcbx_mode
condition|)
block|{
case|case
name|NVM_CFG1_PORT_DCBX_MODE_DYNAMIC
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|dcbx_mode
operator|=
name|ECORE_DCBX_VERSION_DYNAMIC
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_DCBX_MODE_CEE
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|dcbx_mode
operator|=
name|ECORE_DCBX_VERSION_CEE
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_DCBX_MODE_IEEE
case|:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|dcbx_mode
operator|=
name|ECORE_DCBX_VERSION_IEEE
expr_stmt|;
break|break;
default|default:
name|p_hwfn
operator|->
name|hw_info
operator|.
name|dcbx_mode
operator|=
name|ECORE_DCBX_VERSION_DISABLED
expr_stmt|;
block|}
comment|/* Read default link configuration */
name|link
operator|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_input
expr_stmt|;
name|p_caps
operator|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_capabilities
expr_stmt|;
name|port_cfg_addr
operator|=
name|MCP_REG_SCRATCH
operator|+
name|nvm_cfg1_offset
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1
argument_list|,
name|port
index|[
name|MFW_PORT
argument_list|(
name|p_hwfn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|link_temp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|port_cfg_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1_port
argument_list|,
name|speed_cap_mask
argument_list|)
argument_list|)
expr_stmt|;
name|link_temp
operator|&=
name|NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_MASK
expr_stmt|;
name|link
operator|->
name|speed
operator|.
name|advertised_speeds
operator|=
name|link_temp
expr_stmt|;
name|p_caps
operator|->
name|speed_capabilities
operator|=
name|link
operator|->
name|speed
operator|.
name|advertised_speeds
expr_stmt|;
name|link_temp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|port_cfg_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1_port
argument_list|,
name|link_settings
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|link_temp
operator|&
name|NVM_CFG1_PORT_DRV_LINK_SPEED_MASK
operator|)
operator|>>
name|NVM_CFG1_PORT_DRV_LINK_SPEED_OFFSET
condition|)
block|{
case|case
name|NVM_CFG1_PORT_DRV_LINK_SPEED_AUTONEG
case|:
name|link
operator|->
name|speed
operator|.
name|autoneg
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_DRV_LINK_SPEED_1G
case|:
name|link
operator|->
name|speed
operator|.
name|forced_speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_DRV_LINK_SPEED_10G
case|:
name|link
operator|->
name|speed
operator|.
name|forced_speed
operator|=
literal|10000
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_DRV_LINK_SPEED_25G
case|:
name|link
operator|->
name|speed
operator|.
name|forced_speed
operator|=
literal|25000
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_DRV_LINK_SPEED_40G
case|:
name|link
operator|->
name|speed
operator|.
name|forced_speed
operator|=
literal|40000
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_DRV_LINK_SPEED_50G
case|:
name|link
operator|->
name|speed
operator|.
name|forced_speed
operator|=
literal|50000
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_DRV_LINK_SPEED_BB_100G
case|:
name|link
operator|->
name|speed
operator|.
name|forced_speed
operator|=
literal|100000
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unknown Speed in 0x%08x\n"
argument_list|,
name|link_temp
argument_list|)
expr_stmt|;
block|}
name|p_caps
operator|->
name|default_speed
operator|=
name|link
operator|->
name|speed
operator|.
name|forced_speed
expr_stmt|;
name|p_caps
operator|->
name|default_speed_autoneg
operator|=
name|link
operator|->
name|speed
operator|.
name|autoneg
expr_stmt|;
name|link_temp
operator|&=
name|NVM_CFG1_PORT_DRV_FLOW_CONTROL_MASK
expr_stmt|;
name|link_temp
operator|>>=
name|NVM_CFG1_PORT_DRV_FLOW_CONTROL_OFFSET
expr_stmt|;
name|link
operator|->
name|pause
operator|.
name|autoneg
operator|=
operator|!
operator|!
operator|(
name|link_temp
operator|&
name|NVM_CFG1_PORT_DRV_FLOW_CONTROL_AUTONEG
operator|)
expr_stmt|;
name|link
operator|->
name|pause
operator|.
name|forced_rx
operator|=
operator|!
operator|!
operator|(
name|link_temp
operator|&
name|NVM_CFG1_PORT_DRV_FLOW_CONTROL_RX
operator|)
expr_stmt|;
name|link
operator|->
name|pause
operator|.
name|forced_tx
operator|=
operator|!
operator|!
operator|(
name|link_temp
operator|&
name|NVM_CFG1_PORT_DRV_FLOW_CONTROL_TX
operator|)
expr_stmt|;
name|link
operator|->
name|loopback_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|capabilities
operator|&
name|FW_MB_PARAM_FEATURE_SUPPORT_EEE
condition|)
block|{
name|link_temp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|port_cfg_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1_port
argument_list|,
name|ext_phy
argument_list|)
argument_list|)
expr_stmt|;
name|link_temp
operator|&=
name|NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_MASK
expr_stmt|;
name|link_temp
operator|>>=
name|NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_OFFSET
expr_stmt|;
name|p_caps
operator|->
name|default_eee
operator|=
name|ECORE_MCP_EEE_ENABLED
expr_stmt|;
name|link
operator|->
name|eee
operator|.
name|enable
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|link_temp
condition|)
block|{
case|case
name|NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_DISABLED
case|:
name|p_caps
operator|->
name|default_eee
operator|=
name|ECORE_MCP_EEE_DISABLED
expr_stmt|;
name|link
operator|->
name|eee
operator|.
name|enable
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_BALANCED
case|:
name|p_caps
operator|->
name|eee_lpi_timer
operator|=
name|EEE_TX_TIMER_USEC_BALANCED_TIME
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_AGGRESSIVE
case|:
name|p_caps
operator|->
name|eee_lpi_timer
operator|=
name|EEE_TX_TIMER_USEC_AGGRESSIVE_TIME
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_LOW_LATENCY
case|:
name|p_caps
operator|->
name|eee_lpi_timer
operator|=
name|EEE_TX_TIMER_USEC_LATENCY_TIME
expr_stmt|;
break|break;
block|}
name|link
operator|->
name|eee
operator|.
name|tx_lpi_timer
operator|=
name|p_caps
operator|->
name|eee_lpi_timer
expr_stmt|;
name|link
operator|->
name|eee
operator|.
name|tx_lpi_enable
operator|=
name|link
operator|->
name|eee
operator|.
name|enable
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|eee
operator|.
name|enable
condition|)
name|link
operator|->
name|eee
operator|.
name|adv_caps
operator|=
name|ECORE_EEE_1G_ADV
operator||
name|ECORE_EEE_10G_ADV
expr_stmt|;
block|}
else|else
block|{
name|p_caps
operator|->
name|default_eee
operator|=
name|ECORE_MCP_EEE_UNSUPPORTED
expr_stmt|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Read default link: Speed 0x%08x, Adv. Speed 0x%08x, AN: 0x%02x, PAUSE AN: 0x%02x EEE: %02x [%08x usec]\n"
argument_list|,
name|link
operator|->
name|speed
operator|.
name|forced_speed
argument_list|,
name|link
operator|->
name|speed
operator|.
name|advertised_speeds
argument_list|,
name|link
operator|->
name|speed
operator|.
name|autoneg
argument_list|,
name|link
operator|->
name|pause
operator|.
name|autoneg
argument_list|,
name|p_caps
operator|->
name|default_eee
argument_list|,
name|p_caps
operator|->
name|eee_lpi_timer
argument_list|)
expr_stmt|;
comment|/* Read Multi-function information from shmem */
name|addr
operator|=
name|MCP_REG_SCRATCH
operator|+
name|nvm_cfg1_offset
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1
argument_list|,
name|glob
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1_glob
argument_list|,
name|generic_cont0
argument_list|)
expr_stmt|;
name|generic_cont0
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|mf_mode
operator|=
operator|(
name|generic_cont0
operator|&
name|NVM_CFG1_GLOB_MF_MODE_MASK
operator|)
operator|>>
name|NVM_CFG1_GLOB_MF_MODE_OFFSET
expr_stmt|;
switch|switch
condition|(
name|mf_mode
condition|)
block|{
case|case
name|NVM_CFG1_GLOB_MF_MODE_MF_ALLOWED
case|:
name|p_hwfn
operator|->
name|p_dev
operator|->
name|mf_mode
operator|=
name|ECORE_MF_OVLAN
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_MF_MODE_NPAR1_0
case|:
name|p_hwfn
operator|->
name|p_dev
operator|->
name|mf_mode
operator|=
name|ECORE_MF_NPAR
expr_stmt|;
break|break;
case|case
name|NVM_CFG1_GLOB_MF_MODE_DEFAULT
case|:
name|p_hwfn
operator|->
name|p_dev
operator|->
name|mf_mode
operator|=
name|ECORE_MF_DEFAULT
expr_stmt|;
break|break;
block|}
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Multi function mode is %08x\n"
argument_list|,
name|p_hwfn
operator|->
name|p_dev
operator|->
name|mf_mode
argument_list|)
expr_stmt|;
comment|/* Read Multi-function information from shmem */
name|addr
operator|=
name|MCP_REG_SCRATCH
operator|+
name|nvm_cfg1_offset
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1
argument_list|,
name|glob
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1_glob
argument_list|,
name|device_capabilities
argument_list|)
expr_stmt|;
name|device_capabilities
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_capabilities
operator|&
name|NVM_CFG1_GLOB_DEVICE_CAPABILITIES_ETHERNET
condition|)
name|OSAL_SET_BIT
argument_list|(
name|ECORE_DEV_CAP_ETH
argument_list|,
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|device_capabilities
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_capabilities
operator|&
name|NVM_CFG1_GLOB_DEVICE_CAPABILITIES_FCOE
condition|)
name|OSAL_SET_BIT
argument_list|(
name|ECORE_DEV_CAP_FCOE
argument_list|,
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|device_capabilities
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_capabilities
operator|&
name|NVM_CFG1_GLOB_DEVICE_CAPABILITIES_ISCSI
condition|)
name|OSAL_SET_BIT
argument_list|(
name|ECORE_DEV_CAP_ISCSI
argument_list|,
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|device_capabilities
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_capabilities
operator|&
name|NVM_CFG1_GLOB_DEVICE_CAPABILITIES_ROCE
condition|)
name|OSAL_SET_BIT
argument_list|(
name|ECORE_DEV_CAP_ROCE
argument_list|,
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|device_capabilities
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_capabilities
operator|&
name|NVM_CFG1_GLOB_DEVICE_CAPABILITIES_IWARP
condition|)
name|OSAL_SET_BIT
argument_list|(
name|ECORE_DEV_CAP_IWARP
argument_list|,
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|device_capabilities
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_fill_shmem_func_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
operator|&&
name|p_params
operator|->
name|b_relaxed_probe
condition|)
block|{
name|rc
operator|=
name|ECORE_SUCCESS
expr_stmt|;
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_BAD_MCP
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_get_num_funcs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u8
name|num_funcs
decl_stmt|,
name|enabled_func_idx
init|=
name|p_hwfn
operator|->
name|rel_pf_id
decl_stmt|;
name|u32
name|reg_function_hide
decl_stmt|,
name|tmp
decl_stmt|,
name|eng_mask
decl_stmt|,
name|low_pfs_mask
decl_stmt|;
name|struct
name|ecore_dev
modifier|*
name|p_dev
init|=
name|p_hwfn
operator|->
name|p_dev
decl_stmt|;
name|num_funcs
operator|=
name|ECORE_IS_AH
argument_list|(
name|p_dev
argument_list|)
condition|?
name|MAX_NUM_PFS_K2
else|:
name|MAX_NUM_PFS_BB
expr_stmt|;
comment|/* Bit 0 of MISCS_REG_FUNCTION_HIDE indicates whether the bypass values 	 * in the other bits are selected. 	 * Bits 1-15 are for functions 1-15, respectively, and their value is 	 * '0' only for enabled functions (function 0 always exists and 	 * enabled). 	 * In case of CMT in BB, only the "even" functions are enabled, and thus 	 * the number of functions for both hwfns is learnt from the same bits. 	 */
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_AH
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|reg_function_hide
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_FUNCTION_HIDE_BB_K2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* E5 */
name|reg_function_hide
operator|=
literal|0
expr_stmt|;
name|ECORE_E5_MISSING_CODE
expr_stmt|;
block|}
if|if
condition|(
name|reg_function_hide
operator|&
literal|0x1
condition|)
block|{
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|ECORE_PATH_ID
argument_list|(
name|p_hwfn
argument_list|)
operator|&&
name|p_dev
operator|->
name|num_hwfns
operator|==
literal|1
condition|)
block|{
name|num_funcs
operator|=
literal|0
expr_stmt|;
name|eng_mask
operator|=
literal|0xaaaa
expr_stmt|;
block|}
else|else
block|{
name|num_funcs
operator|=
literal|1
expr_stmt|;
name|eng_mask
operator|=
literal|0x5554
expr_stmt|;
block|}
block|}
else|else
block|{
name|num_funcs
operator|=
literal|1
expr_stmt|;
name|eng_mask
operator|=
literal|0xfffe
expr_stmt|;
block|}
comment|/* Get the number of the enabled functions on the engine */
name|tmp
operator|=
operator|(
name|reg_function_hide
operator|^
literal|0xffffffff
operator|)
operator|&
name|eng_mask
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|tmp
operator|&
literal|0x1
condition|)
name|num_funcs
operator|++
expr_stmt|;
name|tmp
operator|>>=
literal|0x1
expr_stmt|;
block|}
comment|/* Get the PF index within the enabled functions */
name|low_pfs_mask
operator|=
operator|(
literal|0x1
operator|<<
name|p_hwfn
operator|->
name|abs_pf_id
operator|)
operator|-
literal|1
expr_stmt|;
name|tmp
operator|=
name|reg_function_hide
operator|&
name|eng_mask
operator|&
name|low_pfs_mask
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|tmp
operator|&
literal|0x1
condition|)
name|enabled_func_idx
operator|--
expr_stmt|;
name|tmp
operator|>>=
literal|0x1
expr_stmt|;
block|}
block|}
name|p_hwfn
operator|->
name|num_funcs_on_engine
operator|=
name|num_funcs
expr_stmt|;
name|p_hwfn
operator|->
name|enabled_func_idx
operator|=
name|enabled_func_idx
expr_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"FPGA: Limit number of PFs to 4 [would affect resource allocation, needed for IOV]\n"
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|num_funcs_on_engine
operator|=
literal|4
expr_stmt|;
block|}
endif|#
directive|endif
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_PROBE
argument_list|,
literal|"PF [rel_id %d, abs_id %d] occupies index %d within the %d enabled functions on the engine\n"
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|,
name|p_hwfn
operator|->
name|abs_pf_id
argument_list|,
name|p_hwfn
operator|->
name|enabled_func_idx
argument_list|,
name|p_hwfn
operator|->
name|num_funcs_on_engine
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_hw_info_port_num_bb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|port_mode
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
comment|/* Read the port mode */
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|port_mode
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|&&
operator|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
operator|)
condition|)
comment|/* In CMT on emulation, assume 1 port */
name|port_mode
operator|=
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
name|port_mode
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_NW_PORT_MODE_BB
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_mode
operator|<
literal|3
condition|)
block|{
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_mode
operator|<=
literal|5
condition|)
block|{
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"PORT MODE: %d not supported\n"
argument_list|,
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
argument_list|)
expr_stmt|;
comment|/* Default num_ports_in_engines to something */
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_hw_info_port_num_ah_e5
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|port
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_ECO_RESERVED
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|port
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
condition|)
block|{
case|case
literal|1
case|:
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Unknown port mode in ECO_RESERVED %08x\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUM_PORTS_K2
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CNIG_REG_NIG_PORT0_CONF_K2_E5
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|&
literal|1
condition|)
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_ports_in_engines
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_hw_info_port_num
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|ecore_hw_info_port_num_bb
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
else|else
name|ecore_hw_info_port_num_ah_e5
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_get_hw_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_pci_personality
name|personality
parameter_list|,
name|struct
name|ecore_hw_prepare_params
modifier|*
name|p_params
parameter_list|)
block|{
name|bool
name|drv_resc_alloc
init|=
name|p_params
operator|->
name|drv_resc_alloc
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* Since all information is common, only first hwfns should do this */
if|if
condition|(
name|IS_LEAD_HWFN
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ecore_iov_hw_info
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_BAD_IOV
expr_stmt|;
else|else
return|return
name|rc
return|;
block|}
block|}
comment|/* TODO In get_hw_info, amoungst others: 	 * Get MCP FW revision and determine according to it the supported 	 * featrues (e.g. DCB) 	 * Get boot mode 	 * ecore_get_pcie_width_speed, WOL capability. 	 * Number of global CQ-s (for storage 	 */
name|ecore_hw_info_port_num
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_mcp_get_capabilities
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_ASIC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|rc
operator|=
name|ecore_hw_get_nvm_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
block|}
endif|#
directive|endif
name|rc
operator|=
name|ecore_int_igu_read_cam
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_BAD_IGU
expr_stmt|;
else|else
return|return
name|rc
return|;
block|}
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_ASIC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|&&
name|ecore_mcp_is_init
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|OSAL_MEMCPY
argument_list|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mac_addr
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
block|}
else|else
block|{
specifier|static
name|u8
name|mcp_hw_mac
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|}
decl_stmt|;
name|OSAL_MEMCPY
argument_list|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mac_addr
argument_list|,
name|mcp_hw_mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mac_addr
index|[
literal|5
index|]
operator|=
name|p_hwfn
operator|->
name|abs_pf_id
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ecore_mcp_is_init
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|ovlan
operator|!=
name|ECORE_MCP_VLAN_UNSET
condition|)
name|p_hwfn
operator|->
name|hw_info
operator|.
name|ovlan
operator|=
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|ovlan
expr_stmt|;
name|ecore_mcp_cmd_port_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|personality
operator|!=
name|ECORE_PCI_DEFAULT
condition|)
block|{
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|=
name|personality
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ecore_mcp_is_init
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|enum
name|ecore_pci_personality
name|protocol
decl_stmt|;
name|protocol
operator|=
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|protocol
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|=
name|protocol
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ASIC_ONLY
comment|/* To overcome ILT lack for emulation, until at least until we'll have 	 * a definite answer from system about it, allow only PF0 to be RoCE. 	 */
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|&&
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|rel_pf_id
condition|)
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|=
name|ECORE_PCI_ETH_ROCE
expr_stmt|;
else|else
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
operator|=
name|ECORE_PCI_ETH
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* although in BB some constellations may support more than 4 tcs, 	 * that can result in performance penalty in some cases. 4 	 * represents a good tradeoff between performance and flexibility. 	 */
name|p_hwfn
operator|->
name|hw_info
operator|.
name|num_hw_tc
operator|=
name|NUM_PHYS_TCS_4PORT_K2
expr_stmt|;
comment|/* start out with a single active tc. This can be increased either 	 * by dcbx negotiation or by upper layer driver 	 */
name|p_hwfn
operator|->
name|hw_info
operator|.
name|num_active_tc
operator|=
literal|1
expr_stmt|;
name|ecore_get_num_funcs
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecore_mcp_is_init
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|p_hwfn
operator|->
name|hw_info
operator|.
name|mtu
operator|=
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|mtu
expr_stmt|;
comment|/* In case of forcing the driver's default resource allocation, calling 	 * ecore_hw_get_resc() should come after initializing the personality 	 * and after getting the number of functions, since the calculation of 	 * the resources/features depends on them. 	 * This order is not harmful if not forcing. 	 */
name|rc
operator|=
name|ecore_hw_get_resc
argument_list|(
name|p_hwfn
argument_list|,
name|drv_resc_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
operator|&&
name|p_params
operator|->
name|b_relaxed_probe
condition|)
block|{
name|rc
operator|=
name|ECORE_SUCCESS
expr_stmt|;
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_BAD_MCP
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_get_dev_info
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|u16
name|device_id_mask
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
comment|/* Read Vendor Id / Device Id */
name|OSAL_PCI_READ_CONFIG_WORD
argument_list|(
name|p_dev
argument_list|,
name|PCICFG_VENDOR_ID_OFFSET
argument_list|,
operator|&
name|p_dev
operator|->
name|vendor_id
argument_list|)
expr_stmt|;
name|OSAL_PCI_READ_CONFIG_WORD
argument_list|(
name|p_dev
argument_list|,
name|PCICFG_DEVICE_ID_OFFSET
argument_list|,
operator|&
name|p_dev
operator|->
name|device_id
argument_list|)
expr_stmt|;
comment|/* Determine type */
name|device_id_mask
operator|=
name|p_dev
operator|->
name|device_id
operator|&
name|ECORE_DEV_ID_MASK
expr_stmt|;
switch|switch
condition|(
name|device_id_mask
condition|)
block|{
case|case
name|ECORE_DEV_ID_MASK_BB
case|:
name|p_dev
operator|->
name|type
operator|=
name|ECORE_DEV_TYPE_BB
expr_stmt|;
break|break;
case|case
name|ECORE_DEV_ID_MASK_AH
case|:
name|p_dev
operator|->
name|type
operator|=
name|ECORE_DEV_TYPE_AH
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unknown device id 0x%x\n"
argument_list|,
name|p_dev
operator|->
name|device_id
argument_list|)
expr_stmt|;
return|return
name|ECORE_ABORTED
return|;
block|}
name|p_dev
operator|->
name|chip_num
operator|=
operator|(
name|u16
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|MISCS_REG_CHIP_NUM
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|chip_rev
operator|=
operator|(
name|u16
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|MISCS_REG_CHIP_REV
argument_list|)
expr_stmt|;
name|MASK_FIELD
argument_list|(
name|CHIP_REV
argument_list|,
name|p_dev
operator|->
name|chip_rev
argument_list|)
expr_stmt|;
comment|/* Learn number of HW-functions */
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|MISCS_REG_CMT_ENABLED_FOR_PAIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
operator|(
literal|1
operator|<<
name|p_hwfn
operator|->
name|rel_pf_id
operator|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
operator|->
name|hwfns
argument_list|,
name|false
argument_list|,
literal|"device in CMT mode\n"
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|num_hwfns
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p_dev
operator|->
name|num_hwfns
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
comment|/* For some reason we have problems with this register 		 * in B0 emulation; Simply assume no CMT 		 */
name|DP_NOTICE
argument_list|(
name|p_dev
operator|->
name|hwfns
argument_list|,
name|false
argument_list|,
literal|"device on emul - assume no CMT\n"
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|num_hwfns
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|p_dev
operator|->
name|chip_bond_id
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|MISCS_REG_CHIP_TEST_REG
argument_list|)
operator|>>
literal|4
expr_stmt|;
name|MASK_FIELD
argument_list|(
name|CHIP_BOND_ID
argument_list|,
name|p_dev
operator|->
name|chip_bond_id
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|chip_metal
operator|=
operator|(
name|u16
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|MISCS_REG_CHIP_METAL
argument_list|)
expr_stmt|;
name|MASK_FIELD
argument_list|(
name|CHIP_METAL
argument_list|,
name|p_dev
operator|->
name|chip_metal
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_dev
operator|->
name|hwfns
argument_list|,
literal|"Chip details - %s %c%d, Num: %04x Rev: %04x Bond id: %04x Metal: %04x\n"
argument_list|,
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
literal|"BB"
else|:
literal|"AH"
argument_list|,
literal|'A'
operator|+
name|p_dev
operator|->
name|chip_rev
argument_list|,
operator|(
name|int
operator|)
name|p_dev
operator|->
name|chip_metal
argument_list|,
name|p_dev
operator|->
name|chip_num
argument_list|,
name|p_dev
operator|->
name|chip_rev
argument_list|,
name|p_dev
operator|->
name|chip_bond_id
argument_list|,
name|p_dev
operator|->
name|chip_metal
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
operator|&&
name|CHIP_REV_IS_A0
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
operator|->
name|hwfns
argument_list|,
name|false
argument_list|,
literal|"The chip type/rev (BB A0) is not supported!\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_ABORTED
return|;
block|}
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_dev
argument_list|)
operator|&&
name|ECORE_IS_AH
argument_list|(
name|p_dev
argument_list|)
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|MISCS_REG_PLL_MAIN_CTRL_4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|MISCS_REG_ECO_RESERVED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
operator|(
literal|1
operator|<<
literal|29
operator|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Emulation: Running on a FULL build\n"
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|b_is_emul_full
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Emulation: Running on a REDUCED build\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|ecore_hw_hibernate_prepare
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
return|return;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|j
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|j
index|]
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IFDOWN
argument_list|,
literal|"Mark hw/fw uninitialized\n"
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|hw_init_done
operator|=
name|false
expr_stmt|;
name|p_hwfn
operator|->
name|first_on_engine
operator|=
name|false
expr_stmt|;
name|ecore_ptt_invalidate
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_hw_hibernate_resume
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
return|return;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|j
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|j
index|]
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
init|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
name|ecore_hw_hwfn_prepare
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"ptt acquire failed\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|ecore_load_mcp_offsets
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IFUP
argument_list|,
literal|"Reinitialized hw after low power state\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_hw_prepare_single
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|void
name|OSAL_IOMEM
modifier|*
name|p_regview
parameter_list|,
name|void
name|OSAL_IOMEM
modifier|*
name|p_doorbells
parameter_list|,
name|struct
name|ecore_hw_prepare_params
modifier|*
name|p_params
parameter_list|)
block|{
name|struct
name|ecore_mdump_retain_data
name|mdump_retain
decl_stmt|;
name|struct
name|ecore_dev
modifier|*
name|p_dev
init|=
name|p_hwfn
operator|->
name|p_dev
decl_stmt|;
name|struct
name|ecore_mdump_info
name|mdump_info
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
comment|/* Split PCI bars evenly between hwfns */
name|p_hwfn
operator|->
name|regview
operator|=
name|p_regview
expr_stmt|;
name|p_hwfn
operator|->
name|doorbells
operator|=
name|p_doorbells
expr_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
return|return
name|ecore_vf_hw_prepare
argument_list|(
name|p_hwfn
argument_list|)
return|;
comment|/* Validate that chip access is feasible */
if|if
condition|(
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|PXP_PF_ME_OPAQUE_ADDR
argument_list|)
operator|==
literal|0xffffffff
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Reading the ME register returns all Fs; Preventing further chip access\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_FAILED_ME
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|get_function_id
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* Allocate PTT pool */
name|rc
operator|=
name|ecore_ptt_pool_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to prepare hwfn's hw\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_FAILED_MEM
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
comment|/* Allocate the main PTT */
name|p_hwfn
operator|->
name|p_main_ptt
operator|=
name|ecore_get_reserved_ptt
argument_list|(
name|p_hwfn
argument_list|,
name|RESERVED_PTT_MAIN
argument_list|)
expr_stmt|;
comment|/* First hwfn learns basic information, e.g., number of hwfns */
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|my_id
condition|)
block|{
name|rc
operator|=
name|ecore_get_dev_info
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_FAILED_DEV
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
block|}
name|ecore_hw_hwfn_prepare
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* Initialize MCP structure */
name|rc
operator|=
name|ecore_mcp_cmd_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed initializing mcp command\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_FAILED_MEM
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Read the device configuration information from the HW and SHMEM */
name|rc
operator|=
name|ecore_get_hw_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|p_params
operator|->
name|personality
argument_list|,
name|p_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to get HW information\n"
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
comment|/* Sending a mailbox to the MFW should be after ecore_get_hw_info() is 	 * called, since among others it sets the ports number in an engine. 	 */
if|if
condition|(
name|p_params
operator|->
name|initiate_pf_flr
operator|&&
name|p_hwfn
operator|==
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
operator|&&
operator|!
name|p_dev
operator|->
name|recov_in_prog
condition|)
block|{
name|rc
operator|=
name|ecore_mcp_initiate_pf_flr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to initiate PF FLR\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Check if mdump logs/data are present and update the epoch value */
if|if
condition|(
name|p_hwfn
operator|==
name|ECORE_LEADING_HWFN
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ecore_mcp_mdump_get_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
operator|&
name|mdump_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
operator|&&
name|mdump_info
operator|.
name|num_of_logs
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"* * * IMPORTANT - HW ERROR register dump captured by device * * *\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_mdump_get_retain
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
operator|&
name|mdump_retain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
operator|&&
name|mdump_retain
operator|.
name|valid
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"mdump retained data: epoch 0x%08x, pf 0x%x, status 0x%08x\n"
argument_list|,
name|mdump_retain
operator|.
name|epoch
argument_list|,
name|mdump_retain
operator|.
name|pf
argument_list|,
name|mdump_retain
operator|.
name|status
argument_list|)
expr_stmt|;
name|ecore_mcp_mdump_set_values
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|p_params
operator|->
name|epoch
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the init RT array and initialize the init-ops engine */
name|rc
operator|=
name|ecore_init_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate the init array\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_FAILED_MEM
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"FPGA: workaround; Prevent DMAE parities\n"
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PCIE_REG_PRTY_MASK_K2_E5
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"FPGA: workaround: Set VF bar0 size\n"
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|PGLUE_B_REG_VF_BAR0_SIZE_K2_E5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|rc
return|;
name|err2
label|:
if|if
condition|(
name|IS_LEAD_HWFN
argument_list|(
name|p_hwfn
argument_list|)
condition|)
name|ecore_iov_free_hw_info
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
name|ecore_mcp_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|err1
label|:
name|ecore_hw_hwfn_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|err0
label|:
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_hw_prepare
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_hw_prepare_params
modifier|*
name|p_params
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|p_dev
operator|->
name|chk_reg_fifo
operator|=
name|p_params
operator|->
name|chk_reg_fifo
expr_stmt|;
name|p_dev
operator|->
name|allow_mdump
operator|=
name|p_params
operator|->
name|allow_mdump
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_SUCCESS
expr_stmt|;
comment|/* Store the precompiled init data ptrs */
if|if
condition|(
name|IS_PF
argument_list|(
name|p_dev
argument_list|)
condition|)
name|ecore_init_iro_array
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
comment|/* Initialize the first hwfn - will learn number of hwfns */
name|rc
operator|=
name|ecore_hw_prepare_single
argument_list|(
name|p_hwfn
argument_list|,
name|p_dev
operator|->
name|regview
argument_list|,
name|p_dev
operator|->
name|doorbells
argument_list|,
name|p_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|p_params
operator|->
name|personality
operator|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|personality
expr_stmt|;
comment|/* initilalize 2nd hwfn if necessary */
if|if
condition|(
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
block|{
name|void
name|OSAL_IOMEM
modifier|*
name|p_regview
decl_stmt|,
modifier|*
name|p_doorbell
decl_stmt|;
name|u8
name|OSAL_IOMEM
modifier|*
name|addr
decl_stmt|;
comment|/* adjust bar offset for second engine */
name|addr
operator|=
operator|(
name|u8
name|OSAL_IOMEM
operator|*
operator|)
name|p_dev
operator|->
name|regview
operator|+
name|ecore_hw_bar_size
argument_list|(
name|p_hwfn
argument_list|,
name|BAR_ID_0
argument_list|)
operator|/
literal|2
expr_stmt|;
name|p_regview
operator|=
operator|(
name|void
name|OSAL_IOMEM
operator|*
operator|)
name|addr
expr_stmt|;
name|addr
operator|=
operator|(
name|u8
name|OSAL_IOMEM
operator|*
operator|)
name|p_dev
operator|->
name|doorbells
operator|+
name|ecore_hw_bar_size
argument_list|(
name|p_hwfn
argument_list|,
name|BAR_ID_1
argument_list|)
operator|/
literal|2
expr_stmt|;
name|p_doorbell
operator|=
operator|(
name|void
name|OSAL_IOMEM
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* prepare second hw function */
name|rc
operator|=
name|ecore_hw_prepare_single
argument_list|(
operator|&
name|p_dev
operator|->
name|hwfns
index|[
literal|1
index|]
argument_list|,
name|p_regview
argument_list|,
name|p_doorbell
argument_list|,
name|p_params
argument_list|)
expr_stmt|;
comment|/* in case of error, need to free the previously 		 * initiliazed hwfn 0. 		 */
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
if|if
condition|(
name|p_params
operator|->
name|b_relaxed_probe
condition|)
name|p_params
operator|->
name|p_relaxed_res
operator|=
name|ECORE_HW_PREPARE_FAILED_ENG2
expr_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_init_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_mcp_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_hw_hwfn_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"What do we need to free when VF hwfn1 init fails\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_hw_remove
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|p_dev
argument_list|)
condition|)
name|ecore_mcp_ov_update_driver_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|,
name|ECORE_OV_DRIVER_STATE_NOT_LOADED
argument_list|)
expr_stmt|;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_vf_pf_release
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ecore_init_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_hw_hwfn_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_mcp_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|OSAL_MUTEX_DEALLOC
argument_list|(
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
name|ecore_iov_free_hw_info
argument_list|(
name|p_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_chain_free_next_ptr
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|void
modifier|*
name|p_virt
init|=
name|p_chain
operator|->
name|p_virt_addr
decl_stmt|,
modifier|*
name|p_virt_next
init|=
name|OSAL_NULL
decl_stmt|;
name|dma_addr_t
name|p_phys
init|=
name|p_chain
operator|->
name|p_phys_addr
decl_stmt|,
name|p_phys_next
init|=
literal|0
decl_stmt|;
name|struct
name|ecore_chain_next
modifier|*
name|p_next
decl_stmt|;
name|u32
name|size
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
return|return;
name|size
operator|=
name|p_chain
operator|->
name|elem_size
operator|*
name|p_chain
operator|->
name|usable_per_page
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_chain
operator|->
name|page_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p_virt
condition|)
break|break;
name|p_next
operator|=
operator|(
expr|struct
name|ecore_chain_next
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|p_virt
operator|+
name|size
operator|)
expr_stmt|;
name|p_virt_next
operator|=
name|p_next
operator|->
name|next_virt
expr_stmt|;
name|p_phys_next
operator|=
name|HILO_DMA_REGPAIR
argument_list|(
name|p_next
operator|->
name|next_phys
argument_list|)
expr_stmt|;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_dev
argument_list|,
name|p_virt
argument_list|,
name|p_phys
argument_list|,
name|ECORE_CHAIN_PAGE_SIZE
argument_list|)
expr_stmt|;
name|p_virt
operator|=
name|p_virt_next
expr_stmt|;
name|p_phys
operator|=
name|p_phys_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_chain_free_single
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_chain
operator|->
name|p_virt_addr
condition|)
return|return;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_dev
argument_list|,
name|p_chain
operator|->
name|p_virt_addr
argument_list|,
name|p_chain
operator|->
name|p_phys_addr
argument_list|,
name|ECORE_CHAIN_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_chain_free_pbl
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|pp_virt_addr_tbl
init|=
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
decl_stmt|;
name|u8
modifier|*
name|p_pbl_virt
init|=
operator|(
name|u8
operator|*
operator|)
name|p_chain
operator|->
name|pbl_sp
operator|.
name|p_virt_table
decl_stmt|;
name|u32
name|page_cnt
init|=
name|p_chain
operator|->
name|page_cnt
decl_stmt|,
name|i
decl_stmt|,
name|pbl_size
decl_stmt|;
if|if
condition|(
operator|!
name|pp_virt_addr_tbl
condition|)
return|return;
if|if
condition|(
operator|!
name|p_pbl_virt
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|pp_virt_addr_tbl
index|[
name|i
index|]
condition|)
break|break;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_dev
argument_list|,
name|pp_virt_addr_tbl
index|[
name|i
index|]
argument_list|,
operator|*
operator|(
name|dma_addr_t
operator|*
operator|)
name|p_pbl_virt
argument_list|,
name|ECORE_CHAIN_PAGE_SIZE
argument_list|)
expr_stmt|;
name|p_pbl_virt
operator|+=
name|ECORE_CHAIN_PBL_ENTRY_SIZE
expr_stmt|;
block|}
name|pbl_size
operator|=
name|page_cnt
operator|*
name|ECORE_CHAIN_PBL_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|p_chain
operator|->
name|b_external_pbl
condition|)
block|{
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_dev
argument_list|,
name|p_chain
operator|->
name|pbl_sp
operator|.
name|p_virt_table
argument_list|,
name|p_chain
operator|->
name|pbl_sp
operator|.
name|p_phys_table
argument_list|,
name|pbl_size
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|OSAL_VFREE
argument_list|(
name|p_dev
argument_list|,
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
argument_list|)
expr_stmt|;
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_chain_free
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
switch|switch
condition|(
name|p_chain
operator|->
name|mode
condition|)
block|{
case|case
name|ECORE_CHAIN_MODE_NEXT_PTR
case|:
name|ecore_chain_free_next_ptr
argument_list|(
name|p_dev
argument_list|,
name|p_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_CHAIN_MODE_SINGLE
case|:
name|ecore_chain_free_single
argument_list|(
name|p_dev
argument_list|,
name|p_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_CHAIN_MODE_PBL
case|:
name|ecore_chain_free_pbl
argument_list|(
name|p_dev
argument_list|,
name|p_chain
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_chain_alloc_sanity_check
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|enum
name|ecore_chain_cnt_type
name|cnt_type
parameter_list|,
name|osal_size_t
name|elem_size
parameter_list|,
name|u32
name|page_cnt
parameter_list|)
block|{
name|u64
name|chain_size
init|=
name|ELEMS_PER_PAGE
argument_list|(
name|elem_size
argument_list|)
operator|*
name|page_cnt
decl_stmt|;
comment|/* The actual chain size can be larger than the maximal possible value 	 * after rounding up the requested elements number to pages, and after 	 * taking into acount the unusuable elements (next-ptr elements). 	 * The size of a "u16" chain can be (U16_MAX + 1) since the chain 	 * size/capacity fields are of a u32 type. 	 */
if|if
condition|(
operator|(
name|cnt_type
operator|==
name|ECORE_CHAIN_CNT_TYPE_U16
operator|&&
name|chain_size
operator|>
operator|(
operator|(
name|u32
operator|)
name|ECORE_U16_MAX
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
name|cnt_type
operator|==
name|ECORE_CHAIN_CNT_TYPE_U32
operator|&&
name|chain_size
operator|>
name|ECORE_U32_MAX
operator|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"The actual chain size (0x%llx) is larger than the maximal possible value\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|chain_size
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_chain_alloc_next_ptr
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|void
modifier|*
name|p_virt
init|=
name|OSAL_NULL
decl_stmt|,
modifier|*
name|p_virt_prev
init|=
name|OSAL_NULL
decl_stmt|;
name|dma_addr_t
name|p_phys
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_chain
operator|->
name|page_cnt
condition|;
name|i
operator|++
control|)
block|{
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_dev
argument_list|,
operator|&
name|p_phys
argument_list|,
name|ECORE_CHAIN_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate chain memory\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|ecore_chain_init_mem
argument_list|(
name|p_chain
argument_list|,
name|p_virt
argument_list|,
name|p_phys
argument_list|)
expr_stmt|;
name|ecore_chain_reset
argument_list|(
name|p_chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ecore_chain_init_next_ptr_elem
argument_list|(
name|p_chain
argument_list|,
name|p_virt_prev
argument_list|,
name|p_virt
argument_list|,
name|p_phys
argument_list|)
expr_stmt|;
block|}
name|p_virt_prev
operator|=
name|p_virt
expr_stmt|;
block|}
comment|/* Last page's next element should point to the beginning of the 	 * chain. 	 */
name|ecore_chain_init_next_ptr_elem
argument_list|(
name|p_chain
argument_list|,
name|p_virt_prev
argument_list|,
name|p_chain
operator|->
name|p_virt_addr
argument_list|,
name|p_chain
operator|->
name|p_phys_addr
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_chain_alloc_single
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|dma_addr_t
name|p_phys
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|p_virt
init|=
name|OSAL_NULL
decl_stmt|;
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_dev
argument_list|,
operator|&
name|p_phys
argument_list|,
name|ECORE_CHAIN_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate chain memory\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
name|ecore_chain_init_mem
argument_list|(
name|p_chain
argument_list|,
name|p_virt
argument_list|,
name|p_phys
argument_list|)
expr_stmt|;
name|ecore_chain_reset
argument_list|(
name|p_chain
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_chain_alloc_pbl
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|struct
name|ecore_chain_ext_pbl
modifier|*
name|ext_pbl
parameter_list|)
block|{
name|void
modifier|*
name|p_virt
init|=
name|OSAL_NULL
decl_stmt|;
name|u8
modifier|*
name|p_pbl_virt
init|=
name|OSAL_NULL
decl_stmt|;
name|void
modifier|*
modifier|*
name|pp_virt_addr_tbl
init|=
name|OSAL_NULL
decl_stmt|;
name|dma_addr_t
name|p_phys
init|=
literal|0
decl_stmt|,
name|p_pbl_phys
init|=
literal|0
decl_stmt|;
name|u32
name|page_cnt
init|=
name|p_chain
operator|->
name|page_cnt
decl_stmt|,
name|size
decl_stmt|,
name|i
decl_stmt|;
name|size
operator|=
name|page_cnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pp_virt_addr_tbl
argument_list|)
expr_stmt|;
name|pp_virt_addr_tbl
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|OSAL_VZALLOC
argument_list|(
name|p_dev
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pp_virt_addr_tbl
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate memory for the chain virtual addresses table\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* The allocation of the PBL table is done with its full size, since it 	 * is expected to be successive. 	 * ecore_chain_init_pbl_mem() is called even in a case of an allocation 	 * failure, since pp_virt_addr_tbl was previously allocated, and it 	 * should be saved to allow its freeing during the error flow. 	 */
name|size
operator|=
name|page_cnt
operator|*
name|ECORE_CHAIN_PBL_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|ext_pbl
operator|==
name|OSAL_NULL
condition|)
block|{
name|p_pbl_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_dev
argument_list|,
operator|&
name|p_pbl_phys
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_pbl_virt
operator|=
name|ext_pbl
operator|->
name|p_pbl_virt
expr_stmt|;
name|p_pbl_phys
operator|=
name|ext_pbl
operator|->
name|p_pbl_phys
expr_stmt|;
name|p_chain
operator|->
name|b_external_pbl
operator|=
name|true
expr_stmt|;
block|}
name|ecore_chain_init_pbl_mem
argument_list|(
name|p_chain
argument_list|,
name|p_pbl_virt
argument_list|,
name|p_pbl_phys
argument_list|,
name|pp_virt_addr_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_pbl_virt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate chain pbl memory\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_cnt
condition|;
name|i
operator|++
control|)
block|{
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_dev
argument_list|,
operator|&
name|p_phys
argument_list|,
name|ECORE_CHAIN_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate chain memory\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|ecore_chain_init_mem
argument_list|(
name|p_chain
argument_list|,
name|p_virt
argument_list|,
name|p_phys
argument_list|)
expr_stmt|;
name|ecore_chain_reset
argument_list|(
name|p_chain
argument_list|)
expr_stmt|;
block|}
comment|/* Fill the PBL table with the physical address of the page */
operator|*
operator|(
name|dma_addr_t
operator|*
operator|)
name|p_pbl_virt
operator|=
name|p_phys
expr_stmt|;
comment|/* Keep the virtual address of the page */
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
index|[
name|i
index|]
operator|=
name|p_virt
expr_stmt|;
name|p_pbl_virt
operator|+=
name|ECORE_CHAIN_PBL_ENTRY_SIZE
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_chain_alloc
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|enum
name|ecore_chain_use_mode
name|intended_use
parameter_list|,
name|enum
name|ecore_chain_mode
name|mode
parameter_list|,
name|enum
name|ecore_chain_cnt_type
name|cnt_type
parameter_list|,
name|u32
name|num_elems
parameter_list|,
name|osal_size_t
name|elem_size
parameter_list|,
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|struct
name|ecore_chain_ext_pbl
modifier|*
name|ext_pbl
parameter_list|)
block|{
name|u32
name|page_cnt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|ECORE_CHAIN_MODE_SINGLE
condition|)
name|page_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|page_cnt
operator|=
name|ECORE_CHAIN_PAGE_CNT
argument_list|(
name|num_elems
argument_list|,
name|elem_size
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_chain_alloc_sanity_check
argument_list|(
name|p_dev
argument_list|,
name|cnt_type
argument_list|,
name|elem_size
argument_list|,
name|page_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Cannot allocate a chain with the given arguments:\n"
literal|"[use_mode %d, mode %d, cnt_type %d, num_elems %d, elem_size %zu]\n"
argument_list|,
name|intended_use
argument_list|,
name|mode
argument_list|,
name|cnt_type
argument_list|,
name|num_elems
argument_list|,
name|elem_size
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|ecore_chain_init_params
argument_list|(
name|p_chain
argument_list|,
name|page_cnt
argument_list|,
operator|(
name|u8
operator|)
name|elem_size
argument_list|,
name|intended_use
argument_list|,
name|mode
argument_list|,
name|cnt_type
argument_list|,
name|p_dev
operator|->
name|dp_ctx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ECORE_CHAIN_MODE_NEXT_PTR
case|:
name|rc
operator|=
name|ecore_chain_alloc_next_ptr
argument_list|(
name|p_dev
argument_list|,
name|p_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_CHAIN_MODE_SINGLE
case|:
name|rc
operator|=
name|ecore_chain_alloc_single
argument_list|(
name|p_dev
argument_list|,
name|p_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_CHAIN_MODE_PBL
case|:
name|rc
operator|=
name|ecore_chain_alloc_pbl
argument_list|(
name|p_dev
argument_list|,
name|p_chain
argument_list|,
name|ext_pbl
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rc
condition|)
goto|goto
name|nomem
goto|;
return|return
name|ECORE_SUCCESS
return|;
name|nomem
label|:
name|ecore_chain_free
argument_list|(
name|p_dev
argument_list|,
name|p_chain
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_fw_l2_queue
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|src_id
parameter_list|,
name|u16
modifier|*
name|dst_id
parameter_list|)
block|{
if|if
condition|(
name|src_id
operator|>=
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_L2_QUEUE
argument_list|)
condition|)
block|{
name|u16
name|min
decl_stmt|,
name|max
decl_stmt|;
name|min
operator|=
operator|(
name|u16
operator|)
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_L2_QUEUE
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
operator|+
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_L2_QUEUE
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"l2_queue id [%d] is not valid, available indices [%d - %d]\n"
argument_list|,
name|src_id
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
operator|*
name|dst_id
operator|=
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_L2_QUEUE
argument_list|)
operator|+
name|src_id
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_fw_vport
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|src_id
parameter_list|,
name|u8
modifier|*
name|dst_id
parameter_list|)
block|{
if|if
condition|(
name|src_id
operator|>=
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VPORT
argument_list|)
condition|)
block|{
name|u8
name|min
decl_stmt|,
name|max
decl_stmt|;
name|min
operator|=
operator|(
name|u8
operator|)
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VPORT
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
operator|+
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VPORT
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"vport id [%d] is not valid, available indices [%d - %d]\n"
argument_list|,
name|src_id
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
operator|*
name|dst_id
operator|=
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_VPORT
argument_list|)
operator|+
name|src_id
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_fw_rss_eng
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|src_id
parameter_list|,
name|u8
modifier|*
name|dst_id
parameter_list|)
block|{
if|if
condition|(
name|src_id
operator|>=
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_RSS_ENG
argument_list|)
condition|)
block|{
name|u8
name|min
decl_stmt|,
name|max
decl_stmt|;
name|min
operator|=
operator|(
name|u8
operator|)
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_RSS_ENG
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
operator|+
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_RSS_ENG
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"rss_eng id [%d] is not valid, available indices [%d - %d]\n"
argument_list|,
name|src_id
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
operator|*
name|dst_id
operator|=
name|RESC_START
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_RSS_ENG
argument_list|)
operator|+
name|src_id
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_llh_add_mac_filter_bb_ah
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|high
parameter_list|,
name|u32
name|low
parameter_list|,
name|u32
modifier|*
name|p_entry_num
parameter_list|)
block|{
name|u32
name|en
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find a free entry and utilize it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|en
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_EN_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|en
condition|)
continue|continue;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
literal|2
operator|*
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
operator|(
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_MODE_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_PROTOCOL_TYPE_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_EN_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|)
return|return
name|ECORE_NORESOURCES
return|;
operator|*
name|p_entry_num
operator|=
name|i
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_llh_add_mac_filter_e5
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|high
parameter_list|,
name|u32
name|low
parameter_list|,
name|u32
modifier|*
name|p_entry_num
parameter_list|)
block|{
name|ECORE_E5_MISSING_CODE
expr_stmt|;
return|return
name|ECORE_NOTIMPL
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_llh_add_mac_filter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
modifier|*
name|p_filter
parameter_list|)
block|{
name|u32
name|high
decl_stmt|,
name|low
decl_stmt|,
name|entry_num
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|IS_MF_SI
argument_list|(
name|p_hwfn
argument_list|)
operator|||
name|IS_MF_DEFAULT
argument_list|(
name|p_hwfn
argument_list|)
operator|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|high
operator|=
name|p_filter
index|[
literal|1
index|]
operator||
operator|(
name|p_filter
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|low
operator|=
name|p_filter
index|[
literal|5
index|]
operator||
operator|(
name|p_filter
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|p_filter
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p_filter
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|rc
operator|=
name|ecore_llh_add_mac_filter_bb_ah
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
operator|&
name|entry_num
argument_list|)
expr_stmt|;
else|else
comment|/* E5 */
name|rc
operator|=
name|ecore_llh_add_mac_filter_e5
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
operator|&
name|entry_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to find an empty LLH filter to utilize\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"MAC: %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx is added at LLH entry %d\n"
argument_list|,
name|p_filter
index|[
literal|0
index|]
argument_list|,
name|p_filter
index|[
literal|1
index|]
argument_list|,
name|p_filter
index|[
literal|2
index|]
argument_list|,
name|p_filter
index|[
literal|3
index|]
argument_list|,
name|p_filter
index|[
literal|4
index|]
argument_list|,
name|p_filter
index|[
literal|5
index|]
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_llh_remove_mac_filter_bb_ah
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|high
parameter_list|,
name|u32
name|low
parameter_list|,
name|u32
modifier|*
name|p_entry_num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Find the entry and clean it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
literal|2
operator|*
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
operator|!=
name|low
condition|)
continue|continue;
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
operator|(
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
operator|!=
name|high
condition|)
continue|continue;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_EN_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
literal|2
operator|*
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
operator|(
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|)
return|return
name|ECORE_INVAL
return|;
operator|*
name|p_entry_num
operator|=
name|i
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_llh_remove_mac_filter_e5
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|high
parameter_list|,
name|u32
name|low
parameter_list|,
name|u32
modifier|*
name|p_entry_num
parameter_list|)
block|{
name|ECORE_E5_MISSING_CODE
expr_stmt|;
return|return
name|ECORE_NOTIMPL
return|;
block|}
end_function

begin_function
name|void
name|ecore_llh_remove_mac_filter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
modifier|*
name|p_filter
parameter_list|)
block|{
name|u32
name|high
decl_stmt|,
name|low
decl_stmt|,
name|entry_num
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|IS_MF_SI
argument_list|(
name|p_hwfn
argument_list|)
operator|||
name|IS_MF_DEFAULT
argument_list|(
name|p_hwfn
argument_list|)
operator|)
condition|)
return|return;
name|high
operator|=
name|p_filter
index|[
literal|1
index|]
operator||
operator|(
name|p_filter
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|low
operator|=
name|p_filter
index|[
literal|5
index|]
operator||
operator|(
name|p_filter
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|p_filter
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p_filter
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|rc
operator|=
name|ecore_llh_remove_mac_filter_bb_ah
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
operator|&
name|entry_num
argument_list|)
expr_stmt|;
else|else
comment|/* E5 */
name|rc
operator|=
name|ecore_llh_remove_mac_filter_e5
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
operator|&
name|entry_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Tried to remove a non-configured filter [MAC %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx]\n"
argument_list|,
name|p_filter
index|[
literal|0
index|]
argument_list|,
name|p_filter
index|[
literal|1
index|]
argument_list|,
name|p_filter
index|[
literal|2
index|]
argument_list|,
name|p_filter
index|[
literal|3
index|]
argument_list|,
name|p_filter
index|[
literal|4
index|]
argument_list|,
name|p_filter
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"MAC: %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx was removed from LLH entry %d\n"
argument_list|,
name|p_filter
index|[
literal|0
index|]
argument_list|,
name|p_filter
index|[
literal|1
index|]
argument_list|,
name|p_filter
index|[
literal|2
index|]
argument_list|,
name|p_filter
index|[
literal|3
index|]
argument_list|,
name|p_filter
index|[
literal|4
index|]
argument_list|,
name|p_filter
index|[
literal|5
index|]
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_llh_add_protocol_filter_bb_ah
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_llh_port_filter_type_t
name|type
parameter_list|,
name|u32
name|high
parameter_list|,
name|u32
name|low
parameter_list|,
name|u32
modifier|*
name|p_entry_num
parameter_list|)
block|{
name|u32
name|en
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find a free entry and utilize it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|en
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_EN_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|en
condition|)
continue|continue;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
literal|2
operator|*
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
operator|(
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_MODE_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_PROTOCOL_TYPE_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|1
operator|<<
name|type
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_EN_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|)
return|return
name|ECORE_NORESOURCES
return|;
operator|*
name|p_entry_num
operator|=
name|i
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_llh_add_protocol_filter_e5
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_llh_port_filter_type_t
name|type
parameter_list|,
name|u32
name|high
parameter_list|,
name|u32
name|low
parameter_list|,
name|u32
modifier|*
name|p_entry_num
parameter_list|)
block|{
name|ECORE_E5_MISSING_CODE
expr_stmt|;
return|return
name|ECORE_NOTIMPL
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_llh_add_protocol_filter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|source_port_or_eth_type
parameter_list|,
name|u16
name|dest_port
parameter_list|,
name|enum
name|ecore_llh_port_filter_type_t
name|type
parameter_list|)
block|{
name|u32
name|high
decl_stmt|,
name|low
decl_stmt|,
name|entry_num
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|IS_MF_SI
argument_list|(
name|p_hwfn
argument_list|)
operator|||
name|IS_MF_DEFAULT
argument_list|(
name|p_hwfn
argument_list|)
operator|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|high
operator|=
literal|0
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ECORE_LLH_FILTER_ETHERTYPE
case|:
name|high
operator|=
name|source_port_or_eth_type
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_SRC_PORT
case|:
case|case
name|ECORE_LLH_FILTER_UDP_SRC_PORT
case|:
name|low
operator|=
name|source_port_or_eth_type
operator|<<
literal|16
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_DEST_PORT
case|:
case|case
name|ECORE_LLH_FILTER_UDP_DEST_PORT
case|:
name|low
operator|=
name|dest_port
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_SRC_AND_DEST_PORT
case|:
case|case
name|ECORE_LLH_FILTER_UDP_SRC_AND_DEST_PORT
case|:
name|low
operator|=
operator|(
name|source_port_or_eth_type
operator|<<
literal|16
operator|)
operator||
name|dest_port
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Non valid LLH protocol filter type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|rc
operator|=
name|ecore_llh_add_protocol_filter_bb_ah
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|type
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
operator|&
name|entry_num
argument_list|)
expr_stmt|;
else|else
comment|/* E5 */
name|rc
operator|=
name|ecore_llh_add_protocol_filter_e5
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|type
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
operator|&
name|entry_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to find an empty LLH filter to utilize\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ECORE_LLH_FILTER_ETHERTYPE
case|:
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"ETH type %x is added at LLH entry %d\n"
argument_list|,
name|source_port_or_eth_type
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_SRC_PORT
case|:
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"TCP src port %x is added at LLH entry %d\n"
argument_list|,
name|source_port_or_eth_type
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_UDP_SRC_PORT
case|:
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"UDP src port %x is added at LLH entry %d\n"
argument_list|,
name|source_port_or_eth_type
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_DEST_PORT
case|:
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"TCP dst port %x is added at LLH entry %d\n"
argument_list|,
name|dest_port
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_UDP_DEST_PORT
case|:
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"UDP dst port %x is added at LLH entry %d\n"
argument_list|,
name|dest_port
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_SRC_AND_DEST_PORT
case|:
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"TCP src/dst ports %x/%x are added at LLH entry %d\n"
argument_list|,
name|source_port_or_eth_type
argument_list|,
name|dest_port
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_UDP_SRC_AND_DEST_PORT
case|:
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"UDP src/dst ports %x/%x are added at LLH entry %d\n"
argument_list|,
name|source_port_or_eth_type
argument_list|,
name|dest_port
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_llh_remove_protocol_filter_bb_ah
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_llh_port_filter_type_t
name|type
parameter_list|,
name|u32
name|high
parameter_list|,
name|u32
name|low
parameter_list|,
name|u32
modifier|*
name|p_entry_num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Find the entry and clean it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_EN_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_MODE_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_PROTOCOL_TYPE_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|type
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
literal|2
operator|*
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
operator|!=
name|low
condition|)
continue|continue;
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
operator|(
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
operator|!=
name|high
condition|)
continue|continue;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_EN_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_MODE_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_PROTOCOL_TYPE_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
literal|2
operator|*
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
operator|(
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|)
return|return
name|ECORE_INVAL
return|;
operator|*
name|p_entry_num
operator|=
name|i
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_llh_remove_protocol_filter_e5
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_llh_port_filter_type_t
name|type
parameter_list|,
name|u32
name|high
parameter_list|,
name|u32
name|low
parameter_list|,
name|u32
modifier|*
name|p_entry_num
parameter_list|)
block|{
name|ECORE_E5_MISSING_CODE
expr_stmt|;
return|return
name|ECORE_NOTIMPL
return|;
block|}
end_function

begin_function
name|void
name|ecore_llh_remove_protocol_filter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|source_port_or_eth_type
parameter_list|,
name|u16
name|dest_port
parameter_list|,
name|enum
name|ecore_llh_port_filter_type_t
name|type
parameter_list|)
block|{
name|u32
name|high
decl_stmt|,
name|low
decl_stmt|,
name|entry_num
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|IS_MF_SI
argument_list|(
name|p_hwfn
argument_list|)
operator|||
name|IS_MF_DEFAULT
argument_list|(
name|p_hwfn
argument_list|)
operator|)
condition|)
return|return;
name|high
operator|=
literal|0
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ECORE_LLH_FILTER_ETHERTYPE
case|:
name|high
operator|=
name|source_port_or_eth_type
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_SRC_PORT
case|:
case|case
name|ECORE_LLH_FILTER_UDP_SRC_PORT
case|:
name|low
operator|=
name|source_port_or_eth_type
operator|<<
literal|16
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_DEST_PORT
case|:
case|case
name|ECORE_LLH_FILTER_UDP_DEST_PORT
case|:
name|low
operator|=
name|dest_port
expr_stmt|;
break|break;
case|case
name|ECORE_LLH_FILTER_TCP_SRC_AND_DEST_PORT
case|:
case|case
name|ECORE_LLH_FILTER_UDP_SRC_AND_DEST_PORT
case|:
name|low
operator|=
operator|(
name|source_port_or_eth_type
operator|<<
literal|16
operator|)
operator||
name|dest_port
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Non valid LLH protocol filter type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|rc
operator|=
name|ecore_llh_remove_protocol_filter_bb_ah
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|type
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
operator|&
name|entry_num
argument_list|)
expr_stmt|;
else|else
comment|/* E5 */
name|rc
operator|=
name|ecore_llh_remove_protocol_filter_e5
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|type
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
operator|&
name|entry_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Tried to remove a non-configured filter [type %d, source_port_or_eth_type 0x%x, dest_port 0x%x]\n"
argument_list|,
name|type
argument_list|,
name|source_port_or_eth_type
argument_list|,
name|dest_port
argument_list|)
expr_stmt|;
return|return;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"Protocol filter [type %d, source_port_or_eth_type 0x%x, dest_port 0x%x] was removed from LLH entry %d\n"
argument_list|,
name|type
argument_list|,
name|source_port_or_eth_type
argument_list|,
name|dest_port
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_llh_clear_all_filters_bb_ah
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIG_REG_LLH_FUNC_FILTER_EN_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_EN_BB_K2
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
literal|2
operator|*
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_FILTER_VALUE_BB_K2
operator|+
operator|(
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_llh_clear_all_filters_e5
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|ECORE_E5_MISSING_CODE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_llh_clear_all_filters
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|IS_MF_SI
argument_list|(
name|p_hwfn
argument_list|)
operator|||
name|IS_MF_DEFAULT
argument_list|(
name|p_hwfn
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|ecore_llh_clear_all_filters_bb_ah
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
else|else
comment|/* E5 */
name|ecore_llh_clear_all_filters_e5
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_llh_set_function_as_default
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
if|if
condition|(
name|IS_MF_DEFAULT
argument_list|(
name|p_hwfn
argument_list|)
operator|&&
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_TAGMAC_DEF_PF_VECTOR
argument_list|,
literal|1
operator|<<
name|p_hwfn
operator|->
name|abs_pf_id
operator|/
literal|2
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_MSG_INFO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"This function can't be set as default\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_set_coalesce
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|hw_addr
parameter_list|,
name|void
modifier|*
name|p_eth_qzone
parameter_list|,
name|osal_size_t
name|eth_qzone_size
parameter_list|,
name|u8
name|timeset
parameter_list|)
block|{
name|struct
name|coalescing_timeset
modifier|*
name|p_coal_timeset
decl_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|int_coalescing_mode
operator|!=
name|ECORE_COAL_MODE_ENABLE
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Coalescing configuration not enabled\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|p_coal_timeset
operator|=
name|p_eth_qzone
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_eth_qzone
argument_list|,
literal|0
argument_list|,
name|eth_qzone_size
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_coal_timeset
operator|->
name|value
argument_list|,
name|COALESCING_TIMESET_TIMESET
argument_list|,
name|timeset
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_coal_timeset
operator|->
name|value
argument_list|,
name|COALESCING_TIMESET_VALID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_memcpy_to
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|hw_addr
argument_list|,
name|p_eth_qzone
argument_list|,
name|eth_qzone_size
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_set_queue_coalesce
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|rx_coal
parameter_list|,
name|u16
name|tx_coal
parameter_list|,
name|void
modifier|*
name|p_handle
parameter_list|)
block|{
name|struct
name|ecore_queue_cid
modifier|*
name|p_cid
init|=
operator|(
expr|struct
name|ecore_queue_cid
operator|*
operator|)
name|p_handle
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
comment|/* TODO - Configuring a single queue's coalescing but 	 * claiming all queues are abiding same configuration 	 * for PF and VF both. 	 */
ifdef|#
directive|ifdef
name|CONFIG_ECORE_SRIOV
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ecore_vf_pf_set_coalesce
argument_list|(
name|p_hwfn
argument_list|,
name|rx_coal
argument_list|,
name|tx_coal
argument_list|,
name|p_cid
argument_list|)
return|;
endif|#
directive|endif
comment|/* #ifdef CONFIG_ECORE_SRIOV */
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_AGAIN
return|;
if|if
condition|(
name|rx_coal
condition|)
block|{
name|rc
operator|=
name|ecore_set_rxq_coalesce
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|rx_coal
argument_list|,
name|p_cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|out
goto|;
name|p_hwfn
operator|->
name|p_dev
operator|->
name|rx_coalesce_usecs
operator|=
name|rx_coal
expr_stmt|;
block|}
if|if
condition|(
name|tx_coal
condition|)
block|{
name|rc
operator|=
name|ecore_set_txq_coalesce
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|tx_coal
argument_list|,
name|p_cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|out
goto|;
name|p_hwfn
operator|->
name|p_dev
operator|->
name|tx_coalesce_usecs
operator|=
name|tx_coal
expr_stmt|;
block|}
name|out
label|:
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_set_rxq_coalesce
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|coalesce
parameter_list|,
name|struct
name|ecore_queue_cid
modifier|*
name|p_cid
parameter_list|)
block|{
name|struct
name|ustorm_eth_queue_zone
name|eth_qzone
decl_stmt|;
name|u8
name|timeset
decl_stmt|,
name|timer_res
decl_stmt|;
name|u32
name|address
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* Coalesce = (timeset<< timer-resolution), timeset is 7bit wide */
if|if
condition|(
name|coalesce
operator|<=
literal|0x7F
condition|)
name|timer_res
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|coalesce
operator|<=
literal|0xFF
condition|)
name|timer_res
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|coalesce
operator|<=
literal|0x1FF
condition|)
name|timer_res
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Invalid coalesce value - %d\n"
argument_list|,
name|coalesce
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|timeset
operator|=
call|(
name|u8
call|)
argument_list|(
name|coalesce
operator|>>
name|timer_res
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_int_set_timer_res
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|timer_res
argument_list|,
name|p_cid
operator|->
name|sb_igu_id
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|address
operator|=
name|BAR0_MAP_REG_USDM_RAM
operator|+
name|USTORM_ETH_QUEUE_ZONE_OFFSET
argument_list|(
name|p_cid
operator|->
name|abs
operator|.
name|queue_id
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_set_coalesce
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|address
argument_list|,
operator|&
name|eth_qzone
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ustorm_eth_queue_zone
argument_list|)
argument_list|,
name|timeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|out
label|:
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_set_txq_coalesce
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|coalesce
parameter_list|,
name|struct
name|ecore_queue_cid
modifier|*
name|p_cid
parameter_list|)
block|{
name|struct
name|xstorm_eth_queue_zone
name|eth_qzone
decl_stmt|;
name|u8
name|timeset
decl_stmt|,
name|timer_res
decl_stmt|;
name|u32
name|address
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* Coalesce = (timeset<< timer-resolution), timeset is 7bit wide */
if|if
condition|(
name|coalesce
operator|<=
literal|0x7F
condition|)
name|timer_res
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|coalesce
operator|<=
literal|0xFF
condition|)
name|timer_res
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|coalesce
operator|<=
literal|0x1FF
condition|)
name|timer_res
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Invalid coalesce value - %d\n"
argument_list|,
name|coalesce
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|timeset
operator|=
call|(
name|u8
call|)
argument_list|(
name|coalesce
operator|>>
name|timer_res
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_int_set_timer_res
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|timer_res
argument_list|,
name|p_cid
operator|->
name|sb_igu_id
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|address
operator|=
name|BAR0_MAP_REG_XSDM_RAM
operator|+
name|XSTORM_ETH_QUEUE_ZONE_OFFSET
argument_list|(
name|p_cid
operator|->
name|abs
operator|.
name|queue_id
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_set_coalesce
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|address
argument_list|,
operator|&
name|eth_qzone
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xstorm_eth_queue_zone
argument_list|)
argument_list|,
name|timeset
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Calculate final WFQ values for all vports and configure it.  * After this configuration each vport must have  * approx min rate =  vport_wfq * min_pf_rate / ECORE_WFQ_UNIT  */
end_comment

begin_function
specifier|static
name|void
name|ecore_configure_wfq_for_all_vports
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|min_pf_rate
parameter_list|)
block|{
name|struct
name|init_qm_vport_params
modifier|*
name|vport_params
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vport_params
operator|=
name|p_hwfn
operator|->
name|qm_info
operator|.
name|qm_vport_params
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_vports
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|wfq_speed
init|=
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|i
index|]
operator|.
name|min_speed
decl_stmt|;
name|vport_params
index|[
name|i
index|]
operator|.
name|vport_wfq
operator|=
operator|(
name|wfq_speed
operator|*
name|ECORE_WFQ_UNIT
operator|)
operator|/
name|min_pf_rate
expr_stmt|;
name|ecore_init_vport_wfq
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|vport_params
index|[
name|i
index|]
operator|.
name|first_tx_pq_id
argument_list|,
name|vport_params
index|[
name|i
index|]
operator|.
name|vport_wfq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_wfq_default_param
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|min_pf_rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_vports
condition|;
name|i
operator|++
control|)
name|p_hwfn
operator|->
name|qm_info
operator|.
name|qm_vport_params
index|[
name|i
index|]
operator|.
name|vport_wfq
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_disable_wfq_for_all_vports
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|min_pf_rate
parameter_list|)
block|{
name|struct
name|init_qm_vport_params
modifier|*
name|vport_params
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vport_params
operator|=
name|p_hwfn
operator|->
name|qm_info
operator|.
name|qm_vport_params
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_vports
condition|;
name|i
operator|++
control|)
block|{
name|ecore_init_wfq_default_param
argument_list|(
name|p_hwfn
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
name|ecore_init_vport_wfq
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|vport_params
index|[
name|i
index|]
operator|.
name|first_tx_pq_id
argument_list|,
name|vport_params
index|[
name|i
index|]
operator|.
name|vport_wfq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function performs several validations for WFQ  * configuration and required min rate for a given vport  * 1. req_rate must be greater than one percent of min_pf_rate.  * 2. req_rate should not cause other vports [not configured for WFQ explicitly]  *    rates to get less than one percent of min_pf_rate.  * 3. total_req_min_rate [all vports min rate sum] shouldn't exceed min_pf_rate.  */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_init_wfq_param
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|vport_id
parameter_list|,
name|u32
name|req_rate
parameter_list|,
name|u32
name|min_pf_rate
parameter_list|)
block|{
name|u32
name|total_req_min_rate
init|=
literal|0
decl_stmt|,
name|total_left_rate
init|=
literal|0
decl_stmt|,
name|left_rate_per_vp
init|=
literal|0
decl_stmt|;
name|int
name|non_requested_count
init|=
literal|0
decl_stmt|,
name|req_count
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|num_vports
decl_stmt|;
name|num_vports
operator|=
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_vports
expr_stmt|;
comment|/* Accounting for the vports which are configured for WFQ explicitly */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vports
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|tmp_speed
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|!=
name|vport_id
operator|)
operator|&&
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|i
index|]
operator|.
name|configured
condition|)
block|{
name|req_count
operator|++
expr_stmt|;
name|tmp_speed
operator|=
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|i
index|]
operator|.
name|min_speed
expr_stmt|;
name|total_req_min_rate
operator|+=
name|tmp_speed
expr_stmt|;
block|}
block|}
comment|/* Include current vport data as well */
name|req_count
operator|++
expr_stmt|;
name|total_req_min_rate
operator|+=
name|req_rate
expr_stmt|;
name|non_requested_count
operator|=
name|num_vports
operator|-
name|req_count
expr_stmt|;
comment|/* validate possible error cases */
if|if
condition|(
name|req_rate
operator|>
name|min_pf_rate
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Vport [%d] - Requested rate[%d Mbps] is greater than configured PF min rate[%d Mbps]\n"
argument_list|,
name|vport_id
argument_list|,
name|req_rate
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|req_rate
operator|<
name|min_pf_rate
operator|/
name|ECORE_WFQ_UNIT
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Vport [%d] - Requested rate[%d Mbps] is less than one percent of configured PF min rate[%d Mbps]\n"
argument_list|,
name|vport_id
argument_list|,
name|req_rate
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* TBD - for number of vports greater than 100 */
if|if
condition|(
name|num_vports
operator|>
name|ECORE_WFQ_UNIT
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Number of vports is greater than %d\n"
argument_list|,
name|ECORE_WFQ_UNIT
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|total_req_min_rate
operator|>
name|min_pf_rate
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Total requested min rate for all vports[%d Mbps] is greater than configured PF min rate[%d Mbps]\n"
argument_list|,
name|total_req_min_rate
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Data left for non requested vports */
name|total_left_rate
operator|=
name|min_pf_rate
operator|-
name|total_req_min_rate
expr_stmt|;
name|left_rate_per_vp
operator|=
name|total_left_rate
operator|/
name|non_requested_count
expr_stmt|;
comment|/* validate if non requested get< 1% of min bw */
if|if
condition|(
name|left_rate_per_vp
operator|<
name|min_pf_rate
operator|/
name|ECORE_WFQ_UNIT
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Non WFQ configured vports rate [%d Mbps] is less than one percent of configured PF min rate[%d Mbps]\n"
argument_list|,
name|left_rate_per_vp
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* now req_rate for given vport passes all scenarios. 	 * assign final wfq rates to all vports. 	 */
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|vport_id
index|]
operator|.
name|min_speed
operator|=
name|req_rate
expr_stmt|;
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|vport_id
index|]
operator|.
name|configured
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|i
index|]
operator|.
name|min_speed
operator|=
name|left_rate_per_vp
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__ecore_configure_vport_wfq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|vp_id
parameter_list|,
name|u32
name|rate
parameter_list|)
block|{
name|struct
name|ecore_mcp_link_state
modifier|*
name|p_link
decl_stmt|;
name|int
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|p_link
operator|=
operator|&
name|p_hwfn
operator|->
name|p_dev
operator|->
name|hwfns
index|[
literal|0
index|]
operator|.
name|mcp_info
operator|->
name|link_output
expr_stmt|;
if|if
condition|(
operator|!
name|p_link
operator|->
name|min_pf_rate
condition|)
block|{
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|vp_id
index|]
operator|.
name|min_speed
operator|=
name|rate
expr_stmt|;
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|vp_id
index|]
operator|.
name|configured
operator|=
name|true
expr_stmt|;
return|return
name|rc
return|;
block|}
name|rc
operator|=
name|ecore_init_wfq_param
argument_list|(
name|p_hwfn
argument_list|,
name|vp_id
argument_list|,
name|rate
argument_list|,
name|p_link
operator|->
name|min_pf_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
condition|)
name|ecore_configure_wfq_for_all_vports
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_link
operator|->
name|min_pf_rate
argument_list|)
expr_stmt|;
else|else
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Validation failed while configuring min rate\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__ecore_configure_vp_wfq_on_link_change
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|min_pf_rate
parameter_list|)
block|{
name|bool
name|use_wfq
init|=
name|false
decl_stmt|;
name|int
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
comment|/* Validate all pre configured vports for wfq */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_vports
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|rate
decl_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
name|rate
operator|=
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
index|[
name|i
index|]
operator|.
name|min_speed
expr_stmt|;
name|use_wfq
operator|=
name|true
expr_stmt|;
name|rc
operator|=
name|ecore_init_wfq_param
argument_list|(
name|p_hwfn
argument_list|,
name|i
argument_list|,
name|rate
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"WFQ validation failed while configuring min rate\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
operator|&&
name|use_wfq
condition|)
name|ecore_configure_wfq_for_all_vports
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
else|else
name|ecore_disable_wfq_for_all_vports
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Main API for ecore clients to configure vport min rate.  * vp_id - vport id in PF Range[0 - (total_num_vports_per_pf - 1)]  * rate - Speed in Mbps needs to be assigned to a given vport.  */
end_comment

begin_function
name|int
name|ecore_configure_vport_wfq
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u16
name|vp_id
parameter_list|,
name|u32
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
name|ECORE_INVAL
decl_stmt|;
comment|/* TBD - for multiple hardware functions - that is 100 gig */
if|if
condition|(
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"WFQ configuration is not supported for this device\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_TIMEOUT
return|;
name|rc
operator|=
name|__ecore_configure_vport_wfq
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|vp_id
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* API to configure WFQ from mcp link change */
end_comment

begin_function
name|void
name|ecore_configure_vp_wfq_on_link_change
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|min_pf_rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* TBD - for multiple hardware functions - that is 100 gig */
if|if
condition|(
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_dev
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"WFQ configuration is not supported for this device\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|__ecore_configure_vp_wfq_on_link_change
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|min_pf_rate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|__ecore_configure_pf_max_bandwidth
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mcp_link_state
modifier|*
name|p_link
parameter_list|,
name|u8
name|max_bw
parameter_list|)
block|{
name|int
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|bandwidth_max
operator|=
name|max_bw
expr_stmt|;
if|if
condition|(
operator|!
name|p_link
operator|->
name|line_speed
operator|&&
operator|(
name|max_bw
operator|!=
literal|100
operator|)
condition|)
return|return
name|rc
return|;
name|p_link
operator|->
name|speed
operator|=
operator|(
name|p_link
operator|->
name|line_speed
operator|*
name|max_bw
operator|)
operator|/
literal|100
expr_stmt|;
name|p_hwfn
operator|->
name|qm_info
operator|.
name|pf_rl
operator|=
name|p_link
operator|->
name|speed
expr_stmt|;
comment|/* Since the limiter also affects Tx-switched traffic, we don't want it 	 * to limit such traffic in case there's no actual limit. 	 * In that case, set limit to imaginary high boundary. 	 */
if|if
condition|(
name|max_bw
operator|==
literal|100
condition|)
name|p_hwfn
operator|->
name|qm_info
operator|.
name|pf_rl
operator|=
literal|100000
expr_stmt|;
name|rc
operator|=
name|ecore_init_pf_rl
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|,
name|p_hwfn
operator|->
name|qm_info
operator|.
name|pf_rl
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Configured MAX bandwidth to be %08x Mb/sec\n"
argument_list|,
name|p_link
operator|->
name|speed
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Main API to configure PF max bandwidth where bw range is [1 - 100] */
end_comment

begin_function
name|int
name|ecore_configure_pf_max_bandwidth
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u8
name|max_bw
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
name|ECORE_INVAL
decl_stmt|;
if|if
condition|(
name|max_bw
operator|<
literal|1
operator|||
name|max_bw
operator|>
literal|100
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"PF max bw valid range is [1-100]\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ecore_hwfn
modifier|*
name|p_lead
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_link_state
modifier|*
name|p_link
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|p_link
operator|=
operator|&
name|p_lead
operator|->
name|mcp_info
operator|->
name|link_output
expr_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_TIMEOUT
return|;
name|rc
operator|=
name|__ecore_configure_pf_max_bandwidth
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_link
argument_list|,
name|max_bw
argument_list|)
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|__ecore_configure_pf_min_bandwidth
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mcp_link_state
modifier|*
name|p_link
parameter_list|,
name|u8
name|min_bw
parameter_list|)
block|{
name|int
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|bandwidth_min
operator|=
name|min_bw
expr_stmt|;
name|p_hwfn
operator|->
name|qm_info
operator|.
name|pf_wfq
operator|=
name|min_bw
expr_stmt|;
if|if
condition|(
operator|!
name|p_link
operator|->
name|line_speed
condition|)
return|return
name|rc
return|;
name|p_link
operator|->
name|min_pf_rate
operator|=
operator|(
name|p_link
operator|->
name|line_speed
operator|*
name|min_bw
operator|)
operator|/
literal|100
expr_stmt|;
name|rc
operator|=
name|ecore_init_pf_wfq
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|,
name|min_bw
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Configured MIN bandwidth to be %d Mb/sec\n"
argument_list|,
name|p_link
operator|->
name|min_pf_rate
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Main API to configure PF min bandwidth where bw range is [1-100] */
end_comment

begin_function
name|int
name|ecore_configure_pf_min_bandwidth
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u8
name|min_bw
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
name|ECORE_INVAL
decl_stmt|;
if|if
condition|(
name|min_bw
operator|<
literal|1
operator|||
name|min_bw
operator|>
literal|100
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"PF min bw valid range is [1-100]\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ecore_hwfn
modifier|*
name|p_lead
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_link_state
modifier|*
name|p_link
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|p_link
operator|=
operator|&
name|p_lead
operator|->
name|mcp_info
operator|->
name|link_output
expr_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_TIMEOUT
return|;
name|rc
operator|=
name|__ecore_configure_pf_min_bandwidth
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_link
argument_list|,
name|min_bw
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
if|if
condition|(
name|p_link
operator|->
name|min_pf_rate
condition|)
block|{
name|u32
name|min_rate
init|=
name|p_link
operator|->
name|min_pf_rate
decl_stmt|;
name|rc
operator|=
name|__ecore_configure_vp_wfq_on_link_change
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|min_rate
argument_list|)
expr_stmt|;
block|}
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_clean_wfq_db
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mcp_link_state
modifier|*
name|p_link
decl_stmt|;
name|p_link
operator|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_output
expr_stmt|;
if|if
condition|(
name|p_link
operator|->
name|min_pf_rate
condition|)
name|ecore_disable_wfq_for_all_vports
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_link
operator|->
name|min_pf_rate
argument_list|)
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_hwfn
operator|->
name|qm_info
operator|.
name|wfq_data
argument_list|)
operator|*
name|p_hwfn
operator|->
name|qm_info
operator|.
name|num_vports
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ecore_device_num_engines
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
return|return
name|ECORE_IS_BB
argument_list|(
name|p_dev
argument_list|)
condition|?
literal|2
else|:
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ecore_device_num_ports
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
comment|/* in CMT always only one port */
if|if
condition|(
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
return|return
literal|1
return|;
return|return
name|p_dev
operator|->
name|num_ports_in_engines
operator|*
name|ecore_device_num_engines
argument_list|(
name|p_dev
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ecore_set_fw_mac_addr
parameter_list|(
name|__le16
modifier|*
name|fw_msb
parameter_list|,
name|__le16
modifier|*
name|fw_mid
parameter_list|,
name|__le16
modifier|*
name|fw_lsb
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
operator|(
operator|(
name|u8
operator|*
operator|)
name|fw_msb
operator|)
index|[
literal|0
index|]
operator|=
name|mac
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|u8
operator|*
operator|)
name|fw_msb
operator|)
index|[
literal|1
index|]
operator|=
name|mac
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|(
name|u8
operator|*
operator|)
name|fw_mid
operator|)
index|[
literal|0
index|]
operator|=
name|mac
index|[
literal|3
index|]
expr_stmt|;
operator|(
operator|(
name|u8
operator|*
operator|)
name|fw_mid
operator|)
index|[
literal|1
index|]
operator|=
name|mac
index|[
literal|2
index|]
expr_stmt|;
operator|(
operator|(
name|u8
operator|*
operator|)
name|fw_lsb
operator|)
index|[
literal|0
index|]
operator|=
name|mac
index|[
literal|5
index|]
expr_stmt|;
operator|(
operator|(
name|u8
operator|*
operator|)
name|fw_lsb
operator|)
index|[
literal|1
index|]
operator|=
name|mac
index|[
literal|4
index|]
expr_stmt|;
block|}
end_function

end_unit

