begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__ECORE_CHAIN_H__
end_ifndef

begin_define
define|#
directive|define
name|__ECORE_CHAIN_H__
end_define

begin_include
include|#
directive|include
file|"common_hsi.h"
end_include

begin_include
include|#
directive|include
file|"ecore_utils.h"
end_include

begin_enum
enum|enum
name|ecore_chain_mode
block|{
comment|/* Each Page contains a next pointer at its end */
name|ECORE_CHAIN_MODE_NEXT_PTR
block|,
comment|/* Chain is a single page (next ptr) is unrequired */
name|ECORE_CHAIN_MODE_SINGLE
block|,
comment|/* Page pointers are located in a side list */
name|ECORE_CHAIN_MODE_PBL
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ecore_chain_use_mode
block|{
name|ECORE_CHAIN_USE_TO_PRODUCE
block|,
comment|/* Chain starts empty */
name|ECORE_CHAIN_USE_TO_CONSUME
block|,
comment|/* Chain starts full */
name|ECORE_CHAIN_USE_TO_CONSUME_PRODUCE
block|,
comment|/* Chain starts empty */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ecore_chain_cnt_type
block|{
comment|/* The chain's size/prod/cons are kept in 16-bit variables */
name|ECORE_CHAIN_CNT_TYPE_U16
block|,
comment|/* The chain's size/prod/cons are kept in 32-bit variables  */
name|ECORE_CHAIN_CNT_TYPE_U32
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ecore_chain_next
block|{
name|struct
name|regpair
name|next_phys
decl_stmt|;
name|void
modifier|*
name|next_virt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_chain_pbl_u16
block|{
name|u16
name|prod_page_idx
decl_stmt|;
name|u16
name|cons_page_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_chain_pbl_u32
block|{
name|u32
name|prod_page_idx
decl_stmt|;
name|u32
name|cons_page_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_chain_ext_pbl
block|{
name|dma_addr_t
name|p_pbl_phys
decl_stmt|;
name|void
modifier|*
name|p_pbl_virt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_chain_u16
block|{
comment|/* Cyclic index of next element to produce/consme */
name|u16
name|prod_idx
decl_stmt|;
name|u16
name|cons_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_chain_u32
block|{
comment|/* Cyclic index of next element to produce/consme */
name|u32
name|prod_idx
decl_stmt|;
name|u32
name|cons_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_chain
block|{
comment|/* fastpath portion of the chain - required for commands such 	 * as produce / consume. 	 */
comment|/* Point to next element to produce/consume */
name|void
modifier|*
name|p_prod_elem
decl_stmt|;
name|void
modifier|*
name|p_cons_elem
decl_stmt|;
comment|/* Fastpath portions of the PBL [if exists] */
struct|struct
block|{
comment|/* Table for keeping the virtual addresses of the chain pages, 		 * respectively to the physical addresses in the pbl table. 		 */
name|void
modifier|*
modifier|*
name|pp_virt_addr_tbl
decl_stmt|;
union|union
block|{
name|struct
name|ecore_chain_pbl_u16
name|pbl_u16
decl_stmt|;
name|struct
name|ecore_chain_pbl_u32
name|pbl_u32
decl_stmt|;
block|}
name|c
union|;
block|}
name|pbl
struct|;
union|union
block|{
name|struct
name|ecore_chain_u16
name|chain16
decl_stmt|;
name|struct
name|ecore_chain_u32
name|chain32
decl_stmt|;
block|}
name|u
union|;
comment|/* Capacity counts only usable elements */
name|u32
name|capacity
decl_stmt|;
name|u32
name|page_cnt
decl_stmt|;
comment|/* A u8 would suffice for mode, but it would save as a lot of headaches 	 * on castings& defaults. 	 */
name|enum
name|ecore_chain_mode
name|mode
decl_stmt|;
comment|/* Elements information for fast calculations */
name|u16
name|elem_per_page
decl_stmt|;
name|u16
name|elem_per_page_mask
decl_stmt|;
name|u16
name|elem_size
decl_stmt|;
name|u16
name|next_page_mask
decl_stmt|;
name|u16
name|usable_per_page
decl_stmt|;
name|u8
name|elem_unusable
decl_stmt|;
name|u8
name|cnt_type
decl_stmt|;
comment|/* Slowpath of the chain - required for initialization and destruction, 	 * but isn't involved in regular functionality. 	 */
comment|/* Base address of a pre-allocated buffer for pbl */
struct|struct
block|{
name|dma_addr_t
name|p_phys_table
decl_stmt|;
name|void
modifier|*
name|p_virt_table
decl_stmt|;
block|}
name|pbl_sp
struct|;
comment|/* Address of first page of the chain  - the address is required 	 * for fastpath operation [consume/produce] but only for the the SINGLE 	 * flavour which isn't considered fastpath [== SPQ]. 	 */
name|void
modifier|*
name|p_virt_addr
decl_stmt|;
name|dma_addr_t
name|p_phys_addr
decl_stmt|;
comment|/* Total number of elements [for entire chain] */
name|u32
name|size
decl_stmt|;
name|u8
name|intended_use
decl_stmt|;
comment|/* TBD - do we really need this? Couldn't find usage for it */
name|bool
name|b_external_pbl
decl_stmt|;
name|void
modifier|*
name|dp_ctx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ECORE_CHAIN_PBL_ENTRY_SIZE
value|(8)
end_define

begin_define
define|#
directive|define
name|ECORE_CHAIN_PAGE_SIZE
value|(0x1000)
end_define

begin_define
define|#
directive|define
name|ELEMS_PER_PAGE
parameter_list|(
name|elem_size
parameter_list|)
value|(ECORE_CHAIN_PAGE_SIZE/(elem_size))
end_define

begin_define
define|#
directive|define
name|UNUSABLE_ELEMS_PER_PAGE
parameter_list|(
name|elem_size
parameter_list|,
name|mode
parameter_list|)
define|\
value|((mode == ECORE_CHAIN_MODE_NEXT_PTR) ? 		\ 	   (u8)(1 + ((sizeof(struct ecore_chain_next)-1) /	\ 		     (elem_size))) : 0)
end_define

begin_define
define|#
directive|define
name|USABLE_ELEMS_PER_PAGE
parameter_list|(
name|elem_size
parameter_list|,
name|mode
parameter_list|)
define|\
value|((u32) (ELEMS_PER_PAGE(elem_size) - 			\ 	  	  UNUSABLE_ELEMS_PER_PAGE(elem_size, mode)))
end_define

begin_define
define|#
directive|define
name|ECORE_CHAIN_PAGE_CNT
parameter_list|(
name|elem_cnt
parameter_list|,
name|elem_size
parameter_list|,
name|mode
parameter_list|)
define|\
value|DIV_ROUND_UP(elem_cnt, USABLE_ELEMS_PER_PAGE(elem_size, mode))
end_define

begin_define
define|#
directive|define
name|is_chain_u16
parameter_list|(
name|p
parameter_list|)
value|((p)->cnt_type == ECORE_CHAIN_CNT_TYPE_U16)
end_define

begin_define
define|#
directive|define
name|is_chain_u32
parameter_list|(
name|p
parameter_list|)
value|((p)->cnt_type == ECORE_CHAIN_CNT_TYPE_U32)
end_define

begin_comment
comment|/* Accessors */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|u16
name|ecore_chain_get_prod_idx
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|OSAL_ASSERT
argument_list|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u32
name|ecore_chain_get_prod_idx_u32
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|OSAL_ASSERT
argument_list|(
name|is_chain_u32
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u16
name|ecore_chain_get_cons_idx
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|OSAL_ASSERT
argument_list|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u32
name|ecore_chain_get_cons_idx_u32
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|OSAL_ASSERT
argument_list|(
name|is_chain_u32
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
return|;
block|}
end_function

begin_comment
comment|/* FIXME:  * Should create OSALs for the below definitions.  * For Linux, replace them with the existing U16_MAX and U32_MAX, and handle  * kernel versions that lack them.  */
end_comment

begin_define
define|#
directive|define
name|ECORE_U16_MAX
value|((u16)~0U)
end_define

begin_define
define|#
directive|define
name|ECORE_U32_MAX
value|((u32)~0U)
end_define

begin_function
specifier|static
name|OSAL_INLINE
name|u16
name|ecore_chain_get_elem_left
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|u16
name|used
decl_stmt|;
name|OSAL_ASSERT
argument_list|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
operator|(
name|u32
operator|)
name|ECORE_U16_MAX
operator|+
literal|1
operator|+
call|(
name|u32
call|)
argument_list|(
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
argument_list|)
operator|)
operator|-
operator|(
name|u32
operator|)
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_chain
operator|->
name|mode
operator|==
name|ECORE_CHAIN_MODE_NEXT_PTR
condition|)
name|used
operator|-=
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
operator|/
name|p_chain
operator|->
name|elem_per_page
operator|-
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
operator|/
name|p_chain
operator|->
name|elem_per_page
expr_stmt|;
return|return
call|(
name|u16
call|)
argument_list|(
name|p_chain
operator|->
name|capacity
operator|-
name|used
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u32
name|ecore_chain_get_elem_left_u32
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|u32
name|used
decl_stmt|;
name|OSAL_ASSERT
argument_list|(
name|is_chain_u32
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|=
call|(
name|u32
call|)
argument_list|(
operator|(
operator|(
name|u64
operator|)
name|ECORE_U32_MAX
operator|+
literal|1
operator|+
call|(
name|u64
call|)
argument_list|(
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
argument_list|)
operator|)
operator|-
operator|(
name|u64
operator|)
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_chain
operator|->
name|mode
operator|==
name|ECORE_CHAIN_MODE_NEXT_PTR
condition|)
name|used
operator|-=
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
operator|/
name|p_chain
operator|->
name|elem_per_page
operator|-
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
operator|/
name|p_chain
operator|->
name|elem_per_page
expr_stmt|;
return|return
name|p_chain
operator|->
name|capacity
operator|-
name|used
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u8
name|ecore_chain_is_full
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
return|return
operator|(
name|ecore_chain_get_elem_left
argument_list|(
name|p_chain
argument_list|)
operator|==
name|p_chain
operator|->
name|capacity
operator|)
return|;
else|else
return|return
operator|(
name|ecore_chain_get_elem_left_u32
argument_list|(
name|p_chain
argument_list|)
operator|==
name|p_chain
operator|->
name|capacity
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u8
name|ecore_chain_is_empty
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
return|return
operator|(
name|ecore_chain_get_elem_left
argument_list|(
name|p_chain
argument_list|)
operator|==
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|ecore_chain_get_elem_left_u32
argument_list|(
name|p_chain
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u16
name|ecore_chain_get_elem_per_page
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
return|return
name|p_chain
operator|->
name|elem_per_page
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u16
name|ecore_chain_get_usable_per_page
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
return|return
name|p_chain
operator|->
name|usable_per_page
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u8
name|ecore_chain_get_unusable_per_page
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
return|return
name|p_chain
operator|->
name|elem_unusable
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u32
name|ecore_chain_get_size
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
return|return
name|p_chain
operator|->
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|u32
name|ecore_chain_get_page_cnt
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
return|return
name|p_chain
operator|->
name|page_cnt
return|;
block|}
end_function

begin_function
specifier|static
name|OSAL_INLINE
name|dma_addr_t
name|ecore_chain_get_pbl_phys
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
return|return
name|p_chain
operator|->
name|pbl_sp
operator|.
name|p_phys_table
return|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_advance_page -  *  * Advance the next element accros pages for a linked chain  *  * @param p_chain  * @param p_next_elem  * @param idx_to_inc  * @param page_to_inc  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_advance_page
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|void
modifier|*
modifier|*
name|p_next_elem
parameter_list|,
name|void
modifier|*
name|idx_to_inc
parameter_list|,
name|void
modifier|*
name|page_to_inc
parameter_list|)
block|{
name|struct
name|ecore_chain_next
modifier|*
name|p_next
init|=
name|OSAL_NULL
decl_stmt|;
name|u32
name|page_index
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|p_chain
operator|->
name|mode
condition|)
block|{
case|case
name|ECORE_CHAIN_MODE_NEXT_PTR
case|:
name|p_next
operator|=
operator|(
expr|struct
name|ecore_chain_next
operator|*
operator|)
operator|(
operator|*
name|p_next_elem
operator|)
expr_stmt|;
operator|*
name|p_next_elem
operator|=
name|p_next
operator|->
name|next_virt
expr_stmt|;
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
operator|*
operator|(
name|u16
operator|*
operator|)
name|idx_to_inc
operator|+=
operator|(
name|u16
operator|)
name|p_chain
operator|->
name|elem_unusable
expr_stmt|;
else|else
operator|*
operator|(
name|u32
operator|*
operator|)
name|idx_to_inc
operator|+=
operator|(
name|u16
operator|)
name|p_chain
operator|->
name|elem_unusable
expr_stmt|;
break|break;
case|case
name|ECORE_CHAIN_MODE_SINGLE
case|:
operator|*
name|p_next_elem
operator|=
name|p_chain
operator|->
name|p_virt_addr
expr_stmt|;
break|break;
case|case
name|ECORE_CHAIN_MODE_PBL
case|:
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
operator|(
operator|*
operator|(
name|u16
operator|*
operator|)
name|page_to_inc
operator|)
operator|==
name|p_chain
operator|->
name|page_cnt
condition|)
operator|*
operator|(
name|u16
operator|*
operator|)
name|page_to_inc
operator|=
literal|0
expr_stmt|;
name|page_index
operator|=
operator|*
operator|(
name|u16
operator|*
operator|)
name|page_to_inc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|++
operator|(
operator|*
operator|(
name|u32
operator|*
operator|)
name|page_to_inc
operator|)
operator|==
name|p_chain
operator|->
name|page_cnt
condition|)
operator|*
operator|(
name|u32
operator|*
operator|)
name|page_to_inc
operator|=
literal|0
expr_stmt|;
name|page_index
operator|=
operator|*
operator|(
name|u32
operator|*
operator|)
name|page_to_inc
expr_stmt|;
block|}
operator|*
name|p_next_elem
operator|=
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
index|[
name|page_index
index|]
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|is_unusable_idx
parameter_list|(
name|p
parameter_list|,
name|idx
parameter_list|)
define|\
value|(((p)->u.chain16.idx& (p)->elem_per_page_mask) == (p)->usable_per_page)
end_define

begin_define
define|#
directive|define
name|is_unusable_idx_u32
parameter_list|(
name|p
parameter_list|,
name|idx
parameter_list|)
define|\
value|(((p)->u.chain32.idx& (p)->elem_per_page_mask) == (p)->usable_per_page)
end_define

begin_define
define|#
directive|define
name|is_unusable_next_idx
parameter_list|(
name|p
parameter_list|,
name|idx
parameter_list|)
define|\
value|((((p)->u.chain16.idx + 1)& (p)->elem_per_page_mask) == (p)->usable_per_page)
end_define

begin_define
define|#
directive|define
name|is_unusable_next_idx_u32
parameter_list|(
name|p
parameter_list|,
name|idx
parameter_list|)
define|\
value|((((p)->u.chain32.idx + 1)& (p)->elem_per_page_mask) == (p)->usable_per_page)
end_define

begin_define
define|#
directive|define
name|test_and_skip
parameter_list|(
name|p
parameter_list|,
name|idx
parameter_list|)
define|\
value|do {									\ 		if (is_chain_u16(p)) {						\ 			if (is_unusable_idx(p, idx))				\ 				(p)->u.chain16.idx += (p)->elem_unusable;	\ 		} else {							\ 			if (is_unusable_idx_u32(p, idx))			\ 				(p)->u.chain32.idx += (p)->elem_unusable;	\ 		}								\ 	} while (0)
end_define

begin_comment
comment|/**  * @brief ecore_chain_return_multi_produced -  *  * A chain in which the driver "Produces" elements should use this API  * to indicate previous produced elements are now consumed.  *  * @param p_chain  * @param num  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_return_multi_produced
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|u32
name|num
parameter_list|)
block|{
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
operator|+=
operator|(
name|u16
operator|)
name|num
expr_stmt|;
else|else
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
operator|+=
name|num
expr_stmt|;
name|test_and_skip
argument_list|(
name|p_chain
argument_list|,
name|cons_idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_return_produced -  *  * A chain in which the driver "Produces" elements should use this API  * to indicate previous produced elements are now consumed.  *  * @param p_chain  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_return_produced
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
operator|++
expr_stmt|;
else|else
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
operator|++
expr_stmt|;
name|test_and_skip
argument_list|(
name|p_chain
argument_list|,
name|cons_idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_produce -  *  * A chain in which the driver "Produces" elements should use this to get  * a pointer to the next element which can be "Produced". It's driver  * responsibility to validate that the chain has room for new element.  *  * @param p_chain  *  * @return void*, a pointer to next element  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
modifier|*
name|ecore_chain_produce
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|void
modifier|*
name|p_ret
init|=
name|OSAL_NULL
decl_stmt|,
modifier|*
name|p_prod_idx
decl_stmt|,
modifier|*
name|p_prod_page_idx
decl_stmt|;
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
operator|&
name|p_chain
operator|->
name|elem_per_page_mask
operator|)
operator|==
name|p_chain
operator|->
name|next_page_mask
condition|)
block|{
name|p_prod_idx
operator|=
operator|&
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
expr_stmt|;
name|p_prod_page_idx
operator|=
operator|&
name|p_chain
operator|->
name|pbl
operator|.
name|c
operator|.
name|pbl_u16
operator|.
name|prod_page_idx
expr_stmt|;
name|ecore_chain_advance_page
argument_list|(
name|p_chain
argument_list|,
operator|&
name|p_chain
operator|->
name|p_prod_elem
argument_list|,
name|p_prod_idx
argument_list|,
name|p_prod_page_idx
argument_list|)
expr_stmt|;
block|}
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
operator|&
name|p_chain
operator|->
name|elem_per_page_mask
operator|)
operator|==
name|p_chain
operator|->
name|next_page_mask
condition|)
block|{
name|p_prod_idx
operator|=
operator|&
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
expr_stmt|;
name|p_prod_page_idx
operator|=
operator|&
name|p_chain
operator|->
name|pbl
operator|.
name|c
operator|.
name|pbl_u32
operator|.
name|prod_page_idx
expr_stmt|;
name|ecore_chain_advance_page
argument_list|(
name|p_chain
argument_list|,
operator|&
name|p_chain
operator|->
name|p_prod_elem
argument_list|,
name|p_prod_idx
argument_list|,
name|p_prod_page_idx
argument_list|)
expr_stmt|;
block|}
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
operator|++
expr_stmt|;
block|}
name|p_ret
operator|=
name|p_chain
operator|->
name|p_prod_elem
expr_stmt|;
name|p_chain
operator|->
name|p_prod_elem
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|u8
operator|*
operator|)
name|p_chain
operator|->
name|p_prod_elem
operator|)
operator|+
name|p_chain
operator|->
name|elem_size
operator|)
expr_stmt|;
return|return
name|p_ret
return|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_get_capacity -  *  * Get the maximum number of BDs in chain  *  * @param p_chain  * @param num  *  * @return number of unusable BDs  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|u32
name|ecore_chain_get_capacity
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
return|return
name|p_chain
operator|->
name|capacity
return|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_recycle_consumed -  *  * Returns an element which was previously consumed;  * Increments producers so they could be written to FW.  *  * @param p_chain  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_recycle_consumed
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|test_and_skip
argument_list|(
name|p_chain
argument_list|,
name|prod_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
operator|++
expr_stmt|;
else|else
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_consume -  *  * A Chain in which the driver utilizes data written by a different source  * (i.e., FW) should use this to access passed buffers.  *  * @param p_chain  *  * @return void*, a pointer to the next buffer written  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
modifier|*
name|ecore_chain_consume
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|void
modifier|*
name|p_ret
init|=
name|OSAL_NULL
decl_stmt|,
modifier|*
name|p_cons_idx
decl_stmt|,
modifier|*
name|p_cons_page_idx
decl_stmt|;
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
operator|&
name|p_chain
operator|->
name|elem_per_page_mask
operator|)
operator|==
name|p_chain
operator|->
name|next_page_mask
condition|)
block|{
name|p_cons_idx
operator|=
operator|&
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
expr_stmt|;
name|p_cons_page_idx
operator|=
operator|&
name|p_chain
operator|->
name|pbl
operator|.
name|c
operator|.
name|pbl_u16
operator|.
name|cons_page_idx
expr_stmt|;
name|ecore_chain_advance_page
argument_list|(
name|p_chain
argument_list|,
operator|&
name|p_chain
operator|->
name|p_cons_elem
argument_list|,
name|p_cons_idx
argument_list|,
name|p_cons_page_idx
argument_list|)
expr_stmt|;
block|}
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
operator|&
name|p_chain
operator|->
name|elem_per_page_mask
operator|)
operator|==
name|p_chain
operator|->
name|next_page_mask
condition|)
block|{
name|p_cons_idx
operator|=
operator|&
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
expr_stmt|;
name|p_cons_page_idx
operator|=
operator|&
name|p_chain
operator|->
name|pbl
operator|.
name|c
operator|.
name|pbl_u32
operator|.
name|cons_page_idx
expr_stmt|;
name|ecore_chain_advance_page
argument_list|(
name|p_chain
argument_list|,
operator|&
name|p_chain
operator|->
name|p_cons_elem
argument_list|,
name|p_cons_idx
argument_list|,
name|p_cons_page_idx
argument_list|)
expr_stmt|;
block|}
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
operator|++
expr_stmt|;
block|}
name|p_ret
operator|=
name|p_chain
operator|->
name|p_cons_elem
expr_stmt|;
name|p_chain
operator|->
name|p_cons_elem
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|u8
operator|*
operator|)
name|p_chain
operator|->
name|p_cons_elem
operator|)
operator|+
name|p_chain
operator|->
name|elem_size
operator|)
expr_stmt|;
return|return
name|p_ret
return|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_reset -  *  * Resets the chain to its start state  *  * @param p_chain pointer to a previously allocted chain  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_reset
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
block|{
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
operator|=
literal|0
expr_stmt|;
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|cons_idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
operator|=
literal|0
expr_stmt|;
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|cons_idx
operator|=
literal|0
expr_stmt|;
block|}
name|p_chain
operator|->
name|p_cons_elem
operator|=
name|p_chain
operator|->
name|p_virt_addr
expr_stmt|;
name|p_chain
operator|->
name|p_prod_elem
operator|=
name|p_chain
operator|->
name|p_virt_addr
expr_stmt|;
if|if
condition|(
name|p_chain
operator|->
name|mode
operator|==
name|ECORE_CHAIN_MODE_PBL
condition|)
block|{
comment|/* Use (page_cnt - 1) as a reset value for the prod/cons page's 		 * indices, to avoid unnecessary page advancing on the first 		 * call to ecore_chain_produce/consume. Instead, the indices 		 * will be advanced to page_cnt and then will be wrapped to 0. 		 */
name|u32
name|reset_val
init|=
name|p_chain
operator|->
name|page_cnt
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
block|{
name|p_chain
operator|->
name|pbl
operator|.
name|c
operator|.
name|pbl_u16
operator|.
name|prod_page_idx
operator|=
operator|(
name|u16
operator|)
name|reset_val
expr_stmt|;
name|p_chain
operator|->
name|pbl
operator|.
name|c
operator|.
name|pbl_u16
operator|.
name|cons_page_idx
operator|=
operator|(
name|u16
operator|)
name|reset_val
expr_stmt|;
block|}
else|else
block|{
name|p_chain
operator|->
name|pbl
operator|.
name|c
operator|.
name|pbl_u32
operator|.
name|prod_page_idx
operator|=
name|reset_val
expr_stmt|;
name|p_chain
operator|->
name|pbl
operator|.
name|c
operator|.
name|pbl_u32
operator|.
name|cons_page_idx
operator|=
name|reset_val
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|p_chain
operator|->
name|intended_use
condition|)
block|{
case|case
name|ECORE_CHAIN_USE_TO_CONSUME
case|:
comment|/* produce empty elements */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_chain
operator|->
name|capacity
condition|;
name|i
operator|++
control|)
name|ecore_chain_recycle_consumed
argument_list|(
name|p_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_CHAIN_USE_TO_CONSUME_PRODUCE
case|:
case|case
name|ECORE_CHAIN_USE_TO_PRODUCE
case|:
default|default:
comment|/* Do nothing */
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_init_params -  *  * Initalizes a basic chain struct  *  * @param p_chain  * @param page_cnt	number of pages in the allocated buffer  * @param elem_size	size of each element in the chain  * @param intended_use  * @param mode  * @param cnt_type  * @param dp_ctx  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_init_params
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|u32
name|page_cnt
parameter_list|,
name|u8
name|elem_size
parameter_list|,
name|enum
name|ecore_chain_use_mode
name|intended_use
parameter_list|,
name|enum
name|ecore_chain_mode
name|mode
parameter_list|,
name|enum
name|ecore_chain_cnt_type
name|cnt_type
parameter_list|,
name|void
modifier|*
name|dp_ctx
parameter_list|)
block|{
comment|/* chain fixed parameters */
name|p_chain
operator|->
name|p_virt_addr
operator|=
name|OSAL_NULL
expr_stmt|;
name|p_chain
operator|->
name|p_phys_addr
operator|=
literal|0
expr_stmt|;
name|p_chain
operator|->
name|elem_size
operator|=
name|elem_size
expr_stmt|;
name|p_chain
operator|->
name|intended_use
operator|=
operator|(
name|u8
operator|)
name|intended_use
expr_stmt|;
name|p_chain
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|p_chain
operator|->
name|cnt_type
operator|=
operator|(
name|u8
operator|)
name|cnt_type
expr_stmt|;
name|p_chain
operator|->
name|elem_per_page
operator|=
name|ELEMS_PER_PAGE
argument_list|(
name|elem_size
argument_list|)
expr_stmt|;
name|p_chain
operator|->
name|usable_per_page
operator|=
name|USABLE_ELEMS_PER_PAGE
argument_list|(
name|elem_size
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|p_chain
operator|->
name|elem_per_page_mask
operator|=
name|p_chain
operator|->
name|elem_per_page
operator|-
literal|1
expr_stmt|;
name|p_chain
operator|->
name|elem_unusable
operator|=
name|UNUSABLE_ELEMS_PER_PAGE
argument_list|(
name|elem_size
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|p_chain
operator|->
name|next_page_mask
operator|=
operator|(
name|p_chain
operator|->
name|usable_per_page
operator|&
name|p_chain
operator|->
name|elem_per_page_mask
operator|)
expr_stmt|;
name|p_chain
operator|->
name|page_cnt
operator|=
name|page_cnt
expr_stmt|;
name|p_chain
operator|->
name|capacity
operator|=
name|p_chain
operator|->
name|usable_per_page
operator|*
name|page_cnt
expr_stmt|;
name|p_chain
operator|->
name|size
operator|=
name|p_chain
operator|->
name|elem_per_page
operator|*
name|page_cnt
expr_stmt|;
name|p_chain
operator|->
name|b_external_pbl
operator|=
name|false
expr_stmt|;
name|p_chain
operator|->
name|pbl_sp
operator|.
name|p_phys_table
operator|=
literal|0
expr_stmt|;
name|p_chain
operator|->
name|pbl_sp
operator|.
name|p_virt_table
operator|=
name|OSAL_NULL
expr_stmt|;
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
operator|=
name|OSAL_NULL
expr_stmt|;
name|p_chain
operator|->
name|dp_ctx
operator|=
name|dp_ctx
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_init_mem -  *  * Initalizes a basic chain struct with its chain buffers  *  * @param p_chain  * @param p_virt_addr	virtual address of allocated buffer's beginning  * @param p_phys_addr	physical address of allocated buffer's beginning  *  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_init_mem
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|void
modifier|*
name|p_virt_addr
parameter_list|,
name|dma_addr_t
name|p_phys_addr
parameter_list|)
block|{
name|p_chain
operator|->
name|p_virt_addr
operator|=
name|p_virt_addr
expr_stmt|;
name|p_chain
operator|->
name|p_phys_addr
operator|=
name|p_phys_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_init_pbl_mem -  *  * Initalizes a basic chain struct with its pbl buffers  *  * @param p_chain  * @param p_virt_pbl	pointer to a pre allocated side table which will hold  *                      virtual page addresses.  * @param p_phys_pbl	pointer to a pre-allocated side table which will hold  *                      physical page addresses.  * @param pp_virt_addr_tbl  *                      pointer to a pre-allocated side table which will hold  *                      the virtual addresses of the chain pages.  *  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_init_pbl_mem
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|void
modifier|*
name|p_virt_pbl
parameter_list|,
name|dma_addr_t
name|p_phys_pbl
parameter_list|,
name|void
modifier|*
modifier|*
name|pp_virt_addr_tbl
parameter_list|)
block|{
name|p_chain
operator|->
name|pbl_sp
operator|.
name|p_phys_table
operator|=
name|p_phys_pbl
expr_stmt|;
name|p_chain
operator|->
name|pbl_sp
operator|.
name|p_virt_table
operator|=
name|p_virt_pbl
expr_stmt|;
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
operator|=
name|pp_virt_addr_tbl
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_init_next_ptr_elem -  *  * Initalizes a next pointer element  *  * @param p_chain  * @param p_virt_curr	virtual address of a chain page of which the next  *                      pointer element is initialized  * @param p_virt_next	virtual address of the next chain page  * @param p_phys_next	physical address of the next chain page  *  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_init_next_ptr_elem
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|void
modifier|*
name|p_virt_curr
parameter_list|,
name|void
modifier|*
name|p_virt_next
parameter_list|,
name|dma_addr_t
name|p_phys_next
parameter_list|)
block|{
name|struct
name|ecore_chain_next
modifier|*
name|p_next
decl_stmt|;
name|u32
name|size
decl_stmt|;
name|size
operator|=
name|p_chain
operator|->
name|elem_size
operator|*
name|p_chain
operator|->
name|usable_per_page
expr_stmt|;
name|p_next
operator|=
operator|(
expr|struct
name|ecore_chain_next
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|p_virt_curr
operator|+
name|size
operator|)
expr_stmt|;
name|DMA_REGPAIR_LE
argument_list|(
name|p_next
operator|->
name|next_phys
argument_list|,
name|p_phys_next
argument_list|)
expr_stmt|;
name|p_next
operator|->
name|next_virt
operator|=
name|p_virt_next
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_get_last_elem -  *  * Returns a pointer to the last element of the chain  *  * @param p_chain  *  * @return void*  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
modifier|*
name|ecore_chain_get_last_elem
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|struct
name|ecore_chain_next
modifier|*
name|p_next
init|=
name|OSAL_NULL
decl_stmt|;
name|void
modifier|*
name|p_virt_addr
init|=
name|OSAL_NULL
decl_stmt|;
name|u32
name|size
decl_stmt|,
name|last_page_idx
decl_stmt|;
if|if
condition|(
operator|!
name|p_chain
operator|->
name|p_virt_addr
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|p_chain
operator|->
name|mode
condition|)
block|{
case|case
name|ECORE_CHAIN_MODE_NEXT_PTR
case|:
name|size
operator|=
name|p_chain
operator|->
name|elem_size
operator|*
name|p_chain
operator|->
name|usable_per_page
expr_stmt|;
name|p_virt_addr
operator|=
name|p_chain
operator|->
name|p_virt_addr
expr_stmt|;
name|p_next
operator|=
operator|(
expr|struct
name|ecore_chain_next
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|p_virt_addr
operator|+
name|size
operator|)
expr_stmt|;
while|while
condition|(
name|p_next
operator|->
name|next_virt
operator|!=
name|p_chain
operator|->
name|p_virt_addr
condition|)
block|{
name|p_virt_addr
operator|=
name|p_next
operator|->
name|next_virt
expr_stmt|;
name|p_next
operator|=
operator|(
expr|struct
name|ecore_chain_next
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|p_virt_addr
operator|+
name|size
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_CHAIN_MODE_SINGLE
case|:
name|p_virt_addr
operator|=
name|p_chain
operator|->
name|p_virt_addr
expr_stmt|;
break|break;
case|case
name|ECORE_CHAIN_MODE_PBL
case|:
name|last_page_idx
operator|=
name|p_chain
operator|->
name|page_cnt
operator|-
literal|1
expr_stmt|;
name|p_virt_addr
operator|=
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
index|[
name|last_page_idx
index|]
expr_stmt|;
break|break;
block|}
comment|/* p_virt_addr points at this stage to the last page of the chain */
name|size
operator|=
name|p_chain
operator|->
name|elem_size
operator|*
operator|(
name|p_chain
operator|->
name|usable_per_page
operator|-
literal|1
operator|)
expr_stmt|;
name|p_virt_addr
operator|=
operator|(
name|u8
operator|*
operator|)
name|p_virt_addr
operator|+
name|size
expr_stmt|;
name|out
label|:
return|return
name|p_virt_addr
return|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_set_prod - sets the prod to the given value  *  * @param prod_idx  * @param p_prod_elem  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_set_prod
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|u32
name|prod_idx
parameter_list|,
name|void
modifier|*
name|p_prod_elem
parameter_list|)
block|{
if|if
condition|(
name|is_chain_u16
argument_list|(
name|p_chain
argument_list|)
condition|)
name|p_chain
operator|->
name|u
operator|.
name|chain16
operator|.
name|prod_idx
operator|=
operator|(
name|u16
operator|)
name|prod_idx
expr_stmt|;
else|else
name|p_chain
operator|->
name|u
operator|.
name|chain32
operator|.
name|prod_idx
operator|=
name|prod_idx
expr_stmt|;
name|p_chain
operator|->
name|p_prod_elem
operator|=
name|p_prod_elem
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_chain_pbl_zero_mem - set chain memory to 0  *  * @param p_chain  */
end_comment

begin_function
specifier|static
name|OSAL_INLINE
name|void
name|ecore_chain_pbl_zero_mem
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|page_cnt
decl_stmt|;
if|if
condition|(
name|p_chain
operator|->
name|mode
operator|!=
name|ECORE_CHAIN_MODE_PBL
condition|)
return|return;
name|page_cnt
operator|=
name|ecore_chain_get_page_cnt
argument_list|(
name|p_chain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_cnt
condition|;
name|i
operator|++
control|)
name|OSAL_MEM_ZERO
argument_list|(
name|p_chain
operator|->
name|pbl
operator|.
name|pp_virt_addr_tbl
index|[
name|i
index|]
argument_list|,
name|ECORE_CHAIN_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
name|ecore_chain_print
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|u32
name|buffer_size
parameter_list|,
name|u32
modifier|*
name|element_indx
parameter_list|,
name|u32
name|stop_indx
parameter_list|,
name|bool
name|print_metadata
parameter_list|,
name|int
function_decl|(
modifier|*
name|func_ptr_print_element
function_decl|)
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|void
modifier|*
name|p_element
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|func_ptr_print_metadata
function_decl|)
parameter_list|(
name|struct
name|ecore_chain
modifier|*
name|p_chain
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __ECORE_CHAIN_H__ */
end_comment

end_unit

