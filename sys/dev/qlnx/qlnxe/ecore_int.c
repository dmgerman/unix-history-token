begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * File : ecore_int.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bcm_osal.h"
end_include

begin_include
include|#
directive|include
file|"ecore.h"
end_include

begin_include
include|#
directive|include
file|"ecore_spq.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_gtt_reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_ops.h"
end_include

begin_include
include|#
directive|include
file|"ecore_rt_defs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_int.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw.h"
end_include

begin_include
include|#
directive|include
file|"ecore_sriov.h"
end_include

begin_include
include|#
directive|include
file|"ecore_vf.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw_defs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_common.h"
end_include

begin_include
include|#
directive|include
file|"ecore_mcp.h"
end_include

begin_include
include|#
directive|include
file|"ecore_dbg_fw_funcs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DIAG
end_ifdef

begin_comment
comment|/* This is nasty, but diag is using the drv_dbg_fw_funcs.c [non-ecore flavor],  * and so the functions are lacking ecore prefix.  * If there would be other clients needing this [or if the content that isn't  * really optional there would increase], we'll need to re-think this.  */
end_comment

begin_function_decl
name|enum
name|dbg_status
name|dbg_read_attn
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|dev
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|ptt
parameter_list|,
name|enum
name|block_id
name|block
parameter_list|,
name|enum
name|dbg_attn_type
name|attn_type
parameter_list|,
name|bool
name|clear_status
parameter_list|,
name|struct
name|dbg_attn_block_result
modifier|*
name|results
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|dbg_status
name|dbg_parse_attn
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|dev
parameter_list|,
name|struct
name|dbg_attn_block_result
modifier|*
name|results
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|dbg_get_status_str
parameter_list|(
name|enum
name|dbg_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ecore_dbg_read_attn
parameter_list|(
name|hwfn
parameter_list|,
name|ptt
parameter_list|,
name|id
parameter_list|,
name|type
parameter_list|,
name|clear
parameter_list|,
name|results
parameter_list|)
define|\
value|dbg_read_attn(hwfn, ptt, id, type, clear, results)
end_define

begin_define
define|#
directive|define
name|ecore_dbg_parse_attn
parameter_list|(
name|hwfn
parameter_list|,
name|results
parameter_list|)
define|\
value|dbg_parse_attn(hwfn, results)
end_define

begin_define
define|#
directive|define
name|ecore_dbg_get_status_str
parameter_list|(
name|status
parameter_list|)
define|\
value|dbg_get_status_str(status)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|ecore_pi_info
block|{
name|ecore_int_comp_cb_t
name|comp_cb
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
comment|/* Will be sent to the completion callback function */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_sb_sp_info
block|{
name|struct
name|ecore_sb_info
name|sb_info
decl_stmt|;
comment|/* per protocol index data */
name|struct
name|ecore_pi_info
name|pi_info_arr
index|[
name|PIS_PER_SB_E4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ecore_attention_type
block|{
name|ECORE_ATTN_TYPE_ATTN
block|,
name|ECORE_ATTN_TYPE_PARITY
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|SB_ATTN_ALIGNED_SIZE
parameter_list|(
name|p_hwfn
parameter_list|)
define|\
value|ALIGNED_TYPE_SIZE(struct atten_status_block, p_hwfn)
end_define

begin_struct
struct|struct
name|aeu_invert_reg_bit
block|{
name|char
name|bit_name
index|[
literal|30
index|]
decl_stmt|;
define|#
directive|define
name|ATTENTION_PARITY
value|(1<< 0)
define|#
directive|define
name|ATTENTION_LENGTH_MASK
value|(0x00000ff0)
define|#
directive|define
name|ATTENTION_LENGTH_SHIFT
value|(4)
define|#
directive|define
name|ATTENTION_LENGTH
parameter_list|(
name|flags
parameter_list|)
value|(((flags)& ATTENTION_LENGTH_MASK)>> \ 					 ATTENTION_LENGTH_SHIFT)
define|#
directive|define
name|ATTENTION_SINGLE
value|(1<< ATTENTION_LENGTH_SHIFT)
define|#
directive|define
name|ATTENTION_PAR
value|(ATTENTION_SINGLE | ATTENTION_PARITY)
define|#
directive|define
name|ATTENTION_PAR_INT
value|((2<< ATTENTION_LENGTH_SHIFT) | \ 					 ATTENTION_PARITY)
comment|/* Multiple bits start with this offset */
define|#
directive|define
name|ATTENTION_OFFSET_MASK
value|(0x000ff000)
define|#
directive|define
name|ATTENTION_OFFSET_SHIFT
value|(12)
define|#
directive|define
name|ATTENTION_BB_MASK
value|(0x00700000)
define|#
directive|define
name|ATTENTION_BB_SHIFT
value|(20)
define|#
directive|define
name|ATTENTION_BB
parameter_list|(
name|value
parameter_list|)
value|(value<< ATTENTION_BB_SHIFT)
define|#
directive|define
name|ATTENTION_BB_DIFFERENT
value|(1<< 23)
define|#
directive|define
name|ATTENTION_CLEAR_ENABLE
value|(1<< 28)
name|unsigned
name|int
name|flags
decl_stmt|;
comment|/* Callback to call if attention will be triggered */
name|enum
name|_ecore_status_t
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
function_decl|;
name|enum
name|block_id
name|block_index
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|aeu_invert_reg
block|{
name|struct
name|aeu_invert_reg_bit
name|bits
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_ATTN_GRPS
value|(8)
end_define

begin_define
define|#
directive|define
name|NUM_ATTN_REGS
value|(9)
end_define

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_attn_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|tmp
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|MCP_REG_CPU_STATE
argument_list|)
decl_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"MCP_REG_CPU_STATE: %08x - Masking...\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|MCP_REG_CPU_EVENT_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_PF_MASK
value|(0x3c000)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_PF_SHIFT
value|(14)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_VF_MASK
value|(0x03fc0)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_VF_SHIFT
value|(6)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_VALID_MASK
value|(0x00020)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_VALID_SHIFT
value|(5)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_CLIENT_MASK
value|(0x0001e)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_CLIENT_SHIFT
value|(1)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_DISABLED_WRITE_MASK
value|(0x1)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTNETION_DISABLED_WRITE_SHIFT
value|(0)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_VF_DISABLED
value|(0x1)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS
value|(0x1)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_WR_MASK
value|(0x1)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_WR_SHIFT
value|(0)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_CLIENT_MASK
value|(0x1e)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_CLIENT_SHIFT
value|(1)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_VF_VALID_MASK
value|(0x20)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_VF_VALID_SHIFT
value|(5)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_VF_ID_MASK
value|(0x3fc0)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_VF_ID_SHIFT
value|(6)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_PF_ID_MASK
value|(0x3c000)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_PF_ID_SHIFT
value|(14)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_BYTE_EN_MASK
value|(0x3fc0000)
end_define

begin_define
define|#
directive|define
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_BYTE_EN_SHIFT
value|(18)
end_define

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_pswhst_attn_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|tmp
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PSWHST_REG_VF_DISABLED_ERROR_VALID
argument_list|)
decl_stmt|;
comment|/* Disabled VF access */
if|if
condition|(
name|tmp
operator|&
name|ECORE_PSWHST_ATTENTION_VF_DISABLED
condition|)
block|{
name|u32
name|addr
decl_stmt|,
name|data
decl_stmt|;
name|addr
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PSWHST_REG_VF_DISABLED_ERROR_ADDRESS
argument_list|)
expr_stmt|;
name|data
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PSWHST_REG_VF_DISABLED_ERROR_DATA
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"PF[0x%02x] VF [0x%02x] [Valid 0x%02x] Client [0x%02x] Write [0x%02x] Addr [0x%08x]\n"
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_DISABLED_PF_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_DISABLED_PF_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_DISABLED_VF_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_DISABLED_VF_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_DISABLED_VALID_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_DISABLED_VALID_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_DISABLED_CLIENT_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_DISABLED_CLIENT_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_DISABLED_WRITE_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTNETION_DISABLED_WRITE_SHIFT
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PSWHST_REG_INCORRECT_ACCESS_VALID
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS
condition|)
block|{
name|u32
name|addr
decl_stmt|,
name|data
decl_stmt|,
name|length
decl_stmt|;
name|addr
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PSWHST_REG_INCORRECT_ACCESS_ADDRESS
argument_list|)
expr_stmt|;
name|data
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PSWHST_REG_INCORRECT_ACCESS_DATA
argument_list|)
expr_stmt|;
name|length
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PSWHST_REG_INCORRECT_ACCESS_LENGTH
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Incorrect access to %08x of length %08x - PF [%02x] VF [%04x] [valid %02x] client [%02x] write [%02x] Byte-Enable [%04x] [%08x]\n"
argument_list|,
name|addr
argument_list|,
name|length
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_PF_ID_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_PF_ID_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_VF_ID_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_VF_ID_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_VF_VALID_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_VF_VALID_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_CLIENT_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_CLIENT_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_WR_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_WR_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|data
operator|&
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_BYTE_EN_MASK
operator|)
operator|>>
name|ECORE_PSWHST_ATTENTION_INCORRECT_ACCESS_BYTE_EN_SHIFT
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* TODO - We know 'some' of these are legal due to virtualization, 	 * but is it true for all of them? 	 */
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_VALID_BIT
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_ADDRESS_MASK
value|(0x7fffff<< 0)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_RDWR_BIT
value|(1<< 23)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_MASTER_MASK
value|(0xf<< 24)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_MASTER_SHIFT
value|(24)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_PF_MASK
value|(0xf)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_VF_MASK
value|(0xff<< 4)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_VF_SHIFT
value|(4)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_PRIV_MASK
value|(0x3<< 14)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_PRIV_SHIFT
value|(14)
end_define

begin_define
define|#
directive|define
name|ECORE_GRC_ATTENTION_PRIV_VF
value|(0)
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|grc_timeout_attn_master_to_str
parameter_list|(
name|u8
name|master
parameter_list|)
block|{
switch|switch
condition|(
name|master
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"PXP"
return|;
case|case
literal|2
case|:
return|return
literal|"MCP"
return|;
case|case
literal|3
case|:
return|return
literal|"MSDM"
return|;
case|case
literal|4
case|:
return|return
literal|"PSDM"
return|;
case|case
literal|5
case|:
return|return
literal|"YSDM"
return|;
case|case
literal|6
case|:
return|return
literal|"USDM"
return|;
case|case
literal|7
case|:
return|return
literal|"TSDM"
return|;
case|case
literal|8
case|:
return|return
literal|"XSDM"
return|;
case|case
literal|9
case|:
return|return
literal|"DBU"
return|;
case|case
literal|10
case|:
return|return
literal|"DMAE"
return|;
default|default:
return|return
literal|"Unkown"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_grc_attn_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* We've already cleared the timeout interrupt register, so we learn 	 * of interrupts via the validity register 	 */
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|GRC_REG_TIMEOUT_ATTN_ACCESS_VALID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|ECORE_GRC_ATTENTION_VALID_BIT
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Read the GRC timeout information */
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|GRC_REG_TIMEOUT_ATTN_ACCESS_DATA_0
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|GRC_REG_TIMEOUT_ATTN_ACCESS_DATA_1
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"GRC timeout [%08x:%08x] - %s Address [%08x] [Master %s] [PF: %02x %s %02x]\n"
argument_list|,
name|tmp2
argument_list|,
name|tmp
argument_list|,
operator|(
name|tmp
operator|&
name|ECORE_GRC_ATTENTION_RDWR_BIT
operator|)
condition|?
literal|"Write to"
else|:
literal|"Read from"
argument_list|,
operator|(
name|tmp
operator|&
name|ECORE_GRC_ATTENTION_ADDRESS_MASK
operator|)
operator|<<
literal|2
argument_list|,
name|grc_timeout_attn_master_to_str
argument_list|(
operator|(
name|tmp
operator|&
name|ECORE_GRC_ATTENTION_MASTER_MASK
operator|)
operator|>>
name|ECORE_GRC_ATTENTION_MASTER_SHIFT
argument_list|)
argument_list|,
operator|(
name|tmp2
operator|&
name|ECORE_GRC_ATTENTION_PF_MASK
operator|)
argument_list|,
operator|(
operator|(
operator|(
name|tmp2
operator|&
name|ECORE_GRC_ATTENTION_PRIV_MASK
operator|)
operator|>>
name|ECORE_GRC_ATTENTION_PRIV_SHIFT
operator|)
operator|==
name|ECORE_GRC_ATTENTION_PRIV_VF
operator|)
condition|?
literal|"VF"
else|:
literal|"(Irrelevant:)"
argument_list|,
operator|(
name|tmp2
operator|&
name|ECORE_GRC_ATTENTION_VF_MASK
operator|)
operator|>>
name|ECORE_GRC_ATTENTION_VF_SHIFT
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* Regardles of anything else, clean the validity bit */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|GRC_REG_TIMEOUT_ATTN_ACCESS_VALID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_VALID
value|(1<< 29)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_RD_VALID
value|(1<< 26)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_DETAILS_PFID_MASK
value|(0xf<< 20)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_DETAILS_PFID_SHIFT
value|(20)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_DETAILS_VF_VALID
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_DETAILS_VFID_MASK
value|(0xff<< 24)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_DETAILS_VFID_SHIFT
value|(24)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_DETAILS2_WAS_ERR
value|(1<< 21)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_DETAILS2_BME
value|(1<< 22)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_DETAILS2_FID_EN
value|(1<< 23)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_ICPL_VALID
value|(1<< 23)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_ZLR_VALID
value|(1<< 25)
end_define

begin_define
define|#
directive|define
name|ECORE_PGLUE_ATTENTION_ILT_VALID
value|(1<< 23)
end_define

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_pglub_rbc_attn_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_WR_DETAILS2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_VALID
condition|)
block|{
name|u32
name|addr_lo
decl_stmt|,
name|addr_hi
decl_stmt|,
name|details
decl_stmt|;
name|addr_lo
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_WR_ADD_31_0
argument_list|)
expr_stmt|;
name|addr_hi
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_WR_ADD_63_32
argument_list|)
expr_stmt|;
name|details
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_WR_DETAILS
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Illegal write by chip to [%08x:%08x] blocked. Details: %08x [PFID %02x, VFID %02x, VF_VALID %02x] Details2 %08x [Was_error %02x BME deassert %02x FID_enable deassert %02x]\n"
argument_list|,
name|addr_hi
argument_list|,
name|addr_lo
argument_list|,
name|details
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|details
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS_PFID_MASK
operator|)
operator|>>
name|ECORE_PGLUE_ATTENTION_DETAILS_PFID_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|details
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS_VFID_MASK
operator|)
operator|>>
name|ECORE_PGLUE_ATTENTION_DETAILS_VFID_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|details
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS_VF_VALID
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|,
name|tmp
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS2_WAS_ERR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS2_BME
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS2_FID_EN
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_RD_DETAILS2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_RD_VALID
condition|)
block|{
name|u32
name|addr_lo
decl_stmt|,
name|addr_hi
decl_stmt|,
name|details
decl_stmt|;
name|addr_lo
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_RD_ADD_31_0
argument_list|)
expr_stmt|;
name|addr_hi
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_RD_ADD_63_32
argument_list|)
expr_stmt|;
name|details
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_RD_DETAILS
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Illegal read by chip from [%08x:%08x] blocked. Details: %08x [PFID %02x, VFID %02x, VF_VALID %02x] Details2 %08x [Was_error %02x BME deassert %02x FID_enable deassert %02x]\n"
argument_list|,
name|addr_hi
argument_list|,
name|addr_lo
argument_list|,
name|details
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|details
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS_PFID_MASK
operator|)
operator|>>
name|ECORE_PGLUE_ATTENTION_DETAILS_PFID_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|details
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS_VFID_MASK
operator|)
operator|>>
name|ECORE_PGLUE_ATTENTION_DETAILS_VFID_SHIFT
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|details
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS_VF_VALID
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|,
name|tmp
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS2_WAS_ERR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS2_BME
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_DETAILS2_FID_EN
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_TX_ERR_WR_DETAILS_ICPL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_ICPL_VALID
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"ICPL eror - %08x\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_MASTER_ZLR_ERR_DETAILS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_ZLR_VALID
condition|)
block|{
name|u32
name|addr_hi
decl_stmt|,
name|addr_lo
decl_stmt|;
name|addr_lo
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_MASTER_ZLR_ERR_ADD_31_0
argument_list|)
expr_stmt|;
name|addr_hi
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_MASTER_ZLR_ERR_ADD_63_32
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"ICPL eror - %08x [Address %08x:%08x]\n"
argument_list|,
name|tmp
argument_list|,
name|addr_hi
argument_list|,
name|addr_lo
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_VF_ILT_ERR_DETAILS2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|ECORE_PGLUE_ATTENTION_ILT_VALID
condition|)
block|{
name|u32
name|addr_hi
decl_stmt|,
name|addr_lo
decl_stmt|,
name|details
decl_stmt|;
name|addr_lo
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_VF_ILT_ERR_ADD_31_0
argument_list|)
expr_stmt|;
name|addr_hi
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_VF_ILT_ERR_ADD_63_32
argument_list|)
expr_stmt|;
name|details
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_VF_ILT_ERR_DETAILS
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"ILT error - Details %08x Details2 %08x [Address %08x:%08x]\n"
argument_list|,
name|details
argument_list|,
name|tmp
argument_list|,
name|addr_hi
argument_list|,
name|addr_lo
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the indications */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|PGLUE_B_REG_LATCHED_ERRORS_CLR
argument_list|,
operator|(
literal|1
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_fw_assertion
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"FW assertion!\n"
argument_list|)
expr_stmt|;
name|ecore_hw_err_notify
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_ERR_FW_ASSERT
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_general_attention_35
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"General attention 35!\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ECORE_DORQ_ATTENTION_REASON_MASK
value|(0xfffff)
end_define

begin_define
define|#
directive|define
name|ECORE_DORQ_ATTENTION_OPAQUE_MASK
value|(0xffff)
end_define

begin_define
define|#
directive|define
name|ECORE_DORQ_ATTENTION_OPAQUE_SHIFT
value|(0x0)
end_define

begin_define
define|#
directive|define
name|ECORE_DORQ_ATTENTION_SIZE_MASK
value|(0x7f)
end_define

begin_define
define|#
directive|define
name|ECORE_DORQ_ATTENTION_SIZE_SHIFT
value|(16)
end_define

begin_define
define|#
directive|define
name|ECORE_DB_REC_COUNT
value|10
end_define

begin_define
define|#
directive|define
name|ECORE_DB_REC_INTERVAL
value|100
end_define

begin_comment
comment|/* assumes sticky overflow indication was set for this PF */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_db_rec_attn
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u8
name|count
init|=
name|ECORE_DB_REC_COUNT
decl_stmt|;
name|u32
name|usage
init|=
literal|1
decl_stmt|;
comment|/* wait for usage to zero or count to run out. This is necessary since 	 * EDPM doorbell transactions can take multiple 64b cycles, and as such 	 * can "split" over the pci. Possibly, the doorbell drop can happen with 	 * half an EDPM in the queue and other half dropped. Another EDPM 	 * doorbell to the same address (from doorbell recovery mechanism or 	 * from the doorbelling entity) could have first half dropped and second 	 * half interperted as continuation of the first. To prevent such 	 * malformed doorbells from reaching the device, flush the queue before 	 * releaseing the overflow sticky indication. 	 */
while|while
condition|(
name|count
operator|--
operator|&&
name|usage
condition|)
block|{
name|usage
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_PF_USAGE_CNT
argument_list|)
expr_stmt|;
name|OSAL_UDELAY
argument_list|(
name|ECORE_DB_REC_INTERVAL
argument_list|)
expr_stmt|;
block|}
comment|/* should have been depleted by now */
if|if
condition|(
name|usage
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"DB recovery: doorbell usage failed to zero after %d usec. usage was %x\n"
argument_list|,
name|ECORE_DB_REC_INTERVAL
operator|*
name|ECORE_DB_REC_COUNT
argument_list|,
name|usage
argument_list|)
expr_stmt|;
return|return
name|ECORE_TIMEOUT
return|;
block|}
comment|/* flush any pedning (e)dpm as they may never arrive */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_DPM_FORCE_ABORT
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* release overflow sticky indication (stop silently dropping everything) */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_PF_OVFL_STICKY
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* repeat all last doorbells (doorbell drop recovery) */
name|ecore_db_recovery_execute
argument_list|(
name|p_hwfn
argument_list|,
name|DB_REC_REAL_DEAL
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_dorq_attn_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|int_sts
decl_stmt|,
name|first_drop_reason
decl_stmt|,
name|details
decl_stmt|,
name|address
decl_stmt|,
name|overflow
decl_stmt|,
name|all_drops_reason
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
init|=
name|p_hwfn
operator|->
name|p_dpc_ptt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|int_sts
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_INT_STS
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"DORQ attention. int_sts was %x\n"
argument_list|,
name|int_sts
argument_list|)
expr_stmt|;
comment|/* check if db_drop or overflow happened */
if|if
condition|(
name|int_sts
operator|&
operator|(
name|DORQ_REG_INT_STS_DB_DROP
operator||
name|DORQ_REG_INT_STS_DORQ_FIFO_OVFL_ERR
operator|)
condition|)
block|{
comment|/* obtain data about db drop/overflow */
name|first_drop_reason
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_DB_DROP_REASON
argument_list|)
operator|&
name|ECORE_DORQ_ATTENTION_REASON_MASK
expr_stmt|;
name|details
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_DB_DROP_DETAILS
argument_list|)
expr_stmt|;
name|address
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_DB_DROP_DETAILS_ADDRESS
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_PF_OVFL_STICKY
argument_list|)
expr_stmt|;
name|all_drops_reason
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_DB_DROP_DETAILS_REASON
argument_list|)
expr_stmt|;
comment|/* log info */
name|DP_NOTICE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"Doorbell drop occurred\n"
literal|"Address\t\t0x%08x\t(second BAR address)\n"
literal|"FID\t\t0x%04x\t\t(Opaque FID)\n"
literal|"Size\t\t0x%04x\t\t(in bytes)\n"
literal|"1st drop reason\t0x%08x\t(details on first drop since last handling)\n"
literal|"Sticky reasons\t0x%08x\t(all drop reasons since last handling)\n"
literal|"Overflow\t0x%x\t\t(a per PF indication)\n"
argument_list|,
name|address
argument_list|,
name|GET_FIELD
argument_list|(
name|details
argument_list|,
name|ECORE_DORQ_ATTENTION_OPAQUE
argument_list|)
argument_list|,
name|GET_FIELD
argument_list|(
name|details
argument_list|,
name|ECORE_DORQ_ATTENTION_SIZE
argument_list|)
operator|*
literal|4
argument_list|,
name|first_drop_reason
argument_list|,
name|all_drops_reason
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
comment|/* if this PF caused overflow, initiate recovery */
if|if
condition|(
name|overflow
condition|)
block|{
name|rc
operator|=
name|ecore_db_rec_attn
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
block|}
comment|/* clear the doorbell drop details and prepare for next drop */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_DB_DROP_DETAILS_REL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mark interrupt as handeld (note: even if drop was due to a diffrent 		 * reason than overflow we mark as handled) 		 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_INT_STS_WR
argument_list|,
name|DORQ_REG_INT_STS_DB_DROP
operator||
name|DORQ_REG_INT_STS_DORQ_FIFO_OVFL_ERR
argument_list|)
expr_stmt|;
comment|/* if there are no indications otherthan drop indications, success */
if|if
condition|(
operator|(
name|int_sts
operator|&
operator|~
operator|(
name|DORQ_REG_INT_STS_DB_DROP
operator||
name|DORQ_REG_INT_STS_DORQ_FIFO_OVFL_ERR
operator||
name|DORQ_REG_INT_STS_DORQ_FIFO_AFULL
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|ECORE_SUCCESS
return|;
block|}
comment|/* some other indication was present - non recoverable */
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"DORQ fatal attention\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_tm_attn_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL_B0
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|u32
name|val
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|TM_REG_INT_STS_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|&
operator|~
operator|(
name|TM_REG_INT_STS_1_PEND_TASK_SCAN
operator||
name|TM_REG_INT_STS_1_PEND_CONN_SCAN
operator|)
condition|)
return|return
name|ECORE_INVAL
return|;
if|if
condition|(
name|val
operator|&
operator|(
name|TM_REG_INT_STS_1_PEND_TASK_SCAN
operator||
name|TM_REG_INT_STS_1_PEND_CONN_SCAN
operator|)
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"TM attention on emulation - most likely results of clock-ratios\n"
argument_list|)
expr_stmt|;
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|TM_REG_INT_MASK_1
argument_list|)
expr_stmt|;
name|val
operator||=
name|TM_REG_INT_MASK_1_PEND_CONN_SCAN
operator||
name|TM_REG_INT_MASK_1_PEND_TASK_SCAN
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|TM_REG_INT_MASK_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
endif|#
directive|endif
return|return
name|ECORE_INVAL
return|;
block|}
end_function

begin_comment
comment|/* Instead of major changes to the data-structure, we have a some 'special'  * identifiers for sources that changed meaning between adapters.  */
end_comment

begin_enum
enum|enum
name|aeu_invert_reg_special_type
block|{
name|AEU_INVERT_REG_SPECIAL_CNIG_0
block|,
name|AEU_INVERT_REG_SPECIAL_CNIG_1
block|,
name|AEU_INVERT_REG_SPECIAL_CNIG_2
block|,
name|AEU_INVERT_REG_SPECIAL_CNIG_3
block|,
name|AEU_INVERT_REG_SPECIAL_MAX
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|aeu_invert_reg_bit
name|aeu_descs_special
index|[
name|AEU_INVERT_REG_SPECIAL_MAX
index|]
init|=
block|{
block|{
literal|"CNIG port 0"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|BLOCK_CNIG
block|}
block|,
block|{
literal|"CNIG port 1"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|BLOCK_CNIG
block|}
block|,
block|{
literal|"CNIG port 2"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|BLOCK_CNIG
block|}
block|,
block|{
literal|"CNIG port 3"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|BLOCK_CNIG
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Notice aeu_invert_reg must be defined in the same order of bits as HW; */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|aeu_invert_reg
name|aeu_descs
index|[
name|NUM_ATTN_REGS
index|]
init|=
block|{
block|{
block|{
comment|/* After Invert 1 */
block|{
literal|"GPIO0 function%d"
block|,
operator|(
literal|32
operator|<<
name|ATTENTION_LENGTH_SHIFT
operator|)
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|, 		}
block|}
block|,
block|{
block|{
comment|/* After Invert 2 */
block|{
literal|"PGLUE config_space"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"PGLUE misc_flr"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"PGLUE B RBC"
block|,
name|ATTENTION_PAR_INT
block|,
name|ecore_pglub_rbc_attn_cb
block|,
name|BLOCK_PGLUE_B
block|}
block|,
block|{
literal|"PGLUE misc_mctp"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"Flash event"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"SMB event"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"Main Power"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"SW timers #%d"
block|,
operator|(
literal|8
operator|<<
name|ATTENTION_LENGTH_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|ATTENTION_OFFSET_SHIFT
operator|)
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"PCIE glue/PXP VPD %d"
block|,
operator|(
literal|16
operator|<<
name|ATTENTION_LENGTH_SHIFT
operator|)
block|,
name|OSAL_NULL
block|,
name|BLOCK_PGLCS
block|}
block|, 		}
block|}
block|,
block|{
block|{
comment|/* After Invert 3 */
block|{
literal|"General Attention %d"
block|,
operator|(
literal|32
operator|<<
name|ATTENTION_LENGTH_SHIFT
operator|)
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|, 		}
block|}
block|,
block|{
block|{
comment|/* After Invert 4 */
block|{
literal|"General Attention 32"
block|,
name|ATTENTION_SINGLE
operator||
name|ATTENTION_CLEAR_ENABLE
block|,
name|ecore_fw_assertion
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"General Attention %d"
block|,
operator|(
literal|2
operator|<<
name|ATTENTION_LENGTH_SHIFT
operator|)
operator||
operator|(
literal|33
operator|<<
name|ATTENTION_OFFSET_SHIFT
operator|)
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"General Attention 35"
block|,
name|ATTENTION_SINGLE
operator||
name|ATTENTION_CLEAR_ENABLE
block|,
name|ecore_general_attention_35
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"NWS Parity"
block|,
name|ATTENTION_PAR
operator||
name|ATTENTION_BB_DIFFERENT
operator||
name|ATTENTION_BB
argument_list|(
name|AEU_INVERT_REG_SPECIAL_CNIG_0
argument_list|)
block|,
name|OSAL_NULL
block|,
name|BLOCK_NWS
block|}
block|,
block|{
literal|"NWS Interrupt"
block|,
name|ATTENTION_SINGLE
operator||
name|ATTENTION_BB_DIFFERENT
operator||
name|ATTENTION_BB
argument_list|(
name|AEU_INVERT_REG_SPECIAL_CNIG_1
argument_list|)
block|,
name|OSAL_NULL
block|,
name|BLOCK_NWS
block|}
block|,
block|{
literal|"NWM Parity"
block|,
name|ATTENTION_PAR
operator||
name|ATTENTION_BB_DIFFERENT
operator||
name|ATTENTION_BB
argument_list|(
name|AEU_INVERT_REG_SPECIAL_CNIG_2
argument_list|)
block|,
name|OSAL_NULL
block|,
name|BLOCK_NWM
block|}
block|,
block|{
literal|"NWM Interrupt"
block|,
name|ATTENTION_SINGLE
operator||
name|ATTENTION_BB_DIFFERENT
operator||
name|ATTENTION_BB
argument_list|(
name|AEU_INVERT_REG_SPECIAL_CNIG_3
argument_list|)
block|,
name|OSAL_NULL
block|,
name|BLOCK_NWM
block|}
block|,
block|{
literal|"MCP CPU"
block|,
name|ATTENTION_SINGLE
block|,
name|ecore_mcp_attn_cb
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"MCP Watchdog timer"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"MCP M2P"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"AVS stop status ready"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"MSTAT"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"MSTAT per-path"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"Reserved %d"
block|,
operator|(
literal|6
operator|<<
name|ATTENTION_LENGTH_SHIFT
operator|)
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"NIG"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_NIG
block|}
block|,
block|{
literal|"BMB/OPTE/MCP"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_BMB
block|}
block|,
block|{
literal|"BTB"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_BTB
block|}
block|,
block|{
literal|"BRB"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_BRB
block|}
block|,
block|{
literal|"PRS"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PRS
block|}
block|, 		}
block|}
block|,
block|{
block|{
comment|/* After Invert 5 */
block|{
literal|"SRC"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_SRC
block|}
block|,
block|{
literal|"PB Client1"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PBF_PB1
block|}
block|,
block|{
literal|"PB Client2"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PBF_PB2
block|}
block|,
block|{
literal|"RPB"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_RPB
block|}
block|,
block|{
literal|"PBF"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PBF
block|}
block|,
block|{
literal|"QM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_QM
block|}
block|,
block|{
literal|"TM"
block|,
name|ATTENTION_PAR_INT
block|,
name|ecore_tm_attn_cb
block|,
name|BLOCK_TM
block|}
block|,
block|{
literal|"MCM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_MCM
block|}
block|,
block|{
literal|"MSDM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_MSDM
block|}
block|,
block|{
literal|"MSEM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_MSEM
block|}
block|,
block|{
literal|"PCM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PCM
block|}
block|,
block|{
literal|"PSDM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSDM
block|}
block|,
block|{
literal|"PSEM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSEM
block|}
block|,
block|{
literal|"TCM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_TCM
block|}
block|,
block|{
literal|"TSDM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_TSDM
block|}
block|,
block|{
literal|"TSEM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_TSEM
block|}
block|, 		}
block|}
block|,
block|{
block|{
comment|/* After Invert 6 */
block|{
literal|"UCM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_UCM
block|}
block|,
block|{
literal|"USDM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_USDM
block|}
block|,
block|{
literal|"USEM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_USEM
block|}
block|,
block|{
literal|"XCM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_XCM
block|}
block|,
block|{
literal|"XSDM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_XSDM
block|}
block|,
block|{
literal|"XSEM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_XSEM
block|}
block|,
block|{
literal|"YCM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_YCM
block|}
block|,
block|{
literal|"YSDM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_YSDM
block|}
block|,
block|{
literal|"YSEM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_YSEM
block|}
block|,
block|{
literal|"XYLD"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_XYLD
block|}
block|,
block|{
literal|"TMLD"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_TMLD
block|}
block|,
block|{
literal|"MYLD"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_MULD
block|}
block|,
block|{
literal|"YULD"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_YULD
block|}
block|,
block|{
literal|"DORQ"
block|,
name|ATTENTION_PAR_INT
block|,
name|ecore_dorq_attn_cb
block|,
name|BLOCK_DORQ
block|}
block|,
block|{
literal|"DBG"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_DBG
block|}
block|,
block|{
literal|"IPC"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_IPC
block|}
block|, 		}
block|}
block|,
block|{
block|{
comment|/* After Invert 7 */
block|{
literal|"CCFC"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_CCFC
block|}
block|,
block|{
literal|"CDU"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_CDU
block|}
block|,
block|{
literal|"DMAE"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_DMAE
block|}
block|,
block|{
literal|"IGU"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_IGU
block|}
block|,
block|{
literal|"ATC"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"CAU"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_CAU
block|}
block|,
block|{
literal|"PTU"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PTU
block|}
block|,
block|{
literal|"PRM"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PRM
block|}
block|,
block|{
literal|"TCFC"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_TCFC
block|}
block|,
block|{
literal|"RDIF"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_RDIF
block|}
block|,
block|{
literal|"TDIF"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_TDIF
block|}
block|,
block|{
literal|"RSS"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_RSS
block|}
block|,
block|{
literal|"MISC"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_MISC
block|}
block|,
block|{
literal|"MISCS"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_MISCS
block|}
block|,
block|{
literal|"PCIE"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|BLOCK_PCIE
block|}
block|,
block|{
literal|"Vaux PCI core"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|BLOCK_PGLCS
block|}
block|,
block|{
literal|"PSWRQ"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSWRQ
block|}
block|, 		}
block|}
block|,
block|{
block|{
comment|/* After Invert 8 */
block|{
literal|"PSWRQ (pci_clk)"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSWRQ2
block|}
block|,
block|{
literal|"PSWWR"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSWWR
block|}
block|,
block|{
literal|"PSWWR (pci_clk)"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSWWR2
block|}
block|,
block|{
literal|"PSWRD"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSWRD
block|}
block|,
block|{
literal|"PSWRD (pci_clk)"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSWRD2
block|}
block|,
block|{
literal|"PSWHST"
block|,
name|ATTENTION_PAR_INT
block|,
name|ecore_pswhst_attn_cb
block|,
name|BLOCK_PSWHST
block|}
block|,
block|{
literal|"PSWHST (pci_clk)"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_PSWHST2
block|}
block|,
block|{
literal|"GRC"
block|,
name|ATTENTION_PAR_INT
block|,
name|ecore_grc_attn_cb
block|,
name|BLOCK_GRC
block|}
block|,
block|{
literal|"CPMU"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_CPMU
block|}
block|,
block|{
literal|"NCSI"
block|,
name|ATTENTION_PAR_INT
block|,
name|OSAL_NULL
block|,
name|BLOCK_NCSI
block|}
block|,
block|{
literal|"MSEM PRAM"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"PSEM PRAM"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"TSEM PRAM"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"USEM PRAM"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"XSEM PRAM"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"YSEM PRAM"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"pxp_misc_mps"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|BLOCK_PGLCS
block|}
block|,
block|{
literal|"PCIE glue/PXP Exp. ROM"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|BLOCK_PGLCS
block|}
block|,
block|{
literal|"PERST_B assertion"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"PERST_B deassertion"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"Reserved %d"
block|,
operator|(
literal|2
operator|<<
name|ATTENTION_LENGTH_SHIFT
operator|)
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|, 		}
block|}
block|,
block|{
block|{
comment|/* After Invert 9 */
block|{
literal|"MCP Latched memory"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"MCP Latched scratchpad cache"
block|,
name|ATTENTION_SINGLE
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"MCP Latched ump_tx"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"MCP Latched scratchpad"
block|,
name|ATTENTION_PAR
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|,
block|{
literal|"Reserved %d"
block|,
operator|(
literal|28
operator|<<
name|ATTENTION_LENGTH_SHIFT
operator|)
block|,
name|OSAL_NULL
block|,
name|MAX_BLOCK_ID
block|}
block|, 		}
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|aeu_invert_reg_bit
modifier|*
name|ecore_int_aeu_translate
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|aeu_invert_reg_bit
modifier|*
name|p_bit
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|p_bit
return|;
if|if
condition|(
operator|!
operator|(
name|p_bit
operator|->
name|flags
operator|&
name|ATTENTION_BB_DIFFERENT
operator|)
condition|)
return|return
name|p_bit
return|;
return|return
operator|&
name|aeu_descs_special
index|[
operator|(
name|p_bit
operator|->
name|flags
operator|&
name|ATTENTION_BB_MASK
operator|)
operator|>>
name|ATTENTION_BB_SHIFT
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_int_is_parity_flag
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|aeu_invert_reg_bit
modifier|*
name|p_bit
parameter_list|)
block|{
return|return
operator|!
operator|!
operator|(
name|ecore_int_aeu_translate
argument_list|(
name|p_hwfn
argument_list|,
name|p_bit
argument_list|)
operator|->
name|flags
operator|&
name|ATTENTION_PARITY
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ATTN_STATE_BITS
value|(0xfff)
end_define

begin_define
define|#
directive|define
name|ATTN_BITS_MASKABLE
value|(0x3ff)
end_define

begin_struct
struct|struct
name|ecore_sb_attn_info
block|{
comment|/* Virtual& Physical address of the SB */
name|struct
name|atten_status_block
modifier|*
name|sb_attn
decl_stmt|;
name|dma_addr_t
name|sb_phys
decl_stmt|;
comment|/* Last seen running index */
name|u16
name|index
decl_stmt|;
comment|/* A mask of the AEU bits resulting in a parity error */
name|u32
name|parity_mask
index|[
name|NUM_ATTN_REGS
index|]
decl_stmt|;
comment|/* A pointer to the attention description structure */
name|struct
name|aeu_invert_reg
modifier|*
name|p_aeu_desc
decl_stmt|;
comment|/* Previously asserted attentions, which are still unasserted */
name|u16
name|known_attn
decl_stmt|;
comment|/* Cleanup address for the link's general hw attention */
name|u32
name|mfw_attn_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|u16
name|ecore_attn_update_idx
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_sb_attn_info
modifier|*
name|p_sb_desc
parameter_list|)
block|{
name|u16
name|rc
init|=
literal|0
decl_stmt|,
name|index
decl_stmt|;
name|OSAL_MMIOWB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
name|index
operator|=
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_sb_desc
operator|->
name|sb_attn
operator|->
name|sb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sb_desc
operator|->
name|index
operator|!=
name|index
condition|)
block|{
name|p_sb_desc
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|rc
operator|=
name|ECORE_SB_ATT_IDX
expr_stmt|;
block|}
name|OSAL_MMIOWB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_int_assertion - handles asserted attention bits  *  * @param p_hwfn  * @param asserted_bits newly asserted bits  * @return enum _ecore_status_t  */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_int_assertion
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|asserted_bits
parameter_list|)
block|{
name|struct
name|ecore_sb_attn_info
modifier|*
name|sb_attn_sw
init|=
name|p_hwfn
operator|->
name|p_sb_attn
decl_stmt|;
name|u32
name|igu_mask
decl_stmt|;
comment|/* Mask the source of the attention in the IGU */
name|igu_mask
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|IGU_REG_ATTENTION_ENABLE
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"IGU mask: 0x%08x --> 0x%08x\n"
argument_list|,
name|igu_mask
argument_list|,
name|igu_mask
operator|&
operator|~
operator|(
name|asserted_bits
operator|&
name|ATTN_BITS_MASKABLE
operator|)
argument_list|)
expr_stmt|;
name|igu_mask
operator|&=
operator|~
operator|(
name|asserted_bits
operator|&
name|ATTN_BITS_MASKABLE
operator|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|IGU_REG_ATTENTION_ENABLE
argument_list|,
name|igu_mask
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"inner known ATTN state: 0x%04x --> 0x%04x\n"
argument_list|,
name|sb_attn_sw
operator|->
name|known_attn
argument_list|,
name|sb_attn_sw
operator|->
name|known_attn
operator||
name|asserted_bits
argument_list|)
expr_stmt|;
name|sb_attn_sw
operator|->
name|known_attn
operator||=
name|asserted_bits
expr_stmt|;
comment|/* Handle MCP events */
if|if
condition|(
name|asserted_bits
operator|&
literal|0x100
condition|)
block|{
name|ecore_mcp_handle_events
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|)
expr_stmt|;
comment|/* Clean the MCP attention */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|sb_attn_sw
operator|->
name|mfw_attn_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME - this will change once we'll have GOOD gtt definitions */
name|DIRECT_REG_WR
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|u8
name|OSAL_IOMEM
operator|*
operator|)
name|p_hwfn
operator|->
name|regview
operator|+
name|GTT_BAR0_MAP_REG_IGU_CMD
operator|+
operator|(
operator|(
name|IGU_CMD_ATTN_BIT_SET_UPPER
operator|-
name|IGU_CMD_INT_ACK_BASE
operator|)
operator|<<
literal|3
operator|)
argument_list|,
operator|(
name|u32
operator|)
name|asserted_bits
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"set cmd IGU: 0x%04x\n"
argument_list|,
name|asserted_bits
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_attn_print
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|block_id
name|id
parameter_list|,
name|enum
name|dbg_attn_type
name|type
parameter_list|,
name|bool
name|b_clear
parameter_list|)
block|{
name|struct
name|dbg_attn_block_result
name|attn_results
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|attn_results
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|attn_results
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|ecore_dbg_read_attn
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|id
argument_list|,
name|type
argument_list|,
name|b_clear
argument_list|,
operator|&
name|attn_results
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTN_DESC
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to parse attention information [status: %s]\n"
argument_list|,
name|ecore_dbg_get_status_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ecore_dbg_parse_attn
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|attn_results
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to parse attention information [status: %d]\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|ecore_dbg_print_attn
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|attn_results
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * @brief ecore_int_deassertion_aeu_bit - handles the effects of a single  * cause of the attention  *  * @param p_hwfn  * @param p_aeu - descriptor of an AEU bit which caused the attention  * @param aeu_en_reg - register offset of the AEU enable reg. which configured  *  this bit to this group.  * @param bit_index - index of this bit in the aeu_en_reg  *  * @return enum _ecore_status_t  */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_int_deassertion_aeu_bit
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|aeu_invert_reg_bit
modifier|*
name|p_aeu
parameter_list|,
name|u32
name|aeu_en_reg
parameter_list|,
specifier|const
name|char
modifier|*
name|p_bit_name
parameter_list|,
name|u32
name|bitmask
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_INVAL
decl_stmt|;
name|bool
name|b_fatal
init|=
name|false
decl_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Deasserted attention `%s'[%08x]\n"
argument_list|,
name|p_bit_name
argument_list|,
name|bitmask
argument_list|)
expr_stmt|;
comment|/* Call callback before clearing the interrupt status */
if|if
condition|(
name|p_aeu
operator|->
name|cb
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"`%s (attention)': Calling Callback function\n"
argument_list|,
name|p_bit_name
argument_list|)
expr_stmt|;
name|rc
operator|=
name|p_aeu
operator|->
name|cb
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|b_fatal
operator|=
name|true
expr_stmt|;
comment|/* Print HW block interrupt registers */
if|if
condition|(
name|p_aeu
operator|->
name|block_index
operator|!=
name|MAX_BLOCK_ID
condition|)
name|ecore_int_attn_print
argument_list|(
name|p_hwfn
argument_list|,
name|p_aeu
operator|->
name|block_index
argument_list|,
name|ATTN_TYPE_INTERRUPT
argument_list|,
operator|!
name|b_fatal
argument_list|)
expr_stmt|;
comment|/* Reach assertion if attention is fatal */
if|if
condition|(
name|b_fatal
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"`%s': Fatal attention\n"
argument_list|,
name|p_bit_name
argument_list|)
expr_stmt|;
name|ecore_hw_err_notify
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_ERR_HW_ATTN
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent this Attention from being asserted in the future */
if|if
condition|(
name|p_aeu
operator|->
name|flags
operator|&
name|ATTENTION_CLEAR_ENABLE
operator|||
name|p_hwfn
operator|->
name|p_dev
operator|->
name|attn_clr_en
condition|)
block|{
name|u32
name|val
decl_stmt|;
name|u32
name|mask
init|=
operator|~
name|bitmask
decl_stmt|;
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|aeu_en_reg
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|aeu_en_reg
argument_list|,
operator|(
name|val
operator|&
name|mask
operator|)
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"`%s' - Disabled future attentions\n"
argument_list|,
name|p_bit_name
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_int_deassertion_parity - handle a single parity AEU source  *  * @param p_hwfn  * @param p_aeu - descriptor of an AEU bit which caused the parity  * @param aeu_en_reg - address of the AEU enable register  * @param bit_index  */
end_comment

begin_function
specifier|static
name|void
name|ecore_int_deassertion_parity
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|aeu_invert_reg_bit
modifier|*
name|p_aeu
parameter_list|,
name|u32
name|aeu_en_reg
parameter_list|,
name|u8
name|bit_index
parameter_list|)
block|{
name|u32
name|block_id
init|=
name|p_aeu
operator|->
name|block_index
decl_stmt|,
name|mask
decl_stmt|,
name|val
decl_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"%s parity attention is set [address 0x%08x, bit %d]\n"
argument_list|,
name|p_aeu
operator|->
name|bit_name
argument_list|,
name|aeu_en_reg
argument_list|,
name|bit_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_id
operator|==
name|MAX_BLOCK_ID
condition|)
return|return;
name|ecore_int_attn_print
argument_list|(
name|p_hwfn
argument_list|,
name|block_id
argument_list|,
name|ATTN_TYPE_PARITY
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* In A0, there's a single parity bit for several blocks */
if|if
condition|(
name|block_id
operator|==
name|BLOCK_BTB
condition|)
block|{
name|ecore_int_attn_print
argument_list|(
name|p_hwfn
argument_list|,
name|BLOCK_OPTE
argument_list|,
name|ATTN_TYPE_PARITY
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ecore_int_attn_print
argument_list|(
name|p_hwfn
argument_list|,
name|BLOCK_MCP
argument_list|,
name|ATTN_TYPE_PARITY
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent this parity error from being re-asserted */
name|mask
operator|=
operator|~
operator|(
literal|0x1
operator|<<
name|bit_index
operator|)
expr_stmt|;
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|aeu_en_reg
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|aeu_en_reg
argument_list|,
name|val
operator|&
name|mask
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"`%s' - Disabled future parity errors\n"
argument_list|,
name|p_aeu
operator|->
name|bit_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief - handles deassertion of previously asserted attentions.  *  * @param p_hwfn  * @param deasserted_bits - newly deasserted bits  * @return enum _ecore_status_t  *  */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_int_deassertion
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|deasserted_bits
parameter_list|)
block|{
name|struct
name|ecore_sb_attn_info
modifier|*
name|sb_attn_sw
init|=
name|p_hwfn
operator|->
name|p_sb_attn
decl_stmt|;
name|u32
name|aeu_inv_arr
index|[
name|NUM_ATTN_REGS
index|]
decl_stmt|,
name|aeu_mask
decl_stmt|,
name|aeu_en
decl_stmt|,
name|en
decl_stmt|;
name|u8
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|bit_idx
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
comment|/* Read the attention registers in the AEU */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ATTN_REGS
condition|;
name|i
operator|++
control|)
block|{
name|aeu_inv_arr
index|[
name|i
index|]
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_1_IGU
operator|+
name|i
operator|*
literal|0x4
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"Deasserted bits [%d]: %08x\n"
argument_list|,
name|i
argument_list|,
name|aeu_inv_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Handle parity attentions first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ATTN_REGS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|aeu_invert_reg
modifier|*
name|p_aeu
init|=
operator|&
name|sb_attn_sw
operator|->
name|p_aeu_desc
index|[
name|i
index|]
decl_stmt|;
name|u32
name|parities
decl_stmt|;
name|aeu_en
operator|=
name|MISC_REG_AEU_ENABLE1_IGU_OUT_0
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
expr_stmt|;
name|en
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|aeu_en
argument_list|)
expr_stmt|;
name|parities
operator|=
name|sb_attn_sw
operator|->
name|parity_mask
index|[
name|i
index|]
operator|&
name|aeu_inv_arr
index|[
name|i
index|]
operator|&
name|en
expr_stmt|;
comment|/* Skip register in which no parity bit is currently set */
if|if
condition|(
operator|!
name|parities
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|bit_idx
operator|=
literal|0
init|;
name|bit_idx
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|aeu_invert_reg_bit
modifier|*
name|p_bit
init|=
operator|&
name|p_aeu
operator|->
name|bits
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|ecore_int_is_parity_flag
argument_list|(
name|p_hwfn
argument_list|,
name|p_bit
argument_list|)
operator|&&
operator|!
operator|!
operator|(
name|parities
operator|&
operator|(
literal|1
operator|<<
name|bit_idx
operator|)
operator|)
condition|)
name|ecore_int_deassertion_parity
argument_list|(
name|p_hwfn
argument_list|,
name|p_bit
argument_list|,
name|aeu_en
argument_list|,
name|bit_idx
argument_list|)
expr_stmt|;
name|bit_idx
operator|+=
name|ATTENTION_LENGTH
argument_list|(
name|p_bit
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find non-parity cause for attention and act */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAX_ATTN_GRPS
condition|;
name|k
operator|++
control|)
block|{
name|struct
name|aeu_invert_reg_bit
modifier|*
name|p_aeu
decl_stmt|;
comment|/* Handle only groups whose attention is currently deasserted */
if|if
condition|(
operator|!
operator|(
name|deasserted_bits
operator|&
operator|(
literal|1
operator|<<
name|k
operator|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ATTN_REGS
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|bits
decl_stmt|;
name|aeu_en
operator|=
name|MISC_REG_AEU_ENABLE1_IGU_OUT_0
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|+
name|k
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|NUM_ATTN_REGS
expr_stmt|;
name|en
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|aeu_en
argument_list|)
expr_stmt|;
name|bits
operator|=
name|aeu_inv_arr
index|[
name|i
index|]
operator|&
name|en
expr_stmt|;
comment|/* Skip if no bit from this group is currently set */
if|if
condition|(
operator|!
name|bits
condition|)
continue|continue;
comment|/* Find all set bits from current register which belong 			 * to current group, making them responsible for the 			 * previous assertion. 			 */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|bit_idx
operator|=
literal|0
init|;
name|bit_idx
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|long
name|unsigned
name|int
name|bitmask
decl_stmt|;
name|u8
name|bit
decl_stmt|,
name|bit_len
decl_stmt|;
comment|/* Need to account bits with changed meaning */
name|p_aeu
operator|=
operator|&
name|sb_attn_sw
operator|->
name|p_aeu_desc
index|[
name|i
index|]
operator|.
name|bits
index|[
name|j
index|]
expr_stmt|;
name|p_aeu
operator|=
name|ecore_int_aeu_translate
argument_list|(
name|p_hwfn
argument_list|,
name|p_aeu
argument_list|)
expr_stmt|;
name|bit
operator|=
name|bit_idx
expr_stmt|;
name|bit_len
operator|=
name|ATTENTION_LENGTH
argument_list|(
name|p_aeu
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecore_int_is_parity_flag
argument_list|(
name|p_hwfn
argument_list|,
name|p_aeu
argument_list|)
condition|)
block|{
comment|/* Skip Parity */
name|bit
operator|++
expr_stmt|;
name|bit_len
operator|--
expr_stmt|;
block|}
comment|/* Find the bits relating to HW-block, then 				 * shift so they'll become LSB. 				 */
name|bitmask
operator|=
name|bits
operator|&
operator|(
operator|(
operator|(
literal|1
operator|<<
name|bit_len
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bit
operator|)
expr_stmt|;
name|bitmask
operator|>>=
name|bit
expr_stmt|;
if|if
condition|(
name|bitmask
condition|)
block|{
name|u32
name|flags
init|=
name|p_aeu
operator|->
name|flags
decl_stmt|;
name|char
name|bit_name
index|[
literal|30
index|]
decl_stmt|;
name|u8
name|num
decl_stmt|;
name|num
operator|=
operator|(
name|u8
operator|)
name|OSAL_FIND_FIRST_BIT
argument_list|(
operator|&
name|bitmask
argument_list|,
name|bit_len
argument_list|)
expr_stmt|;
comment|/* Some bits represent more than a 					 * a single interrupt. Correctly print 					 * their name. 					 */
if|if
condition|(
name|ATTENTION_LENGTH
argument_list|(
name|flags
argument_list|)
operator|>
literal|2
operator|||
operator|(
operator|(
name|flags
operator|&
name|ATTENTION_PAR_INT
operator|)
operator|&&
name|ATTENTION_LENGTH
argument_list|(
name|flags
argument_list|)
operator|>
literal|1
operator|)
condition|)
name|OSAL_SNPRINTF
argument_list|(
name|bit_name
argument_list|,
literal|30
argument_list|,
name|p_aeu
operator|->
name|bit_name
argument_list|,
name|num
argument_list|)
expr_stmt|;
else|else
name|OSAL_STRNCPY
argument_list|(
name|bit_name
argument_list|,
name|p_aeu
operator|->
name|bit_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
comment|/* We now need to pass bitmask in its 					 * correct position. 					 */
name|bitmask
operator|<<=
name|bit
expr_stmt|;
comment|/* Handle source of the attention */
name|ecore_int_deassertion_aeu_bit
argument_list|(
name|p_hwfn
argument_list|,
name|p_aeu
argument_list|,
name|aeu_en
argument_list|,
name|bit_name
argument_list|,
name|bitmask
argument_list|)
expr_stmt|;
block|}
name|bit_idx
operator|+=
name|ATTENTION_LENGTH
argument_list|(
name|p_aeu
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Clear IGU indication for the deasserted bits */
comment|/* FIXME - this will change once we'll have GOOD gtt definitions */
name|DIRECT_REG_WR
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|u8
name|OSAL_IOMEM
operator|*
operator|)
name|p_hwfn
operator|->
name|regview
operator|+
name|GTT_BAR0_MAP_REG_IGU_CMD
operator|+
operator|(
operator|(
name|IGU_CMD_ATTN_BIT_CLR_UPPER
operator|-
name|IGU_CMD_INT_ACK_BASE
operator|)
operator|<<
literal|3
operator|)
argument_list|,
operator|~
operator|(
operator|(
name|u32
operator|)
name|deasserted_bits
operator|)
argument_list|)
expr_stmt|;
comment|/* Unmask deasserted attentions in IGU */
name|aeu_mask
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|IGU_REG_ATTENTION_ENABLE
argument_list|)
expr_stmt|;
name|aeu_mask
operator||=
operator|(
name|deasserted_bits
operator|&
name|ATTN_BITS_MASKABLE
operator|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_dpc_ptt
argument_list|,
name|IGU_REG_ATTENTION_ENABLE
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
comment|/* Clear deassertion from inner state */
name|sb_attn_sw
operator|->
name|known_attn
operator|&=
operator|~
name|deasserted_bits
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_int_attentions
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_sb_attn_info
modifier|*
name|p_sb_attn_sw
init|=
name|p_hwfn
operator|->
name|p_sb_attn
decl_stmt|;
name|struct
name|atten_status_block
modifier|*
name|p_sb_attn
init|=
name|p_sb_attn_sw
operator|->
name|sb_attn
decl_stmt|;
name|u16
name|index
init|=
literal|0
decl_stmt|,
name|asserted_bits
decl_stmt|,
name|deasserted_bits
decl_stmt|;
name|u32
name|attn_bits
init|=
literal|0
decl_stmt|,
name|attn_acks
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
comment|/* Read current attention bits/acks - safeguard against attentions 	 * by guaranting work on a synchronized timeframe 	 */
do|do
block|{
name|index
operator|=
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_sb_attn
operator|->
name|sb_index
argument_list|)
expr_stmt|;
name|attn_bits
operator|=
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_sb_attn
operator|->
name|atten_bits
argument_list|)
expr_stmt|;
name|attn_acks
operator|=
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_sb_attn
operator|->
name|atten_ack
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|index
operator|!=
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_sb_attn
operator|->
name|sb_index
argument_list|)
condition|)
do|;
name|p_sb_attn
operator|->
name|sb_index
operator|=
name|index
expr_stmt|;
comment|/* Attention / Deassertion are meaningful (and in correct state) 	 * only when they differ and consistent with known state - deassertion 	 * when previous attention& current ack, and assertion when current 	 * attention with no previous attention 	 */
name|asserted_bits
operator|=
operator|(
name|attn_bits
operator|&
operator|~
name|attn_acks
operator|&
name|ATTN_STATE_BITS
operator|)
operator|&
operator|~
name|p_sb_attn_sw
operator|->
name|known_attn
expr_stmt|;
name|deasserted_bits
operator|=
operator|(
operator|~
name|attn_bits
operator|&
name|attn_acks
operator|&
name|ATTN_STATE_BITS
operator|)
operator|&
name|p_sb_attn_sw
operator|->
name|known_attn
expr_stmt|;
if|if
condition|(
operator|(
name|asserted_bits
operator|&
operator|~
literal|0x100
operator|)
operator|||
operator|(
name|deasserted_bits
operator|&
operator|~
literal|0x100
operator|)
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Attention: Index: 0x%04x, Bits: 0x%08x, Acks: 0x%08x, asserted: 0x%04x, De-asserted 0x%04x [Prev. known: 0x%04x]\n"
argument_list|,
name|index
argument_list|,
name|attn_bits
argument_list|,
name|attn_acks
argument_list|,
name|asserted_bits
argument_list|,
name|deasserted_bits
argument_list|,
name|p_sb_attn_sw
operator|->
name|known_attn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|asserted_bits
operator|==
literal|0x100
condition|)
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"MFW indication via attention\n"
argument_list|)
expr_stmt|;
else|else
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"MFW indication [deassertion]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asserted_bits
condition|)
block|{
name|rc
operator|=
name|ecore_int_assertion
argument_list|(
name|p_hwfn
argument_list|,
name|asserted_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
block|}
if|if
condition|(
name|deasserted_bits
condition|)
name|rc
operator|=
name|ecore_int_deassertion
argument_list|(
name|p_hwfn
argument_list|,
name|deasserted_bits
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_sb_ack_attn
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|void
name|OSAL_IOMEM
modifier|*
name|igu_addr
parameter_list|,
name|u32
name|ack_cons
parameter_list|)
block|{
name|struct
name|igu_prod_cons_update
name|igu_ack
init|=
block|{
literal|0
block|}
decl_stmt|;
name|igu_ack
operator|.
name|sb_id_and_flags
operator|=
operator|(
operator|(
name|ack_cons
operator|<<
name|IGU_PROD_CONS_UPDATE_SB_INDEX_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|IGU_PROD_CONS_UPDATE_UPDATE_FLAG_SHIFT
operator|)
operator||
operator|(
name|IGU_INT_NOP
operator|<<
name|IGU_PROD_CONS_UPDATE_ENABLE_INT_SHIFT
operator|)
operator||
operator|(
name|IGU_SEG_ACCESS_ATTN
operator|<<
name|IGU_PROD_CONS_UPDATE_SEGMENT_ACCESS_SHIFT
operator|)
operator|)
expr_stmt|;
name|DIRECT_REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|igu_addr
argument_list|,
name|igu_ack
operator|.
name|sb_id_and_flags
argument_list|)
expr_stmt|;
comment|/* Both segments (interrupts& acks) are written to same place address; 	 * Need to guarantee all commands will be received (in-order) by HW. 	 */
name|OSAL_MMIOWB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
name|OSAL_BARRIER
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_int_sp_dpc
parameter_list|(
name|osal_int_ptr_t
name|hwfn_cookie
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|(
expr|struct
name|ecore_hwfn
operator|*
operator|)
name|hwfn_cookie
decl_stmt|;
name|struct
name|ecore_pi_info
modifier|*
name|pi_info
init|=
name|OSAL_NULL
decl_stmt|;
name|struct
name|ecore_sb_attn_info
modifier|*
name|sb_attn
decl_stmt|;
name|struct
name|ecore_sb_info
modifier|*
name|sb_info
decl_stmt|;
name|int
name|arr_size
decl_stmt|;
name|u16
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
condition|)
return|return;
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_sp_sb
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"DPC called - no p_sp_sb\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sb_info
operator|=
operator|&
name|p_hwfn
operator|->
name|p_sp_sb
operator|->
name|sb_info
expr_stmt|;
name|arr_size
operator|=
name|OSAL_ARRAY_SIZE
argument_list|(
name|p_hwfn
operator|->
name|p_sp_sb
operator|->
name|pi_info_arr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sb_info
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Status block is NULL - cannot ack interrupts\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_sb_attn
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"DPC called - no p_sb_attn"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sb_attn
operator|=
name|p_hwfn
operator|->
name|p_sb_attn
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"DPC Called! (hwfn %p %d)\n"
argument_list|,
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|my_id
argument_list|)
expr_stmt|;
comment|/* Disable ack for def status block. Required both for msix + 	 * inta in non-mask mode, in inta does no harm. 	 */
name|ecore_sb_ack
argument_list|(
name|sb_info
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Gather Interrupts/Attentions information */
if|if
condition|(
operator|!
name|sb_info
operator|->
name|sb_virt
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Interrupt Status block is NULL - cannot check for new interrupts!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u32
name|tmp_index
init|=
name|sb_info
operator|->
name|sb_ack
decl_stmt|;
name|rc
operator|=
name|ecore_sb_update_sb_idx
argument_list|(
name|sb_info
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"Interrupt indices: 0x%08x --> 0x%08x\n"
argument_list|,
name|tmp_index
argument_list|,
name|sb_info
operator|->
name|sb_ack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sb_attn
operator|||
operator|!
name|sb_attn
operator|->
name|sb_attn
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Attentions Status block is NULL - cannot check for new attentions!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u16
name|tmp_index
init|=
name|sb_attn
operator|->
name|index
decl_stmt|;
name|rc
operator||=
name|ecore_attn_update_idx
argument_list|(
name|p_hwfn
argument_list|,
name|sb_attn
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"Attention indices: 0x%08x --> 0x%08x\n"
argument_list|,
name|tmp_index
argument_list|,
name|sb_attn
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Check if we expect interrupts at this time. if not just ack them */
if|if
condition|(
operator|!
operator|(
name|rc
operator|&
name|ECORE_SB_EVENT_MASK
operator|)
condition|)
block|{
name|ecore_sb_ack
argument_list|(
name|sb_info
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check the validity of the DPC ptt. If not ack interrupts and fail */
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_dpc_ptt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate PTT\n"
argument_list|)
expr_stmt|;
name|ecore_sb_ack
argument_list|(
name|sb_info
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rc
operator|&
name|ECORE_SB_ATT_IDX
condition|)
name|ecore_int_attentions
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|&
name|ECORE_SB_IDX
condition|)
block|{
name|int
name|pi
decl_stmt|;
comment|/* Since we only looked at the SB index, it's possible more 		 * than a single protocol-index on the SB incremented. 		 * Iterate over all configured protocol indices and check 		 * whether something happened for each. 		 */
for|for
control|(
name|pi
operator|=
literal|0
init|;
name|pi
operator|<
name|arr_size
condition|;
name|pi
operator|++
control|)
block|{
name|pi_info
operator|=
operator|&
name|p_hwfn
operator|->
name|p_sp_sb
operator|->
name|pi_info_arr
index|[
name|pi
index|]
expr_stmt|;
if|if
condition|(
name|pi_info
operator|->
name|comp_cb
operator|!=
name|OSAL_NULL
condition|)
name|pi_info
operator|->
name|comp_cb
argument_list|(
name|p_hwfn
argument_list|,
name|pi_info
operator|->
name|cookie
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sb_attn
operator|&&
operator|(
name|rc
operator|&
name|ECORE_SB_ATT_IDX
operator|)
condition|)
block|{
comment|/* This should be done before the interrupts are enabled, 		 * since otherwise a new attention will be generated. 		 */
name|ecore_sb_ack_attn
argument_list|(
name|p_hwfn
argument_list|,
name|sb_info
operator|->
name|igu_addr
argument_list|,
name|sb_attn
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|ecore_sb_ack
argument_list|(
name|sb_info
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_sb_attn_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_sb_attn_info
modifier|*
name|p_sb
init|=
name|p_hwfn
operator|->
name|p_sb_attn
decl_stmt|;
if|if
condition|(
operator|!
name|p_sb
condition|)
return|return;
if|if
condition|(
name|p_sb
operator|->
name|sb_attn
condition|)
block|{
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_sb
operator|->
name|sb_attn
argument_list|,
name|p_sb
operator|->
name|sb_phys
argument_list|,
name|SB_ATTN_ALIGNED_SIZE
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_sb
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_sb_attn
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_sb_attn_setup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_sb_attn_info
modifier|*
name|sb_info
init|=
name|p_hwfn
operator|->
name|p_sb_attn
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
name|sb_info
operator|->
name|sb_attn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb_info
operator|->
name|sb_attn
argument_list|)
argument_list|)
expr_stmt|;
name|sb_info
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|sb_info
operator|->
name|known_attn
operator|=
literal|0
expr_stmt|;
comment|/* Configure Attention Status Block in IGU */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_ATTN_MSG_ADDR_L
argument_list|,
name|DMA_LO
argument_list|(
name|p_hwfn
operator|->
name|p_sb_attn
operator|->
name|sb_phys
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_ATTN_MSG_ADDR_H
argument_list|,
name|DMA_HI
argument_list|(
name|p_hwfn
operator|->
name|p_sb_attn
operator|->
name|sb_phys
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_sb_attn_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|void
modifier|*
name|sb_virt_addr
parameter_list|,
name|dma_addr_t
name|sb_phy_addr
parameter_list|)
block|{
name|struct
name|ecore_sb_attn_info
modifier|*
name|sb_info
init|=
name|p_hwfn
operator|->
name|p_sb_attn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|sb_info
operator|->
name|sb_attn
operator|=
name|sb_virt_addr
expr_stmt|;
name|sb_info
operator|->
name|sb_phys
operator|=
name|sb_phy_addr
expr_stmt|;
comment|/* Set the pointer to the AEU descriptors */
name|sb_info
operator|->
name|p_aeu_desc
operator|=
name|aeu_descs
expr_stmt|;
comment|/* Calculate Parity Masks */
name|OSAL_MEMSET
argument_list|(
name|sb_info
operator|->
name|parity_mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|NUM_ATTN_REGS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ATTN_REGS
condition|;
name|i
operator|++
control|)
block|{
comment|/* j is array index, k is bit index */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|aeu_invert_reg_bit
modifier|*
name|p_aeu
decl_stmt|;
name|p_aeu
operator|=
operator|&
name|aeu_descs
index|[
name|i
index|]
operator|.
name|bits
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ecore_int_is_parity_flag
argument_list|(
name|p_hwfn
argument_list|,
name|p_aeu
argument_list|)
condition|)
name|sb_info
operator|->
name|parity_mask
index|[
name|i
index|]
operator||=
literal|1
operator|<<
name|k
expr_stmt|;
name|k
operator|+=
name|ATTENTION_LENGTH
argument_list|(
name|p_aeu
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"Attn Mask [Reg %d]: 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|sb_info
operator|->
name|parity_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Set the address of cleanup for the mcp attention */
name|sb_info
operator|->
name|mfw_attn_addr
operator|=
operator|(
name|p_hwfn
operator|->
name|rel_pf_id
operator|<<
literal|3
operator|)
operator|+
name|MISC_REG_AEU_GENERAL_ATTN_0
expr_stmt|;
name|ecore_int_sb_attn_setup
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_int_sb_attn_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_dev
modifier|*
name|p_dev
init|=
name|p_hwfn
operator|->
name|p_dev
decl_stmt|;
name|struct
name|ecore_sb_attn_info
modifier|*
name|p_sb
decl_stmt|;
name|dma_addr_t
name|p_phys
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|p_virt
decl_stmt|;
comment|/* SB struct */
name|p_sb
operator|=
name|OSAL_ALLOC
argument_list|(
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sb
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `struct ecore_sb_attn_info'\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* SB ring  */
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_dev
argument_list|,
operator|&
name|p_phys
argument_list|,
name|SB_ATTN_ALIGNED_SIZE
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate status block (attentions)\n"
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_dev
argument_list|,
name|p_sb
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* Attention setup */
name|p_hwfn
operator|->
name|p_sb_attn
operator|=
name|p_sb
expr_stmt|;
name|ecore_int_sb_attn_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_virt
argument_list|,
name|p_phys
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* coalescing timeout = timeset<< (timer_res + 1) */
end_comment

begin_define
define|#
directive|define
name|ECORE_CAU_DEF_RX_USECS
value|24
end_define

begin_define
define|#
directive|define
name|ECORE_CAU_DEF_TX_USECS
value|48
end_define

begin_function
name|void
name|ecore_init_cau_sb_entry
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|cau_sb_entry
modifier|*
name|p_sb_entry
parameter_list|,
name|u8
name|pf_id
parameter_list|,
name|u16
name|vf_number
parameter_list|,
name|u8
name|vf_valid
parameter_list|)
block|{
name|struct
name|ecore_dev
modifier|*
name|p_dev
init|=
name|p_hwfn
operator|->
name|p_dev
decl_stmt|;
name|u32
name|cau_state
decl_stmt|;
name|u8
name|timer_res
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_sb_entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_sb_entry
argument_list|)
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|params
argument_list|,
name|CAU_SB_ENTRY_PF_NUMBER
argument_list|,
name|pf_id
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|params
argument_list|,
name|CAU_SB_ENTRY_VF_NUMBER
argument_list|,
name|vf_number
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|params
argument_list|,
name|CAU_SB_ENTRY_VF_VALID
argument_list|,
name|vf_valid
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|params
argument_list|,
name|CAU_SB_ENTRY_SB_TIMESET0
argument_list|,
literal|0x7F
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|params
argument_list|,
name|CAU_SB_ENTRY_SB_TIMESET1
argument_list|,
literal|0x7F
argument_list|)
expr_stmt|;
name|cau_state
operator|=
name|CAU_HC_DISABLE_STATE
expr_stmt|;
if|if
condition|(
name|p_dev
operator|->
name|int_coalescing_mode
operator|==
name|ECORE_COAL_MODE_ENABLE
condition|)
block|{
name|cau_state
operator|=
name|CAU_HC_ENABLE_STATE
expr_stmt|;
if|if
condition|(
operator|!
name|p_dev
operator|->
name|rx_coalesce_usecs
condition|)
name|p_dev
operator|->
name|rx_coalesce_usecs
operator|=
name|ECORE_CAU_DEF_RX_USECS
expr_stmt|;
if|if
condition|(
operator|!
name|p_dev
operator|->
name|tx_coalesce_usecs
condition|)
name|p_dev
operator|->
name|tx_coalesce_usecs
operator|=
name|ECORE_CAU_DEF_TX_USECS
expr_stmt|;
block|}
comment|/* Coalesce = (timeset<< timer-res), timeset is 7bit wide */
if|if
condition|(
name|p_dev
operator|->
name|rx_coalesce_usecs
operator|<=
literal|0x7F
condition|)
name|timer_res
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p_dev
operator|->
name|rx_coalesce_usecs
operator|<=
literal|0xFF
condition|)
name|timer_res
operator|=
literal|1
expr_stmt|;
else|else
name|timer_res
operator|=
literal|2
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|params
argument_list|,
name|CAU_SB_ENTRY_TIMER_RES0
argument_list|,
name|timer_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_dev
operator|->
name|tx_coalesce_usecs
operator|<=
literal|0x7F
condition|)
name|timer_res
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p_dev
operator|->
name|tx_coalesce_usecs
operator|<=
literal|0xFF
condition|)
name|timer_res
operator|=
literal|1
expr_stmt|;
else|else
name|timer_res
operator|=
literal|2
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|params
argument_list|,
name|CAU_SB_ENTRY_TIMER_RES1
argument_list|,
name|timer_res
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|data
argument_list|,
name|CAU_SB_ENTRY_STATE0
argument_list|,
name|cau_state
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_sb_entry
operator|->
name|data
argument_list|,
name|CAU_SB_ENTRY_STATE1
argument_list|,
name|cau_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_ecore_int_cau_conf_pi
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|igu_sb_id
parameter_list|,
name|u32
name|pi_index
parameter_list|,
name|enum
name|ecore_coalescing_fsm
name|coalescing_fsm
parameter_list|,
name|u8
name|timeset
parameter_list|)
block|{
name|struct
name|cau_pi_entry
name|pi_entry
decl_stmt|;
name|u32
name|sb_offset
decl_stmt|,
name|pi_offset
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return;
comment|/* @@@TBD MichalK- VF CAU... */
name|sb_offset
operator|=
name|igu_sb_id
operator|*
name|PIS_PER_SB_E4
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|pi_entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cau_pi_entry
argument_list|)
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|pi_entry
operator|.
name|prod
argument_list|,
name|CAU_PI_ENTRY_PI_TIMESET
argument_list|,
name|timeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|coalescing_fsm
operator|==
name|ECORE_COAL_RX_STATE_MACHINE
condition|)
name|SET_FIELD
argument_list|(
name|pi_entry
operator|.
name|prod
argument_list|,
name|CAU_PI_ENTRY_FSM_SEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|SET_FIELD
argument_list|(
name|pi_entry
operator|.
name|prod
argument_list|,
name|CAU_PI_ENTRY_FSM_SEL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pi_offset
operator|=
name|sb_offset
operator|+
name|pi_index
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|hw_init_done
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CAU_REG_PI_MEMORY
operator|+
name|pi_offset
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
operator|&
operator|(
name|pi_entry
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|CAU_REG_PI_MEMORY_RT_OFFSET
operator|+
name|pi_offset
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
operator|&
operator|(
name|pi_entry
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_int_cau_conf_pi
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_sb_info
modifier|*
name|p_sb
parameter_list|,
name|u32
name|pi_index
parameter_list|,
name|enum
name|ecore_coalescing_fsm
name|coalescing_fsm
parameter_list|,
name|u8
name|timeset
parameter_list|)
block|{
name|_ecore_int_cau_conf_pi
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_sb
operator|->
name|igu_sb_id
argument_list|,
name|pi_index
argument_list|,
name|coalescing_fsm
argument_list|,
name|timeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_int_cau_conf_sb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|dma_addr_t
name|sb_phys
parameter_list|,
name|u16
name|igu_sb_id
parameter_list|,
name|u16
name|vf_number
parameter_list|,
name|u8
name|vf_valid
parameter_list|)
block|{
name|struct
name|cau_sb_entry
name|sb_entry
decl_stmt|;
name|ecore_init_cau_sb_entry
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|sb_entry
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|,
name|vf_number
argument_list|,
name|vf_valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|hw_init_done
condition|)
block|{
comment|/* Wide-bus, initialize via DMAE */
name|u64
name|phys_addr
init|=
operator|(
name|u64
operator|)
name|sb_phys
decl_stmt|;
name|ecore_dmae_host2grc
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
operator|&
name|phys_addr
argument_list|,
name|CAU_REG_SB_ADDR_MEMORY
operator|+
name|igu_sb_id
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_dmae_host2grc
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
operator|&
name|sb_entry
argument_list|,
name|CAU_REG_SB_VAR_MEMORY
operator|+
name|igu_sb_id
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize Status Block Address */
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|CAU_REG_SB_ADDR_MEMORY_RT_OFFSET
operator|+
name|igu_sb_id
operator|*
literal|2
argument_list|,
name|sb_phys
argument_list|)
expr_stmt|;
name|STORE_RT_REG_AGG
argument_list|(
name|p_hwfn
argument_list|,
name|CAU_REG_SB_VAR_MEMORY_RT_OFFSET
operator|+
name|igu_sb_id
operator|*
literal|2
argument_list|,
name|sb_entry
argument_list|)
expr_stmt|;
block|}
comment|/* Configure pi coalescing if set */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|int_coalescing_mode
operator|==
name|ECORE_COAL_MODE_ENABLE
condition|)
block|{
comment|/* eth will open queues for all tcs, so configure all of them 		 * properly, rather than just the active ones 		 */
name|u8
name|num_tc
init|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|num_hw_tc
decl_stmt|;
name|u8
name|timeset
decl_stmt|,
name|timer_res
decl_stmt|;
name|u8
name|i
decl_stmt|;
comment|/* timeset = (coalesce>> timer-res), timeset is 7bit wide */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|rx_coalesce_usecs
operator|<=
literal|0x7F
condition|)
name|timer_res
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|rx_coalesce_usecs
operator|<=
literal|0xFF
condition|)
name|timer_res
operator|=
literal|1
expr_stmt|;
else|else
name|timer_res
operator|=
literal|2
expr_stmt|;
name|timeset
operator|=
call|(
name|u8
call|)
argument_list|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|rx_coalesce_usecs
operator|>>
name|timer_res
argument_list|)
expr_stmt|;
name|_ecore_int_cau_conf_pi
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|igu_sb_id
argument_list|,
name|RX_PI
argument_list|,
name|ECORE_COAL_RX_STATE_MACHINE
argument_list|,
name|timeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|tx_coalesce_usecs
operator|<=
literal|0x7F
condition|)
name|timer_res
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|tx_coalesce_usecs
operator|<=
literal|0xFF
condition|)
name|timer_res
operator|=
literal|1
expr_stmt|;
else|else
name|timer_res
operator|=
literal|2
expr_stmt|;
name|timeset
operator|=
call|(
name|u8
call|)
argument_list|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|tx_coalesce_usecs
operator|>>
name|timer_res
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tc
condition|;
name|i
operator|++
control|)
block|{
name|_ecore_int_cau_conf_pi
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|igu_sb_id
argument_list|,
name|TX_PI
argument_list|(
name|i
argument_list|)
argument_list|,
name|ECORE_COAL_TX_STATE_MACHINE
argument_list|,
name|timeset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ecore_int_sb_setup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_sb_info
modifier|*
name|sb_info
parameter_list|)
block|{
comment|/* zero status block and ack counter */
name|sb_info
operator|->
name|sb_ack
operator|=
literal|0
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|sb_info
operator|->
name|sb_virt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb_info
operator|->
name|sb_virt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|ecore_int_cau_conf_sb
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|sb_info
operator|->
name|sb_phys
argument_list|,
name|sb_info
operator|->
name|igu_sb_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ecore_igu_block
modifier|*
name|ecore_get_igu_free_sb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|bool
name|b_is_pf
parameter_list|)
block|{
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|u16
name|igu_id
decl_stmt|;
for|for
control|(
name|igu_id
operator|=
literal|0
init|;
name|igu_id
operator|<
name|ECORE_MAPPING_MEMORY_SIZE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|;
name|igu_id
operator|++
control|)
block|{
name|p_block
operator|=
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
operator|->
name|entry
index|[
name|igu_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_VALID
operator|)
operator|||
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_FREE
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_PF
operator|)
operator|==
name|b_is_pf
condition|)
return|return
name|p_block
return|;
block|}
return|return
name|OSAL_NULL
return|;
block|}
end_function

begin_function
specifier|static
name|u16
name|ecore_get_pf_igu_sb_id
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|vector_id
parameter_list|)
block|{
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|u16
name|igu_id
decl_stmt|;
for|for
control|(
name|igu_id
operator|=
literal|0
init|;
name|igu_id
operator|<
name|ECORE_MAPPING_MEMORY_SIZE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|;
name|igu_id
operator|++
control|)
block|{
name|p_block
operator|=
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
operator|->
name|entry
index|[
name|igu_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_VALID
operator|)
operator|||
operator|!
name|p_block
operator|->
name|is_pf
operator|||
name|p_block
operator|->
name|vector_number
operator|!=
name|vector_id
condition|)
continue|continue;
return|return
name|igu_id
return|;
block|}
return|return
name|ECORE_SB_INVALID_IDX
return|;
block|}
end_function

begin_function
name|u16
name|ecore_get_igu_sb_id
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|sb_id
parameter_list|)
block|{
name|u16
name|igu_sb_id
decl_stmt|;
comment|/* Assuming continuous set of IGU SBs dedicated for given PF */
if|if
condition|(
name|sb_id
operator|==
name|ECORE_SP_SB_ID
condition|)
name|igu_sb_id
operator|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
operator|->
name|igu_dsb_id
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_PF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|igu_sb_id
operator|=
name|ecore_get_pf_igu_sb_id
argument_list|(
name|p_hwfn
argument_list|,
name|sb_id
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|igu_sb_id
operator|=
name|ecore_vf_get_igu_sb_id
argument_list|(
name|p_hwfn
argument_list|,
name|sb_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|igu_sb_id
operator|==
name|ECORE_SB_INVALID_IDX
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Slowpath SB vector %04x doesn't exist\n"
argument_list|,
name|sb_id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sb_id
operator|==
name|ECORE_SP_SB_ID
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"Slowpath SB index in IGU is 0x%04x\n"
argument_list|,
name|igu_sb_id
argument_list|)
expr_stmt|;
else|else
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"SB [%04x]<--> IGU SB [%04x]\n"
argument_list|,
name|sb_id
argument_list|,
name|igu_sb_id
argument_list|)
expr_stmt|;
return|return
name|igu_sb_id
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_sb_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_sb_info
modifier|*
name|sb_info
parameter_list|,
name|void
modifier|*
name|sb_virt_addr
parameter_list|,
name|dma_addr_t
name|sb_phy_addr
parameter_list|,
name|u16
name|sb_id
parameter_list|)
block|{
name|sb_info
operator|->
name|sb_virt
operator|=
name|sb_virt_addr
expr_stmt|;
name|sb_info
operator|->
name|sb_phys
operator|=
name|sb_phy_addr
expr_stmt|;
name|sb_info
operator|->
name|igu_sb_id
operator|=
name|ecore_get_igu_sb_id
argument_list|(
name|p_hwfn
argument_list|,
name|sb_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb_info
operator|->
name|igu_sb_id
operator|==
name|ECORE_SB_INVALID_IDX
condition|)
return|return
name|ECORE_INVAL
return|;
comment|/* Let the igu info reference the client's SB info */
if|if
condition|(
name|sb_id
operator|!=
name|ECORE_SP_SB_ID
condition|)
block|{
if|if
condition|(
name|IS_PF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|struct
name|ecore_igu_info
modifier|*
name|p_info
decl_stmt|;
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|p_info
operator|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
expr_stmt|;
name|p_block
operator|=
operator|&
name|p_info
operator|->
name|entry
index|[
name|sb_info
operator|->
name|igu_sb_id
index|]
expr_stmt|;
name|p_block
operator|->
name|sb_info
operator|=
name|sb_info
expr_stmt|;
name|p_block
operator|->
name|status
operator|&=
operator|~
name|ECORE_IGU_STATUS_FREE
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|free_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|ecore_vf_set_sb_info
argument_list|(
name|p_hwfn
argument_list|,
name|sb_id
argument_list|,
name|sb_info
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ECORE_CONFIG_DIRECT_HWFN
name|sb_info
operator|->
name|p_hwfn
operator|=
name|p_hwfn
expr_stmt|;
endif|#
directive|endif
name|sb_info
operator|->
name|p_dev
operator|=
name|p_hwfn
operator|->
name|p_dev
expr_stmt|;
comment|/* The igu address will hold the absolute address that needs to be 	 * written to for a specific status block 	 */
if|if
condition|(
name|IS_PF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|sb_info
operator|->
name|igu_addr
operator|=
operator|(
name|u8
name|OSAL_IOMEM
operator|*
operator|)
name|p_hwfn
operator|->
name|regview
operator|+
name|GTT_BAR0_MAP_REG_IGU_CMD
operator|+
operator|(
name|sb_info
operator|->
name|igu_sb_id
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sb_info
operator|->
name|igu_addr
operator|=
operator|(
name|u8
name|OSAL_IOMEM
operator|*
operator|)
name|p_hwfn
operator|->
name|regview
operator|+
name|PXP_VF_BAR0_START_IGU
operator|+
operator|(
operator|(
name|IGU_CMD_INT_ACK_BASE
operator|+
name|sb_info
operator|->
name|igu_sb_id
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|sb_info
operator|->
name|flags
operator||=
name|ECORE_SB_INFO_INIT
expr_stmt|;
name|ecore_int_sb_setup
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|sb_info
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_sb_release
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_sb_info
modifier|*
name|sb_info
parameter_list|,
name|u16
name|sb_id
parameter_list|)
block|{
name|struct
name|ecore_igu_info
modifier|*
name|p_info
decl_stmt|;
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
if|if
condition|(
name|sb_info
operator|==
name|OSAL_NULL
condition|)
return|return
name|ECORE_SUCCESS
return|;
comment|/* zero status block and ack counter */
name|sb_info
operator|->
name|sb_ack
operator|=
literal|0
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|sb_info
operator|->
name|sb_virt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb_info
operator|->
name|sb_virt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_vf_set_sb_info
argument_list|(
name|p_hwfn
argument_list|,
name|sb_id
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
name|p_info
operator|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
expr_stmt|;
name|p_block
operator|=
operator|&
name|p_info
operator|->
name|entry
index|[
name|sb_info
operator|->
name|igu_sb_id
index|]
expr_stmt|;
comment|/* Vector 0 is reserved to Default SB */
if|if
condition|(
name|p_block
operator|->
name|vector_number
operator|==
literal|0
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Do Not free sp sb using this function"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Lose reference to client's SB info, and fix counters */
name|p_block
operator|->
name|sb_info
operator|=
name|OSAL_NULL
expr_stmt|;
name|p_block
operator|->
name|status
operator||=
name|ECORE_IGU_STATUS_FREE
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|free_cnt
operator|++
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_sp_sb_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_sb_sp_info
modifier|*
name|p_sb
init|=
name|p_hwfn
operator|->
name|p_sp_sb
decl_stmt|;
if|if
condition|(
operator|!
name|p_sb
condition|)
return|return;
if|if
condition|(
name|p_sb
operator|->
name|sb_info
operator|.
name|sb_virt
condition|)
block|{
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_sb
operator|->
name|sb_info
operator|.
name|sb_virt
argument_list|,
name|p_sb
operator|->
name|sb_info
operator|.
name|sb_phys
argument_list|,
name|SB_ALIGNED_SIZE
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_sb
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_sp_sb
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_int_sp_sb_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_sb_sp_info
modifier|*
name|p_sb
decl_stmt|;
name|dma_addr_t
name|p_phys
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|p_virt
decl_stmt|;
comment|/* SB struct */
name|p_sb
operator|=
name|OSAL_ALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sb
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `struct ecore_sb_info'\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* SB ring  */
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_phys
argument_list|,
name|SB_ALIGNED_SIZE
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate status block\n"
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_sb
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* Status Block setup */
name|p_hwfn
operator|->
name|p_sp_sb
operator|=
name|p_sb
expr_stmt|;
name|ecore_int_sb_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|p_sb
operator|->
name|sb_info
argument_list|,
name|p_virt
argument_list|,
name|p_phys
argument_list|,
name|ECORE_SP_SB_ID
argument_list|)
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_sb
operator|->
name|pi_info_arr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p_sb
operator|->
name|pi_info_arr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_register_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|ecore_int_comp_cb_t
name|comp_cb
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|u8
modifier|*
name|sb_idx
parameter_list|,
name|__le16
modifier|*
modifier|*
name|p_fw_cons
parameter_list|)
block|{
name|struct
name|ecore_sb_sp_info
modifier|*
name|p_sp_sb
init|=
name|p_hwfn
operator|->
name|p_sp_sb
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_NOMEM
decl_stmt|;
name|u8
name|pi
decl_stmt|;
comment|/* Look for a free index */
for|for
control|(
name|pi
operator|=
literal|0
init|;
name|pi
operator|<
name|OSAL_ARRAY_SIZE
argument_list|(
name|p_sp_sb
operator|->
name|pi_info_arr
argument_list|)
condition|;
name|pi
operator|++
control|)
block|{
if|if
condition|(
name|p_sp_sb
operator|->
name|pi_info_arr
index|[
name|pi
index|]
operator|.
name|comp_cb
operator|!=
name|OSAL_NULL
condition|)
continue|continue;
name|p_sp_sb
operator|->
name|pi_info_arr
index|[
name|pi
index|]
operator|.
name|comp_cb
operator|=
name|comp_cb
expr_stmt|;
name|p_sp_sb
operator|->
name|pi_info_arr
index|[
name|pi
index|]
operator|.
name|cookie
operator|=
name|cookie
expr_stmt|;
operator|*
name|sb_idx
operator|=
name|pi
expr_stmt|;
operator|*
name|p_fw_cons
operator|=
operator|&
name|p_sp_sb
operator|->
name|sb_info
operator|.
name|sb_virt
operator|->
name|pi_array
index|[
name|pi
index|]
expr_stmt|;
name|rc
operator|=
name|ECORE_SUCCESS
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_unregister_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|pi
parameter_list|)
block|{
name|struct
name|ecore_sb_sp_info
modifier|*
name|p_sp_sb
init|=
name|p_hwfn
operator|->
name|p_sp_sb
decl_stmt|;
if|if
condition|(
name|p_sp_sb
operator|->
name|pi_info_arr
index|[
name|pi
index|]
operator|.
name|comp_cb
operator|==
name|OSAL_NULL
condition|)
return|return
name|ECORE_NOMEM
return|;
name|p_sp_sb
operator|->
name|pi_info_arr
index|[
name|pi
index|]
operator|.
name|comp_cb
operator|=
name|OSAL_NULL
expr_stmt|;
name|p_sp_sb
operator|->
name|pi_info_arr
index|[
name|pi
index|]
operator|.
name|cookie
operator|=
name|OSAL_NULL
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|u16
name|ecore_int_get_sp_sb_id
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
return|return
name|p_hwfn
operator|->
name|p_sp_sb
operator|->
name|sb_info
operator|.
name|igu_sb_id
return|;
block|}
end_function

begin_function
name|void
name|ecore_int_igu_enable_int
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_int_mode
name|int_mode
parameter_list|)
block|{
name|u32
name|igu_pf_conf
init|=
name|IGU_PF_CONF_FUNC_EN
operator||
name|IGU_PF_CONF_ATTN_BIT_EN
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"FPGA - don't enable ATTN generation in IGU\n"
argument_list|)
expr_stmt|;
name|igu_pf_conf
operator|&=
operator|~
name|IGU_PF_CONF_ATTN_BIT_EN
expr_stmt|;
block|}
endif|#
directive|endif
name|p_hwfn
operator|->
name|p_dev
operator|->
name|int_mode
operator|=
name|int_mode
expr_stmt|;
switch|switch
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|int_mode
condition|)
block|{
case|case
name|ECORE_INT_MODE_INTA
case|:
name|igu_pf_conf
operator||=
name|IGU_PF_CONF_INT_LINE_EN
expr_stmt|;
name|igu_pf_conf
operator||=
name|IGU_PF_CONF_SINGLE_ISR_EN
expr_stmt|;
break|break;
case|case
name|ECORE_INT_MODE_MSI
case|:
name|igu_pf_conf
operator||=
name|IGU_PF_CONF_MSI_MSIX_EN
expr_stmt|;
name|igu_pf_conf
operator||=
name|IGU_PF_CONF_SINGLE_ISR_EN
expr_stmt|;
break|break;
case|case
name|ECORE_INT_MODE_MSIX
case|:
name|igu_pf_conf
operator||=
name|IGU_PF_CONF_MSI_MSIX_EN
expr_stmt|;
break|break;
case|case
name|ECORE_INT_MODE_POLL
case|:
break|break;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|,
name|igu_pf_conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_igu_enable_attn
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"FPGA - Don't enable Attentions in IGU and MISC\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Configure AEU signal change to produce attentions */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_ATTENTION_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_LEADING_EDGE_LATCH
argument_list|,
literal|0xfff
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_TRAILING_EDGE_LATCH
argument_list|,
literal|0xfff
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_ATTENTION_ENABLE
argument_list|,
literal|0xfff
argument_list|)
expr_stmt|;
comment|/* Flush the writes to IGU */
name|OSAL_MMIOWB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
comment|/* Unmask AEU signals toward IGU */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_AEU_MASK_ATTN_IGU
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_igu_enable
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_int_mode
name|int_mode
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
comment|/* @@@tmp - Starting with MFW 8.2.1.0 we've started hitting AVS stop 	 * attentions. Since we're waiting for BRCM answer regarding this 	 * attention, in the meanwhile we simply mask it. 	 */
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_AEU_ENABLE4_IGU_OUT_0
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0x800
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_AEU_ENABLE4_IGU_OUT_0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ecore_int_igu_enable_attn
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int_mode
operator|!=
name|ECORE_INT_MODE_INTA
operator|)
operator|||
name|IS_LEAD_HWFN
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|rc
operator|=
name|OSAL_SLOWPATH_IRQ_REQ
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Slowpath IRQ request failed\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NORESOURCES
return|;
block|}
name|p_hwfn
operator|->
name|b_int_requested
operator|=
name|true
expr_stmt|;
block|}
comment|/* Enable interrupt Generation */
name|ecore_int_igu_enable_int
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|int_mode
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|b_int_enabled
operator|=
literal|1
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_int_igu_disable_int
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|p_hwfn
operator|->
name|b_int_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IGU_CLEANUP_SLEEP_LENGTH
value|(1000)
end_define

begin_function
specifier|static
name|void
name|ecore_int_igu_cleanup_sb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|igu_sb_id
parameter_list|,
name|bool
name|cleanup_set
parameter_list|,
name|u16
name|opaque_fid
parameter_list|)
block|{
name|u32
name|cmd_ctrl
init|=
literal|0
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|,
name|sb_bit
init|=
literal|0
decl_stmt|,
name|sb_bit_addr
init|=
literal|0
decl_stmt|,
name|data
init|=
literal|0
decl_stmt|;
name|u32
name|pxp_addr
init|=
name|IGU_CMD_INT_ACK_BASE
operator|+
name|igu_sb_id
decl_stmt|;
name|u32
name|sleep_cnt
init|=
name|IGU_CLEANUP_SLEEP_LENGTH
decl_stmt|;
name|u8
name|type
init|=
literal|0
decl_stmt|;
comment|/* FIXME MichalS type??? */
name|OSAL_BUILD_BUG_ON
argument_list|(
operator|(
name|IGU_REG_CLEANUP_STATUS_4
operator|-
name|IGU_REG_CLEANUP_STATUS_0
operator|)
operator|!=
literal|0x200
argument_list|)
expr_stmt|;
comment|/* USE Control Command Register to perform cleanup. There is an 	 * option to do this using IGU bar, but then it can't be used for VFs. 	 */
comment|/* Set the data field */
name|SET_FIELD
argument_list|(
name|data
argument_list|,
name|IGU_CLEANUP_CLEANUP_SET
argument_list|,
name|cleanup_set
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|data
argument_list|,
name|IGU_CLEANUP_CLEANUP_TYPE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|data
argument_list|,
name|IGU_CLEANUP_COMMAND_TYPE
argument_list|,
name|IGU_COMMAND_TYPE_SET
argument_list|)
expr_stmt|;
comment|/* Set the control register */
name|SET_FIELD
argument_list|(
name|cmd_ctrl
argument_list|,
name|IGU_CTRL_REG_PXP_ADDR
argument_list|,
name|pxp_addr
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cmd_ctrl
argument_list|,
name|IGU_CTRL_REG_FID
argument_list|,
name|opaque_fid
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cmd_ctrl
argument_list|,
name|IGU_CTRL_REG_TYPE
argument_list|,
name|IGU_CTRL_CMD_TYPE_WR
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_COMMAND_REG_32LSB_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|OSAL_BARRIER
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_COMMAND_REG_CTRL
argument_list|,
name|cmd_ctrl
argument_list|)
expr_stmt|;
comment|/* Flush the write to IGU */
name|OSAL_MMIOWB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
comment|/* calculate where to read the status bit from */
name|sb_bit
operator|=
literal|1
operator|<<
operator|(
name|igu_sb_id
operator|%
literal|32
operator|)
expr_stmt|;
name|sb_bit_addr
operator|=
name|igu_sb_id
operator|/
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
expr_stmt|;
name|sb_bit_addr
operator|+=
name|IGU_REG_CLEANUP_STATUS_0
operator|+
operator|(
literal|0x80
operator|*
name|type
operator|)
expr_stmt|;
comment|/* Now wait for the command to complete */
while|while
condition|(
operator|--
name|sleep_cnt
condition|)
block|{
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|sb_bit_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|sb_bit
operator|)
operator|==
operator|(
name|cleanup_set
condition|?
name|sb_bit
else|:
literal|0
operator|)
condition|)
break|break;
name|OSAL_MSLEEP
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sleep_cnt
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Timeout waiting for clear status 0x%08x [for sb %d]\n"
argument_list|,
name|val
argument_list|,
name|igu_sb_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_int_igu_init_pure_rt_single
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|igu_sb_id
parameter_list|,
name|u16
name|opaque
parameter_list|,
name|bool
name|b_set
parameter_list|)
block|{
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|int
name|pi
decl_stmt|,
name|i
decl_stmt|;
name|p_block
operator|=
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
operator|->
name|entry
index|[
name|igu_sb_id
index|]
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"Cleaning SB [%04x]: func_id= %d is_pf = %d vector_num = 0x%0x\n"
argument_list|,
name|igu_sb_id
argument_list|,
name|p_block
operator|->
name|function_id
argument_list|,
name|p_block
operator|->
name|is_pf
argument_list|,
name|p_block
operator|->
name|vector_number
argument_list|)
expr_stmt|;
comment|/* Set */
if|if
condition|(
name|b_set
condition|)
name|ecore_int_igu_cleanup_sb
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|igu_sb_id
argument_list|,
literal|1
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
comment|/* Clear */
name|ecore_int_igu_cleanup_sb
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|igu_sb_id
argument_list|,
literal|0
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
comment|/* Wait for the IGU SB to cleanup */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGU_CLEANUP_SLEEP_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_WRITE_DONE_PENDING
operator|+
operator|(
operator|(
name|igu_sb_id
operator|/
literal|32
operator|)
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|igu_sb_id
operator|%
literal|32
operator|)
operator|)
condition|)
name|OSAL_UDELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|IGU_CLEANUP_SLEEP_LENGTH
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed SB[0x%08x] still appearing in WRITE_DONE_PENDING\n"
argument_list|,
name|igu_sb_id
argument_list|)
expr_stmt|;
comment|/* Clear the CAU for the SB */
for|for
control|(
name|pi
operator|=
literal|0
init|;
name|pi
operator|<
literal|12
condition|;
name|pi
operator|++
control|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CAU_REG_PI_MEMORY
operator|+
operator|(
name|igu_sb_id
operator|*
literal|12
operator|+
name|pi
operator|)
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_int_igu_init_pure_rt
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|b_set
parameter_list|,
name|bool
name|b_slowpath
parameter_list|)
block|{
name|struct
name|ecore_igu_info
modifier|*
name|p_info
init|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
decl_stmt|;
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|u16
name|igu_sb_id
init|=
literal|0
decl_stmt|;
name|u32
name|val
init|=
literal|0
decl_stmt|;
comment|/* @@@TBD MichalK temporary... should be moved to init-tool... */
name|val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_BLOCK_CONFIGURATION
argument_list|)
expr_stmt|;
name|val
operator||=
name|IGU_REG_BLOCK_CONFIGURATION_VF_CLEANUP_EN
expr_stmt|;
name|val
operator|&=
operator|~
name|IGU_REG_BLOCK_CONFIGURATION_PXP_TPH_INTERFACE_EN
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_BLOCK_CONFIGURATION
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* end temporary */
for|for
control|(
name|igu_sb_id
operator|=
literal|0
init|;
name|igu_sb_id
operator|<
name|ECORE_MAPPING_MEMORY_SIZE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|;
name|igu_sb_id
operator|++
control|)
block|{
name|p_block
operator|=
operator|&
name|p_info
operator|->
name|entry
index|[
name|igu_sb_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_VALID
operator|)
operator|||
operator|!
name|p_block
operator|->
name|is_pf
operator|||
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_DSB
operator|)
condition|)
continue|continue;
name|ecore_int_igu_init_pure_rt_single
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|igu_sb_id
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|opaque_fid
argument_list|,
name|b_set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b_slowpath
condition|)
name|ecore_int_igu_init_pure_rt_single
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_info
operator|->
name|igu_dsb_id
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|opaque_fid
argument_list|,
name|b_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ecore_int_igu_reset_cam
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_igu_info
modifier|*
name|p_info
init|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
decl_stmt|;
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|int
name|pf_sbs
decl_stmt|,
name|vf_sbs
decl_stmt|;
name|u16
name|igu_sb_id
decl_stmt|;
name|u32
name|val
decl_stmt|,
name|rval
decl_stmt|;
if|if
condition|(
operator|!
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_SB
argument_list|)
condition|)
block|{
comment|/* We're using an old MFW - have to prevent any switching 		 * of SBs between PF and VFs as later driver wouldn't be 		 * able to tell which belongs to which. 		 */
name|p_info
operator|->
name|b_allow_pf_vf_change
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the numbers the MFW have provided - 		 * don't forget MFW accounts for the default SB as well. 		 */
name|p_info
operator|->
name|b_allow_pf_vf_change
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|p_info
operator|->
name|usage
operator|.
name|cnt
operator|!=
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_SB
argument_list|)
operator|-
literal|1
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"MFW notifies of 0x%04x PF SBs; IGU indicates of only 0x%04x\n"
argument_list|,
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_SB
argument_list|)
operator|-
literal|1
argument_list|,
name|p_info
operator|->
name|usage
operator|.
name|cnt
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|cnt
operator|=
name|RESC_NUM
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_SB
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* TODO - how do we learn about VF SBs from MFW? */
if|if
condition|(
name|IS_PF_SRIOV
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|u16
name|vfs
init|=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
operator|->
name|total_vfs
decl_stmt|;
if|if
condition|(
name|vfs
operator|!=
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"0x%04x VF SBs in IGU CAM != PCI configuration 0x%04x\n"
argument_list|,
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
argument_list|,
name|vfs
argument_list|)
expr_stmt|;
comment|/* At this point we know how many SBs we have totally 			 * in IGU + number of PF SBs. So we can validate that 			 * we'd have sufficient for VF. 			 */
if|if
condition|(
name|vfs
operator|>
name|p_info
operator|->
name|usage
operator|.
name|free_cnt
operator|+
name|p_info
operator|->
name|usage
operator|.
name|free_cnt_iov
operator|-
name|p_info
operator|->
name|usage
operator|.
name|cnt
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Not enough SBs for VFs - 0x%04x SBs, from which %04x PFs and %04x are required\n"
argument_list|,
name|p_info
operator|->
name|usage
operator|.
name|free_cnt
operator|+
name|p_info
operator|->
name|usage
operator|.
name|free_cnt_iov
argument_list|,
name|p_info
operator|->
name|usage
operator|.
name|cnt
argument_list|,
name|vfs
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Currently cap the number of VFs SBs by the 			 * number of VFs. 			 */
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
operator|=
name|vfs
expr_stmt|;
block|}
block|}
comment|/* Mark all SBs as free, now in the right PF/VFs division */
name|p_info
operator|->
name|usage
operator|.
name|free_cnt
operator|=
name|p_info
operator|->
name|usage
operator|.
name|cnt
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|free_cnt_iov
operator|=
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|orig
operator|=
name|p_info
operator|->
name|usage
operator|.
name|cnt
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|iov_orig
operator|=
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
expr_stmt|;
comment|/* We now proceed to re-configure the IGU cam to reflect the initial 	 * configuration. We can start with the Default SB. 	 */
name|pf_sbs
operator|=
name|p_info
operator|->
name|usage
operator|.
name|cnt
expr_stmt|;
name|vf_sbs
operator|=
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
expr_stmt|;
for|for
control|(
name|igu_sb_id
operator|=
name|p_info
operator|->
name|igu_dsb_id
init|;
name|igu_sb_id
operator|<
name|ECORE_MAPPING_MEMORY_SIZE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|;
name|igu_sb_id
operator|++
control|)
block|{
name|p_block
operator|=
operator|&
name|p_info
operator|->
name|entry
index|[
name|igu_sb_id
index|]
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_VALID
operator|)
condition|)
continue|continue;
if|if
condition|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_DSB
condition|)
block|{
name|p_block
operator|->
name|function_id
operator|=
name|p_hwfn
operator|->
name|rel_pf_id
expr_stmt|;
name|p_block
operator|->
name|is_pf
operator|=
literal|1
expr_stmt|;
name|p_block
operator|->
name|vector_number
operator|=
literal|0
expr_stmt|;
name|p_block
operator|->
name|status
operator|=
name|ECORE_IGU_STATUS_VALID
operator||
name|ECORE_IGU_STATUS_PF
operator||
name|ECORE_IGU_STATUS_DSB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pf_sbs
condition|)
block|{
name|pf_sbs
operator|--
expr_stmt|;
name|p_block
operator|->
name|function_id
operator|=
name|p_hwfn
operator|->
name|rel_pf_id
expr_stmt|;
name|p_block
operator|->
name|is_pf
operator|=
literal|1
expr_stmt|;
name|p_block
operator|->
name|vector_number
operator|=
name|p_info
operator|->
name|usage
operator|.
name|cnt
operator|-
name|pf_sbs
expr_stmt|;
name|p_block
operator|->
name|status
operator|=
name|ECORE_IGU_STATUS_VALID
operator||
name|ECORE_IGU_STATUS_PF
operator||
name|ECORE_IGU_STATUS_FREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vf_sbs
condition|)
block|{
name|p_block
operator|->
name|function_id
operator|=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
operator|->
name|first_vf_in_pf
operator|+
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
operator|-
name|vf_sbs
expr_stmt|;
name|p_block
operator|->
name|is_pf
operator|=
literal|0
expr_stmt|;
name|p_block
operator|->
name|vector_number
operator|=
literal|0
expr_stmt|;
name|p_block
operator|->
name|status
operator|=
name|ECORE_IGU_STATUS_VALID
operator||
name|ECORE_IGU_STATUS_FREE
expr_stmt|;
name|vf_sbs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|p_block
operator|->
name|function_id
operator|=
literal|0
expr_stmt|;
name|p_block
operator|->
name|is_pf
operator|=
literal|0
expr_stmt|;
name|p_block
operator|->
name|vector_number
operator|=
literal|0
expr_stmt|;
block|}
name|SET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_FUNCTION_NUMBER
argument_list|,
name|p_block
operator|->
name|function_id
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_PF_VALID
argument_list|,
name|p_block
operator|->
name|is_pf
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_VECTOR_NUMBER
argument_list|,
name|p_block
operator|->
name|vector_number
argument_list|)
expr_stmt|;
comment|/* VF entries would be enabled when VF is initializaed */
name|SET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_VALID
argument_list|,
name|p_block
operator|->
name|is_pf
argument_list|)
expr_stmt|;
name|rval
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_MAPPING_MEMORY
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|igu_sb_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|val
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_MAPPING_MEMORY
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|igu_sb_id
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"IGU reset: [SB 0x%04x] func_id = %d is_pf = %d vector_num = 0x%x [%08x -> %08x]\n"
argument_list|,
name|igu_sb_id
argument_list|,
name|p_block
operator|->
name|function_id
argument_list|,
name|p_block
operator|->
name|is_pf
argument_list|,
name|p_block
operator|->
name|vector_number
argument_list|,
name|rval
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ecore_int_igu_reset_cam_default
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_sb_cnt_info
modifier|*
name|p_cnt
init|=
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
operator|->
name|usage
decl_stmt|;
comment|/* Return all the usage indications to default prior to the reset; 	 * The reset expects the !orig to reflect the initial status of the 	 * SBs, and would re-calculate the originals based on those. 	 */
name|p_cnt
operator|->
name|cnt
operator|=
name|p_cnt
operator|->
name|orig
expr_stmt|;
name|p_cnt
operator|->
name|free_cnt
operator|=
name|p_cnt
operator|->
name|orig
expr_stmt|;
name|p_cnt
operator|->
name|iov_cnt
operator|=
name|p_cnt
operator|->
name|iov_orig
expr_stmt|;
name|p_cnt
operator|->
name|free_cnt_iov
operator|=
name|p_cnt
operator|->
name|iov_orig
expr_stmt|;
name|p_cnt
operator|->
name|orig
operator|=
literal|0
expr_stmt|;
name|p_cnt
operator|->
name|iov_orig
operator|=
literal|0
expr_stmt|;
comment|/* TODO - we probably need to re-configure the CAU as well... */
return|return
name|ecore_int_igu_reset_cam
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_igu_read_cam_block
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|igu_sb_id
parameter_list|)
block|{
name|u32
name|val
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_MAPPING_MEMORY
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|igu_sb_id
argument_list|)
decl_stmt|;
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|p_block
operator|=
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
operator|->
name|entry
index|[
name|igu_sb_id
index|]
expr_stmt|;
comment|/* Fill the block information */
name|p_block
operator|->
name|function_id
operator|=
name|GET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_FUNCTION_NUMBER
argument_list|)
expr_stmt|;
name|p_block
operator|->
name|is_pf
operator|=
name|GET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_PF_VALID
argument_list|)
expr_stmt|;
name|p_block
operator|->
name|vector_number
operator|=
name|GET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_VECTOR_NUMBER
argument_list|)
expr_stmt|;
name|p_block
operator|->
name|igu_sb_id
operator|=
name|igu_sb_id
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_igu_read_cam
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_igu_info
modifier|*
name|p_igu_info
decl_stmt|;
name|struct
name|ecore_igu_block
modifier|*
name|p_block
decl_stmt|;
name|u32
name|min_vf
init|=
literal|0
decl_stmt|,
name|max_vf
init|=
literal|0
decl_stmt|;
name|u16
name|igu_sb_id
decl_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_igu_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
condition|)
return|return
name|ECORE_NOMEM
return|;
name|p_igu_info
operator|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
expr_stmt|;
comment|/* Distinguish between existent and onn-existent default SB */
name|p_igu_info
operator|->
name|igu_dsb_id
operator|=
name|ECORE_SB_INVALID_IDX
expr_stmt|;
comment|/* Find the range of VF ids whose SB belong to this PF */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
condition|)
block|{
name|struct
name|ecore_hw_sriov_info
modifier|*
name|p_iov
init|=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
decl_stmt|;
name|min_vf
operator|=
name|p_iov
operator|->
name|first_vf_in_pf
expr_stmt|;
name|max_vf
operator|=
name|p_iov
operator|->
name|first_vf_in_pf
operator|+
name|p_iov
operator|->
name|total_vfs
expr_stmt|;
block|}
for|for
control|(
name|igu_sb_id
operator|=
literal|0
init|;
name|igu_sb_id
operator|<
name|ECORE_MAPPING_MEMORY_SIZE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|;
name|igu_sb_id
operator|++
control|)
block|{
comment|/* Read current entry; Notice it might not belong to this PF */
name|ecore_int_igu_read_cam_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|igu_sb_id
argument_list|)
expr_stmt|;
name|p_block
operator|=
operator|&
name|p_igu_info
operator|->
name|entry
index|[
name|igu_sb_id
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p_block
operator|->
name|is_pf
operator|)
operator|&&
operator|(
name|p_block
operator|->
name|function_id
operator|==
name|p_hwfn
operator|->
name|rel_pf_id
operator|)
condition|)
block|{
name|p_block
operator|->
name|status
operator|=
name|ECORE_IGU_STATUS_PF
operator||
name|ECORE_IGU_STATUS_VALID
operator||
name|ECORE_IGU_STATUS_FREE
expr_stmt|;
if|if
condition|(
name|p_igu_info
operator|->
name|igu_dsb_id
operator|!=
name|ECORE_SB_INVALID_IDX
condition|)
name|p_igu_info
operator|->
name|usage
operator|.
name|cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|p_block
operator|->
name|is_pf
operator|)
operator|&&
operator|(
name|p_block
operator|->
name|function_id
operator|>=
name|min_vf
operator|)
operator|&&
operator|(
name|p_block
operator|->
name|function_id
operator|<
name|max_vf
operator|)
condition|)
block|{
comment|/* Available for VFs of this PF */
name|p_block
operator|->
name|status
operator|=
name|ECORE_IGU_STATUS_VALID
operator||
name|ECORE_IGU_STATUS_FREE
expr_stmt|;
if|if
condition|(
name|p_igu_info
operator|->
name|igu_dsb_id
operator|!=
name|ECORE_SB_INVALID_IDX
condition|)
name|p_igu_info
operator|->
name|usage
operator|.
name|iov_cnt
operator|++
expr_stmt|;
block|}
comment|/* Mark the First entry belonging to the PF or its VFs 		 * as the default SB [we'll reset IGU prior to first usage]. 		 */
if|if
condition|(
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_VALID
operator|)
operator|&&
operator|(
name|p_igu_info
operator|->
name|igu_dsb_id
operator|==
name|ECORE_SB_INVALID_IDX
operator|)
condition|)
block|{
name|p_igu_info
operator|->
name|igu_dsb_id
operator|=
name|igu_sb_id
expr_stmt|;
name|p_block
operator|->
name|status
operator||=
name|ECORE_IGU_STATUS_DSB
expr_stmt|;
block|}
comment|/* While this isn't suitable for all clients, limit number 		 * of prints by having each PF print only its entries with the 		 * exception of PF0 which would print everything. 		 */
if|if
condition|(
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_VALID
operator|)
operator|||
operator|(
name|p_hwfn
operator|->
name|abs_pf_id
operator|==
literal|0
operator|)
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"IGU_BLOCK: [SB 0x%04x] func_id = %d is_pf = %d vector_num = 0x%x\n"
argument_list|,
name|igu_sb_id
argument_list|,
name|p_block
operator|->
name|function_id
argument_list|,
name|p_block
operator|->
name|is_pf
argument_list|,
name|p_block
operator|->
name|vector_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_igu_info
operator|->
name|igu_dsb_id
operator|==
name|ECORE_SB_INVALID_IDX
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"IGU CAM returned invalid values igu_dsb_id=0x%x\n"
argument_list|,
name|p_igu_info
operator|->
name|igu_dsb_id
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* All non default SB are considered free at this point */
name|p_igu_info
operator|->
name|usage
operator|.
name|free_cnt
operator|=
name|p_igu_info
operator|->
name|usage
operator|.
name|cnt
expr_stmt|;
name|p_igu_info
operator|->
name|usage
operator|.
name|free_cnt_iov
operator|=
name|p_igu_info
operator|->
name|usage
operator|.
name|iov_cnt
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"igu_dsb_id=0x%x, num Free SBs - PF: %04x VF: %04x [might change after resource allocation]\n"
argument_list|,
name|p_igu_info
operator|->
name|igu_dsb_id
argument_list|,
name|p_igu_info
operator|->
name|usage
operator|.
name|cnt
argument_list|,
name|p_igu_info
operator|->
name|usage
operator|.
name|iov_cnt
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_igu_relocate_sb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|sb_id
parameter_list|,
name|bool
name|b_to_vf
parameter_list|)
block|{
name|struct
name|ecore_igu_info
modifier|*
name|p_info
init|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
decl_stmt|;
name|struct
name|ecore_igu_block
modifier|*
name|p_block
init|=
name|OSAL_NULL
decl_stmt|;
name|u16
name|igu_sb_id
init|=
literal|0
decl_stmt|,
name|vf_num
init|=
literal|0
decl_stmt|;
name|u32
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
operator|!
name|IS_PF_SRIOV
argument_list|(
name|p_hwfn
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
if|if
condition|(
name|sb_id
operator|==
name|ECORE_SP_SB_ID
condition|)
return|return
name|ECORE_INVAL
return|;
if|if
condition|(
operator|!
name|p_info
operator|->
name|b_allow_pf_vf_change
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Can't relocate SBs as MFW is too old.\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* If we're moving a SB from PF to VF, the client had to specify 	 * which vector it wants to move. 	 */
if|if
condition|(
name|b_to_vf
condition|)
block|{
name|igu_sb_id
operator|=
name|ecore_get_pf_igu_sb_id
argument_list|(
name|p_hwfn
argument_list|,
name|sb_id
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|igu_sb_id
operator|==
name|ECORE_SB_INVALID_IDX
condition|)
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* If we're moving a SB from VF to PF, need to validate there isn't 	 * already a line configured for that vector. 	 */
if|if
condition|(
operator|!
name|b_to_vf
condition|)
block|{
if|if
condition|(
name|ecore_get_pf_igu_sb_id
argument_list|(
name|p_hwfn
argument_list|,
name|sb_id
operator|+
literal|1
argument_list|)
operator|!=
name|ECORE_SB_INVALID_IDX
condition|)
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* We need to validate that the SB can actually be relocated. 	 * This would also handle the previous case where we've explicitly 	 * stated which IGU SB needs to move. 	 */
for|for
control|(
init|;
name|igu_sb_id
operator|<
name|ECORE_MAPPING_MEMORY_SIZE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|;
name|igu_sb_id
operator|++
control|)
block|{
name|p_block
operator|=
operator|&
name|p_info
operator|->
name|entry
index|[
name|igu_sb_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_VALID
operator|)
operator|||
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_FREE
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|p_block
operator|->
name|status
operator|&
name|ECORE_IGU_STATUS_PF
operator|)
operator|!=
name|b_to_vf
operator|)
condition|)
block|{
if|if
condition|(
name|b_to_vf
condition|)
return|return
name|ECORE_INVAL
return|;
else|else
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|igu_sb_id
operator|==
name|ECORE_MAPPING_MEMORY_SIZE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_INTR
operator||
name|ECORE_MSG_IOV
operator|)
argument_list|,
literal|"Failed to find a free SB to move\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* At this point, p_block points to the SB we want to relocate */
if|if
condition|(
name|b_to_vf
condition|)
block|{
name|p_block
operator|->
name|status
operator|&=
operator|~
name|ECORE_IGU_STATUS_PF
expr_stmt|;
comment|/* It doesn't matter which VF number we choose, since we're 		 * going to disable the line; But let's keep it in range. 		 */
name|vf_num
operator|=
operator|(
name|u16
operator|)
name|p_hwfn
operator|->
name|p_dev
operator|->
name|p_iov_info
operator|->
name|first_vf_in_pf
expr_stmt|;
name|p_block
operator|->
name|function_id
operator|=
operator|(
name|u8
operator|)
name|vf_num
expr_stmt|;
name|p_block
operator|->
name|is_pf
operator|=
literal|0
expr_stmt|;
name|p_block
operator|->
name|vector_number
operator|=
literal|0
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|cnt
operator|--
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|free_cnt
operator|--
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
operator|++
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|free_cnt_iov
operator|++
expr_stmt|;
comment|/* TODO - if SBs aren't really the limiting factor, 		 * then it might not be accurate [in the since that 		 * we might not need decrement the feature]. 		 */
name|p_hwfn
operator|->
name|hw_info
operator|.
name|feat_num
index|[
name|ECORE_PF_L2_QUE
index|]
operator|--
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|feat_num
index|[
name|ECORE_VF_L2_QUE
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|p_block
operator|->
name|status
operator||=
name|ECORE_IGU_STATUS_PF
expr_stmt|;
name|p_block
operator|->
name|function_id
operator|=
name|p_hwfn
operator|->
name|rel_pf_id
expr_stmt|;
name|p_block
operator|->
name|is_pf
operator|=
literal|1
expr_stmt|;
name|p_block
operator|->
name|vector_number
operator|=
name|sb_id
operator|+
literal|1
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|cnt
operator|++
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|free_cnt
operator|++
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|iov_cnt
operator|--
expr_stmt|;
name|p_info
operator|->
name|usage
operator|.
name|free_cnt_iov
operator|--
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|feat_num
index|[
name|ECORE_PF_L2_QUE
index|]
operator|++
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|feat_num
index|[
name|ECORE_VF_L2_QUE
index|]
operator|--
expr_stmt|;
block|}
comment|/* Update the IGU and CAU with the new configuration */
name|SET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_FUNCTION_NUMBER
argument_list|,
name|p_block
operator|->
name|function_id
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_PF_VALID
argument_list|,
name|p_block
operator|->
name|is_pf
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_VALID
argument_list|,
name|p_block
operator|->
name|is_pf
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|val
argument_list|,
name|IGU_MAPPING_LINE_VECTOR_NUMBER
argument_list|,
name|p_block
operator|->
name|vector_number
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_MAPPING_MEMORY
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|igu_sb_id
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ecore_int_cau_conf_sb
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
literal|0
argument_list|,
name|igu_sb_id
argument_list|,
name|vf_num
argument_list|,
name|p_block
operator|->
name|is_pf
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_INTR
argument_list|,
literal|"Relocation: [SB 0x%04x] func_id = %d is_pf = %d vector_num = 0x%x\n"
argument_list|,
name|igu_sb_id
argument_list|,
name|p_block
operator|->
name|function_id
argument_list|,
name|p_block
operator|->
name|is_pf
argument_list|,
name|p_block
operator|->
name|vector_number
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Initialize igu runtime registers  *  * @param p_hwfn  */
end_comment

begin_function
name|void
name|ecore_int_igu_init_rt
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|igu_pf_conf
init|=
name|IGU_PF_CONF_FUNC_EN
decl_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|IGU_REG_PF_CONFIGURATION_RT_OFFSET
argument_list|,
name|igu_pf_conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LSB_IGU_CMD_ADDR
value|(IGU_REG_SISR_MDPC_WMASK_LSB_UPPER - \ 			  IGU_CMD_INT_ACK_BASE)
end_define

begin_define
define|#
directive|define
name|MSB_IGU_CMD_ADDR
value|(IGU_REG_SISR_MDPC_WMASK_MSB_UPPER - \ 			  IGU_CMD_INT_ACK_BASE)
end_define

begin_function
name|u64
name|ecore_int_igu_read_sisr_reg
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|intr_status_hi
init|=
literal|0
decl_stmt|,
name|intr_status_lo
init|=
literal|0
decl_stmt|;
name|u64
name|intr_status
init|=
literal|0
decl_stmt|;
name|intr_status_lo
operator|=
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|GTT_BAR0_MAP_REG_IGU_CMD
operator|+
name|LSB_IGU_CMD_ADDR
operator|*
literal|8
argument_list|)
expr_stmt|;
name|intr_status_hi
operator|=
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|GTT_BAR0_MAP_REG_IGU_CMD
operator|+
name|MSB_IGU_CMD_ADDR
operator|*
literal|8
argument_list|)
expr_stmt|;
name|intr_status
operator|=
operator|(
operator|(
name|u64
operator|)
name|intr_status_hi
operator|<<
literal|32
operator|)
operator|+
operator|(
name|u64
operator|)
name|intr_status_lo
expr_stmt|;
return|return
name|intr_status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_sp_dpc_setup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|OSAL_DPC_INIT
argument_list|(
name|p_hwfn
operator|->
name|sp_dpc
argument_list|,
name|p_hwfn
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|b_sp_dpc_enabled
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_int_sp_dpc_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|p_hwfn
operator|->
name|sp_dpc
operator|=
name|OSAL_DPC_ALLOC
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|sp_dpc
condition|)
return|return
name|ECORE_NOMEM
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_int_sp_dpc_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|sp_dpc
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|sp_dpc
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|rc
operator|=
name|ecore_int_sp_dpc_alloc
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Failed to allocate sp dpc mem\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|rc
operator|=
name|ecore_int_sp_sb_alloc
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Failed to allocate sp sb mem\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|rc
operator|=
name|ecore_int_sb_attn_alloc
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
literal|"Failed to allocate sb attn mem\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_int_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|ecore_int_sp_sb_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_int_sb_attn_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|ecore_int_sp_dpc_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_int_setup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|||
operator|!
name|p_hwfn
operator|->
name|p_sp_sb
operator|||
operator|!
name|p_hwfn
operator|->
name|p_sb_attn
condition|)
return|return;
name|ecore_int_sb_setup
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|p_hwfn
operator|->
name|p_sp_sb
operator|->
name|sb_info
argument_list|)
expr_stmt|;
name|ecore_int_sb_attn_setup
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_int_sp_dpc_setup
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_int_get_num_sbs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_sb_cnt_info
modifier|*
name|p_sb_cnt_info
parameter_list|)
block|{
name|struct
name|ecore_igu_info
modifier|*
name|p_igu_info
init|=
name|p_hwfn
operator|->
name|hw_info
operator|.
name|p_igu_info
decl_stmt|;
if|if
condition|(
operator|!
name|p_igu_info
operator|||
operator|!
name|p_sb_cnt_info
condition|)
return|return;
name|OSAL_MEMCPY
argument_list|(
name|p_sb_cnt_info
argument_list|,
operator|&
name|p_igu_info
operator|->
name|usage
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_sb_cnt_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_int_disable_post_isr_release
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|for_each_hwfn
argument_list|(
argument|p_dev
argument_list|,
argument|i
argument_list|)
name|p_dev
operator|->
name|hwfns
index|[
name|i
index|]
operator|.
name|b_int_requested
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_int_attn_clr_enable
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|bool
name|clr_enable
parameter_list|)
block|{
name|p_dev
operator|->
name|attn_clr_en
operator|=
name|clr_enable
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_set_timer_res
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|timer_res
parameter_list|,
name|u16
name|sb_id
parameter_list|,
name|bool
name|tx
parameter_list|)
block|{
name|struct
name|cau_sb_entry
name|sb_entry
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|hw_init_done
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"hardware not initialized yet\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|rc
operator|=
name|ecore_dmae_grc2host
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CAU_REG_SB_VAR_MEMORY
operator|+
name|sb_id
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
operator|&
name|sb_entry
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"dmae_grc2host failed %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
if|if
condition|(
name|tx
condition|)
name|SET_FIELD
argument_list|(
name|sb_entry
operator|.
name|params
argument_list|,
name|CAU_SB_ENTRY_TIMER_RES1
argument_list|,
name|timer_res
argument_list|)
expr_stmt|;
else|else
name|SET_FIELD
argument_list|(
name|sb_entry
operator|.
name|params
argument_list|,
name|CAU_SB_ENTRY_TIMER_RES0
argument_list|,
name|timer_res
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_dmae_host2grc
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
operator|&
name|sb_entry
argument_list|,
name|CAU_REG_SB_VAR_MEMORY
operator|+
name|sb_id
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"dmae_host2grc failed %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_int_get_sb_dbg
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_sb_info
modifier|*
name|p_sb
parameter_list|,
name|struct
name|ecore_sb_info_dbg
modifier|*
name|p_info
parameter_list|)
block|{
name|u16
name|sbid
init|=
name|p_sb
operator|->
name|igu_sb_id
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
if|if
condition|(
name|sbid
operator|>
name|NUM_OF_SBS
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
name|p_info
operator|->
name|igu_prod
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_PRODUCER_MEMORY
operator|+
name|sbid
operator|*
literal|4
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|igu_cons
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_CONSUMER_MEM
operator|+
name|sbid
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PIS_PER_SB_E4
condition|;
name|i
operator|++
control|)
name|p_info
operator|->
name|pi
index|[
name|i
index|]
operator|=
operator|(
name|u16
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CAU_REG_PI_MEMORY
operator|+
name|sbid
operator|*
literal|4
operator|*
name|PIS_PER_SB_E4
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

end_unit

