begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * File : ecore_init_fw_funcs.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bcm_osal.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_ops.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_rt_defs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_common.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_init_func.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_eth.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_init_tool.h"
end_include

begin_include
include|#
directive|include
file|"ecore_iro.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_fw_funcs.h"
end_include

begin_define
define|#
directive|define
name|CDU_VALIDATION_DEFAULT_CFG
value|61
end_define

begin_decl_stmt
specifier|static
name|u16
name|con_region_offsets
index|[
literal|3
index|]
index|[
name|E4_NUM_OF_CONNECTION_TYPES
index|]
init|=
block|{
block|{
literal|400
block|,
literal|336
block|,
literal|352
block|,
literal|304
block|,
literal|304
block|,
literal|384
block|,
literal|416
block|,
literal|352
block|}
block|,
comment|/* region 3 offsets */
block|{
literal|528
block|,
literal|496
block|,
literal|416
block|,
literal|448
block|,
literal|448
block|,
literal|512
block|,
literal|544
block|,
literal|480
block|}
block|,
comment|/* region 4 offsets */
block|{
literal|608
block|,
literal|544
block|,
literal|496
block|,
literal|512
block|,
literal|576
block|,
literal|592
block|,
literal|624
block|,
literal|560
block|}
comment|/* region 5 offsets */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u16
name|task_region_offsets
index|[
literal|1
index|]
index|[
name|E4_NUM_OF_CONNECTION_TYPES
index|]
init|=
block|{
block|{
literal|240
block|,
literal|240
block|,
literal|112
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|96
block|}
comment|/* region 1 offsets */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* General constants */
end_comment

begin_define
define|#
directive|define
name|QM_PQ_MEM_4KB
parameter_list|(
name|pq_size
parameter_list|)
value|(pq_size ? DIV_ROUND_UP((pq_size + 1) * QM_PQ_ELEMENT_SIZE, 0x1000) : 0)
end_define

begin_define
define|#
directive|define
name|QM_PQ_SIZE_256B
parameter_list|(
name|pq_size
parameter_list|)
value|(pq_size ? DIV_ROUND_UP(pq_size, 0x100) - 1 : 0)
end_define

begin_define
define|#
directive|define
name|QM_INVALID_PQ_ID
value|0xffff
end_define

begin_comment
comment|/* Feature enable */
end_comment

begin_define
define|#
directive|define
name|QM_BYPASS_EN
value|1
end_define

begin_define
define|#
directive|define
name|QM_BYTE_CRD_EN
value|1
end_define

begin_comment
comment|/* Other PQ constants */
end_comment

begin_define
define|#
directive|define
name|QM_OTHER_PQS_PER_PF
value|4
end_define

begin_comment
comment|/* WFQ constants: */
end_comment

begin_comment
comment|/* Upper bound in MB, 10 * burst size of 1ms in 50Gbps */
end_comment

begin_define
define|#
directive|define
name|QM_WFQ_UPPER_BOUND
value|62500000
end_define

begin_comment
comment|/* Bit  of VOQ in WFQ VP PQ map */
end_comment

begin_define
define|#
directive|define
name|QM_WFQ_VP_PQ_VOQ_SHIFT
value|0
end_define

begin_comment
comment|/* Bit  of PF in WFQ VP PQ map */
end_comment

begin_define
define|#
directive|define
name|QM_WFQ_VP_PQ_PF_SHIFT
value|5
end_define

begin_comment
comment|/* 0x9000 = 4*9*1024 */
end_comment

begin_define
define|#
directive|define
name|QM_WFQ_INC_VAL
parameter_list|(
name|weight
parameter_list|)
value|((weight) * 0x9000)
end_define

begin_comment
comment|/* 0.7 * upper bound (62500000) */
end_comment

begin_define
define|#
directive|define
name|QM_WFQ_MAX_INC_VAL
value|43750000
end_define

begin_comment
comment|/* RL constants: */
end_comment

begin_comment
comment|/* Upper bound is set to 10 * burst size of 1ms in 50Gbps */
end_comment

begin_define
define|#
directive|define
name|QM_RL_UPPER_BOUND
value|62500000
end_define

begin_comment
comment|/* Period in us */
end_comment

begin_define
define|#
directive|define
name|QM_RL_PERIOD
value|5
end_define

begin_comment
comment|/* Period in 25MHz cycles */
end_comment

begin_define
define|#
directive|define
name|QM_RL_PERIOD_CLK_25M
value|(25 * QM_RL_PERIOD)
end_define

begin_comment
comment|/* 0.7 * upper bound (62500000) */
end_comment

begin_define
define|#
directive|define
name|QM_RL_MAX_INC_VAL
value|43750000
end_define

begin_comment
comment|/* RL increment value - rate is specified in mbps. the factor of 1.01 was  * added after seeing only 99% factor reached in a 25Gbps port with DPDK RFC  * 2544 test. In this scenario the PF RL was reducing the line rate to 99%  * although the credit increment value was the correct one and FW calculated  * correct packet sizes. The reason for the inaccuracy of the RL is unknown at  * this point.  */
end_comment

begin_define
define|#
directive|define
name|QM_RL_INC_VAL
parameter_list|(
name|rate
parameter_list|)
value|OSAL_MAX_T(u32, (u32)(((rate ? rate : 1000000) * QM_RL_PERIOD * 101) 	/ (8 * 100)), 1)
end_define

begin_comment
comment|/* AFullOprtnstcCrdMask constants */
end_comment

begin_define
define|#
directive|define
name|QM_OPPOR_LINE_VOQ_DEF
value|1
end_define

begin_define
define|#
directive|define
name|QM_OPPOR_FW_STOP_DEF
value|0
end_define

begin_define
define|#
directive|define
name|QM_OPPOR_PQ_EMPTY_DEF
value|1
end_define

begin_comment
comment|/* Command Queue constants: */
end_comment

begin_comment
comment|/* Pure LB CmdQ lines (+spare) */
end_comment

begin_define
define|#
directive|define
name|PBF_CMDQ_PURE_LB_LINES
value|150
end_define

begin_define
define|#
directive|define
name|PBF_CMDQ_LINES_RT_OFFSET
parameter_list|(
name|voq
parameter_list|)
value|(PBF_REG_YCMD_QS_NUM_LINES_VOQ0_RT_OFFSET + voq 	* (PBF_REG_YCMD_QS_NUM_LINES_VOQ1_RT_OFFSET 	- PBF_REG_YCMD_QS_NUM_LINES_VOQ0_RT_OFFSET))
end_define

begin_define
define|#
directive|define
name|PBF_BTB_GUARANTEED_RT_OFFSET
parameter_list|(
name|voq
parameter_list|)
value|(PBF_REG_BTB_GUARANTEED_VOQ0_RT_OFFSET + voq 	* (PBF_REG_BTB_GUARANTEED_VOQ1_RT_OFFSET 	- PBF_REG_BTB_GUARANTEED_VOQ0_RT_OFFSET))
end_define

begin_define
define|#
directive|define
name|QM_VOQ_LINE_CRD
parameter_list|(
name|pbf_cmd_lines
parameter_list|)
value|((((pbf_cmd_lines) - 4) * 2) | QM_LINE_CRD_REG_SIGN_BIT)
end_define

begin_comment
comment|/* BTB: blocks constants (block size = 256B) */
end_comment

begin_comment
comment|/* 256B blocks in 9700B packet */
end_comment

begin_define
define|#
directive|define
name|BTB_JUMBO_PKT_BLOCKS
value|38
end_define

begin_comment
comment|/* Headroom per-port */
end_comment

begin_define
define|#
directive|define
name|BTB_HEADROOM_BLOCKS
value|BTB_JUMBO_PKT_BLOCKS
end_define

begin_define
define|#
directive|define
name|BTB_PURE_LB_FACTOR
value|10
end_define

begin_comment
comment|/* Factored (hence really 0.7) */
end_comment

begin_define
define|#
directive|define
name|BTB_PURE_LB_RATIO
value|7
end_define

begin_comment
comment|/* QM stop command constants */
end_comment

begin_define
define|#
directive|define
name|QM_STOP_PQ_MASK_WIDTH
value|32
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_ADDR
value|2
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_STRUCT_SIZE
value|2
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_PAUSE_MASK_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_PAUSE_MASK_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_PAUSE_MASK_MASK
value|-1
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_GROUP_ID_OFFSET
value|1
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_GROUP_ID_SHIFT
value|16
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_GROUP_ID_MASK
value|15
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_PQ_TYPE_OFFSET
value|1
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_PQ_TYPE_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_PQ_TYPE_MASK
value|1
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_MAX_POLL_COUNT
value|100
end_define

begin_define
define|#
directive|define
name|QM_STOP_CMD_POLL_PERIOD_US
value|500
end_define

begin_comment
comment|/* QM command macros */
end_comment

begin_define
define|#
directive|define
name|QM_CMD_STRUCT_SIZE
parameter_list|(
name|cmd
parameter_list|)
value|cmd##_STRUCT_SIZE
end_define

begin_define
define|#
directive|define
name|QM_CMD_SET_FIELD
parameter_list|(
name|var
parameter_list|,
name|cmd
parameter_list|,
name|field
parameter_list|,
name|value
parameter_list|)
value|SET_FIELD(var[cmd##_##field##_OFFSET], cmd##_##field, value)
end_define

begin_comment
comment|/* QM: VOQ macros */
end_comment

begin_define
define|#
directive|define
name|PHYS_VOQ
parameter_list|(
name|port
parameter_list|,
name|tc
parameter_list|,
name|max_phys_tcs_per_port
parameter_list|)
value|((port) * (max_phys_tcs_per_port) + (tc))
end_define

begin_define
define|#
directive|define
name|LB_VOQ
parameter_list|(
name|port
parameter_list|)
value|(MAX_PHYS_VOQS + (port))
end_define

begin_define
define|#
directive|define
name|VOQ
parameter_list|(
name|port
parameter_list|,
name|tc
parameter_list|,
name|max_phys_tcs_per_port
parameter_list|)
value|((tc)< LB_TC ? PHYS_VOQ(port, tc, max_phys_tcs_per_port) 	: LB_VOQ(port))
end_define

begin_comment
comment|/******************** INTERNAL IMPLEMENTATION *********************/
end_comment

begin_comment
comment|/* Prepare PF RL enable/disable runtime init values */
end_comment

begin_function
specifier|static
name|void
name|ecore_enable_pf_rl
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|bool
name|pf_rl_en
parameter_list|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLPFENABLE_RT_OFFSET
argument_list|,
name|pf_rl_en
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_rl_en
condition|)
block|{
comment|/* Enable RLs for all VOQs */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLPFVOQENABLE_RT_OFFSET
argument_list|,
operator|(
literal|1
operator|<<
name|MAX_NUM_VOQS
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Write RL period */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLPFPERIOD_RT_OFFSET
argument_list|,
name|QM_RL_PERIOD_CLK_25M
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLPFPERIODTIMER_RT_OFFSET
argument_list|,
name|QM_RL_PERIOD_CLK_25M
argument_list|)
expr_stmt|;
comment|/* Set credit threshold for QM bypass flow */
if|if
condition|(
name|QM_BYPASS_EN
condition|)
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_AFULLQMBYPTHRPFRL_RT_OFFSET
argument_list|,
name|QM_RL_UPPER_BOUND
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare PF WFQ enable/disable runtime init values */
end_comment

begin_function
specifier|static
name|void
name|ecore_enable_pf_wfq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|bool
name|pf_wfq_en
parameter_list|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_WFQPFENABLE_RT_OFFSET
argument_list|,
name|pf_wfq_en
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Set credit threshold for QM bypass flow */
if|if
condition|(
name|pf_wfq_en
operator|&&
name|QM_BYPASS_EN
condition|)
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_AFULLQMBYPTHRPFWFQ_RT_OFFSET
argument_list|,
name|QM_WFQ_UPPER_BOUND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare VPORT RL enable/disable runtime init values */
end_comment

begin_function
specifier|static
name|void
name|ecore_enable_vport_rl
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|bool
name|vport_rl_en
parameter_list|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLGLBLENABLE_RT_OFFSET
argument_list|,
name|vport_rl_en
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vport_rl_en
condition|)
block|{
comment|/* Write RL period (use timer 0 only) */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLGLBLPERIOD_0_RT_OFFSET
argument_list|,
name|QM_RL_PERIOD_CLK_25M
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLGLBLPERIODTIMER_0_RT_OFFSET
argument_list|,
name|QM_RL_PERIOD_CLK_25M
argument_list|)
expr_stmt|;
comment|/* Set credit threshold for QM bypass flow */
if|if
condition|(
name|QM_BYPASS_EN
condition|)
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_AFULLQMBYPTHRGLBLRL_RT_OFFSET
argument_list|,
name|QM_RL_UPPER_BOUND
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare VPORT WFQ enable/disable runtime init values */
end_comment

begin_function
specifier|static
name|void
name|ecore_enable_vport_wfq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|bool
name|vport_wfq_en
parameter_list|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_WFQVPENABLE_RT_OFFSET
argument_list|,
name|vport_wfq_en
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Set credit threshold for QM bypass flow */
if|if
condition|(
name|vport_wfq_en
operator|&&
name|QM_BYPASS_EN
condition|)
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_AFULLQMBYPTHRVPWFQ_RT_OFFSET
argument_list|,
name|QM_WFQ_UPPER_BOUND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare runtime init values to allocate PBF command queue lines for  * the specified VOQ.  */
end_comment

begin_function
specifier|static
name|void
name|ecore_cmdq_lines_voq_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|voq
parameter_list|,
name|u16
name|cmdq_lines
parameter_list|)
block|{
name|u32
name|qm_line_crd
decl_stmt|;
name|qm_line_crd
operator|=
name|QM_VOQ_LINE_CRD
argument_list|(
name|cmdq_lines
argument_list|)
expr_stmt|;
name|OVERWRITE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PBF_CMDQ_LINES_RT_OFFSET
argument_list|(
name|voq
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|cmdq_lines
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_VOQCRDLINE_RT_OFFSET
operator|+
name|voq
argument_list|,
name|qm_line_crd
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_VOQINITCRDLINE_RT_OFFSET
operator|+
name|voq
argument_list|,
name|qm_line_crd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare runtime init values to allocate PBF command queue lines. */
end_comment

begin_function
specifier|static
name|void
name|ecore_cmdq_lines_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|max_ports_per_engine
parameter_list|,
name|u8
name|max_phys_tcs_per_port
parameter_list|,
name|struct
name|init_qm_port_params
name|port_params
index|[
name|MAX_NUM_PORTS
index|]
parameter_list|)
block|{
name|u8
name|tc
decl_stmt|,
name|voq
decl_stmt|,
name|port_id
decl_stmt|,
name|num_tcs_in_port
decl_stmt|;
comment|/* Clear PBF lines for all VOQs */
for|for
control|(
name|voq
operator|=
literal|0
init|;
name|voq
operator|<
name|MAX_NUM_VOQS
condition|;
name|voq
operator|++
control|)
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PBF_CMDQ_LINES_RT_OFFSET
argument_list|(
name|voq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|port_id
operator|=
literal|0
init|;
name|port_id
operator|<
name|max_ports_per_engine
condition|;
name|port_id
operator|++
control|)
block|{
name|u16
name|phys_lines
decl_stmt|,
name|phys_lines_per_tc
decl_stmt|;
if|if
condition|(
operator|!
name|port_params
index|[
name|port_id
index|]
operator|.
name|active
condition|)
continue|continue;
comment|/* Find #lines to divide between the active physical TCs */
name|phys_lines
operator|=
name|port_params
index|[
name|port_id
index|]
operator|.
name|num_pbf_cmd_lines
operator|-
name|PBF_CMDQ_PURE_LB_LINES
expr_stmt|;
comment|/* Find #lines per active physical TC */
name|num_tcs_in_port
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_PHYS_TCS
condition|;
name|tc
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|port_params
index|[
name|port_id
index|]
operator|.
name|active_phys_tcs
operator|>>
name|tc
operator|)
operator|&
literal|0x1
operator|)
operator|==
literal|1
condition|)
name|num_tcs_in_port
operator|++
expr_stmt|;
name|phys_lines_per_tc
operator|=
name|phys_lines
operator|/
name|num_tcs_in_port
expr_stmt|;
comment|/* Init registers per active TC */
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_PHYS_TCS
condition|;
name|tc
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|port_params
index|[
name|port_id
index|]
operator|.
name|active_phys_tcs
operator|>>
name|tc
operator|)
operator|&
literal|0x1
operator|)
operator|==
literal|1
condition|)
block|{
name|voq
operator|=
name|PHYS_VOQ
argument_list|(
name|port_id
argument_list|,
name|tc
argument_list|,
name|max_phys_tcs_per_port
argument_list|)
expr_stmt|;
name|ecore_cmdq_lines_voq_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|voq
argument_list|,
name|phys_lines_per_tc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Init registers for pure LB TC */
name|ecore_cmdq_lines_voq_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|LB_VOQ
argument_list|(
name|port_id
argument_list|)
argument_list|,
name|PBF_CMDQ_PURE_LB_LINES
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare runtime init values to allocate guaranteed BTB blocks for the  * specified port. The guaranteed BTB space is divided between the TCs as  * follows (shared space Is currently not used):  * 1. Parameters:  *    B - BTB blocks for this port  *    C - Number of physical TCs for this port  * 2. Calculation:  *    a. 38 blocks (9700B jumbo frame) are allocated for global per port  *	 headroom.  *    b. B = B - 38 (remainder after global headroom allocation).  *    c. MAX(38,B/(C+0.7)) blocks are allocated for the pure LB VOQ.  *    d. B = B % MAX(38, B/(C+0.7)) (remainder after pure LB allocation).  *    e. B/C blocks are allocated for each physical TC.  * Assumptions:  * - MTU is up to 9700 bytes (38 blocks)  * - All TCs are considered symmetrical (same rate and packet size)  * - No optimization for lossy TC (all are considered lossless). Shared space  *   is not enabled and allocated for each TC.  */
end_comment

begin_function
specifier|static
name|void
name|ecore_btb_blocks_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|max_ports_per_engine
parameter_list|,
name|u8
name|max_phys_tcs_per_port
parameter_list|,
name|struct
name|init_qm_port_params
name|port_params
index|[
name|MAX_NUM_PORTS
index|]
parameter_list|)
block|{
name|u32
name|usable_blocks
decl_stmt|,
name|pure_lb_blocks
decl_stmt|,
name|phys_blocks
decl_stmt|;
name|u8
name|tc
decl_stmt|,
name|voq
decl_stmt|,
name|port_id
decl_stmt|,
name|num_tcs_in_port
decl_stmt|;
for|for
control|(
name|port_id
operator|=
literal|0
init|;
name|port_id
operator|<
name|max_ports_per_engine
condition|;
name|port_id
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|port_params
index|[
name|port_id
index|]
operator|.
name|active
condition|)
continue|continue;
comment|/* Subtract headroom blocks */
name|usable_blocks
operator|=
name|port_params
index|[
name|port_id
index|]
operator|.
name|num_btb_blocks
operator|-
name|BTB_HEADROOM_BLOCKS
expr_stmt|;
comment|/* Find blocks per physical TC. use factor to avoid floating 		 * arithmethic. 		 */
name|num_tcs_in_port
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_PHYS_TCS
condition|;
name|tc
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|port_params
index|[
name|port_id
index|]
operator|.
name|active_phys_tcs
operator|>>
name|tc
operator|)
operator|&
literal|0x1
operator|)
operator|==
literal|1
condition|)
name|num_tcs_in_port
operator|++
expr_stmt|;
name|pure_lb_blocks
operator|=
operator|(
name|usable_blocks
operator|*
name|BTB_PURE_LB_FACTOR
operator|)
operator|/
operator|(
name|num_tcs_in_port
operator|*
name|BTB_PURE_LB_FACTOR
operator|+
name|BTB_PURE_LB_RATIO
operator|)
expr_stmt|;
name|pure_lb_blocks
operator|=
name|OSAL_MAX_T
argument_list|(
name|u32
argument_list|,
name|BTB_JUMBO_PKT_BLOCKS
argument_list|,
name|pure_lb_blocks
operator|/
name|BTB_PURE_LB_FACTOR
argument_list|)
expr_stmt|;
name|phys_blocks
operator|=
operator|(
name|usable_blocks
operator|-
name|pure_lb_blocks
operator|)
operator|/
name|num_tcs_in_port
expr_stmt|;
comment|/* Init physical TCs */
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_PHYS_TCS
condition|;
name|tc
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|port_params
index|[
name|port_id
index|]
operator|.
name|active_phys_tcs
operator|>>
name|tc
operator|)
operator|&
literal|0x1
operator|)
operator|==
literal|1
condition|)
block|{
name|voq
operator|=
name|PHYS_VOQ
argument_list|(
name|port_id
argument_list|,
name|tc
argument_list|,
name|max_phys_tcs_per_port
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PBF_BTB_GUARANTEED_RT_OFFSET
argument_list|(
name|voq
argument_list|)
argument_list|,
name|phys_blocks
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Init pure LB TC */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PBF_BTB_GUARANTEED_RT_OFFSET
argument_list|(
name|LB_VOQ
argument_list|(
name|port_id
argument_list|)
argument_list|)
argument_list|,
name|pure_lb_blocks
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare Tx PQ mapping runtime init values for the specified PF */
end_comment

begin_function
specifier|static
name|void
name|ecore_tx_pq_map_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|port_id
parameter_list|,
name|u8
name|pf_id
parameter_list|,
name|u8
name|max_phys_tcs_per_port
parameter_list|,
name|bool
name|is_first_pf
parameter_list|,
name|u32
name|num_pf_cids
parameter_list|,
name|u32
name|num_vf_cids
parameter_list|,
name|u16
name|start_pq
parameter_list|,
name|u16
name|num_pf_pqs
parameter_list|,
name|u16
name|num_vf_pqs
parameter_list|,
name|u8
name|start_vport
parameter_list|,
name|u32
name|base_mem_addr_4kb
parameter_list|,
name|struct
name|init_qm_pq_params
modifier|*
name|pq_params
parameter_list|,
name|struct
name|init_qm_vport_params
modifier|*
name|vport_params
parameter_list|)
block|{
comment|/* A bit per Tx PQ indicating if the PQ is associated with a VF */
name|u32
name|tx_pq_vf_mask
index|[
name|MAX_QM_TX_QUEUES
operator|/
name|QM_PF_QUEUE_GROUP_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|num_tx_pq_vf_masks
init|=
name|MAX_QM_TX_QUEUES
operator|/
name|QM_PF_QUEUE_GROUP_SIZE
decl_stmt|;
name|u16
name|num_pqs
decl_stmt|,
name|first_pq_group
decl_stmt|,
name|last_pq_group
decl_stmt|,
name|i
decl_stmt|,
name|pq_id
decl_stmt|,
name|pq_group
decl_stmt|;
name|u32
name|pq_mem_4kb
decl_stmt|,
name|vport_pq_mem_4kb
decl_stmt|,
name|mem_addr_4kb
decl_stmt|;
name|num_pqs
operator|=
name|num_pf_pqs
operator|+
name|num_vf_pqs
expr_stmt|;
name|first_pq_group
operator|=
name|start_pq
operator|/
name|QM_PF_QUEUE_GROUP_SIZE
expr_stmt|;
name|last_pq_group
operator|=
operator|(
name|start_pq
operator|+
name|num_pqs
operator|-
literal|1
operator|)
operator|/
name|QM_PF_QUEUE_GROUP_SIZE
expr_stmt|;
name|pq_mem_4kb
operator|=
name|QM_PQ_MEM_4KB
argument_list|(
name|num_pf_cids
argument_list|)
expr_stmt|;
name|vport_pq_mem_4kb
operator|=
name|QM_PQ_MEM_4KB
argument_list|(
name|num_vf_cids
argument_list|)
expr_stmt|;
name|mem_addr_4kb
operator|=
name|base_mem_addr_4kb
expr_stmt|;
comment|/* Set mapping from PQ group to PF */
for|for
control|(
name|pq_group
operator|=
name|first_pq_group
init|;
name|pq_group
operator|<=
name|last_pq_group
condition|;
name|pq_group
operator|++
control|)
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_PQTX2PF_0_RT_OFFSET
operator|+
name|pq_group
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|pf_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set PQ sizes */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_MAXPQSIZE_0_RT_OFFSET
argument_list|,
name|QM_PQ_SIZE_256B
argument_list|(
name|num_pf_cids
argument_list|)
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_MAXPQSIZE_1_RT_OFFSET
argument_list|,
name|QM_PQ_SIZE_256B
argument_list|(
name|num_vf_cids
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go over all Tx PQs */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pq_id
operator|=
name|start_pq
init|;
name|i
operator|<
name|num_pqs
condition|;
name|i
operator|++
operator|,
name|pq_id
operator|++
control|)
block|{
name|u32
name|max_qm_global_rls
init|=
name|MAX_QM_GLOBAL_RLS
decl_stmt|;
name|struct
name|qm_rf_pq_map
name|tx_pq_map
decl_stmt|;
name|bool
name|is_vf_pq
decl_stmt|,
name|rl_valid
decl_stmt|;
name|u8
name|voq
decl_stmt|,
name|vport_id_in_pf
decl_stmt|;
name|u16
name|first_tx_pq_id
decl_stmt|;
name|voq
operator|=
name|VOQ
argument_list|(
name|port_id
argument_list|,
name|pq_params
index|[
name|i
index|]
operator|.
name|tc_id
argument_list|,
name|max_phys_tcs_per_port
argument_list|)
expr_stmt|;
name|is_vf_pq
operator|=
operator|(
name|i
operator|>=
name|num_pf_pqs
operator|)
expr_stmt|;
name|rl_valid
operator|=
name|pq_params
index|[
name|i
index|]
operator|.
name|rl_valid
operator|&&
name|pq_params
index|[
name|i
index|]
operator|.
name|vport_id
operator|<
name|max_qm_global_rls
expr_stmt|;
comment|/* Update first Tx PQ of VPORT/TC */
name|vport_id_in_pf
operator|=
name|pq_params
index|[
name|i
index|]
operator|.
name|vport_id
operator|-
name|start_vport
expr_stmt|;
name|first_tx_pq_id
operator|=
name|vport_params
index|[
name|vport_id_in_pf
index|]
operator|.
name|first_tx_pq_id
index|[
name|pq_params
index|[
name|i
index|]
operator|.
name|tc_id
index|]
expr_stmt|;
if|if
condition|(
name|first_tx_pq_id
operator|==
name|QM_INVALID_PQ_ID
condition|)
block|{
comment|/* Create new VP PQ */
name|vport_params
index|[
name|vport_id_in_pf
index|]
operator|.
name|first_tx_pq_id
index|[
name|pq_params
index|[
name|i
index|]
operator|.
name|tc_id
index|]
operator|=
name|pq_id
expr_stmt|;
name|first_tx_pq_id
operator|=
name|pq_id
expr_stmt|;
comment|/* Map VP PQ to VOQ and PF */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_WFQVPMAP_RT_OFFSET
operator|+
name|first_tx_pq_id
argument_list|,
operator|(
name|voq
operator|<<
name|QM_WFQ_VP_PQ_VOQ_SHIFT
operator|)
operator||
operator|(
name|pf_id
operator|<<
name|QM_WFQ_VP_PQ_PF_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check RL ID */
if|if
condition|(
name|pq_params
index|[
name|i
index|]
operator|.
name|rl_valid
operator|&&
name|pq_params
index|[
name|i
index|]
operator|.
name|vport_id
operator|>=
name|max_qm_global_rls
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid VPORT ID for rate limiter configuration\n"
argument_list|)
expr_stmt|;
comment|/* Fill PQ map entry */
name|OSAL_MEMSET
argument_list|(
operator|&
name|tx_pq_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_pq_map
argument_list|)
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|tx_pq_map
operator|.
name|reg
argument_list|,
name|QM_RF_PQ_MAP_PQ_VALID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|tx_pq_map
operator|.
name|reg
argument_list|,
name|QM_RF_PQ_MAP_RL_VALID
argument_list|,
name|rl_valid
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|tx_pq_map
operator|.
name|reg
argument_list|,
name|QM_RF_PQ_MAP_VP_PQ_ID
argument_list|,
name|first_tx_pq_id
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|tx_pq_map
operator|.
name|reg
argument_list|,
name|QM_RF_PQ_MAP_RL_ID
argument_list|,
name|rl_valid
condition|?
name|pq_params
index|[
name|i
index|]
operator|.
name|vport_id
else|:
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|tx_pq_map
operator|.
name|reg
argument_list|,
name|QM_RF_PQ_MAP_VOQ
argument_list|,
name|voq
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|tx_pq_map
operator|.
name|reg
argument_list|,
name|QM_RF_PQ_MAP_WRR_WEIGHT_GROUP
argument_list|,
name|pq_params
index|[
name|i
index|]
operator|.
name|wrr_group
argument_list|)
expr_stmt|;
comment|/* Write PQ map entry to CAM */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_TXPQMAP_RT_OFFSET
operator|+
name|pq_id
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
operator|&
name|tx_pq_map
operator|)
argument_list|)
expr_stmt|;
comment|/* Set base address */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_BASEADDRTXPQ_RT_OFFSET
operator|+
name|pq_id
argument_list|,
name|mem_addr_4kb
argument_list|)
expr_stmt|;
comment|/* If VF PQ, add indication to PQ VF mask */
if|if
condition|(
name|is_vf_pq
condition|)
block|{
name|tx_pq_vf_mask
index|[
name|pq_id
operator|/
name|QM_PF_QUEUE_GROUP_SIZE
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pq_id
operator|%
name|QM_PF_QUEUE_GROUP_SIZE
operator|)
operator|)
expr_stmt|;
name|mem_addr_4kb
operator|+=
name|vport_pq_mem_4kb
expr_stmt|;
block|}
else|else
block|{
name|mem_addr_4kb
operator|+=
name|pq_mem_4kb
expr_stmt|;
block|}
block|}
comment|/* Store Tx PQ VF mask to size select register */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tx_pq_vf_masks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tx_pq_vf_mask
index|[
name|i
index|]
condition|)
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_MAXPQSIZETXSEL_0_RT_OFFSET
operator|+
name|i
argument_list|,
name|tx_pq_vf_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare Other PQ mapping runtime init values for the specified PF */
end_comment

begin_function
specifier|static
name|void
name|ecore_other_pq_map_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|port_id
parameter_list|,
name|u8
name|pf_id
parameter_list|,
name|u32
name|num_pf_cids
parameter_list|,
name|u32
name|num_tids
parameter_list|,
name|u32
name|base_mem_addr_4kb
parameter_list|)
block|{
name|u32
name|pq_size
decl_stmt|,
name|pq_mem_4kb
decl_stmt|,
name|mem_addr_4kb
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|pq_id
decl_stmt|,
name|pq_group
decl_stmt|;
comment|/* A single other PQ group is used in each PF, where PQ group i is used 	 * in PF i. 	 */
name|pq_group
operator|=
name|pf_id
expr_stmt|;
name|pq_size
operator|=
name|num_pf_cids
operator|+
name|num_tids
expr_stmt|;
name|pq_mem_4kb
operator|=
name|QM_PQ_MEM_4KB
argument_list|(
name|pq_size
argument_list|)
expr_stmt|;
name|mem_addr_4kb
operator|=
name|base_mem_addr_4kb
expr_stmt|;
comment|/* Map PQ group to PF */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_PQOTHER2PF_0_RT_OFFSET
operator|+
name|pq_group
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|pf_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set PQ sizes */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_MAXPQSIZE_2_RT_OFFSET
argument_list|,
name|QM_PQ_SIZE_256B
argument_list|(
name|pq_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set base address */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pq_id
operator|=
name|pf_id
operator|*
name|QM_PF_QUEUE_GROUP_SIZE
init|;
name|i
operator|<
name|QM_OTHER_PQS_PER_PF
condition|;
name|i
operator|++
operator|,
name|pq_id
operator|++
control|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_BASEADDROTHERPQ_RT_OFFSET
operator|+
name|pq_id
argument_list|,
name|mem_addr_4kb
argument_list|)
expr_stmt|;
name|mem_addr_4kb
operator|+=
name|pq_mem_4kb
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare PF WFQ runtime init values for the specified PF.  * Return -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_pf_wfq_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|port_id
parameter_list|,
name|u8
name|pf_id
parameter_list|,
name|u16
name|pf_wfq
parameter_list|,
name|u8
name|max_phys_tcs_per_port
parameter_list|,
name|u16
name|num_tx_pqs
parameter_list|,
name|struct
name|init_qm_pq_params
modifier|*
name|pq_params
parameter_list|)
block|{
name|u32
name|inc_val
decl_stmt|,
name|crd_reg_offset
decl_stmt|;
name|u8
name|voq
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|crd_reg_offset
operator|=
operator|(
name|pf_id
operator|<
name|MAX_NUM_PFS_BB
condition|?
name|QM_REG_WFQPFCRD_RT_OFFSET
else|:
name|QM_REG_WFQPFCRD_MSB_RT_OFFSET
operator|)
operator|+
operator|(
name|pf_id
operator|%
name|MAX_NUM_PFS_BB
operator|)
expr_stmt|;
name|inc_val
operator|=
name|QM_WFQ_INC_VAL
argument_list|(
name|pf_wfq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inc_val
operator|||
name|inc_val
operator|>
name|QM_WFQ_MAX_INC_VAL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid PF WFQ weight configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tx_pqs
condition|;
name|i
operator|++
control|)
block|{
name|voq
operator|=
name|VOQ
argument_list|(
name|port_id
argument_list|,
name|pq_params
index|[
name|i
index|]
operator|.
name|tc_id
argument_list|,
name|max_phys_tcs_per_port
argument_list|)
expr_stmt|;
name|OVERWRITE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|crd_reg_offset
operator|+
name|voq
operator|*
name|MAX_NUM_PFS_BB
argument_list|,
operator|(
name|u32
operator|)
name|QM_WFQ_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
block|}
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_WFQPFUPPERBOUND_RT_OFFSET
operator|+
name|pf_id
argument_list|,
name|QM_WFQ_UPPER_BOUND
operator||
operator|(
name|u32
operator|)
name|QM_WFQ_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_WFQPFWEIGHT_RT_OFFSET
operator|+
name|pf_id
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prepare PF RL runtime init values for the specified PF.  * Return -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_pf_rl_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|pf_id
parameter_list|,
name|u32
name|pf_rl
parameter_list|)
block|{
name|u32
name|inc_val
decl_stmt|;
name|inc_val
operator|=
name|QM_RL_INC_VAL
argument_list|(
name|pf_rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_val
operator|>
name|QM_RL_MAX_INC_VAL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid PF rate limit configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLPFCRD_RT_OFFSET
operator|+
name|pf_id
argument_list|,
operator|(
name|u32
operator|)
name|QM_RL_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLPFUPPERBOUND_RT_OFFSET
operator|+
name|pf_id
argument_list|,
name|QM_RL_UPPER_BOUND
operator||
operator|(
name|u32
operator|)
name|QM_RL_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLPFINCVAL_RT_OFFSET
operator|+
name|pf_id
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prepare VPORT WFQ runtime init values for the specified VPORTs.  * Return -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_vp_wfq_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|num_vports
parameter_list|,
name|struct
name|init_qm_vport_params
modifier|*
name|vport_params
parameter_list|)
block|{
name|u16
name|vport_pq_id
decl_stmt|;
name|u32
name|inc_val
decl_stmt|;
name|u8
name|tc
decl_stmt|,
name|i
decl_stmt|;
comment|/* Go over all PF VPORTs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|vport_params
index|[
name|i
index|]
operator|.
name|vport_wfq
condition|)
continue|continue;
name|inc_val
operator|=
name|QM_WFQ_INC_VAL
argument_list|(
name|vport_params
index|[
name|i
index|]
operator|.
name|vport_wfq
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_val
operator|>
name|QM_WFQ_MAX_INC_VAL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid VPORT WFQ weight configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Each VPORT can have several VPORT PQ IDs for various TCs */
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_TCS
condition|;
name|tc
operator|++
control|)
block|{
name|vport_pq_id
operator|=
name|vport_params
index|[
name|i
index|]
operator|.
name|first_tx_pq_id
index|[
name|tc
index|]
expr_stmt|;
if|if
condition|(
name|vport_pq_id
operator|!=
name|QM_INVALID_PQ_ID
condition|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_WFQVPCRD_RT_OFFSET
operator|+
name|vport_pq_id
argument_list|,
operator|(
name|u32
operator|)
name|QM_WFQ_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_WFQVPWEIGHT_RT_OFFSET
operator|+
name|vport_pq_id
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prepare VPORT RL runtime init values for the specified VPORTs.  * Return -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_vport_rl_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|start_vport
parameter_list|,
name|u8
name|num_vports
parameter_list|,
name|struct
name|init_qm_vport_params
modifier|*
name|vport_params
parameter_list|)
block|{
name|u8
name|i
decl_stmt|,
name|vport_id
decl_stmt|;
name|u32
name|inc_val
decl_stmt|;
if|if
condition|(
name|start_vport
operator|+
name|num_vports
operator|>=
name|MAX_QM_GLOBAL_RLS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid VPORT ID for rate limiter configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Go over all PF VPORTs */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|vport_id
operator|=
name|start_vport
init|;
name|i
operator|<
name|num_vports
condition|;
name|i
operator|++
operator|,
name|vport_id
operator|++
control|)
block|{
name|inc_val
operator|=
name|QM_RL_INC_VAL
argument_list|(
name|vport_params
index|[
name|i
index|]
operator|.
name|vport_rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_val
operator|>
name|QM_RL_MAX_INC_VAL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid VPORT rate-limit configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLGLBLCRD_RT_OFFSET
operator|+
name|vport_id
argument_list|,
operator|(
name|u32
operator|)
name|QM_RL_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLGLBLUPPERBOUND_RT_OFFSET
operator|+
name|vport_id
argument_list|,
name|QM_RL_UPPER_BOUND
operator||
operator|(
name|u32
operator|)
name|QM_RL_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_RLGLBLINCVAL_RT_OFFSET
operator|+
name|vport_id
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_poll_on_qm_cmd_ready
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|reg_val
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|reg_val
operator|=
literal|0
init|;
name|i
operator|<
name|QM_STOP_CMD_MAX_POLL_COUNT
operator|&&
operator|!
name|reg_val
condition|;
name|i
operator|++
control|)
block|{
name|OSAL_UDELAY
argument_list|(
name|QM_STOP_CMD_POLL_PERIOD_US
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_SDMCMDREADY
argument_list|)
expr_stmt|;
block|}
comment|/* Check if timeout while waiting for SDM command ready */
if|if
condition|(
name|i
operator|==
name|QM_STOP_CMD_MAX_POLL_COUNT
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"Timeout when waiting for QM SDM command ready signal\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_send_qm_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|cmd_addr
parameter_list|,
name|u32
name|cmd_data_lsb
parameter_list|,
name|u32
name|cmd_data_msb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ecore_poll_on_qm_cmd_ready
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
condition|)
return|return
name|false
return|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_SDMCMDADDR
argument_list|,
name|cmd_addr
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_SDMCMDDATALSB
argument_list|,
name|cmd_data_lsb
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_SDMCMDDATAMSB
argument_list|,
name|cmd_data_msb
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_SDMCMDGO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_SDMCMDGO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ecore_poll_on_qm_cmd_ready
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************** INTERFACE IMPLEMENTATION *********************/
end_comment

begin_function
name|u32
name|ecore_qm_pf_mem_size
parameter_list|(
name|u8
name|pf_id
parameter_list|,
name|u32
name|num_pf_cids
parameter_list|,
name|u32
name|num_vf_cids
parameter_list|,
name|u32
name|num_tids
parameter_list|,
name|u16
name|num_pf_pqs
parameter_list|,
name|u16
name|num_vf_pqs
parameter_list|)
block|{
return|return
name|QM_PQ_MEM_4KB
argument_list|(
name|num_pf_cids
argument_list|)
operator|*
name|num_pf_pqs
operator|+
name|QM_PQ_MEM_4KB
argument_list|(
name|num_vf_cids
argument_list|)
operator|*
name|num_vf_pqs
operator|+
name|QM_PQ_MEM_4KB
argument_list|(
name|num_pf_cids
operator|+
name|num_tids
argument_list|)
operator|*
name|QM_OTHER_PQS_PER_PF
return|;
block|}
end_function

begin_function
name|int
name|ecore_qm_common_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|max_ports_per_engine
parameter_list|,
name|u8
name|max_phys_tcs_per_port
parameter_list|,
name|bool
name|pf_rl_en
parameter_list|,
name|bool
name|pf_wfq_en
parameter_list|,
name|bool
name|vport_rl_en
parameter_list|,
name|bool
name|vport_wfq_en
parameter_list|,
name|struct
name|init_qm_port_params
name|port_params
index|[
name|MAX_NUM_PORTS
index|]
parameter_list|)
block|{
name|u32
name|mask
decl_stmt|;
comment|/* Init AFullOprtnstcCrdMask */
name|mask
operator|=
operator|(
name|QM_OPPOR_LINE_VOQ_DEF
operator|<<
name|QM_RF_OPPORTUNISTIC_MASK_LINEVOQ_SHIFT
operator|)
operator||
operator|(
name|QM_BYTE_CRD_EN
operator|<<
name|QM_RF_OPPORTUNISTIC_MASK_BYTEVOQ_SHIFT
operator|)
operator||
operator|(
name|pf_wfq_en
operator|<<
name|QM_RF_OPPORTUNISTIC_MASK_PFWFQ_SHIFT
operator|)
operator||
operator|(
name|vport_wfq_en
operator|<<
name|QM_RF_OPPORTUNISTIC_MASK_VPWFQ_SHIFT
operator|)
operator||
operator|(
name|pf_rl_en
operator|<<
name|QM_RF_OPPORTUNISTIC_MASK_PFRL_SHIFT
operator|)
operator||
operator|(
name|vport_rl_en
operator|<<
name|QM_RF_OPPORTUNISTIC_MASK_VPQCNRL_SHIFT
operator|)
operator||
operator|(
name|QM_OPPOR_FW_STOP_DEF
operator|<<
name|QM_RF_OPPORTUNISTIC_MASK_FWPAUSE_SHIFT
operator|)
operator||
operator|(
name|QM_OPPOR_PQ_EMPTY_DEF
operator|<<
name|QM_RF_OPPORTUNISTIC_MASK_QUEUEEMPTY_SHIFT
operator|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|QM_REG_AFULLOPRTNSTCCRDMASK_RT_OFFSET
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* Enable/disable PF RL */
name|ecore_enable_pf_rl
argument_list|(
name|p_hwfn
argument_list|,
name|pf_rl_en
argument_list|)
expr_stmt|;
comment|/* Enable/disable PF WFQ */
name|ecore_enable_pf_wfq
argument_list|(
name|p_hwfn
argument_list|,
name|pf_wfq_en
argument_list|)
expr_stmt|;
comment|/* Enable/disable VPORT RL */
name|ecore_enable_vport_rl
argument_list|(
name|p_hwfn
argument_list|,
name|vport_rl_en
argument_list|)
expr_stmt|;
comment|/* Enable/disable VPORT WFQ */
name|ecore_enable_vport_wfq
argument_list|(
name|p_hwfn
argument_list|,
name|vport_wfq_en
argument_list|)
expr_stmt|;
comment|/* Init PBF CMDQ line credit */
name|ecore_cmdq_lines_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|max_ports_per_engine
argument_list|,
name|max_phys_tcs_per_port
argument_list|,
name|port_params
argument_list|)
expr_stmt|;
comment|/* Init BTB blocks in PBF */
name|ecore_btb_blocks_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|max_ports_per_engine
argument_list|,
name|max_phys_tcs_per_port
argument_list|,
name|port_params
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ecore_qm_pf_rt_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|port_id
parameter_list|,
name|u8
name|pf_id
parameter_list|,
name|u8
name|max_phys_tcs_per_port
parameter_list|,
name|bool
name|is_first_pf
parameter_list|,
name|u32
name|num_pf_cids
parameter_list|,
name|u32
name|num_vf_cids
parameter_list|,
name|u32
name|num_tids
parameter_list|,
name|u16
name|start_pq
parameter_list|,
name|u16
name|num_pf_pqs
parameter_list|,
name|u16
name|num_vf_pqs
parameter_list|,
name|u8
name|start_vport
parameter_list|,
name|u8
name|num_vports
parameter_list|,
name|u16
name|pf_wfq
parameter_list|,
name|u32
name|pf_rl
parameter_list|,
name|struct
name|init_qm_pq_params
modifier|*
name|pq_params
parameter_list|,
name|struct
name|init_qm_vport_params
modifier|*
name|vport_params
parameter_list|)
block|{
name|u32
name|other_mem_size_4kb
decl_stmt|;
name|u8
name|tc
decl_stmt|,
name|i
decl_stmt|;
name|other_mem_size_4kb
operator|=
name|QM_PQ_MEM_4KB
argument_list|(
name|num_pf_cids
operator|+
name|num_tids
argument_list|)
operator|*
name|QM_OTHER_PQS_PER_PF
expr_stmt|;
comment|/* Clear first Tx PQ ID array for each VPORT */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vports
condition|;
name|i
operator|++
control|)
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_TCS
condition|;
name|tc
operator|++
control|)
name|vport_params
index|[
name|i
index|]
operator|.
name|first_tx_pq_id
index|[
name|tc
index|]
operator|=
name|QM_INVALID_PQ_ID
expr_stmt|;
comment|/* Map Other PQs (if any) */
if|#
directive|if
name|QM_OTHER_PQS_PER_PF
operator|>
literal|0
name|ecore_other_pq_map_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|port_id
argument_list|,
name|pf_id
argument_list|,
name|num_pf_cids
argument_list|,
name|num_tids
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Map Tx PQs */
name|ecore_tx_pq_map_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|port_id
argument_list|,
name|pf_id
argument_list|,
name|max_phys_tcs_per_port
argument_list|,
name|is_first_pf
argument_list|,
name|num_pf_cids
argument_list|,
name|num_vf_cids
argument_list|,
name|start_pq
argument_list|,
name|num_pf_pqs
argument_list|,
name|num_vf_pqs
argument_list|,
name|start_vport
argument_list|,
name|other_mem_size_4kb
argument_list|,
name|pq_params
argument_list|,
name|vport_params
argument_list|)
expr_stmt|;
comment|/* Init PF WFQ */
if|if
condition|(
name|pf_wfq
condition|)
if|if
condition|(
name|ecore_pf_wfq_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|port_id
argument_list|,
name|pf_id
argument_list|,
name|pf_wfq
argument_list|,
name|max_phys_tcs_per_port
argument_list|,
name|num_pf_pqs
operator|+
name|num_vf_pqs
argument_list|,
name|pq_params
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Init PF RL */
if|if
condition|(
name|ecore_pf_rl_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|pf_id
argument_list|,
name|pf_rl
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set VPORT WFQ */
if|if
condition|(
name|ecore_vp_wfq_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|num_vports
argument_list|,
name|vport_params
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set VPORT RL */
if|if
condition|(
name|ecore_vport_rl_rt_init
argument_list|(
name|p_hwfn
argument_list|,
name|start_vport
argument_list|,
name|num_vports
argument_list|,
name|vport_params
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ecore_init_pf_wfq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|pf_id
parameter_list|,
name|u16
name|pf_wfq
parameter_list|)
block|{
name|u32
name|inc_val
decl_stmt|;
name|inc_val
operator|=
name|QM_WFQ_INC_VAL
argument_list|(
name|pf_wfq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inc_val
operator|||
name|inc_val
operator|>
name|QM_WFQ_MAX_INC_VAL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid PF WFQ weight configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_WFQPFWEIGHT
operator|+
name|pf_id
operator|*
literal|4
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ecore_init_pf_rl
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|pf_id
parameter_list|,
name|u32
name|pf_rl
parameter_list|)
block|{
name|u32
name|inc_val
decl_stmt|;
name|inc_val
operator|=
name|QM_RL_INC_VAL
argument_list|(
name|pf_rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_val
operator|>
name|QM_RL_MAX_INC_VAL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid PF rate limit configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_RLPFCRD
operator|+
name|pf_id
operator|*
literal|4
argument_list|,
operator|(
name|u32
operator|)
name|QM_RL_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_RLPFINCVAL
operator|+
name|pf_id
operator|*
literal|4
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ecore_init_vport_wfq
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|first_tx_pq_id
index|[
name|NUM_OF_TCS
index|]
parameter_list|,
name|u16
name|vport_wfq
parameter_list|)
block|{
name|u16
name|vport_pq_id
decl_stmt|;
name|u32
name|inc_val
decl_stmt|;
name|u8
name|tc
decl_stmt|;
name|inc_val
operator|=
name|QM_WFQ_INC_VAL
argument_list|(
name|vport_wfq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inc_val
operator|||
name|inc_val
operator|>
name|QM_WFQ_MAX_INC_VAL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid VPORT WFQ weight configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_TCS
condition|;
name|tc
operator|++
control|)
block|{
name|vport_pq_id
operator|=
name|first_tx_pq_id
index|[
name|tc
index|]
expr_stmt|;
if|if
condition|(
name|vport_pq_id
operator|!=
name|QM_INVALID_PQ_ID
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_WFQVPWEIGHT
operator|+
name|vport_pq_id
operator|*
literal|4
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ecore_init_vport_rl
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|vport_id
parameter_list|,
name|u32
name|vport_rl
parameter_list|)
block|{
name|u32
name|inc_val
decl_stmt|,
name|max_qm_global_rls
init|=
name|MAX_QM_GLOBAL_RLS
decl_stmt|;
if|if
condition|(
name|vport_id
operator|>=
name|max_qm_global_rls
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid VPORT ID for rate limiter configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|inc_val
operator|=
name|QM_RL_INC_VAL
argument_list|(
name|vport_rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_val
operator|>
name|QM_RL_MAX_INC_VAL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid VPORT rate-limit configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_RLGLBLCRD
operator|+
name|vport_id
operator|*
literal|4
argument_list|,
operator|(
name|u32
operator|)
name|QM_RL_CRD_REG_SIGN_BIT
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_REG_RLGLBLINCVAL
operator|+
name|vport_id
operator|*
literal|4
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bool
name|ecore_send_qm_stop_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|is_release_cmd
parameter_list|,
name|bool
name|is_tx_pq
parameter_list|,
name|u16
name|start_pq
parameter_list|,
name|u16
name|num_pqs
parameter_list|)
block|{
name|u32
name|cmd_arr
index|[
name|QM_CMD_STRUCT_SIZE
argument_list|(
name|QM_STOP_CMD
argument_list|)
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|pq_mask
init|=
literal|0
decl_stmt|,
name|last_pq
decl_stmt|,
name|pq_id
decl_stmt|;
name|last_pq
operator|=
name|start_pq
operator|+
name|num_pqs
operator|-
literal|1
expr_stmt|;
comment|/* Set command's PQ type */
name|QM_CMD_SET_FIELD
argument_list|(
name|cmd_arr
argument_list|,
name|QM_STOP_CMD
argument_list|,
name|PQ_TYPE
argument_list|,
name|is_tx_pq
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Go over requested PQs */
for|for
control|(
name|pq_id
operator|=
name|start_pq
init|;
name|pq_id
operator|<=
name|last_pq
condition|;
name|pq_id
operator|++
control|)
block|{
comment|/* Set PQ bit in mask (stop command only) */
if|if
condition|(
operator|!
name|is_release_cmd
condition|)
name|pq_mask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pq_id
operator|%
name|QM_STOP_PQ_MASK_WIDTH
operator|)
operator|)
expr_stmt|;
comment|/* If last PQ or end of PQ mask, write command */
if|if
condition|(
operator|(
name|pq_id
operator|==
name|last_pq
operator|)
operator|||
operator|(
name|pq_id
operator|%
name|QM_STOP_PQ_MASK_WIDTH
operator|==
operator|(
name|QM_STOP_PQ_MASK_WIDTH
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|QM_CMD_SET_FIELD
argument_list|(
name|cmd_arr
argument_list|,
operator|(
name|u32
operator|)
name|QM_STOP_CMD
argument_list|,
name|PAUSE_MASK
argument_list|,
name|pq_mask
argument_list|)
expr_stmt|;
name|QM_CMD_SET_FIELD
argument_list|(
name|cmd_arr
argument_list|,
name|QM_STOP_CMD
argument_list|,
name|GROUP_ID
argument_list|,
name|pq_id
operator|/
name|QM_STOP_PQ_MASK_WIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecore_send_qm_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|QM_STOP_CMD_ADDR
argument_list|,
name|cmd_arr
index|[
literal|0
index|]
argument_list|,
name|cmd_arr
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|false
return|;
name|pq_mask
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED_HSI_FUNC
end_ifndef

begin_comment
comment|/* NIG: ETS configuration constants */
end_comment

begin_define
define|#
directive|define
name|NIG_TX_ETS_CLIENT_OFFSET
value|4
end_define

begin_define
define|#
directive|define
name|NIG_LB_ETS_CLIENT_OFFSET
value|1
end_define

begin_define
define|#
directive|define
name|NIG_ETS_MIN_WFQ_BYTES
value|1600
end_define

begin_comment
comment|/* NIG: ETS constants */
end_comment

begin_define
define|#
directive|define
name|NIG_ETS_UP_BOUND
parameter_list|(
name|weight
parameter_list|,
name|mtu
parameter_list|)
value|(2 * ((weight)> (mtu) ? (weight) : (mtu)))
end_define

begin_comment
comment|/* NIG: RL constants */
end_comment

begin_comment
comment|/* Byte base type value */
end_comment

begin_define
define|#
directive|define
name|NIG_RL_BASE_TYPE
value|1
end_define

begin_comment
comment|/* Period in us */
end_comment

begin_define
define|#
directive|define
name|NIG_RL_PERIOD
value|1
end_define

begin_comment
comment|/* Period in 25MHz cycles */
end_comment

begin_define
define|#
directive|define
name|NIG_RL_PERIOD_CLK_25M
value|(25 * NIG_RL_PERIOD)
end_define

begin_comment
comment|/* Rate in mbps */
end_comment

begin_define
define|#
directive|define
name|NIG_RL_INC_VAL
parameter_list|(
name|rate
parameter_list|)
value|(((rate) * NIG_RL_PERIOD) / 8)
end_define

begin_define
define|#
directive|define
name|NIG_RL_MAX_VAL
parameter_list|(
name|inc_val
parameter_list|,
name|mtu
parameter_list|)
value|(2 * ((inc_val)> (mtu) ? (inc_val) : (mtu)))
end_define

begin_comment
comment|/* NIG: packet prioritry configuration constants */
end_comment

begin_define
define|#
directive|define
name|NIG_PRIORITY_MAP_TC_BITS
value|4
end_define

begin_function
name|void
name|ecore_init_nig_ets
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|init_ets_req
modifier|*
name|req
parameter_list|,
name|bool
name|is_lb
parameter_list|)
block|{
name|u32
name|min_weight
decl_stmt|,
name|tc_weight_base_addr
decl_stmt|,
name|tc_weight_addr_diff
decl_stmt|;
name|u32
name|tc_bound_base_addr
decl_stmt|,
name|tc_bound_addr_diff
decl_stmt|;
name|u8
name|sp_tc_map
init|=
literal|0
decl_stmt|,
name|wfq_tc_map
init|=
literal|0
decl_stmt|;
name|u8
name|tc
decl_stmt|,
name|num_tc
decl_stmt|,
name|tc_client_offset
decl_stmt|;
name|num_tc
operator|=
name|is_lb
condition|?
name|NUM_OF_TCS
else|:
name|NUM_OF_PHYS_TCS
expr_stmt|;
name|tc_client_offset
operator|=
name|is_lb
condition|?
name|NIG_LB_ETS_CLIENT_OFFSET
else|:
name|NIG_TX_ETS_CLIENT_OFFSET
expr_stmt|;
name|min_weight
operator|=
literal|0xffffffff
expr_stmt|;
name|tc_weight_base_addr
operator|=
name|is_lb
condition|?
name|NIG_REG_LB_ARB_CREDIT_WEIGHT_0
else|:
name|NIG_REG_TX_ARB_CREDIT_WEIGHT_0
expr_stmt|;
name|tc_weight_addr_diff
operator|=
name|is_lb
condition|?
name|NIG_REG_LB_ARB_CREDIT_WEIGHT_1
operator|-
name|NIG_REG_LB_ARB_CREDIT_WEIGHT_0
else|:
name|NIG_REG_TX_ARB_CREDIT_WEIGHT_1
operator|-
name|NIG_REG_TX_ARB_CREDIT_WEIGHT_0
expr_stmt|;
name|tc_bound_base_addr
operator|=
name|is_lb
condition|?
name|NIG_REG_LB_ARB_CREDIT_UPPER_BOUND_0
else|:
name|NIG_REG_TX_ARB_CREDIT_UPPER_BOUND_0
expr_stmt|;
name|tc_bound_addr_diff
operator|=
name|is_lb
condition|?
name|NIG_REG_LB_ARB_CREDIT_UPPER_BOUND_1
operator|-
name|NIG_REG_LB_ARB_CREDIT_UPPER_BOUND_0
else|:
name|NIG_REG_TX_ARB_CREDIT_UPPER_BOUND_1
operator|-
name|NIG_REG_TX_ARB_CREDIT_UPPER_BOUND_0
expr_stmt|;
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|num_tc
condition|;
name|tc
operator|++
control|)
block|{
name|struct
name|init_ets_tc_req
modifier|*
name|tc_req
init|=
operator|&
name|req
operator|->
name|tc_req
index|[
name|tc
index|]
decl_stmt|;
comment|/* Update SP map */
if|if
condition|(
name|tc_req
operator|->
name|use_sp
condition|)
name|sp_tc_map
operator||=
operator|(
literal|1
operator|<<
name|tc
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|tc_req
operator|->
name|use_wfq
condition|)
continue|continue;
comment|/* Update WFQ map */
name|wfq_tc_map
operator||=
operator|(
literal|1
operator|<<
name|tc
operator|)
expr_stmt|;
comment|/* Find minimal weight */
if|if
condition|(
name|tc_req
operator|->
name|weight
operator|<
name|min_weight
condition|)
name|min_weight
operator|=
name|tc_req
operator|->
name|weight
expr_stmt|;
block|}
comment|/* Write SP map */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|is_lb
condition|?
name|NIG_REG_LB_ARB_CLIENT_IS_STRICT
else|:
name|NIG_REG_TX_ARB_CLIENT_IS_STRICT
argument_list|,
operator|(
name|sp_tc_map
operator|<<
name|tc_client_offset
operator|)
argument_list|)
expr_stmt|;
comment|/* Write WFQ map */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|is_lb
condition|?
name|NIG_REG_LB_ARB_CLIENT_IS_SUBJECT2WFQ
else|:
name|NIG_REG_TX_ARB_CLIENT_IS_SUBJECT2WFQ
argument_list|,
operator|(
name|wfq_tc_map
operator|<<
name|tc_client_offset
operator|)
argument_list|)
expr_stmt|;
comment|/* Write WFQ weights */
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|num_tc
condition|;
name|tc
operator|++
operator|,
name|tc_client_offset
operator|++
control|)
block|{
name|struct
name|init_ets_tc_req
modifier|*
name|tc_req
init|=
operator|&
name|req
operator|->
name|tc_req
index|[
name|tc
index|]
decl_stmt|;
name|u32
name|byte_weight
decl_stmt|;
if|if
condition|(
operator|!
name|tc_req
operator|->
name|use_wfq
condition|)
continue|continue;
comment|/* Translate weight to bytes */
name|byte_weight
operator|=
operator|(
name|NIG_ETS_MIN_WFQ_BYTES
operator|*
name|tc_req
operator|->
name|weight
operator|)
operator|/
name|min_weight
expr_stmt|;
comment|/* Write WFQ weight */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|tc_weight_base_addr
operator|+
name|tc_weight_addr_diff
operator|*
name|tc_client_offset
argument_list|,
name|byte_weight
argument_list|)
expr_stmt|;
comment|/* Write WFQ upper bound */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|tc_bound_base_addr
operator|+
name|tc_bound_addr_diff
operator|*
name|tc_client_offset
argument_list|,
name|NIG_ETS_UP_BOUND
argument_list|(
name|byte_weight
argument_list|,
name|req
operator|->
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_nig_lb_rl
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|init_nig_lb_rl_req
modifier|*
name|req
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|,
name|inc_val
decl_stmt|,
name|reg_offset
decl_stmt|;
name|u8
name|tc
decl_stmt|;
comment|/* Disable global MAC+LB RL */
name|ctrl
operator|=
name|NIG_RL_BASE_TYPE
operator|<<
name|NIG_REG_TX_LB_GLBRATELIMIT_CTRL_TX_LB_GLBRATELIMIT_BASE_TYPE_SHIFT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_TX_LB_GLBRATELIMIT_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure and enable global MAC+LB RL */
if|if
condition|(
name|req
operator|->
name|lb_mac_rate
condition|)
block|{
comment|/* Configure  */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_TX_LB_GLBRATELIMIT_INC_PERIOD
argument_list|,
name|NIG_RL_PERIOD_CLK_25M
argument_list|)
expr_stmt|;
name|inc_val
operator|=
name|NIG_RL_INC_VAL
argument_list|(
name|req
operator|->
name|lb_mac_rate
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_TX_LB_GLBRATELIMIT_INC_VALUE
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_TX_LB_GLBRATELIMIT_MAX_VALUE
argument_list|,
name|NIG_RL_MAX_VAL
argument_list|(
name|inc_val
argument_list|,
name|req
operator|->
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable */
name|ctrl
operator||=
literal|1
operator|<<
name|NIG_REG_TX_LB_GLBRATELIMIT_CTRL_TX_LB_GLBRATELIMIT_EN_SHIFT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_TX_LB_GLBRATELIMIT_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Disable global LB-only RL */
name|ctrl
operator|=
name|NIG_RL_BASE_TYPE
operator|<<
name|NIG_REG_LB_BRBRATELIMIT_CTRL_LB_BRBRATELIMIT_BASE_TYPE_SHIFT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_BRBRATELIMIT_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure and enable global LB-only RL */
if|if
condition|(
name|req
operator|->
name|lb_rate
condition|)
block|{
comment|/* Configure  */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_BRBRATELIMIT_INC_PERIOD
argument_list|,
name|NIG_RL_PERIOD_CLK_25M
argument_list|)
expr_stmt|;
name|inc_val
operator|=
name|NIG_RL_INC_VAL
argument_list|(
name|req
operator|->
name|lb_rate
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_BRBRATELIMIT_INC_VALUE
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_BRBRATELIMIT_MAX_VALUE
argument_list|,
name|NIG_RL_MAX_VAL
argument_list|(
name|inc_val
argument_list|,
name|req
operator|->
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable */
name|ctrl
operator||=
literal|1
operator|<<
name|NIG_REG_LB_BRBRATELIMIT_CTRL_LB_BRBRATELIMIT_EN_SHIFT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_BRBRATELIMIT_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Per-TC RLs */
for|for
control|(
name|tc
operator|=
literal|0
operator|,
name|reg_offset
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_PHYS_TCS
condition|;
name|tc
operator|++
operator|,
name|reg_offset
operator|+=
literal|4
control|)
block|{
comment|/* Disable TC RL */
name|ctrl
operator|=
name|NIG_RL_BASE_TYPE
operator|<<
name|NIG_REG_LB_TCRATELIMIT_CTRL_0_LB_TCRATELIMIT_BASE_TYPE_0_SHIFT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_TCRATELIMIT_CTRL_0
operator|+
name|reg_offset
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure and enable TC RL */
if|if
condition|(
operator|!
name|req
operator|->
name|tc_rate
index|[
name|tc
index|]
condition|)
continue|continue;
comment|/* Configure */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_TCRATELIMIT_INC_PERIOD_0
operator|+
name|reg_offset
argument_list|,
name|NIG_RL_PERIOD_CLK_25M
argument_list|)
expr_stmt|;
name|inc_val
operator|=
name|NIG_RL_INC_VAL
argument_list|(
name|req
operator|->
name|tc_rate
index|[
name|tc
index|]
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_TCRATELIMIT_INC_VALUE_0
operator|+
name|reg_offset
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_TCRATELIMIT_MAX_VALUE_0
operator|+
name|reg_offset
argument_list|,
name|NIG_RL_MAX_VAL
argument_list|(
name|inc_val
argument_list|,
name|req
operator|->
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable */
name|ctrl
operator||=
literal|1
operator|<<
name|NIG_REG_LB_TCRATELIMIT_CTRL_0_LB_TCRATELIMIT_EN_0_SHIFT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LB_TCRATELIMIT_CTRL_0
operator|+
name|reg_offset
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_nig_pri_tc_map
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|init_nig_pri_tc_map_req
modifier|*
name|req
parameter_list|)
block|{
name|u8
name|tc_pri_mask
index|[
name|NUM_OF_PHYS_TCS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|pri_tc_mask
init|=
literal|0
decl_stmt|;
name|u8
name|pri
decl_stmt|,
name|tc
decl_stmt|;
for|for
control|(
name|pri
operator|=
literal|0
init|;
name|pri
operator|<
name|NUM_OF_VLAN_PRIORITIES
condition|;
name|pri
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|req
operator|->
name|pri
index|[
name|pri
index|]
operator|.
name|valid
condition|)
continue|continue;
name|pri_tc_mask
operator||=
operator|(
name|req
operator|->
name|pri
index|[
name|pri
index|]
operator|.
name|tc_id
operator|<<
operator|(
name|pri
operator|*
name|NIG_PRIORITY_MAP_TC_BITS
operator|)
operator|)
expr_stmt|;
name|tc_pri_mask
index|[
name|req
operator|->
name|pri
index|[
name|pri
index|]
operator|.
name|tc_id
index|]
operator||=
operator|(
literal|1
operator|<<
name|pri
operator|)
expr_stmt|;
block|}
comment|/* Write priority -> TC mask */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_PKT_PRIORITY_TO_TC
argument_list|,
name|pri_tc_mask
argument_list|)
expr_stmt|;
comment|/* Write TC -> priority mask */
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_PHYS_TCS
condition|;
name|tc
operator|++
control|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_PRIORITY_FOR_TC_0
operator|+
name|tc
operator|*
literal|4
argument_list|,
name|tc_pri_mask
index|[
name|tc
index|]
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_RX_TC0_PRIORITY_MASK
operator|+
name|tc
operator|*
literal|4
argument_list|,
name|tc_pri_mask
index|[
name|tc
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED_HSI_FUNC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED_HSI_FUNC
end_ifndef

begin_comment
comment|/* PRS: ETS configuration constants */
end_comment

begin_define
define|#
directive|define
name|PRS_ETS_MIN_WFQ_BYTES
value|1600
end_define

begin_define
define|#
directive|define
name|PRS_ETS_UP_BOUND
parameter_list|(
name|weight
parameter_list|,
name|mtu
parameter_list|)
value|(2 * ((weight)> (mtu) ? (weight) : (mtu)))
end_define

begin_function
name|void
name|ecore_init_prs_ets
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|init_ets_req
modifier|*
name|req
parameter_list|)
block|{
name|u32
name|tc_weight_addr_diff
decl_stmt|,
name|tc_bound_addr_diff
decl_stmt|,
name|min_weight
init|=
literal|0xffffffff
decl_stmt|;
name|u8
name|tc
decl_stmt|,
name|sp_tc_map
init|=
literal|0
decl_stmt|,
name|wfq_tc_map
init|=
literal|0
decl_stmt|;
name|tc_weight_addr_diff
operator|=
name|PRS_REG_ETS_ARB_CREDIT_WEIGHT_1
operator|-
name|PRS_REG_ETS_ARB_CREDIT_WEIGHT_0
expr_stmt|;
name|tc_bound_addr_diff
operator|=
name|PRS_REG_ETS_ARB_CREDIT_UPPER_BOUND_1
operator|-
name|PRS_REG_ETS_ARB_CREDIT_UPPER_BOUND_0
expr_stmt|;
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_TCS
condition|;
name|tc
operator|++
control|)
block|{
name|struct
name|init_ets_tc_req
modifier|*
name|tc_req
init|=
operator|&
name|req
operator|->
name|tc_req
index|[
name|tc
index|]
decl_stmt|;
comment|/* Update SP map */
if|if
condition|(
name|tc_req
operator|->
name|use_sp
condition|)
name|sp_tc_map
operator||=
operator|(
literal|1
operator|<<
name|tc
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|tc_req
operator|->
name|use_wfq
condition|)
continue|continue;
comment|/* Update WFQ map */
name|wfq_tc_map
operator||=
operator|(
literal|1
operator|<<
name|tc
operator|)
expr_stmt|;
comment|/* Find minimal weight */
if|if
condition|(
name|tc_req
operator|->
name|weight
operator|<
name|min_weight
condition|)
name|min_weight
operator|=
name|tc_req
operator|->
name|weight
expr_stmt|;
block|}
comment|/* Write SP map */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ETS_ARB_CLIENT_IS_STRICT
argument_list|,
name|sp_tc_map
argument_list|)
expr_stmt|;
comment|/* Write WFQ map */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ
argument_list|,
name|wfq_tc_map
argument_list|)
expr_stmt|;
comment|/* Write WFQ weights */
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_TCS
condition|;
name|tc
operator|++
control|)
block|{
name|struct
name|init_ets_tc_req
modifier|*
name|tc_req
init|=
operator|&
name|req
operator|->
name|tc_req
index|[
name|tc
index|]
decl_stmt|;
name|u32
name|byte_weight
decl_stmt|;
if|if
condition|(
operator|!
name|tc_req
operator|->
name|use_wfq
condition|)
continue|continue;
comment|/* Translate weight to bytes */
name|byte_weight
operator|=
operator|(
name|PRS_ETS_MIN_WFQ_BYTES
operator|*
name|tc_req
operator|->
name|weight
operator|)
operator|/
name|min_weight
expr_stmt|;
comment|/* Write WFQ weight */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ETS_ARB_CREDIT_WEIGHT_0
operator|+
name|tc
operator|*
name|tc_weight_addr_diff
argument_list|,
name|byte_weight
argument_list|)
expr_stmt|;
comment|/* Write WFQ upper bound */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ETS_ARB_CREDIT_UPPER_BOUND_0
operator|+
name|tc
operator|*
name|tc_bound_addr_diff
argument_list|,
name|PRS_ETS_UP_BOUND
argument_list|(
name|byte_weight
argument_list|,
name|req
operator|->
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED_HSI_FUNC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED_HSI_FUNC
end_ifndef

begin_comment
comment|/* BRB: RAM configuration constants */
end_comment

begin_define
define|#
directive|define
name|BRB_TOTAL_RAM_BLOCKS_BB
value|4800
end_define

begin_define
define|#
directive|define
name|BRB_TOTAL_RAM_BLOCKS_K2
value|5632
end_define

begin_define
define|#
directive|define
name|BRB_BLOCK_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|BRB_MIN_BLOCKS_PER_TC
value|9
end_define

begin_define
define|#
directive|define
name|BRB_HYST_BYTES
value|10240
end_define

begin_define
define|#
directive|define
name|BRB_HYST_BLOCKS
value|(BRB_HYST_BYTES / BRB_BLOCK_SIZE)
end_define

begin_comment
comment|/* Temporary big RAM allocation - should be updated */
end_comment

begin_function
name|void
name|ecore_init_brb_ram
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|init_brb_ram_req
modifier|*
name|req
parameter_list|)
block|{
name|u32
name|tc_headroom_blocks
decl_stmt|,
name|min_pkt_size_blocks
decl_stmt|,
name|total_blocks
decl_stmt|;
name|u32
name|active_port_blocks
decl_stmt|,
name|reg_offset
init|=
literal|0
decl_stmt|;
name|u8
name|port
decl_stmt|,
name|active_ports
init|=
literal|0
decl_stmt|;
name|tc_headroom_blocks
operator|=
operator|(
name|u32
operator|)
name|DIV_ROUND_UP
argument_list|(
name|req
operator|->
name|headroom_per_tc
argument_list|,
name|BRB_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|min_pkt_size_blocks
operator|=
operator|(
name|u32
operator|)
name|DIV_ROUND_UP
argument_list|(
name|req
operator|->
name|min_pkt_size
argument_list|,
name|BRB_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|total_blocks
operator|=
name|ECORE_IS_K2
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|?
name|BRB_TOTAL_RAM_BLOCKS_K2
else|:
name|BRB_TOTAL_RAM_BLOCKS_BB
expr_stmt|;
comment|/* Find number of active ports */
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|MAX_NUM_PORTS
condition|;
name|port
operator|++
control|)
if|if
condition|(
name|req
operator|->
name|num_active_tcs
index|[
name|port
index|]
condition|)
name|active_ports
operator|++
expr_stmt|;
name|active_port_blocks
operator|=
call|(
name|u32
call|)
argument_list|(
name|total_blocks
operator|/
name|active_ports
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|req
operator|->
name|max_ports_per_engine
condition|;
name|port
operator|++
control|)
block|{
name|u32
name|port_blocks
decl_stmt|,
name|port_shared_blocks
decl_stmt|,
name|port_guaranteed_blocks
decl_stmt|;
name|u32
name|full_xoff_th
decl_stmt|,
name|full_xon_th
decl_stmt|,
name|pause_xoff_th
decl_stmt|,
name|pause_xon_th
decl_stmt|;
name|u32
name|tc_guaranteed_blocks
decl_stmt|;
name|u8
name|tc
decl_stmt|;
comment|/* Calculate per-port sizes */
name|tc_guaranteed_blocks
operator|=
operator|(
name|u32
operator|)
name|DIV_ROUND_UP
argument_list|(
name|req
operator|->
name|guranteed_per_tc
argument_list|,
name|BRB_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|port_blocks
operator|=
name|req
operator|->
name|num_active_tcs
index|[
name|port
index|]
condition|?
name|active_port_blocks
else|:
literal|0
expr_stmt|;
name|port_guaranteed_blocks
operator|=
name|req
operator|->
name|num_active_tcs
index|[
name|port
index|]
operator|*
name|tc_guaranteed_blocks
expr_stmt|;
name|port_shared_blocks
operator|=
name|port_blocks
operator|-
name|port_guaranteed_blocks
expr_stmt|;
name|full_xoff_th
operator|=
name|req
operator|->
name|num_active_tcs
index|[
name|port
index|]
operator|*
name|BRB_MIN_BLOCKS_PER_TC
expr_stmt|;
name|full_xon_th
operator|=
name|full_xoff_th
operator|+
name|min_pkt_size_blocks
expr_stmt|;
name|pause_xoff_th
operator|=
name|tc_headroom_blocks
expr_stmt|;
name|pause_xon_th
operator|=
name|pause_xoff_th
operator|+
name|min_pkt_size_blocks
expr_stmt|;
comment|/* Init total size per port */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_TOTAL_MAC_SIZE
operator|+
name|port
operator|*
literal|4
argument_list|,
name|port_blocks
argument_list|)
expr_stmt|;
comment|/* Init shared size per port */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_SHARED_HR_AREA
operator|+
name|port
operator|*
literal|4
argument_list|,
name|port_shared_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|NUM_OF_TCS
condition|;
name|tc
operator|++
operator|,
name|reg_offset
operator|+=
literal|4
control|)
block|{
comment|/* Clear init values for non-active TCs */
if|if
condition|(
name|tc
operator|==
name|req
operator|->
name|num_active_tcs
index|[
name|port
index|]
condition|)
block|{
name|tc_guaranteed_blocks
operator|=
literal|0
expr_stmt|;
name|full_xoff_th
operator|=
literal|0
expr_stmt|;
name|full_xon_th
operator|=
literal|0
expr_stmt|;
name|pause_xoff_th
operator|=
literal|0
expr_stmt|;
name|pause_xon_th
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Init guaranteed size per TC */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_TC_GUARANTIED_0
operator|+
name|reg_offset
argument_list|,
name|tc_guaranteed_blocks
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_MAIN_TC_GUARANTIED_HYST_0
operator|+
name|reg_offset
argument_list|,
name|BRB_HYST_BLOCKS
argument_list|)
expr_stmt|;
comment|/* Init pause/full thresholds per physical TC - for 			 * loopback traffic. 			 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_LB_TC_FULL_XOFF_THRESHOLD_0
operator|+
name|reg_offset
argument_list|,
name|full_xoff_th
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_LB_TC_FULL_XON_THRESHOLD_0
operator|+
name|reg_offset
argument_list|,
name|full_xon_th
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_LB_TC_PAUSE_XOFF_THRESHOLD_0
operator|+
name|reg_offset
argument_list|,
name|pause_xoff_th
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_LB_TC_PAUSE_XON_THRESHOLD_0
operator|+
name|reg_offset
argument_list|,
name|pause_xon_th
argument_list|)
expr_stmt|;
comment|/* Init pause/full thresholds per physical TC - for 			 * main traffic. 			 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_MAIN_TC_FULL_XOFF_THRESHOLD_0
operator|+
name|reg_offset
argument_list|,
name|full_xoff_th
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_MAIN_TC_FULL_XON_THRESHOLD_0
operator|+
name|reg_offset
argument_list|,
name|full_xon_th
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_MAIN_TC_PAUSE_XOFF_THRESHOLD_0
operator|+
name|reg_offset
argument_list|,
name|pause_xoff_th
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|BRB_REG_MAIN_TC_PAUSE_XON_THRESHOLD_0
operator|+
name|reg_offset
argument_list|,
name|pause_xon_th
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED_HSI_FUNC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED_HSI_FUNC
end_ifndef

begin_comment
comment|/* In MF, should be called once per engine to set EtherType of OuterTag */
end_comment

begin_function
name|void
name|ecore_set_engine_mf_ovlan_eth_type
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|ethType
parameter_list|)
block|{
comment|/* Update PRS register */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PRS_REG_TAG_ETHERTYPE_0_RT_OFFSET
argument_list|,
name|ethType
argument_list|)
expr_stmt|;
comment|/* Update NIG register */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|NIG_REG_TAG_ETHERTYPE_0_RT_OFFSET
argument_list|,
name|ethType
argument_list|)
expr_stmt|;
comment|/* Update PBF register */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PBF_REG_TAG_ETHERTYPE_0_RT_OFFSET
argument_list|,
name|ethType
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In MF, should be called once per port to set EtherType of OuterTag */
end_comment

begin_function
name|void
name|ecore_set_port_mf_ovlan_eth_type
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|ethType
parameter_list|)
block|{
comment|/* Update DORQ register */
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|DORQ_REG_TAG1_ETHERTYPE_RT_OFFSET
argument_list|,
name|ethType
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED_HSI_FUNC */
end_comment

begin_define
define|#
directive|define
name|SET_TUNNEL_TYPE_ENABLE_BIT
parameter_list|(
name|var
parameter_list|,
name|offset
parameter_list|,
name|enable
parameter_list|)
value|var = ((var)& ~(1<< (offset))) | ( (enable) ? (1<< (offset)) : 0)
end_define

begin_define
define|#
directive|define
name|PRS_ETH_TUNN_FIC_FORMAT
value|-188897008
end_define

begin_function
name|void
name|ecore_set_vxlan_dest_port
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|dest_port
parameter_list|)
block|{
comment|/* Update PRS register */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_VXLAN_PORT
argument_list|,
name|dest_port
argument_list|)
expr_stmt|;
comment|/* Update NIG register */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_VXLAN_CTRL
argument_list|,
name|dest_port
argument_list|)
expr_stmt|;
comment|/* Update PBF register */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PBF_REG_VXLAN_PORT
argument_list|,
name|dest_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_set_vxlan_enable
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|vxlan_enable
parameter_list|)
block|{
name|u32
name|reg_val
decl_stmt|;
comment|/* Update PRS register */
name|reg_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN
argument_list|)
expr_stmt|;
name|SET_TUNNEL_TYPE_ENABLE_BIT
argument_list|(
name|reg_val
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN_VXLAN_ENABLE_SHIFT
argument_list|,
name|vxlan_enable
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
condition|)
comment|/* TODO: handle E5 init */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_OUTPUT_FORMAT_4_0_BB_K2
argument_list|,
operator|(
name|u32
operator|)
name|PRS_ETH_TUNN_FIC_FORMAT
argument_list|)
expr_stmt|;
comment|/* Update NIG register */
name|reg_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_ENC_TYPE_ENABLE
argument_list|)
expr_stmt|;
name|SET_TUNNEL_TYPE_ENABLE_BIT
argument_list|(
name|reg_val
argument_list|,
name|NIG_REG_ENC_TYPE_ENABLE_VXLAN_ENABLE_SHIFT
argument_list|,
name|vxlan_enable
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_ENC_TYPE_ENABLE
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Update DORQ register */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_L2_EDPM_TUNNEL_VXLAN_EN
argument_list|,
name|vxlan_enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_set_gre_enable
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|eth_gre_enable
parameter_list|,
name|bool
name|ip_gre_enable
parameter_list|)
block|{
name|u32
name|reg_val
decl_stmt|;
comment|/* Update PRS register */
name|reg_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN
argument_list|)
expr_stmt|;
name|SET_TUNNEL_TYPE_ENABLE_BIT
argument_list|(
name|reg_val
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN_ETH_OVER_GRE_ENABLE_SHIFT
argument_list|,
name|eth_gre_enable
argument_list|)
expr_stmt|;
name|SET_TUNNEL_TYPE_ENABLE_BIT
argument_list|(
name|reg_val
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN_IP_OVER_GRE_ENABLE_SHIFT
argument_list|,
name|ip_gre_enable
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
condition|)
comment|/* TODO: handle E5 init */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_OUTPUT_FORMAT_4_0_BB_K2
argument_list|,
operator|(
name|u32
operator|)
name|PRS_ETH_TUNN_FIC_FORMAT
argument_list|)
expr_stmt|;
comment|/* Update NIG register */
name|reg_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_ENC_TYPE_ENABLE
argument_list|)
expr_stmt|;
name|SET_TUNNEL_TYPE_ENABLE_BIT
argument_list|(
name|reg_val
argument_list|,
name|NIG_REG_ENC_TYPE_ENABLE_ETH_OVER_GRE_ENABLE_SHIFT
argument_list|,
name|eth_gre_enable
argument_list|)
expr_stmt|;
name|SET_TUNNEL_TYPE_ENABLE_BIT
argument_list|(
name|reg_val
argument_list|,
name|NIG_REG_ENC_TYPE_ENABLE_IP_OVER_GRE_ENABLE_SHIFT
argument_list|,
name|ip_gre_enable
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_ENC_TYPE_ENABLE
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Update DORQ registers */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_L2_EDPM_TUNNEL_GRE_ETH_EN
argument_list|,
name|eth_gre_enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_L2_EDPM_TUNNEL_GRE_IP_EN
argument_list|,
name|ip_gre_enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_set_geneve_dest_port
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|dest_port
parameter_list|)
block|{
comment|/* Update PRS register */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_NGE_PORT
argument_list|,
name|dest_port
argument_list|)
expr_stmt|;
comment|/* Update NIG register */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_NGE_PORT
argument_list|,
name|dest_port
argument_list|)
expr_stmt|;
comment|/* Update PBF register */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PBF_REG_NGE_PORT
argument_list|,
name|dest_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_set_geneve_enable
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|eth_geneve_enable
parameter_list|,
name|bool
name|ip_geneve_enable
parameter_list|)
block|{
name|u32
name|reg_val
decl_stmt|;
comment|/* Update PRS register */
name|reg_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN
argument_list|)
expr_stmt|;
name|SET_TUNNEL_TYPE_ENABLE_BIT
argument_list|(
name|reg_val
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN_ETH_OVER_GENEVE_ENABLE_SHIFT
argument_list|,
name|eth_geneve_enable
argument_list|)
expr_stmt|;
name|SET_TUNNEL_TYPE_ENABLE_BIT
argument_list|(
name|reg_val
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN_IP_OVER_GENEVE_ENABLE_SHIFT
argument_list|,
name|ip_geneve_enable
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_ENCAPSULATION_TYPE_EN
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
condition|)
comment|/* TODO: handle E5 init */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_OUTPUT_FORMAT_4_0_BB_K2
argument_list|,
operator|(
name|u32
operator|)
name|PRS_ETH_TUNN_FIC_FORMAT
argument_list|)
expr_stmt|;
comment|/* Update NIG register */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_NGE_ETH_ENABLE
argument_list|,
name|eth_geneve_enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_NGE_IP_ENABLE
argument_list|,
name|ip_geneve_enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* EDPM with geneve tunnel not supported in BB */
if|if
condition|(
name|ECORE_IS_BB_B0
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return;
comment|/* Update DORQ registers */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_L2_EDPM_TUNNEL_NGE_ETH_EN_K2_E5
argument_list|,
name|eth_geneve_enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DORQ_REG_L2_EDPM_TUNNEL_NGE_IP_EN_K2_E5
argument_list|,
name|ip_geneve_enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED_HSI_FUNC
end_ifndef

begin_define
define|#
directive|define
name|T_ETH_PACKET_ACTION_GFT_EVENTID
value|23
end_define

begin_define
define|#
directive|define
name|PARSER_ETH_CONN_GFT_ACTION_CM_HDR
value|272
end_define

begin_define
define|#
directive|define
name|T_ETH_PACKET_MATCH_RFS_EVENTID
value|25
end_define

begin_define
define|#
directive|define
name|PARSER_ETH_CONN_CM_HDR
value|0
end_define

begin_define
define|#
directive|define
name|CAM_LINE_SIZE
value|sizeof(u32)
end_define

begin_define
define|#
directive|define
name|RAM_LINE_SIZE
value|sizeof(u64)
end_define

begin_define
define|#
directive|define
name|REG_SIZE
value|sizeof(u32)
end_define

begin_function
name|void
name|ecore_set_rfs_mode_disable
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|pf_id
parameter_list|)
block|{
name|union
name|gft_cam_line_union
name|cam_line
decl_stmt|;
name|struct
name|gft_ram_line
name|ram_line
decl_stmt|;
name|u32
name|i
decl_stmt|,
modifier|*
name|ram_line_ptr
decl_stmt|;
name|ram_line_ptr
operator|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|ram_line
expr_stmt|;
comment|/* Stop using gft logic, disable gft search */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_GFT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_CM_HDR_GFT
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Clean ram& cam for next rfs/gft session*/
comment|/* Zero camline */
name|OSAL_MEMSET
argument_list|(
operator|&
name|cam_line
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cam_line
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_GFT_CAM
operator|+
name|CAM_LINE_SIZE
operator|*
name|pf_id
argument_list|,
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|)
expr_stmt|;
comment|/* Zero ramline */
name|OSAL_MEMSET
argument_list|(
operator|&
name|ram_line
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ram_line
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Each iteration write to reg */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAM_LINE_SIZE
operator|/
name|REG_SIZE
condition|;
name|i
operator|++
control|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_GFT_PROFILE_MASK_RAM
operator|+
name|RAM_LINE_SIZE
operator|*
name|pf_id
operator|+
name|i
operator|*
name|REG_SIZE
argument_list|,
operator|*
operator|(
name|ram_line_ptr
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_set_gft_event_id_cm_hdr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|rfs_cm_hdr_event_id
decl_stmt|;
comment|/* Set RFS event ID to be awakened i Tstorm By Prs */
name|rfs_cm_hdr_event_id
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_CM_HDR_GFT
argument_list|)
expr_stmt|;
name|rfs_cm_hdr_event_id
operator||=
name|T_ETH_PACKET_ACTION_GFT_EVENTID
operator|<<
name|PRS_REG_CM_HDR_GFT_EVENT_ID_SHIFT
expr_stmt|;
name|rfs_cm_hdr_event_id
operator||=
name|PARSER_ETH_CONN_GFT_ACTION_CM_HDR
operator|<<
name|PRS_REG_CM_HDR_GFT_CM_HDR_SHIFT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_CM_HDR_GFT
argument_list|,
name|rfs_cm_hdr_event_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_set_rfs_mode_enable
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|pf_id
parameter_list|,
name|bool
name|tcp
parameter_list|,
name|bool
name|udp
parameter_list|,
name|bool
name|ipv4
parameter_list|,
name|bool
name|ipv6
parameter_list|)
block|{
name|u32
name|rfs_cm_hdr_event_id
decl_stmt|,
modifier|*
name|ram_line_ptr
decl_stmt|;
name|union
name|gft_cam_line_union
name|cam_line
decl_stmt|;
name|struct
name|gft_ram_line
name|ram_line
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rfs_cm_hdr_event_id
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_CM_HDR_GFT
argument_list|)
expr_stmt|;
name|ram_line_ptr
operator|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|ram_line
expr_stmt|;
if|if
condition|(
operator|!
name|ipv6
operator|&&
operator|!
name|ipv4
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"set_rfs_mode_enable: must accept at least on of - ipv4 or ipv6\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcp
operator|&&
operator|!
name|udp
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"set_rfs_mode_enable: must accept at least on of - udp or tcp\n"
argument_list|)
expr_stmt|;
comment|/* Set RFS event ID to be awakened i Tstorm By Prs */
name|rfs_cm_hdr_event_id
operator||=
name|T_ETH_PACKET_MATCH_RFS_EVENTID
operator|<<
name|PRS_REG_CM_HDR_GFT_EVENT_ID_SHIFT
expr_stmt|;
name|rfs_cm_hdr_event_id
operator||=
name|PARSER_ETH_CONN_CM_HDR
operator|<<
name|PRS_REG_CM_HDR_GFT_CM_HDR_SHIFT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_CM_HDR_GFT
argument_list|,
name|rfs_cm_hdr_event_id
argument_list|)
expr_stmt|;
comment|/* Configure Registers for RFS mode */
comment|/* Enable gft search */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_SEARCH_GFT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Do not load context only cid in PRS on match. */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_LOAD_L2_FILTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cam line is now valid!! */
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_VALID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Filters are per PF!! */
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_PF_ID_MASK
argument_list|,
name|GFT_CAM_LINE_MAPPED_PF_ID_MASK_MASK
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_PF_ID
argument_list|,
name|pf_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tcp
operator|&&
name|udp
operator|)
condition|)
block|{
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_UPPER_PROTOCOL_TYPE_MASK
argument_list|,
name|GFT_CAM_LINE_MAPPED_UPPER_PROTOCOL_TYPE_MASK_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp
condition|)
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_UPPER_PROTOCOL_TYPE
argument_list|,
name|GFT_PROFILE_TCP_PROTOCOL
argument_list|)
expr_stmt|;
else|else
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_UPPER_PROTOCOL_TYPE
argument_list|,
name|GFT_PROFILE_UDP_PROTOCOL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ipv4
operator|&&
name|ipv6
operator|)
condition|)
block|{
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_IP_VERSION_MASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipv4
condition|)
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_IP_VERSION
argument_list|,
name|GFT_PROFILE_IPV4
argument_list|)
expr_stmt|;
else|else
name|SET_FIELD
argument_list|(
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|,
name|GFT_CAM_LINE_MAPPED_IP_VERSION
argument_list|,
name|GFT_PROFILE_IPV6
argument_list|)
expr_stmt|;
block|}
comment|/* Write characteristics to cam */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_GFT_CAM
operator|+
name|CAM_LINE_SIZE
operator|*
name|pf_id
argument_list|,
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
argument_list|)
expr_stmt|;
name|cam_line
operator|.
name|cam_line_mapped
operator|.
name|camline
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_GFT_CAM
operator|+
name|CAM_LINE_SIZE
operator|*
name|pf_id
argument_list|)
expr_stmt|;
comment|/* Write line to RAM - compare to filter 4 tuple */
name|ram_line
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
name|ram_line
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ram_line
operator|.
name|hi
argument_list|,
name|GFT_RAM_LINE_DST_IP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ram_line
operator|.
name|hi
argument_list|,
name|GFT_RAM_LINE_SRC_IP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ram_line
operator|.
name|hi
argument_list|,
name|GFT_RAM_LINE_OVER_IP_PROTOCOL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ram_line
operator|.
name|lo
argument_list|,
name|GFT_RAM_LINE_ETHERTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ram_line
operator|.
name|lo
argument_list|,
name|GFT_RAM_LINE_SRC_PORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|ram_line
operator|.
name|lo
argument_list|,
name|GFT_RAM_LINE_DST_PORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Each iteration write to reg */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAM_LINE_SIZE
operator|/
name|REG_SIZE
condition|;
name|i
operator|++
control|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_GFT_PROFILE_MASK_RAM
operator|+
name|RAM_LINE_SIZE
operator|*
name|pf_id
operator|+
name|i
operator|*
name|REG_SIZE
argument_list|,
operator|*
operator|(
name|ram_line_ptr
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* Set default profile so that no filter match will happen */
name|ram_line
operator|.
name|lo
operator|=
literal|0xffffffff
expr_stmt|;
name|ram_line
operator|.
name|hi
operator|=
literal|0x3ff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RAM_LINE_SIZE
operator|/
name|REG_SIZE
condition|;
name|i
operator|++
control|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PRS_REG_GFT_PROFILE_MASK_RAM
operator|+
name|RAM_LINE_SIZE
operator|*
name|PRS_GFT_CAM_LINES_NO_MATCH
operator|+
name|i
operator|*
name|REG_SIZE
argument_list|,
operator|*
operator|(
name|ram_line_ptr
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED_HSI_FUNC */
end_comment

begin_comment
comment|/* Configure VF zone size mode*/
end_comment

begin_function
name|void
name|ecore_config_vf_zone_size_mode
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|mode
parameter_list|,
name|bool
name|runtime_init
parameter_list|)
block|{
name|u32
name|msdm_vf_size_log
init|=
name|MSTORM_VF_ZONE_DEFAULT_SIZE_LOG
decl_stmt|;
name|u32
name|msdm_vf_offset_mask
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VF_ZONE_SIZE_MODE_DOUBLE
condition|)
name|msdm_vf_size_log
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|VF_ZONE_SIZE_MODE_QUAD
condition|)
name|msdm_vf_size_log
operator|+=
literal|2
expr_stmt|;
name|msdm_vf_offset_mask
operator|=
operator|(
literal|1
operator|<<
name|msdm_vf_size_log
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|runtime_init
condition|)
block|{
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PGLUE_REG_B_MSDM_VF_SHIFT_B_RT_OFFSET
argument_list|,
name|msdm_vf_size_log
argument_list|)
expr_stmt|;
name|STORE_RT_REG
argument_list|(
name|p_hwfn
argument_list|,
name|PGLUE_REG_B_MSDM_OFFSET_MASK_B_RT_OFFSET
argument_list|,
name|msdm_vf_offset_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PGLUE_B_REG_MSDM_VF_SHIFT_B
argument_list|,
name|msdm_vf_size_log
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PGLUE_B_REG_MSDM_OFFSET_MASK_B
argument_list|,
name|msdm_vf_offset_mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get mstorm statistics for offset by VF zone size mode */
end_comment

begin_function
name|u32
name|ecore_get_mstorm_queue_stat_offset
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|stat_cnt_id
parameter_list|,
name|u16
name|vf_zone_size_mode
parameter_list|)
block|{
name|u32
name|offset
init|=
name|MSTORM_QUEUE_STAT_OFFSET
argument_list|(
name|stat_cnt_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|vf_zone_size_mode
operator|!=
name|VF_ZONE_SIZE_MODE_DEFAULT
operator|)
operator|&&
operator|(
name|stat_cnt_id
operator|>
name|MAX_NUM_PFS
operator|)
condition|)
block|{
if|if
condition|(
name|vf_zone_size_mode
operator|==
name|VF_ZONE_SIZE_MODE_DOUBLE
condition|)
name|offset
operator|+=
operator|(
literal|1
operator|<<
name|MSTORM_VF_ZONE_DEFAULT_SIZE_LOG
operator|)
operator|*
operator|(
name|stat_cnt_id
operator|-
name|MAX_NUM_PFS
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vf_zone_size_mode
operator|==
name|VF_ZONE_SIZE_MODE_QUAD
condition|)
name|offset
operator|+=
literal|3
operator|*
operator|(
literal|1
operator|<<
name|MSTORM_VF_ZONE_DEFAULT_SIZE_LOG
operator|)
operator|*
operator|(
name|stat_cnt_id
operator|-
name|MAX_NUM_PFS
operator|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Get mstorm VF producer offset by VF zone size mode */
end_comment

begin_function
name|u32
name|ecore_get_mstorm_eth_vf_prods_offset
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|vf_id
parameter_list|,
name|u8
name|vf_queue_id
parameter_list|,
name|u16
name|vf_zone_size_mode
parameter_list|)
block|{
name|u32
name|offset
init|=
name|MSTORM_ETH_VF_PRODS_OFFSET
argument_list|(
name|vf_id
argument_list|,
name|vf_queue_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|vf_zone_size_mode
operator|!=
name|VF_ZONE_SIZE_MODE_DEFAULT
condition|)
block|{
if|if
condition|(
name|vf_zone_size_mode
operator|==
name|VF_ZONE_SIZE_MODE_DOUBLE
condition|)
name|offset
operator|+=
operator|(
literal|1
operator|<<
name|MSTORM_VF_ZONE_DEFAULT_SIZE_LOG
operator|)
operator|*
name|vf_id
expr_stmt|;
elseif|else
if|if
condition|(
name|vf_zone_size_mode
operator|==
name|VF_ZONE_SIZE_MODE_QUAD
condition|)
name|offset
operator|+=
literal|3
operator|*
operator|(
literal|1
operator|<<
name|MSTORM_VF_ZONE_DEFAULT_SIZE_LOG
operator|)
operator|*
name|vf_id
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CRC8_INIT_VALUE
value|0xFF
end_define

begin_decl_stmt
specifier|static
name|u8
name|cdu_crc8_table
index|[
name|CRC8_TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calculate and return CDU validation byte per connection type/region/cid */
end_comment

begin_function
specifier|static
name|u8
name|ecore_calc_cdu_validation_byte
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|conn_type
parameter_list|,
name|u8
name|region
parameter_list|,
name|u32
name|cid
parameter_list|)
block|{
specifier|const
name|u8
name|validation_cfg
init|=
name|CDU_VALIDATION_DEFAULT_CFG
decl_stmt|;
specifier|static
name|u8
name|crc8_table_valid
decl_stmt|;
comment|/*automatically initialized to 0*/
name|u8
name|crc
decl_stmt|,
name|validation_byte
init|=
literal|0
decl_stmt|;
name|u32
name|validation_string
init|=
literal|0
decl_stmt|;
name|u32
name|data_to_crc
decl_stmt|;
if|if
condition|(
name|crc8_table_valid
operator|==
literal|0
condition|)
block|{
name|OSAL_CRC8_POPULATE
argument_list|(
name|cdu_crc8_table
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|crc8_table_valid
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The CRC is calculated on the String-to-compress: 	 * [31:8]  = {CID[31:20],CID[11:0]} 	 * [7:4]   = Region 	 * [3:0]   = Type 	 */
if|if
condition|(
operator|(
name|validation_cfg
operator|>>
name|CDU_CONTEXT_VALIDATION_CFG_USE_CID
operator|)
operator|&
literal|1
condition|)
name|validation_string
operator||=
operator|(
name|cid
operator|&
literal|0xFFF00000
operator|)
operator||
operator|(
operator|(
name|cid
operator|&
literal|0xFFF
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|validation_cfg
operator|>>
name|CDU_CONTEXT_VALIDATION_CFG_USE_REGION
operator|)
operator|&
literal|1
condition|)
name|validation_string
operator||=
operator|(
operator|(
name|region
operator|&
literal|0xF
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|validation_cfg
operator|>>
name|CDU_CONTEXT_VALIDATION_CFG_USE_TYPE
operator|)
operator|&
literal|1
condition|)
name|validation_string
operator||=
operator|(
name|conn_type
operator|&
literal|0xF
operator|)
expr_stmt|;
comment|/* Convert to big-endian and calculate CRC8*/
name|data_to_crc
operator|=
name|OSAL_BE32_TO_CPU
argument_list|(
name|validation_string
argument_list|)
expr_stmt|;
name|crc
operator|=
name|OSAL_CRC8
argument_list|(
name|cdu_crc8_table
argument_list|,
operator|(
name|u8
operator|*
operator|)
operator|&
name|data_to_crc
argument_list|,
sizeof|sizeof
argument_list|(
name|data_to_crc
argument_list|)
argument_list|,
name|CRC8_INIT_VALUE
argument_list|)
expr_stmt|;
comment|/* The validation byte [7:0] is composed: 	 * for type A validation 	 * [7]		= active configuration bit 	 * [6:0]	= crc[6:0] 	 * 	 * for type B validation 	 * [7]		= active configuration bit 	 * [6:3]	= connection_type[3:0] 	 * [2:0]	= crc[2:0] 	 */
name|validation_byte
operator||=
operator|(
operator|(
name|validation_cfg
operator|>>
name|CDU_CONTEXT_VALIDATION_CFG_USE_ACTIVE
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|validation_cfg
operator|>>
name|CDU_CONTEXT_VALIDATION_CFG_VALIDATION_TYPE_SHIFT
operator|)
operator|&
literal|1
condition|)
name|validation_byte
operator||=
operator|(
operator|(
name|conn_type
operator|&
literal|0xF
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
name|crc
operator|&
literal|0x7
operator|)
expr_stmt|;
else|else
name|validation_byte
operator||=
name|crc
operator|&
literal|0x7F
expr_stmt|;
return|return
name|validation_byte
return|;
block|}
end_function

begin_comment
comment|/* Calcualte and set validation bytes for session context */
end_comment

begin_function
name|void
name|ecore_calc_session_ctx_validation
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|void
modifier|*
name|p_ctx_mem
parameter_list|,
name|u16
name|ctx_size
parameter_list|,
name|u8
name|ctx_type
parameter_list|,
name|u32
name|cid
parameter_list|)
block|{
name|u8
modifier|*
name|x_val_ptr
decl_stmt|,
modifier|*
name|t_val_ptr
decl_stmt|,
modifier|*
name|u_val_ptr
decl_stmt|,
modifier|*
name|p_ctx
decl_stmt|;
name|p_ctx
operator|=
operator|(
name|u8
operator|*
specifier|const
operator|)
name|p_ctx_mem
expr_stmt|;
name|x_val_ptr
operator|=
operator|&
name|p_ctx
index|[
name|con_region_offsets
index|[
literal|0
index|]
index|[
name|ctx_type
index|]
index|]
expr_stmt|;
name|t_val_ptr
operator|=
operator|&
name|p_ctx
index|[
name|con_region_offsets
index|[
literal|1
index|]
index|[
name|ctx_type
index|]
index|]
expr_stmt|;
name|u_val_ptr
operator|=
operator|&
name|p_ctx
index|[
name|con_region_offsets
index|[
literal|2
index|]
index|[
name|ctx_type
index|]
index|]
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_ctx
argument_list|,
literal|0
argument_list|,
name|ctx_size
argument_list|)
expr_stmt|;
operator|*
name|x_val_ptr
operator|=
name|ecore_calc_cdu_validation_byte
argument_list|(
name|p_hwfn
argument_list|,
name|ctx_type
argument_list|,
literal|3
argument_list|,
name|cid
argument_list|)
expr_stmt|;
operator|*
name|t_val_ptr
operator|=
name|ecore_calc_cdu_validation_byte
argument_list|(
name|p_hwfn
argument_list|,
name|ctx_type
argument_list|,
literal|4
argument_list|,
name|cid
argument_list|)
expr_stmt|;
operator|*
name|u_val_ptr
operator|=
name|ecore_calc_cdu_validation_byte
argument_list|(
name|p_hwfn
argument_list|,
name|ctx_type
argument_list|,
literal|5
argument_list|,
name|cid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calcualte and set validation bytes for task context */
end_comment

begin_function
name|void
name|ecore_calc_task_ctx_validation
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|void
modifier|*
name|p_ctx_mem
parameter_list|,
name|u16
name|ctx_size
parameter_list|,
name|u8
name|ctx_type
parameter_list|,
name|u32
name|tid
parameter_list|)
block|{
name|u8
modifier|*
name|p_ctx
decl_stmt|,
modifier|*
name|region1_val_ptr
decl_stmt|;
name|p_ctx
operator|=
operator|(
name|u8
operator|*
specifier|const
operator|)
name|p_ctx_mem
expr_stmt|;
name|region1_val_ptr
operator|=
operator|&
name|p_ctx
index|[
name|task_region_offsets
index|[
literal|0
index|]
index|[
name|ctx_type
index|]
index|]
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_ctx
argument_list|,
literal|0
argument_list|,
name|ctx_size
argument_list|)
expr_stmt|;
operator|*
name|region1_val_ptr
operator|=
name|ecore_calc_cdu_validation_byte
argument_list|(
name|p_hwfn
argument_list|,
name|ctx_type
argument_list|,
literal|1
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Memset session context to 0 while preserving validation bytes */
end_comment

begin_function
name|void
name|ecore_memset_session_ctx
parameter_list|(
name|void
modifier|*
name|p_ctx_mem
parameter_list|,
name|u32
name|ctx_size
parameter_list|,
name|u8
name|ctx_type
parameter_list|)
block|{
name|u8
modifier|*
name|x_val_ptr
decl_stmt|,
modifier|*
name|t_val_ptr
decl_stmt|,
modifier|*
name|u_val_ptr
decl_stmt|,
modifier|*
name|p_ctx
decl_stmt|;
name|u8
name|x_val
decl_stmt|,
name|t_val
decl_stmt|,
name|u_val
decl_stmt|;
name|p_ctx
operator|=
operator|(
name|u8
operator|*
specifier|const
operator|)
name|p_ctx_mem
expr_stmt|;
name|x_val_ptr
operator|=
operator|&
name|p_ctx
index|[
name|con_region_offsets
index|[
literal|0
index|]
index|[
name|ctx_type
index|]
index|]
expr_stmt|;
name|t_val_ptr
operator|=
operator|&
name|p_ctx
index|[
name|con_region_offsets
index|[
literal|1
index|]
index|[
name|ctx_type
index|]
index|]
expr_stmt|;
name|u_val_ptr
operator|=
operator|&
name|p_ctx
index|[
name|con_region_offsets
index|[
literal|2
index|]
index|[
name|ctx_type
index|]
index|]
expr_stmt|;
name|x_val
operator|=
operator|*
name|x_val_ptr
expr_stmt|;
name|t_val
operator|=
operator|*
name|t_val_ptr
expr_stmt|;
name|u_val
operator|=
operator|*
name|u_val_ptr
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_ctx
argument_list|,
literal|0
argument_list|,
name|ctx_size
argument_list|)
expr_stmt|;
operator|*
name|x_val_ptr
operator|=
name|x_val
expr_stmt|;
operator|*
name|t_val_ptr
operator|=
name|t_val
expr_stmt|;
operator|*
name|u_val_ptr
operator|=
name|u_val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Memset task context to 0 while preserving validation bytes */
end_comment

begin_function
name|void
name|ecore_memset_task_ctx
parameter_list|(
name|void
modifier|*
name|p_ctx_mem
parameter_list|,
name|u32
name|ctx_size
parameter_list|,
name|u8
name|ctx_type
parameter_list|)
block|{
name|u8
modifier|*
name|p_ctx
decl_stmt|,
modifier|*
name|region1_val_ptr
decl_stmt|;
name|u8
name|region1_val
decl_stmt|;
name|p_ctx
operator|=
operator|(
name|u8
operator|*
specifier|const
operator|)
name|p_ctx_mem
expr_stmt|;
name|region1_val_ptr
operator|=
operator|&
name|p_ctx
index|[
name|task_region_offsets
index|[
literal|0
index|]
index|[
name|ctx_type
index|]
index|]
expr_stmt|;
name|region1_val
operator|=
operator|*
name|region1_val_ptr
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_ctx
argument_list|,
literal|0
argument_list|,
name|ctx_size
argument_list|)
expr_stmt|;
operator|*
name|region1_val_ptr
operator|=
name|region1_val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable and configure context validation */
end_comment

begin_function
name|void
name|ecore_enable_context_validation
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|ctx_validation
decl_stmt|;
comment|/* Enable validation for connection region 3: CCFC_CTX_VALID0[31:24] */
name|ctx_validation
operator|=
name|CDU_VALIDATION_DEFAULT_CFG
operator|<<
literal|24
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CDU_REG_CCFC_CTX_VALID0
argument_list|,
name|ctx_validation
argument_list|)
expr_stmt|;
comment|/* Enable validation for connection region 5: CCFC_CTX_VALID1[15:8] */
name|ctx_validation
operator|=
name|CDU_VALIDATION_DEFAULT_CFG
operator|<<
literal|8
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CDU_REG_CCFC_CTX_VALID1
argument_list|,
name|ctx_validation
argument_list|)
expr_stmt|;
comment|/* Enable validation for connection region 1: TCFC_CTX_VALID0[15:8] */
name|ctx_validation
operator|=
name|CDU_VALIDATION_DEFAULT_CFG
operator|<<
literal|8
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|CDU_REG_TCFC_CTX_VALID0
argument_list|,
name|ctx_validation
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

