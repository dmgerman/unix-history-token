begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * File : ecore_mcp.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bcm_osal.h"
end_include

begin_include
include|#
directive|include
file|"ecore.h"
end_include

begin_include
include|#
directive|include
file|"ecore_status.h"
end_include

begin_include
include|#
directive|include
file|"nvm_map.h"
end_include

begin_include
include|#
directive|include
file|"nvm_cfg.h"
end_include

begin_include
include|#
directive|include
file|"ecore_mcp.h"
end_include

begin_include
include|#
directive|include
file|"mcp_public.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_fw_funcs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_sriov.h"
end_include

begin_include
include|#
directive|include
file|"ecore_vf.h"
end_include

begin_include
include|#
directive|include
file|"ecore_iov_api.h"
end_include

begin_include
include|#
directive|include
file|"ecore_gtt_reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_iro.h"
end_include

begin_include
include|#
directive|include
file|"ecore_dcbx.h"
end_include

begin_define
define|#
directive|define
name|CHIP_MCP_RESP_ITER_US
value|10
end_define

begin_define
define|#
directive|define
name|EMUL_MCP_RESP_ITER_US
value|1000 * 1000
end_define

begin_define
define|#
directive|define
name|ECORE_DRV_MB_MAX_RETRIES
value|(500 * 1000)
end_define

begin_comment
comment|/* Account for 5 sec */
end_comment

begin_define
define|#
directive|define
name|ECORE_MCP_RESET_RETRIES
value|(50 * 1000)
end_define

begin_comment
comment|/* Account for 500 msec */
end_comment

begin_define
define|#
directive|define
name|DRV_INNER_WR
parameter_list|(
name|_p_hwfn
parameter_list|,
name|_p_ptt
parameter_list|,
name|_ptr
parameter_list|,
name|_offset
parameter_list|,
name|_val
parameter_list|)
define|\
value|ecore_wr(_p_hwfn, _p_ptt, (_p_hwfn->mcp_info->_ptr + _offset), \ 		 _val)
end_define

begin_define
define|#
directive|define
name|DRV_INNER_RD
parameter_list|(
name|_p_hwfn
parameter_list|,
name|_p_ptt
parameter_list|,
name|_ptr
parameter_list|,
name|_offset
parameter_list|)
define|\
value|ecore_rd(_p_hwfn, _p_ptt, (_p_hwfn->mcp_info->_ptr + _offset))
end_define

begin_define
define|#
directive|define
name|DRV_MB_WR
parameter_list|(
name|_p_hwfn
parameter_list|,
name|_p_ptt
parameter_list|,
name|_field
parameter_list|,
name|_val
parameter_list|)
define|\
value|DRV_INNER_WR(p_hwfn, _p_ptt, drv_mb_addr, \ 		     OFFSETOF(struct public_drv_mb, _field), _val)
end_define

begin_define
define|#
directive|define
name|DRV_MB_RD
parameter_list|(
name|_p_hwfn
parameter_list|,
name|_p_ptt
parameter_list|,
name|_field
parameter_list|)
define|\
value|DRV_INNER_RD(_p_hwfn, _p_ptt, drv_mb_addr, \ 		     OFFSETOF(struct public_drv_mb, _field))
end_define

begin_define
define|#
directive|define
name|PDA_COMP
value|(((FW_MAJOR_VERSION) + (FW_MINOR_VERSION<< 8))<< \ 	DRV_ID_PDA_COMP_VER_SHIFT)
end_define

begin_define
define|#
directive|define
name|MCP_BYTES_PER_MBIT_SHIFT
value|17
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ASIC_ONLY
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|loaded
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loaded_port
index|[
name|MAX_NUM_PORTS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|ecore_mcp_is_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|mcp_info
operator|||
operator|!
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|ecore_mcp_cmd_port_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|addr
init|=
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_PORT
argument_list|)
decl_stmt|;
name|u32
name|mfw_mb_offsize
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|=
name|SECTION_ADDR
argument_list|(
name|mfw_mb_offsize
argument_list|,
name|MFW_PORT
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"port_addr = 0x%x, port_id 0x%02x\n"
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
argument_list|,
name|MFW_PORT
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_mcp_read_mb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|length
init|=
name|MFW_DRV_MSG_MAX_DWORDS
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_length
argument_list|)
decl_stmt|;
name|OSAL_BE32
name|tmp
decl_stmt|;
name|u32
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_TEDIBEAR
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_addr
operator|+
operator|(
name|i
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u32
operator|*
operator|)
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_cur
operator|)
index|[
name|i
index|]
operator|=
name|OSAL_BE32_TO_CPU
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
condition|)
block|{
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_cur
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mfw_mb_shadow
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_LOCK_ALLOC
name|OSAL_SPIN_LOCK_DEALLOC
argument_list|(
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_SPIN_LOCK_DEALLOC
argument_list|(
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|mcp_info
operator|=
name|OSAL_NULL
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_load_mcp_offsets
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mcp_info
modifier|*
name|p_info
init|=
name|p_hwfn
operator|->
name|mcp_info
decl_stmt|;
name|u32
name|drv_mb_offsize
decl_stmt|,
name|mfw_mb_offsize
decl_stmt|;
name|u32
name|mcp_pf_id
init|=
name|MCP_PF_ID
argument_list|(
name|p_hwfn
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Emulation - assume no MFW\n"
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|public_base
operator|=
literal|0
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
endif|#
directive|endif
name|p_info
operator|->
name|public_base
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_SHARED_MEM_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_info
operator|->
name|public_base
condition|)
return|return
name|ECORE_INVAL
return|;
name|p_info
operator|->
name|public_base
operator||=
name|GRCBASE_MCP
expr_stmt|;
comment|/* Calculate the driver and MFW mailbox address */
name|drv_mb_offsize
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_DRV_MB
argument_list|)
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|drv_mb_addr
operator|=
name|SECTION_ADDR
argument_list|(
name|drv_mb_offsize
argument_list|,
name|mcp_pf_id
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"drv_mb_offsiz = 0x%x, drv_mb_addr = 0x%x mcp_pf_id = 0x%x\n"
argument_list|,
name|drv_mb_offsize
argument_list|,
name|p_info
operator|->
name|drv_mb_addr
argument_list|,
name|mcp_pf_id
argument_list|)
expr_stmt|;
comment|/* Set the MFW MB address */
name|mfw_mb_offsize
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_MFW_MB
argument_list|)
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|mfw_mb_addr
operator|=
name|SECTION_ADDR
argument_list|(
name|mfw_mb_offsize
argument_list|,
name|mcp_pf_id
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|mfw_mb_length
operator|=
operator|(
name|u16
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_info
operator|->
name|mfw_mb_addr
argument_list|)
expr_stmt|;
comment|/* Get the current driver mailbox sequence before sending 	 * the first command 	 */
name|p_info
operator|->
name|drv_mb_seq
operator|=
name|DRV_MB_RD
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|drv_mb_header
argument_list|)
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
expr_stmt|;
comment|/* Get current FW pulse sequence */
name|p_info
operator|->
name|drv_pulse_seq
operator|=
name|DRV_MB_RD
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|drv_pulse_mb
argument_list|)
operator|&
name|DRV_PULSE_SEQ_MASK
expr_stmt|;
name|p_info
operator|->
name|mcp_hist
operator|=
operator|(
name|u16
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_GENERIC_POR_0
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_cmd_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mcp_info
modifier|*
name|p_info
decl_stmt|;
name|u32
name|size
decl_stmt|;
comment|/* Allocate mcp_info structure */
name|p_hwfn
operator|->
name|mcp_info
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_hwfn
operator|->
name|mcp_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|mcp_info
condition|)
goto|goto
name|err
goto|;
name|p_info
operator|=
name|p_hwfn
operator|->
name|mcp_info
expr_stmt|;
if|if
condition|(
name|ecore_load_mcp_offsets
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"MCP is not initialized\n"
argument_list|)
expr_stmt|;
comment|/* Do not free mcp_info here, since public_base indicate that 		 * the MCP is not initialized 		 */
return|return
name|ECORE_SUCCESS
return|;
block|}
name|size
operator|=
name|MFW_DRV_MSG_MAX_DWORDS
argument_list|(
name|p_info
operator|->
name|mfw_mb_length
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|mfw_mb_cur
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|mfw_mb_shadow
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_info
operator|->
name|mfw_mb_shadow
operator|||
operator|!
name|p_info
operator|->
name|mfw_mb_addr
condition|)
goto|goto
name|err
goto|;
comment|/* Initialize the MFW spinlock */
ifdef|#
directive|ifdef
name|CONFIG_ECORE_LOCK_ALLOC
name|OSAL_SPIN_LOCK_ALLOC
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_info
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_SPIN_LOCK_ALLOC
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_info
operator|->
name|link_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OSAL_SPIN_LOCK_INIT
argument_list|(
operator|&
name|p_info
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_SPIN_LOCK_INIT
argument_list|(
operator|&
name|p_info
operator|->
name|link_lock
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
name|err
label|:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate mcp memory\n"
argument_list|)
expr_stmt|;
name|ecore_mcp_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
end_function

begin_comment
comment|/* Locks the MFW mailbox of a PF to ensure a single access.  * The lock is achieved in most cases by holding a spinlock, causing other  * threads to wait till a previous access is done.  * In some cases (currently when a [UN]LOAD_REQ commands are sent), the single  * access is achieved by setting a blocking flag, which will fail other  * competing contexts to send their mailboxes.  */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_mb_lock
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|cmd
parameter_list|)
block|{
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* The spinlock shouldn't be acquired when the mailbox command is 	 * [UN]LOAD_REQ, since the engine is locked by the MFW, and a parallel 	 * pending [UN]LOAD_REQ command of another PF together with a spinlock 	 * (i.e. interrupts are disabled) - can lead to a deadlock. 	 * It is assumed that for a single PF, no other mailbox commands can be 	 * sent from another context while sending LOAD_REQ, and that any 	 * parallel commands to UNLOAD_REQ can be cancelled. 	 */
if|if
condition|(
name|cmd
operator|==
name|DRV_MSG_CODE_LOAD_DONE
operator|||
name|cmd
operator|==
name|DRV_MSG_CODE_UNLOAD_DONE
condition|)
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|block_mb_sending
operator|=
name|false
expr_stmt|;
comment|/* There's at least a single command that is sent by ecore during the 	 * load sequence [expectation of MFW]. 	 */
if|if
condition|(
operator|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|block_mb_sending
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|DRV_MSG_CODE_FEATURE_SUPPORT
operator|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Trying to send a MFW mailbox command [0x%x] in parallel to [UN]LOAD_REQ. Aborting.\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|DRV_MSG_CODE_LOAD_REQ
operator|||
name|cmd
operator|==
name|DRV_MSG_CODE_UNLOAD_REQ
condition|)
block|{
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|block_mb_sending
operator|=
name|true
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_mb_unlock
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|!=
name|DRV_MSG_CODE_LOAD_REQ
operator|&&
name|cmd
operator|!=
name|DRV_MSG_CODE_UNLOAD_REQ
condition|)
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_reset
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|seq
init|=
operator|++
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|drv_mb_seq
decl_stmt|;
name|u32
name|delay
init|=
name|CHIP_MCP_RESP_ITER_US
decl_stmt|;
name|u32
name|org_mcp_reset_seq
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|delay
operator|=
name|EMUL_MCP_RESP_ITER_US
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure that only a single thread is accessing the mailbox at a 	 * certain time. 	 */
name|rc
operator|=
name|ecore_mcp_mb_lock
argument_list|(
name|p_hwfn
argument_list|,
name|DRV_MSG_CODE_MCP_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* Set drv command along with the updated sequence */
name|org_mcp_reset_seq
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_GENERIC_POR_0
argument_list|)
expr_stmt|;
name|DRV_MB_WR
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|drv_mb_header
argument_list|,
operator|(
name|DRV_MSG_CODE_MCP_RESET
operator||
name|seq
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Wait for MFW response */
name|OSAL_UDELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
comment|/* Give the FW up to 500 second (50*1000*10usec) */
block|}
do|while
condition|(
operator|(
name|org_mcp_reset_seq
operator|==
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_GENERIC_POR_0
argument_list|)
operator|)
operator|&&
operator|(
name|cnt
operator|++
operator|<
name|ECORE_MCP_RESET_RETRIES
operator|)
condition|)
do|;
if|if
condition|(
name|org_mcp_reset_seq
operator|!=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_GENERIC_POR_0
argument_list|)
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"MCP was reset after %d usec\n"
argument_list|,
name|cnt
operator|*
name|delay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to reset MCP\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_AGAIN
expr_stmt|;
block|}
name|ecore_mcp_mb_unlock
argument_list|(
name|p_hwfn
argument_list|,
name|DRV_MSG_CODE_MCP_RESET
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_do_mcp_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|cmd
parameter_list|,
name|u32
name|param
parameter_list|,
name|u32
modifier|*
name|o_mcp_resp
parameter_list|,
name|u32
modifier|*
name|o_mcp_param
parameter_list|)
block|{
name|u32
name|delay
init|=
name|CHIP_MCP_RESP_ITER_US
decl_stmt|;
name|u32
name|max_retries
init|=
name|ECORE_DRV_MB_MAX_RETRIES
decl_stmt|;
name|u32
name|seq
decl_stmt|,
name|cnt
init|=
literal|1
decl_stmt|,
name|actual_mb_seq
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|delay
operator|=
name|EMUL_MCP_RESP_ITER_US
expr_stmt|;
comment|/* There is a built-in delay of 100usec in each MFW response read */
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|max_retries
operator|/=
literal|10
expr_stmt|;
endif|#
directive|endif
comment|/* Get actual driver mailbox sequence */
name|actual_mb_seq
operator|=
name|DRV_MB_RD
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|drv_mb_header
argument_list|)
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
expr_stmt|;
comment|/* Use MCP history register to check if MCP reset occurred between 	 * init time and now. 	 */
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|mcp_hist
operator|!=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_GENERIC_POR_0
argument_list|)
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Rereading MCP offsets\n"
argument_list|)
expr_stmt|;
name|ecore_load_mcp_offsets
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_mcp_cmd_port_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
operator|++
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|drv_mb_seq
expr_stmt|;
comment|/* Set drv param */
name|DRV_MB_WR
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|drv_mb_param
argument_list|,
name|param
argument_list|)
expr_stmt|;
comment|/* Set drv command along with the updated sequence */
name|DRV_MB_WR
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|drv_mb_header
argument_list|,
operator|(
name|cmd
operator||
name|seq
operator|)
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"wrote command (%x) to MFW MB param 0x%08x\n"
argument_list|,
operator|(
name|cmd
operator||
name|seq
operator|)
argument_list|,
name|param
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Wait for MFW response */
name|OSAL_UDELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
operator|*
name|o_mcp_resp
operator|=
name|DRV_MB_RD
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|fw_mb_header
argument_list|)
expr_stmt|;
comment|/* Give the FW up to 5 second (500*10ms) */
block|}
do|while
condition|(
operator|(
name|seq
operator|!=
operator|(
operator|*
name|o_mcp_resp
operator|&
name|FW_MSG_SEQ_NUMBER_MASK
operator|)
operator|)
operator|&&
operator|(
name|cnt
operator|++
operator|<
name|max_retries
operator|)
condition|)
do|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"[after %d ms] read (%x) seq is (%x) from FW MB\n"
argument_list|,
name|cnt
operator|*
name|delay
argument_list|,
operator|*
name|o_mcp_resp
argument_list|,
name|seq
argument_list|)
expr_stmt|;
comment|/* Is this a reply to our command? */
if|if
condition|(
name|seq
operator|==
operator|(
operator|*
name|o_mcp_resp
operator|&
name|FW_MSG_SEQ_NUMBER_MASK
operator|)
condition|)
block|{
operator|*
name|o_mcp_resp
operator|&=
name|FW_MSG_CODE_MASK
expr_stmt|;
comment|/* Get the MCP param */
operator|*
name|o_mcp_param
operator|=
name|DRV_MB_RD
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|fw_mb_param
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FW BUG! */
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"MFW failed to respond [cmd 0x%x param 0x%x]\n"
argument_list|,
name|cmd
argument_list|,
name|param
argument_list|)
expr_stmt|;
operator|*
name|o_mcp_resp
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ECORE_AGAIN
expr_stmt|;
name|ecore_hw_err_notify
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_ERR_MFW_RESP_FAIL
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_cmd_and_union
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mcp_mb_params
modifier|*
name|p_mb_params
parameter_list|)
block|{
name|union
name|drv_union_data
name|union_data
decl_stmt|;
name|u32
name|union_data_addr
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* MCP not initialized */
if|if
condition|(
operator|!
name|ecore_mcp_is_init
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"MFW is not initialized!\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
block|}
if|if
condition|(
name|p_mb_params
operator|->
name|data_src_size
operator|>
sizeof|sizeof
argument_list|(
name|union_data
argument_list|)
operator|||
name|p_mb_params
operator|->
name|data_dst_size
operator|>
sizeof|sizeof
argument_list|(
name|union_data
argument_list|)
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"The provided size is larger than the union data size [src_size %u, dst_size %u, union_data_size %zu]\n"
argument_list|,
name|p_mb_params
operator|->
name|data_src_size
argument_list|,
name|p_mb_params
operator|->
name|data_dst_size
argument_list|,
sizeof|sizeof
argument_list|(
name|union_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|union_data_addr
operator|=
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|drv_mb_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_drv_mb
argument_list|,
name|union_data
argument_list|)
expr_stmt|;
comment|/* Ensure that only a single thread is accessing the mailbox at a 	 * certain time. 	 */
name|rc
operator|=
name|ecore_mcp_mb_lock
argument_list|(
name|p_hwfn
argument_list|,
name|p_mb_params
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|union_data
argument_list|,
sizeof|sizeof
argument_list|(
name|union_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mb_params
operator|->
name|p_data_src
operator|!=
name|OSAL_NULL
operator|&&
name|p_mb_params
operator|->
name|data_src_size
condition|)
name|OSAL_MEMCPY
argument_list|(
operator|&
name|union_data
argument_list|,
name|p_mb_params
operator|->
name|p_data_src
argument_list|,
name|p_mb_params
operator|->
name|data_src_size
argument_list|)
expr_stmt|;
name|ecore_memcpy_to
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|union_data_addr
argument_list|,
operator|&
name|union_data
argument_list|,
sizeof|sizeof
argument_list|(
name|union_data
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_do_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_mb_params
operator|->
name|cmd
argument_list|,
name|p_mb_params
operator|->
name|param
argument_list|,
operator|&
name|p_mb_params
operator|->
name|mcp_resp
argument_list|,
operator|&
name|p_mb_params
operator|->
name|mcp_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mb_params
operator|->
name|p_data_dst
operator|!=
name|OSAL_NULL
operator|&&
name|p_mb_params
operator|->
name|data_dst_size
condition|)
name|ecore_memcpy_from
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_mb_params
operator|->
name|p_data_dst
argument_list|,
name|union_data_addr
argument_list|,
name|p_mb_params
operator|->
name|data_dst_size
argument_list|)
expr_stmt|;
name|ecore_mcp_mb_unlock
argument_list|(
name|p_hwfn
argument_list|,
name|p_mb_params
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|cmd
parameter_list|,
name|u32
name|param
parameter_list|,
name|u32
modifier|*
name|o_mcp_resp
parameter_list|,
name|u32
modifier|*
name|o_mcp_param
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|DRV_MSG_CODE_UNLOAD_REQ
condition|)
block|{
name|loaded
operator|--
expr_stmt|;
name|loaded_port
index|[
name|p_hwfn
operator|->
name|port_id
index|]
operator|--
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Unload cnt: 0x%x\n"
argument_list|,
name|loaded
argument_list|)
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
endif|#
directive|endif
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|param
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
operator|*
name|o_mcp_resp
operator|=
name|mb_params
operator|.
name|mcp_resp
expr_stmt|;
operator|*
name|o_mcp_param
operator|=
name|mb_params
operator|.
name|mcp_param
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_wr_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|cmd
parameter_list|,
name|u32
name|param
parameter_list|,
name|u32
modifier|*
name|o_mcp_resp
parameter_list|,
name|u32
modifier|*
name|o_mcp_param
parameter_list|,
name|u32
name|i_txn_size
parameter_list|,
name|u32
modifier|*
name|i_buf
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|param
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
name|i_buf
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
operator|(
name|u8
operator|)
name|i_txn_size
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
operator|*
name|o_mcp_resp
operator|=
name|mb_params
operator|.
name|mcp_resp
expr_stmt|;
operator|*
name|o_mcp_param
operator|=
name|mb_params
operator|.
name|mcp_param
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_rd_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|cmd
parameter_list|,
name|u32
name|param
parameter_list|,
name|u32
modifier|*
name|o_mcp_resp
parameter_list|,
name|u32
modifier|*
name|o_mcp_param
parameter_list|,
name|u32
modifier|*
name|o_txn_size
parameter_list|,
name|u32
modifier|*
name|o_buf
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|u8
name|raw_data
index|[
name|MCP_DRV_NVM_BUF_LEN
index|]
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|param
expr_stmt|;
name|mb_params
operator|.
name|p_data_dst
operator|=
name|raw_data
expr_stmt|;
comment|/* Use the maximal value since the actual one is part of the response */
name|mb_params
operator|.
name|data_dst_size
operator|=
name|MCP_DRV_NVM_BUF_LEN
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
operator|*
name|o_mcp_resp
operator|=
name|mb_params
operator|.
name|mcp_resp
expr_stmt|;
operator|*
name|o_mcp_param
operator|=
name|mb_params
operator|.
name|mcp_param
expr_stmt|;
operator|*
name|o_txn_size
operator|=
operator|*
name|o_mcp_param
expr_stmt|;
name|OSAL_MEMCPY
argument_list|(
name|o_buf
argument_list|,
name|raw_data
argument_list|,
operator|*
name|o_txn_size
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ASIC_ONLY
end_ifndef

begin_function
specifier|static
name|void
name|ecore_mcp_mf_workaround
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
modifier|*
name|p_load_code
parameter_list|)
block|{
specifier|static
name|int
name|load_phase
init|=
name|FW_MSG_CODE_DRV_LOAD_ENGINE
decl_stmt|;
if|if
condition|(
operator|!
name|loaded
condition|)
block|{
name|load_phase
operator|=
name|FW_MSG_CODE_DRV_LOAD_ENGINE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|loaded_port
index|[
name|p_hwfn
operator|->
name|port_id
index|]
condition|)
block|{
name|load_phase
operator|=
name|FW_MSG_CODE_DRV_LOAD_PORT
expr_stmt|;
block|}
else|else
block|{
name|load_phase
operator|=
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
expr_stmt|;
block|}
comment|/* On CMT, always tell that it's engine */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
operator|>
literal|1
condition|)
name|load_phase
operator|=
name|FW_MSG_CODE_DRV_LOAD_ENGINE
expr_stmt|;
operator|*
name|p_load_code
operator|=
name|load_phase
expr_stmt|;
name|loaded
operator|++
expr_stmt|;
name|loaded_port
index|[
name|p_hwfn
operator|->
name|port_id
index|]
operator|++
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Load phase: %x load cnt: 0x%x port id=%d port_load=%d\n"
argument_list|,
operator|*
name|p_load_code
argument_list|,
name|loaded
argument_list|,
name|p_hwfn
operator|->
name|port_id
argument_list|,
name|loaded_port
index|[
name|p_hwfn
operator|->
name|port_id
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|ecore_mcp_can_force_load
parameter_list|(
name|u8
name|drv_role
parameter_list|,
name|u8
name|exist_drv_role
parameter_list|,
name|enum
name|ecore_override_force_load
name|override_force_load
parameter_list|)
block|{
name|bool
name|can_force_load
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|override_force_load
condition|)
block|{
case|case
name|ECORE_OVERRIDE_FORCE_LOAD_ALWAYS
case|:
name|can_force_load
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ECORE_OVERRIDE_FORCE_LOAD_NEVER
case|:
name|can_force_load
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|can_force_load
operator|=
operator|(
name|drv_role
operator|==
name|DRV_ROLE_OS
operator|&&
name|exist_drv_role
operator|==
name|DRV_ROLE_PREBOOT
operator|)
operator|||
operator|(
name|drv_role
operator|==
name|DRV_ROLE_KDUMP
operator|&&
name|exist_drv_role
operator|==
name|DRV_ROLE_OS
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|can_force_load
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_cancel_load_req
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_CANCEL_LOAD_REQ
argument_list|,
literal|0
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to send cancel load request, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CONFIG_ECORE_L2_BITMAP_IDX
value|(0x1<< 0)
end_define

begin_define
define|#
directive|define
name|CONFIG_ECORE_SRIOV_BITMAP_IDX
value|(0x1<< 1)
end_define

begin_define
define|#
directive|define
name|CONFIG_ECORE_ROCE_BITMAP_IDX
value|(0x1<< 2)
end_define

begin_define
define|#
directive|define
name|CONFIG_ECORE_IWARP_BITMAP_IDX
value|(0x1<< 3)
end_define

begin_define
define|#
directive|define
name|CONFIG_ECORE_FCOE_BITMAP_IDX
value|(0x1<< 4)
end_define

begin_define
define|#
directive|define
name|CONFIG_ECORE_ISCSI_BITMAP_IDX
value|(0x1<< 5)
end_define

begin_define
define|#
directive|define
name|CONFIG_ECORE_LL2_BITMAP_IDX
value|(0x1<< 6)
end_define

begin_function
specifier|static
name|u32
name|ecore_get_config_bitmap
parameter_list|(
name|void
parameter_list|)
block|{
name|u32
name|config_bitmap
init|=
literal|0x0
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_L2
name|config_bitmap
operator||=
name|CONFIG_ECORE_L2_BITMAP_IDX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_SRIOV
name|config_bitmap
operator||=
name|CONFIG_ECORE_SRIOV_BITMAP_IDX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ROCE
name|config_bitmap
operator||=
name|CONFIG_ECORE_ROCE_BITMAP_IDX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_IWARP
name|config_bitmap
operator||=
name|CONFIG_ECORE_IWARP_BITMAP_IDX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_FCOE
name|config_bitmap
operator||=
name|CONFIG_ECORE_FCOE_BITMAP_IDX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ISCSI
name|config_bitmap
operator||=
name|CONFIG_ECORE_ISCSI_BITMAP_IDX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_ECORE_LL2
name|config_bitmap
operator||=
name|CONFIG_ECORE_LL2_BITMAP_IDX
expr_stmt|;
endif|#
directive|endif
return|return
name|config_bitmap
return|;
block|}
end_function

begin_struct
struct|struct
name|ecore_load_req_in_params
block|{
name|u8
name|hsi_ver
decl_stmt|;
define|#
directive|define
name|ECORE_LOAD_REQ_HSI_VER_DEFAULT
value|0
define|#
directive|define
name|ECORE_LOAD_REQ_HSI_VER_1
value|1
name|u32
name|drv_ver_0
decl_stmt|;
name|u32
name|drv_ver_1
decl_stmt|;
name|u32
name|fw_ver
decl_stmt|;
name|u8
name|drv_role
decl_stmt|;
name|u8
name|timeout_val
decl_stmt|;
name|u8
name|force_cmd
decl_stmt|;
name|bool
name|avoid_eng_reset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_load_req_out_params
block|{
name|u32
name|load_code
decl_stmt|;
name|u32
name|exist_drv_ver_0
decl_stmt|;
name|u32
name|exist_drv_ver_1
decl_stmt|;
name|u32
name|exist_fw_ver
decl_stmt|;
name|u8
name|exist_drv_role
decl_stmt|;
name|u8
name|mfw_hsi_ver
decl_stmt|;
name|bool
name|drv_exists
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|__ecore_mcp_load_req
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_load_req_in_params
modifier|*
name|p_in_params
parameter_list|,
name|struct
name|ecore_load_req_out_params
modifier|*
name|p_out_params
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|struct
name|load_req_stc
name|load_req
decl_stmt|;
name|struct
name|load_rsp_stc
name|load_rsp
decl_stmt|;
name|u32
name|hsi_ver
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|load_req
argument_list|,
sizeof|sizeof
argument_list|(
name|load_req
argument_list|)
argument_list|)
expr_stmt|;
name|load_req
operator|.
name|drv_ver_0
operator|=
name|p_in_params
operator|->
name|drv_ver_0
expr_stmt|;
name|load_req
operator|.
name|drv_ver_1
operator|=
name|p_in_params
operator|->
name|drv_ver_1
expr_stmt|;
name|load_req
operator|.
name|fw_ver
operator|=
name|p_in_params
operator|->
name|fw_ver
expr_stmt|;
name|ECORE_MFW_SET_FIELD
argument_list|(
name|load_req
operator|.
name|misc0
argument_list|,
name|LOAD_REQ_ROLE
argument_list|,
name|p_in_params
operator|->
name|drv_role
argument_list|)
expr_stmt|;
name|ECORE_MFW_SET_FIELD
argument_list|(
name|load_req
operator|.
name|misc0
argument_list|,
name|LOAD_REQ_LOCK_TO
argument_list|,
name|p_in_params
operator|->
name|timeout_val
argument_list|)
expr_stmt|;
name|ECORE_MFW_SET_FIELD
argument_list|(
name|load_req
operator|.
name|misc0
argument_list|,
operator|(
name|u64
operator|)
name|LOAD_REQ_FORCE
argument_list|,
name|p_in_params
operator|->
name|force_cmd
argument_list|)
expr_stmt|;
name|ECORE_MFW_SET_FIELD
argument_list|(
name|load_req
operator|.
name|misc0
argument_list|,
operator|(
name|u64
operator|)
name|LOAD_REQ_FLAGS0
argument_list|,
name|p_in_params
operator|->
name|avoid_eng_reset
argument_list|)
expr_stmt|;
name|hsi_ver
operator|=
operator|(
name|p_in_params
operator|->
name|hsi_ver
operator|==
name|ECORE_LOAD_REQ_HSI_VER_DEFAULT
operator|)
condition|?
name|DRV_ID_MCP_HSI_VER_CURRENT
else|:
operator|(
name|p_in_params
operator|->
name|hsi_ver
operator|<<
name|DRV_ID_MCP_HSI_VER_SHIFT
operator|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_LOAD_REQ
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|PDA_COMP
operator||
name|hsi_ver
operator||
name|p_hwfn
operator|->
name|p_dev
operator|->
name|drv_type
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|load_req
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|load_req
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|p_data_dst
operator|=
operator|&
name|load_rsp
expr_stmt|;
name|mb_params
operator|.
name|data_dst_size
operator|=
sizeof|sizeof
argument_list|(
name|load_rsp
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Load Request: param 0x%08x [init_hw %d, drv_type %d, hsi_ver %d, pda 0x%04x]\n"
argument_list|,
name|mb_params
operator|.
name|param
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mb_params
operator|.
name|param
argument_list|,
name|DRV_ID_DRV_INIT_HW
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mb_params
operator|.
name|param
argument_list|,
name|DRV_ID_DRV_TYPE
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mb_params
operator|.
name|param
argument_list|,
name|DRV_ID_MCP_HSI_VER
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mb_params
operator|.
name|param
argument_list|,
name|DRV_ID_PDA_COMP_VER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_in_params
operator|->
name|hsi_ver
operator|!=
name|ECORE_LOAD_REQ_HSI_VER_1
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Load Request: drv_ver 0x%08x_0x%08x, fw_ver 0x%08x, misc0 0x%08x [role %d, timeout %d, force %d, flags0 0x%x]\n"
argument_list|,
name|load_req
operator|.
name|drv_ver_0
argument_list|,
name|load_req
operator|.
name|drv_ver_1
argument_list|,
name|load_req
operator|.
name|fw_ver
argument_list|,
name|load_req
operator|.
name|misc0
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_req
operator|.
name|misc0
argument_list|,
name|LOAD_REQ_ROLE
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_req
operator|.
name|misc0
argument_list|,
name|LOAD_REQ_LOCK_TO
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_req
operator|.
name|misc0
argument_list|,
name|LOAD_REQ_FORCE
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_req
operator|.
name|misc0
argument_list|,
name|LOAD_REQ_FLAGS0
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to send load request, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Load Response: resp 0x%08x\n"
argument_list|,
name|mb_params
operator|.
name|mcp_resp
argument_list|)
expr_stmt|;
name|p_out_params
operator|->
name|load_code
operator|=
name|mb_params
operator|.
name|mcp_resp
expr_stmt|;
if|if
condition|(
name|p_in_params
operator|->
name|hsi_ver
operator|!=
name|ECORE_LOAD_REQ_HSI_VER_1
operator|&&
name|p_out_params
operator|->
name|load_code
operator|!=
name|FW_MSG_CODE_DRV_LOAD_REFUSED_HSI_1
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Load Response: exist_drv_ver 0x%08x_0x%08x, exist_fw_ver 0x%08x, misc0 0x%08x [exist_role %d, mfw_hsi %d, flags0 0x%x]\n"
argument_list|,
name|load_rsp
operator|.
name|drv_ver_0
argument_list|,
name|load_rsp
operator|.
name|drv_ver_1
argument_list|,
name|load_rsp
operator|.
name|fw_ver
argument_list|,
name|load_rsp
operator|.
name|misc0
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_rsp
operator|.
name|misc0
argument_list|,
name|LOAD_RSP_ROLE
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_rsp
operator|.
name|misc0
argument_list|,
name|LOAD_RSP_HSI
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_rsp
operator|.
name|misc0
argument_list|,
name|LOAD_RSP_FLAGS0
argument_list|)
argument_list|)
expr_stmt|;
name|p_out_params
operator|->
name|exist_drv_ver_0
operator|=
name|load_rsp
operator|.
name|drv_ver_0
expr_stmt|;
name|p_out_params
operator|->
name|exist_drv_ver_1
operator|=
name|load_rsp
operator|.
name|drv_ver_1
expr_stmt|;
name|p_out_params
operator|->
name|exist_fw_ver
operator|=
name|load_rsp
operator|.
name|fw_ver
expr_stmt|;
name|p_out_params
operator|->
name|exist_drv_role
operator|=
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_rsp
operator|.
name|misc0
argument_list|,
name|LOAD_RSP_ROLE
argument_list|)
expr_stmt|;
name|p_out_params
operator|->
name|mfw_hsi_ver
operator|=
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_rsp
operator|.
name|misc0
argument_list|,
name|LOAD_RSP_HSI
argument_list|)
expr_stmt|;
name|p_out_params
operator|->
name|drv_exists
operator|=
name|ECORE_MFW_GET_FIELD
argument_list|(
name|load_rsp
operator|.
name|misc0
argument_list|,
name|LOAD_RSP_FLAGS0
argument_list|)
operator|&
name|LOAD_RSP_FLAGS0_DRV_EXISTS
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|eocre_get_mfw_drv_role
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_drv_role
name|drv_role
parameter_list|,
name|u8
modifier|*
name|p_mfw_drv_role
parameter_list|)
block|{
switch|switch
condition|(
name|drv_role
condition|)
block|{
case|case
name|ECORE_DRV_ROLE_OS
case|:
operator|*
name|p_mfw_drv_role
operator|=
name|DRV_ROLE_OS
expr_stmt|;
break|break;
case|case
name|ECORE_DRV_ROLE_KDUMP
case|:
operator|*
name|p_mfw_drv_role
operator|=
name|DRV_ROLE_KDUMP
expr_stmt|;
break|break;
default|default:
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Unexpected driver role %d\n"
argument_list|,
name|drv_role
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_enum
enum|enum
name|ecore_load_req_force
block|{
name|ECORE_LOAD_REQ_FORCE_NONE
block|,
name|ECORE_LOAD_REQ_FORCE_PF
block|,
name|ECORE_LOAD_REQ_FORCE_ALL
block|, }
enum|;
end_enum

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_get_mfw_force_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_load_req_force
name|force_cmd
parameter_list|,
name|u8
modifier|*
name|p_mfw_force_cmd
parameter_list|)
block|{
switch|switch
condition|(
name|force_cmd
condition|)
block|{
case|case
name|ECORE_LOAD_REQ_FORCE_NONE
case|:
operator|*
name|p_mfw_force_cmd
operator|=
name|LOAD_REQ_FORCE_NONE
expr_stmt|;
break|break;
case|case
name|ECORE_LOAD_REQ_FORCE_PF
case|:
operator|*
name|p_mfw_force_cmd
operator|=
name|LOAD_REQ_FORCE_PF
expr_stmt|;
break|break;
case|case
name|ECORE_LOAD_REQ_FORCE_ALL
case|:
operator|*
name|p_mfw_force_cmd
operator|=
name|LOAD_REQ_FORCE_ALL
expr_stmt|;
break|break;
default|default:
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Unexpected force value %d\n"
argument_list|,
name|force_cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_load_req
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_load_req_params
modifier|*
name|p_params
parameter_list|)
block|{
name|struct
name|ecore_load_req_out_params
name|out_params
decl_stmt|;
name|struct
name|ecore_load_req_in_params
name|in_params
decl_stmt|;
name|u8
name|mfw_drv_role
decl_stmt|,
name|mfw_force_cmd
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_mcp_mf_workaround
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_params
operator|->
name|load_code
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
endif|#
directive|endif
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|in_params
argument_list|,
sizeof|sizeof
argument_list|(
name|in_params
argument_list|)
argument_list|)
expr_stmt|;
name|in_params
operator|.
name|hsi_ver
operator|=
name|ECORE_LOAD_REQ_HSI_VER_DEFAULT
expr_stmt|;
name|in_params
operator|.
name|drv_ver_0
operator|=
name|ECORE_VERSION
expr_stmt|;
name|in_params
operator|.
name|drv_ver_1
operator|=
name|ecore_get_config_bitmap
argument_list|()
expr_stmt|;
name|in_params
operator|.
name|fw_ver
operator|=
name|STORM_FW_VERSION
expr_stmt|;
name|rc
operator|=
name|eocre_get_mfw_drv_role
argument_list|(
name|p_hwfn
argument_list|,
name|p_params
operator|->
name|drv_role
argument_list|,
operator|&
name|mfw_drv_role
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|in_params
operator|.
name|drv_role
operator|=
name|mfw_drv_role
expr_stmt|;
name|in_params
operator|.
name|timeout_val
operator|=
name|p_params
operator|->
name|timeout_val
expr_stmt|;
name|rc
operator|=
name|ecore_get_mfw_force_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_LOAD_REQ_FORCE_NONE
argument_list|,
operator|&
name|mfw_force_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|in_params
operator|.
name|force_cmd
operator|=
name|mfw_force_cmd
expr_stmt|;
name|in_params
operator|.
name|avoid_eng_reset
operator|=
name|p_params
operator|->
name|avoid_eng_reset
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|out_params
argument_list|,
sizeof|sizeof
argument_list|(
name|out_params
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|__ecore_mcp_load_req
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|in_params
argument_list|,
operator|&
name|out_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* First handle cases where another load request should/might be sent: 	 * - MFW expects the old interface [HSI version = 1] 	 * - MFW responds that a force load request is required 	 */
if|if
condition|(
name|out_params
operator|.
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_REFUSED_HSI_1
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"MFW refused a load request due to HSI> 1. Resending with HSI = 1.\n"
argument_list|)
expr_stmt|;
comment|/* The previous load request set the mailbox blocking */
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|block_mb_sending
operator|=
name|false
expr_stmt|;
name|in_params
operator|.
name|hsi_ver
operator|=
name|ECORE_LOAD_REQ_HSI_VER_1
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|out_params
argument_list|,
sizeof|sizeof
argument_list|(
name|out_params
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|__ecore_mcp_load_req
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|in_params
argument_list|,
operator|&
name|out_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
block|}
elseif|else
if|if
condition|(
name|out_params
operator|.
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_REFUSED_REQUIRES_FORCE
condition|)
block|{
comment|/* The previous load request set the mailbox blocking */
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|block_mb_sending
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ecore_mcp_can_force_load
argument_list|(
name|in_params
operator|.
name|drv_role
argument_list|,
name|out_params
operator|.
name|exist_drv_role
argument_list|,
name|p_params
operator|->
name|override_force_load
argument_list|)
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"A force load is required [{role, fw_ver, drv_ver}: loading={%d, 0x%08x, x%08x_0x%08x}, existing={%d, 0x%08x, 0x%08x_0x%08x}]\n"
argument_list|,
name|in_params
operator|.
name|drv_role
argument_list|,
name|in_params
operator|.
name|fw_ver
argument_list|,
name|in_params
operator|.
name|drv_ver_0
argument_list|,
name|in_params
operator|.
name|drv_ver_1
argument_list|,
name|out_params
operator|.
name|exist_drv_role
argument_list|,
name|out_params
operator|.
name|exist_fw_ver
argument_list|,
name|out_params
operator|.
name|exist_drv_ver_0
argument_list|,
name|out_params
operator|.
name|exist_drv_ver_1
argument_list|)
expr_stmt|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Sending a force load request\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_get_mfw_force_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_LOAD_REQ_FORCE_ALL
argument_list|,
operator|&
name|mfw_force_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|in_params
operator|.
name|force_cmd
operator|=
name|mfw_force_cmd
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|out_params
argument_list|,
sizeof|sizeof
argument_list|(
name|out_params
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|__ecore_mcp_load_req
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|in_params
argument_list|,
operator|&
name|out_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"A force load is required [{role, fw_ver, drv_ver}: loading={%d, 0x%08x, x%08x_0x%08x}, existing={%d, 0x%08x, 0x%08x_0x%08x}]\n"
argument_list|,
name|in_params
operator|.
name|drv_role
argument_list|,
name|in_params
operator|.
name|fw_ver
argument_list|,
name|in_params
operator|.
name|drv_ver_0
argument_list|,
name|in_params
operator|.
name|drv_ver_1
argument_list|,
name|out_params
operator|.
name|exist_drv_role
argument_list|,
name|out_params
operator|.
name|exist_fw_ver
argument_list|,
name|out_params
operator|.
name|exist_drv_ver_0
argument_list|,
name|out_params
operator|.
name|exist_drv_ver_1
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Avoid sending a force load request to prevent disruption of active PFs\n"
argument_list|)
expr_stmt|;
name|ecore_mcp_cancel_load_req
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
block|}
block|}
comment|/* Now handle the other types of responses. 	 * The "REFUSED_HSI_1" and "REFUSED_REQUIRES_FORCE" responses are not 	 * expected here after the additional revised load requests were sent. 	 */
switch|switch
condition|(
name|out_params
operator|.
name|load_code
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_LOAD_ENGINE
case|:
case|case
name|FW_MSG_CODE_DRV_LOAD_PORT
case|:
case|case
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
case|:
if|if
condition|(
name|out_params
operator|.
name|mfw_hsi_ver
operator|!=
name|ECORE_LOAD_REQ_HSI_VER_1
operator|&&
name|out_params
operator|.
name|drv_exists
condition|)
block|{
comment|/* The role and fw/driver version match, but the PF is 			 * already loaded and has not been unloaded gracefully. 			 * This is unexpected since a quasi-FLR request was 			 * previously sent as part of ecore_hw_prepare(). 			 */
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"PF is already loaded - shouldn't have got here since a quasi-FLR request was previously sent!\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
break|break;
case|case
name|FW_MSG_CODE_DRV_LOAD_REFUSED_PDA
case|:
case|case
name|FW_MSG_CODE_DRV_LOAD_REFUSED_DIAG
case|:
case|case
name|FW_MSG_CODE_DRV_LOAD_REFUSED_HSI
case|:
case|case
name|FW_MSG_CODE_DRV_LOAD_REFUSED_REJECT
case|:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"MFW refused a load request [resp 0x%08x]. Aborting.\n"
argument_list|,
name|out_params
operator|.
name|load_code
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Unexpected response to load request [resp 0x%08x]. Aborting.\n"
argument_list|,
name|out_params
operator|.
name|load_code
argument_list|)
expr_stmt|;
break|break;
block|}
name|p_params
operator|->
name|load_code
operator|=
name|out_params
operator|.
name|load_code
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_unload_req
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|wol_param
decl_stmt|,
name|mcp_resp
decl_stmt|,
name|mcp_param
decl_stmt|;
switch|switch
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|wol_config
condition|)
block|{
case|case
name|ECORE_OV_WOL_DISABLED
case|:
name|wol_param
operator|=
name|DRV_MB_PARAM_UNLOAD_WOL_DISABLED
expr_stmt|;
break|break;
case|case
name|ECORE_OV_WOL_ENABLED
case|:
name|wol_param
operator|=
name|DRV_MB_PARAM_UNLOAD_WOL_ENABLED
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unknown WoL configuration %02x\n"
argument_list|,
name|p_hwfn
operator|->
name|p_dev
operator|->
name|wol_config
argument_list|)
expr_stmt|;
comment|/* Fallthrough */
case|case
name|ECORE_OV_WOL_DEFAULT
case|:
name|wol_param
operator|=
name|DRV_MB_PARAM_UNLOAD_WOL_MCP
expr_stmt|;
block|}
return|return
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_UNLOAD_REQ
argument_list|,
name|wol_param
argument_list|,
operator|&
name|mcp_resp
argument_list|,
operator|&
name|mcp_param
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_unload_done
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|struct
name|mcp_mac
name|wol_mac
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_UNLOAD_DONE
expr_stmt|;
comment|/* Set the primary MAC if WoL is enabled */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|wol_config
operator|==
name|ECORE_OV_WOL_ENABLED
condition|)
block|{
name|u8
modifier|*
name|p_mac
init|=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|wol_mac
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|wol_mac
argument_list|,
sizeof|sizeof
argument_list|(
name|wol_mac
argument_list|)
argument_list|)
expr_stmt|;
name|wol_mac
operator|.
name|mac_upper
operator|=
name|p_mac
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|p_mac
index|[
literal|1
index|]
expr_stmt|;
name|wol_mac
operator|.
name|mac_lower
operator|=
name|p_mac
index|[
literal|2
index|]
operator|<<
literal|24
operator||
name|p_mac
index|[
literal|3
index|]
operator|<<
literal|16
operator||
name|p_mac
index|[
literal|4
index|]
operator|<<
literal|8
operator||
name|p_mac
index|[
literal|5
index|]
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_SP
operator||
name|ECORE_MSG_IFDOWN
operator|)
argument_list|,
literal|"Setting WoL MAC: %02x:%02x:%02x:%02x:%02x:%02x --> [%08x,%08x]\n"
argument_list|,
name|p_mac
index|[
literal|0
index|]
argument_list|,
name|p_mac
index|[
literal|1
index|]
argument_list|,
name|p_mac
index|[
literal|2
index|]
argument_list|,
name|p_mac
index|[
literal|3
index|]
argument_list|,
name|p_mac
index|[
literal|4
index|]
argument_list|,
name|p_mac
index|[
literal|5
index|]
argument_list|,
name|wol_mac
operator|.
name|mac_upper
argument_list|,
name|wol_mac
operator|.
name|mac_lower
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|wol_mac
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|wol_mac
argument_list|)
expr_stmt|;
block|}
return|return
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_handle_vf_flr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|addr
init|=
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_PATH
argument_list|)
decl_stmt|;
name|u32
name|mfw_path_offsize
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|u32
name|path_addr
init|=
name|SECTION_ADDR
argument_list|(
name|mfw_path_offsize
argument_list|,
name|ECORE_PATH_ID
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|disabled_vfs
index|[
name|VF_MAX_STATIC
operator|/
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Reading Disabled VF information from [offset %08x], path_addr %08x\n"
argument_list|,
name|mfw_path_offsize
argument_list|,
name|path_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|VF_MAX_STATIC
operator|/
literal|32
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|disabled_vfs
index|[
name|i
index|]
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|path_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_path
argument_list|,
name|mcp_vf_disabled
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|i
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_SP
operator||
name|ECORE_MSG_IOV
operator|)
argument_list|,
literal|"FLR-ed VFs [%08x,...,%08x] - %08x\n"
argument_list|,
name|i
operator|*
literal|32
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|32
operator|-
literal|1
argument_list|,
name|disabled_vfs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecore_iov_mark_vf_flr
argument_list|(
name|p_hwfn
argument_list|,
name|disabled_vfs
argument_list|)
condition|)
name|OSAL_VF_FLR_UPDATE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_ack_vf_flr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|vfs_to_ack
parameter_list|)
block|{
name|u32
name|addr
init|=
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_FUNC
argument_list|)
decl_stmt|;
name|u32
name|mfw_func_offsize
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|u32
name|func_addr
init|=
name|SECTION_ADDR
argument_list|(
name|mfw_func_offsize
argument_list|,
name|MCP_PF_ID
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|VF_MAX_STATIC
operator|/
literal|32
operator|)
condition|;
name|i
operator|++
control|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_SP
operator||
name|ECORE_MSG_IOV
operator|)
argument_list|,
literal|"Acking VFs [%08x,...,%08x] - %08x\n"
argument_list|,
name|i
operator|*
literal|32
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|32
operator|-
literal|1
argument_list|,
name|vfs_to_ack
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_VF_DISABLED_DONE
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
name|vfs_to_ack
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
name|VF_MAX_STATIC
operator|/
literal|8
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to pass ACK for VF flr to MFW\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_TIMEOUT
return|;
block|}
comment|/* TMP - clear the ACK bits; should be done by MFW */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|VF_MAX_STATIC
operator|/
literal|32
operator|)
condition|;
name|i
operator|++
control|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|func_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_func
argument_list|,
name|drv_ack_vf_disabled
argument_list|)
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_handle_transceiver_change
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|transceiver_state
decl_stmt|;
name|transceiver_state
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_port
argument_list|,
name|transceiver_data
argument_list|)
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_HW
operator||
name|ECORE_MSG_SP
operator|)
argument_list|,
literal|"Received transceiver state update [0x%08x] from mfw [Addr 0x%x]\n"
argument_list|,
name|transceiver_state
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_port
argument_list|,
name|transceiver_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|transceiver_state
operator|=
name|GET_FIELD
argument_list|(
name|transceiver_state
argument_list|,
name|ETH_TRANSCEIVER_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|transceiver_state
operator|==
name|ETH_TRANSCEIVER_STATE_PRESENT
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Transceiver is present.\n"
argument_list|)
expr_stmt|;
else|else
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Transceiver is unplugged.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_read_eee_config
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mcp_link_state
modifier|*
name|p_link
parameter_list|)
block|{
name|u32
name|eee_status
decl_stmt|,
name|val
decl_stmt|;
name|p_link
operator|->
name|eee_adv_caps
operator|=
literal|0
expr_stmt|;
name|p_link
operator|->
name|eee_lp_adv_caps
operator|=
literal|0
expr_stmt|;
name|eee_status
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_port
argument_list|,
name|eee_status
argument_list|)
argument_list|)
expr_stmt|;
name|p_link
operator|->
name|eee_active
operator|=
operator|!
operator|!
operator|(
name|eee_status
operator|&
name|EEE_ACTIVE_BIT
operator|)
expr_stmt|;
name|val
operator|=
operator|(
name|eee_status
operator|&
name|EEE_LD_ADV_STATUS_MASK
operator|)
operator|>>
name|EEE_LD_ADV_STATUS_SHIFT
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|EEE_1G_ADV
condition|)
name|p_link
operator|->
name|eee_adv_caps
operator||=
name|ECORE_EEE_1G_ADV
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|EEE_10G_ADV
condition|)
name|p_link
operator|->
name|eee_adv_caps
operator||=
name|ECORE_EEE_10G_ADV
expr_stmt|;
name|val
operator|=
operator|(
name|eee_status
operator|&
name|EEE_LP_ADV_STATUS_MASK
operator|)
operator|>>
name|EEE_LP_ADV_STATUS_SHIFT
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|EEE_1G_ADV
condition|)
name|p_link
operator|->
name|eee_lp_adv_caps
operator||=
name|ECORE_EEE_1G_ADV
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|EEE_10G_ADV
condition|)
name|p_link
operator|->
name|eee_lp_adv_caps
operator||=
name|ECORE_EEE_10G_ADV
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_handle_link_change
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|b_reset
parameter_list|)
block|{
name|struct
name|ecore_mcp_link_state
modifier|*
name|p_link
decl_stmt|;
name|u8
name|max_bw
decl_stmt|,
name|min_bw
decl_stmt|;
name|u32
name|status
init|=
literal|0
decl_stmt|;
comment|/* Prevent SW/attentions from doing this at the same time */
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_lock
argument_list|)
expr_stmt|;
name|p_link
operator|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_output
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_link
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_reset
condition|)
block|{
name|status
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_port
argument_list|,
name|link_status
argument_list|)
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_LINK
operator||
name|ECORE_MSG_SP
operator|)
argument_list|,
literal|"Received link update [0x%08x] from mfw [Addr 0x%x]\n"
argument_list|,
name|status
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_port
argument_list|,
name|link_status
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Resetting link indications\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|p_hwfn
operator|->
name|b_drv_link_init
condition|)
name|p_link
operator|->
name|link_up
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_UP
operator|)
expr_stmt|;
else|else
name|p_link
operator|->
name|link_up
operator|=
name|false
expr_stmt|;
name|p_link
operator|->
name|full_duplex
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
operator|(
name|status
operator|&
name|LINK_STATUS_SPEED_AND_DUPLEX_MASK
operator|)
condition|)
block|{
case|case
name|LINK_STATUS_SPEED_AND_DUPLEX_100G
case|:
name|p_link
operator|->
name|speed
operator|=
literal|100000
expr_stmt|;
break|break;
case|case
name|LINK_STATUS_SPEED_AND_DUPLEX_50G
case|:
name|p_link
operator|->
name|speed
operator|=
literal|50000
expr_stmt|;
break|break;
case|case
name|LINK_STATUS_SPEED_AND_DUPLEX_40G
case|:
name|p_link
operator|->
name|speed
operator|=
literal|40000
expr_stmt|;
break|break;
case|case
name|LINK_STATUS_SPEED_AND_DUPLEX_25G
case|:
name|p_link
operator|->
name|speed
operator|=
literal|25000
expr_stmt|;
break|break;
case|case
name|LINK_STATUS_SPEED_AND_DUPLEX_20G
case|:
name|p_link
operator|->
name|speed
operator|=
literal|20000
expr_stmt|;
break|break;
case|case
name|LINK_STATUS_SPEED_AND_DUPLEX_10G
case|:
name|p_link
operator|->
name|speed
operator|=
literal|10000
expr_stmt|;
break|break;
case|case
name|LINK_STATUS_SPEED_AND_DUPLEX_1000THD
case|:
name|p_link
operator|->
name|full_duplex
operator|=
name|false
expr_stmt|;
comment|/* Fall-through */
case|case
name|LINK_STATUS_SPEED_AND_DUPLEX_1000TFD
case|:
name|p_link
operator|->
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
default|default:
name|p_link
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We never store total line speed as p_link->speed is 	 * again changes according to bandwidth allocation. 	 */
if|if
condition|(
name|p_link
operator|->
name|link_up
operator|&&
name|p_link
operator|->
name|speed
condition|)
name|p_link
operator|->
name|line_speed
operator|=
name|p_link
operator|->
name|speed
expr_stmt|;
else|else
name|p_link
operator|->
name|line_speed
operator|=
literal|0
expr_stmt|;
name|max_bw
operator|=
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|bandwidth_max
expr_stmt|;
name|min_bw
operator|=
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|bandwidth_min
expr_stmt|;
comment|/* Max bandwidth configuration */
name|__ecore_configure_pf_max_bandwidth
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_link
argument_list|,
name|max_bw
argument_list|)
expr_stmt|;
comment|/* Mintz bandwidth configuration */
name|__ecore_configure_pf_min_bandwidth
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_link
argument_list|,
name|min_bw
argument_list|)
expr_stmt|;
name|ecore_configure_vp_wfq_on_link_change
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_ptt
argument_list|,
name|p_link
operator|->
name|min_pf_rate
argument_list|)
expr_stmt|;
name|p_link
operator|->
name|an
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|LINK_STATUS_AUTO_NEGOTIATE_ENABLED
operator|)
expr_stmt|;
name|p_link
operator|->
name|an_complete
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
operator|)
expr_stmt|;
name|p_link
operator|->
name|parallel_detection
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|LINK_STATUS_PARALLEL_DETECTION_USED
operator|)
expr_stmt|;
name|p_link
operator|->
name|pfc_enabled
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|LINK_STATUS_PFC_ENABLED
operator|)
expr_stmt|;
name|p_link
operator|->
name|partner_adv_speed
operator||=
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE
operator|)
condition|?
name|ECORE_LINK_PARTNER_SPEED_1G_FD
else|:
literal|0
expr_stmt|;
name|p_link
operator|->
name|partner_adv_speed
operator||=
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_1000THD_CAPABLE
operator|)
condition|?
name|ECORE_LINK_PARTNER_SPEED_1G_HD
else|:
literal|0
expr_stmt|;
name|p_link
operator|->
name|partner_adv_speed
operator||=
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_10G_CAPABLE
operator|)
condition|?
name|ECORE_LINK_PARTNER_SPEED_10G
else|:
literal|0
expr_stmt|;
name|p_link
operator|->
name|partner_adv_speed
operator||=
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_20G_CAPABLE
operator|)
condition|?
name|ECORE_LINK_PARTNER_SPEED_20G
else|:
literal|0
expr_stmt|;
name|p_link
operator|->
name|partner_adv_speed
operator||=
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_25G_CAPABLE
operator|)
condition|?
name|ECORE_LINK_PARTNER_SPEED_25G
else|:
literal|0
expr_stmt|;
name|p_link
operator|->
name|partner_adv_speed
operator||=
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_40G_CAPABLE
operator|)
condition|?
name|ECORE_LINK_PARTNER_SPEED_40G
else|:
literal|0
expr_stmt|;
name|p_link
operator|->
name|partner_adv_speed
operator||=
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_50G_CAPABLE
operator|)
condition|?
name|ECORE_LINK_PARTNER_SPEED_50G
else|:
literal|0
expr_stmt|;
name|p_link
operator|->
name|partner_adv_speed
operator||=
operator|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_100G_CAPABLE
operator|)
condition|?
name|ECORE_LINK_PARTNER_SPEED_100G
else|:
literal|0
expr_stmt|;
name|p_link
operator|->
name|partner_tx_flow_ctrl_en
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|LINK_STATUS_TX_FLOW_CONTROL_ENABLED
operator|)
expr_stmt|;
name|p_link
operator|->
name|partner_rx_flow_ctrl_en
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|LINK_STATUS_RX_FLOW_CONTROL_ENABLED
operator|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|LINK_STATUS_LINK_PARTNER_FLOW_CONTROL_MASK
condition|)
block|{
case|case
name|LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE
case|:
name|p_link
operator|->
name|partner_adv_pause
operator|=
name|ECORE_LINK_PARTNER_SYMMETRIC_PAUSE
expr_stmt|;
break|break;
case|case
name|LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE
case|:
name|p_link
operator|->
name|partner_adv_pause
operator|=
name|ECORE_LINK_PARTNER_ASYMMETRIC_PAUSE
expr_stmt|;
break|break;
case|case
name|LINK_STATUS_LINK_PARTNER_BOTH_PAUSE
case|:
name|p_link
operator|->
name|partner_adv_pause
operator|=
name|ECORE_LINK_PARTNER_BOTH_PAUSE
expr_stmt|;
break|break;
default|default:
name|p_link
operator|->
name|partner_adv_pause
operator|=
literal|0
expr_stmt|;
block|}
name|p_link
operator|->
name|sfp_tx_fault
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|LINK_STATUS_SFP_TX_FAULT
operator|)
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|capabilities
operator|&
name|FW_MB_PARAM_FEATURE_SUPPORT_EEE
condition|)
name|ecore_mcp_read_eee_config
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_link
argument_list|)
expr_stmt|;
name|OSAL_LINK_UPDATE
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|out
label|:
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_set_link
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|b_up
parameter_list|)
block|{
name|struct
name|ecore_mcp_link_params
modifier|*
name|params
init|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_input
decl_stmt|;
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|struct
name|eth_phy_cfg
name|phy_cfg
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u32
name|cmd
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
endif|#
directive|endif
comment|/* Set the shmem configuration according to params */
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|phy_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|phy_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|b_up
condition|?
name|DRV_MSG_CODE_INIT_PHY
else|:
name|DRV_MSG_CODE_LINK_RESET
expr_stmt|;
if|if
condition|(
operator|!
name|params
operator|->
name|speed
operator|.
name|autoneg
condition|)
name|phy_cfg
operator|.
name|speed
operator|=
name|params
operator|->
name|speed
operator|.
name|forced_speed
expr_stmt|;
name|phy_cfg
operator|.
name|pause
operator||=
operator|(
name|params
operator|->
name|pause
operator|.
name|autoneg
operator|)
condition|?
name|ETH_PAUSE_AUTONEG
else|:
literal|0
expr_stmt|;
name|phy_cfg
operator|.
name|pause
operator||=
operator|(
name|params
operator|->
name|pause
operator|.
name|forced_rx
operator|)
condition|?
name|ETH_PAUSE_RX
else|:
literal|0
expr_stmt|;
name|phy_cfg
operator|.
name|pause
operator||=
operator|(
name|params
operator|->
name|pause
operator|.
name|forced_tx
operator|)
condition|?
name|ETH_PAUSE_TX
else|:
literal|0
expr_stmt|;
name|phy_cfg
operator|.
name|adv_speed
operator|=
name|params
operator|->
name|speed
operator|.
name|advertised_speeds
expr_stmt|;
name|phy_cfg
operator|.
name|loopback_mode
operator|=
name|params
operator|->
name|loopback_mode
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|capabilities
operator|&
name|FW_MB_PARAM_FEATURE_SUPPORT_EEE
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|eee
operator|.
name|enable
condition|)
name|phy_cfg
operator|.
name|eee_cfg
operator||=
name|EEE_CFG_EEE_ENABLED
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|eee
operator|.
name|tx_lpi_enable
condition|)
name|phy_cfg
operator|.
name|eee_cfg
operator||=
name|EEE_CFG_TX_LPI
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|eee
operator|.
name|adv_caps
operator|&
name|ECORE_EEE_1G_ADV
condition|)
name|phy_cfg
operator|.
name|eee_cfg
operator||=
name|EEE_CFG_ADV_SPEED_1G
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|eee
operator|.
name|adv_caps
operator|&
name|ECORE_EEE_10G_ADV
condition|)
name|phy_cfg
operator|.
name|eee_cfg
operator||=
name|EEE_CFG_ADV_SPEED_10G
expr_stmt|;
name|phy_cfg
operator|.
name|eee_cfg
operator||=
operator|(
name|params
operator|->
name|eee
operator|.
name|tx_lpi_timer
operator|<<
name|EEE_TX_TIMER_USEC_SHIFT
operator|)
operator|&
name|EEE_TX_TIMER_USEC_MASK
expr_stmt|;
block|}
name|p_hwfn
operator|->
name|b_drv_link_init
operator|=
name|b_up
expr_stmt|;
if|if
condition|(
name|b_up
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Configuring Link: Speed 0x%08x, Pause 0x%08x, adv_speed 0x%08x, loopback 0x%08x\n"
argument_list|,
name|phy_cfg
operator|.
name|speed
argument_list|,
name|phy_cfg
operator|.
name|pause
argument_list|,
name|phy_cfg
operator|.
name|adv_speed
argument_list|,
name|phy_cfg
operator|.
name|loopback_mode
argument_list|)
expr_stmt|;
else|else
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Resetting link\n"
argument_list|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|phy_cfg
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|phy_cfg
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
comment|/* if mcp fails to respond we must abort */
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* Mimic link-change attention, done for several reasons: 	 *  - On reset, there's no guarantee MFW would trigger 	 *    an attention. 	 *  - On initialization, older MFWs might not indicate link change 	 *    during LFA, so we'll never get an UP indication. 	 */
name|ecore_mcp_handle_link_change
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|!
name|b_up
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|u32
name|ecore_get_process_kill_counter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|path_offsize_addr
decl_stmt|,
name|path_offsize
decl_stmt|,
name|path_addr
decl_stmt|,
name|proc_kill_cnt
decl_stmt|;
comment|/* TODO - Add support for VFs */
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
name|path_offsize_addr
operator|=
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_PATH
argument_list|)
expr_stmt|;
name|path_offsize
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|path_offsize_addr
argument_list|)
expr_stmt|;
name|path_addr
operator|=
name|SECTION_ADDR
argument_list|(
name|path_offsize
argument_list|,
name|ECORE_PATH_ID
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
name|proc_kill_cnt
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|path_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_path
argument_list|,
name|process_kill
argument_list|)
argument_list|)
operator|&
name|PROCESS_KILL_COUNTER_MASK
expr_stmt|;
return|return
name|proc_kill_cnt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_handle_process_kill
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_dev
modifier|*
name|p_dev
init|=
name|p_hwfn
operator|->
name|p_dev
decl_stmt|;
name|u32
name|proc_kill_cnt
decl_stmt|;
comment|/* Prevent possible attentions/interrupts during the recovery handling 	 * and till its load phase, during which they will be re-enabled. 	 */
name|ecore_int_igu_disable_int
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Received a process kill indication\n"
argument_list|)
expr_stmt|;
comment|/* The following operations should be done once, and thus in CMT mode 	 * are carried out by only the first HW function. 	 */
if|if
condition|(
name|p_hwfn
operator|!=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
condition|)
return|return;
if|if
condition|(
name|p_dev
operator|->
name|recov_in_prog
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Ignoring the indication since a recovery process is already in progress\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_dev
operator|->
name|recov_in_prog
operator|=
name|true
expr_stmt|;
name|proc_kill_cnt
operator|=
name|ecore_get_process_kill_counter
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Process kill counter: %d\n"
argument_list|,
name|proc_kill_cnt
argument_list|)
expr_stmt|;
name|OSAL_SCHEDULE_RECOVERY_HANDLER
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_send_protocol_stats
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|MFW_DRV_MSG_TYPE
name|type
parameter_list|)
block|{
name|enum
name|ecore_mcp_protocol_type
name|stats_type
decl_stmt|;
name|union
name|ecore_mcp_protocol_stats
name|stats
decl_stmt|;
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|u32
name|hsi_param
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MFW_DRV_MSG_GET_LAN_STATS
case|:
name|stats_type
operator|=
name|ECORE_MCP_LAN_STATS
expr_stmt|;
name|hsi_param
operator|=
name|DRV_MSG_CODE_STATS_TYPE_LAN
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_GET_FCOE_STATS
case|:
name|stats_type
operator|=
name|ECORE_MCP_FCOE_STATS
expr_stmt|;
name|hsi_param
operator|=
name|DRV_MSG_CODE_STATS_TYPE_FCOE
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_GET_ISCSI_STATS
case|:
name|stats_type
operator|=
name|ECORE_MCP_ISCSI_STATS
expr_stmt|;
name|hsi_param
operator|=
name|DRV_MSG_CODE_STATS_TYPE_ISCSI
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_GET_RDMA_STATS
case|:
name|stats_type
operator|=
name|ECORE_MCP_RDMA_STATS
expr_stmt|;
name|hsi_param
operator|=
name|DRV_MSG_CODE_STATS_TYPE_RDMA
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Invalid protocol type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
name|OSAL_GET_PROTOCOL_STATS
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|stats_type
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_GET_STATS
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|hsi_param
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|stats
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to send protocol stats, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_read_pf_bandwidth
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|public_func
modifier|*
name|p_shmem_info
parameter_list|)
block|{
name|struct
name|ecore_mcp_function_info
modifier|*
name|p_info
decl_stmt|;
name|p_info
operator|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
expr_stmt|;
comment|/* TODO - bandwidth min/max should have valid values of 1-100, 	 * as well as some indication that the feature is disabled. 	 * Until MFW/qlediag enforce those limitations, Assume THERE IS ALWAYS 	 * limit and correct value to min `1' and max `100' if limit isn't in 	 * range. 	 */
name|p_info
operator|->
name|bandwidth_min
operator|=
operator|(
name|p_shmem_info
operator|->
name|config
operator|&
name|FUNC_MF_CFG_MIN_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MIN_BW_SHIFT
expr_stmt|;
if|if
condition|(
name|p_info
operator|->
name|bandwidth_min
operator|<
literal|1
operator|||
name|p_info
operator|->
name|bandwidth_min
operator|>
literal|100
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"bandwidth minimum out of bounds [%02x]. Set to 1\n"
argument_list|,
name|p_info
operator|->
name|bandwidth_min
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|bandwidth_min
operator|=
literal|1
expr_stmt|;
block|}
name|p_info
operator|->
name|bandwidth_max
operator|=
operator|(
name|p_shmem_info
operator|->
name|config
operator|&
name|FUNC_MF_CFG_MAX_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MAX_BW_SHIFT
expr_stmt|;
if|if
condition|(
name|p_info
operator|->
name|bandwidth_max
operator|<
literal|1
operator|||
name|p_info
operator|->
name|bandwidth_max
operator|>
literal|100
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"bandwidth maximum out of bounds [%02x]. Set to 100\n"
argument_list|,
name|p_info
operator|->
name|bandwidth_max
argument_list|)
expr_stmt|;
name|p_info
operator|->
name|bandwidth_max
operator|=
literal|100
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u32
name|ecore_mcp_get_shmem_func
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|public_func
modifier|*
name|p_data
parameter_list|,
name|int
name|pfid
parameter_list|)
block|{
name|u32
name|addr
init|=
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_FUNC
argument_list|)
decl_stmt|;
name|u32
name|mfw_path_offsize
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|u32
name|func_addr
init|=
name|SECTION_ADDR
argument_list|(
name|mfw_path_offsize
argument_list|,
name|pfid
argument_list|)
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|size
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
name|p_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_data
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_data
argument_list|)
argument_list|,
name|SECTION_SIZE
argument_list|(
name|mfw_path_offsize
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|u32
operator|*
operator|)
name|p_data
operator|)
index|[
name|i
index|]
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|func_addr
operator|+
operator|(
name|i
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This was introduced with FW 8.10.5.0; Hopefully this is only temp. */
end_comment

begin_comment
unit|enum _ecore_status_t ecore_hw_init_first_eth(struct ecore_hwfn *p_hwfn, 					     struct ecore_ptt *p_ptt, 					     u8 *p_pf) { 	struct public_func shmem_info; 	int i;
comment|/* Find first Ethernet interface in port */
end_comment

begin_comment
unit|for (i = 0; i< NUM_OF_ENG_PFS(p_hwfn->p_dev); 	     i += p_hwfn->p_dev->num_ports_in_engines) { 		ecore_mcp_get_shmem_func(p_hwfn, p_ptt,&shmem_info, 					 MCP_PF_ID_BY_REL(p_hwfn, i));  		if (shmem_info.config& FUNC_MF_CFG_FUNC_HIDE) 			continue;  		if ((shmem_info.config& FUNC_MF_CFG_PROTOCOL_MASK) == 		    FUNC_MF_CFG_PROTOCOL_ETHERNET) { 			*p_pf = (u8)i; 			return ECORE_SUCCESS; 		} 	}
comment|/* This might actually be valid somewhere in the future but for now 	 * it's highly unlikely. 	 */
end_comment

begin_endif
unit|DP_NOTICE(p_hwfn, false, 		  "Failed to find on port an ethernet interface in MF_SI mode\n");  	return ECORE_INVAL; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ecore_mcp_update_bw
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mcp_function_info
modifier|*
name|p_info
decl_stmt|;
name|struct
name|public_func
name|shmem_info
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|ecore_mcp_get_shmem_func
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|shmem_info
argument_list|,
name|MCP_PF_ID
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_read_pf_bandwidth
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|shmem_info
argument_list|)
expr_stmt|;
name|p_info
operator|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
expr_stmt|;
name|ecore_configure_pf_min_bandwidth
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_info
operator|->
name|bandwidth_min
argument_list|)
expr_stmt|;
name|ecore_configure_pf_max_bandwidth
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_info
operator|->
name|bandwidth_max
argument_list|)
expr_stmt|;
comment|/* Acknowledge the MFW */
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_BW_UPDATE_ACK
argument_list|,
literal|0
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_update_stag
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|public_func
name|shmem_info
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|ecore_mcp_get_shmem_func
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|shmem_info
argument_list|,
name|MCP_PF_ID
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|ovlan
operator|=
operator|(
name|u16
operator|)
name|shmem_info
operator|.
name|ovlan_stag
operator|&
name|FUNC_MF_CFG_OV_STAG_MASK
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|ovlan
operator|=
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
operator|.
name|ovlan
expr_stmt|;
if|if
condition|(
operator|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|hw_mode
operator|&
operator|(
literal|1
operator|<<
name|MODE_MF_SD
operator|)
operator|)
operator|&&
operator|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|ovlan
operator|!=
name|ECORE_MCP_VLAN_UNSET
operator|)
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_LLH_FUNC_TAG_VALUE
argument_list|,
name|p_hwfn
operator|->
name|hw_info
operator|.
name|ovlan
argument_list|)
expr_stmt|;
name|OSAL_HW_INFO_CHANGE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_INFO_CHANGE_OVLAN
argument_list|)
expr_stmt|;
comment|/* Acknowledge the MFW */
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_S_TAG_UPDATE_ACK
argument_list|,
literal|0
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_handle_fan_failure
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
comment|/* A single notification should be sent to upper driver in CMT mode */
if|if
condition|(
name|p_hwfn
operator|!=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Fan failure was detected on the network interface card and it's going to be shut down.\n"
argument_list|)
expr_stmt|;
name|ecore_hw_err_notify
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_ERR_FAN_FAIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|ecore_mdump_cmd_params
block|{
name|u32
name|cmd
decl_stmt|;
name|void
modifier|*
name|p_data_src
decl_stmt|;
name|u8
name|data_src_size
decl_stmt|;
name|void
modifier|*
name|p_data_dst
decl_stmt|;
name|u8
name|data_dst_size
decl_stmt|;
name|u32
name|mcp_resp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mdump_cmd_params
modifier|*
name|p_mdump_cmd_params
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_MDUMP_CMD
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|p_mdump_cmd_params
operator|->
name|cmd
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
name|p_mdump_cmd_params
operator|->
name|p_data_src
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
name|p_mdump_cmd_params
operator|->
name|data_src_size
expr_stmt|;
name|mb_params
operator|.
name|p_data_dst
operator|=
name|p_mdump_cmd_params
operator|->
name|p_data_dst
expr_stmt|;
name|mb_params
operator|.
name|data_dst_size
operator|=
name|p_mdump_cmd_params
operator|->
name|data_dst_size
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|p_mdump_cmd_params
operator|->
name|mcp_resp
operator|=
name|mb_params
operator|.
name|mcp_resp
expr_stmt|;
if|if
condition|(
name|p_mdump_cmd_params
operator|->
name|mcp_resp
operator|==
name|FW_MSG_CODE_MDUMP_INVALID_CMD
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"The mdump sub command is unsupported by the MFW [mdump_cmd 0x%x]\n"
argument_list|,
name|p_mdump_cmd_params
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_NOTIMPL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_mdump_cmd_params
operator|->
name|mcp_resp
operator|==
name|FW_MSG_CODE_UNSUPPORTED
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"The mdump command is not supported by the MFW\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_NOTIMPL
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_ack
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mdump_cmd_params
name|mdump_cmd_params
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mdump_cmd_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mdump_cmd_params
argument_list|)
argument_list|)
expr_stmt|;
name|mdump_cmd_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_MDUMP_ACK
expr_stmt|;
return|return
name|ecore_mcp_mdump_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_cmd_params
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_set_values
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|epoch
parameter_list|)
block|{
name|struct
name|ecore_mdump_cmd_params
name|mdump_cmd_params
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mdump_cmd_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mdump_cmd_params
argument_list|)
argument_list|)
expr_stmt|;
name|mdump_cmd_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_MDUMP_SET_VALUES
expr_stmt|;
name|mdump_cmd_params
operator|.
name|p_data_src
operator|=
operator|&
name|epoch
expr_stmt|;
name|mdump_cmd_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|epoch
argument_list|)
expr_stmt|;
return|return
name|ecore_mcp_mdump_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_cmd_params
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_trigger
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mdump_cmd_params
name|mdump_cmd_params
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mdump_cmd_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mdump_cmd_params
argument_list|)
argument_list|)
expr_stmt|;
name|mdump_cmd_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_MDUMP_TRIGGER
expr_stmt|;
return|return
name|ecore_mcp_mdump_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_cmd_params
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_get_config
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|mdump_config_stc
modifier|*
name|p_mdump_config
parameter_list|)
block|{
name|struct
name|ecore_mdump_cmd_params
name|mdump_cmd_params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mdump_cmd_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mdump_cmd_params
argument_list|)
argument_list|)
expr_stmt|;
name|mdump_cmd_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_MDUMP_GET_CONFIG
expr_stmt|;
name|mdump_cmd_params
operator|.
name|p_data_dst
operator|=
name|p_mdump_config
expr_stmt|;
name|mdump_cmd_params
operator|.
name|data_dst_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_mdump_config
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_mdump_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_cmd_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|mdump_cmd_params
operator|.
name|mcp_resp
operator|!=
name|FW_MSG_CODE_OK
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to get the mdump configuration and logs info [mcp_resp 0x%x]\n"
argument_list|,
name|mdump_cmd_params
operator|.
name|mcp_resp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_get_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mdump_info
modifier|*
name|p_mdump_info
parameter_list|)
block|{
name|u32
name|addr
decl_stmt|,
name|global_offsize
decl_stmt|,
name|global_addr
decl_stmt|;
name|struct
name|mdump_config_stc
name|mdump_config
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
name|p_mdump_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_mdump_info
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_GLOBAL
argument_list|)
expr_stmt|;
name|global_offsize
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|global_addr
operator|=
name|SECTION_ADDR
argument_list|(
name|global_offsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_mdump_info
operator|->
name|reason
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|global_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_global
argument_list|,
name|mdump_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mdump_info
operator|->
name|reason
condition|)
block|{
name|rc
operator|=
name|ecore_mcp_mdump_get_config
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|p_mdump_info
operator|->
name|version
operator|=
name|mdump_config
operator|.
name|version
expr_stmt|;
name|p_mdump_info
operator|->
name|config
operator|=
name|mdump_config
operator|.
name|config
expr_stmt|;
name|p_mdump_info
operator|->
name|epoch
operator|=
name|mdump_config
operator|.
name|epoc
expr_stmt|;
name|p_mdump_info
operator|->
name|num_of_logs
operator|=
name|mdump_config
operator|.
name|num_of_logs
expr_stmt|;
name|p_mdump_info
operator|->
name|valid_logs
operator|=
name|mdump_config
operator|.
name|valid_logs
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"MFW mdump info: reason %d, version 0x%x, config 0x%x, epoch 0x%x, num_of_logs 0x%x, valid_logs 0x%x\n"
argument_list|,
name|p_mdump_info
operator|->
name|reason
argument_list|,
name|p_mdump_info
operator|->
name|version
argument_list|,
name|p_mdump_info
operator|->
name|config
argument_list|,
name|p_mdump_info
operator|->
name|epoch
argument_list|,
name|p_mdump_info
operator|->
name|num_of_logs
argument_list|,
name|p_mdump_info
operator|->
name|valid_logs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"MFW mdump info: reason %d\n"
argument_list|,
name|p_mdump_info
operator|->
name|reason
argument_list|)
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_clear_logs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mdump_cmd_params
name|mdump_cmd_params
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mdump_cmd_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mdump_cmd_params
argument_list|)
argument_list|)
expr_stmt|;
name|mdump_cmd_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_MDUMP_CLEAR_LOGS
expr_stmt|;
return|return
name|ecore_mcp_mdump_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_cmd_params
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_get_retain
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mdump_retain_data
modifier|*
name|p_mdump_retain
parameter_list|)
block|{
name|struct
name|ecore_mdump_cmd_params
name|mdump_cmd_params
decl_stmt|;
name|struct
name|mdump_retain_data_stc
name|mfw_mdump_retain
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mdump_cmd_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mdump_cmd_params
argument_list|)
argument_list|)
expr_stmt|;
name|mdump_cmd_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_MDUMP_GET_RETAIN
expr_stmt|;
name|mdump_cmd_params
operator|.
name|p_data_dst
operator|=
operator|&
name|mfw_mdump_retain
expr_stmt|;
name|mdump_cmd_params
operator|.
name|data_dst_size
operator|=
sizeof|sizeof
argument_list|(
name|mfw_mdump_retain
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_mdump_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_cmd_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|mdump_cmd_params
operator|.
name|mcp_resp
operator|!=
name|FW_MSG_CODE_OK
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to get the mdump retained data [mcp_resp 0x%x]\n"
argument_list|,
name|mdump_cmd_params
operator|.
name|mcp_resp
argument_list|)
expr_stmt|;
return|return
name|ECORE_UNKNOWN_ERROR
return|;
block|}
name|p_mdump_retain
operator|->
name|valid
operator|=
name|mfw_mdump_retain
operator|.
name|valid
expr_stmt|;
name|p_mdump_retain
operator|->
name|epoch
operator|=
name|mfw_mdump_retain
operator|.
name|epoch
expr_stmt|;
name|p_mdump_retain
operator|->
name|pf
operator|=
name|mfw_mdump_retain
operator|.
name|pf
expr_stmt|;
name|p_mdump_retain
operator|->
name|status
operator|=
name|mfw_mdump_retain
operator|.
name|status
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_mdump_clr_retain
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mdump_cmd_params
name|mdump_cmd_params
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mdump_cmd_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mdump_cmd_params
argument_list|)
argument_list|)
expr_stmt|;
name|mdump_cmd_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_MDUMP_CLR_RETAIN
expr_stmt|;
return|return
name|ecore_mcp_mdump_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_cmd_params
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcp_handle_critical_error
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mdump_retain_data
name|mdump_retain
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* In CMT mode - no need for more than a single acknowledgement to the 	 * MFW, and no more than a single notification to the upper driver. 	 */
if|if
condition|(
name|p_hwfn
operator|!=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return;
name|rc
operator|=
name|ecore_mcp_mdump_get_retain
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mdump_retain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
operator|&&
name|mdump_retain
operator|.
name|valid
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"The MFW notified that a critical error occurred in the device [epoch 0x%08x, pf 0x%x, status 0x%08x]\n"
argument_list|,
name|mdump_retain
operator|.
name|epoch
argument_list|,
name|mdump_retain
operator|.
name|pf
argument_list|,
name|mdump_retain
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"The MFW notified that a critical error occurred in the device\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|allow_mdump
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Not acknowledging the notification to allow the MFW crash dump\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Acknowledging the notification to not allow the MFW crash dump [driver debug data collection is preferable]\n"
argument_list|)
expr_stmt|;
name|ecore_mcp_mdump_ack
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_hw_err_notify
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_ERR_HW_ATTN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_handle_events
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mcp_info
modifier|*
name|info
init|=
name|p_hwfn
operator|->
name|mcp_info
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Received message from MFW\n"
argument_list|)
expr_stmt|;
comment|/* Read Messages from MFW */
name|ecore_mcp_read_mb
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* Compare current messages to old ones */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|mfw_mb_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|->
name|mfw_mb_cur
index|[
name|i
index|]
operator|==
name|info
operator|->
name|mfw_mb_shadow
index|[
name|i
index|]
condition|)
continue|continue;
name|found
operator|=
name|true
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_LINK
argument_list|,
literal|"Msg [%d] - old CMD 0x%02x, new CMD 0x%02x\n"
argument_list|,
name|i
argument_list|,
name|info
operator|->
name|mfw_mb_shadow
index|[
name|i
index|]
argument_list|,
name|info
operator|->
name|mfw_mb_cur
index|[
name|i
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|MFW_DRV_MSG_LINK_CHANGE
case|:
name|ecore_mcp_handle_link_change
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_VF_DISABLED
case|:
name|ecore_mcp_handle_vf_flr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_LLDP_DATA_UPDATED
case|:
name|ecore_dcbx_mib_update_event
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|ECORE_DCBX_REMOTE_LLDP_MIB
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_DCBX_REMOTE_MIB_UPDATED
case|:
name|ecore_dcbx_mib_update_event
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|ECORE_DCBX_REMOTE_MIB
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_DCBX_OPERATIONAL_MIB_UPDATED
case|:
name|ecore_dcbx_mib_update_event
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|ECORE_DCBX_OPERATIONAL_MIB
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_TRANSCEIVER_STATE_CHANGE
case|:
name|ecore_mcp_handle_transceiver_change
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_ERROR_RECOVERY
case|:
name|ecore_mcp_handle_process_kill
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_GET_LAN_STATS
case|:
case|case
name|MFW_DRV_MSG_GET_FCOE_STATS
case|:
case|case
name|MFW_DRV_MSG_GET_ISCSI_STATS
case|:
case|case
name|MFW_DRV_MSG_GET_RDMA_STATS
case|:
name|ecore_mcp_send_protocol_stats
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_BW_UPDATE
case|:
name|ecore_mcp_update_bw
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_S_TAG_UPDATE
case|:
name|ecore_mcp_update_stag
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_FAILURE_DETECTED
case|:
name|ecore_mcp_handle_fan_failure
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_CRITICAL_ERROR_OCCURRED
case|:
name|ecore_mcp_handle_critical_error
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFW_DRV_MSG_GET_TLV_REQ
case|:
name|OSAL_MFW_TLV_REQ
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Unimplemented MFW message %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
block|}
block|}
comment|/* ACK everything */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MFW_DRV_MSG_MAX_DWORDS
argument_list|(
name|info
operator|->
name|mfw_mb_length
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|OSAL_BE32
name|val
init|=
name|OSAL_CPU_TO_BE32
argument_list|(
operator|(
operator|(
name|u32
operator|*
operator|)
name|info
operator|->
name|mfw_mb_cur
operator|)
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|/* MFW expect answer in BE, so we force write in that format */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|info
operator|->
name|mfw_mb_addr
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|+
name|MFW_DRV_MSG_MAX_DWORDS
argument_list|(
name|info
operator|->
name|mfw_mb_length
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Received an MFW message indication but no new message!\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
block|}
comment|/* Copy the new mfw messages into the shadow */
name|OSAL_MEMCPY
argument_list|(
name|info
operator|->
name|mfw_mb_shadow
argument_list|,
name|info
operator|->
name|mfw_mb_cur
argument_list|,
name|info
operator|->
name|mfw_mb_length
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_mfw_ver
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|p_mfw_ver
parameter_list|,
name|u32
modifier|*
name|p_running_bundle_id
parameter_list|)
block|{
name|u32
name|global_offsize
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Emulation - can't get MFW version\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|vf_iov_info
condition|)
block|{
name|struct
name|pfvf_acquire_resp_tlv
modifier|*
name|p_resp
decl_stmt|;
name|p_resp
operator|=
operator|&
name|p_hwfn
operator|->
name|vf_iov_info
operator|->
name|acquire_resp
expr_stmt|;
operator|*
name|p_mfw_ver
operator|=
name|p_resp
operator|->
name|pfdev_info
operator|.
name|mfw_ver
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
else|else
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IOV
argument_list|,
literal|"VF requested MFW version prior to ACQUIRE\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
block|}
name|global_offsize
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|SECTION_OFFSIZE_ADDR
argument_list|(
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|public_base
argument_list|,
name|PUBLIC_GLOBAL
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_mfw_ver
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|SECTION_ADDR
argument_list|(
name|global_offsize
argument_list|,
literal|0
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_global
argument_list|,
name|mfw_ver
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_running_bundle_id
operator|!=
name|OSAL_NULL
condition|)
block|{
operator|*
name|p_running_bundle_id
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|SECTION_ADDR
argument_list|(
name|global_offsize
argument_list|,
literal|0
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_global
argument_list|,
name|running_bundle_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_mbi_ver
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|p_mbi_ver
parameter_list|)
block|{
name|u32
name|nvm_cfg_addr
decl_stmt|,
name|nvm_cfg1_offset
decl_stmt|,
name|mbi_ver_addr
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Emulation - can't get MBI version\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
comment|/* Read the address of the nvm_cfg */
name|nvm_cfg_addr
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_GEN_PURP_CR0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nvm_cfg_addr
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Shared memory not initialized\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Read the offset of nvm_cfg1 */
name|nvm_cfg1_offset
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|nvm_cfg_addr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|mbi_ver_addr
operator|=
name|MCP_REG_SCRATCH
operator|+
name|nvm_cfg1_offset
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1
argument_list|,
name|glob
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|nvm_cfg1_glob
argument_list|,
name|mbi_version
argument_list|)
expr_stmt|;
operator|*
name|p_mbi_ver
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|mbi_ver_addr
argument_list|)
operator|&
operator|(
name|NVM_CFG1_GLOB_MBI_VERSION_0_MASK
operator||
name|NVM_CFG1_GLOB_MBI_VERSION_1_MASK
operator||
name|NVM_CFG1_GLOB_MBI_VERSION_2_MASK
operator|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_media_type
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
modifier|*
name|p_media_type
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
operator|&
name|p_dev
operator|->
name|hwfns
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
comment|/* TODO - Add support for VFs */
if|if
condition|(
name|IS_VF
argument_list|(
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
if|if
condition|(
operator|!
name|ecore_mcp_is_init
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"MFW is not initialized!\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
block|}
operator|*
name|p_media_type
operator|=
name|MEDIA_UNSPECIFIED
expr_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
operator|*
name|p_media_type
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_port
argument_list|,
name|media_type
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Old MFW has a global configuration for all PFs regarding RDMA support */
end_comment

begin_function
specifier|static
name|void
name|ecore_mcp_get_shmem_proto_legacy
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_pci_personality
modifier|*
name|p_proto
parameter_list|)
block|{
comment|/* There wasn't ever a legacy MFW that published iwarp. 	 * So at this point, this is either plain l2 or RoCE. 	 */
if|if
condition|(
name|OSAL_TEST_BIT
argument_list|(
name|ECORE_DEV_CAP_ROCE
argument_list|,
operator|&
name|p_hwfn
operator|->
name|hw_info
operator|.
name|device_capabilities
argument_list|)
condition|)
operator|*
name|p_proto
operator|=
name|ECORE_PCI_ETH_ROCE
expr_stmt|;
else|else
operator|*
name|p_proto
operator|=
name|ECORE_PCI_ETH
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IFUP
argument_list|,
literal|"According to Legacy capabilities, L2 personality is %08x\n"
argument_list|,
operator|(
name|u32
operator|)
operator|*
name|p_proto
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_get_shmem_proto_mfw
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_pci_personality
modifier|*
name|p_proto
parameter_list|)
block|{
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_GET_PF_RDMA_PROTOCOL
argument_list|,
literal|0
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|resp
operator|!=
name|FW_MSG_CODE_OK
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IFUP
argument_list|,
literal|"MFW lacks support for command; Returns %08x\n"
argument_list|,
name|resp
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|FW_MB_PARAM_GET_PF_RDMA_NONE
case|:
operator|*
name|p_proto
operator|=
name|ECORE_PCI_ETH
expr_stmt|;
break|break;
case|case
name|FW_MB_PARAM_GET_PF_RDMA_ROCE
case|:
operator|*
name|p_proto
operator|=
name|ECORE_PCI_ETH_ROCE
expr_stmt|;
break|break;
case|case
name|FW_MB_PARAM_GET_PF_RDMA_IWARP
case|:
operator|*
name|p_proto
operator|=
name|ECORE_PCI_ETH_IWARP
expr_stmt|;
break|break;
case|case
name|FW_MB_PARAM_GET_PF_RDMA_BOTH
case|:
operator|*
name|p_proto
operator|=
name|ECORE_PCI_ETH_RDMA
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"MFW answers GET_PF_RDMA_PROTOCOL but param is %08x\n"
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IFUP
argument_list|,
literal|"According to capabilities, L2 personality is %08x [resp %08x param %08x]\n"
argument_list|,
operator|(
name|u32
operator|)
operator|*
name|p_proto
argument_list|,
name|resp
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_get_shmem_proto
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|public_func
modifier|*
name|p_info
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_pci_personality
modifier|*
name|p_proto
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
switch|switch
condition|(
name|p_info
operator|->
name|config
operator|&
name|FUNC_MF_CFG_PROTOCOL_MASK
condition|)
block|{
case|case
name|FUNC_MF_CFG_PROTOCOL_ETHERNET
case|:
if|if
condition|(
name|ecore_mcp_get_shmem_proto_mfw
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_proto
argument_list|)
operator|!=
name|ECORE_SUCCESS
condition|)
name|ecore_mcp_get_shmem_proto_legacy
argument_list|(
name|p_hwfn
argument_list|,
name|p_proto
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC_MF_CFG_PROTOCOL_ISCSI
case|:
operator|*
name|p_proto
operator|=
name|ECORE_PCI_ISCSI
expr_stmt|;
break|break;
case|case
name|FUNC_MF_CFG_PROTOCOL_FCOE
case|:
operator|*
name|p_proto
operator|=
name|ECORE_PCI_FCOE
expr_stmt|;
break|break;
case|case
name|FUNC_MF_CFG_PROTOCOL_ROCE
case|:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"RoCE personality is not a valid value!\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_fill_shmem_func_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_mcp_function_info
modifier|*
name|info
decl_stmt|;
name|struct
name|public_func
name|shmem_info
decl_stmt|;
name|ecore_mcp_get_shmem_func
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|shmem_info
argument_list|,
name|MCP_PF_ID
argument_list|(
name|p_hwfn
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|=
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
expr_stmt|;
name|info
operator|->
name|pause_on_host
operator|=
operator|(
name|shmem_info
operator|.
name|config
operator|&
name|FUNC_MF_CFG_PAUSE_ON_HOST_RING
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ecore_mcp_get_shmem_proto
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|shmem_info
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|info
operator|->
name|protocol
argument_list|)
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Unknown personality %08x\n"
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|shmem_info
operator|.
name|config
operator|&
name|FUNC_MF_CFG_PROTOCOL_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|ecore_read_pf_bandwidth
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|shmem_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmem_info
operator|.
name|mac_upper
operator|||
name|shmem_info
operator|.
name|mac_lower
condition|)
block|{
name|info
operator|->
name|mac
index|[
literal|0
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|shmem_info
operator|.
name|mac_upper
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|info
operator|->
name|mac
index|[
literal|1
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|shmem_info
operator|.
name|mac_upper
argument_list|)
expr_stmt|;
name|info
operator|->
name|mac
index|[
literal|2
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|shmem_info
operator|.
name|mac_lower
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|info
operator|->
name|mac
index|[
literal|3
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|shmem_info
operator|.
name|mac_lower
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|info
operator|->
name|mac
index|[
literal|4
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|shmem_info
operator|.
name|mac_lower
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|info
operator|->
name|mac
index|[
literal|5
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|shmem_info
operator|.
name|mac_lower
argument_list|)
expr_stmt|;
comment|/* Store primary MAC for later possible WoL */
name|OSAL_MEMCPY
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_dev
operator|->
name|wol_mac
argument_list|,
name|info
operator|->
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO - are there protocols for which there's no MAC? */
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"MAC is 0 in shmem\n"
argument_list|)
expr_stmt|;
block|}
comment|/* TODO - are these calculations true for BE machine? */
name|info
operator|->
name|wwn_port
operator|=
operator|(
name|u64
operator|)
name|shmem_info
operator|.
name|fcoe_wwn_port_name_upper
operator||
operator|(
operator|(
operator|(
name|u64
operator|)
name|shmem_info
operator|.
name|fcoe_wwn_port_name_lower
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|info
operator|->
name|wwn_node
operator|=
operator|(
name|u64
operator|)
name|shmem_info
operator|.
name|fcoe_wwn_node_name_upper
operator||
operator|(
operator|(
operator|(
name|u64
operator|)
name|shmem_info
operator|.
name|fcoe_wwn_node_name_lower
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|info
operator|->
name|ovlan
operator|=
call|(
name|u16
call|)
argument_list|(
name|shmem_info
operator|.
name|ovlan_stag
operator|&
name|FUNC_MF_CFG_OV_STAG_MASK
argument_list|)
expr_stmt|;
name|info
operator|->
name|mtu
operator|=
operator|(
name|u16
operator|)
name|shmem_info
operator|.
name|mtu_size
expr_stmt|;
name|p_hwfn
operator|->
name|hw_info
operator|.
name|b_wol_support
operator|=
name|ECORE_WOL_SUPPORT_NONE
expr_stmt|;
if|if
condition|(
name|ecore_mcp_is_init
argument_list|(
name|p_hwfn
argument_list|)
condition|)
block|{
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_OS_WOL
argument_list|,
literal|0
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|resp
operator|==
name|FW_MSG_CODE_OS_WOL_SUPPORTED
condition|)
name|p_hwfn
operator|->
name|hw_info
operator|.
name|b_wol_support
operator|=
name|ECORE_WOL_SUPPORT_PME
expr_stmt|;
block|}
name|p_hwfn
operator|->
name|p_dev
operator|->
name|wol_config
operator|=
operator|(
name|u8
operator|)
name|ECORE_OV_WOL_DEFAULT
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_SP
operator||
name|ECORE_MSG_IFUP
operator|)
argument_list|,
literal|"Read configuration from shmem: pause_on_host %02x protocol %02x BW [%02x - %02x] MAC %02x:%02x:%02x:%02x:%02x:%02x wwn port %llx node %llx ovlan %04x wol %02x\n"
argument_list|,
name|info
operator|->
name|pause_on_host
argument_list|,
name|info
operator|->
name|protocol
argument_list|,
name|info
operator|->
name|bandwidth_min
argument_list|,
name|info
operator|->
name|bandwidth_max
argument_list|,
name|info
operator|->
name|mac
index|[
literal|0
index|]
argument_list|,
name|info
operator|->
name|mac
index|[
literal|1
index|]
argument_list|,
name|info
operator|->
name|mac
index|[
literal|2
index|]
argument_list|,
name|info
operator|->
name|mac
index|[
literal|3
index|]
argument_list|,
name|info
operator|->
name|mac
index|[
literal|4
index|]
argument_list|,
name|info
operator|->
name|mac
index|[
literal|5
index|]
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|info
operator|->
name|wwn_port
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|info
operator|->
name|wwn_node
argument_list|,
name|info
operator|->
name|ovlan
argument_list|,
operator|(
name|u8
operator|)
name|p_hwfn
operator|->
name|hw_info
operator|.
name|b_wol_support
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|struct
name|ecore_mcp_link_params
modifier|*
name|ecore_mcp_get_link_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|||
operator|!
name|p_hwfn
operator|->
name|mcp_info
condition|)
return|return
name|OSAL_NULL
return|;
return|return
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_input
return|;
block|}
end_function

begin_function
name|struct
name|ecore_mcp_link_state
modifier|*
name|ecore_mcp_get_link_state
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|||
operator|!
name|p_hwfn
operator|->
name|mcp_info
condition|)
return|return
name|OSAL_NULL
return|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Non-ASIC - always notify that link is up\n"
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_output
operator|.
name|link_up
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_output
return|;
block|}
end_function

begin_function
name|struct
name|ecore_mcp_link_capabilities
modifier|*
name|ecore_mcp_get_link_capabilities
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|||
operator|!
name|p_hwfn
operator|->
name|mcp_info
condition|)
return|return
name|OSAL_NULL
return|;
return|return
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|link_capabilities
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_drain
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_NIG_DRAIN
argument_list|,
literal|1000
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
comment|/* Wait for the drain to complete before returning */
name|OSAL_MSLEEP
argument_list|(
literal|1020
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|LINUX_REMOVE
end_ifndef

begin_function
specifier|const
name|struct
name|ecore_mcp_function_info
modifier|*
name|ecore_mcp_get_function_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|||
operator|!
name|p_hwfn
operator|->
name|mcp_info
condition|)
return|return
name|OSAL_NULL
return|;
return|return
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|func_info
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_command
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mcp_nvm_params
modifier|*
name|params
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
switch|switch
condition|(
name|params
operator|->
name|type
condition|)
block|{
case|case
name|ECORE_MCP_NVM_RD
case|:
name|rc
operator|=
name|ecore_mcp_nvm_rd_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|params
operator|->
name|nvm_common
operator|.
name|cmd
argument_list|,
name|params
operator|->
name|nvm_common
operator|.
name|offset
argument_list|,
operator|&
name|params
operator|->
name|nvm_common
operator|.
name|resp
argument_list|,
operator|&
name|params
operator|->
name|nvm_common
operator|.
name|param
argument_list|,
name|params
operator|->
name|nvm_rd
operator|.
name|buf_size
argument_list|,
name|params
operator|->
name|nvm_rd
operator|.
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCP_CMD
case|:
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|params
operator|->
name|nvm_common
operator|.
name|cmd
argument_list|,
name|params
operator|->
name|nvm_common
operator|.
name|offset
argument_list|,
operator|&
name|params
operator|->
name|nvm_common
operator|.
name|resp
argument_list|,
operator|&
name|params
operator|->
name|nvm_common
operator|.
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCP_NVM_WR
case|:
name|rc
operator|=
name|ecore_mcp_nvm_wr_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|params
operator|->
name|nvm_common
operator|.
name|cmd
argument_list|,
name|params
operator|->
name|nvm_common
operator|.
name|offset
argument_list|,
operator|&
name|params
operator|->
name|nvm_common
operator|.
name|resp
argument_list|,
operator|&
name|params
operator|->
name|nvm_common
operator|.
name|param
argument_list|,
name|params
operator|->
name|nvm_wr
operator|.
name|buf_size
argument_list|,
name|params
operator|->
name|nvm_wr
operator|.
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ECORE_NOTIMPL
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|LINUX_REMOVE
end_ifndef

begin_function
name|int
name|ecore_mcp_get_personality_cnt
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|personalities
parameter_list|)
block|{
name|enum
name|ecore_pci_personality
name|protocol
init|=
name|ECORE_PCI_DEFAULT
decl_stmt|;
name|struct
name|public_func
name|shmem_info
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|num_pfs
decl_stmt|;
name|num_pfs
operator|=
name|NUM_OF_ENG_PFS
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pfs
condition|;
name|i
operator|++
control|)
block|{
name|ecore_mcp_get_shmem_func
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|shmem_info
argument_list|,
name|MCP_PF_ID_BY_REL
argument_list|(
name|p_hwfn
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmem_info
operator|.
name|config
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
condition|)
continue|continue;
if|if
condition|(
name|ecore_mcp_get_shmem_proto
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|shmem_info
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|protocol
argument_list|)
operator|!=
name|ECORE_SUCCESS
condition|)
continue|continue;
if|if
condition|(
operator|(
literal|1
operator|<<
operator|(
operator|(
name|u32
operator|)
name|protocol
operator|)
operator|)
operator|&
name|personalities
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_flash_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|p_flash_size
parameter_list|)
block|{
name|u32
name|flash_size
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Emulation - can't get flash size\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
name|flash_size
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MCP_REG_NVM_CFG4
argument_list|)
expr_stmt|;
name|flash_size
operator|=
operator|(
name|flash_size
operator|&
name|MCP_REG_NVM_CFG4_FLASH_SIZE
operator|)
operator|>>
name|MCP_REG_NVM_CFG4_FLASH_SIZE_SHIFT
expr_stmt|;
name|flash_size
operator|=
operator|(
literal|1
operator|<<
operator|(
name|flash_size
operator|+
name|MCP_BYTES_PER_MBIT_SHIFT
operator|)
operator|)
expr_stmt|;
operator|*
name|p_flash_size
operator|=
name|flash_size
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_start_recovery_process
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|ecore_dev
modifier|*
name|p_dev
init|=
name|p_hwfn
operator|->
name|p_dev
decl_stmt|;
if|if
condition|(
name|p_dev
operator|->
name|recov_in_prog
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Avoid triggering a recovery since such a process is already in progress\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_AGAIN
return|;
block|}
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Triggering a recovery process\n"
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_35
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_config_vf_msix
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|vf_id
parameter_list|,
name|u8
name|num
parameter_list|)
block|{
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|,
name|rc_param
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* Only Leader can configure MSIX, and need to take CMT into account */
if|if
condition|(
operator|!
name|IS_LEAD_HWFN
argument_list|(
name|p_hwfn
argument_list|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|num
operator|*=
name|p_hwfn
operator|->
name|p_dev
operator|->
name|num_hwfns
expr_stmt|;
name|param
operator||=
operator|(
name|vf_id
operator|<<
name|DRV_MB_PARAM_CFG_VF_MSIX_VF_ID_SHIFT
operator|)
operator|&
name|DRV_MB_PARAM_CFG_VF_MSIX_VF_ID_MASK
expr_stmt|;
name|param
operator||=
operator|(
name|num
operator|<<
name|DRV_MB_PARAM_CFG_VF_MSIX_SB_NUM_SHIFT
operator|)
operator|&
name|DRV_MB_PARAM_CFG_VF_MSIX_SB_NUM_MASK
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_CFG_VF_MSIX
argument_list|,
name|param
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|rc_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|!=
name|FW_MSG_CODE_DRV_CFG_VF_MSIX_DONE
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"VF[%d]: MFW failed to set MSI-X\n"
argument_list|,
name|vf_id
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
block|}
else|else
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_IOV
argument_list|,
literal|"Requested 0x%02x MSI-x interrupts from VF 0x%02x\n"
argument_list|,
name|num
argument_list|,
name|vf_id
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_send_drv_version
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mcp_drv_version
modifier|*
name|p_ver
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|struct
name|drv_version_stc
name|drv_version
decl_stmt|;
name|u32
name|num_words
decl_stmt|,
name|i
decl_stmt|;
name|void
modifier|*
name|p_name
decl_stmt|;
name|OSAL_BE32
name|val
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
endif|#
directive|endif
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|drv_version
argument_list|,
sizeof|sizeof
argument_list|(
name|drv_version
argument_list|)
argument_list|)
expr_stmt|;
name|drv_version
operator|.
name|version
operator|=
name|p_ver
operator|->
name|version
expr_stmt|;
name|num_words
operator|=
operator|(
name|MCP_DRV_VER_STR_SIZE
operator|-
literal|4
operator|)
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_words
condition|;
name|i
operator|++
control|)
block|{
comment|/* The driver name is expected to be in a big-endian format */
name|p_name
operator|=
operator|&
name|p_ver
operator|->
name|name
index|[
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
index|]
expr_stmt|;
name|val
operator|=
name|OSAL_CPU_TO_BE32
argument_list|(
operator|*
operator|(
name|u32
operator|*
operator|)
name|p_name
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u32
operator|*
operator|)
operator|&
name|drv_version
operator|.
name|name
index|[
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
index|]
operator|=
name|val
expr_stmt|;
block|}
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_SET_VERSION
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|drv_version
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|drv_version
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_halt
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_MCP_HALT
argument_list|,
literal|0
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_resume
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|value
decl_stmt|,
name|cpu_mode
decl_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MCP_REG_CPU_STATE
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|value
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MCP_REG_CPU_MODE
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
name|MCP_REG_CPU_MODE_SOFT_HALT
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MCP_REG_CPU_MODE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|cpu_mode
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MCP_REG_CPU_MODE
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpu_mode
operator|&
name|MCP_REG_CPU_MODE_SOFT_HALT
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_ov_update_current_config
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_ov_client
name|client
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|u32
name|drv_mb_param
decl_stmt|;
switch|switch
condition|(
name|client
condition|)
block|{
case|case
name|ECORE_OV_CLIENT_DRV
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_OV_CURR_CFG_OS
expr_stmt|;
break|break;
case|case
name|ECORE_OV_CLIENT_USER
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_OV_CURR_CFG_OTHER
expr_stmt|;
break|break;
case|case
name|ECORE_OV_CLIENT_VENDOR_SPEC
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_OV_CURR_CFG_VENDOR_SPEC
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid client type %d\n"
argument_list|,
name|client
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_OV_UPDATE_CURR_CFG
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_ov_update_driver_state
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_ov_driver_state
name|drv_state
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|u32
name|drv_mb_param
decl_stmt|;
switch|switch
condition|(
name|drv_state
condition|)
block|{
case|case
name|ECORE_OV_DRIVER_STATE_NOT_LOADED
case|:
name|drv_mb_param
operator|=
name|DRV_MSG_CODE_OV_UPDATE_DRIVER_STATE_NOT_LOADED
expr_stmt|;
break|break;
case|case
name|ECORE_OV_DRIVER_STATE_DISABLED
case|:
name|drv_mb_param
operator|=
name|DRV_MSG_CODE_OV_UPDATE_DRIVER_STATE_DISABLED
expr_stmt|;
break|break;
case|case
name|ECORE_OV_DRIVER_STATE_ACTIVE
case|:
name|drv_mb_param
operator|=
name|DRV_MSG_CODE_OV_UPDATE_DRIVER_STATE_ACTIVE
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid driver state %d\n"
argument_list|,
name|drv_state
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_OV_UPDATE_DRIVER_STATE
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to send driver state\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_ov_get_fc_npiv
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_fc_npiv_tbl
modifier|*
name|p_table
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|struct
name|dci_fc_npiv_tbl
modifier|*
name|p_npiv_table
decl_stmt|;
name|u8
modifier|*
name|p_buf
init|=
name|OSAL_NULL
decl_stmt|;
name|u32
name|addr
decl_stmt|,
name|size
decl_stmt|,
name|i
decl_stmt|;
name|p_table
operator|->
name|num_wwpn
operator|=
literal|0
expr_stmt|;
name|p_table
operator|->
name|num_wwnn
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_port
argument_list|,
name|fc_npiv_nvram_tbl_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NPIV_TBL_INVALID_ADDR
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"NPIV table doesn't exist\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|size
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|port_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_port
argument_list|,
name|fc_npiv_nvram_tbl_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"NPIV table is empty\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|p_buf
operator|=
name|OSAL_VZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_buf
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Buffer allocation failed\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
name|rc
operator|=
name|ecore_mcp_nvm_read
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|addr
argument_list|,
name|p_buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|OSAL_VFREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_buf
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|p_npiv_table
operator|=
operator|(
expr|struct
name|dci_fc_npiv_tbl
operator|*
operator|)
name|p_buf
expr_stmt|;
name|p_table
operator|->
name|num_wwpn
operator|=
operator|(
name|u16
operator|)
name|p_npiv_table
operator|->
name|fc_npiv_cfg
operator|.
name|num_of_npiv
expr_stmt|;
name|p_table
operator|->
name|num_wwnn
operator|=
operator|(
name|u16
operator|)
name|p_npiv_table
operator|->
name|fc_npiv_cfg
operator|.
name|num_of_npiv
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_table
operator|->
name|num_wwpn
condition|;
name|i
operator|++
control|)
block|{
name|OSAL_MEMCPY
argument_list|(
name|p_table
operator|->
name|wwpn
argument_list|,
name|p_npiv_table
operator|->
name|settings
index|[
name|i
index|]
operator|.
name|npiv_wwpn
argument_list|,
name|ECORE_WWN_SIZE
argument_list|)
expr_stmt|;
name|OSAL_MEMCPY
argument_list|(
name|p_table
operator|->
name|wwnn
argument_list|,
name|p_npiv_table
operator|->
name|settings
index|[
name|i
index|]
operator|.
name|npiv_wwnn
argument_list|,
name|ECORE_WWN_SIZE
argument_list|)
expr_stmt|;
block|}
name|OSAL_VFREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_buf
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_ov_update_mtu
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|mtu
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|u32
name|drv_mb_param
decl_stmt|;
name|drv_mb_param
operator|=
operator|(
name|u32
operator|)
name|mtu
operator|<<
name|DRV_MB_PARAM_OV_MTU_SIZE_SHIFT
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_OV_UPDATE_MTU
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to send mtu value, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_ov_update_mac
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|mfw_mac
index|[
literal|2
index|]
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_SET_VMAC
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|DRV_MSG_CODE_VMAC_TYPE_MAC
operator|<<
name|DRV_MSG_CODE_VMAC_TYPE_SHIFT
expr_stmt|;
name|mb_params
operator|.
name|param
operator||=
name|MCP_PF_ID
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* MCP is BE, and on LE platforms PCI would swap access to SHMEM 	 * in 32-bit granularity. 	 * So the MAC has to be set in native order [and not byte order], 	 * otherwise it would be read incorrectly by MFW after swap. 	 */
name|mfw_mac
index|[
literal|0
index|]
operator|=
name|mac
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|mac
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|mac
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|mac
index|[
literal|3
index|]
expr_stmt|;
name|mfw_mac
index|[
literal|1
index|]
operator|=
name|mac
index|[
literal|4
index|]
operator|<<
literal|24
operator||
name|mac
index|[
literal|5
index|]
operator|<<
literal|16
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|(
name|u8
operator|*
operator|)
name|mfw_mac
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
literal|8
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to send mac address, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* Store primary MAC for later possible WoL */
name|OSAL_MEMCPY
argument_list|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|wol_mac
argument_list|,
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_ov_update_wol
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_ov_wol
name|wol
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|u32
name|drv_mb_param
decl_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|hw_info
operator|.
name|b_wol_support
operator|==
name|ECORE_WOL_SUPPORT_NONE
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Can't change WoL configuration when WoL isn't supported\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
switch|switch
condition|(
name|wol
condition|)
block|{
case|case
name|ECORE_OV_WOL_DEFAULT
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_WOL_DEFAULT
expr_stmt|;
break|break;
case|case
name|ECORE_OV_WOL_DISABLED
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_WOL_DISABLED
expr_stmt|;
break|break;
case|case
name|ECORE_OV_WOL_ENABLED
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_WOL_ENABLED
expr_stmt|;
break|break;
default|default:
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Invalid wol state %d\n"
argument_list|,
name|wol
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_OV_UPDATE_WOL
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to send wol mode, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* Store the WoL update for a future unload */
name|p_hwfn
operator|->
name|p_dev
operator|->
name|wol_config
operator|=
operator|(
name|u8
operator|)
name|wol
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_ov_update_eswitch
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_ov_eswitch
name|eswitch
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|u32
name|drv_mb_param
decl_stmt|;
switch|switch
condition|(
name|eswitch
condition|)
block|{
case|case
name|ECORE_OV_ESWITCH_NONE
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_ESWITCH_MODE_NONE
expr_stmt|;
break|break;
case|case
name|ECORE_OV_ESWITCH_VEB
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_ESWITCH_MODE_VEB
expr_stmt|;
break|break;
case|case
name|ECORE_OV_ESWITCH_VEPA
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_ESWITCH_MODE_VEPA
expr_stmt|;
break|break;
default|default:
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Invalid eswitch mode %d\n"
argument_list|,
name|eswitch
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_OV_UPDATE_ESWITCH_MODE
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to send eswitch mode, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_set_led
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_led_mode
name|mode
parameter_list|)
block|{
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|,
name|drv_mb_param
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ECORE_LED_MODE_ON
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_SET_LED_MODE_ON
expr_stmt|;
break|break;
case|case
name|ECORE_LED_MODE_OFF
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_SET_LED_MODE_OFF
expr_stmt|;
break|break;
case|case
name|ECORE_LED_MODE_RESTORE
case|:
name|drv_mb_param
operator|=
name|DRV_MB_PARAM_SET_LED_MODE_OPER
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid LED mode %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_SET_LED_MODE
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_mask_parities
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|mask_parities
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_MASK_PARITIES
argument_list|,
name|mask_parities
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"MCP response failure for mask parities, aborting\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resp
operator|!=
name|FW_MSG_CODE_OK
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"MCP did not acknowledge mask parity request. Old MFW?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_read
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u8
modifier|*
name|p_buf
parameter_list|,
name|u32
name|len
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|u32
name|bytes_left
decl_stmt|,
name|offset
decl_stmt|,
name|bytes_to_copy
decl_stmt|,
name|buf_size
decl_stmt|;
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_left
operator|=
name|len
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_NVM_RD
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
operator|=
operator|&
name|buf_size
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_NVM_READ_NVRAM
expr_stmt|;
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|bytes_to_copy
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|bytes_left
argument_list|,
name|MCP_DRV_NVM_BUF_LEN
argument_list|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
operator|(
name|addr
operator|+
name|offset
operator|)
operator||
operator|(
name|bytes_to_copy
operator|<<
name|DRV_MB_PARAM_NVM_LEN_SHIFT
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|p_buf
operator|+
name|offset
operator|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
operator|||
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|!=
name|FW_MSG_CODE_NVM_OK
operator|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"MCP command rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* This can be a lengthy process, and it's possible scheduler 		 * isn't preemptable. Sleep a bit to prevent CPU hogging. 		 */
if|if
condition|(
name|bytes_left
operator|%
literal|0x1000
operator|<
operator|(
name|bytes_left
operator|-
operator|*
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
operator|)
operator|%
literal|0x1000
condition|)
name|OSAL_MSLEEP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
operator|*
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
expr_stmt|;
name|bytes_left
operator|-=
operator|*
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
expr_stmt|;
block|}
name|p_dev
operator|->
name|mcp_nvm_resp
operator|=
name|params
operator|.
name|nvm_common
operator|.
name|resp
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_phy_read
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
name|cmd
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u8
modifier|*
name|p_buf
parameter_list|,
name|u32
name|len
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_NVM_RD
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
operator|=
operator|&
name|len
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
operator|(
name|cmd
operator|==
name|ECORE_PHY_CORE_READ
operator|)
condition|?
name|DRV_MSG_CODE_PHY_CORE_READ
else|:
name|DRV_MSG_CODE_PHY_RAW_READ
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
name|addr
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf
operator|=
operator|(
name|u32
operator|*
operator|)
name|p_buf
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"MCP command rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|mcp_nvm_resp
operator|=
name|params
operator|.
name|nvm_common
operator|.
name|resp
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_resp
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u8
modifier|*
name|p_buf
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|OSAL_MEMCPY
argument_list|(
name|p_buf
argument_list|,
operator|&
name|p_dev
operator|->
name|mcp_nvm_resp
argument_list|,
sizeof|sizeof
argument_list|(
name|p_dev
operator|->
name|mcp_nvm_resp
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_del_file
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
name|addr
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_CMD
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_NVM_DEL_FILE
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
name|addr
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|mcp_nvm_resp
operator|=
name|params
operator|.
name|nvm_common
operator|.
name|resp
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_put_file_begin
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
name|addr
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_CMD
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_NVM_PUT_FILE_BEGIN
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
name|addr
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|mcp_nvm_resp
operator|=
name|params
operator|.
name|nvm_common
operator|.
name|resp
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* rc receives ECORE_INVAL as default parameter because  * it might not enter the while loop if the len is 0  */
end_comment

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_write
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
name|cmd
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u8
modifier|*
name|p_buf
parameter_list|,
name|u32
name|len
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_INVAL
decl_stmt|;
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|u32
name|buf_idx
decl_stmt|,
name|buf_size
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_NVM_WR
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ECORE_PUT_FILE_DATA
case|:
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_NVM_PUT_FILE_DATA
expr_stmt|;
break|break;
case|case
name|ECORE_NVM_WRITE_NVRAM
case|:
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_NVM_WRITE_NVRAM
expr_stmt|;
break|break;
case|case
name|ECORE_EXT_PHY_FW_UPGRADE
case|:
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_EXT_PHY_FW_UPGRADE
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid nvm write command 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|buf_idx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf_idx
operator|<
name|len
condition|)
block|{
name|buf_size
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
operator|(
name|len
operator|-
name|buf_idx
operator|)
argument_list|,
name|MCP_DRV_NVM_BUF_LEN
argument_list|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
operator|(
operator|(
name|buf_size
operator|<<
name|DRV_MB_PARAM_NVM_LEN_SHIFT
operator|)
operator||
name|addr
operator|)
operator|+
name|buf_idx
expr_stmt|;
name|params
operator|.
name|nvm_wr
operator|.
name|buf_size
operator|=
name|buf_size
expr_stmt|;
name|params
operator|.
name|nvm_wr
operator|.
name|buf
operator|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|p_buf
index|[
name|buf_idx
index|]
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
operator|||
operator|(
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|!=
name|FW_MSG_CODE_NVM_OK
operator|)
operator|&&
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|!=
name|FW_MSG_CODE_NVM_PUT_FILE_FINISH_OK
operator|)
operator|)
condition|)
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"MCP command rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* This can be a lengthy process, and it's possible scheduler 		 * isn't preemptable. Sleep a bit to prevent CPU hogging. 		 */
if|if
condition|(
name|buf_idx
operator|%
literal|0x1000
operator|>
operator|(
name|buf_idx
operator|+
name|buf_size
operator|)
operator|%
literal|0x1000
condition|)
name|OSAL_MSLEEP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|buf_idx
operator|+=
name|buf_size
expr_stmt|;
block|}
name|p_dev
operator|->
name|mcp_nvm_resp
operator|=
name|params
operator|.
name|nvm_common
operator|.
name|resp
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_phy_write
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
name|cmd
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u8
modifier|*
name|p_buf
parameter_list|,
name|u32
name|len
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_NVM_WR
expr_stmt|;
name|params
operator|.
name|nvm_wr
operator|.
name|buf_size
operator|=
name|len
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
operator|(
name|cmd
operator|==
name|ECORE_PHY_CORE_WRITE
operator|)
condition|?
name|DRV_MSG_CODE_PHY_CORE_WRITE
else|:
name|DRV_MSG_CODE_PHY_RAW_WRITE
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
name|addr
expr_stmt|;
name|params
operator|.
name|nvm_wr
operator|.
name|buf
operator|=
operator|(
name|u32
operator|*
operator|)
name|p_buf
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_NOTICE
argument_list|(
name|p_dev
argument_list|,
name|false
argument_list|,
literal|"MCP command rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|mcp_nvm_resp
operator|=
name|params
operator|.
name|nvm_common
operator|.
name|resp
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_nvm_set_secure_mode
parameter_list|(
name|struct
name|ecore_dev
modifier|*
name|p_dev
parameter_list|,
name|u32
name|addr
parameter_list|)
block|{
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
init|=
name|ECORE_LEADING_HWFN
argument_list|(
name|p_dev
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|p_ptt
operator|=
name|ecore_ptt_acquire
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptt
condition|)
return|return
name|ECORE_BUSY
return|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_CMD
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_SET_SECURE_MODE
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
name|addr
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|p_dev
operator|->
name|mcp_nvm_resp
operator|=
name|params
operator|.
name|nvm_common
operator|.
name|resp
expr_stmt|;
name|ecore_ptt_release
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_phy_sfp_read
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|port
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|len
parameter_list|,
name|u8
modifier|*
name|p_buf
parameter_list|)
block|{
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|bytes_left
decl_stmt|,
name|bytes_to_copy
decl_stmt|,
name|buf_size
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
operator|(
name|port
operator|<<
name|DRV_MB_PARAM_TRANSCEIVER_PORT_SHIFT
operator|)
operator||
operator|(
name|addr
operator|<<
name|DRV_MB_PARAM_TRANSCEIVER_I2C_ADDRESS_SHIFT
operator|)
expr_stmt|;
name|addr
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|bytes_left
operator|=
name|len
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_NVM_RD
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
operator|=
operator|&
name|buf_size
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_TRANSCEIVER_READ
expr_stmt|;
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|bytes_to_copy
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|bytes_left
argument_list|,
name|MAX_I2C_TRANSACTION_SIZE
argument_list|)
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|p_buf
operator|+
name|offset
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|&=
operator|(
name|DRV_MB_PARAM_TRANSCEIVER_I2C_ADDRESS_MASK
operator||
name|DRV_MB_PARAM_TRANSCEIVER_PORT_MASK
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator||=
operator|(
operator|(
name|addr
operator|+
name|offset
operator|)
operator|<<
name|DRV_MB_PARAM_TRANSCEIVER_OFFSET_SHIFT
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator||=
operator|(
name|bytes_to_copy
operator|<<
name|DRV_MB_PARAM_TRANSCEIVER_SIZE_SHIFT
operator|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|==
name|FW_MSG_CODE_TRANSCEIVER_NOT_PRESENT
condition|)
block|{
return|return
name|ECORE_NODEV
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_TRANSCEIVER_DIAG_OK
condition|)
return|return
name|ECORE_UNKNOWN_ERROR
return|;
name|offset
operator|+=
operator|*
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
expr_stmt|;
name|bytes_left
operator|-=
operator|*
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_phy_sfp_write
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|port
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|len
parameter_list|,
name|u8
modifier|*
name|p_buf
parameter_list|)
block|{
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|buf_idx
decl_stmt|,
name|buf_size
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
operator|(
name|port
operator|<<
name|DRV_MB_PARAM_TRANSCEIVER_PORT_SHIFT
operator|)
operator||
operator|(
name|addr
operator|<<
name|DRV_MB_PARAM_TRANSCEIVER_I2C_ADDRESS_SHIFT
operator|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_NVM_WR
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_TRANSCEIVER_WRITE
expr_stmt|;
name|buf_idx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf_idx
operator|<
name|len
condition|)
block|{
name|buf_size
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
operator|(
name|len
operator|-
name|buf_idx
operator|)
argument_list|,
name|MAX_I2C_TRANSACTION_SIZE
argument_list|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|&=
operator|(
name|DRV_MB_PARAM_TRANSCEIVER_I2C_ADDRESS_MASK
operator||
name|DRV_MB_PARAM_TRANSCEIVER_PORT_MASK
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator||=
operator|(
operator|(
name|offset
operator|+
name|buf_idx
operator|)
operator|<<
name|DRV_MB_PARAM_TRANSCEIVER_OFFSET_SHIFT
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator||=
operator|(
name|buf_size
operator|<<
name|DRV_MB_PARAM_TRANSCEIVER_SIZE_SHIFT
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_wr
operator|.
name|buf_size
operator|=
name|buf_size
expr_stmt|;
name|params
operator|.
name|nvm_wr
operator|.
name|buf
operator|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|p_buf
index|[
name|buf_idx
index|]
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|==
name|FW_MSG_CODE_TRANSCEIVER_NOT_PRESENT
condition|)
block|{
return|return
name|ECORE_NODEV
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_TRANSCEIVER_DIAG_OK
condition|)
return|return
name|ECORE_UNKNOWN_ERROR
return|;
name|buf_idx
operator|+=
name|buf_size
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_gpio_read
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|gpio
parameter_list|,
name|u32
modifier|*
name|gpio_val
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u32
name|drv_mb_param
init|=
literal|0
decl_stmt|,
name|rsp
decl_stmt|;
name|drv_mb_param
operator|=
operator|(
name|gpio
operator|<<
name|DRV_MB_PARAM_GPIO_NUMBER_SHIFT
operator|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_GPIO_READ
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|rsp
argument_list|,
name|gpio_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|rsp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_GPIO_OK
condition|)
return|return
name|ECORE_UNKNOWN_ERROR
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_gpio_write
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|gpio
parameter_list|,
name|u16
name|gpio_val
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u32
name|drv_mb_param
init|=
literal|0
decl_stmt|,
name|param
decl_stmt|,
name|rsp
decl_stmt|;
name|drv_mb_param
operator|=
operator|(
name|gpio
operator|<<
name|DRV_MB_PARAM_GPIO_NUMBER_SHIFT
operator|)
operator||
operator|(
name|gpio_val
operator|<<
name|DRV_MB_PARAM_GPIO_VALUE_SHIFT
operator|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_GPIO_WRITE
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|rsp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|rsp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_GPIO_OK
condition|)
return|return
name|ECORE_UNKNOWN_ERROR
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_gpio_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|gpio
parameter_list|,
name|u32
modifier|*
name|gpio_direction
parameter_list|,
name|u32
modifier|*
name|gpio_ctrl
parameter_list|)
block|{
name|u32
name|drv_mb_param
init|=
literal|0
decl_stmt|,
name|rsp
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|drv_mb_param
operator|=
name|gpio
operator|<<
name|DRV_MB_PARAM_GPIO_NUMBER_SHIFT
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_GPIO_INFO
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|rsp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
operator|*
name|gpio_direction
operator|=
operator|(
name|val
operator|&
name|DRV_MB_PARAM_GPIO_DIRECTION_MASK
operator|)
operator|>>
name|DRV_MB_PARAM_GPIO_DIRECTION_SHIFT
expr_stmt|;
operator|*
name|gpio_ctrl
operator|=
operator|(
name|val
operator|&
name|DRV_MB_PARAM_GPIO_CTRL_MASK
operator|)
operator|>>
name|DRV_MB_PARAM_GPIO_CTRL_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|rsp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_GPIO_OK
condition|)
return|return
name|ECORE_UNKNOWN_ERROR
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_bist_register_test
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|drv_mb_param
init|=
literal|0
decl_stmt|,
name|rsp
decl_stmt|,
name|param
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|drv_mb_param
operator|=
operator|(
name|DRV_MB_PARAM_BIST_REGISTER_TEST
operator|<<
name|DRV_MB_PARAM_BIST_TEST_INDEX_SHIFT
operator|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_BIST_TEST
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|rsp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
operator|(
name|rsp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_OK
operator|)
operator|||
operator|(
name|param
operator|!=
name|DRV_MB_PARAM_BIST_RC_PASSED
operator|)
condition|)
name|rc
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_bist_clock_test
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|drv_mb_param
decl_stmt|,
name|rsp
decl_stmt|,
name|param
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|drv_mb_param
operator|=
operator|(
name|DRV_MB_PARAM_BIST_CLOCK_TEST
operator|<<
name|DRV_MB_PARAM_BIST_TEST_INDEX_SHIFT
operator|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_BIST_TEST
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|rsp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
operator|(
name|rsp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_OK
operator|)
operator|||
operator|(
name|param
operator|!=
name|DRV_MB_PARAM_BIST_RC_PASSED
operator|)
condition|)
name|rc
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_bist_nvm_test_get_num_images
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|num_images
parameter_list|)
block|{
name|u32
name|drv_mb_param
init|=
literal|0
decl_stmt|,
name|rsp
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|drv_mb_param
operator|=
operator|(
name|DRV_MB_PARAM_BIST_NVM_TEST_NUM_IMAGES
operator|<<
name|DRV_MB_PARAM_BIST_TEST_INDEX_SHIFT
operator|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_BIST_TEST
argument_list|,
name|drv_mb_param
argument_list|,
operator|&
name|rsp
argument_list|,
name|num_images
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
operator|(
name|rsp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_OK
operator|)
condition|)
name|rc
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_bist_nvm_test_get_image_att
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|bist_nvm_image_att
modifier|*
name|p_image_att
parameter_list|,
name|u32
name|image_index
parameter_list|)
block|{
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|buf_size
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcp_nvm_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
operator|(
name|DRV_MB_PARAM_BIST_NVM_TEST_IMAGE_BY_INDEX
operator|<<
name|DRV_MB_PARAM_BIST_TEST_INDEX_SHIFT
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator||=
operator|(
name|image_index
operator|<<
name|DRV_MB_PARAM_BIST_TEST_IMAGE_INDEX_SHIFT
operator|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_NVM_RD
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
operator|=
operator|&
name|buf_size
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_BIST_TEST
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf
operator|=
operator|(
name|u32
operator|*
operator|)
name|p_image_att
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_OK
operator|)
operator|||
operator|(
name|p_image_att
operator|->
name|return_code
operator|!=
literal|1
operator|)
condition|)
name|rc
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_nvm_image_att
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_nvm_images
name|image_id
parameter_list|,
name|struct
name|ecore_nvm_image_att
modifier|*
name|p_image_att
parameter_list|)
block|{
name|struct
name|bist_nvm_image_att
name|mfw_image_att
decl_stmt|;
name|enum
name|nvm_image_type
name|type
decl_stmt|;
name|u32
name|num_images
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* Translate image_id into MFW definitions */
switch|switch
condition|(
name|image_id
condition|)
block|{
case|case
name|ECORE_NVM_IMAGE_ISCSI_CFG
case|:
name|type
operator|=
name|NVM_TYPE_ISCSI_CFG
expr_stmt|;
break|break;
case|case
name|ECORE_NVM_IMAGE_FCOE_CFG
case|:
name|type
operator|=
name|NVM_TYPE_FCOE_CFG
expr_stmt|;
break|break;
case|case
name|ECORE_NVM_IMAGE_MDUMP
case|:
name|type
operator|=
name|NVM_TYPE_MDUMP
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Unknown request of image_id %08x\n"
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Learn number of images, then traverse and see if one fits */
name|rc
operator|=
name|ecore_mcp_bist_nvm_test_get_num_images
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|num_images
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
operator|||
operator|!
name|num_images
condition|)
return|return
name|ECORE_INVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_images
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|ecore_mcp_bist_nvm_test_get_image_att
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mfw_image_att
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|type
operator|==
name|mfw_image_att
operator|.
name|image_type
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|num_images
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"Failed to find nvram image of type %08x\n"
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|p_image_att
operator|->
name|start_addr
operator|=
name|mfw_image_att
operator|.
name|nvm_start_addr
expr_stmt|;
name|p_image_att
operator|->
name|length
operator|=
name|mfw_image_att
operator|.
name|len
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_nvm_image
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_nvm_images
name|image_id
parameter_list|,
name|u8
modifier|*
name|p_buffer
parameter_list|,
name|u32
name|buffer_len
parameter_list|)
block|{
name|struct
name|ecore_nvm_image_att
name|image_att
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
name|p_buffer
argument_list|,
name|buffer_len
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_get_nvm_image_att
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|image_id
argument_list|,
operator|&
name|image_att
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* Validate sizes - both the image's and the supplied buffer's */
if|if
condition|(
name|image_att
operator|.
name|length
operator|<=
literal|4
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"Image [%d] is too small - only %d bytes\n"
argument_list|,
name|image_id
argument_list|,
name|image_att
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Each NVM image is suffixed by CRC; Upper-layer has no need for it */
name|image_att
operator|.
name|length
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|image_att
operator|.
name|length
operator|>
name|buffer_len
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"Image [%d] is too big - %08x bytes where only %08x are available\n"
argument_list|,
name|image_id
argument_list|,
name|image_att
operator|.
name|length
argument_list|,
name|buffer_len
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
return|return
name|ecore_mcp_nvm_read
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|image_att
operator|.
name|start_addr
argument_list|,
name|p_buffer
argument_list|,
name|image_att
operator|.
name|length
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_temperature_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_temperature_info
modifier|*
name|p_temp_info
parameter_list|)
block|{
name|struct
name|ecore_temperature_sensor
modifier|*
name|p_temp_sensor
decl_stmt|;
name|struct
name|temperature_status_stc
name|mfw_temp_info
decl_stmt|;
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_GET_TEMPERATURE
expr_stmt|;
name|mb_params
operator|.
name|p_data_dst
operator|=
operator|&
name|mfw_temp_info
expr_stmt|;
name|mb_params
operator|.
name|data_dst_size
operator|=
sizeof|sizeof
argument_list|(
name|mfw_temp_info
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|OSAL_BUILD_BUG_ON
argument_list|(
name|ECORE_MAX_NUM_OF_SENSORS
operator|!=
name|MAX_NUM_OF_SENSORS
argument_list|)
expr_stmt|;
name|p_temp_info
operator|->
name|num_sensors
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|mfw_temp_info
operator|.
name|num_of_sensors
argument_list|,
name|ECORE_MAX_NUM_OF_SENSORS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_temp_info
operator|->
name|num_sensors
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|mfw_temp_info
operator|.
name|sensor
index|[
name|i
index|]
expr_stmt|;
name|p_temp_sensor
operator|=
operator|&
name|p_temp_info
operator|->
name|sensors
index|[
name|i
index|]
expr_stmt|;
name|p_temp_sensor
operator|->
name|sensor_location
operator|=
operator|(
name|val
operator|&
name|SENSOR_LOCATION_MASK
operator|)
operator|>>
name|SENSOR_LOCATION_SHIFT
expr_stmt|;
name|p_temp_sensor
operator|->
name|threshold_high
operator|=
operator|(
name|val
operator|&
name|THRESHOLD_HIGH_MASK
operator|)
operator|>>
name|THRESHOLD_HIGH_SHIFT
expr_stmt|;
name|p_temp_sensor
operator|->
name|critical
operator|=
operator|(
name|val
operator|&
name|CRITICAL_TEMPERATURE_MASK
operator|)
operator|>>
name|CRITICAL_TEMPERATURE_SHIFT
expr_stmt|;
name|p_temp_sensor
operator|->
name|current_temp
operator|=
operator|(
name|val
operator|&
name|CURRENT_TEMP_MASK
operator|)
operator|>>
name|CURRENT_TEMP_SHIFT
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_mba_versions
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_mba_vers
modifier|*
name|p_mba_vers
parameter_list|)
block|{
name|struct
name|ecore_mcp_nvm_params
name|params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u32
name|buf_size
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|type
operator|=
name|ECORE_MCP_NVM_RD
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_GET_MBA_VERSION
expr_stmt|;
name|params
operator|.
name|nvm_common
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf
operator|=
operator|&
operator|(
name|p_mba_vers
operator|->
name|mba_vers
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|params
operator|.
name|nvm_rd
operator|.
name|buf_size
operator|=
operator|&
name|buf_size
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_nvm_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|params
operator|.
name|nvm_common
operator|.
name|resp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_NVM_OK
condition|)
name|rc
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
if|if
condition|(
name|buf_size
operator|!=
name|MCP_DRV_NVM_BUF_LEN
condition|)
name|rc
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_mem_ecc_events
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u64
modifier|*
name|num_events
parameter_list|)
block|{
name|u32
name|rsp
decl_stmt|;
return|return
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_MEM_ECC_EVENTS
argument_list|,
literal|0
argument_list|,
operator|&
name|rsp
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|num_events
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|resource_id_enum
name|ecore_mcp_get_mfw_res_id
parameter_list|(
name|enum
name|ecore_resources
name|res_id
parameter_list|)
block|{
name|enum
name|resource_id_enum
name|mfw_res_id
init|=
name|RESOURCE_NUM_INVALID
decl_stmt|;
switch|switch
condition|(
name|res_id
condition|)
block|{
case|case
name|ECORE_SB
case|:
name|mfw_res_id
operator|=
name|RESOURCE_NUM_SB_E
expr_stmt|;
break|break;
case|case
name|ECORE_L2_QUEUE
case|:
name|mfw_res_id
operator|=
name|RESOURCE_NUM_L2_QUEUE_E
expr_stmt|;
break|break;
case|case
name|ECORE_VPORT
case|:
name|mfw_res_id
operator|=
name|RESOURCE_NUM_VPORT_E
expr_stmt|;
break|break;
case|case
name|ECORE_RSS_ENG
case|:
name|mfw_res_id
operator|=
name|RESOURCE_NUM_RSS_ENGINES_E
expr_stmt|;
break|break;
case|case
name|ECORE_PQ
case|:
name|mfw_res_id
operator|=
name|RESOURCE_NUM_PQ_E
expr_stmt|;
break|break;
case|case
name|ECORE_RL
case|:
name|mfw_res_id
operator|=
name|RESOURCE_NUM_RL_E
expr_stmt|;
break|break;
case|case
name|ECORE_MAC
case|:
case|case
name|ECORE_VLAN
case|:
comment|/* Each VFC resource can accommodate both a MAC and a VLAN */
name|mfw_res_id
operator|=
name|RESOURCE_VFC_FILTER_E
expr_stmt|;
break|break;
case|case
name|ECORE_ILT
case|:
name|mfw_res_id
operator|=
name|RESOURCE_ILT_E
expr_stmt|;
break|break;
case|case
name|ECORE_LL2_QUEUE
case|:
name|mfw_res_id
operator|=
name|RESOURCE_LL2_QUEUE_E
expr_stmt|;
break|break;
case|case
name|ECORE_RDMA_CNQ_RAM
case|:
case|case
name|ECORE_CMDQS_CQS
case|:
comment|/* CNQ/CMDQS are the same resource */
name|mfw_res_id
operator|=
name|RESOURCE_CQS_E
expr_stmt|;
break|break;
case|case
name|ECORE_RDMA_STATS_QUEUE
case|:
name|mfw_res_id
operator|=
name|RESOURCE_RDMA_STATS_QUEUE_E
expr_stmt|;
break|break;
case|case
name|ECORE_BDQ
case|:
name|mfw_res_id
operator|=
name|RESOURCE_BDQ_E
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|mfw_res_id
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ECORE_RESC_ALLOC_VERSION_MAJOR
value|2
end_define

begin_define
define|#
directive|define
name|ECORE_RESC_ALLOC_VERSION_MINOR
value|0
end_define

begin_define
define|#
directive|define
name|ECORE_RESC_ALLOC_VERSION
define|\
value|((ECORE_RESC_ALLOC_VERSION_MAJOR<<			\ 	  DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_SHIFT) |	\ 	 (ECORE_RESC_ALLOC_VERSION_MINOR<<			\ 	  DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_SHIFT))
end_define

begin_struct
struct|struct
name|ecore_resc_alloc_in_params
block|{
name|u32
name|cmd
decl_stmt|;
name|enum
name|ecore_resources
name|res_id
decl_stmt|;
name|u32
name|resc_max_val
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_resc_alloc_out_params
block|{
name|u32
name|mcp_resp
decl_stmt|;
name|u32
name|mcp_param
decl_stmt|;
name|u32
name|resc_num
decl_stmt|;
name|u32
name|resc_start
decl_stmt|;
name|u32
name|vf_resc_num
decl_stmt|;
name|u32
name|vf_resc_start
decl_stmt|;
name|u32
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_resc_allocation_msg
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_resc_alloc_in_params
modifier|*
name|p_in_params
parameter_list|,
name|struct
name|ecore_resc_alloc_out_params
modifier|*
name|p_out_params
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|struct
name|resource_info
name|mfw_resc_info
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mfw_resc_info
argument_list|,
sizeof|sizeof
argument_list|(
name|mfw_resc_info
argument_list|)
argument_list|)
expr_stmt|;
name|mfw_resc_info
operator|.
name|res_id
operator|=
name|ecore_mcp_get_mfw_res_id
argument_list|(
name|p_in_params
operator|->
name|res_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfw_resc_info
operator|.
name|res_id
operator|==
name|RESOURCE_NUM_INVALID
condition|)
block|{
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to match resource %d [%s] with the MFW resources\n"
argument_list|,
name|p_in_params
operator|->
name|res_id
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|p_in_params
operator|->
name|res_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
switch|switch
condition|(
name|p_in_params
operator|->
name|cmd
condition|)
block|{
case|case
name|DRV_MSG_SET_RESOURCE_VALUE_MSG
case|:
name|mfw_resc_info
operator|.
name|size
operator|=
name|p_in_params
operator|->
name|resc_max_val
expr_stmt|;
comment|/* Fallthrough */
case|case
name|DRV_MSG_GET_RESOURCE_ALLOC_MSG
case|:
break|break;
default|default:
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Unexpected resource alloc command [0x%08x]\n"
argument_list|,
name|p_in_params
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|p_in_params
operator|->
name|cmd
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|ECORE_RESC_ALLOC_VERSION
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|mfw_resc_info
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|mfw_resc_info
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|p_data_dst
operator|=
name|mb_params
operator|.
name|p_data_src
expr_stmt|;
name|mb_params
operator|.
name|data_dst_size
operator|=
name|mb_params
operator|.
name|data_src_size
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Resource message request: cmd 0x%08x, res_id %d [%s], hsi_version %d.%d, val 0x%x\n"
argument_list|,
name|p_in_params
operator|->
name|cmd
argument_list|,
name|p_in_params
operator|->
name|res_id
argument_list|,
name|ecore_hw_get_resc_name
argument_list|(
name|p_in_params
operator|->
name|res_id
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mb_params
operator|.
name|param
argument_list|,
name|DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mb_params
operator|.
name|param
argument_list|,
name|DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR
argument_list|)
argument_list|,
name|p_in_params
operator|->
name|resc_max_val
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
name|p_out_params
operator|->
name|mcp_resp
operator|=
name|mb_params
operator|.
name|mcp_resp
expr_stmt|;
name|p_out_params
operator|->
name|mcp_param
operator|=
name|mb_params
operator|.
name|mcp_param
expr_stmt|;
name|p_out_params
operator|->
name|resc_num
operator|=
name|mfw_resc_info
operator|.
name|size
expr_stmt|;
name|p_out_params
operator|->
name|resc_start
operator|=
name|mfw_resc_info
operator|.
name|offset
expr_stmt|;
name|p_out_params
operator|->
name|vf_resc_num
operator|=
name|mfw_resc_info
operator|.
name|vf_size
expr_stmt|;
name|p_out_params
operator|->
name|vf_resc_start
operator|=
name|mfw_resc_info
operator|.
name|vf_offset
expr_stmt|;
name|p_out_params
operator|->
name|flags
operator|=
name|mfw_resc_info
operator|.
name|flags
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Resource message response: mfw_hsi_version %d.%d, num 0x%x, start 0x%x, vf_num 0x%x, vf_start 0x%x, flags 0x%08x\n"
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|p_out_params
operator|->
name|mcp_param
argument_list|,
name|FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR
argument_list|)
argument_list|,
name|ECORE_MFW_GET_FIELD
argument_list|(
name|p_out_params
operator|->
name|mcp_param
argument_list|,
name|FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR
argument_list|)
argument_list|,
name|p_out_params
operator|->
name|resc_num
argument_list|,
name|p_out_params
operator|->
name|resc_start
argument_list|,
name|p_out_params
operator|->
name|vf_resc_num
argument_list|,
name|p_out_params
operator|->
name|vf_resc_start
argument_list|,
name|p_out_params
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_set_resc_max_val
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_resources
name|res_id
parameter_list|,
name|u32
name|resc_max_val
parameter_list|,
name|u32
modifier|*
name|p_mcp_resp
parameter_list|)
block|{
name|struct
name|ecore_resc_alloc_out_params
name|out_params
decl_stmt|;
name|struct
name|ecore_resc_alloc_in_params
name|in_params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|in_params
argument_list|,
sizeof|sizeof
argument_list|(
name|in_params
argument_list|)
argument_list|)
expr_stmt|;
name|in_params
operator|.
name|cmd
operator|=
name|DRV_MSG_SET_RESOURCE_VALUE_MSG
expr_stmt|;
name|in_params
operator|.
name|res_id
operator|=
name|res_id
expr_stmt|;
name|in_params
operator|.
name|resc_max_val
operator|=
name|resc_max_val
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|out_params
argument_list|,
sizeof|sizeof
argument_list|(
name|out_params
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_resc_allocation_msg
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|in_params
argument_list|,
operator|&
name|out_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
operator|*
name|p_mcp_resp
operator|=
name|out_params
operator|.
name|mcp_resp
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_resc_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|ecore_resources
name|res_id
parameter_list|,
name|u32
modifier|*
name|p_mcp_resp
parameter_list|,
name|u32
modifier|*
name|p_resc_num
parameter_list|,
name|u32
modifier|*
name|p_resc_start
parameter_list|)
block|{
name|struct
name|ecore_resc_alloc_out_params
name|out_params
decl_stmt|;
name|struct
name|ecore_resc_alloc_in_params
name|in_params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|in_params
argument_list|,
sizeof|sizeof
argument_list|(
name|in_params
argument_list|)
argument_list|)
expr_stmt|;
name|in_params
operator|.
name|cmd
operator|=
name|DRV_MSG_GET_RESOURCE_ALLOC_MSG
expr_stmt|;
name|in_params
operator|.
name|res_id
operator|=
name|res_id
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|out_params
argument_list|,
sizeof|sizeof
argument_list|(
name|out_params
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_resc_allocation_msg
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|in_params
argument_list|,
operator|&
name|out_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
operator|*
name|p_mcp_resp
operator|=
name|out_params
operator|.
name|mcp_resp
expr_stmt|;
if|if
condition|(
operator|*
name|p_mcp_resp
operator|==
name|FW_MSG_CODE_RESOURCE_ALLOC_OK
condition|)
block|{
operator|*
name|p_resc_num
operator|=
name|out_params
operator|.
name|resc_num
expr_stmt|;
operator|*
name|p_resc_start
operator|=
name|out_params
operator|.
name|resc_start
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_initiate_pf_flr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|mcp_resp
decl_stmt|,
name|mcp_param
decl_stmt|;
return|return
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_INITIATE_PF_FLR
argument_list|,
literal|0
argument_list|,
operator|&
name|mcp_resp
argument_list|,
operator|&
name|mcp_param
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_lldp_mac
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|lldp_mac_addr
index|[
name|ETH_ALEN
index|]
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|struct
name|mcp_mac
name|lldp_mac
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_GET_LLDP_MAC
expr_stmt|;
name|mb_params
operator|.
name|p_data_dst
operator|=
operator|&
name|lldp_mac
expr_stmt|;
name|mb_params
operator|.
name|data_dst_size
operator|=
sizeof|sizeof
argument_list|(
name|lldp_mac
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|mb_params
operator|.
name|mcp_resp
operator|!=
name|FW_MSG_CODE_OK
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"MFW lacks support for the GET_LLDP_MAC command [resp 0x%08x]\n"
argument_list|,
name|mb_params
operator|.
name|mcp_resp
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
operator|*
operator|(
name|u16
operator|*
operator|)
name|lldp_mac_addr
operator|=
operator|*
operator|(
name|u16
operator|*
operator|)
operator|&
name|lldp_mac
operator|.
name|mac_upper
expr_stmt|;
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
name|lldp_mac_addr
operator|+
literal|2
operator|)
operator|=
name|lldp_mac
operator|.
name|mac_lower
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"LLDP MAC address is %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\n"
argument_list|,
name|lldp_mac_addr
index|[
literal|0
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|1
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|2
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|3
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|4
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_set_lldp_mac
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|lldp_mac_addr
index|[
name|ETH_ALEN
index|]
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|struct
name|mcp_mac
name|lldp_mac
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Configuring LLDP MAC address to %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\n"
argument_list|,
name|lldp_mac_addr
index|[
literal|0
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|1
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|2
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|3
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|4
index|]
argument_list|,
name|lldp_mac_addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|lldp_mac
argument_list|,
sizeof|sizeof
argument_list|(
name|lldp_mac
argument_list|)
argument_list|)
expr_stmt|;
name|lldp_mac
operator|.
name|mac_upper
operator|=
operator|*
operator|(
name|u16
operator|*
operator|)
name|lldp_mac_addr
expr_stmt|;
name|lldp_mac
operator|.
name|mac_lower
operator|=
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
name|lldp_mac_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_SET_LLDP_MAC
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|lldp_mac
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|lldp_mac
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|mb_params
operator|.
name|mcp_resp
operator|!=
name|FW_MSG_CODE_OK
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"MFW lacks support for the SET_LLDP_MAC command [resp 0x%08x]\n"
argument_list|,
name|mb_params
operator|.
name|mcp_resp
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_mcp_resource_cmd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|param
parameter_list|,
name|u32
modifier|*
name|p_mcp_resp
parameter_list|,
name|u32
modifier|*
name|p_mcp_param
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_RESOURCE_CMD
argument_list|,
name|param
argument_list|,
name|p_mcp_resp
argument_list|,
name|p_mcp_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|*
name|p_mcp_resp
operator|==
name|FW_MSG_CODE_UNSUPPORTED
condition|)
block|{
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"The resource command is unsupported by the MFW\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOTIMPL
return|;
block|}
if|if
condition|(
operator|*
name|p_mcp_param
operator|==
name|RESOURCE_OPCODE_UNKNOWN_CMD
condition|)
block|{
name|u8
name|opcode
init|=
name|ECORE_MFW_GET_FIELD
argument_list|(
name|param
argument_list|,
name|RESOURCE_CMD_REQ_OPCODE
argument_list|)
decl_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"The resource command is unknown to the MFW [param 0x%08x, opcode %d]\n"
argument_list|,
name|param
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|__ecore_mcp_resc_lock
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_resc_lock_params
modifier|*
name|p_params
parameter_list|)
block|{
name|u32
name|param
init|=
literal|0
decl_stmt|,
name|mcp_resp
decl_stmt|,
name|mcp_param
decl_stmt|;
name|u8
name|opcode
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
switch|switch
condition|(
name|p_params
operator|->
name|timeout
condition|)
block|{
case|case
name|ECORE_MCP_RESC_LOCK_TO_DEFAULT
case|:
name|opcode
operator|=
name|RESOURCE_OPCODE_REQ
expr_stmt|;
name|p_params
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ECORE_MCP_RESC_LOCK_TO_NONE
case|:
name|opcode
operator|=
name|RESOURCE_OPCODE_REQ_WO_AGING
expr_stmt|;
name|p_params
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|opcode
operator|=
name|RESOURCE_OPCODE_REQ_W_AGING
expr_stmt|;
break|break;
block|}
name|ECORE_MFW_SET_FIELD
argument_list|(
name|param
argument_list|,
name|RESOURCE_CMD_REQ_RESC
argument_list|,
name|p_params
operator|->
name|resource
argument_list|)
expr_stmt|;
name|ECORE_MFW_SET_FIELD
argument_list|(
name|param
argument_list|,
name|RESOURCE_CMD_REQ_OPCODE
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|ECORE_MFW_SET_FIELD
argument_list|(
name|param
argument_list|,
name|RESOURCE_CMD_REQ_AGE
argument_list|,
name|p_params
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Resource lock request: param 0x%08x [age %d, opcode %d, resource %d]\n"
argument_list|,
name|param
argument_list|,
name|p_params
operator|->
name|timeout
argument_list|,
name|opcode
argument_list|,
name|p_params
operator|->
name|resource
argument_list|)
expr_stmt|;
comment|/* Attempt to acquire the resource */
name|rc
operator|=
name|ecore_mcp_resource_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|param
argument_list|,
operator|&
name|mcp_resp
argument_list|,
operator|&
name|mcp_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* Analyze the response */
name|p_params
operator|->
name|owner
operator|=
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mcp_param
argument_list|,
name|RESOURCE_CMD_RSP_OWNER
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mcp_param
argument_list|,
name|RESOURCE_CMD_RSP_OPCODE
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Resource lock response: mcp_param 0x%08x [opcode %d, owner %d]\n"
argument_list|,
name|mcp_param
argument_list|,
name|opcode
argument_list|,
name|p_params
operator|->
name|owner
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|RESOURCE_OPCODE_GNT
case|:
name|p_params
operator|->
name|b_granted
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RESOURCE_OPCODE_BUSY
case|:
name|p_params
operator|->
name|b_granted
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Unexpected opcode in resource lock response [mcp_param 0x%08x, opcode %d]\n"
argument_list|,
name|mcp_param
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_resc_lock
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_resc_lock_params
modifier|*
name|p_params
parameter_list|)
block|{
name|u32
name|retry_cnt
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
do|do
block|{
comment|/* No need for an interval before the first iteration */
if|if
condition|(
name|retry_cnt
condition|)
block|{
if|if
condition|(
name|p_params
operator|->
name|sleep_b4_retry
condition|)
block|{
name|u16
name|retry_interval_in_ms
init|=
name|DIV_ROUND_UP
argument_list|(
name|p_params
operator|->
name|retry_interval
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|OSAL_MSLEEP
argument_list|(
name|retry_interval_in_ms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSAL_UDELAY
argument_list|(
name|p_params
operator|->
name|retry_interval
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|__ecore_mcp_resc_lock
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|p_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|p_params
operator|->
name|b_granted
condition|)
break|break;
block|}
do|while
condition|(
name|retry_cnt
operator|++
operator|<
name|p_params
operator|->
name|retry_num
condition|)
do|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_resc_unlock
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|ecore_resc_unlock_params
modifier|*
name|p_params
parameter_list|)
block|{
name|u32
name|param
init|=
literal|0
decl_stmt|,
name|mcp_resp
decl_stmt|,
name|mcp_param
decl_stmt|;
name|u8
name|opcode
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|opcode
operator|=
name|p_params
operator|->
name|b_force
condition|?
name|RESOURCE_OPCODE_FORCE_RELEASE
else|:
name|RESOURCE_OPCODE_RELEASE
expr_stmt|;
name|ECORE_MFW_SET_FIELD
argument_list|(
name|param
argument_list|,
name|RESOURCE_CMD_REQ_RESC
argument_list|,
name|p_params
operator|->
name|resource
argument_list|)
expr_stmt|;
name|ECORE_MFW_SET_FIELD
argument_list|(
name|param
argument_list|,
name|RESOURCE_CMD_REQ_OPCODE
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Resource unlock request: param 0x%08x [opcode %d, resource %d]\n"
argument_list|,
name|param
argument_list|,
name|opcode
argument_list|,
name|p_params
operator|->
name|resource
argument_list|)
expr_stmt|;
comment|/* Attempt to release the resource */
name|rc
operator|=
name|ecore_mcp_resource_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|param
argument_list|,
operator|&
name|mcp_resp
argument_list|,
operator|&
name|mcp_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|rc
return|;
comment|/* Analyze the response */
name|opcode
operator|=
name|ECORE_MFW_GET_FIELD
argument_list|(
name|mcp_param
argument_list|,
name|RESOURCE_CMD_RSP_OPCODE
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SP
argument_list|,
literal|"Resource unlock response: mcp_param 0x%08x [opcode %d]\n"
argument_list|,
name|mcp_param
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|RESOURCE_OPCODE_RELEASED_PREVIOUS
case|:
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Resource unlock request for an already released resource [%d]\n"
argument_list|,
name|p_params
operator|->
name|resource
argument_list|)
expr_stmt|;
comment|/* Fallthrough */
case|case
name|RESOURCE_OPCODE_RELEASED
case|:
name|p_params
operator|->
name|b_released
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RESOURCE_OPCODE_WRONG_OWNER
case|:
name|p_params
operator|->
name|b_released
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Unexpected opcode in resource unlock response [mcp_param 0x%08x, opcode %d]\n"
argument_list|,
name|mcp_param
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_update_fcoe_cvid
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|vlan
parameter_list|)
block|{
name|u32
name|resp
init|=
literal|0
decl_stmt|,
name|param
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_OEM_UPDATE_FCOE_CVID
argument_list|,
operator|(
name|u32
operator|)
name|vlan
operator|<<
name|DRV_MB_PARAM_FCOE_CVID_SHIFT
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to update fcoe vlan, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_update_fcoe_fabric_name
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
modifier|*
name|wwn
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
decl_stmt|;
name|struct
name|mcp_wwn
name|fabric_name
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|fabric_name
argument_list|,
sizeof|sizeof
argument_list|(
name|fabric_name
argument_list|)
argument_list|)
expr_stmt|;
name|fabric_name
operator|.
name|wwn_upper
operator|=
operator|*
operator|(
name|u32
operator|*
operator|)
name|wwn
expr_stmt|;
name|fabric_name
operator|.
name|wwn_lower
operator|=
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
name|wwn
operator|+
literal|4
operator|)
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
operator|&
name|mb_params
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_params
argument_list|)
argument_list|)
expr_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_OEM_UPDATE_FCOE_FABRIC_NAME
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|fabric_name
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|fabric_name
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
name|DP_ERR
argument_list|(
name|p_hwfn
argument_list|,
literal|"Failed to update fcoe wwn, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_mcp_wol_wr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|struct
name|ecore_mcp_mb_params
name|mb_params
init|=
block|{
literal|0
block|}
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u32
name|dword
init|=
name|val
decl_stmt|;
name|mb_params
operator|.
name|cmd
operator|=
name|DRV_MSG_CODE_WRITE_WOL_REG
expr_stmt|;
name|mb_params
operator|.
name|param
operator|=
name|offset
expr_stmt|;
name|mb_params
operator|.
name|p_data_src
operator|=
operator|&
name|dword
expr_stmt|;
name|mb_params
operator|.
name|data_src_size
operator|=
sizeof|sizeof
argument_list|(
name|dword
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd_and_union
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|mb_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to wol write request, rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mb_params
operator|.
name|mcp_resp
operator|!=
name|FW_MSG_CODE_WOL_READ_WRITE_OK
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to write value 0x%x to offset 0x%x [mcp_resp 0x%x]\n"
argument_list|,
name|val
argument_list|,
name|offset
argument_list|,
name|mb_params
operator|.
name|mcp_resp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_UNKNOWN_ERROR
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_get_capabilities
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|mcp_resp
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_GET_MFW_FEATURE_SUPPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|mcp_resp
argument_list|,
operator|&
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|capabilities
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|ECORE_MSG_SP
operator||
name|ECORE_MSG_PROBE
operator|)
argument_list|,
literal|"MFW supported features: %08x\n"
argument_list|,
name|p_hwfn
operator|->
name|mcp_info
operator|->
name|capabilities
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_mcp_set_capabilities
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|mcp_resp
decl_stmt|,
name|mcp_param
decl_stmt|,
name|features
decl_stmt|;
name|features
operator|=
name|DRV_MB_PARAM_FEATURE_SUPPORT_PORT_SMARTLINQ
operator||
name|DRV_MB_PARAM_FEATURE_SUPPORT_PORT_EEE
expr_stmt|;
return|return
name|ecore_mcp_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_FEATURE_SUPPORT
argument_list|,
name|features
argument_list|,
operator|&
name|mcp_resp
argument_list|,
operator|&
name|mcp_param
argument_list|)
return|;
block|}
end_function

end_unit

