begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * File : ecore_dbg_fw_funcs.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bcm_osal.h"
end_include

begin_include
include|#
directive|include
file|"ecore.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw.h"
end_include

begin_include
include|#
directive|include
file|"ecore_mcp.h"
end_include

begin_include
include|#
directive|include
file|"spad_layout.h"
end_include

begin_include
include|#
directive|include
file|"nvm_map.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_common.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_debug_tools.h"
end_include

begin_include
include|#
directive|include
file|"mcp_public.h"
end_include

begin_include
include|#
directive|include
file|"nvm_map.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_DBG_BIN_FILE
end_ifndef

begin_include
include|#
directive|include
file|"ecore_dbg_values.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ecore_dbg_fw_funcs.h"
end_include

begin_comment
comment|/* Memory groups enum */
end_comment

begin_enum
enum|enum
name|mem_groups
block|{
name|MEM_GROUP_PXP_MEM
block|,
name|MEM_GROUP_DMAE_MEM
block|,
name|MEM_GROUP_CM_MEM
block|,
name|MEM_GROUP_QM_MEM
block|,
name|MEM_GROUP_TM_MEM
block|,
name|MEM_GROUP_BRB_RAM
block|,
name|MEM_GROUP_BRB_MEM
block|,
name|MEM_GROUP_PRS_MEM
block|,
name|MEM_GROUP_SDM_MEM
block|,
name|MEM_GROUP_IOR
block|,
name|MEM_GROUP_RAM
block|,
name|MEM_GROUP_BTB_RAM
block|,
name|MEM_GROUP_RDIF_CTX
block|,
name|MEM_GROUP_TDIF_CTX
block|,
name|MEM_GROUP_CFC_MEM
block|,
name|MEM_GROUP_CONN_CFC_MEM
block|,
name|MEM_GROUP_TASK_CFC_MEM
block|,
name|MEM_GROUP_CAU_PI
block|,
name|MEM_GROUP_CAU_MEM
block|,
name|MEM_GROUP_PXP_ILT
block|,
name|MEM_GROUP_PBUF
block|,
name|MEM_GROUP_MULD_MEM
block|,
name|MEM_GROUP_BTB_MEM
block|,
name|MEM_GROUP_IGU_MEM
block|,
name|MEM_GROUP_IGU_MSIX
block|,
name|MEM_GROUP_CAU_SB
block|,
name|MEM_GROUP_BMB_RAM
block|,
name|MEM_GROUP_BMB_MEM
block|,
name|MEM_GROUPS_NUM
block|}
enum|;
end_enum

begin_comment
comment|/* Memory groups names */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_mem_group_names
index|[]
init|=
block|{
literal|"PXP_MEM"
block|,
literal|"DMAE_MEM"
block|,
literal|"CM_MEM"
block|,
literal|"QM_MEM"
block|,
literal|"TM_MEM"
block|,
literal|"BRB_RAM"
block|,
literal|"BRB_MEM"
block|,
literal|"PRS_MEM"
block|,
literal|"SDM_MEM"
block|,
literal|"IOR"
block|,
literal|"RAM"
block|,
literal|"BTB_RAM"
block|,
literal|"RDIF_CTX"
block|,
literal|"TDIF_CTX"
block|,
literal|"CFC_MEM"
block|,
literal|"CONN_CFC_MEM"
block|,
literal|"TASK_CFC_MEM"
block|,
literal|"CAU_PI"
block|,
literal|"CAU_MEM"
block|,
literal|"PXP_ILT"
block|,
literal|"PBUF"
block|,
literal|"MULD_MEM"
block|,
literal|"BTB_MEM"
block|,
literal|"IGU_MEM"
block|,
literal|"IGU_MSIX"
block|,
literal|"CAU_SB"
block|,
literal|"BMB_RAM"
block|,
literal|"BMB_MEM"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Idle check conditions */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__PREVENT_COND_ARR__
end_ifndef

begin_function
specifier|static
name|u32
name|cond5
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|&
name|imm
index|[
literal|0
index|]
operator|)
operator|!=
name|imm
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
operator|(
name|r
index|[
literal|1
index|]
operator|&
name|imm
index|[
literal|2
index|]
operator|)
operator|!=
name|imm
index|[
literal|3
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond7
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|>>
name|imm
index|[
literal|0
index|]
operator|)
operator|&
name|imm
index|[
literal|1
index|]
operator|)
operator|!=
name|imm
index|[
literal|2
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond14
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|!=
name|imm
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
operator|(
operator|(
name|r
index|[
literal|1
index|]
operator|>>
name|imm
index|[
literal|1
index|]
operator|)
operator|&
name|imm
index|[
literal|2
index|]
operator|)
operator|==
name|imm
index|[
literal|3
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond6
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|&
name|imm
index|[
literal|0
index|]
operator|)
operator|!=
name|imm
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond9
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|&
name|imm
index|[
literal|0
index|]
operator|)
operator|>>
name|imm
index|[
literal|1
index|]
operator|)
operator|!=
operator|(
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|&
name|imm
index|[
literal|2
index|]
operator|)
operator|>>
name|imm
index|[
literal|3
index|]
operator|)
operator||
operator|(
operator|(
name|r
index|[
literal|1
index|]
operator|&
name|imm
index|[
literal|4
index|]
operator|)
operator|<<
name|imm
index|[
literal|5
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond10
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|&
name|imm
index|[
literal|0
index|]
operator|)
operator|>>
name|imm
index|[
literal|1
index|]
operator|)
operator|!=
operator|(
name|r
index|[
literal|0
index|]
operator|&
name|imm
index|[
literal|2
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond4
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|&
operator|~
name|imm
index|[
literal|0
index|]
operator|)
operator|!=
name|imm
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond0
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|r
index|[
literal|0
index|]
operator|&
operator|~
name|r
index|[
literal|1
index|]
operator|)
operator|!=
name|imm
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond1
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|r
index|[
literal|0
index|]
operator|!=
name|imm
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond11
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|r
index|[
literal|0
index|]
operator|!=
name|r
index|[
literal|1
index|]
operator|&&
name|r
index|[
literal|2
index|]
operator|==
name|imm
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond12
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|r
index|[
literal|0
index|]
operator|!=
name|r
index|[
literal|1
index|]
operator|&&
name|r
index|[
literal|2
index|]
operator|>
name|imm
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond3
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|r
index|[
literal|0
index|]
operator|!=
name|r
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond13
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|r
index|[
literal|0
index|]
operator|&
name|imm
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond8
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|r
index|[
literal|0
index|]
operator|<
operator|(
name|r
index|[
literal|1
index|]
operator|-
name|imm
index|[
literal|0
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|cond2
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|r
index|[
literal|0
index|]
operator|>
name|imm
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Array of Idle Check conditions */
end_comment

begin_function_decl
specifier|static
name|u32
function_decl|(
modifier|*
name|cond_arr
index|[]
function_decl|)
parameter_list|(
specifier|const
name|u32
modifier|*
name|r
parameter_list|,
specifier|const
name|u32
modifier|*
name|imm
parameter_list|)
init|=
block|{
name|cond0
operator|,
function_decl|cond1
operator|,
function_decl|cond2
operator|,
function_decl|cond3
operator|,
function_decl|cond4
operator|,
function_decl|cond5
operator|,
function_decl|cond6
operator|,
function_decl|cond7
operator|,
function_decl|cond8
operator|,
function_decl|cond9
operator|,
function_decl|cond10
operator|,
function_decl|cond11
operator|,
function_decl|cond12
operator|,
function_decl|cond13
operator|,
function_decl|cond14
operator|,
end_function_decl

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|/* __PREVENT_COND_ARR__ */
end_comment

begin_comment
comment|/******************************* Data Types **********************************/
end_comment

begin_enum
enum|enum
name|platform_ids
block|{
name|PLATFORM_ASIC
block|,
name|PLATFORM_EMUL_FULL
block|,
name|PLATFORM_EMUL_REDUCED
block|,
name|PLATFORM_FPGA
block|,
name|MAX_PLATFORM_IDS
block|}
enum|;
end_enum

begin_struct
struct|struct
name|chip_platform_defs
block|{
name|u8
name|num_ports
decl_stmt|;
name|u8
name|num_pfs
decl_stmt|;
name|u8
name|num_vfs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chip constant definitions */
end_comment

begin_struct
struct|struct
name|chip_defs
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|chip_platform_defs
name|per_platform
index|[
name|MAX_PLATFORM_IDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Platform constant definitions */
end_comment

begin_struct
struct|struct
name|platform_defs
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|u32
name|delay_factor
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Storm constant definitions.  * Addresses are in bytes, sizes are in quad-regs.  */
end_comment

begin_struct
struct|struct
name|storm_defs
block|{
name|char
name|letter
decl_stmt|;
name|enum
name|block_id
name|block_id
decl_stmt|;
name|enum
name|dbg_bus_clients
name|dbg_client_id
index|[
name|MAX_CHIP_IDS
index|]
decl_stmt|;
name|bool
name|has_vfc
decl_stmt|;
name|u32
name|sem_fast_mem_addr
decl_stmt|;
name|u32
name|sem_frame_mode_addr
decl_stmt|;
name|u32
name|sem_slow_enable_addr
decl_stmt|;
name|u32
name|sem_slow_mode_addr
decl_stmt|;
name|u32
name|sem_slow_mode1_conf_addr
decl_stmt|;
name|u32
name|sem_sync_dbg_empty_addr
decl_stmt|;
name|u32
name|sem_slow_dbg_empty_addr
decl_stmt|;
name|u32
name|cm_ctx_wr_addr
decl_stmt|;
name|u32
name|cm_conn_ag_ctx_lid_size
decl_stmt|;
name|u32
name|cm_conn_ag_ctx_rd_addr
decl_stmt|;
name|u32
name|cm_conn_st_ctx_lid_size
decl_stmt|;
name|u32
name|cm_conn_st_ctx_rd_addr
decl_stmt|;
name|u32
name|cm_task_ag_ctx_lid_size
decl_stmt|;
name|u32
name|cm_task_ag_ctx_rd_addr
decl_stmt|;
name|u32
name|cm_task_st_ctx_lid_size
decl_stmt|;
name|u32
name|cm_task_st_ctx_rd_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Block constant definitions */
end_comment

begin_struct
struct|struct
name|block_defs
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bool
name|has_dbg_bus
index|[
name|MAX_CHIP_IDS
index|]
decl_stmt|;
name|bool
name|associated_to_storm
decl_stmt|;
comment|/* Valid only if associated_to_storm is true */
name|u32
name|storm_id
decl_stmt|;
name|enum
name|dbg_bus_clients
name|dbg_client_id
index|[
name|MAX_CHIP_IDS
index|]
decl_stmt|;
name|u32
name|dbg_select_addr
decl_stmt|;
name|u32
name|dbg_enable_addr
decl_stmt|;
name|u32
name|dbg_shift_addr
decl_stmt|;
name|u32
name|dbg_force_valid_addr
decl_stmt|;
name|u32
name|dbg_force_frame_addr
decl_stmt|;
name|bool
name|has_reset_bit
decl_stmt|;
comment|/* If true, block is taken out of reset before dump */
name|bool
name|unreset
decl_stmt|;
name|enum
name|dbg_reset_regs
name|reset_reg
decl_stmt|;
comment|/* Bit offset in reset register */
name|u8
name|reset_bit_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Reset register definitions */
end_comment

begin_struct
struct|struct
name|reset_reg_defs
block|{
name|u32
name|addr
decl_stmt|;
name|u32
name|unreset_val
decl_stmt|;
name|bool
name|exists
index|[
name|MAX_CHIP_IDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Debug Bus Constraint operation constant definitions */
end_comment

begin_struct
struct|struct
name|dbg_bus_constraint_op_defs
block|{
name|u8
name|hw_op_val
decl_stmt|;
name|bool
name|is_cyclic
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Storm Mode definitions */
end_comment

begin_struct
struct|struct
name|storm_mode_defs
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bool
name|is_fast_dbg
decl_stmt|;
name|u8
name|id_in_hw
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|grc_param_defs
block|{
name|u32
name|default_val
index|[
name|MAX_CHIP_IDS
index|]
decl_stmt|;
name|u32
name|min
decl_stmt|;
name|u32
name|max
decl_stmt|;
name|bool
name|is_preset
decl_stmt|;
name|u32
name|exclude_all_preset_val
decl_stmt|;
name|u32
name|crash_preset_val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* address is in 128b units. Width is in bits. */
end_comment

begin_struct
struct|struct
name|rss_mem_defs
block|{
specifier|const
name|char
modifier|*
name|mem_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|type_name
decl_stmt|;
name|u32
name|addr
decl_stmt|;
name|u32
name|num_entries
index|[
name|MAX_CHIP_IDS
index|]
decl_stmt|;
name|u32
name|entry_width
index|[
name|MAX_CHIP_IDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vfc_ram_defs
block|{
specifier|const
name|char
modifier|*
name|mem_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|type_name
decl_stmt|;
name|u32
name|base_row
decl_stmt|;
name|u32
name|num_rows
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|big_ram_defs
block|{
specifier|const
name|char
modifier|*
name|instance_name
decl_stmt|;
name|enum
name|mem_groups
name|mem_group_id
decl_stmt|;
name|enum
name|mem_groups
name|ram_mem_group_id
decl_stmt|;
name|enum
name|dbg_grc_params
name|grc_param
decl_stmt|;
name|u32
name|addr_reg_addr
decl_stmt|;
name|u32
name|data_reg_addr
decl_stmt|;
name|u32
name|num_of_blocks
index|[
name|MAX_CHIP_IDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|phy_defs
block|{
specifier|const
name|char
modifier|*
name|phy_name
decl_stmt|;
comment|/* PHY base GRC address */
name|u32
name|base_addr
decl_stmt|;
comment|/* Relative address of indirect TBUS address register (bits 0..7) */
name|u32
name|tbus_addr_lo_addr
decl_stmt|;
comment|/* Relative address of indirect TBUS address register (bits 8..10) */
name|u32
name|tbus_addr_hi_addr
decl_stmt|;
comment|/* Relative address of indirect TBUS data register (bits 0..7) */
name|u32
name|tbus_data_lo_addr
decl_stmt|;
comment|/* Relative address of indirect TBUS data register (bits 8..11) */
name|u32
name|tbus_data_hi_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/******************************** Constants **********************************/
end_comment

begin_define
define|#
directive|define
name|MAX_LCIDS
value|320
end_define

begin_define
define|#
directive|define
name|MAX_LTIDS
value|320
end_define

begin_define
define|#
directive|define
name|NUM_IOR_SETS
value|2
end_define

begin_define
define|#
directive|define
name|IORS_PER_SET
value|176
end_define

begin_define
define|#
directive|define
name|IOR_SET_OFFSET
parameter_list|(
name|set_id
parameter_list|)
value|((set_id) * 256)
end_define

begin_define
define|#
directive|define
name|BYTES_IN_DWORD
value|sizeof(u32)
end_define

begin_comment
comment|/* Cyclic  right */
end_comment

begin_define
define|#
directive|define
name|SHR
parameter_list|(
name|val
parameter_list|,
name|val_width
parameter_list|,
name|amount
parameter_list|)
value|(((val) | ((val)<< (val_width)))>> (amount))& ((1<< (val_width)) - 1)
end_define

begin_comment
comment|/* In the macros below, size and offset are specified in bits */
end_comment

begin_define
define|#
directive|define
name|CEIL_DWORDS
parameter_list|(
name|size
parameter_list|)
value|DIV_ROUND_UP(size, 32)
end_define

begin_define
define|#
directive|define
name|FIELD_BIT_OFFSET
parameter_list|(
name|type
parameter_list|,
name|field
parameter_list|)
value|type##_##field##_##OFFSET
end_define

begin_define
define|#
directive|define
name|FIELD_BIT_SIZE
parameter_list|(
name|type
parameter_list|,
name|field
parameter_list|)
value|type##_##field##_##SIZE
end_define

begin_define
define|#
directive|define
name|FIELD_DWORD_OFFSET
parameter_list|(
name|type
parameter_list|,
name|field
parameter_list|)
value|(int)(FIELD_BIT_OFFSET(type, field) / 32)
end_define

begin_define
define|#
directive|define
name|FIELD_DWORD_SHIFT
parameter_list|(
name|type
parameter_list|,
name|field
parameter_list|)
value|(FIELD_BIT_OFFSET(type, field) % 32)
end_define

begin_define
define|#
directive|define
name|FIELD_BIT_MASK
parameter_list|(
name|type
parameter_list|,
name|field
parameter_list|)
value|(((1<< FIELD_BIT_SIZE(type, field)) - 1)<< FIELD_DWORD_SHIFT(type, field))
end_define

begin_define
define|#
directive|define
name|SET_VAR_FIELD
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|,
name|val
parameter_list|)
value|var[FIELD_DWORD_OFFSET(type, field)]&= 		(~FIELD_BIT_MASK(type, field)); 	var[FIELD_DWORD_OFFSET(type, field)] |= 		(val)<< FIELD_DWORD_SHIFT(type, field)
end_define

begin_define
define|#
directive|define
name|ARR_REG_WR
parameter_list|(
name|dev
parameter_list|,
name|ptt
parameter_list|,
name|addr
parameter_list|,
name|arr
parameter_list|,
name|arr_size
parameter_list|)
value|for (i = 0; i< (arr_size); i++) 		ecore_wr(dev, ptt, addr, (arr)[i])
end_define

begin_define
define|#
directive|define
name|ARR_REG_RD
parameter_list|(
name|dev
parameter_list|,
name|ptt
parameter_list|,
name|addr
parameter_list|,
name|arr
parameter_list|,
name|arr_size
parameter_list|)
value|for (i = 0; i< (arr_size); i++) 		(arr)[i] = ecore_rd(dev, ptt, addr)
end_define

begin_define
define|#
directive|define
name|CHECK_ARR_SIZE
parameter_list|(
name|arr
parameter_list|,
name|size
parameter_list|)
value|OSAL_BUILD_BUG_ON(!(OSAL_ARRAY_SIZE(arr) == size))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DWORDS_TO_BYTES
end_ifndef

begin_define
define|#
directive|define
name|DWORDS_TO_BYTES
parameter_list|(
name|dwords
parameter_list|)
value|((dwords) * BYTES_IN_DWORD)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BYTES_TO_DWORDS
end_ifndef

begin_define
define|#
directive|define
name|BYTES_TO_DWORDS
parameter_list|(
name|bytes
parameter_list|)
value|((bytes) / BYTES_IN_DWORD)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* extra lines include a signature line + optional latency events line */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NUM_DBG_LINES
end_ifndef

begin_define
define|#
directive|define
name|NUM_EXTRA_DBG_LINES
parameter_list|(
name|block_desc
parameter_list|)
value|(1 + (block_desc->has_latency_events ? 1 : 0))
end_define

begin_define
define|#
directive|define
name|NUM_DBG_LINES
parameter_list|(
name|block_desc
parameter_list|)
value|(block_desc->num_of_lines + NUM_EXTRA_DBG_LINES(block_desc))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAM_LINES_TO_DWORDS
parameter_list|(
name|lines
parameter_list|)
value|((lines) * 2)
end_define

begin_define
define|#
directive|define
name|RAM_LINES_TO_BYTES
parameter_list|(
name|lines
parameter_list|)
value|DWORDS_TO_BYTES(RAM_LINES_TO_DWORDS(lines))
end_define

begin_define
define|#
directive|define
name|REG_DUMP_LEN_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|MEM_DUMP_ENTRY_SIZE_DWORDS
value|BYTES_TO_DWORDS(sizeof(struct dbg_dump_mem))
end_define

begin_define
define|#
directive|define
name|IDLE_CHK_RULE_SIZE_DWORDS
value|BYTES_TO_DWORDS(sizeof(struct dbg_idle_chk_rule))
end_define

begin_define
define|#
directive|define
name|IDLE_CHK_RESULT_HDR_DWORDS
value|BYTES_TO_DWORDS(sizeof(struct dbg_idle_chk_result_hdr))
end_define

begin_define
define|#
directive|define
name|IDLE_CHK_RESULT_REG_HDR_DWORDS
value|BYTES_TO_DWORDS(sizeof(struct dbg_idle_chk_result_reg_hdr))
end_define

begin_define
define|#
directive|define
name|IDLE_CHK_MAX_ENTRIES_SIZE
value|32
end_define

begin_comment
comment|/* The sizes and offsets below are specified in bits */
end_comment

begin_define
define|#
directive|define
name|VFC_CAM_CMD_STRUCT_SIZE
value|64
end_define

begin_define
define|#
directive|define
name|VFC_CAM_CMD_ROW_OFFSET
value|48
end_define

begin_define
define|#
directive|define
name|VFC_CAM_CMD_ROW_SIZE
value|9
end_define

begin_define
define|#
directive|define
name|VFC_CAM_ADDR_STRUCT_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|VFC_CAM_ADDR_OP_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|VFC_CAM_ADDR_OP_SIZE
value|4
end_define

begin_define
define|#
directive|define
name|VFC_CAM_RESP_STRUCT_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|VFC_RAM_ADDR_STRUCT_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|VFC_RAM_ADDR_OP_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|VFC_RAM_ADDR_OP_SIZE
value|2
end_define

begin_define
define|#
directive|define
name|VFC_RAM_ADDR_ROW_OFFSET
value|2
end_define

begin_define
define|#
directive|define
name|VFC_RAM_ADDR_ROW_SIZE
value|10
end_define

begin_define
define|#
directive|define
name|VFC_RAM_RESP_STRUCT_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|VFC_CAM_CMD_DWORDS
value|CEIL_DWORDS(VFC_CAM_CMD_STRUCT_SIZE)
end_define

begin_define
define|#
directive|define
name|VFC_CAM_ADDR_DWORDS
value|CEIL_DWORDS(VFC_CAM_ADDR_STRUCT_SIZE)
end_define

begin_define
define|#
directive|define
name|VFC_CAM_RESP_DWORDS
value|CEIL_DWORDS(VFC_CAM_RESP_STRUCT_SIZE)
end_define

begin_define
define|#
directive|define
name|VFC_RAM_CMD_DWORDS
value|VFC_CAM_CMD_DWORDS
end_define

begin_define
define|#
directive|define
name|VFC_RAM_ADDR_DWORDS
value|CEIL_DWORDS(VFC_RAM_ADDR_STRUCT_SIZE)
end_define

begin_define
define|#
directive|define
name|VFC_RAM_RESP_DWORDS
value|CEIL_DWORDS(VFC_RAM_RESP_STRUCT_SIZE)
end_define

begin_define
define|#
directive|define
name|NUM_VFC_RAM_TYPES
value|4
end_define

begin_define
define|#
directive|define
name|VFC_CAM_NUM_ROWS
value|512
end_define

begin_define
define|#
directive|define
name|VFC_OPCODE_CAM_RD
value|14
end_define

begin_define
define|#
directive|define
name|VFC_OPCODE_RAM_RD
value|0
end_define

begin_define
define|#
directive|define
name|NUM_RSS_MEM_TYPES
value|5
end_define

begin_define
define|#
directive|define
name|NUM_BIG_RAM_TYPES
value|3
end_define

begin_define
define|#
directive|define
name|BIG_RAM_BLOCK_SIZE_BYTES
value|128
end_define

begin_define
define|#
directive|define
name|BIG_RAM_BLOCK_SIZE_DWORDS
value|BYTES_TO_DWORDS(BIG_RAM_BLOCK_SIZE_BYTES)
end_define

begin_define
define|#
directive|define
name|NUM_PHY_TBUS_ADDRESSES
value|2048
end_define

begin_define
define|#
directive|define
name|PHY_DUMP_SIZE_DWORDS
value|(NUM_PHY_TBUS_ADDRESSES / 2)
end_define

begin_define
define|#
directive|define
name|SEM_FAST_MODE6_SRC_ENABLE
value|0x10
end_define

begin_define
define|#
directive|define
name|SEM_FAST_MODE6_SRC_DISABLE
value|0x3f
end_define

begin_define
define|#
directive|define
name|SEM_SLOW_MODE1_DATA_ENABLE
value|0x1
end_define

begin_define
define|#
directive|define
name|VALUES_PER_CYCLE
value|4
end_define

begin_define
define|#
directive|define
name|MAX_CYCLE_VALUES_MASK
value|((1<< VALUES_PER_CYCLE) - 1)
end_define

begin_define
define|#
directive|define
name|MAX_DWORDS_PER_CYCLE
value|8
end_define

begin_define
define|#
directive|define
name|HW_ID_BITS
value|3
end_define

begin_define
define|#
directive|define
name|NUM_CALENDAR_SLOTS
value|16
end_define

begin_define
define|#
directive|define
name|MAX_TRIGGER_STATES
value|3
end_define

begin_define
define|#
directive|define
name|TRIGGER_SETS_PER_STATE
value|2
end_define

begin_define
define|#
directive|define
name|MAX_CONSTRAINTS
value|4
end_define

begin_define
define|#
directive|define
name|SEM_FILTER_CID_EN_MASK
value|0x008
end_define

begin_define
define|#
directive|define
name|SEM_FILTER_EID_MASK_EN_MASK
value|0x010
end_define

begin_define
define|#
directive|define
name|SEM_FILTER_EID_RANGE_EN_MASK
value|0x110
end_define

begin_define
define|#
directive|define
name|CHUNK_SIZE_IN_DWORDS
value|64
end_define

begin_define
define|#
directive|define
name|CHUNK_SIZE_IN_BYTES
value|DWORDS_TO_BYTES(CHUNK_SIZE_IN_DWORDS)
end_define

begin_define
define|#
directive|define
name|INT_BUF_NUM_OF_LINES
value|192
end_define

begin_define
define|#
directive|define
name|INT_BUF_LINE_SIZE_IN_DWORDS
value|16
end_define

begin_define
define|#
directive|define
name|INT_BUF_SIZE_IN_DWORDS
value|(INT_BUF_NUM_OF_LINES * INT_BUF_LINE_SIZE_IN_DWORDS)
end_define

begin_define
define|#
directive|define
name|INT_BUF_SIZE_IN_CHUNKS
value|(INT_BUF_SIZE_IN_DWORDS / CHUNK_SIZE_IN_DWORDS)
end_define

begin_define
define|#
directive|define
name|PCI_BUF_LINE_SIZE_IN_DWORDS
value|8
end_define

begin_define
define|#
directive|define
name|PCI_BUF_LINE_SIZE_IN_BYTES
value|DWORDS_TO_BYTES(PCI_BUF_LINE_SIZE_IN_DWORDS)
end_define

begin_define
define|#
directive|define
name|TARGET_EN_MASK_PCI
value|0x3
end_define

begin_define
define|#
directive|define
name|TARGET_EN_MASK_NIG
value|0x4
end_define

begin_define
define|#
directive|define
name|PCI_REQ_CREDIT
value|1
end_define

begin_define
define|#
directive|define
name|PCI_PHYS_ADDR_TYPE
value|0
end_define

begin_define
define|#
directive|define
name|OPAQUE_FID
parameter_list|(
name|pci_func
parameter_list|)
value|((pci_func<< 4) | 0xff00)
end_define

begin_define
define|#
directive|define
name|RESET_REG_UNRESET_OFFSET
value|4
end_define

begin_define
define|#
directive|define
name|PCI_PKT_SIZE_IN_CHUNKS
value|1
end_define

begin_define
define|#
directive|define
name|PCI_PKT_SIZE_IN_BYTES
value|(PCI_PKT_SIZE_IN_CHUNKS * CHUNK_SIZE_IN_BYTES)
end_define

begin_define
define|#
directive|define
name|NIG_PKT_SIZE_IN_CHUNKS
value|4
end_define

begin_define
define|#
directive|define
name|FLUSH_DELAY_MS
value|500
end_define

begin_define
define|#
directive|define
name|STALL_DELAY_MS
value|500
end_define

begin_define
define|#
directive|define
name|SRC_MAC_ADDR_LO16
value|0x0a0b
end_define

begin_define
define|#
directive|define
name|SRC_MAC_ADDR_HI32
value|0x0c0d0e0f
end_define

begin_define
define|#
directive|define
name|ETH_TYPE
value|0x1000
end_define

begin_define
define|#
directive|define
name|STATIC_DEBUG_LINE_DWORDS
value|9
end_define

begin_define
define|#
directive|define
name|NUM_COMMON_GLOBAL_PARAMS
value|8
end_define

begin_define
define|#
directive|define
name|FW_IMG_KUKU
value|0
end_define

begin_define
define|#
directive|define
name|FW_IMG_MAIN
value|1
end_define

begin_define
define|#
directive|define
name|FW_IMG_L2B
value|2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|REG_FIFO_ELEMENT_DWORDS
end_ifndef

begin_define
define|#
directive|define
name|REG_FIFO_ELEMENT_DWORDS
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REG_FIFO_DEPTH_ELEMENTS
value|32
end_define

begin_define
define|#
directive|define
name|REG_FIFO_DEPTH_DWORDS
value|(REG_FIFO_ELEMENT_DWORDS * REG_FIFO_DEPTH_ELEMENTS)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|IGU_FIFO_ELEMENT_DWORDS
end_ifndef

begin_define
define|#
directive|define
name|IGU_FIFO_ELEMENT_DWORDS
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IGU_FIFO_DEPTH_ELEMENTS
value|64
end_define

begin_define
define|#
directive|define
name|IGU_FIFO_DEPTH_DWORDS
value|(IGU_FIFO_ELEMENT_DWORDS * IGU_FIFO_DEPTH_ELEMENTS)
end_define

begin_define
define|#
directive|define
name|SEMI_SYNC_FIFO_POLLING_DELAY_MS
value|5
end_define

begin_define
define|#
directive|define
name|SEMI_SYNC_FIFO_POLLING_COUNT
value|20
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PROTECTION_OVERRIDE_ELEMENT_DWORDS
end_ifndef

begin_define
define|#
directive|define
name|PROTECTION_OVERRIDE_ELEMENT_DWORDS
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PROTECTION_OVERRIDE_DEPTH_ELEMENTS
value|20
end_define

begin_define
define|#
directive|define
name|PROTECTION_OVERRIDE_DEPTH_DWORDS
value|(PROTECTION_OVERRIDE_DEPTH_ELEMENTS 	* PROTECTION_OVERRIDE_ELEMENT_DWORDS)
end_define

begin_define
define|#
directive|define
name|MCP_SPAD_TRACE_OFFSIZE_ADDR
value|(MCP_REG_SCRATCH + 	OFFSETOF(struct static_init, sections[SPAD_SECTION_TRACE]))
end_define

begin_define
define|#
directive|define
name|EMPTY_FW_VERSION_STR
value|"???_???_???_???"
end_define

begin_define
define|#
directive|define
name|EMPTY_FW_IMAGE_STR
value|"???????????????"
end_define

begin_comment
comment|/***************************** Constant Arrays *******************************/
end_comment

begin_struct
struct|struct
name|dbg_array
block|{
specifier|const
name|u32
modifier|*
name|ptr
decl_stmt|;
name|u32
name|size_in_dwords
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Debug arrays */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DBG_BIN_FILE
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|dbg_array
name|s_dbg_arrays
index|[
name|MAX_BIN_DBG_BUFFER_TYPE
index|]
init|=
block|{
block|{
name|OSAL_NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|dbg_array
name|s_dbg_arrays
index|[
name|MAX_BIN_DBG_BUFFER_TYPE
index|]
init|=
block|{
comment|/* BIN_BUF_DBG_MODE_TREE */
block|{
operator|(
specifier|const
name|u32
operator|*
operator|)
name|dbg_modes_tree_buf
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|dbg_modes_tree_buf
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_DUMP_REG */
block|{
name|dump_reg
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|dump_reg
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_DUMP_MEM */
block|{
name|dump_mem
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|dump_mem
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_IDLE_CHK_REGS */
block|{
name|idle_chk_regs
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|idle_chk_regs
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_IDLE_CHK_IMMS */
block|{
name|idle_chk_imms
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|idle_chk_imms
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_IDLE_CHK_RULES */
block|{
name|idle_chk_rules
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|idle_chk_rules
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_IDLE_CHK_PARSING_DATA */
block|{
name|OSAL_NULL
block|,
literal|0
block|}
block|,
comment|/* BIN_BUF_DBG_ATTN_BLOCKS */
block|{
name|attn_block
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|attn_block
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_ATTN_REGSS */
block|{
name|attn_reg
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|attn_reg
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_ATTN_INDEXES */
block|{
name|OSAL_NULL
block|,
literal|0
block|}
block|,
comment|/* BIN_BUF_DBG_ATTN_NAME_OFFSETS */
block|{
name|OSAL_NULL
block|,
literal|0
block|}
block|,
comment|/* BIN_BUF_DBG_BUS_BLOCKS */
block|{
name|dbg_bus_blocks
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|dbg_bus_blocks
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_BUS_LINES */
block|{
name|dbg_bus_lines
block|,
name|OSAL_ARRAY_SIZE
argument_list|(
argument|dbg_bus_lines
argument_list|)
block|}
block|,
comment|/* BIN_BUF_DBG_BUS_BLOCKS_USER_DATA */
block|{
name|OSAL_NULL
block|,
literal|0
block|}
block|,
comment|/* BIN_BUF_DBG_BUS_LINE_NAME_OFFSETS */
block|{
name|OSAL_NULL
block|,
literal|0
block|}
block|,
comment|/* BIN_BUF_DBG_PARSING_STRINGS */
block|{
name|OSAL_NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chip constant definitions array */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|chip_defs
name|s_chip_defs
index|[
name|MAX_CHIP_IDS
index|]
init|=
block|{
block|{
literal|"bb"
block|,
comment|/* ASIC */
block|{
block|{
name|MAX_NUM_PORTS_BB
block|,
name|MAX_NUM_PFS_BB
block|,
name|MAX_NUM_VFS_BB
block|}
block|,
comment|/* EMUL_FULL */
block|{
name|MAX_NUM_PORTS_BB
block|,
name|MAX_NUM_PFS_BB
block|,
name|MAX_NUM_VFS_BB
block|}
block|,
comment|/* EMUL_REDUCED */
block|{
name|MAX_NUM_PORTS_BB
block|,
name|MAX_NUM_PFS_BB
block|,
name|MAX_NUM_VFS_BB
block|}
block|,
comment|/* FPGA */
block|{
name|MAX_NUM_PORTS_BB
block|,
name|MAX_NUM_PFS_BB
block|,
name|MAX_NUM_VFS_BB
block|}
block|}
block|}
block|,
block|{
literal|"k2"
block|,
comment|/* ASIC */
block|{
block|{
name|MAX_NUM_PORTS_K2
block|,
name|MAX_NUM_PFS_K2
block|,
name|MAX_NUM_VFS_K2
block|}
block|,
comment|/* EMUL_FULL */
block|{
name|MAX_NUM_PORTS_K2
block|,
name|MAX_NUM_PFS_K2
block|,
name|MAX_NUM_VFS_K2
block|}
block|,
comment|/* EMUL_REDUCED */
block|{
name|MAX_NUM_PORTS_K2
block|,
name|MAX_NUM_PFS_K2
block|,
name|MAX_NUM_VFS_K2
block|}
block|,
comment|/* FPGA */
block|{
name|MAX_NUM_PORTS_K2
block|,
literal|8
block|,
name|MAX_NUM_VFS_K2
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Storm constant definitions array */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|storm_defs
name|s_storm_defs
index|[]
init|=
block|{
comment|/* Tstorm */
block|{
literal|'T'
block|,
name|BLOCK_TSEM
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCT
block|}
block|,
name|true
block|,
name|TSEM_REG_FAST_MEMORY
block|,
name|TSEM_REG_DBG_FRAME_MODE_BB_K2
block|,
name|TSEM_REG_SLOW_DBG_ACTIVE_BB_K2
block|,
name|TSEM_REG_SLOW_DBG_MODE_BB_K2
block|,
name|TSEM_REG_DBG_MODE1_CFG_BB_K2
block|,
name|TSEM_REG_SYNC_DBG_EMPTY
block|,
name|TSEM_REG_SLOW_DBG_EMPTY_BB_K2
block|,
name|TCM_REG_CTX_RBC_ACCS
block|,
literal|4
block|,
name|TCM_REG_AGG_CON_CTX
block|,
literal|16
block|,
name|TCM_REG_SM_CON_CTX
block|,
literal|2
block|,
name|TCM_REG_AGG_TASK_CTX
block|,
literal|4
block|,
name|TCM_REG_SM_TASK_CTX
block|}
block|,
comment|/* Mstorm */
block|{
literal|'M'
block|,
name|BLOCK_MSEM
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCM
block|}
block|,
name|false
block|,
name|MSEM_REG_FAST_MEMORY
block|,
name|MSEM_REG_DBG_FRAME_MODE_BB_K2
block|,
name|MSEM_REG_SLOW_DBG_ACTIVE_BB_K2
block|,
name|MSEM_REG_SLOW_DBG_MODE_BB_K2
block|,
name|MSEM_REG_DBG_MODE1_CFG_BB_K2
block|,
name|MSEM_REG_SYNC_DBG_EMPTY
block|,
name|MSEM_REG_SLOW_DBG_EMPTY_BB_K2
block|,
name|MCM_REG_CTX_RBC_ACCS
block|,
literal|1
block|,
name|MCM_REG_AGG_CON_CTX
block|,
literal|10
block|,
name|MCM_REG_SM_CON_CTX
block|,
literal|2
block|,
name|MCM_REG_AGG_TASK_CTX
block|,
literal|7
block|,
name|MCM_REG_SM_TASK_CTX
block|}
block|,
comment|/* Ustorm */
block|{
literal|'U'
block|,
name|BLOCK_USEM
block|,
block|{
name|DBG_BUS_CLIENT_RBCU
block|,
name|DBG_BUS_CLIENT_RBCU
block|}
block|,
name|false
block|,
name|USEM_REG_FAST_MEMORY
block|,
name|USEM_REG_DBG_FRAME_MODE_BB_K2
block|,
name|USEM_REG_SLOW_DBG_ACTIVE_BB_K2
block|,
name|USEM_REG_SLOW_DBG_MODE_BB_K2
block|,
name|USEM_REG_DBG_MODE1_CFG_BB_K2
block|,
name|USEM_REG_SYNC_DBG_EMPTY
block|,
name|USEM_REG_SLOW_DBG_EMPTY_BB_K2
block|,
name|UCM_REG_CTX_RBC_ACCS
block|,
literal|2
block|,
name|UCM_REG_AGG_CON_CTX
block|,
literal|13
block|,
name|UCM_REG_SM_CON_CTX
block|,
literal|3
block|,
name|UCM_REG_AGG_TASK_CTX
block|,
literal|3
block|,
name|UCM_REG_SM_TASK_CTX
block|}
block|,
comment|/* Xstorm */
block|{
literal|'X'
block|,
name|BLOCK_XSEM
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCX
block|}
block|,
name|false
block|,
name|XSEM_REG_FAST_MEMORY
block|,
name|XSEM_REG_DBG_FRAME_MODE_BB_K2
block|,
name|XSEM_REG_SLOW_DBG_ACTIVE_BB_K2
block|,
name|XSEM_REG_SLOW_DBG_MODE_BB_K2
block|,
name|XSEM_REG_DBG_MODE1_CFG_BB_K2
block|,
name|XSEM_REG_SYNC_DBG_EMPTY
block|,
name|XSEM_REG_SLOW_DBG_EMPTY_BB_K2
block|,
name|XCM_REG_CTX_RBC_ACCS
block|,
literal|9
block|,
name|XCM_REG_AGG_CON_CTX
block|,
literal|15
block|,
name|XCM_REG_SM_CON_CTX
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ystorm */
block|{
literal|'Y'
block|,
name|BLOCK_YSEM
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCY
block|}
block|,
name|false
block|,
name|YSEM_REG_FAST_MEMORY
block|,
name|YSEM_REG_DBG_FRAME_MODE_BB_K2
block|,
name|YSEM_REG_SLOW_DBG_ACTIVE_BB_K2
block|,
name|YSEM_REG_SLOW_DBG_MODE_BB_K2
block|,
name|YSEM_REG_DBG_MODE1_CFG_BB_K2
block|,
name|YSEM_REG_SYNC_DBG_EMPTY
block|,
name|TSEM_REG_SLOW_DBG_EMPTY_BB_K2
block|,
name|YCM_REG_CTX_RBC_ACCS
block|,
literal|2
block|,
name|YCM_REG_AGG_CON_CTX
block|,
literal|3
block|,
name|YCM_REG_SM_CON_CTX
block|,
literal|2
block|,
name|YCM_REG_AGG_TASK_CTX
block|,
literal|12
block|,
name|YCM_REG_SM_TASK_CTX
block|}
block|,
comment|/* Pstorm */
block|{
literal|'P'
block|,
name|BLOCK_PSEM
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCS
block|}
block|,
name|true
block|,
name|PSEM_REG_FAST_MEMORY
block|,
name|PSEM_REG_DBG_FRAME_MODE_BB_K2
block|,
name|PSEM_REG_SLOW_DBG_ACTIVE_BB_K2
block|,
name|PSEM_REG_SLOW_DBG_MODE_BB_K2
block|,
name|PSEM_REG_DBG_MODE1_CFG_BB_K2
block|,
name|PSEM_REG_SYNC_DBG_EMPTY
block|,
name|PSEM_REG_SLOW_DBG_EMPTY_BB_K2
block|,
name|PCM_REG_CTX_RBC_ACCS
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
name|PCM_REG_SM_CON_CTX
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Block definitions array */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_grc_defs
init|=
block|{
literal|"grc"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCN
block|,
name|DBG_BUS_CLIENT_RBCN
block|}
block|,
name|GRC_REG_DBG_SELECT
block|,
name|GRC_REG_DBG_DWORD_ENABLE
block|,
name|GRC_REG_DBG_SHIFT
block|,
name|GRC_REG_DBG_FORCE_VALID
block|,
name|GRC_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_UA
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_miscs_defs
init|=
block|{
literal|"miscs"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_misc_defs
init|=
block|{
literal|"misc"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_dbu_defs
init|=
block|{
literal|"dbu"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pglue_b_defs
init|=
block|{
literal|"pglue_b"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCH
block|,
name|DBG_BUS_CLIENT_RBCH
block|}
block|,
name|PGLUE_B_REG_DBG_SELECT
block|,
name|PGLUE_B_REG_DBG_DWORD_ENABLE
block|,
name|PGLUE_B_REG_DBG_SHIFT
block|,
name|PGLUE_B_REG_DBG_FORCE_VALID
block|,
name|PGLUE_B_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_cnig_defs
init|=
block|{
literal|"cnig"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCW
block|}
block|,
name|CNIG_REG_DBG_SELECT_K2_E5
block|,
name|CNIG_REG_DBG_DWORD_ENABLE_K2_E5
block|,
name|CNIG_REG_DBG_SHIFT_K2_E5
block|,
name|CNIG_REG_DBG_FORCE_VALID_K2_E5
block|,
name|CNIG_REG_DBG_FORCE_FRAME_K2_E5
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_cpmu_defs
init|=
block|{
literal|"cpmu"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ncsi_defs
init|=
block|{
literal|"ncsi"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCZ
block|,
name|DBG_BUS_CLIENT_RBCZ
block|}
block|,
name|NCSI_REG_DBG_SELECT
block|,
name|NCSI_REG_DBG_DWORD_ENABLE
block|,
name|NCSI_REG_DBG_SHIFT
block|,
name|NCSI_REG_DBG_FORCE_VALID
block|,
name|NCSI_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_opte_defs
init|=
block|{
literal|"opte"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_bmb_defs
init|=
block|{
literal|"bmb"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCZ
block|,
name|DBG_BUS_CLIENT_RBCB
block|}
block|,
name|BMB_REG_DBG_SELECT
block|,
name|BMB_REG_DBG_DWORD_ENABLE
block|,
name|BMB_REG_DBG_SHIFT
block|,
name|BMB_REG_DBG_FORCE_VALID
block|,
name|BMB_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_UA
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pcie_defs
init|=
block|{
literal|"pcie"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCH
block|}
block|,
name|PCIE_REG_DBG_COMMON_SELECT_K2_E5
block|,
name|PCIE_REG_DBG_COMMON_DWORD_ENABLE_K2_E5
block|,
name|PCIE_REG_DBG_COMMON_SHIFT_K2_E5
block|,
name|PCIE_REG_DBG_COMMON_FORCE_VALID_K2_E5
block|,
name|PCIE_REG_DBG_COMMON_FORCE_FRAME_K2_E5
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_mcp_defs
init|=
block|{
literal|"mcp"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_mcp2_defs
init|=
block|{
literal|"mcp2"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCZ
block|,
name|DBG_BUS_CLIENT_RBCZ
block|}
block|,
name|MCP2_REG_DBG_SELECT
block|,
name|MCP2_REG_DBG_DWORD_ENABLE
block|,
name|MCP2_REG_DBG_SHIFT
block|,
name|MCP2_REG_DBG_FORCE_VALID
block|,
name|MCP2_REG_DBG_FORCE_FRAME
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pswhst_defs
init|=
block|{
literal|"pswhst"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|PSWHST_REG_DBG_SELECT
block|,
name|PSWHST_REG_DBG_DWORD_ENABLE
block|,
name|PSWHST_REG_DBG_SHIFT
block|,
name|PSWHST_REG_DBG_FORCE_VALID
block|,
name|PSWHST_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_HV
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pswhst2_defs
init|=
block|{
literal|"pswhst2"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|PSWHST2_REG_DBG_SELECT
block|,
name|PSWHST2_REG_DBG_DWORD_ENABLE
block|,
name|PSWHST2_REG_DBG_SHIFT
block|,
name|PSWHST2_REG_DBG_FORCE_VALID
block|,
name|PSWHST2_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_HV
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pswrd_defs
init|=
block|{
literal|"pswrd"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|PSWRD_REG_DBG_SELECT
block|,
name|PSWRD_REG_DBG_DWORD_ENABLE
block|,
name|PSWRD_REG_DBG_SHIFT
block|,
name|PSWRD_REG_DBG_FORCE_VALID
block|,
name|PSWRD_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_HV
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pswrd2_defs
init|=
block|{
literal|"pswrd2"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|PSWRD2_REG_DBG_SELECT
block|,
name|PSWRD2_REG_DBG_DWORD_ENABLE
block|,
name|PSWRD2_REG_DBG_SHIFT
block|,
name|PSWRD2_REG_DBG_FORCE_VALID
block|,
name|PSWRD2_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_HV
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pswwr_defs
init|=
block|{
literal|"pswwr"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|PSWWR_REG_DBG_SELECT
block|,
name|PSWWR_REG_DBG_DWORD_ENABLE
block|,
name|PSWWR_REG_DBG_SHIFT
block|,
name|PSWWR_REG_DBG_FORCE_VALID
block|,
name|PSWWR_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_HV
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pswwr2_defs
init|=
block|{
literal|"pswwr2"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_HV
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pswrq_defs
init|=
block|{
literal|"pswrq"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|PSWRQ_REG_DBG_SELECT
block|,
name|PSWRQ_REG_DBG_DWORD_ENABLE
block|,
name|PSWRQ_REG_DBG_SHIFT
block|,
name|PSWRQ_REG_DBG_FORCE_VALID
block|,
name|PSWRQ_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_HV
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pswrq2_defs
init|=
block|{
literal|"pswrq2"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|PSWRQ2_REG_DBG_SELECT
block|,
name|PSWRQ2_REG_DBG_DWORD_ENABLE
block|,
name|PSWRQ2_REG_DBG_SHIFT
block|,
name|PSWRQ2_REG_DBG_FORCE_VALID
block|,
name|PSWRQ2_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISC_PL_HV
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pglcs_defs
init|=
block|{
literal|"pglcs"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCH
block|}
block|,
name|PGLCS_REG_DBG_SELECT_K2_E5
block|,
name|PGLCS_REG_DBG_DWORD_ENABLE_K2_E5
block|,
name|PGLCS_REG_DBG_SHIFT_K2_E5
block|,
name|PGLCS_REG_DBG_FORCE_VALID_K2_E5
block|,
name|PGLCS_REG_DBG_FORCE_FRAME_K2_E5
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ptu_defs
init|=
block|{
literal|"ptu"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|PTU_REG_DBG_SELECT
block|,
name|PTU_REG_DBG_DWORD_ENABLE
block|,
name|PTU_REG_DBG_SHIFT
block|,
name|PTU_REG_DBG_FORCE_VALID
block|,
name|PTU_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|20
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_dmae_defs
init|=
block|{
literal|"dmae"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|DMAE_REG_DBG_SELECT
block|,
name|DMAE_REG_DBG_DWORD_ENABLE
block|,
name|DMAE_REG_DBG_SHIFT
block|,
name|DMAE_REG_DBG_FORCE_VALID
block|,
name|DMAE_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|28
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tcm_defs
init|=
block|{
literal|"tcm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_TSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCT
block|}
block|,
name|TCM_REG_DBG_SELECT
block|,
name|TCM_REG_DBG_DWORD_ENABLE
block|,
name|TCM_REG_DBG_SHIFT
block|,
name|TCM_REG_DBG_FORCE_VALID
block|,
name|TCM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_mcm_defs
init|=
block|{
literal|"mcm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_MSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCM
block|}
block|,
name|MCM_REG_DBG_SELECT
block|,
name|MCM_REG_DBG_DWORD_ENABLE
block|,
name|MCM_REG_DBG_SHIFT
block|,
name|MCM_REG_DBG_FORCE_VALID
block|,
name|MCM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ucm_defs
init|=
block|{
literal|"ucm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_USTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCU
block|,
name|DBG_BUS_CLIENT_RBCU
block|}
block|,
name|UCM_REG_DBG_SELECT
block|,
name|UCM_REG_DBG_DWORD_ENABLE
block|,
name|UCM_REG_DBG_SHIFT
block|,
name|UCM_REG_DBG_FORCE_VALID
block|,
name|UCM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_xcm_defs
init|=
block|{
literal|"xcm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_XSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCX
block|}
block|,
name|XCM_REG_DBG_SELECT
block|,
name|XCM_REG_DBG_DWORD_ENABLE
block|,
name|XCM_REG_DBG_SHIFT
block|,
name|XCM_REG_DBG_FORCE_VALID
block|,
name|XCM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|19
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ycm_defs
init|=
block|{
literal|"ycm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_YSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCY
block|}
block|,
name|YCM_REG_DBG_SELECT
block|,
name|YCM_REG_DBG_DWORD_ENABLE
block|,
name|YCM_REG_DBG_SHIFT
block|,
name|YCM_REG_DBG_FORCE_VALID
block|,
name|YCM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pcm_defs
init|=
block|{
literal|"pcm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_PSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCS
block|}
block|,
name|PCM_REG_DBG_SELECT
block|,
name|PCM_REG_DBG_DWORD_ENABLE
block|,
name|PCM_REG_DBG_SHIFT
block|,
name|PCM_REG_DBG_FORCE_VALID
block|,
name|PCM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_qm_defs
init|=
block|{
literal|"qm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCQ
block|}
block|,
name|QM_REG_DBG_SELECT
block|,
name|QM_REG_DBG_DWORD_ENABLE
block|,
name|QM_REG_DBG_SHIFT
block|,
name|QM_REG_DBG_FORCE_VALID
block|,
name|QM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tm_defs
init|=
block|{
literal|"tm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCS
block|}
block|,
name|TM_REG_DBG_SELECT
block|,
name|TM_REG_DBG_DWORD_ENABLE
block|,
name|TM_REG_DBG_SHIFT
block|,
name|TM_REG_DBG_FORCE_VALID
block|,
name|TM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|17
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_dorq_defs
init|=
block|{
literal|"dorq"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCY
block|}
block|,
name|DORQ_REG_DBG_SELECT
block|,
name|DORQ_REG_DBG_DWORD_ENABLE
block|,
name|DORQ_REG_DBG_SHIFT
block|,
name|DORQ_REG_DBG_FORCE_VALID
block|,
name|DORQ_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|18
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_brb_defs
init|=
block|{
literal|"brb"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCR
block|,
name|DBG_BUS_CLIENT_RBCR
block|}
block|,
name|BRB_REG_DBG_SELECT
block|,
name|BRB_REG_DBG_DWORD_ENABLE
block|,
name|BRB_REG_DBG_SHIFT
block|,
name|BRB_REG_DBG_FORCE_VALID
block|,
name|BRB_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_src_defs
init|=
block|{
literal|"src"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCF
block|,
name|DBG_BUS_CLIENT_RBCF
block|}
block|,
name|SRC_REG_DBG_SELECT
block|,
name|SRC_REG_DBG_DWORD_ENABLE
block|,
name|SRC_REG_DBG_SHIFT
block|,
name|SRC_REG_DBG_FORCE_VALID
block|,
name|SRC_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_prs_defs
init|=
block|{
literal|"prs"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCR
block|,
name|DBG_BUS_CLIENT_RBCR
block|}
block|,
name|PRS_REG_DBG_SELECT
block|,
name|PRS_REG_DBG_DWORD_ENABLE
block|,
name|PRS_REG_DBG_SHIFT
block|,
name|PRS_REG_DBG_FORCE_VALID
block|,
name|PRS_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tsdm_defs
init|=
block|{
literal|"tsdm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_TSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCT
block|}
block|,
name|TSDM_REG_DBG_SELECT
block|,
name|TSDM_REG_DBG_DWORD_ENABLE
block|,
name|TSDM_REG_DBG_SHIFT
block|,
name|TSDM_REG_DBG_FORCE_VALID
block|,
name|TSDM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_msdm_defs
init|=
block|{
literal|"msdm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_MSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCM
block|}
block|,
name|MSDM_REG_DBG_SELECT
block|,
name|MSDM_REG_DBG_DWORD_ENABLE
block|,
name|MSDM_REG_DBG_SHIFT
block|,
name|MSDM_REG_DBG_FORCE_VALID
block|,
name|MSDM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|6
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_usdm_defs
init|=
block|{
literal|"usdm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_USTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCU
block|,
name|DBG_BUS_CLIENT_RBCU
block|}
block|,
name|USDM_REG_DBG_SELECT
block|,
name|USDM_REG_DBG_DWORD_ENABLE
block|,
name|USDM_REG_DBG_SHIFT
block|,
name|USDM_REG_DBG_FORCE_VALID
block|,
name|USDM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_xsdm_defs
init|=
block|{
literal|"xsdm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_XSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCX
block|}
block|,
name|XSDM_REG_DBG_SELECT
block|,
name|XSDM_REG_DBG_DWORD_ENABLE
block|,
name|XSDM_REG_DBG_SHIFT
block|,
name|XSDM_REG_DBG_FORCE_VALID
block|,
name|XSDM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|20
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ysdm_defs
init|=
block|{
literal|"ysdm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_YSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCY
block|}
block|,
name|YSDM_REG_DBG_SELECT
block|,
name|YSDM_REG_DBG_DWORD_ENABLE
block|,
name|YSDM_REG_DBG_SHIFT
block|,
name|YSDM_REG_DBG_FORCE_VALID
block|,
name|YSDM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_psdm_defs
init|=
block|{
literal|"psdm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_PSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCS
block|}
block|,
name|PSDM_REG_DBG_SELECT
block|,
name|PSDM_REG_DBG_DWORD_ENABLE
block|,
name|PSDM_REG_DBG_SHIFT
block|,
name|PSDM_REG_DBG_FORCE_VALID
block|,
name|PSDM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tsem_defs
init|=
block|{
literal|"tsem"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_TSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCT
block|}
block|,
name|TSEM_REG_DBG_SELECT
block|,
name|TSEM_REG_DBG_DWORD_ENABLE
block|,
name|TSEM_REG_DBG_SHIFT
block|,
name|TSEM_REG_DBG_FORCE_VALID
block|,
name|TSEM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_msem_defs
init|=
block|{
literal|"msem"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_MSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCM
block|}
block|,
name|MSEM_REG_DBG_SELECT
block|,
name|MSEM_REG_DBG_DWORD_ENABLE
block|,
name|MSEM_REG_DBG_SHIFT
block|,
name|MSEM_REG_DBG_FORCE_VALID
block|,
name|MSEM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_usem_defs
init|=
block|{
literal|"usem"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_USTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCU
block|,
name|DBG_BUS_CLIENT_RBCU
block|}
block|,
name|USEM_REG_DBG_SELECT
block|,
name|USEM_REG_DBG_DWORD_ENABLE
block|,
name|USEM_REG_DBG_SHIFT
block|,
name|USEM_REG_DBG_FORCE_VALID
block|,
name|USEM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_xsem_defs
init|=
block|{
literal|"xsem"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_XSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCX
block|}
block|,
name|XSEM_REG_DBG_SELECT
block|,
name|XSEM_REG_DBG_DWORD_ENABLE
block|,
name|XSEM_REG_DBG_SHIFT
block|,
name|XSEM_REG_DBG_FORCE_VALID
block|,
name|XSEM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|21
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ysem_defs
init|=
block|{
literal|"ysem"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_YSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCY
block|}
block|,
name|YSEM_REG_DBG_SELECT
block|,
name|YSEM_REG_DBG_DWORD_ENABLE
block|,
name|YSEM_REG_DBG_SHIFT
block|,
name|YSEM_REG_DBG_FORCE_VALID
block|,
name|YSEM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|11
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_psem_defs
init|=
block|{
literal|"psem"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|true
block|,
name|DBG_PSTORM_ID
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCS
block|}
block|,
name|PSEM_REG_DBG_SELECT
block|,
name|PSEM_REG_DBG_DWORD_ENABLE
block|,
name|PSEM_REG_DBG_SHIFT
block|,
name|PSEM_REG_DBG_FORCE_VALID
block|,
name|PSEM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_rss_defs
init|=
block|{
literal|"rss"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCT
block|}
block|,
name|RSS_REG_DBG_SELECT
block|,
name|RSS_REG_DBG_DWORD_ENABLE
block|,
name|RSS_REG_DBG_SHIFT
block|,
name|RSS_REG_DBG_FORCE_VALID
block|,
name|RSS_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|18
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tmld_defs
init|=
block|{
literal|"tmld"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCM
block|}
block|,
name|TMLD_REG_DBG_SELECT
block|,
name|TMLD_REG_DBG_DWORD_ENABLE
block|,
name|TMLD_REG_DBG_SHIFT
block|,
name|TMLD_REG_DBG_FORCE_VALID
block|,
name|TMLD_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_muld_defs
init|=
block|{
literal|"muld"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCU
block|,
name|DBG_BUS_CLIENT_RBCU
block|}
block|,
name|MULD_REG_DBG_SELECT
block|,
name|MULD_REG_DBG_DWORD_ENABLE
block|,
name|MULD_REG_DBG_SHIFT
block|,
name|MULD_REG_DBG_FORCE_VALID
block|,
name|MULD_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|14
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_yuld_defs
init|=
block|{
literal|"yuld"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCU
block|,
name|DBG_BUS_CLIENT_RBCU
block|}
block|,
name|YULD_REG_DBG_SELECT_BB_K2
block|,
name|YULD_REG_DBG_DWORD_ENABLE_BB_K2
block|,
name|YULD_REG_DBG_SHIFT_BB_K2
block|,
name|YULD_REG_DBG_FORCE_VALID_BB_K2
block|,
name|YULD_REG_DBG_FORCE_FRAME_BB_K2
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_xyld_defs
init|=
block|{
literal|"xyld"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCX
block|,
name|DBG_BUS_CLIENT_RBCX
block|}
block|,
name|XYLD_REG_DBG_SELECT
block|,
name|XYLD_REG_DBG_DWORD_ENABLE
block|,
name|XYLD_REG_DBG_SHIFT
block|,
name|XYLD_REG_DBG_FORCE_VALID
block|,
name|XYLD_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_prm_defs
init|=
block|{
literal|"prm"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCM
block|}
block|,
name|PRM_REG_DBG_SELECT
block|,
name|PRM_REG_DBG_DWORD_ENABLE
block|,
name|PRM_REG_DBG_SHIFT
block|,
name|PRM_REG_DBG_FORCE_VALID
block|,
name|PRM_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|21
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pbf_pb1_defs
init|=
block|{
literal|"pbf_pb1"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCV
block|}
block|,
name|PBF_PB1_REG_DBG_SELECT
block|,
name|PBF_PB1_REG_DBG_DWORD_ENABLE
block|,
name|PBF_PB1_REG_DBG_SHIFT
block|,
name|PBF_PB1_REG_DBG_FORCE_VALID
block|,
name|PBF_PB1_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|11
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pbf_pb2_defs
init|=
block|{
literal|"pbf_pb2"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCV
block|}
block|,
name|PBF_PB2_REG_DBG_SELECT
block|,
name|PBF_PB2_REG_DBG_DWORD_ENABLE
block|,
name|PBF_PB2_REG_DBG_SHIFT
block|,
name|PBF_PB2_REG_DBG_FORCE_VALID
block|,
name|PBF_PB2_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_rpb_defs
init|=
block|{
literal|"rpb"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCM
block|}
block|,
name|RPB_REG_DBG_SELECT
block|,
name|RPB_REG_DBG_DWORD_ENABLE
block|,
name|RPB_REG_DBG_SHIFT
block|,
name|RPB_REG_DBG_FORCE_VALID
block|,
name|RPB_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_btb_defs
init|=
block|{
literal|"btb"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCR
block|,
name|DBG_BUS_CLIENT_RBCV
block|}
block|,
name|BTB_REG_DBG_SELECT
block|,
name|BTB_REG_DBG_DWORD_ENABLE
block|,
name|BTB_REG_DBG_SHIFT
block|,
name|BTB_REG_DBG_FORCE_VALID
block|,
name|BTB_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_pbf_defs
init|=
block|{
literal|"pbf"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCV
block|}
block|,
name|PBF_REG_DBG_SELECT
block|,
name|PBF_REG_DBG_DWORD_ENABLE
block|,
name|PBF_REG_DBG_SHIFT
block|,
name|PBF_REG_DBG_FORCE_VALID
block|,
name|PBF_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_rdif_defs
init|=
block|{
literal|"rdif"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCT
block|,
name|DBG_BUS_CLIENT_RBCM
block|}
block|,
name|RDIF_REG_DBG_SELECT
block|,
name|RDIF_REG_DBG_DWORD_ENABLE
block|,
name|RDIF_REG_DBG_SHIFT
block|,
name|RDIF_REG_DBG_FORCE_VALID
block|,
name|RDIF_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tdif_defs
init|=
block|{
literal|"tdif"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCS
block|,
name|DBG_BUS_CLIENT_RBCS
block|}
block|,
name|TDIF_REG_DBG_SELECT
block|,
name|TDIF_REG_DBG_DWORD_ENABLE
block|,
name|TDIF_REG_DBG_SHIFT
block|,
name|TDIF_REG_DBG_FORCE_VALID
block|,
name|TDIF_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|17
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_cdu_defs
init|=
block|{
literal|"cdu"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCF
block|,
name|DBG_BUS_CLIENT_RBCF
block|}
block|,
name|CDU_REG_DBG_SELECT
block|,
name|CDU_REG_DBG_DWORD_ENABLE
block|,
name|CDU_REG_DBG_SHIFT
block|,
name|CDU_REG_DBG_FORCE_VALID
block|,
name|CDU_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|23
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ccfc_defs
init|=
block|{
literal|"ccfc"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCF
block|,
name|DBG_BUS_CLIENT_RBCF
block|}
block|,
name|CCFC_REG_DBG_SELECT
block|,
name|CCFC_REG_DBG_DWORD_ENABLE
block|,
name|CCFC_REG_DBG_SHIFT
block|,
name|CCFC_REG_DBG_FORCE_VALID
block|,
name|CCFC_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|24
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tcfc_defs
init|=
block|{
literal|"tcfc"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCF
block|,
name|DBG_BUS_CLIENT_RBCF
block|}
block|,
name|TCFC_REG_DBG_SELECT
block|,
name|TCFC_REG_DBG_DWORD_ENABLE
block|,
name|TCFC_REG_DBG_SHIFT
block|,
name|TCFC_REG_DBG_FORCE_VALID
block|,
name|TCFC_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|25
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_igu_defs
init|=
block|{
literal|"igu"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|IGU_REG_DBG_SELECT
block|,
name|IGU_REG_DBG_DWORD_ENABLE
block|,
name|IGU_REG_DBG_SHIFT
block|,
name|IGU_REG_DBG_FORCE_VALID
block|,
name|IGU_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_1
block|,
literal|27
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_cau_defs
init|=
block|{
literal|"cau"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCP
block|,
name|DBG_BUS_CLIENT_RBCP
block|}
block|,
name|CAU_REG_DBG_SELECT
block|,
name|CAU_REG_DBG_DWORD_ENABLE
block|,
name|CAU_REG_DBG_SHIFT
block|,
name|CAU_REG_DBG_FORCE_VALID
block|,
name|CAU_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VMAIN_2
block|,
literal|19
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_umac_defs
init|=
block|{
literal|"umac"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCZ
block|}
block|,
name|UMAC_REG_DBG_SELECT_K2_E5
block|,
name|UMAC_REG_DBG_DWORD_ENABLE_K2_E5
block|,
name|UMAC_REG_DBG_SHIFT_K2_E5
block|,
name|UMAC_REG_DBG_FORCE_VALID_K2_E5
block|,
name|UMAC_REG_DBG_FORCE_FRAME_K2_E5
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|6
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_xmac_defs
init|=
block|{
literal|"xmac"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_dbg_defs
init|=
block|{
literal|"dbg"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VAUX
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_nig_defs
init|=
block|{
literal|"nig"
block|,
block|{
name|true
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|DBG_BUS_CLIENT_RBCN
block|,
name|DBG_BUS_CLIENT_RBCN
block|}
block|,
name|NIG_REG_DBG_SELECT
block|,
name|NIG_REG_DBG_DWORD_ENABLE
block|,
name|NIG_REG_DBG_SHIFT
block|,
name|NIG_REG_DBG_FORCE_VALID
block|,
name|NIG_REG_DBG_FORCE_FRAME
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VAUX
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_wol_defs
init|=
block|{
literal|"wol"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCZ
block|}
block|,
name|WOL_REG_DBG_SELECT_K2_E5
block|,
name|WOL_REG_DBG_DWORD_ENABLE_K2_E5
block|,
name|WOL_REG_DBG_SHIFT_K2_E5
block|,
name|WOL_REG_DBG_FORCE_VALID_K2_E5
block|,
name|WOL_REG_DBG_FORCE_FRAME_K2_E5
block|,
name|true
block|,
name|true
block|,
name|DBG_RESET_REG_MISC_PL_PDA_VAUX
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_bmbn_defs
init|=
block|{
literal|"bmbn"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCB
block|}
block|,
name|BMBN_REG_DBG_SELECT_K2_E5
block|,
name|BMBN_REG_DBG_DWORD_ENABLE_K2_E5
block|,
name|BMBN_REG_DBG_SHIFT_K2_E5
block|,
name|BMBN_REG_DBG_FORCE_VALID_K2_E5
block|,
name|BMBN_REG_DBG_FORCE_FRAME_K2_E5
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ipc_defs
init|=
block|{
literal|"ipc"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_UA
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_nwm_defs
init|=
block|{
literal|"nwm"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCW
block|}
block|,
name|NWM_REG_DBG_SELECT_K2_E5
block|,
name|NWM_REG_DBG_DWORD_ENABLE_K2_E5
block|,
name|NWM_REG_DBG_SHIFT_K2_E5
block|,
name|NWM_REG_DBG_FORCE_VALID_K2_E5
block|,
name|NWM_REG_DBG_FORCE_FRAME_K2_E5
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV_2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_nws_defs
init|=
block|{
literal|"nws"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCW
block|}
block|,
name|NWS_REG_DBG_SELECT_K2_E5
block|,
name|NWS_REG_DBG_DWORD_ENABLE_K2_E5
block|,
name|NWS_REG_DBG_SHIFT_K2_E5
block|,
name|NWS_REG_DBG_FORCE_VALID_K2_E5
block|,
name|NWS_REG_DBG_FORCE_FRAME_K2_E5
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ms_defs
init|=
block|{
literal|"ms"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCZ
block|}
block|,
name|MS_REG_DBG_SELECT_K2_E5
block|,
name|MS_REG_DBG_DWORD_ENABLE_K2_E5
block|,
name|MS_REG_DBG_SHIFT_K2_E5
block|,
name|MS_REG_DBG_FORCE_VALID_K2_E5
block|,
name|MS_REG_DBG_FORCE_FRAME_K2_E5
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_phy_pcie_defs
init|=
block|{
literal|"phy_pcie"
block|,
block|{
name|false
block|,
name|true
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|DBG_BUS_CLIENT_RBCH
block|}
block|,
name|PCIE_REG_DBG_COMMON_SELECT_K2_E5
block|,
name|PCIE_REG_DBG_COMMON_DWORD_ENABLE_K2_E5
block|,
name|PCIE_REG_DBG_COMMON_SHIFT_K2_E5
block|,
name|PCIE_REG_DBG_COMMON_FORCE_VALID_K2_E5
block|,
name|PCIE_REG_DBG_COMMON_FORCE_FRAME_K2_E5
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_led_defs
init|=
block|{
literal|"led"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_HV
block|,
literal|14
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_avs_wrap_defs
init|=
block|{
literal|"avs_wrap"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|DBG_RESET_REG_MISCS_PL_UA
block|,
literal|11
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_rgfs_defs
init|=
block|{
literal|"rgfs"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_rgsrc_defs
init|=
block|{
literal|"rgsrc"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tgfs_defs
init|=
block|{
literal|"tgfs"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_tgsrc_defs
init|=
block|{
literal|"tgsrc"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ptld_defs
init|=
block|{
literal|"ptld"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_ypld_defs
init|=
block|{
literal|"ypld"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_misc_aeu_defs
init|=
block|{
literal|"misc_aeu"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
name|block_bar0_map_defs
init|=
block|{
literal|"bar0_map"
block|,
block|{
name|false
block|,
name|false
block|}
block|,
name|false
block|,
literal|0
block|,
block|{
name|MAX_DBG_BUS_CLIENTS
block|,
name|MAX_DBG_BUS_CLIENTS
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|MAX_DBG_RESET_REGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block_defs
modifier|*
name|s_block_defs
index|[
name|MAX_BLOCK_ID
index|]
init|=
block|{
operator|&
name|block_grc_defs
block|,
operator|&
name|block_miscs_defs
block|,
operator|&
name|block_misc_defs
block|,
operator|&
name|block_dbu_defs
block|,
operator|&
name|block_pglue_b_defs
block|,
operator|&
name|block_cnig_defs
block|,
operator|&
name|block_cpmu_defs
block|,
operator|&
name|block_ncsi_defs
block|,
operator|&
name|block_opte_defs
block|,
operator|&
name|block_bmb_defs
block|,
operator|&
name|block_pcie_defs
block|,
operator|&
name|block_mcp_defs
block|,
operator|&
name|block_mcp2_defs
block|,
operator|&
name|block_pswhst_defs
block|,
operator|&
name|block_pswhst2_defs
block|,
operator|&
name|block_pswrd_defs
block|,
operator|&
name|block_pswrd2_defs
block|,
operator|&
name|block_pswwr_defs
block|,
operator|&
name|block_pswwr2_defs
block|,
operator|&
name|block_pswrq_defs
block|,
operator|&
name|block_pswrq2_defs
block|,
operator|&
name|block_pglcs_defs
block|,
operator|&
name|block_dmae_defs
block|,
operator|&
name|block_ptu_defs
block|,
operator|&
name|block_tcm_defs
block|,
operator|&
name|block_mcm_defs
block|,
operator|&
name|block_ucm_defs
block|,
operator|&
name|block_xcm_defs
block|,
operator|&
name|block_ycm_defs
block|,
operator|&
name|block_pcm_defs
block|,
operator|&
name|block_qm_defs
block|,
operator|&
name|block_tm_defs
block|,
operator|&
name|block_dorq_defs
block|,
operator|&
name|block_brb_defs
block|,
operator|&
name|block_src_defs
block|,
operator|&
name|block_prs_defs
block|,
operator|&
name|block_tsdm_defs
block|,
operator|&
name|block_msdm_defs
block|,
operator|&
name|block_usdm_defs
block|,
operator|&
name|block_xsdm_defs
block|,
operator|&
name|block_ysdm_defs
block|,
operator|&
name|block_psdm_defs
block|,
operator|&
name|block_tsem_defs
block|,
operator|&
name|block_msem_defs
block|,
operator|&
name|block_usem_defs
block|,
operator|&
name|block_xsem_defs
block|,
operator|&
name|block_ysem_defs
block|,
operator|&
name|block_psem_defs
block|,
operator|&
name|block_rss_defs
block|,
operator|&
name|block_tmld_defs
block|,
operator|&
name|block_muld_defs
block|,
operator|&
name|block_yuld_defs
block|,
operator|&
name|block_xyld_defs
block|,
operator|&
name|block_ptld_defs
block|,
operator|&
name|block_ypld_defs
block|,
operator|&
name|block_prm_defs
block|,
operator|&
name|block_pbf_pb1_defs
block|,
operator|&
name|block_pbf_pb2_defs
block|,
operator|&
name|block_rpb_defs
block|,
operator|&
name|block_btb_defs
block|,
operator|&
name|block_pbf_defs
block|,
operator|&
name|block_rdif_defs
block|,
operator|&
name|block_tdif_defs
block|,
operator|&
name|block_cdu_defs
block|,
operator|&
name|block_ccfc_defs
block|,
operator|&
name|block_tcfc_defs
block|,
operator|&
name|block_igu_defs
block|,
operator|&
name|block_cau_defs
block|,
operator|&
name|block_rgfs_defs
block|,
operator|&
name|block_rgsrc_defs
block|,
operator|&
name|block_tgfs_defs
block|,
operator|&
name|block_tgsrc_defs
block|,
operator|&
name|block_umac_defs
block|,
operator|&
name|block_xmac_defs
block|,
operator|&
name|block_dbg_defs
block|,
operator|&
name|block_nig_defs
block|,
operator|&
name|block_wol_defs
block|,
operator|&
name|block_bmbn_defs
block|,
operator|&
name|block_ipc_defs
block|,
operator|&
name|block_nwm_defs
block|,
operator|&
name|block_nws_defs
block|,
operator|&
name|block_ms_defs
block|,
operator|&
name|block_phy_pcie_defs
block|,
operator|&
name|block_led_defs
block|,
operator|&
name|block_avs_wrap_defs
block|,
operator|&
name|block_misc_aeu_defs
block|,
operator|&
name|block_bar0_map_defs
block|,  }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constraint operation types */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dbg_bus_constraint_op_defs
name|s_constraint_op_defs
index|[]
init|=
block|{
comment|/* DBG_BUS_CONSTRAINT_OP_EQ */
block|{
literal|0
block|,
name|false
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_NE */
block|{
literal|5
block|,
name|false
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_LT */
block|{
literal|1
block|,
name|false
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_LTC */
block|{
literal|1
block|,
name|true
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_LE */
block|{
literal|2
block|,
name|false
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_LEC */
block|{
literal|2
block|,
name|true
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_GT */
block|{
literal|4
block|,
name|false
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_GTC */
block|{
literal|4
block|,
name|true
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_GE */
block|{
literal|3
block|,
name|false
block|}
block|,
comment|/* DBG_BUS_CONSTRAINT_OP_GEC */
block|{
literal|3
block|,
name|true
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_dbg_target_names
index|[]
init|=
block|{
comment|/* DBG_BUS_TARGET_ID_INT_BUF */
literal|"int-buf"
block|,
comment|/* DBG_BUS_TARGET_ID_NIG */
literal|"nw"
block|,
comment|/* DBG_BUS_TARGET_ID_PCI */
literal|"pci-buf"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|storm_mode_defs
name|s_storm_mode_defs
index|[]
init|=
block|{
comment|/* DBG_BUS_STORM_MODE_PRINTF */
block|{
literal|"printf"
block|,
name|true
block|,
literal|0
block|}
block|,
comment|/* DBG_BUS_STORM_MODE_PRAM_ADDR */
block|{
literal|"pram_addr"
block|,
name|true
block|,
literal|1
block|}
block|,
comment|/* DBG_BUS_STORM_MODE_DRA_RW */
block|{
literal|"dra_rw"
block|,
name|true
block|,
literal|2
block|}
block|,
comment|/* DBG_BUS_STORM_MODE_DRA_W */
block|{
literal|"dra_w"
block|,
name|true
block|,
literal|3
block|}
block|,
comment|/* DBG_BUS_STORM_MODE_LD_ST_ADDR */
block|{
literal|"ld_st_addr"
block|,
name|true
block|,
literal|4
block|}
block|,
comment|/* DBG_BUS_STORM_MODE_DRA_FSM */
block|{
literal|"dra_fsm"
block|,
name|true
block|,
literal|5
block|}
block|,
comment|/* DBG_BUS_STORM_MODE_RH */
block|{
literal|"rh"
block|,
name|true
block|,
literal|6
block|}
block|,
comment|/* DBG_BUS_STORM_MODE_FOC */
block|{
literal|"foc"
block|,
name|false
block|,
literal|1
block|}
block|,
comment|/* DBG_BUS_STORM_MODE_EXT_STORE */
block|{
literal|"ext_store"
block|,
name|false
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|platform_defs
name|s_platform_defs
index|[]
init|=
block|{
comment|/* PLATFORM_ASIC */
block|{
literal|"asic"
block|,
literal|1
block|}
block|,
comment|/* PLATFORM_EMUL_FULL */
block|{
literal|"emul_full"
block|,
literal|2000
block|}
block|,
comment|/* PLATFORM_EMUL_REDUCED */
block|{
literal|"emul_reduced"
block|,
literal|2000
block|}
block|,
comment|/* PLATFORM_FPGA */
block|{
literal|"fpga"
block|,
literal|200
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|grc_param_defs
name|s_grc_param_defs
index|[]
init|=
block|{
comment|/* DBG_GRC_PARAM_DUMP_TSTORM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_MSTORM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_USTORM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_XSTORM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_YSTORM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_PSTORM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_REGS */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_RAM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_PBUF */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_IOR */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_VFC */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_CM_CTX */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_ILT */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_RSS */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_CAU */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_QM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_MCP */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_RESERVED */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_CFC */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_IGU */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_BRB */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_BTB */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_BMB */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_NIG */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_MULD */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_PRS */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_DMAE */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_TM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_SDM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_DIF */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_STATIC */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_UNSTALL */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DBG_GRC_PARAM_NUM_LCIDS */
block|{
block|{
name|MAX_LCIDS
block|,
name|MAX_LCIDS
block|}
block|,
literal|1
block|,
name|MAX_LCIDS
block|,
name|false
block|,
name|MAX_LCIDS
block|,
name|MAX_LCIDS
block|}
block|,
comment|/* DBG_GRC_PARAM_NUM_LTIDS */
block|{
block|{
name|MAX_LTIDS
block|,
name|MAX_LTIDS
block|}
block|,
literal|1
block|,
name|MAX_LTIDS
block|,
name|false
block|,
name|MAX_LTIDS
block|,
name|MAX_LTIDS
block|}
block|,
comment|/* DBG_GRC_PARAM_EXCLUDE_ALL */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|true
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DBG_GRC_PARAM_CRASH */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|true
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DBG_GRC_PARAM_PARITY_SAFE */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_CM */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_DUMP_PHY */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DBG_GRC_PARAM_NO_MCP */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DBG_GRC_PARAM_NO_FW_VER */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rss_mem_defs
name|s_rss_mem_defs
index|[]
init|=
block|{
block|{
literal|"rss_mem_cid"
block|,
literal|"rss_cid"
block|,
literal|0
block|,
block|{
literal|256
block|,
literal|320
block|}
block|,
block|{
literal|32
block|,
literal|32
block|}
block|}
block|,
block|{
literal|"rss_mem_key_msb"
block|,
literal|"rss_key"
block|,
literal|1024
block|,
block|{
literal|128
block|,
literal|208
block|}
block|,
block|{
literal|256
block|,
literal|256
block|}
block|}
block|,
block|{
literal|"rss_mem_key_lsb"
block|,
literal|"rss_key"
block|,
literal|2048
block|,
block|{
literal|128
block|,
literal|208
block|}
block|,
block|{
literal|64
block|,
literal|64
block|}
block|}
block|,
block|{
literal|"rss_mem_info"
block|,
literal|"rss_info"
block|,
literal|3072
block|,
block|{
literal|128
block|,
literal|208
block|}
block|,
block|{
literal|16
block|,
literal|16
block|}
block|}
block|,
block|{
literal|"rss_mem_ind"
block|,
literal|"rss_ind"
block|,
literal|4096
block|,
block|{
literal|16384
block|,
literal|26624
block|}
block|,
block|{
literal|16
block|,
literal|16
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vfc_ram_defs
name|s_vfc_ram_defs
index|[]
init|=
block|{
block|{
literal|"vfc_ram_tt1"
block|,
literal|"vfc_ram"
block|,
literal|0
block|,
literal|512
block|}
block|,
block|{
literal|"vfc_ram_mtt2"
block|,
literal|"vfc_ram"
block|,
literal|512
block|,
literal|128
block|}
block|,
block|{
literal|"vfc_ram_stt2"
block|,
literal|"vfc_ram"
block|,
literal|640
block|,
literal|32
block|}
block|,
block|{
literal|"vfc_ram_ro_vect"
block|,
literal|"vfc_ram"
block|,
literal|672
block|,
literal|32
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|big_ram_defs
name|s_big_ram_defs
index|[]
init|=
block|{
block|{
literal|"BRB"
block|,
name|MEM_GROUP_BRB_MEM
block|,
name|MEM_GROUP_BRB_RAM
block|,
name|DBG_GRC_PARAM_DUMP_BRB
block|,
name|BRB_REG_BIG_RAM_ADDRESS
block|,
name|BRB_REG_BIG_RAM_DATA
block|,
block|{
literal|4800
block|,
literal|5632
block|}
block|}
block|,
block|{
literal|"BTB"
block|,
name|MEM_GROUP_BTB_MEM
block|,
name|MEM_GROUP_BTB_RAM
block|,
name|DBG_GRC_PARAM_DUMP_BTB
block|,
name|BTB_REG_BIG_RAM_ADDRESS
block|,
name|BTB_REG_BIG_RAM_DATA
block|,
block|{
literal|2880
block|,
literal|3680
block|}
block|}
block|,
block|{
literal|"BMB"
block|,
name|MEM_GROUP_BMB_MEM
block|,
name|MEM_GROUP_BMB_RAM
block|,
name|DBG_GRC_PARAM_DUMP_BMB
block|,
name|BMB_REG_BIG_RAM_ADDRESS
block|,
name|BMB_REG_BIG_RAM_DATA
block|,
block|{
literal|1152
block|,
literal|1152
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|reset_reg_defs
name|s_reset_regs_defs
index|[]
init|=
block|{
comment|/* DBG_RESET_REG_MISCS_PL_UA */
block|{
name|MISCS_REG_RESET_PL_UA
block|,
literal|0x0
block|,
block|{
name|true
block|,
name|true
block|}
block|}
block|,
comment|/* DBG_RESET_REG_MISCS_PL_HV */
block|{
name|MISCS_REG_RESET_PL_HV
block|,
literal|0x0
block|,
block|{
name|true
block|,
name|true
block|}
block|}
block|,
comment|/* DBG_RESET_REG_MISCS_PL_HV_2 */
block|{
name|MISCS_REG_RESET_PL_HV_2_K2_E5
block|,
literal|0x0
block|,
block|{
name|false
block|,
name|true
block|}
block|}
block|,
comment|/* DBG_RESET_REG_MISC_PL_UA */
block|{
name|MISC_REG_RESET_PL_UA
block|,
literal|0x0
block|,
block|{
name|true
block|,
name|true
block|}
block|}
block|,
comment|/* DBG_RESET_REG_MISC_PL_HV */
block|{
name|MISC_REG_RESET_PL_HV
block|,
literal|0x0
block|,
block|{
name|true
block|,
name|true
block|}
block|}
block|,
comment|/* DBG_RESET_REG_MISC_PL_PDA_VMAIN_1 */
block|{
name|MISC_REG_RESET_PL_PDA_VMAIN_1
block|,
literal|0x4404040
block|,
block|{
name|true
block|,
name|true
block|}
block|}
block|,
comment|/* DBG_RESET_REG_MISC_PL_PDA_VMAIN_2 */
block|{
name|MISC_REG_RESET_PL_PDA_VMAIN_2
block|,
literal|0x7c00007
block|,
block|{
name|true
block|,
name|true
block|}
block|}
block|,
comment|/* DBG_RESET_REG_MISC_PL_PDA_VAUX */
block|{
name|MISC_REG_RESET_PL_PDA_VAUX
block|,
literal|0x2
block|,
block|{
name|true
block|,
name|true
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|phy_defs
name|s_phy_defs
index|[]
init|=
block|{
block|{
literal|"nw_phy"
block|,
name|NWS_REG_NWS_CMU_K2_E5
block|,
name|PHY_NW_IP_REG_PHY0_TOP_TBUS_ADDR_7_0_K2_E5
block|,
name|PHY_NW_IP_REG_PHY0_TOP_TBUS_ADDR_15_8_K2_E5
block|,
name|PHY_NW_IP_REG_PHY0_TOP_TBUS_DATA_7_0_K2_E5
block|,
name|PHY_NW_IP_REG_PHY0_TOP_TBUS_DATA_11_8_K2_E5
block|}
block|,
block|{
literal|"sgmii_phy"
block|,
name|MS_REG_MS_CMU_K2_E5
block|,
name|PHY_SGMII_IP_REG_AHB_CMU_CSR_0_X132_K2_E5
block|,
name|PHY_SGMII_IP_REG_AHB_CMU_CSR_0_X133_K2_E5
block|,
name|PHY_SGMII_IP_REG_AHB_CMU_CSR_0_X130_K2_E5
block|,
name|PHY_SGMII_IP_REG_AHB_CMU_CSR_0_X131_K2_E5
block|}
block|,
block|{
literal|"pcie_phy0"
block|,
name|PHY_PCIE_REG_PHY0_K2_E5
block|,
name|PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X132_K2_E5
block|,
name|PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X133_K2_E5
block|,
name|PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X130_K2_E5
block|,
name|PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X131_K2_E5
block|}
block|,
block|{
literal|"pcie_phy1"
block|,
name|PHY_PCIE_REG_PHY1_K2_E5
block|,
name|PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X132_K2_E5
block|,
name|PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X133_K2_E5
block|,
name|PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X130_K2_E5
block|,
name|PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X131_K2_E5
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The order of indexes that should be applied to a PCI buffer line */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u8
name|s_pci_buf_line_ind
index|[
name|PCI_BUF_LINE_SIZE_IN_DWORDS
index|]
init|=
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|5
block|,
literal|4
block|,
literal|7
block|,
literal|6
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************** Variables **********************************/
end_comment

begin_comment
comment|/* The version of the calling app */
end_comment

begin_decl_stmt
specifier|static
name|u32
name|s_app_ver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************** Private Functions ******************************/
end_comment

begin_function
specifier|static
name|void
name|ecore_static_asserts
parameter_list|(
name|void
parameter_list|)
block|{
name|CHECK_ARR_SIZE
argument_list|(
name|s_dbg_arrays
argument_list|,
name|MAX_BIN_DBG_BUFFER_TYPE
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_big_ram_defs
argument_list|,
name|NUM_BIG_RAM_TYPES
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_vfc_ram_defs
argument_list|,
name|NUM_VFC_RAM_TYPES
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_rss_mem_defs
argument_list|,
name|NUM_RSS_MEM_TYPES
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_chip_defs
argument_list|,
name|MAX_CHIP_IDS
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_platform_defs
argument_list|,
name|MAX_PLATFORM_IDS
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_storm_defs
argument_list|,
name|MAX_DBG_STORMS
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_constraint_op_defs
argument_list|,
name|MAX_DBG_BUS_CONSTRAINT_OPS
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_dbg_target_names
argument_list|,
name|MAX_DBG_BUS_TARGETS
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_storm_mode_defs
argument_list|,
name|MAX_DBG_BUS_STORM_MODES
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_grc_param_defs
argument_list|,
name|MAX_DBG_GRC_PARAMS
argument_list|)
expr_stmt|;
name|CHECK_ARR_SIZE
argument_list|(
name|s_reset_regs_defs
argument_list|,
name|MAX_DBG_RESET_REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reads and returns a single dword from the specified unaligned buffer. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_read_unaligned_dword
parameter_list|(
name|u8
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|dword
decl_stmt|;
name|OSAL_MEMCPY
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|dword
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|dword
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dword
return|;
block|}
end_function

begin_comment
comment|/* Returns the difference in bytes between the specified physical addresses.  * Assumes that the first address is bigger then the second, and that the  * difference is a 32-bit value.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_phys_addr_diff
parameter_list|(
name|struct
name|dbg_bus_mem_addr
modifier|*
name|a
parameter_list|,
name|struct
name|dbg_bus_mem_addr
modifier|*
name|b
parameter_list|)
block|{
return|return
name|a
operator|->
name|hi
operator|==
name|b
operator|->
name|hi
condition|?
name|a
operator|->
name|lo
operator|-
name|b
operator|->
name|lo
else|:
name|b
operator|->
name|lo
operator|-
name|a
operator|->
name|lo
return|;
block|}
end_function

begin_comment
comment|/* Sets the value of the specified GRC param */
end_comment

begin_function
specifier|static
name|void
name|ecore_grc_set_param
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_grc_params
name|grc_param
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|dev_data
operator|->
name|grc
operator|.
name|param_val
index|[
name|grc_param
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the value of the specified GRC param */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_get_param
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_grc_params
name|grc_param
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
return|return
name|dev_data
operator|->
name|grc
operator|.
name|param_val
index|[
name|grc_param
index|]
return|;
block|}
end_function

begin_comment
comment|/* Initializes the GRC parameters */
end_comment

begin_function
specifier|static
name|void
name|ecore_dbg_grc_init_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
if|if
condition|(
operator|!
name|dev_data
operator|->
name|grc
operator|.
name|params_initialized
condition|)
block|{
name|ecore_dbg_grc_set_params_default
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|dev_data
operator|->
name|grc
operator|.
name|params_initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initializes debug data for the specified device */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_dbg_dev_init
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|initialized
condition|)
return|return
name|DBG_STATUS_OK
return|;
if|if
condition|(
operator|!
name|s_app_ver
condition|)
return|return
name|DBG_STATUS_APP_VERSION_NOT_SET
return|;
if|if
condition|(
name|ECORE_IS_K2
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|dev_data
operator|->
name|chip_id
operator|=
name|CHIP_K2
expr_stmt|;
name|dev_data
operator|->
name|mode_enable
index|[
name|MODE_K2
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ECORE_IS_BB_B0
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|dev_data
operator|->
name|chip_id
operator|=
name|CHIP_BB
expr_stmt|;
name|dev_data
operator|->
name|mode_enable
index|[
name|MODE_BB
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
name|DBG_STATUS_UNKNOWN_CHIP
return|;
block|}
ifdef|#
directive|ifdef
name|ASIC_ONLY
name|dev_data
operator|->
name|platform_id
operator|=
name|PLATFORM_ASIC
expr_stmt|;
name|dev_data
operator|->
name|mode_enable
index|[
name|MODE_ASIC
index|]
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|CHIP_REV_IS_ASIC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|dev_data
operator|->
name|platform_id
operator|=
name|PLATFORM_ASIC
expr_stmt|;
name|dev_data
operator|->
name|mode_enable
index|[
name|MODE_ASIC
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISCS_REG_ECO_RESERVED
argument_list|)
operator|&
literal|0x20000000
condition|)
block|{
name|dev_data
operator|->
name|platform_id
operator|=
name|PLATFORM_EMUL_FULL
expr_stmt|;
name|dev_data
operator|->
name|mode_enable
index|[
name|MODE_EMUL_FULL
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev_data
operator|->
name|platform_id
operator|=
name|PLATFORM_EMUL_REDUCED
expr_stmt|;
name|dev_data
operator|->
name|mode_enable
index|[
name|MODE_EMUL_REDUCED
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|dev_data
operator|->
name|platform_id
operator|=
name|PLATFORM_FPGA
expr_stmt|;
name|dev_data
operator|->
name|mode_enable
index|[
name|MODE_FPGA
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
name|DBG_STATUS_UNKNOWN_CHIP
return|;
block|}
endif|#
directive|endif
comment|/* Initializes the GRC parameters */
name|ecore_dbg_grc_init_params
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|dev_data
operator|->
name|initialized
operator|=
name|true
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dbg_bus_block
modifier|*
name|get_dbg_bus_block_desc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
return|return
operator|(
expr|struct
name|dbg_bus_block
operator|*
operator|)
operator|&
name|dbg_bus_blocks
index|[
name|block_id
operator|*
name|MAX_CHIP_IDS
operator|+
name|dev_data
operator|->
name|chip_id
index|]
return|;
block|}
end_function

begin_comment
comment|/* Returns OSAL_NULL for signature line, latency line and non-existing lines */
end_comment

begin_function
specifier|static
name|struct
name|dbg_bus_line
modifier|*
name|get_dbg_bus_line_desc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_block_data
modifier|*
name|block_bus
decl_stmt|;
name|struct
name|dbg_bus_block
modifier|*
name|block_desc
decl_stmt|;
name|block_bus
operator|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
expr_stmt|;
name|block_desc
operator|=
name|get_dbg_bus_block_desc
argument_list|(
name|p_hwfn
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|block_bus
operator|->
name|line_num
operator|||
operator|(
name|block_bus
operator|->
name|line_num
operator|==
literal|1
operator|&&
name|block_desc
operator|->
name|has_latency_events
operator|)
operator|||
name|block_bus
operator|->
name|line_num
operator|>=
name|NUM_DBG_LINES
argument_list|(
name|block_desc
argument_list|)
condition|)
return|return
name|OSAL_NULL
return|;
return|return
operator|(
expr|struct
name|dbg_bus_line
operator|*
operator|)
operator|&
name|dbg_bus_lines
index|[
name|block_desc
operator|->
name|lines_offset
operator|+
name|block_bus
operator|->
name|line_num
operator|-
name|NUM_EXTRA_DBG_LINES
argument_list|(
name|block_desc
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* Reads the FW info structure for the specified Storm from the chip,  * and writes it to the specified fw_info pointer.  */
end_comment

begin_function
specifier|static
name|void
name|ecore_read_fw_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|storm_id
parameter_list|,
name|struct
name|fw_info
modifier|*
name|fw_info
parameter_list|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
name|struct
name|fw_info_location
name|fw_info_location
decl_stmt|;
name|u32
name|addr
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|fw_info_location
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fw_info_location
argument_list|)
argument_list|)
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|fw_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fw_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read first the address that points to fw_info location. 	 * The address is located in the last line of the Storm RAM. 	 */
name|addr
operator|=
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_INT_RAM
operator|+
name|DWORDS_TO_BYTES
argument_list|(
name|SEM_FAST_REG_INT_RAM_SIZE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|fw_info_location
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|fw_info_location
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BYTES_TO_DWORDS
argument_list|(
sizeof|sizeof
argument_list|(
name|fw_info_location
argument_list|)
argument_list|)
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
name|BYTES_IN_DWORD
control|)
name|dest
index|[
name|i
index|]
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Read FW version info from Storm RAM */
if|if
condition|(
name|fw_info_location
operator|.
name|size
operator|>
literal|0
operator|&&
name|fw_info_location
operator|.
name|size
operator|<=
sizeof|sizeof
argument_list|(
operator|*
name|fw_info
argument_list|)
condition|)
block|{
name|addr
operator|=
name|fw_info_location
operator|.
name|grc_addr
expr_stmt|;
name|dest
operator|=
operator|(
name|u32
operator|*
operator|)
name|fw_info
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BYTES_TO_DWORDS
argument_list|(
name|fw_info_location
operator|.
name|size
argument_list|)
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
name|BYTES_IN_DWORD
control|)
name|dest
index|[
name|i
index|]
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dumps the specified string to the specified buffer.  * Returns the dumped size in bytes.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_str
parameter_list|(
name|char
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|dump
condition|)
name|OSAL_STRCPY
argument_list|(
name|dump_buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|u32
operator|)
name|OSAL_STRLEN
argument_list|(
name|str
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dumps zeros to align the specified buffer to dwords.  * Returns the dumped size in bytes.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_align
parameter_list|(
name|char
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
name|byte_offset
parameter_list|)
block|{
name|u8
name|offset_in_dword
decl_stmt|,
name|align_size
decl_stmt|;
name|offset_in_dword
operator|=
call|(
name|u8
call|)
argument_list|(
name|byte_offset
operator|&
literal|0x3
argument_list|)
expr_stmt|;
name|align_size
operator|=
name|offset_in_dword
condition|?
name|BYTES_IN_DWORD
operator|-
name|offset_in_dword
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|dump
operator|&&
name|align_size
condition|)
name|OSAL_MEMSET
argument_list|(
name|dump_buf
argument_list|,
literal|0
argument_list|,
name|align_size
argument_list|)
expr_stmt|;
return|return
name|align_size
return|;
block|}
end_function

begin_comment
comment|/* Writes the specified string param to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_str_param
parameter_list|(
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
specifier|const
name|char
modifier|*
name|param_name
parameter_list|,
specifier|const
name|char
modifier|*
name|param_val
parameter_list|)
block|{
name|char
modifier|*
name|char_buf
init|=
operator|(
name|char
operator|*
operator|)
name|dump_buf
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Dump param name */
name|offset
operator|+=
name|ecore_dump_str
argument_list|(
name|char_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|param_name
argument_list|)
expr_stmt|;
comment|/* Indicate a string param value */
if|if
condition|(
name|dump
condition|)
operator|*
operator|(
name|char_buf
operator|+
name|offset
operator|)
operator|=
literal|1
expr_stmt|;
name|offset
operator|++
expr_stmt|;
comment|/* Dump param value */
name|offset
operator|+=
name|ecore_dump_str
argument_list|(
name|char_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|param_val
argument_list|)
expr_stmt|;
comment|/* Align buffer to next dword */
name|offset
operator|+=
name|ecore_dump_align
argument_list|(
name|char_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|BYTES_TO_DWORDS
argument_list|(
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Writes the specified numeric param to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_num_param
parameter_list|(
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
specifier|const
name|char
modifier|*
name|param_name
parameter_list|,
name|u32
name|param_val
parameter_list|)
block|{
name|char
modifier|*
name|char_buf
init|=
operator|(
name|char
operator|*
operator|)
name|dump_buf
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Dump param name */
name|offset
operator|+=
name|ecore_dump_str
argument_list|(
name|char_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|param_name
argument_list|)
expr_stmt|;
comment|/* Indicate a numeric param value */
if|if
condition|(
name|dump
condition|)
operator|*
operator|(
name|char_buf
operator|+
name|offset
operator|)
operator|=
literal|0
expr_stmt|;
name|offset
operator|++
expr_stmt|;
comment|/* Align buffer to next dword */
name|offset
operator|+=
name|ecore_dump_align
argument_list|(
name|char_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Dump param value (and change offset from bytes to dwords) */
name|offset
operator|=
name|BYTES_TO_DWORDS
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
condition|)
operator|*
operator|(
name|dump_buf
operator|+
name|offset
operator|)
operator|=
name|param_val
expr_stmt|;
name|offset
operator|++
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Reads the FW version and writes it as a param to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_fw_ver_param
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|char
name|fw_ver_str
index|[
literal|16
index|]
init|=
name|EMPTY_FW_VERSION_STR
decl_stmt|;
name|char
name|fw_img_str
index|[
literal|16
index|]
init|=
name|EMPTY_FW_IMAGE_STR
decl_stmt|;
name|struct
name|fw_info
name|fw_info
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dump
operator|&&
operator|!
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NO_FW_VER
argument_list|)
condition|)
block|{
comment|/* Read FW image/version from PRAM in a non-reset SEMI */
name|bool
name|found
init|=
name|false
decl_stmt|;
name|u8
name|storm_id
decl_stmt|;
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
operator|&&
operator|!
name|found
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
comment|/* Read FW version/image */
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|storm
operator|->
name|block_id
index|]
condition|)
continue|continue;
comment|/* Read FW info for the current Storm */
name|ecore_read_fw_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm_id
argument_list|,
operator|&
name|fw_info
argument_list|)
expr_stmt|;
comment|/* Create FW version/image strings */
if|if
condition|(
name|OSAL_SNPRINTF
argument_list|(
name|fw_ver_str
argument_list|,
sizeof|sizeof
argument_list|(
name|fw_ver_str
argument_list|)
argument_list|,
literal|"%d_%d_%d_%d"
argument_list|,
name|fw_info
operator|.
name|ver
operator|.
name|num
operator|.
name|major
argument_list|,
name|fw_info
operator|.
name|ver
operator|.
name|num
operator|.
name|minor
argument_list|,
name|fw_info
operator|.
name|ver
operator|.
name|num
operator|.
name|rev
argument_list|,
name|fw_info
operator|.
name|ver
operator|.
name|num
operator|.
name|eng
argument_list|)
operator|<
literal|0
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unexpected debug error: invalid FW version string\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fw_info
operator|.
name|ver
operator|.
name|image_id
condition|)
block|{
case|case
name|FW_IMG_KUKU
case|:
name|OSAL_STRCPY
argument_list|(
name|fw_img_str
argument_list|,
literal|"kuku"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_IMG_MAIN
case|:
name|OSAL_STRCPY
argument_list|(
name|fw_img_str
argument_list|,
literal|"main"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_IMG_L2B
case|:
name|OSAL_STRCPY
argument_list|(
name|fw_img_str
argument_list|,
literal|"l2b"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSAL_STRCPY
argument_list|(
name|fw_img_str
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
name|found
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Dump FW version, image and timestamp */
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"fw-version"
argument_list|,
name|fw_ver_str
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"fw-image"
argument_list|,
name|fw_img_str
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"fw-timestamp"
argument_list|,
name|fw_info
operator|.
name|ver
operator|.
name|timestamp
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Reads the MFW version and writes it as a param to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_mfw_ver_param
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|char
name|mfw_ver_str
index|[
literal|16
index|]
init|=
name|EMPTY_FW_VERSION_STR
decl_stmt|;
name|bool
name|is_emul
decl_stmt|;
name|is_emul
operator|=
name|dev_data
operator|->
name|platform_id
operator|==
name|PLATFORM_EMUL_FULL
operator|||
name|dev_data
operator|->
name|platform_id
operator|==
name|PLATFORM_EMUL_REDUCED
expr_stmt|;
if|if
condition|(
name|dump
operator|&&
operator|!
name|is_emul
operator|&&
operator|!
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NO_FW_VER
argument_list|)
condition|)
block|{
name|u32
name|public_data_addr
decl_stmt|,
name|global_section_offsize_addr
decl_stmt|,
name|global_section_offsize
decl_stmt|,
name|global_section_addr
decl_stmt|,
name|mfw_ver
decl_stmt|;
comment|/* Find MCP public data GRC address. Needs to be ORed with 		 * MCP_REG_SCRATCH due to a HW bug. 		 */
name|public_data_addr
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_SHARED_MEM_ADDR
argument_list|)
operator||
name|MCP_REG_SCRATCH
expr_stmt|;
comment|/* Find MCP public global section offset */
name|global_section_offsize_addr
operator|=
name|public_data_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|mcp_public_data
argument_list|,
name|sections
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|offsize_t
argument_list|)
operator|*
name|PUBLIC_GLOBAL
expr_stmt|;
name|global_section_offsize
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|global_section_offsize_addr
argument_list|)
expr_stmt|;
name|global_section_addr
operator|=
name|MCP_REG_SCRATCH
operator|+
operator|(
name|global_section_offsize
operator|&
name|OFFSIZE_OFFSET_MASK
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Read MFW version from MCP public global section */
name|mfw_ver
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|global_section_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|public_global
argument_list|,
name|mfw_ver
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump MFW version param */
if|if
condition|(
name|OSAL_SNPRINTF
argument_list|(
name|mfw_ver_str
argument_list|,
sizeof|sizeof
argument_list|(
name|mfw_ver_str
argument_list|)
argument_list|,
literal|"%d_%d_%d_%d"
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|mfw_ver
operator|>>
literal|24
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|mfw_ver
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|mfw_ver
operator|>>
literal|8
argument_list|)
argument_list|,
operator|(
name|u8
operator|)
name|mfw_ver
argument_list|)
operator|<
literal|0
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unexpected debug error: invalid MFW version string\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ecore_dump_str_param
argument_list|(
name|dump_buf
argument_list|,
name|dump
argument_list|,
literal|"mfw-version"
argument_list|,
name|mfw_ver_str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Writes a section header to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_section_hdr
parameter_list|(
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u32
name|num_params
parameter_list|)
block|{
return|return
name|ecore_dump_num_param
argument_list|(
name|dump_buf
argument_list|,
name|dump
argument_list|,
name|name
argument_list|,
name|num_params
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Writes the common global params to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_common_global_params
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u8
name|num_specific_global_params
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|u8
name|num_params
decl_stmt|;
comment|/* Dump global params section header */
name|num_params
operator|=
name|NUM_COMMON_GLOBAL_PARAMS
operator|+
name|num_specific_global_params
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"global_params"
argument_list|,
name|num_params
argument_list|)
expr_stmt|;
comment|/* Store params */
name|offset
operator|+=
name|ecore_dump_fw_ver_param
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_mfw_ver_param
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"tools-version"
argument_list|,
name|TOOLS_VERSION
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"chip"
argument_list|,
name|s_chip_defs
index|[
name|dev_data
operator|->
name|chip_id
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"platform"
argument_list|,
name|s_platform_defs
index|[
name|dev_data
operator|->
name|platform_id
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"pci-func"
argument_list|,
name|p_hwfn
operator|->
name|abs_pf_id
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Writes the "last" section (including CRC) to the specified buffer at the  * given offset. Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_dump_last_section
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|offset
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|u32
name|start_offset
init|=
name|offset
decl_stmt|;
comment|/* Dump CRC section header */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"last"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Calculate CRC32 and add it to the dword after the "last" section */
if|if
condition|(
name|dump
condition|)
operator|*
operator|(
name|dump_buf
operator|+
name|offset
operator|)
operator|=
operator|~
name|OSAL_CRC32
argument_list|(
literal|0xffffffff
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|dump_buf
argument_list|,
name|DWORDS_TO_BYTES
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
return|return
name|offset
operator|-
name|start_offset
return|;
block|}
end_function

begin_comment
comment|/* Update blocks reset state  */
end_comment

begin_function
specifier|static
name|void
name|ecore_update_blocks_reset_state
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|reg_val
index|[
name|MAX_DBG_RESET_REGS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|i
decl_stmt|;
comment|/* Read reset registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_DBG_RESET_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s_reset_regs_defs
index|[
name|i
index|]
operator|.
name|exists
index|[
name|dev_data
operator|->
name|chip_id
index|]
condition|)
name|reg_val
index|[
name|i
index|]
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|s_reset_regs_defs
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
comment|/* Check if blocks are in reset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BLOCK_ID
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|i
index|]
decl_stmt|;
name|dev_data
operator|->
name|block_in_reset
index|[
name|i
index|]
operator|=
name|block
operator|->
name|has_reset_bit
operator|&&
operator|!
operator|(
name|reg_val
index|[
name|block
operator|->
name|reset_reg
index|]
operator|&
operator|(
literal|1
operator|<<
name|block
operator|->
name|reset_bit_offset
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enable / disable the Debug block */
end_comment

begin_function
specifier|static
name|void
name|ecore_bus_enable_dbg_block
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_DBG_BLOCK_ON
argument_list|,
name|enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resets the Debug block */
end_comment

begin_function
specifier|static
name|void
name|ecore_bus_reset_dbg_block
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u32
name|dbg_reset_reg_addr
decl_stmt|,
name|old_reset_reg_val
decl_stmt|,
name|new_reset_reg_val
decl_stmt|;
name|struct
name|block_defs
modifier|*
name|dbg_block
init|=
name|s_block_defs
index|[
name|BLOCK_DBG
index|]
decl_stmt|;
name|dbg_reset_reg_addr
operator|=
name|s_reset_regs_defs
index|[
name|dbg_block
operator|->
name|reset_reg
index|]
operator|.
name|addr
expr_stmt|;
name|old_reset_reg_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dbg_reset_reg_addr
argument_list|)
expr_stmt|;
name|new_reset_reg_val
operator|=
name|old_reset_reg_val
operator|&
operator|~
operator|(
literal|1
operator|<<
name|dbg_block
operator|->
name|reset_bit_offset
operator|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dbg_reset_reg_addr
argument_list|,
name|new_reset_reg_val
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dbg_reset_reg_addr
argument_list|,
name|old_reset_reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_bus_set_framing_mode
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|dbg_bus_frame_modes
name|mode
parameter_list|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_FRAMING_MODE
argument_list|,
operator|(
name|u8
operator|)
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable / disable Debug Bus clients according to the specified mask  * (1 = enable, 0 = disable).  */
end_comment

begin_function
specifier|static
name|void
name|ecore_bus_enable_clients
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|client_mask
parameter_list|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_CLIENT_ENABLE
argument_list|,
name|client_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enables the specified Storm for Debug Bus. Assumes a valid Storm ID. */
end_comment

begin_function
specifier|static
name|void
name|ecore_bus_enable_storm
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|dbg_storms
name|storm_id
parameter_list|,
name|enum
name|dbg_bus_filter_types
name|filter_type
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|base_addr
decl_stmt|,
name|sem_filter_params
init|=
name|filter_type
decl_stmt|;
name|struct
name|dbg_bus_storm_data
modifier|*
name|storm_bus
decl_stmt|;
name|struct
name|storm_mode_defs
modifier|*
name|storm_mode
decl_stmt|;
name|struct
name|storm_defs
modifier|*
name|storm
decl_stmt|;
name|storm
operator|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
expr_stmt|;
name|storm_bus
operator|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm_id
index|]
expr_stmt|;
name|storm_mode
operator|=
operator|&
name|s_storm_mode_defs
index|[
name|storm_bus
operator|->
name|mode
index|]
expr_stmt|;
name|base_addr
operator|=
name|storm
operator|->
name|sem_fast_mem_addr
expr_stmt|;
comment|/* Config SEM */
if|if
condition|(
name|storm_mode
operator|->
name|is_fast_dbg
condition|)
block|{
comment|/* Enable fast debug */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_frame_mode_addr
argument_list|,
name|DBG_BUS_SEMI_FRAME_MODE_0SLOW_4FAST
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_DEBUG_MODE
argument_list|,
name|storm_mode
operator|->
name|id_in_hw
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_DEBUG_ACTIVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable all messages except STORE. Must be done after 		 * enabling SEM_FAST_REG_DEBUG_ACTIVE, otherwise messages will 		 * be dropped after the SEMI sync fifo is filled. 		 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_DBG_MODE6_SRC_DISABLE
argument_list|,
name|SEM_FAST_MODE6_SRC_ENABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ensable slow debug */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_frame_mode_addr
argument_list|,
name|DBG_BUS_SEMI_FRAME_MODE_4SLOW_0FAST
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_slow_enable_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_slow_mode_addr
argument_list|,
name|storm_mode
operator|->
name|id_in_hw
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_slow_mode1_conf_addr
argument_list|,
name|SEM_SLOW_MODE1_DATA_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/* Config SEM cid filter */
if|if
condition|(
name|storm_bus
operator|->
name|cid_filter_en
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_FILTER_CID
argument_list|,
name|storm_bus
operator|->
name|cid
argument_list|)
expr_stmt|;
name|sem_filter_params
operator||=
name|SEM_FILTER_CID_EN_MASK
expr_stmt|;
block|}
comment|/* Config SEM eid filter */
if|if
condition|(
name|storm_bus
operator|->
name|eid_filter_en
condition|)
block|{
specifier|const
name|union
name|dbg_bus_storm_eid_params
modifier|*
name|eid_filter
init|=
operator|&
name|storm_bus
operator|->
name|eid_filter_params
decl_stmt|;
if|if
condition|(
name|storm_bus
operator|->
name|eid_range_not_mask
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_EVENT_ID_RANGE_STRT
argument_list|,
name|eid_filter
operator|->
name|range
operator|.
name|min
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_EVENT_ID_RANGE_END
argument_list|,
name|eid_filter
operator|->
name|range
operator|.
name|max
argument_list|)
expr_stmt|;
name|sem_filter_params
operator||=
name|SEM_FILTER_EID_RANGE_EN_MASK
expr_stmt|;
block|}
else|else
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_FILTER_EVENT_ID
argument_list|,
name|eid_filter
operator|->
name|mask
operator|.
name|val
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_EVENT_ID_MASK
argument_list|,
operator|~
name|eid_filter
operator|->
name|mask
operator|.
name|mask
argument_list|)
expr_stmt|;
name|sem_filter_params
operator||=
name|SEM_FILTER_EID_MASK_EN_MASK
expr_stmt|;
block|}
block|}
comment|/* Config accumulaed SEM filter parameters (if any) */
if|if
condition|(
name|sem_filter_params
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_RECORD_FILTER_ENABLE
argument_list|,
name|sem_filter_params
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disables Debug Bus block inputs */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_bus_disable_inputs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|empty_semi_fifos
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u8
name|storm_id
decl_stmt|,
name|num_fifos_to_empty
init|=
name|MAX_DBG_STORMS
decl_stmt|;
name|bool
name|is_fifo_empty
index|[
name|MAX_DBG_STORMS
index|]
init|=
block|{
name|false
block|}
decl_stmt|;
name|u32
name|block_id
decl_stmt|;
comment|/* Disable messages output in all Storms */
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dev_data
operator|->
name|block_in_reset
index|[
name|storm
operator|->
name|block_id
index|]
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_DBG_MODE6_SRC_DISABLE
argument_list|,
name|SEM_FAST_MODE6_SRC_DISABLE
argument_list|)
expr_stmt|;
block|}
comment|/* Try to empty the SEMI sync fifo. Must be done after messages output 	 * were disabled in all Storms (i.e. SEM_FAST_REG_DBG_MODE6_SRC_DISABLE 	 * was set to all 1's. 	 */
while|while
condition|(
name|num_fifos_to_empty
condition|)
block|{
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
name|is_fifo_empty
index|[
name|storm_id
index|]
condition|)
continue|continue;
comment|/* Check if sync fifo got empty */
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|storm
operator|->
name|block_id
index|]
operator|||
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_sync_dbg_empty_addr
argument_list|)
condition|)
block|{
name|is_fifo_empty
index|[
name|storm_id
index|]
operator|=
name|true
expr_stmt|;
name|num_fifos_to_empty
operator|--
expr_stmt|;
block|}
block|}
comment|/* Check if need to continue polling */
if|if
condition|(
name|num_fifos_to_empty
condition|)
block|{
name|u32
name|polling_ms
init|=
name|SEMI_SYNC_FIFO_POLLING_DELAY_MS
operator|*
name|s_platform_defs
index|[
name|dev_data
operator|->
name|platform_id
index|]
operator|.
name|delay_factor
decl_stmt|;
name|u32
name|polling_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|empty_semi_fifos
operator|&&
name|polling_count
operator|<
name|SEMI_SYNC_FIFO_POLLING_COUNT
condition|)
block|{
name|OSAL_MSLEEP
argument_list|(
name|polling_ms
argument_list|)
expr_stmt|;
name|polling_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Warning: failed to empty the SEMI sync FIFO. It means that the last few messages from the SEMI could not be sent to the DBG block. This can happen when the DBG block is blocked (e.g. due to a PCI problem).\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Disable debug in all Storms */
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
name|u32
name|base_addr
init|=
name|storm
operator|->
name|sem_fast_mem_addr
decl_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|storm
operator|->
name|block_id
index|]
condition|)
continue|continue;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_DEBUG_ACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|base_addr
operator|+
name|SEM_FAST_REG_RECORD_FILTER_ENABLE
argument_list|,
name|DBG_BUS_FILTER_TYPE_OFF
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_frame_mode_addr
argument_list|,
name|DBG_BUS_FRAME_MODE_4HW_0ST
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_slow_enable_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all clients */
name|ecore_bus_enable_clients
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable all blocks */
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
if|if
condition|(
name|block
operator|->
name|has_dbg_bus
index|[
name|dev_data
operator|->
name|chip_id
index|]
operator|&&
operator|!
name|dev_data
operator|->
name|block_in_reset
index|[
name|block_id
index|]
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|block
operator|->
name|dbg_enable_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Disable timestamp */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TIMESTAMP_VALID_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable filters and triggers */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_FILTER_ENABLE
argument_list|,
name|DBG_BUS_FILTER_TYPE_OFF
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Sets a Debug Bus trigger/filter constraint */
end_comment

begin_function
specifier|static
name|void
name|ecore_bus_set_constraint
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|is_filter
parameter_list|,
name|u8
name|constraint_id
parameter_list|,
name|u8
name|hw_op_val
parameter_list|,
name|u32
name|data_val
parameter_list|,
name|u32
name|data_mask
parameter_list|,
name|u8
name|frame_bit
parameter_list|,
name|u8
name|frame_mask
parameter_list|,
name|u16
name|dword_offset
parameter_list|,
name|u16
name|range
parameter_list|,
name|u8
name|cyclic_bit
parameter_list|,
name|u8
name|must_bit
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|reg_offset
init|=
name|constraint_id
operator|*
name|BYTES_IN_DWORD
decl_stmt|;
name|u8
name|curr_trigger_state
decl_stmt|;
comment|/* For trigger only - set register offset according to state */
if|if
condition|(
operator|!
name|is_filter
condition|)
block|{
name|curr_trigger_state
operator|=
name|dev_data
operator|->
name|bus
operator|.
name|next_trigger_state
operator|-
literal|1
expr_stmt|;
name|reg_offset
operator|+=
name|curr_trigger_state
operator|*
name|TRIGGER_SETS_PER_STATE
operator|*
name|MAX_CONSTRAINTS
operator|*
name|BYTES_IN_DWORD
expr_stmt|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_OPRTN_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_OPRTN_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|hw_op_val
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_DATA_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_DATA_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|data_val
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_DATA_MASK_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_DATA_MASK_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|data_mask
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_FRAME_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_FRAME_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|frame_bit
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_FRAME_MASK_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_FRAME_MASK_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|frame_mask
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_OFFSET_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_OFFSET_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|dword_offset
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_RANGE_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_RANGE_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_CYCLIC_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_CYCLIC_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|cyclic_bit
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|is_filter
condition|?
name|DBG_REG_FILTER_CNSTR_MUST_0
else|:
name|DBG_REG_TRIGGER_STATE_SET_CNSTR_MUST_0
operator|)
operator|+
name|reg_offset
argument_list|,
name|must_bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reads the specified DBG Bus internal buffer range and copy it to the  * specified buffer. Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_bus_dump_int_buf_range
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
name|start_line
parameter_list|,
name|u32
name|end_line
parameter_list|)
block|{
name|u32
name|line
decl_stmt|,
name|reg_addr
decl_stmt|,
name|i
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
return|return
operator|(
name|end_line
operator|-
name|start_line
operator|+
literal|1
operator|)
operator|*
name|INT_BUF_LINE_SIZE_IN_DWORDS
return|;
for|for
control|(
name|line
operator|=
name|start_line
operator|,
name|reg_addr
operator|=
name|DBG_REG_INTR_BUFFER
operator|+
name|DWORDS_TO_BYTES
argument_list|(
name|start_line
operator|*
name|INT_BUF_LINE_SIZE_IN_DWORDS
argument_list|)
init|;
name|line
operator|<=
name|end_line
condition|;
name|line
operator|++
operator|,
name|offset
operator|+=
name|INT_BUF_LINE_SIZE_IN_DWORDS
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INT_BUF_LINE_SIZE_IN_DWORDS
condition|;
name|i
operator|++
operator|,
name|reg_addr
operator|+=
name|BYTES_IN_DWORD
control|)
name|dump_buf
index|[
name|offset
operator|+
name|INT_BUF_LINE_SIZE_IN_DWORDS
operator|-
literal|1
operator|-
name|i
index|]
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Reads the DBG Bus internal buffer and copy its contents to a buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_bus_dump_int_buf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|u32
name|last_written_line
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|last_written_line
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_INTR_BUFFER_WR_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_WRAP_ON_INT_BUFFER
argument_list|)
condition|)
block|{
comment|/* Internal buffer was wrapped: first dump from write pointer 		 * to buffer end, then dump from buffer start to write pointer. 		 */
if|if
condition|(
name|last_written_line
operator|<
name|INT_BUF_NUM_OF_LINES
operator|-
literal|1
condition|)
name|offset
operator|+=
name|ecore_bus_dump_int_buf_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|last_written_line
operator|+
literal|1
argument_list|,
name|INT_BUF_NUM_OF_LINES
operator|-
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_bus_dump_int_buf_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|0
argument_list|,
name|last_written_line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_written_line
condition|)
block|{
comment|/* Internal buffer wasn't wrapped: dump from buffer start until 		 *  write pointer. 		 */
if|if
condition|(
operator|!
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_INTR_BUFFER_RD_PTR
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_bus_dump_int_buf_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|0
argument_list|,
name|last_written_line
argument_list|)
expr_stmt|;
else|else
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unexpected Debug Bus error: internal buffer read pointer is not zero\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Reads the specified DBG Bus PCI buffer range and copy it to the specified  * buffer. Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_bus_dump_pci_buf_range
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
name|start_line
parameter_list|,
name|u32
name|end_line
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Extract PCI buffer pointer from virtual address */
name|void
modifier|*
name|virt_addr_lo
init|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|virt_addr
operator|.
name|lo
decl_stmt|;
name|u32
modifier|*
name|pci_buf_start
init|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|osal_uintptr_t
operator|)
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
name|virt_addr_lo
operator|)
decl_stmt|;
name|u32
modifier|*
name|pci_buf
decl_stmt|,
name|line
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
return|return
operator|(
name|end_line
operator|-
name|start_line
operator|+
literal|1
operator|)
operator|*
name|PCI_BUF_LINE_SIZE_IN_DWORDS
return|;
for|for
control|(
name|line
operator|=
name|start_line
operator|,
name|pci_buf
operator|=
name|pci_buf_start
operator|+
name|start_line
operator|*
name|PCI_BUF_LINE_SIZE_IN_DWORDS
init|;
name|line
operator|<=
name|end_line
condition|;
name|line
operator|++
operator|,
name|offset
operator|+=
name|PCI_BUF_LINE_SIZE_IN_DWORDS
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCI_BUF_LINE_SIZE_IN_DWORDS
condition|;
name|i
operator|++
operator|,
name|pci_buf
operator|++
control|)
name|dump_buf
index|[
name|offset
operator|+
name|s_pci_buf_line_ind
index|[
name|i
index|]
index|]
operator|=
operator|*
name|pci_buf
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Copies the DBG Bus PCI buffer to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_bus_dump_pci_buf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|next_wr_byte_offset
decl_stmt|,
name|next_wr_line_offset
decl_stmt|;
name|struct
name|dbg_bus_mem_addr
name|next_wr_phys_addr
decl_stmt|;
name|u32
name|pci_buf_size_in_lines
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|pci_buf_size_in_lines
operator|=
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
operator|/
name|PCI_BUF_LINE_SIZE_IN_BYTES
expr_stmt|;
comment|/* Extract write pointer (physical address) */
name|next_wr_phys_addr
operator|.
name|lo
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_EXT_BUFFER_WR_PTR
argument_list|)
expr_stmt|;
name|next_wr_phys_addr
operator|.
name|hi
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_EXT_BUFFER_WR_PTR
operator|+
name|BYTES_IN_DWORD
argument_list|)
expr_stmt|;
comment|/* Convert write pointer to offset */
name|next_wr_byte_offset
operator|=
name|ecore_phys_addr_diff
argument_list|(
operator|&
name|next_wr_phys_addr
argument_list|,
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|phys_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|next_wr_byte_offset
operator|%
name|PCI_BUF_LINE_SIZE_IN_BYTES
operator|)
operator|||
name|next_wr_byte_offset
operator|>
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
condition|)
return|return
literal|0
return|;
name|next_wr_line_offset
operator|=
name|next_wr_byte_offset
operator|/
name|PCI_BUF_LINE_SIZE_IN_BYTES
expr_stmt|;
comment|/* PCI buffer wrapped: first dump from write pointer to buffer end. */
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_WRAP_ON_EXT_BUFFER
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_bus_dump_pci_buf_range
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|next_wr_line_offset
argument_list|,
name|pci_buf_size_in_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Dump from buffer start until write pointer */
if|if
condition|(
name|next_wr_line_offset
condition|)
name|offset
operator|+=
name|ecore_bus_dump_pci_buf_range
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|0
argument_list|,
name|next_wr_line_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Copies the DBG Bus recorded data to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_bus_dump_data
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
switch|switch
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|target
condition|)
block|{
case|case
name|DBG_BUS_TARGET_ID_INT_BUF
case|:
return|return
name|ecore_bus_dump_int_buf
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|dump
argument_list|)
return|;
case|case
name|DBG_BUS_TARGET_ID_PCI
case|:
return|return
name|ecore_bus_dump_pci_buf
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|dump
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Frees the Debug Bus PCI buffer */
end_comment

begin_function
specifier|static
name|void
name|ecore_bus_free_pci_buf
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|dma_addr_t
name|pci_buf_phys_addr
decl_stmt|;
name|void
modifier|*
name|virt_addr_lo
decl_stmt|;
name|u32
modifier|*
name|pci_buf
decl_stmt|;
comment|/* Extract PCI buffer pointer from virtual address */
name|virt_addr_lo
operator|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|virt_addr
operator|.
name|lo
expr_stmt|;
name|pci_buf
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|osal_uintptr_t
operator|)
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
name|virt_addr_lo
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
condition|)
return|return;
name|OSAL_MEMCPY
argument_list|(
operator|&
name|pci_buf_phys_addr
argument_list|,
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|phys_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|pci_buf_phys_addr
argument_list|)
argument_list|)
expr_stmt|;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|pci_buf
argument_list|,
name|pci_buf_phys_addr
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
argument_list|)
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps the list of DBG Bus inputs (blocks/Storms) to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_bus_dump_inputs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|char
name|storm_name
index|[
literal|8
index|]
init|=
literal|"?storm"
decl_stmt|;
name|u32
name|block_id
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|u8
name|storm_id
decl_stmt|;
comment|/* Store storms */
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_storm_data
modifier|*
name|storm_bus
init|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm_id
index|]
decl_stmt|;
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm_id
index|]
operator|.
name|enabled
condition|)
continue|continue;
comment|/* Dump section header */
name|storm_name
index|[
literal|0
index|]
operator|=
name|storm
operator|->
name|letter
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"bus_input"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"name"
argument_list|,
name|storm_name
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"id"
argument_list|,
name|storm_bus
operator|->
name|hw_id
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"mode"
argument_list|,
name|s_storm_mode_defs
index|[
name|storm_bus
operator|->
name|mode
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Store blocks */
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_block_data
modifier|*
name|block_bus
init|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
decl_stmt|;
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
condition|)
continue|continue;
comment|/* Dump section header */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"bus_input"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"name"
argument_list|,
name|block
operator|->
name|name
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"line"
argument_list|,
name|block_bus
operator|->
name|line_num
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"en"
argument_list|,
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"shr"
argument_list|,
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_RIGHT_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps the Debug Bus header (params, inputs, data header) to the specified  * buffer. Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_bus_dump_hdr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|char
name|hw_id_mask_str
index|[
literal|16
index|]
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OSAL_SNPRINTF
argument_list|(
name|hw_id_mask_str
argument_list|,
sizeof|sizeof
argument_list|(
name|hw_id_mask_str
argument_list|)
argument_list|,
literal|"0x%x"
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|hw_id_mask
argument_list|)
operator|<
literal|0
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unexpected debug error: invalid HW ID mask\n"
argument_list|)
expr_stmt|;
comment|/* Dump global params */
name|offset
operator|+=
name|ecore_dump_common_global_params
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"dump-type"
argument_list|,
literal|"debug-bus"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"wrap-mode"
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|one_shot_en
condition|?
literal|"one-shot"
else|:
literal|"wrap-around"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"hw-dwords"
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|hw_dwords
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"hw-id-mask"
argument_list|,
name|hw_id_mask_str
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"target"
argument_list|,
name|s_dbg_target_names
index|[
name|dev_data
operator|->
name|bus
operator|.
name|target
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_bus_dump_inputs
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|target
operator|!=
name|DBG_BUS_TARGET_ID_NIG
condition|)
block|{
name|u32
name|recorded_dwords
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dump
condition|)
name|recorded_dwords
operator|=
name|ecore_bus_dump_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"bus_data"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
name|recorded_dwords
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_is_mode_match
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
modifier|*
name|modes_buf_offset
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|bool
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|u8
name|tree_val
decl_stmt|;
comment|/* Get next element from modes tree buffer */
name|tree_val
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_MODE_TREE
index|]
operator|.
name|ptr
operator|)
index|[
operator|(
operator|*
name|modes_buf_offset
operator|)
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|tree_val
condition|)
block|{
case|case
name|INIT_MODE_OP_NOT
case|:
return|return
operator|!
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
name|modes_buf_offset
argument_list|)
return|;
case|case
name|INIT_MODE_OP_OR
case|:
case|case
name|INIT_MODE_OP_AND
case|:
name|arg1
operator|=
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
name|modes_buf_offset
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
name|modes_buf_offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|tree_val
operator|==
name|INIT_MODE_OP_OR
operator|)
condition|?
operator|(
name|arg1
operator|||
name|arg2
operator|)
else|:
operator|(
name|arg1
operator|&&
name|arg2
operator|)
return|;
default|default:
return|return
name|dev_data
operator|->
name|mode_enable
index|[
name|tree_val
operator|-
name|MAX_INIT_MODE_OPS
index|]
operator|>
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if the specified entity (indicated by GRC param) should be  * included in the dump, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|ecore_grc_is_included
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_grc_params
name|grc_param
parameter_list|)
block|{
return|return
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|grc_param
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true of the specified Storm should be included in the dump, false  * otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|ecore_grc_is_storm_included
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_storms
name|storm
parameter_list|)
block|{
return|return
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|dbg_grc_params
operator|)
name|storm
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the specified memory should be included in the dump, false  * otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|ecore_grc_is_mem_included
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|,
name|u8
name|mem_group_id
parameter_list|)
block|{
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
name|u8
name|i
decl_stmt|;
comment|/* Check Storm match */
if|if
condition|(
name|block
operator|->
name|associated_to_storm
operator|&&
operator|!
name|ecore_grc_is_storm_included
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|dbg_storms
operator|)
name|block
operator|->
name|storm_id
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_BIG_RAM_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|big_ram_defs
modifier|*
name|big_ram
init|=
operator|&
name|s_big_ram_defs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mem_group_id
operator|==
name|big_ram
operator|->
name|mem_group_id
operator|||
name|mem_group_id
operator|==
name|big_ram
operator|->
name|ram_mem_group_id
condition|)
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|big_ram
operator|->
name|grc_param
argument_list|)
return|;
block|}
switch|switch
condition|(
name|mem_group_id
condition|)
block|{
case|case
name|MEM_GROUP_PXP_ILT
case|:
case|case
name|MEM_GROUP_PXP_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_PXP
argument_list|)
return|;
case|case
name|MEM_GROUP_RAM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_RAM
argument_list|)
return|;
case|case
name|MEM_GROUP_PBUF
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_PBUF
argument_list|)
return|;
case|case
name|MEM_GROUP_CAU_MEM
case|:
case|case
name|MEM_GROUP_CAU_SB
case|:
case|case
name|MEM_GROUP_CAU_PI
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_CAU
argument_list|)
return|;
case|case
name|MEM_GROUP_QM_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_QM
argument_list|)
return|;
case|case
name|MEM_GROUP_CFC_MEM
case|:
case|case
name|MEM_GROUP_CONN_CFC_MEM
case|:
case|case
name|MEM_GROUP_TASK_CFC_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_CFC
argument_list|)
return|;
case|case
name|MEM_GROUP_IGU_MEM
case|:
case|case
name|MEM_GROUP_IGU_MSIX
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_IGU
argument_list|)
return|;
case|case
name|MEM_GROUP_MULD_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_MULD
argument_list|)
return|;
case|case
name|MEM_GROUP_PRS_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_PRS
argument_list|)
return|;
case|case
name|MEM_GROUP_DMAE_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_DMAE
argument_list|)
return|;
case|case
name|MEM_GROUP_TM_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_TM
argument_list|)
return|;
case|case
name|MEM_GROUP_SDM_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_SDM
argument_list|)
return|;
case|case
name|MEM_GROUP_TDIF_CTX
case|:
case|case
name|MEM_GROUP_RDIF_CTX
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_DIF
argument_list|)
return|;
case|case
name|MEM_GROUP_CM_MEM
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_CM
argument_list|)
return|;
case|case
name|MEM_GROUP_IOR
case|:
return|return
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_IOR
argument_list|)
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Stalls all Storms */
end_comment

begin_function
specifier|static
name|void
name|ecore_grc_stall_storms
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|stall
parameter_list|)
block|{
name|u32
name|reg_addr
decl_stmt|;
name|u8
name|storm_id
decl_stmt|;
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ecore_grc_is_storm_included
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|dbg_storms
operator|)
name|storm_id
argument_list|)
condition|)
continue|continue;
name|reg_addr
operator|=
name|s_storm_defs
index|[
name|storm_id
index|]
operator|.
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_STALL_0_BB_K2
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|reg_addr
argument_list|,
name|stall
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|OSAL_MSLEEP
argument_list|(
name|STALL_DELAY_MS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes all blocks out of reset */
end_comment

begin_function
specifier|static
name|void
name|ecore_grc_unreset_blocks
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|reg_val
index|[
name|MAX_DBG_RESET_REGS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|block_id
decl_stmt|,
name|i
decl_stmt|;
comment|/* Fill reset regs values */
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
if|if
condition|(
name|block
operator|->
name|has_reset_bit
operator|&&
name|block
operator|->
name|unreset
condition|)
name|reg_val
index|[
name|block
operator|->
name|reset_reg
index|]
operator||=
operator|(
literal|1
operator|<<
name|block
operator|->
name|reset_bit_offset
operator|)
expr_stmt|;
block|}
comment|/* Write reset registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_DBG_RESET_REGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|s_reset_regs_defs
index|[
name|i
index|]
operator|.
name|exists
index|[
name|dev_data
operator|->
name|chip_id
index|]
condition|)
continue|continue;
name|reg_val
index|[
name|i
index|]
operator||=
name|s_reset_regs_defs
index|[
name|i
index|]
operator|.
name|unreset_val
expr_stmt|;
if|if
condition|(
name|reg_val
index|[
name|i
index|]
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|s_reset_regs_defs
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|RESET_REG_UNRESET_OFFSET
argument_list|,
name|reg_val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the attention block data of the specified block */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|dbg_attn_block_type_data
modifier|*
name|ecore_get_block_attn_data
parameter_list|(
name|enum
name|block_id
name|block_id
parameter_list|,
name|enum
name|dbg_attn_type
name|attn_type
parameter_list|)
block|{
specifier|const
name|struct
name|dbg_attn_block
modifier|*
name|base_attn_block_arr
init|=
operator|(
specifier|const
expr|struct
name|dbg_attn_block
operator|*
operator|)
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_ATTN_BLOCKS
index|]
operator|.
name|ptr
decl_stmt|;
return|return
operator|&
name|base_attn_block_arr
index|[
name|block_id
index|]
operator|.
name|per_type_data
index|[
name|attn_type
index|]
return|;
block|}
end_function

begin_comment
comment|/* Returns the attention registers of the specified block */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|dbg_attn_reg
modifier|*
name|ecore_get_block_attn_regs
parameter_list|(
name|enum
name|block_id
name|block_id
parameter_list|,
name|enum
name|dbg_attn_type
name|attn_type
parameter_list|,
name|u8
modifier|*
name|num_attn_regs
parameter_list|)
block|{
specifier|const
name|struct
name|dbg_attn_block_type_data
modifier|*
name|block_type_data
init|=
name|ecore_get_block_attn_data
argument_list|(
name|block_id
argument_list|,
name|attn_type
argument_list|)
decl_stmt|;
operator|*
name|num_attn_regs
operator|=
name|block_type_data
operator|->
name|num_regs
expr_stmt|;
return|return
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|dbg_attn_reg
operator|*
operator|)
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_ATTN_REGS
index|]
operator|.
name|ptr
operator|)
index|[
name|block_type_data
operator|->
name|regs_offset
index|]
return|;
block|}
end_function

begin_comment
comment|/* For each block, clear the status of all parities */
end_comment

begin_function
specifier|static
name|void
name|ecore_grc_clear_all_prty
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
specifier|const
name|struct
name|dbg_attn_reg
modifier|*
name|attn_reg_arr
decl_stmt|;
name|u8
name|reg_idx
decl_stmt|,
name|num_attn_regs
decl_stmt|;
name|u32
name|block_id
decl_stmt|;
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|block_id
index|]
condition|)
continue|continue;
name|attn_reg_arr
operator|=
name|ecore_get_block_attn_regs
argument_list|(
operator|(
expr|enum
name|block_id
operator|)
name|block_id
argument_list|,
name|ATTN_TYPE_PARITY
argument_list|,
operator|&
name|num_attn_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_idx
operator|=
literal|0
init|;
name|reg_idx
operator|<
name|num_attn_regs
condition|;
name|reg_idx
operator|++
control|)
block|{
specifier|const
name|struct
name|dbg_attn_reg
modifier|*
name|reg_data
init|=
operator|&
name|attn_reg_arr
index|[
name|reg_idx
index|]
decl_stmt|;
name|u16
name|modes_buf_offset
decl_stmt|;
name|bool
name|eval_mode
decl_stmt|;
comment|/* Check mode */
name|eval_mode
operator|=
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_EVAL_MODE
argument_list|)
operator|>
literal|0
expr_stmt|;
name|modes_buf_offset
operator|=
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_MODES_BUF_OFFSET
argument_list|)
expr_stmt|;
comment|/* If Mode match: clear parity status */
if|if
condition|(
operator|!
name|eval_mode
operator|||
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|modes_buf_offset
argument_list|)
condition|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DWORDS_TO_BYTES
argument_list|(
name|reg_data
operator|->
name|sts_clr_address
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Dumps GRC registers section header. Returns the dumped size in dwords.  * the following parameters are dumped:  * - count:	 no. of dumped entries  * - split:	 split type  * - id:	 split ID (dumped only if split_id>= 0)  * - param_name: user parameter value (dumped only if param_name != OSAL_NULL  *		 and param_val != OSAL_NULL).  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_regs_hdr
parameter_list|(
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
name|num_reg_entries
parameter_list|,
specifier|const
name|char
modifier|*
name|split_type
parameter_list|,
name|int
name|split_id
parameter_list|,
specifier|const
name|char
modifier|*
name|param_name
parameter_list|,
specifier|const
name|char
modifier|*
name|param_val
parameter_list|)
block|{
name|u8
name|num_params
init|=
literal|2
operator|+
operator|(
name|split_id
operator|>=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|param_name
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"grc_regs"
argument_list|,
name|num_params
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"count"
argument_list|,
name|num_reg_entries
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"split"
argument_list|,
name|split_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_id
operator|>=
literal|0
condition|)
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"id"
argument_list|,
name|split_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|param_name
operator|&&
name|param_val
condition|)
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|param_name
argument_list|,
name|param_val
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps the GRC registers in the specified address range.  * Returns the dumped size in dwords.  * The addr and len arguments are specified in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_addr_range
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|len
parameter_list|,
name|bool
name|wide_bus
parameter_list|)
block|{
name|u32
name|byte_addr
init|=
name|DWORDS_TO_BYTES
argument_list|(
name|addr
argument_list|)
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
return|return
name|len
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|byte_addr
operator|+=
name|BYTES_IN_DWORD
operator|,
name|offset
operator|++
control|)
operator|*
operator|(
name|dump_buf
operator|+
name|offset
operator|)
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|byte_addr
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC registers sequence header. Returns the dumped size in dwords.  * The addr and len arguments are specified in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_reg_entry_hdr
parameter_list|(
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|len
parameter_list|)
block|{
if|if
condition|(
name|dump
condition|)
operator|*
name|dump_buf
operator|=
name|addr
operator||
operator|(
name|len
operator|<<
name|REG_DUMP_LEN_SHIFT
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC registers sequence. Returns the dumped size in dwords.  * The addr and len arguments are specified in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_reg_entry
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|len
parameter_list|,
name|bool
name|wide_bus
parameter_list|)
block|{
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_reg_entry_hdr
argument_list|(
name|dump_buf
argument_list|,
name|dump
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|wide_bus
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC registers sequence with skip cycle.  * Returns the dumped size in dwords.  * - addr:	start GRC address in dwords  * - total_len:	total no. of dwords to dump  * - read_len:	no. consecutive dwords to read   * - skip_len:	no. of dwords to skip (and fill with zeros)  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_reg_entry_skip
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|total_len
parameter_list|,
name|u32
name|read_len
parameter_list|,
name|u32
name|skip_len
parameter_list|)
block|{
name|u32
name|offset
init|=
literal|0
decl_stmt|,
name|reg_offset
init|=
literal|0
decl_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_reg_entry_hdr
argument_list|(
name|dump_buf
argument_list|,
name|dump
argument_list|,
name|addr
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
return|return
name|offset
operator|+
name|total_len
return|;
while|while
condition|(
name|reg_offset
operator|<
name|total_len
condition|)
block|{
name|u32
name|curr_len
init|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|read_len
argument_list|,
name|total_len
operator|-
name|reg_offset
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|addr
argument_list|,
name|curr_len
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
name|curr_len
expr_stmt|;
name|addr
operator|+=
name|curr_len
expr_stmt|;
if|if
condition|(
name|reg_offset
operator|<
name|total_len
condition|)
block|{
name|curr_len
operator|=
name|OSAL_MIN_T
argument_list|(
name|u32
argument_list|,
name|skip_len
argument_list|,
name|total_len
operator|-
name|skip_len
argument_list|)
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
literal|0
argument_list|,
name|DWORDS_TO_BYTES
argument_list|(
name|curr_len
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|curr_len
expr_stmt|;
name|reg_offset
operator|+=
name|curr_len
expr_stmt|;
name|addr
operator|+=
name|curr_len
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC registers entries. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_regs_entries
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|dbg_array
name|input_regs_arr
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|bool
name|block_enable
index|[
name|MAX_BLOCK_ID
index|]
parameter_list|,
name|u32
modifier|*
name|num_dumped_reg_entries
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|input_offset
init|=
literal|0
decl_stmt|;
name|bool
name|mode_match
init|=
name|true
decl_stmt|;
operator|*
name|num_dumped_reg_entries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|input_offset
operator|<
name|input_regs_arr
operator|.
name|size_in_dwords
condition|)
block|{
specifier|const
name|struct
name|dbg_dump_cond_hdr
modifier|*
name|cond_hdr
init|=
operator|(
specifier|const
expr|struct
name|dbg_dump_cond_hdr
operator|*
operator|)
operator|&
name|input_regs_arr
operator|.
name|ptr
index|[
name|input_offset
operator|++
index|]
decl_stmt|;
name|u16
name|modes_buf_offset
decl_stmt|;
name|bool
name|eval_mode
decl_stmt|;
comment|/* Check mode/block */
name|eval_mode
operator|=
name|GET_FIELD
argument_list|(
name|cond_hdr
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_EVAL_MODE
argument_list|)
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|eval_mode
condition|)
block|{
name|modes_buf_offset
operator|=
name|GET_FIELD
argument_list|(
name|cond_hdr
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_MODES_BUF_OFFSET
argument_list|)
expr_stmt|;
name|mode_match
operator|=
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|modes_buf_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mode_match
operator|||
operator|!
name|block_enable
index|[
name|cond_hdr
operator|->
name|block_id
index|]
condition|)
block|{
name|input_offset
operator|+=
name|cond_hdr
operator|->
name|data_size
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cond_hdr
operator|->
name|data_size
condition|;
name|i
operator|++
operator|,
name|input_offset
operator|++
control|)
block|{
specifier|const
name|struct
name|dbg_dump_reg
modifier|*
name|reg
init|=
operator|(
specifier|const
expr|struct
name|dbg_dump_reg
operator|*
operator|)
operator|&
name|input_regs_arr
operator|.
name|ptr
index|[
name|input_offset
index|]
decl_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_reg_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|data
argument_list|,
name|DBG_DUMP_REG_ADDRESS
argument_list|)
argument_list|,
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|data
argument_list|,
name|DBG_DUMP_REG_LENGTH
argument_list|)
argument_list|,
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|data
argument_list|,
name|DBG_DUMP_REG_WIDE_BUS
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num_dumped_reg_entries
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC registers entries. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_split_data
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|dbg_array
name|input_regs_arr
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|bool
name|block_enable
index|[
name|MAX_BLOCK_ID
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|split_type_name
parameter_list|,
name|u32
name|split_id
parameter_list|,
specifier|const
name|char
modifier|*
name|param_name
parameter_list|,
specifier|const
name|char
modifier|*
name|param_val
parameter_list|)
block|{
name|u32
name|num_dumped_reg_entries
decl_stmt|,
name|offset
decl_stmt|;
comment|/* Calculate register dump header size (and skip it for now) */
name|offset
operator|=
name|ecore_grc_dump_regs_hdr
argument_list|(
name|dump_buf
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|split_type_name
argument_list|,
name|split_id
argument_list|,
name|param_name
argument_list|,
name|param_val
argument_list|)
expr_stmt|;
comment|/* Dump registers */
name|offset
operator|+=
name|ecore_grc_dump_regs_entries
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|input_regs_arr
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|block_enable
argument_list|,
operator|&
name|num_dumped_reg_entries
argument_list|)
expr_stmt|;
comment|/* Write register dump header */
if|if
condition|(
name|dump
operator|&&
name|num_dumped_reg_entries
operator|>
literal|0
condition|)
name|ecore_grc_dump_regs_hdr
argument_list|(
name|dump_buf
argument_list|,
name|dump
argument_list|,
name|num_dumped_reg_entries
argument_list|,
name|split_type_name
argument_list|,
name|split_id
argument_list|,
name|param_name
argument_list|,
name|param_val
argument_list|)
expr_stmt|;
return|return
name|num_dumped_reg_entries
operator|>
literal|0
condition|?
name|offset
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Dumps registers according to the input registers array. Returns the dumped  * size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_registers
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|bool
name|block_enable
index|[
name|MAX_BLOCK_ID
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|param_name
parameter_list|,
specifier|const
name|char
modifier|*
name|param_val
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|chip_platform_defs
modifier|*
name|chip_platform
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|,
name|input_offset
init|=
literal|0
decl_stmt|;
name|u8
name|port_id
decl_stmt|,
name|pf_id
decl_stmt|,
name|vf_id
decl_stmt|;
name|chip_platform
operator|=
operator|&
name|s_chip_defs
index|[
name|dev_data
operator|->
name|chip_id
index|]
operator|.
name|per_platform
index|[
name|dev_data
operator|->
name|platform_id
index|]
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"Dumping registers...\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|input_offset
operator|<
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_DUMP_REG
index|]
operator|.
name|size_in_dwords
condition|)
block|{
specifier|const
name|struct
name|dbg_dump_split_hdr
modifier|*
name|split_hdr
decl_stmt|;
name|struct
name|dbg_array
name|curr_input_regs_arr
decl_stmt|;
name|u32
name|split_data_size
decl_stmt|;
name|u8
name|split_type_id
decl_stmt|;
name|split_hdr
operator|=
operator|(
specifier|const
expr|struct
name|dbg_dump_split_hdr
operator|*
operator|)
operator|&
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_DUMP_REG
index|]
operator|.
name|ptr
index|[
name|input_offset
operator|++
index|]
expr_stmt|;
name|split_type_id
operator|=
name|GET_FIELD
argument_list|(
name|split_hdr
operator|->
name|hdr
argument_list|,
name|DBG_DUMP_SPLIT_HDR_SPLIT_TYPE_ID
argument_list|)
expr_stmt|;
name|split_data_size
operator|=
name|GET_FIELD
argument_list|(
name|split_hdr
operator|->
name|hdr
argument_list|,
name|DBG_DUMP_SPLIT_HDR_DATA_SIZE
argument_list|)
expr_stmt|;
name|curr_input_regs_arr
operator|.
name|ptr
operator|=
operator|&
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_DUMP_REG
index|]
operator|.
name|ptr
index|[
name|input_offset
index|]
expr_stmt|;
name|curr_input_regs_arr
operator|.
name|size_in_dwords
operator|=
name|split_data_size
expr_stmt|;
switch|switch
condition|(
name|split_type_id
condition|)
block|{
case|case
name|SPLIT_TYPE_NONE
case|:
name|offset
operator|+=
name|ecore_grc_dump_split_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|curr_input_regs_arr
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|block_enable
argument_list|,
literal|"eng"
argument_list|,
call|(
name|u32
call|)
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|param_name
argument_list|,
name|param_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPLIT_TYPE_PORT
case|:
for|for
control|(
name|port_id
operator|=
literal|0
init|;
name|port_id
operator|<
name|chip_platform
operator|->
name|num_ports
condition|;
name|port_id
operator|++
control|)
block|{
if|if
condition|(
name|dump
condition|)
name|ecore_port_pretend
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_split_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|curr_input_regs_arr
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|block_enable
argument_list|,
literal|"port"
argument_list|,
name|port_id
argument_list|,
name|param_name
argument_list|,
name|param_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPLIT_TYPE_PF
case|:
case|case
name|SPLIT_TYPE_PORT_PF
case|:
for|for
control|(
name|pf_id
operator|=
literal|0
init|;
name|pf_id
operator|<
name|chip_platform
operator|->
name|num_pfs
condition|;
name|pf_id
operator|++
control|)
block|{
if|if
condition|(
name|dump
condition|)
name|ecore_fid_pretend
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|pf_id
operator|<<
name|PXP_PRETEND_CONCRETE_FID_PFID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_split_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|curr_input_regs_arr
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|block_enable
argument_list|,
literal|"pf"
argument_list|,
name|pf_id
argument_list|,
name|param_name
argument_list|,
name|param_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPLIT_TYPE_VF
case|:
for|for
control|(
name|vf_id
operator|=
literal|0
init|;
name|vf_id
operator|<
name|chip_platform
operator|->
name|num_vfs
condition|;
name|vf_id
operator|++
control|)
block|{
if|if
condition|(
name|dump
condition|)
name|ecore_fid_pretend
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
literal|1
operator|<<
name|PXP_PRETEND_CONCRETE_FID_VFVALID_SHIFT
operator|)
operator||
operator|(
name|vf_id
operator|<<
name|PXP_PRETEND_CONCRETE_FID_VFID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_split_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|curr_input_regs_arr
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|block_enable
argument_list|,
literal|"vf"
argument_list|,
name|vf_id
argument_list|,
name|param_name
argument_list|,
name|param_val
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|input_offset
operator|+=
name|split_data_size
expr_stmt|;
block|}
comment|/* Pretend to original PF */
if|if
condition|(
name|dump
condition|)
name|ecore_fid_pretend
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
name|p_hwfn
operator|->
name|rel_pf_id
operator|<<
name|PXP_PRETEND_CONCRETE_FID_PFID_SHIFT
operator|)
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dump reset registers. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_reset_regs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|num_regs
init|=
literal|0
decl_stmt|;
comment|/* Calculate header size */
name|offset
operator|+=
name|ecore_grc_dump_regs_hdr
argument_list|(
name|dump_buf
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"eng"
argument_list|,
operator|-
literal|1
argument_list|,
name|OSAL_NULL
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
comment|/* Write reset registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_DBG_RESET_REGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|s_reset_regs_defs
index|[
name|i
index|]
operator|.
name|exists
index|[
name|dev_data
operator|->
name|chip_id
index|]
condition|)
continue|continue;
name|offset
operator|+=
name|ecore_grc_dump_reg_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|s_reset_regs_defs
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|num_regs
operator|++
expr_stmt|;
block|}
comment|/* Write header */
if|if
condition|(
name|dump
condition|)
name|ecore_grc_dump_regs_hdr
argument_list|(
name|dump_buf
argument_list|,
name|true
argument_list|,
name|num_regs
argument_list|,
literal|"eng"
argument_list|,
operator|-
literal|1
argument_list|,
name|OSAL_NULL
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dump registers that are modified during GRC Dump and therefore must be  * dumped first. Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_modified_regs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|block_id
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|num_reg_entries
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|dbg_attn_reg
modifier|*
name|attn_reg_arr
decl_stmt|;
name|u8
name|storm_id
decl_stmt|,
name|reg_idx
decl_stmt|,
name|num_attn_regs
decl_stmt|;
comment|/* Calculate header size */
name|offset
operator|+=
name|ecore_grc_dump_regs_hdr
argument_list|(
name|dump_buf
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"eng"
argument_list|,
operator|-
literal|1
argument_list|,
name|OSAL_NULL
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
comment|/* Write parity registers */
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|block_id
index|]
operator|&&
name|dump
condition|)
continue|continue;
name|attn_reg_arr
operator|=
name|ecore_get_block_attn_regs
argument_list|(
operator|(
expr|enum
name|block_id
operator|)
name|block_id
argument_list|,
name|ATTN_TYPE_PARITY
argument_list|,
operator|&
name|num_attn_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_idx
operator|=
literal|0
init|;
name|reg_idx
operator|<
name|num_attn_regs
condition|;
name|reg_idx
operator|++
control|)
block|{
specifier|const
name|struct
name|dbg_attn_reg
modifier|*
name|reg_data
init|=
operator|&
name|attn_reg_arr
index|[
name|reg_idx
index|]
decl_stmt|;
name|u16
name|modes_buf_offset
decl_stmt|;
name|bool
name|eval_mode
decl_stmt|;
comment|/* Check mode */
name|eval_mode
operator|=
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_EVAL_MODE
argument_list|)
operator|>
literal|0
expr_stmt|;
name|modes_buf_offset
operator|=
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_MODES_BUF_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval_mode
operator|&&
operator|!
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|modes_buf_offset
argument_list|)
condition|)
continue|continue;
comment|/* Mode match: read& dump registers */
name|offset
operator|+=
name|ecore_grc_dump_reg_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|reg_data
operator|->
name|mask_address
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_reg_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|data
argument_list|,
name|DBG_ATTN_REG_STS_ADDRESS
argument_list|)
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|num_reg_entries
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Write Storm stall status registers */
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|storm
operator|->
name|block_id
index|]
operator|&&
name|dump
condition|)
continue|continue;
name|offset
operator|+=
name|ecore_grc_dump_reg_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_STALLED
argument_list|)
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|num_reg_entries
operator|++
expr_stmt|;
block|}
comment|/* Write header */
if|if
condition|(
name|dump
condition|)
name|ecore_grc_dump_regs_hdr
argument_list|(
name|dump_buf
argument_list|,
name|true
argument_list|,
name|num_reg_entries
argument_list|,
literal|"eng"
argument_list|,
operator|-
literal|1
argument_list|,
name|OSAL_NULL
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps registers that can't be represented in the debug arrays */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_special_regs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_regs_hdr
argument_list|(
name|dump_buf
argument_list|,
name|dump
argument_list|,
literal|2
argument_list|,
literal|"eng"
argument_list|,
operator|-
literal|1
argument_list|,
name|OSAL_NULL
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
comment|/* Dump R/TDIF_REG_DEBUG_ERROR_INFO_SIZE (every 8'th register should be 	 * skipped). 	 */
name|offset
operator|+=
name|ecore_grc_dump_reg_entry_skip
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|RDIF_REG_DEBUG_ERROR_INFO
argument_list|)
argument_list|,
name|RDIF_REG_DEBUG_ERROR_INFO_SIZE
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_reg_entry_skip
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|TDIF_REG_DEBUG_ERROR_INFO
argument_list|)
argument_list|,
name|TDIF_REG_DEBUG_ERROR_INFO_SIZE
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps a GRC memory header (section and params). Returns the dumped size in  * dwords. The following parameters are dumped:  * - name:	   dumped only if it's not OSAL_NULL.  * - addr:	   in dwords, dumped only if name is OSAL_NULL.  * - len:	   in dwords, always dumped.  * - width:	   dumped if it's not zero.  * - packed:	   dumped only if it's not false.  * - mem_group:	   always dumped.  * - is_storm:	   true only if the memory is related to a Storm.  * - storm_letter: valid only if is_storm is true.  *  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_mem_hdr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|len
parameter_list|,
name|u32
name|bit_width
parameter_list|,
name|bool
name|packed
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_group
parameter_list|,
name|bool
name|is_storm
parameter_list|,
name|char
name|storm_letter
parameter_list|)
block|{
name|u8
name|num_params
init|=
literal|3
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unexpected GRC Dump error: dumped memory size must be non-zero\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_width
condition|)
name|num_params
operator|++
expr_stmt|;
if|if
condition|(
name|packed
condition|)
name|num_params
operator|++
expr_stmt|;
comment|/* Dump section header */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"grc_mem"
argument_list|,
name|num_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Dump name */
if|if
condition|(
name|is_storm
condition|)
block|{
name|OSAL_STRCPY
argument_list|(
name|buf
argument_list|,
literal|"?STORM_"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|storm_letter
expr_stmt|;
name|OSAL_STRCPY
argument_list|(
name|buf
operator|+
name|OSAL_STRLEN
argument_list|(
name|buf
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSAL_STRCPY
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"name"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"Dumping %d registers from %s...\n"
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Dump address */
name|u32
name|addr_in_bytes
init|=
name|DWORDS_TO_BYTES
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"addr"
argument_list|,
name|addr_in_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
operator|&&
name|len
operator|>
literal|64
condition|)
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"Dumping %d registers from address 0x%x...\n"
argument_list|,
name|len
argument_list|,
name|addr_in_bytes
argument_list|)
expr_stmt|;
block|}
comment|/* Dump len */
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"len"
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Dump bit width */
if|if
condition|(
name|bit_width
condition|)
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"width"
argument_list|,
name|bit_width
argument_list|)
expr_stmt|;
comment|/* Dump packed */
if|if
condition|(
name|packed
condition|)
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"packed"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Dump reg type */
if|if
condition|(
name|is_storm
condition|)
block|{
name|OSAL_STRCPY
argument_list|(
name|buf
argument_list|,
literal|"?STORM_"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|storm_letter
expr_stmt|;
name|OSAL_STRCPY
argument_list|(
name|buf
operator|+
name|OSAL_STRLEN
argument_list|(
name|buf
argument_list|)
argument_list|,
name|mem_group
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSAL_STRCPY
argument_list|(
name|buf
argument_list|,
name|mem_group
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"type"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps a single GRC memory. If name is OSAL_NULL, the memory is stored by address.  * Returns the dumped size in dwords.  * The addr and len arguments are specified in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_mem
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u32
name|len
parameter_list|,
name|bool
name|wide_bus
parameter_list|,
name|u32
name|bit_width
parameter_list|,
name|bool
name|packed
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_group
parameter_list|,
name|bool
name|is_storm
parameter_list|,
name|char
name|storm_letter
parameter_list|)
block|{
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_mem_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|name
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|bit_width
argument_list|,
name|packed
argument_list|,
name|mem_group
argument_list|,
name|is_storm
argument_list|,
name|storm_letter
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|wide_bus
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC memories entries. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_mem_entries
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|struct
name|dbg_array
name|input_mems_arr
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|input_offset
init|=
literal|0
decl_stmt|;
name|bool
name|mode_match
init|=
name|true
decl_stmt|;
while|while
condition|(
name|input_offset
operator|<
name|input_mems_arr
operator|.
name|size_in_dwords
condition|)
block|{
specifier|const
name|struct
name|dbg_dump_cond_hdr
modifier|*
name|cond_hdr
decl_stmt|;
name|u16
name|modes_buf_offset
decl_stmt|;
name|u32
name|num_entries
decl_stmt|;
name|bool
name|eval_mode
decl_stmt|;
name|cond_hdr
operator|=
operator|(
specifier|const
expr|struct
name|dbg_dump_cond_hdr
operator|*
operator|)
operator|&
name|input_mems_arr
operator|.
name|ptr
index|[
name|input_offset
operator|++
index|]
expr_stmt|;
name|num_entries
operator|=
name|cond_hdr
operator|->
name|data_size
operator|/
name|MEM_DUMP_ENTRY_SIZE_DWORDS
expr_stmt|;
comment|/* Check required mode */
name|eval_mode
operator|=
name|GET_FIELD
argument_list|(
name|cond_hdr
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_EVAL_MODE
argument_list|)
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|eval_mode
condition|)
block|{
name|modes_buf_offset
operator|=
name|GET_FIELD
argument_list|(
name|cond_hdr
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_MODES_BUF_OFFSET
argument_list|)
expr_stmt|;
name|mode_match
operator|=
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|modes_buf_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mode_match
condition|)
block|{
name|input_offset
operator|+=
name|cond_hdr
operator|->
name|data_size
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
operator|,
name|input_offset
operator|+=
name|MEM_DUMP_ENTRY_SIZE_DWORDS
control|)
block|{
specifier|const
name|struct
name|dbg_dump_mem
modifier|*
name|mem
init|=
operator|(
specifier|const
expr|struct
name|dbg_dump_mem
operator|*
operator|)
operator|&
name|input_mems_arr
operator|.
name|ptr
index|[
name|input_offset
index|]
decl_stmt|;
name|u8
name|mem_group_id
init|=
name|GET_FIELD
argument_list|(
name|mem
operator|->
name|dword0
argument_list|,
name|DBG_DUMP_MEM_MEM_GROUP_ID
argument_list|)
decl_stmt|;
name|bool
name|is_storm
init|=
name|false
decl_stmt|,
name|mem_wide_bus
decl_stmt|;
name|char
name|storm_letter
init|=
literal|'a'
decl_stmt|;
name|u32
name|mem_addr
decl_stmt|,
name|mem_len
decl_stmt|;
if|if
condition|(
name|mem_group_id
operator|>=
name|MEM_GROUPS_NUM
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid mem_group_id\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ecore_grc_is_mem_included
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|block_id
operator|)
name|cond_hdr
operator|->
name|block_id
argument_list|,
name|mem_group_id
argument_list|)
condition|)
continue|continue;
name|mem_addr
operator|=
name|GET_FIELD
argument_list|(
name|mem
operator|->
name|dword0
argument_list|,
name|DBG_DUMP_MEM_ADDRESS
argument_list|)
expr_stmt|;
name|mem_len
operator|=
name|GET_FIELD
argument_list|(
name|mem
operator|->
name|dword1
argument_list|,
name|DBG_DUMP_MEM_LENGTH
argument_list|)
expr_stmt|;
name|mem_wide_bus
operator|=
name|GET_FIELD
argument_list|(
name|mem
operator|->
name|dword1
argument_list|,
name|DBG_DUMP_MEM_WIDE_BUS
argument_list|)
expr_stmt|;
comment|/* Update memory length for CCFC/TCFC memories 			 * according to number of LCIDs/LTIDs. 			 */
if|if
condition|(
name|mem_group_id
operator|==
name|MEM_GROUP_CONN_CFC_MEM
condition|)
block|{
if|if
condition|(
name|mem_len
operator|%
name|MAX_LCIDS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid CCFC connection memory size\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mem_len
operator|=
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NUM_LCIDS
argument_list|)
operator|*
operator|(
name|mem_len
operator|/
name|MAX_LCIDS
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mem_group_id
operator|==
name|MEM_GROUP_TASK_CFC_MEM
condition|)
block|{
if|if
condition|(
name|mem_len
operator|%
name|MAX_LTIDS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid TCFC task memory size\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mem_len
operator|=
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NUM_LTIDS
argument_list|)
operator|*
operator|(
name|mem_len
operator|/
name|MAX_LTIDS
operator|)
expr_stmt|;
block|}
comment|/* If memory is associated with Storm, udpate Storm 			 * details. 			 */
if|if
condition|(
name|s_block_defs
index|[
name|cond_hdr
operator|->
name|block_id
index|]
operator|->
name|associated_to_storm
condition|)
block|{
name|is_storm
operator|=
name|true
expr_stmt|;
name|storm_letter
operator|=
name|s_storm_defs
index|[
name|s_block_defs
index|[
name|cond_hdr
operator|->
name|block_id
index|]
operator|->
name|storm_id
index|]
operator|.
name|letter
expr_stmt|;
block|}
comment|/* Dump memory */
name|offset
operator|+=
name|ecore_grc_dump_mem
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|OSAL_NULL
argument_list|,
name|mem_addr
argument_list|,
name|mem_len
argument_list|,
name|mem_wide_bus
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|s_mem_group_names
index|[
name|mem_group_id
index|]
argument_list|,
name|is_storm
argument_list|,
name|storm_letter
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC memories according to the input array dump_mem.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_memories
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|u32
name|offset
init|=
literal|0
decl_stmt|,
name|input_offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|input_offset
operator|<
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_DUMP_MEM
index|]
operator|.
name|size_in_dwords
condition|)
block|{
specifier|const
name|struct
name|dbg_dump_split_hdr
modifier|*
name|split_hdr
decl_stmt|;
name|struct
name|dbg_array
name|curr_input_mems_arr
decl_stmt|;
name|u32
name|split_data_size
decl_stmt|;
name|u8
name|split_type_id
decl_stmt|;
name|split_hdr
operator|=
operator|(
specifier|const
expr|struct
name|dbg_dump_split_hdr
operator|*
operator|)
operator|&
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_DUMP_MEM
index|]
operator|.
name|ptr
index|[
name|input_offset
operator|++
index|]
expr_stmt|;
name|split_type_id
operator|=
name|GET_FIELD
argument_list|(
name|split_hdr
operator|->
name|hdr
argument_list|,
name|DBG_DUMP_SPLIT_HDR_SPLIT_TYPE_ID
argument_list|)
expr_stmt|;
name|split_data_size
operator|=
name|GET_FIELD
argument_list|(
name|split_hdr
operator|->
name|hdr
argument_list|,
name|DBG_DUMP_SPLIT_HDR_DATA_SIZE
argument_list|)
expr_stmt|;
name|curr_input_mems_arr
operator|.
name|ptr
operator|=
operator|&
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_DUMP_MEM
index|]
operator|.
name|ptr
index|[
name|input_offset
index|]
expr_stmt|;
name|curr_input_mems_arr
operator|.
name|size_in_dwords
operator|=
name|split_data_size
expr_stmt|;
switch|switch
condition|(
name|split_type_id
condition|)
block|{
case|case
name|SPLIT_TYPE_NONE
case|:
name|offset
operator|+=
name|ecore_grc_dump_mem_entries
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|curr_input_mems_arr
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Dumping split memories is currently not supported\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|input_offset
operator|+=
name|split_data_size
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC context data for the specified Storm.  * Returns the dumped size in dwords.  * The lid_size argument is specified in quad-regs.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_ctx_data
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u32
name|num_lids
parameter_list|,
name|u32
name|lid_size
parameter_list|,
name|u32
name|rd_reg_addr
parameter_list|,
name|u8
name|storm_id
parameter_list|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|lid
decl_stmt|,
name|total_size
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|lid_size
condition|)
return|return
literal|0
return|;
name|lid_size
operator|*=
name|BYTES_IN_DWORD
expr_stmt|;
name|total_size
operator|=
name|num_lids
operator|*
name|lid_size
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_mem_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|total_size
argument_list|,
name|lid_size
operator|*
literal|32
argument_list|,
name|false
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|storm
operator|->
name|letter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
return|return
name|offset
operator|+
name|total_size
return|;
comment|/* Dump context data */
for|for
control|(
name|lid
operator|=
literal|0
init|;
name|lid
operator|<
name|num_lids
condition|;
name|lid
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lid_size
condition|;
name|i
operator|++
operator|,
name|offset
operator|++
control|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|cm_ctx_wr_addr
argument_list|,
operator|(
name|i
operator|<<
literal|9
operator|)
operator||
name|lid
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dump_buf
operator|+
name|offset
operator|)
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|rd_reg_addr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC contexts. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_ctx
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|u8
name|storm_id
decl_stmt|;
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ecore_grc_is_storm_included
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|dbg_storms
operator|)
name|storm_id
argument_list|)
condition|)
continue|continue;
comment|/* Dump Conn AG context size */
name|offset
operator|+=
name|ecore_grc_dump_ctx_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"CONN_AG_CTX"
argument_list|,
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NUM_LCIDS
argument_list|)
argument_list|,
name|storm
operator|->
name|cm_conn_ag_ctx_lid_size
argument_list|,
name|storm
operator|->
name|cm_conn_ag_ctx_rd_addr
argument_list|,
name|storm_id
argument_list|)
expr_stmt|;
comment|/* Dump Conn ST context size */
name|offset
operator|+=
name|ecore_grc_dump_ctx_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"CONN_ST_CTX"
argument_list|,
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NUM_LCIDS
argument_list|)
argument_list|,
name|storm
operator|->
name|cm_conn_st_ctx_lid_size
argument_list|,
name|storm
operator|->
name|cm_conn_st_ctx_rd_addr
argument_list|,
name|storm_id
argument_list|)
expr_stmt|;
comment|/* Dump Task AG context size */
name|offset
operator|+=
name|ecore_grc_dump_ctx_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"TASK_AG_CTX"
argument_list|,
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NUM_LTIDS
argument_list|)
argument_list|,
name|storm
operator|->
name|cm_task_ag_ctx_lid_size
argument_list|,
name|storm
operator|->
name|cm_task_ag_ctx_rd_addr
argument_list|,
name|storm_id
argument_list|)
expr_stmt|;
comment|/* Dump Task ST context size */
name|offset
operator|+=
name|ecore_grc_dump_ctx_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"TASK_ST_CTX"
argument_list|,
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NUM_LTIDS
argument_list|)
argument_list|,
name|storm
operator|->
name|cm_task_st_ctx_lid_size
argument_list|,
name|storm
operator|->
name|cm_task_st_ctx_rd_addr
argument_list|,
name|storm_id
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC IORs data. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_iors
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|char
name|buf
index|[
literal|10
index|]
init|=
literal|"IOR_SET_?"
decl_stmt|;
name|u32
name|addr
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|u8
name|storm_id
decl_stmt|,
name|set_id
decl_stmt|;
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ecore_grc_is_storm_included
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|dbg_storms
operator|)
name|storm_id
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|set_id
operator|=
literal|0
init|;
name|set_id
operator|<
name|NUM_IOR_SETS
condition|;
name|set_id
operator|++
control|)
block|{
name|addr
operator|=
name|BYTES_TO_DWORDS
argument_list|(
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_STORM_REG_FILE
argument_list|)
operator|+
name|IOR_SET_OFFSET
argument_list|(
name|set_id
argument_list|)
expr_stmt|;
name|buf
index|[
name|OSAL_STRLEN
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'0'
operator|+
name|set_id
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_mem
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|buf
argument_list|,
name|addr
argument_list|,
name|IORS_PER_SET
argument_list|,
name|false
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|"ior"
argument_list|,
name|true
argument_list|,
name|storm
operator|->
name|letter
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dump VFC CAM. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_vfc_cam
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u8
name|storm_id
parameter_list|)
block|{
name|u32
name|total_size
init|=
name|VFC_CAM_NUM_ROWS
operator|*
name|VFC_CAM_RESP_DWORDS
decl_stmt|;
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
name|u32
name|cam_addr
index|[
name|VFC_CAM_ADDR_DWORDS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|cam_cmd
index|[
name|VFC_CAM_CMD_DWORDS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|row
decl_stmt|,
name|i
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_mem_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"vfc_cam"
argument_list|,
literal|0
argument_list|,
name|total_size
argument_list|,
literal|256
argument_list|,
name|false
argument_list|,
literal|"vfc_cam"
argument_list|,
name|true
argument_list|,
name|storm
operator|->
name|letter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
return|return
name|offset
operator|+
name|total_size
return|;
comment|/* Prepare CAM address */
name|SET_VAR_FIELD
argument_list|(
name|cam_addr
argument_list|,
name|VFC_CAM_ADDR
argument_list|,
name|OP
argument_list|,
name|VFC_OPCODE_CAM_RD
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|VFC_CAM_NUM_ROWS
condition|;
name|row
operator|++
operator|,
name|offset
operator|+=
name|VFC_CAM_RESP_DWORDS
control|)
block|{
comment|/* Write VFC CAM command */
name|SET_VAR_FIELD
argument_list|(
name|cam_cmd
argument_list|,
name|VFC_CAM_CMD
argument_list|,
name|ROW
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|ARR_REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_VFC_DATA_WR
argument_list|,
name|cam_cmd
argument_list|,
name|VFC_CAM_CMD_DWORDS
argument_list|)
expr_stmt|;
comment|/* Write VFC CAM address */
name|ARR_REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_VFC_ADDR
argument_list|,
name|cam_addr
argument_list|,
name|VFC_CAM_ADDR_DWORDS
argument_list|)
expr_stmt|;
comment|/* Read VFC CAM read response */
name|ARR_REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_VFC_DATA_RD
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|VFC_CAM_RESP_DWORDS
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dump VFC RAM. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_vfc_ram
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u8
name|storm_id
parameter_list|,
name|struct
name|vfc_ram_defs
modifier|*
name|ram_defs
parameter_list|)
block|{
name|u32
name|total_size
init|=
name|ram_defs
operator|->
name|num_rows
operator|*
name|VFC_RAM_RESP_DWORDS
decl_stmt|;
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
name|u32
name|ram_addr
index|[
name|VFC_RAM_ADDR_DWORDS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|ram_cmd
index|[
name|VFC_RAM_CMD_DWORDS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|row
decl_stmt|,
name|i
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_mem_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|ram_defs
operator|->
name|mem_name
argument_list|,
literal|0
argument_list|,
name|total_size
argument_list|,
literal|256
argument_list|,
name|false
argument_list|,
name|ram_defs
operator|->
name|type_name
argument_list|,
name|true
argument_list|,
name|storm
operator|->
name|letter
argument_list|)
expr_stmt|;
comment|/* Prepare RAM address */
name|SET_VAR_FIELD
argument_list|(
name|ram_addr
argument_list|,
name|VFC_RAM_ADDR
argument_list|,
name|OP
argument_list|,
name|VFC_OPCODE_RAM_RD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
return|return
name|offset
operator|+
name|total_size
return|;
for|for
control|(
name|row
operator|=
name|ram_defs
operator|->
name|base_row
init|;
name|row
operator|<
name|ram_defs
operator|->
name|base_row
operator|+
name|ram_defs
operator|->
name|num_rows
condition|;
name|row
operator|++
operator|,
name|offset
operator|+=
name|VFC_RAM_RESP_DWORDS
control|)
block|{
comment|/* Write VFC RAM command */
name|ARR_REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_VFC_DATA_WR
argument_list|,
name|ram_cmd
argument_list|,
name|VFC_RAM_CMD_DWORDS
argument_list|)
expr_stmt|;
comment|/* Write VFC RAM address */
name|SET_VAR_FIELD
argument_list|(
name|ram_addr
argument_list|,
name|VFC_RAM_ADDR
argument_list|,
name|ROW
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|ARR_REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_VFC_ADDR
argument_list|,
name|ram_addr
argument_list|,
name|VFC_RAM_ADDR_DWORDS
argument_list|)
expr_stmt|;
comment|/* Read VFC RAM read response */
name|ARR_REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_VFC_DATA_RD
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|VFC_RAM_RESP_DWORDS
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC VFC data. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_vfc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u8
name|storm_id
decl_stmt|,
name|i
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ecore_grc_is_storm_included
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|dbg_storms
operator|)
name|storm_id
argument_list|)
operator|||
operator|!
name|s_storm_defs
index|[
name|storm_id
index|]
operator|.
name|has_vfc
operator|||
operator|(
name|storm_id
operator|==
name|DBG_PSTORM_ID
operator|&&
name|dev_data
operator|->
name|platform_id
operator|!=
name|PLATFORM_ASIC
operator|)
condition|)
continue|continue;
comment|/* Read CAM */
name|offset
operator|+=
name|ecore_grc_dump_vfc_cam
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|storm_id
argument_list|)
expr_stmt|;
comment|/* Read RAM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_VFC_RAM_TYPES
condition|;
name|i
operator|++
control|)
name|offset
operator|+=
name|ecore_grc_dump_vfc_ram
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|storm_id
argument_list|,
operator|&
name|s_vfc_ram_defs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC RSS data. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_rss
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|u8
name|rss_mem_id
decl_stmt|;
for|for
control|(
name|rss_mem_id
operator|=
literal|0
init|;
name|rss_mem_id
operator|<
name|NUM_RSS_MEM_TYPES
condition|;
name|rss_mem_id
operator|++
control|)
block|{
name|u32
name|rss_addr
decl_stmt|,
name|num_entries
decl_stmt|,
name|entry_width
decl_stmt|,
name|total_dwords
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|rss_mem_defs
modifier|*
name|rss_defs
decl_stmt|;
name|bool
name|packed
decl_stmt|;
name|rss_defs
operator|=
operator|&
name|s_rss_mem_defs
index|[
name|rss_mem_id
index|]
expr_stmt|;
name|rss_addr
operator|=
name|rss_defs
operator|->
name|addr
expr_stmt|;
name|num_entries
operator|=
name|rss_defs
operator|->
name|num_entries
index|[
name|dev_data
operator|->
name|chip_id
index|]
expr_stmt|;
name|entry_width
operator|=
name|rss_defs
operator|->
name|entry_width
index|[
name|dev_data
operator|->
name|chip_id
index|]
expr_stmt|;
name|total_dwords
operator|=
operator|(
name|num_entries
operator|*
name|entry_width
operator|)
operator|/
literal|32
expr_stmt|;
name|packed
operator|=
operator|(
name|entry_width
operator|==
literal|16
operator|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_mem_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|rss_defs
operator|->
name|mem_name
argument_list|,
literal|0
argument_list|,
name|total_dwords
argument_list|,
name|entry_width
argument_list|,
name|packed
argument_list|,
name|rss_defs
operator|->
name|type_name
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dump RSS data */
if|if
condition|(
operator|!
name|dump
condition|)
block|{
name|offset
operator|+=
name|total_dwords
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_dwords
condition|;
name|i
operator|+=
name|RSS_REG_RSS_RAM_DATA_SIZE
operator|,
name|rss_addr
operator|++
control|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|RSS_REG_RSS_RAM_ADDR
argument_list|,
name|rss_addr
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|RSS_REG_RSS_RAM_DATA
argument_list|)
argument_list|,
name|RSS_REG_RSS_RAM_DATA_SIZE
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps GRC Big RAM. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_big_ram
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u8
name|big_ram_id
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|total_blocks
decl_stmt|,
name|ram_size
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|char
name|mem_name
index|[
literal|12
index|]
init|=
literal|"???_BIG_RAM"
decl_stmt|;
name|char
name|type_name
index|[
literal|8
index|]
init|=
literal|"???_RAM"
decl_stmt|;
name|struct
name|big_ram_defs
modifier|*
name|big_ram
decl_stmt|;
name|big_ram
operator|=
operator|&
name|s_big_ram_defs
index|[
name|big_ram_id
index|]
expr_stmt|;
name|total_blocks
operator|=
name|big_ram
operator|->
name|num_of_blocks
index|[
name|dev_data
operator|->
name|chip_id
index|]
expr_stmt|;
name|ram_size
operator|=
name|total_blocks
operator|*
name|BIG_RAM_BLOCK_SIZE_DWORDS
expr_stmt|;
name|OSAL_STRNCPY
argument_list|(
name|type_name
argument_list|,
name|big_ram
operator|->
name|instance_name
argument_list|,
name|OSAL_STRLEN
argument_list|(
name|big_ram
operator|->
name|instance_name
argument_list|)
argument_list|)
expr_stmt|;
name|OSAL_STRNCPY
argument_list|(
name|mem_name
argument_list|,
name|big_ram
operator|->
name|instance_name
argument_list|,
name|OSAL_STRLEN
argument_list|(
name|big_ram
operator|->
name|instance_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump memory header */
name|offset
operator|+=
name|ecore_grc_dump_mem_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|mem_name
argument_list|,
literal|0
argument_list|,
name|ram_size
argument_list|,
name|BIG_RAM_BLOCK_SIZE_BYTES
operator|*
literal|8
argument_list|,
name|false
argument_list|,
name|type_name
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read and dump Big RAM data */
if|if
condition|(
operator|!
name|dump
condition|)
return|return
name|offset
operator|+
name|ram_size
return|;
comment|/* Dump Big RAM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_blocks
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|big_ram
operator|->
name|addr_reg_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|big_ram
operator|->
name|data_reg_addr
argument_list|)
argument_list|,
literal|2
operator|*
name|BIG_RAM_BLOCK_SIZE_DWORDS
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|ecore_grc_dump_mcp
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|bool
name|block_enable
index|[
name|MAX_BLOCK_ID
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|bool
name|halted
init|=
name|false
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Halt MCP */
if|if
condition|(
name|dump
operator|&&
operator|!
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NO_MCP
argument_list|)
condition|)
block|{
name|halted
operator|=
operator|!
name|ecore_mcp_halt
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|halted
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"MCP halt failed!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Dump MCP scratchpad */
name|offset
operator|+=
name|ecore_grc_dump_mem
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|OSAL_NULL
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|MCP_REG_SCRATCH
argument_list|)
argument_list|,
name|MCP_REG_SCRATCH_SIZE
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|"MCP"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dump MCP cpu_reg_file */
name|offset
operator|+=
name|ecore_grc_dump_mem
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|OSAL_NULL
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|MCP_REG_CPU_REG_FILE
argument_list|)
argument_list|,
name|MCP_REG_CPU_REG_FILE_SIZE
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|"MCP"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dump MCP registers */
name|block_enable
index|[
name|BLOCK_MCP
index|]
operator|=
name|true
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_registers
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|block_enable
argument_list|,
literal|"block"
argument_list|,
literal|"MCP"
argument_list|)
expr_stmt|;
comment|/* Dump required non-MCP registers */
name|offset
operator|+=
name|ecore_grc_dump_regs_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|1
argument_list|,
literal|"eng"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"block"
argument_list|,
literal|"MCP"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_reg_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|MISC_REG_SHARED_MEM_ADDR
argument_list|)
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Release MCP */
if|if
condition|(
name|halted
operator|&&
name|ecore_mcp_resume
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to resume MCP after halt!\n"
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps the tbus indirect memory for all PHYs. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_phy
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|u32
name|offset
init|=
literal|0
decl_stmt|,
name|tbus_lo_offset
decl_stmt|,
name|tbus_hi_offset
decl_stmt|;
name|char
name|mem_name
index|[
literal|32
index|]
decl_stmt|;
name|u8
name|phy_id
decl_stmt|;
for|for
control|(
name|phy_id
operator|=
literal|0
init|;
name|phy_id
operator|<
name|OSAL_ARRAY_SIZE
argument_list|(
name|s_phy_defs
argument_list|)
condition|;
name|phy_id
operator|++
control|)
block|{
name|u32
name|addr_lo_addr
decl_stmt|,
name|addr_hi_addr
decl_stmt|,
name|data_lo_addr
decl_stmt|,
name|data_hi_addr
decl_stmt|;
name|struct
name|phy_defs
modifier|*
name|phy_defs
decl_stmt|;
name|u8
modifier|*
name|bytes_buf
decl_stmt|;
name|phy_defs
operator|=
operator|&
name|s_phy_defs
index|[
name|phy_id
index|]
expr_stmt|;
name|addr_lo_addr
operator|=
name|phy_defs
operator|->
name|base_addr
operator|+
name|phy_defs
operator|->
name|tbus_addr_lo_addr
expr_stmt|;
name|addr_hi_addr
operator|=
name|phy_defs
operator|->
name|base_addr
operator|+
name|phy_defs
operator|->
name|tbus_addr_hi_addr
expr_stmt|;
name|data_lo_addr
operator|=
name|phy_defs
operator|->
name|base_addr
operator|+
name|phy_defs
operator|->
name|tbus_data_lo_addr
expr_stmt|;
name|data_hi_addr
operator|=
name|phy_defs
operator|->
name|base_addr
operator|+
name|phy_defs
operator|->
name|tbus_data_hi_addr
expr_stmt|;
name|bytes_buf
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|dump_buf
operator|+
name|offset
operator|)
expr_stmt|;
if|if
condition|(
name|OSAL_SNPRINTF
argument_list|(
name|mem_name
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_name
argument_list|)
argument_list|,
literal|"tbus_%s"
argument_list|,
name|phy_defs
operator|->
name|phy_name
argument_list|)
operator|<
literal|0
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unexpected debug error: invalid PHY memory name\n"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_mem_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|mem_name
argument_list|,
literal|0
argument_list|,
name|PHY_DUMP_SIZE_DWORDS
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
name|mem_name
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
block|{
name|offset
operator|+=
name|PHY_DUMP_SIZE_DWORDS
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|tbus_hi_offset
operator|=
literal|0
init|;
name|tbus_hi_offset
operator|<
operator|(
name|NUM_PHY_TBUS_ADDRESSES
operator|>>
literal|8
operator|)
condition|;
name|tbus_hi_offset
operator|++
control|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr_hi_addr
argument_list|,
name|tbus_hi_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|tbus_lo_offset
operator|=
literal|0
init|;
name|tbus_lo_offset
operator|<
literal|256
condition|;
name|tbus_lo_offset
operator|++
control|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|addr_lo_addr
argument_list|,
name|tbus_lo_offset
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bytes_buf
operator|++
operator|)
operator|=
operator|(
name|u8
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|data_lo_addr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bytes_buf
operator|++
operator|)
operator|=
operator|(
name|u8
operator|)
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|data_hi_addr
argument_list|)
expr_stmt|;
block|}
block|}
name|offset
operator|+=
name|PHY_DUMP_SIZE_DWORDS
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_config_dbg_line
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|,
name|u8
name|line_id
parameter_list|,
name|u8
name|enable_mask
parameter_list|,
name|u8
name|right_shift
parameter_list|,
name|u8
name|force_valid_mask
parameter_list|,
name|u8
name|force_frame_mask
parameter_list|)
block|{
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|block
operator|->
name|dbg_select_addr
argument_list|,
name|line_id
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|block
operator|->
name|dbg_enable_addr
argument_list|,
name|enable_mask
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|block
operator|->
name|dbg_shift_addr
argument_list|,
name|right_shift
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|block
operator|->
name|dbg_force_valid_addr
argument_list|,
name|force_valid_mask
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|block
operator|->
name|dbg_force_frame_addr
argument_list|,
name|force_frame_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps Static Debug data. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_grc_dump_static_debug
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|block_id
decl_stmt|,
name|line_id
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Skip static debug if a debug bus recording is in progress */
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_DBG_BLOCK_ON
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dump
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"Dumping static debug data...\n"
argument_list|)
expr_stmt|;
comment|/* Disable all blocks debug output */
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
if|if
condition|(
name|block
operator|->
name|has_dbg_bus
index|[
name|dev_data
operator|->
name|chip_id
index|]
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|block
operator|->
name|dbg_enable_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ecore_bus_reset_dbg_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_bus_set_framing_mode
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_BUS_FRAME_MODE_8HW_0ST
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_DEBUG_TARGET
argument_list|,
name|DBG_BUS_TARGET_ID_INT_BUF
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_FULL_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_bus_enable_dbg_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Dump all static debug lines for each relevant block */
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
name|struct
name|dbg_bus_block
modifier|*
name|block_desc
decl_stmt|;
name|u32
name|block_dwords
decl_stmt|;
if|if
condition|(
operator|!
name|block
operator|->
name|has_dbg_bus
index|[
name|dev_data
operator|->
name|chip_id
index|]
condition|)
continue|continue;
name|block_desc
operator|=
name|get_dbg_bus_block_desc
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|block_id
operator|)
name|block_id
argument_list|)
expr_stmt|;
name|block_dwords
operator|=
name|NUM_DBG_LINES
argument_list|(
name|block_desc
argument_list|)
operator|*
name|STATIC_DEBUG_LINE_DWORDS
expr_stmt|;
comment|/* Dump static section params */
name|offset
operator|+=
name|ecore_grc_dump_mem_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|block
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|block_dwords
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|"STATIC"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
block|{
name|offset
operator|+=
name|block_dwords
expr_stmt|;
continue|continue;
block|}
comment|/* If all lines are invalid - dump zeros */
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|block_id
index|]
condition|)
block|{
name|OSAL_MEMSET
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
literal|0
argument_list|,
name|DWORDS_TO_BYTES
argument_list|(
name|block_dwords
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|block_dwords
expr_stmt|;
continue|continue;
block|}
comment|/* Enable block's client */
name|ecore_bus_enable_clients
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
literal|1
operator|<<
name|block
operator|->
name|dbg_client_id
index|[
name|dev_data
operator|->
name|chip_id
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|line_id
operator|=
literal|0
init|;
name|line_id
operator|<
operator|(
name|u32
operator|)
name|NUM_DBG_LINES
argument_list|(
name|block_desc
argument_list|)
condition|;
name|line_id
operator|++
control|)
block|{
comment|/* Configure debug line ID */
name|ecore_config_dbg_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
expr|enum
name|block_id
operator|)
name|block_id
argument_list|,
operator|(
name|u8
operator|)
name|line_id
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read debug line info */
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|DBG_REG_CALENDAR_OUT_DATA
argument_list|)
argument_list|,
name|STATIC_DEBUG_LINE_DWORDS
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Disable block's client and debug output */
name|ecore_bus_enable_clients
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|block
operator|->
name|dbg_enable_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump
condition|)
block|{
name|ecore_bus_enable_dbg_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ecore_bus_enable_clients
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Performs GRC Dump to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_grc_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|bool
name|is_emul
decl_stmt|,
name|parities_masked
init|=
name|false
decl_stmt|;
name|u8
name|i
decl_stmt|,
name|port_mode
init|=
literal|0
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|is_emul
operator|=
name|dev_data
operator|->
name|platform_id
operator|==
name|PLATFORM_EMUL_FULL
operator|||
name|dev_data
operator|->
name|platform_id
operator|==
name|PLATFORM_EMUL_REDUCED
expr_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
comment|/* Find port mode */
switch|switch
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MISC_REG_PORT_MODE
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|port_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|port_mode
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|port_mode
operator|=
literal|4
expr_stmt|;
break|break;
block|}
comment|/* Update reset state */
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
comment|/* Dump global params */
name|offset
operator|+=
name|ecore_dump_common_global_params
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"dump-type"
argument_list|,
literal|"grc-dump"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"num-lcids"
argument_list|,
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NUM_LCIDS
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"num-ltids"
argument_list|,
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NUM_LTIDS
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"num-ports"
argument_list|,
name|port_mode
argument_list|)
expr_stmt|;
comment|/* Dump reset registers (dumped before taking blocks out of reset ) */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_REGS
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_grc_dump_reset_regs
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Take all blocks out of reset (using reset registers) */
if|if
condition|(
name|dump
condition|)
block|{
name|ecore_grc_unreset_blocks
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all parities using MFW command */
if|if
condition|(
name|dump
operator|&&
operator|!
name|is_emul
operator|&&
operator|!
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NO_MCP
argument_list|)
condition|)
block|{
name|parities_masked
operator|=
operator|!
name|ecore_mcp_mask_parities
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parities_masked
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to mask parities using MFW\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_PARITY_SAFE
argument_list|)
condition|)
return|return
name|DBG_STATUS_MCP_COULD_NOT_MASK_PRTY
return|;
block|}
block|}
comment|/* Dump modified registers (dumped before modifying them) */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_REGS
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_grc_dump_modified_regs
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Stall storms */
if|if
condition|(
name|dump
operator|&&
operator|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_IOR
argument_list|)
operator|||
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_VFC
argument_list|)
operator|)
condition|)
name|ecore_grc_stall_storms
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Dump all regs  */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_REGS
argument_list|)
condition|)
block|{
name|bool
name|block_enable
index|[
name|MAX_BLOCK_ID
index|]
decl_stmt|;
comment|/* Dump all blocks except MCP */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BLOCK_ID
condition|;
name|i
operator|++
control|)
name|block_enable
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
name|block_enable
index|[
name|BLOCK_MCP
index|]
operator|=
name|false
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_registers
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|block_enable
argument_list|,
name|OSAL_NULL
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
comment|/* Dump special registers */
name|offset
operator|+=
name|ecore_grc_dump_special_regs
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
block|}
comment|/* Dump memories */
name|offset
operator|+=
name|ecore_grc_dump_memories
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Dump MCP */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_MCP
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_grc_dump_mcp
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Dump context */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_CM_CTX
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_grc_dump_ctx
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Dump RSS memories */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_RSS
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_grc_dump_rss
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Dump Big RAM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_BIG_RAM_TYPES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|s_big_ram_defs
index|[
name|i
index|]
operator|.
name|grc_param
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_grc_dump_big_ram
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Dump IORs */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_IOR
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_grc_dump_iors
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Dump VFC */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_VFC
argument_list|)
condition|)
name|offset
operator|+=
name|ecore_grc_dump_vfc
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Dump PHY tbus */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_PHY
argument_list|)
operator|&&
name|dev_data
operator|->
name|chip_id
operator|==
name|CHIP_K2
operator|&&
name|dev_data
operator|->
name|platform_id
operator|==
name|PLATFORM_ASIC
condition|)
name|offset
operator|+=
name|ecore_grc_dump_phy
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Dump static debug data  */
if|if
condition|(
name|ecore_grc_is_included
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_DUMP_STATIC
argument_list|)
operator|&&
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|==
name|DBG_BUS_STATE_IDLE
condition|)
name|offset
operator|+=
name|ecore_grc_dump_static_debug
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
comment|/* Dump last section */
name|offset
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
argument_list|,
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
comment|/* Unstall storms */
if|if
condition|(
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_UNSTALL
argument_list|)
condition|)
name|ecore_grc_stall_storms
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Clear parity status */
if|if
condition|(
operator|!
name|is_emul
condition|)
name|ecore_grc_clear_all_prty
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* Enable all parities using MFW command */
if|if
condition|(
name|parities_masked
condition|)
name|ecore_mcp_mask_parities
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|num_dumped_dwords
operator|=
name|offset
expr_stmt|;
empty_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Writes the specified failing Idle Check rule to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_idle_chk_dump_failure
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u16
name|rule_id
parameter_list|,
specifier|const
name|struct
name|dbg_idle_chk_rule
modifier|*
name|rule
parameter_list|,
name|u16
name|fail_entry_id
parameter_list|,
name|u32
modifier|*
name|cond_reg_values
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
specifier|const
name|struct
name|dbg_idle_chk_cond_reg
modifier|*
name|cond_regs
decl_stmt|;
specifier|const
name|struct
name|dbg_idle_chk_info_reg
modifier|*
name|info_regs
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|next_reg_offset
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|dbg_idle_chk_result_hdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|union
name|dbg_idle_chk_reg
modifier|*
name|regs
decl_stmt|;
name|u8
name|reg_id
decl_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|dbg_idle_chk_result_hdr
operator|*
operator|)
name|dump_buf
expr_stmt|;
name|regs
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|union
name|dbg_idle_chk_reg
operator|*
operator|)
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_REGS
index|]
operator|.
name|ptr
operator|)
index|[
name|rule
operator|->
name|reg_offset
index|]
expr_stmt|;
name|cond_regs
operator|=
operator|&
name|regs
index|[
literal|0
index|]
operator|.
name|cond_reg
expr_stmt|;
name|info_regs
operator|=
operator|&
name|regs
index|[
name|rule
operator|->
name|num_cond_regs
index|]
operator|.
name|info_reg
expr_stmt|;
comment|/* Dump rule data */
if|if
condition|(
name|dump
condition|)
block|{
name|OSAL_MEMSET
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|rule_id
operator|=
name|rule_id
expr_stmt|;
name|hdr
operator|->
name|mem_entry_id
operator|=
name|fail_entry_id
expr_stmt|;
name|hdr
operator|->
name|severity
operator|=
name|rule
operator|->
name|severity
expr_stmt|;
name|hdr
operator|->
name|num_dumped_cond_regs
operator|=
name|rule
operator|->
name|num_cond_regs
expr_stmt|;
block|}
name|offset
operator|+=
name|IDLE_CHK_RESULT_HDR_DWORDS
expr_stmt|;
comment|/* Dump condition register values */
for|for
control|(
name|reg_id
operator|=
literal|0
init|;
name|reg_id
operator|<
name|rule
operator|->
name|num_cond_regs
condition|;
name|reg_id
operator|++
control|)
block|{
specifier|const
name|struct
name|dbg_idle_chk_cond_reg
modifier|*
name|reg
init|=
operator|&
name|cond_regs
index|[
name|reg_id
index|]
decl_stmt|;
name|struct
name|dbg_idle_chk_result_reg_hdr
modifier|*
name|reg_hdr
decl_stmt|;
name|reg_hdr
operator|=
operator|(
expr|struct
name|dbg_idle_chk_result_reg_hdr
operator|*
operator|)
operator|(
name|dump_buf
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* Write register header */
if|if
condition|(
operator|!
name|dump
condition|)
block|{
name|offset
operator|+=
name|IDLE_CHK_RESULT_REG_HDR_DWORDS
operator|+
name|reg
operator|->
name|entry_size
expr_stmt|;
continue|continue;
block|}
name|offset
operator|+=
name|IDLE_CHK_RESULT_REG_HDR_DWORDS
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|reg_hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reg_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|reg_hdr
operator|->
name|start_entry
operator|=
name|reg
operator|->
name|start_entry
expr_stmt|;
name|reg_hdr
operator|->
name|size
operator|=
name|reg
operator|->
name|entry_size
expr_stmt|;
name|SET_FIELD
argument_list|(
name|reg_hdr
operator|->
name|data
argument_list|,
name|DBG_IDLE_CHK_RESULT_REG_HDR_IS_MEM
argument_list|,
name|reg
operator|->
name|num_entries
operator|>
literal|1
operator|||
name|reg
operator|->
name|start_entry
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|reg_hdr
operator|->
name|data
argument_list|,
name|DBG_IDLE_CHK_RESULT_REG_HDR_REG_ID
argument_list|,
name|reg_id
argument_list|)
expr_stmt|;
comment|/* Write register values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg_hdr
operator|->
name|size
condition|;
name|i
operator|++
operator|,
name|next_reg_offset
operator|++
operator|,
name|offset
operator|++
control|)
name|dump_buf
index|[
name|offset
index|]
operator|=
name|cond_reg_values
index|[
name|next_reg_offset
index|]
expr_stmt|;
block|}
comment|/* Dump info register values */
for|for
control|(
name|reg_id
operator|=
literal|0
init|;
name|reg_id
operator|<
name|rule
operator|->
name|num_info_regs
condition|;
name|reg_id
operator|++
control|)
block|{
specifier|const
name|struct
name|dbg_idle_chk_info_reg
modifier|*
name|reg
init|=
operator|&
name|info_regs
index|[
name|reg_id
index|]
decl_stmt|;
name|u32
name|block_id
decl_stmt|;
comment|/* Check if register's block is in reset */
if|if
condition|(
operator|!
name|dump
condition|)
block|{
name|offset
operator|+=
name|IDLE_CHK_RESULT_REG_HDR_DWORDS
operator|+
name|reg
operator|->
name|size
expr_stmt|;
continue|continue;
block|}
name|block_id
operator|=
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|data
argument_list|,
name|DBG_IDLE_CHK_INFO_REG_BLOCK_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_id
operator|>=
name|MAX_BLOCK_ID
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid block_id\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|dev_data
operator|->
name|block_in_reset
index|[
name|block_id
index|]
condition|)
block|{
name|struct
name|dbg_idle_chk_result_reg_hdr
modifier|*
name|reg_hdr
decl_stmt|;
name|bool
name|wide_bus
decl_stmt|,
name|eval_mode
decl_stmt|,
name|mode_match
init|=
name|true
decl_stmt|;
name|u16
name|modes_buf_offset
decl_stmt|;
name|u32
name|addr
decl_stmt|;
name|reg_hdr
operator|=
operator|(
expr|struct
name|dbg_idle_chk_result_reg_hdr
operator|*
operator|)
operator|(
name|dump_buf
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* Check mode */
name|eval_mode
operator|=
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_EVAL_MODE
argument_list|)
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|eval_mode
condition|)
block|{
name|modes_buf_offset
operator|=
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_MODES_BUF_OFFSET
argument_list|)
expr_stmt|;
name|mode_match
operator|=
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|modes_buf_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mode_match
condition|)
continue|continue;
name|addr
operator|=
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|data
argument_list|,
name|DBG_IDLE_CHK_INFO_REG_ADDRESS
argument_list|)
expr_stmt|;
name|wide_bus
operator|=
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|data
argument_list|,
name|DBG_IDLE_CHK_INFO_REG_WIDE_BUS
argument_list|)
expr_stmt|;
comment|/* Write register header */
name|offset
operator|+=
name|IDLE_CHK_RESULT_REG_HDR_DWORDS
expr_stmt|;
name|hdr
operator|->
name|num_dumped_info_regs
operator|++
expr_stmt|;
name|OSAL_MEMSET
argument_list|(
name|reg_hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reg_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|reg_hdr
operator|->
name|size
operator|=
name|reg
operator|->
name|size
expr_stmt|;
name|SET_FIELD
argument_list|(
name|reg_hdr
operator|->
name|data
argument_list|,
name|DBG_IDLE_CHK_RESULT_REG_HDR_REG_ID
argument_list|,
name|rule
operator|->
name|num_cond_regs
operator|+
name|reg_id
argument_list|)
expr_stmt|;
comment|/* Write register values */
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|addr
argument_list|,
name|reg
operator|->
name|size
argument_list|,
name|wide_bus
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dumps idle check rule entries. Returns the dumped size in dwords. */
end_comment

begin_function
specifier|static
name|u32
name|ecore_idle_chk_dump_rule_entries
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
specifier|const
name|struct
name|dbg_idle_chk_rule
modifier|*
name|input_rules
parameter_list|,
name|u32
name|num_input_rules
parameter_list|,
name|u32
modifier|*
name|num_failing_rules
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|cond_reg_values
index|[
name|IDLE_CHK_MAX_ENTRIES_SIZE
index|]
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|u16
name|entry_id
decl_stmt|;
name|u8
name|reg_id
decl_stmt|;
operator|*
name|num_failing_rules
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_input_rules
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|dbg_idle_chk_cond_reg
modifier|*
name|cond_regs
decl_stmt|;
specifier|const
name|struct
name|dbg_idle_chk_rule
modifier|*
name|rule
decl_stmt|;
specifier|const
name|union
name|dbg_idle_chk_reg
modifier|*
name|regs
decl_stmt|;
name|u16
name|num_reg_entries
init|=
literal|1
decl_stmt|;
name|bool
name|check_rule
init|=
name|true
decl_stmt|;
specifier|const
name|u32
modifier|*
name|imm_values
decl_stmt|;
name|rule
operator|=
operator|&
name|input_rules
index|[
name|i
index|]
expr_stmt|;
name|regs
operator|=
operator|&
operator|(
operator|(
specifier|const
expr|union
name|dbg_idle_chk_reg
operator|*
operator|)
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_REGS
index|]
operator|.
name|ptr
operator|)
index|[
name|rule
operator|->
name|reg_offset
index|]
expr_stmt|;
name|cond_regs
operator|=
operator|&
name|regs
index|[
literal|0
index|]
operator|.
name|cond_reg
expr_stmt|;
name|imm_values
operator|=
operator|&
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_IMMS
index|]
operator|.
name|ptr
index|[
name|rule
operator|->
name|imm_offset
index|]
expr_stmt|;
comment|/* Check if all condition register blocks are out of reset, and 		 * find maximal number of entries (all condition registers that 		 * are memories must have the same size, which is> 1). 		 */
for|for
control|(
name|reg_id
operator|=
literal|0
init|;
name|reg_id
operator|<
name|rule
operator|->
name|num_cond_regs
operator|&&
name|check_rule
condition|;
name|reg_id
operator|++
control|)
block|{
name|u32
name|block_id
init|=
name|GET_FIELD
argument_list|(
name|cond_regs
index|[
name|reg_id
index|]
operator|.
name|data
argument_list|,
name|DBG_IDLE_CHK_COND_REG_BLOCK_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|block_id
operator|>=
name|MAX_BLOCK_ID
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Invalid block_id\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|check_rule
operator|=
operator|!
name|dev_data
operator|->
name|block_in_reset
index|[
name|block_id
index|]
expr_stmt|;
if|if
condition|(
name|cond_regs
index|[
name|reg_id
index|]
operator|.
name|num_entries
operator|>
name|num_reg_entries
condition|)
name|num_reg_entries
operator|=
name|cond_regs
index|[
name|reg_id
index|]
operator|.
name|num_entries
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_rule
operator|&&
name|dump
condition|)
continue|continue;
comment|/* Go over all register entries (number of entries is the same for all 		 * condition registers). 		 */
for|for
control|(
name|entry_id
operator|=
literal|0
init|;
name|entry_id
operator|<
name|num_reg_entries
condition|;
name|entry_id
operator|++
control|)
block|{
name|u32
name|next_reg_offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dump
condition|)
block|{
name|offset
operator|+=
name|ecore_idle_chk_dump_failure
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|false
argument_list|,
name|rule
operator|->
name|rule_id
argument_list|,
name|rule
argument_list|,
name|entry_id
argument_list|,
name|OSAL_NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num_failing_rules
operator|)
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Read current entry of all condition registers */
for|for
control|(
name|reg_id
operator|=
literal|0
init|;
name|reg_id
operator|<
name|rule
operator|->
name|num_cond_regs
condition|;
name|reg_id
operator|++
control|)
block|{
specifier|const
name|struct
name|dbg_idle_chk_cond_reg
modifier|*
name|reg
init|=
operator|&
name|cond_regs
index|[
name|reg_id
index|]
decl_stmt|;
name|u32
name|padded_entry_size
decl_stmt|,
name|addr
decl_stmt|;
name|bool
name|wide_bus
decl_stmt|;
comment|/* Find GRC address (if it's a memory, the address of the 				 * specific entry is calculated). 				 */
name|addr
operator|=
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|data
argument_list|,
name|DBG_IDLE_CHK_COND_REG_ADDRESS
argument_list|)
expr_stmt|;
name|wide_bus
operator|=
name|GET_FIELD
argument_list|(
name|reg
operator|->
name|data
argument_list|,
name|DBG_IDLE_CHK_COND_REG_WIDE_BUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|->
name|num_entries
operator|>
literal|1
operator|||
name|reg
operator|->
name|start_entry
operator|>
literal|0
condition|)
block|{
name|padded_entry_size
operator|=
name|reg
operator|->
name|entry_size
operator|>
literal|1
condition|?
name|OSAL_ROUNDUP_POW_OF_TWO
argument_list|(
name|reg
operator|->
name|entry_size
argument_list|)
else|:
literal|1
expr_stmt|;
name|addr
operator|+=
operator|(
name|reg
operator|->
name|start_entry
operator|+
name|entry_id
operator|)
operator|*
name|padded_entry_size
expr_stmt|;
block|}
comment|/* Read registers */
if|if
condition|(
name|next_reg_offset
operator|+
name|reg
operator|->
name|entry_size
operator|>=
name|IDLE_CHK_MAX_ENTRIES_SIZE
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"idle check registers entry is too large\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|next_reg_offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|cond_reg_values
operator|+
name|next_reg_offset
argument_list|,
name|dump
argument_list|,
name|addr
argument_list|,
name|reg
operator|->
name|entry_size
argument_list|,
name|wide_bus
argument_list|)
expr_stmt|;
block|}
comment|/* Call rule condition function. if returns true, it's a failure.*/
if|if
condition|(
call|(
modifier|*
name|cond_arr
index|[
name|rule
operator|->
name|cond_id
index|]
call|)
argument_list|(
name|cond_reg_values
argument_list|,
name|imm_values
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|ecore_idle_chk_dump_failure
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|rule
operator|->
name|rule_id
argument_list|,
name|rule
argument_list|,
name|entry_id
argument_list|,
name|cond_reg_values
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num_failing_rules
operator|)
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Performs Idle Check Dump to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_idle_chk_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|u32
name|num_failing_rules_offset
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|input_offset
init|=
literal|0
decl_stmt|,
name|num_failing_rules
init|=
literal|0
decl_stmt|;
comment|/* Dump global params */
name|offset
operator|+=
name|ecore_dump_common_global_params
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"dump-type"
argument_list|,
literal|"idle-chk"
argument_list|)
expr_stmt|;
comment|/* Dump idle check section header with a single parameter */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"idle_chk"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|num_failing_rules_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"num_rules"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|input_offset
operator|<
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_RULES
index|]
operator|.
name|size_in_dwords
condition|)
block|{
specifier|const
name|struct
name|dbg_idle_chk_cond_hdr
modifier|*
name|cond_hdr
init|=
operator|(
specifier|const
expr|struct
name|dbg_idle_chk_cond_hdr
operator|*
operator|)
operator|&
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_RULES
index|]
operator|.
name|ptr
index|[
name|input_offset
operator|++
index|]
decl_stmt|;
name|bool
name|eval_mode
decl_stmt|,
name|mode_match
init|=
name|true
decl_stmt|;
name|u32
name|curr_failing_rules
decl_stmt|;
name|u16
name|modes_buf_offset
decl_stmt|;
comment|/* Check mode */
name|eval_mode
operator|=
name|GET_FIELD
argument_list|(
name|cond_hdr
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_EVAL_MODE
argument_list|)
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|eval_mode
condition|)
block|{
name|modes_buf_offset
operator|=
name|GET_FIELD
argument_list|(
name|cond_hdr
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_MODES_BUF_OFFSET
argument_list|)
expr_stmt|;
name|mode_match
operator|=
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|modes_buf_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode_match
condition|)
block|{
name|offset
operator|+=
name|ecore_idle_chk_dump_rule_entries
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
operator|(
specifier|const
expr|struct
name|dbg_idle_chk_rule
operator|*
operator|)
operator|&
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_RULES
index|]
operator|.
name|ptr
index|[
name|input_offset
index|]
argument_list|,
name|cond_hdr
operator|->
name|data_size
operator|/
name|IDLE_CHK_RULE_SIZE_DWORDS
argument_list|,
operator|&
name|curr_failing_rules
argument_list|)
expr_stmt|;
name|num_failing_rules
operator|+=
name|curr_failing_rules
expr_stmt|;
block|}
name|input_offset
operator|+=
name|cond_hdr
operator|->
name|data_size
expr_stmt|;
block|}
comment|/* Overwrite num_rules parameter */
if|if
condition|(
name|dump
condition|)
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|num_failing_rules_offset
argument_list|,
name|dump
argument_list|,
literal|"num_rules"
argument_list|,
name|num_failing_rules
argument_list|)
expr_stmt|;
comment|/* Dump last section */
name|offset
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
argument_list|,
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Finds the meta data image in NVRAM */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_find_nvram_image
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|image_type
parameter_list|,
name|u32
modifier|*
name|nvram_offset_bytes
parameter_list|,
name|u32
modifier|*
name|nvram_size_bytes
parameter_list|)
block|{
name|u32
name|ret_mcp_resp
decl_stmt|,
name|ret_mcp_param
decl_stmt|,
name|ret_txn_size
decl_stmt|;
name|struct
name|mcp_file_att
name|file_att
decl_stmt|;
name|int
name|nvm_result
decl_stmt|;
comment|/* Call NVRAM get file command */
name|nvm_result
operator|=
name|ecore_mcp_nvm_rd_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_NVM_GET_FILE_ATT
argument_list|,
name|image_type
argument_list|,
operator|&
name|ret_mcp_resp
argument_list|,
operator|&
name|ret_mcp_param
argument_list|,
operator|&
name|ret_txn_size
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|file_att
argument_list|)
expr_stmt|;
comment|/* Check response */
if|if
condition|(
name|nvm_result
operator|||
operator|(
name|ret_mcp_resp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_NVM_OK
condition|)
return|return
name|DBG_STATUS_NVRAM_GET_IMAGE_FAILED
return|;
comment|/* Update return values */
operator|*
name|nvram_offset_bytes
operator|=
name|file_att
operator|.
name|nvm_start_addr
expr_stmt|;
operator|*
name|nvram_size_bytes
operator|=
name|file_att
operator|.
name|len
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"find_nvram_image: found NVRAM image of type %d in NVRAM offset %d bytes with size %d bytes\n"
argument_list|,
name|image_type
argument_list|,
operator|*
name|nvram_offset_bytes
argument_list|,
operator|*
name|nvram_size_bytes
argument_list|)
expr_stmt|;
comment|/* Check alignment */
if|if
condition|(
operator|*
name|nvram_size_bytes
operator|&
literal|0x3
condition|)
return|return
name|DBG_STATUS_NON_ALIGNED_NVRAM_IMAGE
return|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Reads data from NVRAM */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_nvram_read
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|nvram_offset_bytes
parameter_list|,
name|u32
name|nvram_size_bytes
parameter_list|,
name|u32
modifier|*
name|ret_buf
parameter_list|)
block|{
name|u32
name|ret_mcp_resp
decl_stmt|,
name|ret_mcp_param
decl_stmt|,
name|ret_read_size
decl_stmt|,
name|bytes_to_copy
decl_stmt|;
name|s32
name|bytes_left
init|=
name|nvram_size_bytes
decl_stmt|;
name|u32
name|read_offset
init|=
literal|0
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"nvram_read: reading image of size %d bytes from NVRAM\n"
argument_list|,
name|nvram_size_bytes
argument_list|)
expr_stmt|;
do|do
block|{
name|bytes_to_copy
operator|=
operator|(
name|bytes_left
operator|>
name|MCP_DRV_NVM_BUF_LEN
operator|)
condition|?
name|MCP_DRV_NVM_BUF_LEN
else|:
name|bytes_left
expr_stmt|;
comment|/* Call NVRAM read command */
if|if
condition|(
name|ecore_mcp_nvm_rd_cmd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DRV_MSG_CODE_NVM_READ_NVRAM
argument_list|,
operator|(
name|nvram_offset_bytes
operator|+
name|read_offset
operator|)
operator||
operator|(
name|bytes_to_copy
operator|<<
name|DRV_MB_PARAM_NVM_LEN_SHIFT
operator|)
argument_list|,
operator|&
name|ret_mcp_resp
argument_list|,
operator|&
name|ret_mcp_param
argument_list|,
operator|&
name|ret_read_size
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|ret_buf
operator|+
name|read_offset
operator|)
argument_list|)
condition|)
return|return
name|DBG_STATUS_NVRAM_READ_FAILED
return|;
comment|/* Check response */
if|if
condition|(
operator|(
name|ret_mcp_resp
operator|&
name|FW_MSG_CODE_MASK
operator|)
operator|!=
name|FW_MSG_CODE_NVM_OK
condition|)
return|return
name|DBG_STATUS_NVRAM_READ_FAILED
return|;
comment|/* Update read offset */
name|read_offset
operator|+=
name|ret_read_size
expr_stmt|;
name|bytes_left
operator|-=
name|ret_read_size
expr_stmt|;
block|}
do|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
do|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Get info on the MCP Trace data in the scratchpad:  * - trace_data_grc_addr (OUT): trace data GRC address in bytes  * - trace_data_size (OUT): trace data size in bytes (without the header)  */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_mcp_trace_get_data_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|trace_data_grc_addr
parameter_list|,
name|u32
modifier|*
name|trace_data_size
parameter_list|)
block|{
name|u32
name|spad_trace_offsize
decl_stmt|,
name|signature
decl_stmt|;
comment|/* Read trace section offsize structure from MCP scratchpad */
name|spad_trace_offsize
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MCP_SPAD_TRACE_OFFSIZE_ADDR
argument_list|)
expr_stmt|;
comment|/* Extract trace section address from offsize (in scratchpad) */
operator|*
name|trace_data_grc_addr
operator|=
name|MCP_REG_SCRATCH
operator|+
name|SECTION_OFFSET
argument_list|(
name|spad_trace_offsize
argument_list|)
expr_stmt|;
comment|/* Read signature from MCP trace section */
name|signature
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|*
name|trace_data_grc_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|mcp_trace
argument_list|,
name|signature
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
name|MFW_TRACE_SIGNATURE
condition|)
return|return
name|DBG_STATUS_INVALID_TRACE_SIGNATURE
return|;
comment|/* Read trace size from MCP trace section */
operator|*
name|trace_data_size
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|*
name|trace_data_grc_addr
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|mcp_trace
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Reads MCP trace meta data image from NVRAM  * - running_bundle_id (OUT): running bundle ID (invalid when loaded from file)  * - trace_meta_offset (OUT): trace meta offset in NVRAM in bytes (invalid when  *			      loaded from file).  * - trace_meta_size (OUT):   size in bytes of the trace meta data.  */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_mcp_trace_get_meta_info
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|trace_data_size_bytes
parameter_list|,
name|u32
modifier|*
name|running_bundle_id
parameter_list|,
name|u32
modifier|*
name|trace_meta_offset
parameter_list|,
name|u32
modifier|*
name|trace_meta_size
parameter_list|)
block|{
name|u32
name|spad_trace_offsize
decl_stmt|,
name|nvram_image_type
decl_stmt|,
name|running_mfw_addr
decl_stmt|;
comment|/* Read MCP trace section offsize structure from MCP scratchpad */
name|spad_trace_offsize
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|MCP_SPAD_TRACE_OFFSIZE_ADDR
argument_list|)
expr_stmt|;
comment|/* Find running bundle ID */
name|running_mfw_addr
operator|=
name|MCP_REG_SCRATCH
operator|+
name|SECTION_OFFSET
argument_list|(
name|spad_trace_offsize
argument_list|)
operator|+
name|SECTION_SIZE
argument_list|(
name|spad_trace_offsize
argument_list|)
operator|+
name|trace_data_size_bytes
expr_stmt|;
operator|*
name|running_bundle_id
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|running_mfw_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|running_bundle_id
operator|>
literal|1
condition|)
return|return
name|DBG_STATUS_INVALID_NVRAM_BUNDLE
return|;
comment|/* Find image in NVRAM */
name|nvram_image_type
operator|=
operator|(
operator|*
name|running_bundle_id
operator|==
name|DIR_ID_1
operator|)
condition|?
name|NVM_TYPE_MFW_TRACE1
else|:
name|NVM_TYPE_MFW_TRACE2
expr_stmt|;
return|return
name|ecore_find_nvram_image
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|nvram_image_type
argument_list|,
name|trace_meta_offset
argument_list|,
name|trace_meta_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reads the MCP Trace meta data from NVRAM into the specified buffer */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_mcp_trace_read_meta
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|nvram_offset_in_bytes
parameter_list|,
name|u32
name|size_in_bytes
parameter_list|,
name|u32
modifier|*
name|buf
parameter_list|)
block|{
name|u8
name|modules_num
decl_stmt|,
name|module_len
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|byte_buf
init|=
operator|(
name|u8
operator|*
operator|)
name|buf
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
name|u32
name|signature
decl_stmt|;
comment|/* Read meta data from NVRAM */
name|status
operator|=
name|ecore_nvram_read
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|nvram_offset_in_bytes
argument_list|,
name|size_in_bytes
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
comment|/* Extract and check first signature */
name|signature
operator|=
name|ecore_read_unaligned_dword
argument_list|(
name|byte_buf
argument_list|)
expr_stmt|;
name|byte_buf
operator|+=
sizeof|sizeof
argument_list|(
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
name|NVM_MAGIC_VALUE
condition|)
return|return
name|DBG_STATUS_INVALID_TRACE_SIGNATURE
return|;
comment|/* Extract number of modules */
name|modules_num
operator|=
operator|*
operator|(
name|byte_buf
operator|++
operator|)
expr_stmt|;
comment|/* Skip all modules */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modules_num
condition|;
name|i
operator|++
control|)
block|{
name|module_len
operator|=
operator|*
operator|(
name|byte_buf
operator|++
operator|)
expr_stmt|;
name|byte_buf
operator|+=
name|module_len
expr_stmt|;
block|}
comment|/* Extract and check second signature */
name|signature
operator|=
name|ecore_read_unaligned_dword
argument_list|(
name|byte_buf
argument_list|)
expr_stmt|;
name|byte_buf
operator|+=
sizeof|sizeof
argument_list|(
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
name|NVM_MAGIC_VALUE
condition|)
return|return
name|DBG_STATUS_INVALID_TRACE_SIGNATURE
return|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Dump MCP Trace */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_mcp_trace_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|trace_meta_offset_bytes
init|=
literal|0
decl_stmt|,
name|trace_meta_size_bytes
init|=
literal|0
decl_stmt|,
name|trace_meta_size_dwords
init|=
literal|0
decl_stmt|;
name|u32
name|trace_data_grc_addr
decl_stmt|,
name|trace_data_size_bytes
decl_stmt|,
name|trace_data_size_dwords
decl_stmt|;
name|u32
name|running_bundle_id
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
name|bool
name|mcp_access
decl_stmt|;
name|int
name|halted
init|=
literal|0
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
name|mcp_access
operator|=
operator|!
name|ecore_grc_get_param
argument_list|(
name|p_hwfn
argument_list|,
name|DBG_GRC_PARAM_NO_MCP
argument_list|)
expr_stmt|;
comment|/* Get trace data info */
name|status
operator|=
name|ecore_mcp_trace_get_data_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|trace_data_grc_addr
argument_list|,
operator|&
name|trace_data_size_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
comment|/* Dump global params */
name|offset
operator|+=
name|ecore_dump_common_global_params
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"dump-type"
argument_list|,
literal|"mcp-trace"
argument_list|)
expr_stmt|;
comment|/* Halt MCP while reading from scratchpad so the read data will be 	 * consistent. if halt fails, MCP trace is taken anyway, with a small 	 * risk that it may be corrupt. 	 */
if|if
condition|(
name|dump
operator|&&
name|mcp_access
condition|)
block|{
name|halted
operator|=
operator|!
name|ecore_mcp_halt
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|halted
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"MCP halt failed!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Find trace data size */
name|trace_data_size_dwords
operator|=
name|DIV_ROUND_UP
argument_list|(
name|trace_data_size_bytes
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mcp_trace
argument_list|)
argument_list|,
name|BYTES_IN_DWORD
argument_list|)
expr_stmt|;
comment|/* Dump trace data section header and param */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"mcp_trace_data"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
name|trace_data_size_dwords
argument_list|)
expr_stmt|;
comment|/* Read trace data from scratchpad into dump buffer */
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|BYTES_TO_DWORDS
argument_list|(
name|trace_data_grc_addr
argument_list|)
argument_list|,
name|trace_data_size_dwords
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Resume MCP (only if halt succeeded) */
if|if
condition|(
name|halted
operator|&&
name|ecore_mcp_resume
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Failed to resume MCP after halt!\n"
argument_list|)
expr_stmt|;
comment|/* Dump trace meta section header */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"mcp_trace_meta"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Read trace meta only if NVRAM access is enabled 	 * (trace_meta_size_bytes is dword-aligned). 	 */
if|if
condition|(
name|OSAL_NVM_IS_ACCESS_ENABLED
argument_list|(
name|p_hwfn
argument_list|)
operator|&&
name|mcp_access
condition|)
block|{
name|status
operator|=
name|ecore_mcp_trace_get_meta_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|trace_data_size_bytes
argument_list|,
operator|&
name|running_bundle_id
argument_list|,
operator|&
name|trace_meta_offset_bytes
argument_list|,
operator|&
name|trace_meta_size_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|DBG_STATUS_OK
condition|)
name|trace_meta_size_dwords
operator|=
name|BYTES_TO_DWORDS
argument_list|(
name|trace_meta_size_bytes
argument_list|)
expr_stmt|;
block|}
comment|/* Dump trace meta size param */
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
name|trace_meta_size_dwords
argument_list|)
expr_stmt|;
comment|/* Read trace meta image into dump buffer */
if|if
condition|(
name|dump
operator|&&
name|trace_meta_size_dwords
condition|)
name|status
operator|=
name|ecore_mcp_trace_read_meta
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|trace_meta_offset_bytes
argument_list|,
name|trace_meta_size_bytes
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|DBG_STATUS_OK
condition|)
name|offset
operator|+=
name|trace_meta_size_dwords
expr_stmt|;
comment|/* Dump last section */
name|offset
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
argument_list|,
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
operator|*
name|num_dumped_dwords
operator|=
name|offset
expr_stmt|;
comment|/* If no mcp access, indicate that the dump doesn't contain the meta 	 * data from NVRAM. 	 */
return|return
name|mcp_access
condition|?
name|status
else|:
name|DBG_STATUS_NVRAM_GET_IMAGE_FAILED
return|;
block|}
end_function

begin_comment
comment|/* Dump GRC FIFO */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_reg_fifo_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|dwords_read
decl_stmt|,
name|size_param_offset
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|bool
name|fifo_has_data
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
comment|/* Dump global params */
name|offset
operator|+=
name|ecore_dump_common_global_params
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"dump-type"
argument_list|,
literal|"reg-fifo"
argument_list|)
expr_stmt|;
comment|/* Dump fifo data section header and param. The size param is 0 for 	 * now, and is overwritten after reading the FIFO. 	 */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"reg_fifo_data"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size_param_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
name|fifo_has_data
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|GRC_REG_TRACE_FIFO_VALID_DATA
argument_list|)
operator|>
literal|0
expr_stmt|;
comment|/* Pull available data from fifo. Use DMAE since this is 		 * widebus memory and must be accessed atomically. Test for 		 * dwords_read not passing buffer size since more entries could 		 * be added to the buffer as we 		 * are emptying it. 		 */
for|for
control|(
name|dwords_read
operator|=
literal|0
init|;
name|fifo_has_data
operator|&&
name|dwords_read
operator|<
name|REG_FIFO_DEPTH_DWORDS
condition|;
name|dwords_read
operator|+=
name|REG_FIFO_ELEMENT_DWORDS
operator|,
name|offset
operator|+=
name|REG_FIFO_ELEMENT_DWORDS
control|)
block|{
if|if
condition|(
name|ecore_dmae_grc2host
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|GRC_REG_TRACE_FIFO
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
argument_list|(
operator|&
name|dump_buf
index|[
name|offset
index|]
argument_list|)
argument_list|,
name|REG_FIFO_ELEMENT_DWORDS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|DBG_STATUS_DMAE_FAILED
return|;
name|fifo_has_data
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|GRC_REG_TRACE_FIFO_VALID_DATA
argument_list|)
operator|>
literal|0
expr_stmt|;
block|}
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|size_param_offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
name|dwords_read
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIFO max size is REG_FIFO_DEPTH_DWORDS. There is no way to 		 * test how much data is available, except for reading it. 		 */
name|offset
operator|+=
name|REG_FIFO_DEPTH_DWORDS
expr_stmt|;
block|}
comment|/* Dump last section */
name|offset
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
argument_list|,
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
operator|*
name|num_dumped_dwords
operator|=
name|offset
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Dump IGU FIFO */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_igu_fifo_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|dwords_read
decl_stmt|,
name|size_param_offset
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|bool
name|fifo_has_data
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
comment|/* Dump global params */
name|offset
operator|+=
name|ecore_dump_common_global_params
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"dump-type"
argument_list|,
literal|"igu-fifo"
argument_list|)
expr_stmt|;
comment|/* Dump fifo data section header and param. The size param is 0 for 	 * now, and is overwritten after reading the FIFO. 	 */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"igu_fifo_data"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size_param_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
name|fifo_has_data
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_ERROR_HANDLING_DATA_VALID
argument_list|)
operator|>
literal|0
expr_stmt|;
comment|/* Pull available data from fifo. Use DMAE since this is 		 * widebus memory and must be accessed atomically. Test for 		 * dwords_read not passing buffer size since more entries could 		 * be added to the buffer as we are emptying it. 		 */
for|for
control|(
name|dwords_read
operator|=
literal|0
init|;
name|fifo_has_data
operator|&&
name|dwords_read
operator|<
name|IGU_FIFO_DEPTH_DWORDS
condition|;
name|dwords_read
operator|+=
name|IGU_FIFO_ELEMENT_DWORDS
operator|,
name|offset
operator|+=
name|IGU_FIFO_ELEMENT_DWORDS
control|)
block|{
if|if
condition|(
name|ecore_dmae_grc2host
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_ERROR_HANDLING_MEMORY
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
argument_list|(
operator|&
name|dump_buf
index|[
name|offset
index|]
argument_list|)
argument_list|,
name|IGU_FIFO_ELEMENT_DWORDS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|DBG_STATUS_DMAE_FAILED
return|;
name|fifo_has_data
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|IGU_REG_ERROR_HANDLING_DATA_VALID
argument_list|)
operator|>
literal|0
expr_stmt|;
block|}
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|size_param_offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
name|dwords_read
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIFO max size is IGU_FIFO_DEPTH_DWORDS. There is no way to 		 * test how much data is available, except for reading it. 		 */
name|offset
operator|+=
name|IGU_FIFO_DEPTH_DWORDS
expr_stmt|;
block|}
comment|/* Dump last section */
name|offset
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
argument_list|,
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
operator|*
name|num_dumped_dwords
operator|=
name|offset
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Protection Override dump */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_protection_override_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|size_param_offset
decl_stmt|,
name|override_window_dwords
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
comment|/* Dump global params */
name|offset
operator|+=
name|ecore_dump_common_global_params
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"dump-type"
argument_list|,
literal|"protection-override"
argument_list|)
expr_stmt|;
comment|/* Dump data section header and param. The size param is 0 for now, 	 * and is overwritten after reading the data. 	 */
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"protection_override_data"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size_param_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
comment|/* Add override window info to buffer */
name|override_window_dwords
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|GRC_REG_NUMBER_VALID_OVERRIDE_WINDOW
argument_list|)
operator|*
name|PROTECTION_OVERRIDE_ELEMENT_DWORDS
expr_stmt|;
if|if
condition|(
name|ecore_dmae_grc2host
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|GRC_REG_PROTECTION_OVERRIDE_WINDOW
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|osal_uintptr_t
argument_list|)
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|)
argument_list|,
name|override_window_dwords
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|DBG_STATUS_DMAE_FAILED
return|;
name|offset
operator|+=
name|override_window_dwords
expr_stmt|;
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|size_param_offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
name|override_window_dwords
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
name|PROTECTION_OVERRIDE_DEPTH_DWORDS
expr_stmt|;
block|}
comment|/* Dump last section */
name|offset
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
argument_list|,
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
operator|*
name|num_dumped_dwords
operator|=
name|offset
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Performs FW Asserts Dump to the specified buffer.  * Returns the dumped size in dwords.  */
end_comment

begin_function
specifier|static
name|u32
name|ecore_fw_asserts_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|bool
name|dump
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|fw_asserts_ram_section
modifier|*
name|asserts
decl_stmt|;
name|char
name|storm_letter_str
index|[
literal|2
index|]
init|=
literal|"?"
decl_stmt|;
name|struct
name|fw_info
name|fw_info
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
name|u8
name|storm_id
decl_stmt|;
comment|/* Dump global params */
name|offset
operator|+=
name|ecore_dump_common_global_params
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"dump-type"
argument_list|,
literal|"fw-asserts"
argument_list|)
expr_stmt|;
comment|/* Find Storm dump size */
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|u32
name|fw_asserts_section_addr
decl_stmt|,
name|next_list_idx_addr
decl_stmt|,
name|next_list_idx
decl_stmt|,
name|last_list_idx
decl_stmt|,
name|addr
decl_stmt|;
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|storm
operator|->
name|block_id
index|]
condition|)
continue|continue;
comment|/* Read FW info for the current Storm  */
name|ecore_read_fw_info
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm_id
argument_list|,
operator|&
name|fw_info
argument_list|)
expr_stmt|;
name|asserts
operator|=
operator|&
name|fw_info
operator|.
name|fw_asserts_section
expr_stmt|;
comment|/* Dump FW Asserts section header and params */
name|storm_letter_str
index|[
literal|0
index|]
operator|=
name|storm
operator|->
name|letter
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_section_hdr
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"fw_asserts"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_str_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"storm"
argument_list|,
name|storm_letter_str
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ecore_dump_num_param
argument_list|(
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
literal|"size"
argument_list|,
name|asserts
operator|->
name|list_element_dword_size
argument_list|)
expr_stmt|;
comment|/* Read and dump FW Asserts data */
if|if
condition|(
operator|!
name|dump
condition|)
block|{
name|offset
operator|+=
name|asserts
operator|->
name|list_element_dword_size
expr_stmt|;
continue|continue;
block|}
name|fw_asserts_section_addr
operator|=
name|storm
operator|->
name|sem_fast_mem_addr
operator|+
name|SEM_FAST_REG_INT_RAM
operator|+
name|RAM_LINES_TO_BYTES
argument_list|(
name|asserts
operator|->
name|section_ram_line_offset
argument_list|)
expr_stmt|;
name|next_list_idx_addr
operator|=
name|fw_asserts_section_addr
operator|+
name|DWORDS_TO_BYTES
argument_list|(
name|asserts
operator|->
name|list_next_index_dword_offset
argument_list|)
expr_stmt|;
name|next_list_idx
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|next_list_idx_addr
argument_list|)
expr_stmt|;
name|last_list_idx
operator|=
operator|(
name|next_list_idx
operator|>
literal|0
condition|?
name|next_list_idx
else|:
name|asserts
operator|->
name|list_num_elements
operator|)
operator|-
literal|1
expr_stmt|;
name|addr
operator|=
name|BYTES_TO_DWORDS
argument_list|(
name|fw_asserts_section_addr
argument_list|)
operator|+
name|asserts
operator|->
name|list_dword_offset
operator|+
name|last_list_idx
operator|*
name|asserts
operator|->
name|list_element_dword_size
expr_stmt|;
name|offset
operator|+=
name|ecore_grc_dump_addr_range
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|dump
argument_list|,
name|addr
argument_list|,
name|asserts
operator|->
name|list_element_dword_size
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Dump last section */
name|offset
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
argument_list|,
name|offset
argument_list|,
name|dump
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/***************************** Public Functions *******************************/
end_comment

begin_function
name|enum
name|dbg_status
name|ecore_dbg_set_bin_ptr
parameter_list|(
specifier|const
name|u8
modifier|*
specifier|const
name|bin_ptr
parameter_list|)
block|{
name|struct
name|bin_buffer_hdr
modifier|*
name|buf_array
init|=
operator|(
expr|struct
name|bin_buffer_hdr
operator|*
operator|)
name|bin_ptr
decl_stmt|;
name|u8
name|buf_id
decl_stmt|;
comment|/* convert binary data to debug arrays */
for|for
control|(
name|buf_id
operator|=
literal|0
init|;
name|buf_id
operator|<
name|MAX_BIN_DBG_BUFFER_TYPE
condition|;
name|buf_id
operator|++
control|)
block|{
name|s_dbg_arrays
index|[
name|buf_id
index|]
operator|.
name|ptr
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|bin_ptr
operator|+
name|buf_array
index|[
name|buf_id
index|]
operator|.
name|offset
operator|)
expr_stmt|;
name|s_dbg_arrays
index|[
name|buf_id
index|]
operator|.
name|size_in_dwords
operator|=
name|BYTES_TO_DWORDS
argument_list|(
name|buf_array
index|[
name|buf_id
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_set_app_ver
parameter_list|(
name|u32
name|ver
parameter_list|)
block|{
if|if
condition|(
name|ver
operator|<
name|TOOLS_VERSION
condition|)
return|return
name|DBG_STATUS_UNSUPPORTED_APP_VERSION
return|;
name|s_app_ver
operator|=
name|ver
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|u32
name|ecore_dbg_get_fw_func_ver
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TOOLS_VERSION
return|;
block|}
end_function

begin_function
name|enum
name|chip_ids
name|ecore_dbg_get_chip_id
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
return|return
operator|(
expr|enum
name|chip_ids
operator|)
name|dev_data
operator|->
name|chip_id
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_reset
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|one_shot_en
parameter_list|,
name|u8
name|force_hw_dwords
parameter_list|,
name|bool
name|unify_inputs
parameter_list|,
name|bool
name|grc_input_en
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
name|status
operator|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_reset: one_shot_en = %d, force_hw_dwords = %d, unify_inputs = %d, grc_input_en = %d\n"
argument_list|,
name|one_shot_en
argument_list|,
name|force_hw_dwords
argument_list|,
name|unify_inputs
argument_list|,
name|grc_input_en
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_hw_dwords
operator|&&
name|force_hw_dwords
operator|!=
literal|4
operator|&&
name|force_hw_dwords
operator|!=
literal|8
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_DBG_BLOCK_ON
argument_list|)
condition|)
return|return
name|DBG_STATUS_DBG_BUS_IN_USE
return|;
comment|/* Update reset state of all blocks */
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* Disable all debug inputs */
name|status
operator|=
name|ecore_bus_disable_inputs
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
comment|/* Reset DBG block */
name|ecore_bus_reset_dbg_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* Set one-shot / wrap-around */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_FULL_MODE
argument_list|,
name|one_shot_en
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Init state params */
name|OSAL_MEMSET
argument_list|(
operator|&
name|dev_data
operator|->
name|bus
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_data
operator|->
name|bus
argument_list|)
argument_list|)
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|target
operator|=
name|DBG_BUS_TARGET_ID_INT_BUF
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|=
name|DBG_BUS_STATE_READY
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|one_shot_en
operator|=
name|one_shot_en
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|hw_dwords
operator|=
name|force_hw_dwords
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|grc_input_en
operator|=
name|grc_input_en
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|unify_inputs
operator|=
name|unify_inputs
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|num_enabled_blocks
operator|=
name|grc_input_en
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Init special DBG block */
if|if
condition|(
name|grc_input_en
condition|)
name|SET_FIELD
argument_list|(
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|BLOCK_DBG
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_set_pci_output
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|buf_size_kb
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|dma_addr_t
name|pci_buf_phys_addr
decl_stmt|;
name|void
modifier|*
name|pci_buf
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_set_pci_output: buf_size_kb = %d\n"
argument_list|,
name|buf_size_kb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|target
operator|!=
name|DBG_BUS_TARGET_ID_INT_BUF
condition|)
return|return
name|DBG_STATUS_OUTPUT_ALREADY_SET
return|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|!=
name|DBG_BUS_STATE_READY
operator|||
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
operator|>
literal|0
condition|)
return|return
name|DBG_STATUS_DBG_BLOCK_NOT_RESET
return|;
name|dev_data
operator|->
name|bus
operator|.
name|target
operator|=
name|DBG_BUS_TARGET_ID_PCI
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
operator|=
name|buf_size_kb
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
operator|%
name|PCI_PKT_SIZE_IN_BYTES
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
name|pci_buf
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|pci_buf_phys_addr
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pci_buf
condition|)
return|return
name|DBG_STATUS_PCI_BUF_ALLOC_FAILED
return|;
name|OSAL_MEMCPY
argument_list|(
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|phys_addr
argument_list|,
operator|&
name|pci_buf_phys_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|pci_buf_phys_addr
argument_list|)
argument_list|)
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|virt_addr
operator|.
name|lo
operator|=
call|(
name|u32
call|)
argument_list|(
operator|(
name|u64
operator|)
operator|(
name|osal_uintptr_t
operator|)
name|pci_buf
argument_list|)
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|virt_addr
operator|.
name|hi
operator|=
call|(
name|u32
call|)
argument_list|(
operator|(
name|u64
operator|)
operator|(
name|osal_uintptr_t
operator|)
name|pci_buf
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_PCI_EXT_BUFFER_STRT_ADDR_LSB
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|phys_addr
operator|.
name|lo
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_PCI_EXT_BUFFER_STRT_ADDR_MSB
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|phys_addr
operator|.
name|hi
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TARGET_PACKET_SIZE
argument_list|,
name|PCI_PKT_SIZE_IN_CHUNKS
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_PCI_EXT_BUFFER_SIZE
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|pci_buf
operator|.
name|size
operator|/
name|PCI_PKT_SIZE_IN_BYTES
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_PCI_FUNC_NUM
argument_list|,
name|OPAQUE_FID
argument_list|(
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_PCI_LOGIC_ADDR
argument_list|,
name|PCI_PHYS_ADDR_TYPE
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_PCI_REQ_CREDIT
argument_list|,
name|PCI_REQ_CREDIT
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_DEBUG_TARGET
argument_list|,
name|DBG_BUS_TARGET_ID_PCI
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_OUTPUT_ENABLE
argument_list|,
name|TARGET_EN_MASK_PCI
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_set_nw_output
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|port_id
parameter_list|,
name|u32
name|dest_addr_lo32
parameter_list|,
name|u16
name|dest_addr_hi16
parameter_list|,
name|u16
name|data_limit_size_kb
parameter_list|,
name|bool
name|send_to_other_engine
parameter_list|,
name|bool
name|rcv_from_other_engine
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_set_nw_output: port_id = %d, dest_addr_lo32 = 0x%x, dest_addr_hi16 = 0x%x, data_limit_size_kb = %d, send_to_other_engine = %d, rcv_from_other_engine = %d\n"
argument_list|,
name|port_id
argument_list|,
name|dest_addr_lo32
argument_list|,
name|dest_addr_hi16
argument_list|,
name|data_limit_size_kb
argument_list|,
name|send_to_other_engine
argument_list|,
name|rcv_from_other_engine
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|target
operator|!=
name|DBG_BUS_TARGET_ID_INT_BUF
condition|)
return|return
name|DBG_STATUS_OUTPUT_ALREADY_SET
return|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|!=
name|DBG_BUS_STATE_READY
condition|)
return|return
name|DBG_STATUS_DBG_BLOCK_NOT_RESET
return|;
if|if
condition|(
name|port_id
operator|>=
name|s_chip_defs
index|[
name|dev_data
operator|->
name|chip_id
index|]
operator|.
name|per_platform
index|[
name|dev_data
operator|->
name|platform_id
index|]
operator|.
name|num_ports
operator|||
operator|(
name|send_to_other_engine
operator|&&
name|rcv_from_other_engine
operator|)
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
name|dev_data
operator|->
name|bus
operator|.
name|target
operator|=
name|DBG_BUS_TARGET_ID_NIG
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|rcv_from_other_engine
operator|=
name|rcv_from_other_engine
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_OUTPUT_ENABLE
argument_list|,
name|TARGET_EN_MASK_NIG
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_DEBUG_TARGET
argument_list|,
name|DBG_BUS_TARGET_ID_NIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_to_other_engine
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_OTHER_ENGINE_MODE_BB_K2
argument_list|,
name|DBG_BUS_OTHER_ENGINE_MODE_CROSS_ENGINE_TX
argument_list|)
expr_stmt|;
else|else
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|NIG_REG_DEBUG_PORT
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcv_from_other_engine
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_OTHER_ENGINE_MODE_BB_K2
argument_list|,
name|DBG_BUS_OTHER_ENGINE_MODE_CROSS_ENGINE_RX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Configure ethernet header of 14 bytes */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_ETHERNET_HDR_WIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_ETHERNET_HDR_7
argument_list|,
name|dest_addr_lo32
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_ETHERNET_HDR_6
argument_list|,
operator|(
name|u32
operator|)
name|SRC_MAC_ADDR_LO16
operator||
operator|(
operator|(
name|u32
operator|)
name|dest_addr_hi16
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_ETHERNET_HDR_5
argument_list|,
name|SRC_MAC_ADDR_HI32
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_ETHERNET_HDR_4
argument_list|,
operator|(
name|u32
operator|)
name|ETH_TYPE
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TARGET_PACKET_SIZE
argument_list|,
name|NIG_PKT_SIZE_IN_CHUNKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_limit_size_kb
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_NIG_DATA_LIMIT_SIZE
argument_list|,
operator|(
name|data_limit_size_kb
operator|*
literal|1024
operator|)
operator|/
name|CHUNK_SIZE_IN_BYTES
argument_list|)
expr_stmt|;
block|}
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_is_overlapping_enable_mask
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|enable_mask
parameter_list|,
name|u8
name|right_shift
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u8
name|curr_shifted_enable_mask
decl_stmt|,
name|shifted_enable_mask
decl_stmt|;
name|u32
name|block_id
decl_stmt|;
name|shifted_enable_mask
operator|=
name|SHR
argument_list|(
name|enable_mask
argument_list|,
name|VALUES_PER_CYCLE
argument_list|,
name|right_shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|num_enabled_blocks
condition|)
block|{
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_block_data
modifier|*
name|block_bus
init|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
condition|)
continue|continue;
name|curr_shifted_enable_mask
operator|=
name|SHR
argument_list|(
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
argument_list|,
name|VALUES_PER_CYCLE
argument_list|,
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_RIGHT_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shifted_enable_mask
operator|&
name|curr_shifted_enable_mask
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_enable_block
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|,
name|u8
name|line_num
parameter_list|,
name|u8
name|enable_mask
parameter_list|,
name|u8
name|right_shift
parameter_list|,
name|u8
name|force_valid_mask
parameter_list|,
name|u8
name|force_frame_mask
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
name|struct
name|dbg_bus_block_data
modifier|*
name|block_bus
decl_stmt|;
name|struct
name|dbg_bus_block
modifier|*
name|block_desc
decl_stmt|;
name|block_bus
operator|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
expr_stmt|;
name|block_desc
operator|=
name|get_dbg_bus_block_desc
argument_list|(
name|p_hwfn
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_enable_block: block = %d, line_num = %d, enable_mask = 0x%x, right_shift = %d, force_valid_mask = 0x%x, force_frame_mask = 0x%x\n"
argument_list|,
name|block_id
argument_list|,
name|line_num
argument_list|,
name|enable_mask
argument_list|,
name|right_shift
argument_list|,
name|force_valid_mask
argument_list|,
name|force_frame_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|!=
name|DBG_BUS_STATE_READY
condition|)
return|return
name|DBG_STATUS_DBG_BLOCK_NOT_RESET
return|;
if|if
condition|(
name|block_id
operator|>=
name|MAX_BLOCK_ID
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
condition|)
return|return
name|DBG_STATUS_BLOCK_ALREADY_ENABLED
return|;
if|if
condition|(
operator|!
name|block
operator|->
name|has_dbg_bus
index|[
name|dev_data
operator|->
name|chip_id
index|]
operator|||
name|line_num
operator|>=
name|NUM_DBG_LINES
argument_list|(
name|block_desc
argument_list|)
operator|||
operator|!
name|enable_mask
operator|||
name|enable_mask
operator|>
name|MAX_CYCLE_VALUES_MASK
operator|||
name|force_valid_mask
operator|>
name|MAX_CYCLE_VALUES_MASK
operator|||
name|force_frame_mask
operator|>
name|MAX_CYCLE_VALUES_MASK
operator|||
name|right_shift
operator|>
name|VALUES_PER_CYCLE
operator|-
literal|1
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|dev_data
operator|->
name|block_in_reset
index|[
name|block_id
index|]
condition|)
return|return
name|DBG_STATUS_BLOCK_IN_RESET
return|;
if|if
condition|(
operator|!
name|dev_data
operator|->
name|bus
operator|.
name|unify_inputs
operator|&&
name|ecore_is_overlapping_enable_mask
argument_list|(
name|p_hwfn
argument_list|,
name|enable_mask
argument_list|,
name|right_shift
argument_list|)
condition|)
return|return
name|DBG_STATUS_INPUT_OVERLAP
return|;
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
operator|.
name|line_num
operator|=
name|line_num
expr_stmt|;
name|SET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|,
name|enable_mask
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_RIGHT_SHIFT
argument_list|,
name|right_shift
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_FORCE_VALID_MASK
argument_list|,
name|force_valid_mask
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_FORCE_FRAME_MASK
argument_list|,
name|force_frame_mask
argument_list|)
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|num_enabled_blocks
operator|++
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_enable_storm
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_storms
name|storm
parameter_list|,
name|enum
name|dbg_bus_storm_modes
name|storm_mode
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_enable_storm: storm = %d, storm_mode = %d\n"
argument_list|,
name|storm
argument_list|,
name|storm_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|!=
name|DBG_BUS_STATE_READY
condition|)
return|return
name|DBG_STATUS_DBG_BLOCK_NOT_RESET
return|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|hw_dwords
operator|>=
literal|4
condition|)
return|return
name|DBG_STATUS_HW_ONLY_RECORDING
return|;
if|if
condition|(
name|storm
operator|>=
name|MAX_DBG_STORMS
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|storm_mode
operator|>=
name|MAX_DBG_BUS_STORM_MODES
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|unify_inputs
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm
index|]
operator|.
name|enabled
condition|)
return|return
name|DBG_STATUS_STORM_ALREADY_ENABLED
return|;
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm
index|]
operator|.
name|enabled
operator|=
name|true
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm
index|]
operator|.
name|mode
operator|=
operator|(
name|u8
operator|)
name|storm_mode
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm
index|]
operator|.
name|hw_id
operator|=
name|dev_data
operator|->
name|bus
operator|.
name|num_enabled_storms
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|num_enabled_storms
operator|++
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_enable_timestamp
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|valid_mask
parameter_list|,
name|u8
name|frame_mask
parameter_list|,
name|u32
name|tick_len
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_enable_timestamp: valid_mask = 0x%x, frame_mask = 0x%x, tick_len = %d\n"
argument_list|,
name|valid_mask
argument_list|,
name|frame_mask
argument_list|,
name|tick_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|!=
name|DBG_BUS_STATE_READY
condition|)
return|return
name|DBG_STATUS_DBG_BLOCK_NOT_RESET
return|;
if|if
condition|(
name|valid_mask
operator|>
literal|0x7
operator|||
name|frame_mask
operator|>
literal|0x7
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
operator|!
name|dev_data
operator|->
name|bus
operator|.
name|unify_inputs
operator|&&
name|ecore_is_overlapping_enable_mask
argument_list|(
name|p_hwfn
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|DBG_STATUS_INPUT_OVERLAP
return|;
name|dev_data
operator|->
name|bus
operator|.
name|timestamp_input_en
operator|=
name|true
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|num_enabled_blocks
operator|++
expr_stmt|;
name|SET_FIELD
argument_list|(
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|BLOCK_DBG
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TIMESTAMP_VALID_EN
argument_list|,
name|valid_mask
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TIMESTAMP_FRAME_EN
argument_list|,
name|frame_mask
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TIMESTAMP_TICK
argument_list|,
name|tick_len
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_add_eid_range_sem_filter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_storms
name|storm_id
parameter_list|,
name|u8
name|min_eid
parameter_list|,
name|u8
name|max_eid
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_storm_data
modifier|*
name|storm_bus
decl_stmt|;
name|storm_bus
operator|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm_id
index|]
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_add_eid_range_sem_filter: storm = %d, min_eid = 0x%x, max_eid = 0x%x\n"
argument_list|,
name|storm_id
argument_list|,
name|min_eid
argument_list|,
name|max_eid
argument_list|)
expr_stmt|;
if|if
condition|(
name|storm_id
operator|>=
name|MAX_DBG_STORMS
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|min_eid
operator|>
name|max_eid
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
operator|!
name|storm_bus
operator|->
name|enabled
condition|)
return|return
name|DBG_STATUS_STORM_NOT_ENABLED
return|;
name|storm_bus
operator|->
name|eid_filter_en
operator|=
literal|1
expr_stmt|;
name|storm_bus
operator|->
name|eid_range_not_mask
operator|=
literal|1
expr_stmt|;
name|storm_bus
operator|->
name|eid_filter_params
operator|.
name|range
operator|.
name|min
operator|=
name|min_eid
expr_stmt|;
name|storm_bus
operator|->
name|eid_filter_params
operator|.
name|range
operator|.
name|max
operator|=
name|max_eid
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_add_eid_mask_sem_filter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_storms
name|storm_id
parameter_list|,
name|u8
name|eid_val
parameter_list|,
name|u8
name|eid_mask
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_storm_data
modifier|*
name|storm_bus
decl_stmt|;
name|storm_bus
operator|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm_id
index|]
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_add_eid_mask_sem_filter: storm = %d, eid_val = 0x%x, eid_mask = 0x%x\n"
argument_list|,
name|storm_id
argument_list|,
name|eid_val
argument_list|,
name|eid_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|storm_id
operator|>=
name|MAX_DBG_STORMS
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
operator|!
name|storm_bus
operator|->
name|enabled
condition|)
return|return
name|DBG_STATUS_STORM_NOT_ENABLED
return|;
name|storm_bus
operator|->
name|eid_filter_en
operator|=
literal|1
expr_stmt|;
name|storm_bus
operator|->
name|eid_range_not_mask
operator|=
literal|0
expr_stmt|;
name|storm_bus
operator|->
name|eid_filter_params
operator|.
name|mask
operator|.
name|val
operator|=
name|eid_val
expr_stmt|;
name|storm_bus
operator|->
name|eid_filter_params
operator|.
name|mask
operator|.
name|mask
operator|=
name|eid_mask
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_add_cid_sem_filter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_storms
name|storm_id
parameter_list|,
name|u32
name|cid
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_storm_data
modifier|*
name|storm_bus
decl_stmt|;
name|storm_bus
operator|=
operator|&
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm_id
index|]
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_add_cid_sem_filter: storm = %d, cid = 0x%x\n"
argument_list|,
name|storm_id
argument_list|,
name|cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|storm_id
operator|>=
name|MAX_DBG_STORMS
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
operator|!
name|storm_bus
operator|->
name|enabled
condition|)
return|return
name|DBG_STATUS_STORM_NOT_ENABLED
return|;
name|storm_bus
operator|->
name|cid_filter_en
operator|=
literal|1
expr_stmt|;
name|storm_bus
operator|->
name|cid
operator|=
name|cid
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_enable_filter
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|,
name|u8
name|const_msg_len
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_enable_filter: block = %d, const_msg_len = %d\n"
argument_list|,
name|block_id
argument_list|,
name|const_msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|!=
name|DBG_BUS_STATE_READY
condition|)
return|return
name|DBG_STATUS_DBG_BLOCK_NOT_RESET
return|;
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|filter_en
condition|)
return|return
name|DBG_STATUS_FILTER_ALREADY_ENABLED
return|;
if|if
condition|(
name|block_id
operator|>=
name|MAX_BLOCK_ID
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
operator|!
name|GET_FIELD
argument_list|(
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
condition|)
return|return
name|DBG_STATUS_BLOCK_NOT_ENABLED
return|;
if|if
condition|(
operator|!
name|dev_data
operator|->
name|bus
operator|.
name|unify_inputs
condition|)
return|return
name|DBG_STATUS_FILTER_BUG
return|;
name|dev_data
operator|->
name|bus
operator|.
name|filter_en
operator|=
name|true
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|next_constraint_id
operator|=
literal|0
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|adding_filter
operator|=
name|true
expr_stmt|;
comment|/* HW ID is set to 0 due to required unifyInputs */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_FILTER_ID_NUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_FILTER_MSG_LENGTH_ENABLE
argument_list|,
name|const_msg_len
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_msg_len
operator|>
literal|0
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_FILTER_MSG_LENGTH
argument_list|,
name|const_msg_len
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_enable_trigger
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|bool
name|rec_pre_trigger
parameter_list|,
name|u8
name|pre_chunks
parameter_list|,
name|bool
name|rec_post_trigger
parameter_list|,
name|u32
name|post_cycles
parameter_list|,
name|bool
name|filter_pre_trigger
parameter_list|,
name|bool
name|filter_post_trigger
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|enum
name|dbg_bus_post_trigger_types
name|post_trigger_type
decl_stmt|;
name|enum
name|dbg_bus_pre_trigger_types
name|pre_trigger_type
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_enable_trigger: rec_pre_trigger = %d, pre_chunks = %d, rec_post_trigger = %d, post_cycles = %d, filter_pre_trigger = %d, filter_post_trigger = %d\n"
argument_list|,
name|rec_pre_trigger
argument_list|,
name|pre_chunks
argument_list|,
name|rec_post_trigger
argument_list|,
name|post_cycles
argument_list|,
name|filter_pre_trigger
argument_list|,
name|filter_post_trigger
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|state
operator|!=
name|DBG_BUS_STATE_READY
condition|)
return|return
name|DBG_STATUS_DBG_BLOCK_NOT_RESET
return|;
if|if
condition|(
name|bus
operator|->
name|trigger_en
condition|)
return|return
name|DBG_STATUS_TRIGGER_ALREADY_ENABLED
return|;
if|if
condition|(
name|rec_pre_trigger
operator|&&
name|pre_chunks
operator|>=
name|INT_BUF_SIZE_IN_CHUNKS
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
name|bus
operator|->
name|trigger_en
operator|=
name|true
expr_stmt|;
name|bus
operator|->
name|filter_pre_trigger
operator|=
name|filter_pre_trigger
expr_stmt|;
name|bus
operator|->
name|filter_post_trigger
operator|=
name|filter_post_trigger
expr_stmt|;
if|if
condition|(
name|rec_pre_trigger
condition|)
block|{
name|pre_trigger_type
operator|=
name|pre_chunks
condition|?
name|DBG_BUS_PRE_TRIGGER_NUM_CHUNKS
else|:
name|DBG_BUS_PRE_TRIGGER_START_FROM_ZERO
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_RCRD_ON_WINDOW_PRE_NUM_CHUNKS
argument_list|,
name|pre_chunks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pre_trigger_type
operator|=
name|DBG_BUS_PRE_TRIGGER_DROP
expr_stmt|;
block|}
if|if
condition|(
name|rec_post_trigger
condition|)
block|{
name|post_trigger_type
operator|=
name|DBG_BUS_POST_TRIGGER_RECORD
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_RCRD_ON_WINDOW_POST_NUM_CYCLES
argument_list|,
name|post_cycles
condition|?
name|post_cycles
else|:
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|post_trigger_type
operator|=
name|DBG_BUS_POST_TRIGGER_DROP
expr_stmt|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_RCRD_ON_WINDOW_PRE_TRGR_EVNT_MODE
argument_list|,
name|pre_trigger_type
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_RCRD_ON_WINDOW_POST_TRGR_EVNT_MODE
argument_list|,
name|post_trigger_type
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_add_trigger_state
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|,
name|u8
name|const_msg_len
parameter_list|,
name|u16
name|count_to_next
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|struct
name|dbg_bus_block_data
modifier|*
name|block_bus
decl_stmt|;
name|u8
name|reg_offset
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_add_trigger_state: block = %d, const_msg_len = %d, count_to_next = %d\n"
argument_list|,
name|block_id
argument_list|,
name|const_msg_len
argument_list|,
name|count_to_next
argument_list|)
expr_stmt|;
name|block_bus
operator|=
operator|&
name|bus
operator|->
name|blocks
index|[
name|block_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bus
operator|->
name|trigger_en
condition|)
return|return
name|DBG_STATUS_TRIGGER_NOT_ENABLED
return|;
if|if
condition|(
name|bus
operator|->
name|next_trigger_state
operator|==
name|MAX_TRIGGER_STATES
condition|)
return|return
name|DBG_STATUS_TOO_MANY_TRIGGER_STATES
return|;
if|if
condition|(
name|block_id
operator|>=
name|MAX_BLOCK_ID
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
operator|!
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
condition|)
return|return
name|DBG_STATUS_BLOCK_NOT_ENABLED
return|;
if|if
condition|(
operator|!
name|count_to_next
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
name|bus
operator|->
name|next_constraint_id
operator|=
literal|0
expr_stmt|;
name|bus
operator|->
name|adding_filter
operator|=
name|false
expr_stmt|;
comment|/* Store block's shifted enable mask */
name|SET_FIELD
argument_list|(
name|bus
operator|->
name|trigger_states
index|[
name|dev_data
operator|->
name|bus
operator|.
name|next_trigger_state
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_TRIGGER_STATE_DATA_BLOCK_SHIFTED_ENABLE_MASK
argument_list|,
name|SHR
argument_list|(
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
argument_list|,
name|VALUES_PER_CYCLE
argument_list|,
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_RIGHT_SHIFT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set trigger state registers */
name|reg_offset
operator|=
name|bus
operator|->
name|next_trigger_state
operator|*
name|BYTES_IN_DWORD
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_STATE_MSG_LENGTH_ENABLE_0
operator|+
name|reg_offset
argument_list|,
name|const_msg_len
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_msg_len
operator|>
literal|0
condition|)
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_STATE_MSG_LENGTH_0
operator|+
name|reg_offset
argument_list|,
name|const_msg_len
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set trigger set registers */
name|reg_offset
operator|=
name|bus
operator|->
name|next_trigger_state
operator|*
name|TRIGGER_SETS_PER_STATE
operator|*
name|BYTES_IN_DWORD
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_STATE_SET_COUNT_0
operator|+
name|reg_offset
argument_list|,
name|count_to_next
argument_list|)
expr_stmt|;
comment|/* Set next state to final state, and overwrite previous next state 	 * (if any). 	 */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_STATE_SET_NXT_STATE_0
operator|+
name|reg_offset
argument_list|,
name|MAX_TRIGGER_STATES
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|next_trigger_state
operator|>
literal|0
condition|)
block|{
name|reg_offset
operator|=
operator|(
name|bus
operator|->
name|next_trigger_state
operator|-
literal|1
operator|)
operator|*
name|TRIGGER_SETS_PER_STATE
operator|*
name|BYTES_IN_DWORD
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_STATE_SET_NXT_STATE_0
operator|+
name|reg_offset
argument_list|,
name|bus
operator|->
name|next_trigger_state
argument_list|)
expr_stmt|;
block|}
name|bus
operator|->
name|next_trigger_state
operator|++
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_add_constraint
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|dbg_bus_constraint_ops
name|constraint_op
parameter_list|,
name|u32
name|data_val
parameter_list|,
name|u32
name|data_mask
parameter_list|,
name|bool
name|compare_frame
parameter_list|,
name|u8
name|frame_bit
parameter_list|,
name|u8
name|cycle_offset
parameter_list|,
name|u8
name|dword_offset_in_cycle
parameter_list|,
name|bool
name|is_mandatory
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|u16
name|dword_offset
decl_stmt|,
name|range
init|=
literal|0
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_add_constraint: op = %d, data_val = 0x%x, data_mask = 0x%x, compare_frame = %d, frame_bit = %d, cycle_offset = %d, dword_offset_in_cycle = %d, is_mandatory = %d\n"
argument_list|,
name|constraint_op
argument_list|,
name|data_val
argument_list|,
name|data_mask
argument_list|,
name|compare_frame
argument_list|,
name|frame_bit
argument_list|,
name|cycle_offset
argument_list|,
name|dword_offset_in_cycle
argument_list|,
name|is_mandatory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bus
operator|->
name|filter_en
operator|&&
operator|!
name|dev_data
operator|->
name|bus
operator|.
name|trigger_en
condition|)
return|return
name|DBG_STATUS_CANT_ADD_CONSTRAINT
return|;
if|if
condition|(
name|bus
operator|->
name|trigger_en
operator|&&
operator|!
name|bus
operator|->
name|adding_filter
operator|&&
operator|!
name|bus
operator|->
name|next_trigger_state
condition|)
return|return
name|DBG_STATUS_CANT_ADD_CONSTRAINT
return|;
if|if
condition|(
name|bus
operator|->
name|next_constraint_id
operator|>=
name|MAX_CONSTRAINTS
condition|)
return|return
name|DBG_STATUS_TOO_MANY_CONSTRAINTS
return|;
if|if
condition|(
name|constraint_op
operator|>=
name|MAX_DBG_BUS_CONSTRAINT_OPS
operator|||
name|frame_bit
operator|>
literal|1
operator|||
name|dword_offset_in_cycle
operator|>
literal|3
operator|||
operator|(
name|bus
operator|->
name|adding_filter
operator|&&
name|cycle_offset
operator|>
literal|3
operator|)
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|compare_frame
operator|&&
name|constraint_op
operator|!=
name|DBG_BUS_CONSTRAINT_OP_EQ
operator|&&
name|constraint_op
operator|!=
name|DBG_BUS_CONSTRAINT_OP_NE
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
name|dword_offset
operator|=
name|cycle_offset
operator|*
name|VALUES_PER_CYCLE
operator|+
name|dword_offset_in_cycle
expr_stmt|;
if|if
condition|(
operator|!
name|bus
operator|->
name|adding_filter
condition|)
block|{
name|u8
name|curr_trigger_state_id
init|=
name|bus
operator|->
name|next_trigger_state
operator|-
literal|1
decl_stmt|;
name|struct
name|dbg_bus_trigger_state_data
modifier|*
name|trigger_state
decl_stmt|;
name|trigger_state
operator|=
operator|&
name|bus
operator|->
name|trigger_states
index|[
name|curr_trigger_state_id
index|]
expr_stmt|;
comment|/* Check if the selected dword is enabled in the block */
if|if
condition|(
operator|!
operator|(
name|GET_FIELD
argument_list|(
name|trigger_state
operator|->
name|data
argument_list|,
name|DBG_BUS_TRIGGER_STATE_DATA_BLOCK_SHIFTED_ENABLE_MASK
argument_list|)
operator|&
call|(
name|u8
call|)
argument_list|(
literal|1
operator|<<
name|dword_offset_in_cycle
argument_list|)
operator|)
condition|)
return|return
name|DBG_STATUS_INVALID_TRIGGER_DWORD_OFFSET
return|;
comment|/* Add selected dword to trigger state's dword mask */
name|SET_FIELD
argument_list|(
name|trigger_state
operator|->
name|data
argument_list|,
name|DBG_BUS_TRIGGER_STATE_DATA_CONSTRAINT_DWORD_MASK
argument_list|,
name|GET_FIELD
argument_list|(
name|trigger_state
operator|->
name|data
argument_list|,
name|DBG_BUS_TRIGGER_STATE_DATA_CONSTRAINT_DWORD_MASK
argument_list|)
operator||
call|(
name|u8
call|)
argument_list|(
literal|1
operator|<<
name|dword_offset_in_cycle
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare data mask and range */
if|if
condition|(
name|constraint_op
operator|==
name|DBG_BUS_CONSTRAINT_OP_EQ
operator|||
name|constraint_op
operator|==
name|DBG_BUS_CONSTRAINT_OP_NE
condition|)
block|{
name|data_mask
operator|=
operator|~
name|data_mask
expr_stmt|;
block|}
else|else
block|{
name|u8
name|lsb
decl_stmt|,
name|width
decl_stmt|;
comment|/* Extract lsb and width from mask */
if|if
condition|(
operator|!
name|data_mask
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
for|for
control|(
name|lsb
operator|=
literal|0
init|;
name|lsb
operator|<
literal|32
operator|&&
operator|!
operator|(
name|data_mask
operator|&
literal|1
operator|)
condition|;
name|lsb
operator|++
operator|,
name|data_mask
operator|>>=
literal|1
control|)
empty_stmt|;
for|for
control|(
name|width
operator|=
literal|0
init|;
name|width
operator|<
literal|32
operator|-
name|lsb
operator|&&
operator|(
name|data_mask
operator|&
literal|1
operator|)
condition|;
name|width
operator|++
operator|,
name|data_mask
operator|>>=
literal|1
control|)
block|{}
if|if
condition|(
name|data_mask
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
name|range
operator|=
operator|(
name|lsb
operator|<<
literal|5
operator|)
operator||
operator|(
name|width
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Add constraint */
name|ecore_bus_set_constraint
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|adding_filter
condition|?
literal|1
else|:
literal|0
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|next_constraint_id
argument_list|,
name|s_constraint_op_defs
index|[
name|constraint_op
index|]
operator|.
name|hw_op_val
argument_list|,
name|data_val
argument_list|,
name|data_mask
argument_list|,
name|frame_bit
argument_list|,
name|compare_frame
condition|?
literal|0
else|:
literal|1
argument_list|,
name|dword_offset
argument_list|,
name|range
argument_list|,
name|s_constraint_op_defs
index|[
name|constraint_op
index|]
operator|.
name|is_cyclic
condition|?
literal|1
else|:
literal|0
argument_list|,
name|is_mandatory
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* If first constraint, fill other 3 constraints with dummy constraints 	 * that always match (using the same offset). 	 */
if|if
condition|(
operator|!
name|dev_data
operator|->
name|bus
operator|.
name|next_constraint_id
condition|)
block|{
name|u8
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_CONSTRAINTS
condition|;
name|i
operator|++
control|)
name|ecore_bus_set_constraint
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|bus
operator|->
name|adding_filter
condition|?
literal|1
else|:
literal|0
argument_list|,
name|i
argument_list|,
name|DBG_BUS_CONSTRAINT_OP_EQ
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|dword_offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|bus
operator|->
name|next_constraint_id
operator|++
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Configure the DBG block client mask */
end_comment

begin_function
specifier|static
name|void
name|ecore_config_dbg_block_client_mask
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|u32
name|block_id
decl_stmt|,
name|client_mask
init|=
literal|0
decl_stmt|;
name|u8
name|storm_id
decl_stmt|;
comment|/* Update client mask for Storm inputs */
if|if
condition|(
name|bus
operator|->
name|num_enabled_storms
condition|)
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
name|bus
operator|->
name|storms
index|[
name|storm_id
index|]
operator|.
name|enabled
condition|)
name|client_mask
operator||=
operator|(
literal|1
operator|<<
name|storm
operator|->
name|dbg_client_id
index|[
name|dev_data
operator|->
name|chip_id
index|]
operator|)
expr_stmt|;
block|}
comment|/* Update client mask for block inputs */
if|if
condition|(
name|bus
operator|->
name|num_enabled_blocks
condition|)
block|{
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_block_data
modifier|*
name|block_bus
init|=
operator|&
name|bus
operator|->
name|blocks
index|[
name|block_id
index|]
decl_stmt|;
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
if|if
condition|(
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
operator|&&
name|block_id
operator|!=
name|BLOCK_DBG
condition|)
name|client_mask
operator||=
operator|(
literal|1
operator|<<
name|block
operator|->
name|dbg_client_id
index|[
name|dev_data
operator|->
name|chip_id
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/* Update client mask for GRC input */
if|if
condition|(
name|bus
operator|->
name|grc_input_en
condition|)
name|client_mask
operator||=
operator|(
literal|1
operator|<<
name|DBG_BUS_CLIENT_CPU
operator|)
expr_stmt|;
comment|/* Update client mask for timestamp input */
if|if
condition|(
name|bus
operator|->
name|timestamp_input_en
condition|)
name|client_mask
operator||=
operator|(
literal|1
operator|<<
name|DBG_BUS_CLIENT_TIMESTAMP
operator|)
expr_stmt|;
name|ecore_bus_enable_clients
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|client_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Configure the DBG block framing mode */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_config_dbg_block_framing_mode
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|enum
name|dbg_bus_frame_modes
name|dbg_framing_mode
decl_stmt|;
name|u32
name|block_id
decl_stmt|;
if|if
condition|(
operator|!
name|bus
operator|->
name|hw_dwords
operator|&&
name|bus
operator|->
name|num_enabled_blocks
condition|)
block|{
name|struct
name|dbg_bus_line
modifier|*
name|line_desc
decl_stmt|;
name|u8
name|hw_dwords
decl_stmt|;
comment|/* Choose either 4 HW dwords (128-bit mode) or 8 HW dwords 		 * (256-bit mode). 		 */
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_block_data
modifier|*
name|block_bus
init|=
operator|&
name|bus
operator|->
name|blocks
index|[
name|block_id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
condition|)
continue|continue;
name|line_desc
operator|=
name|get_dbg_bus_line_desc
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|block_id
operator|)
name|block_id
argument_list|)
expr_stmt|;
name|hw_dwords
operator|=
name|line_desc
operator|&&
name|GET_FIELD
argument_list|(
name|line_desc
operator|->
name|data
argument_list|,
name|DBG_BUS_LINE_IS_256B
argument_list|)
condition|?
literal|8
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|hw_dwords
operator|>
literal|0
operator|&&
name|bus
operator|->
name|hw_dwords
operator|!=
name|hw_dwords
condition|)
return|return
name|DBG_STATUS_NON_MATCHING_LINES
return|;
comment|/* The DBG block doesn't support triggers and 			 * filters on 256b debug lines. 			 */
if|if
condition|(
name|hw_dwords
operator|==
literal|8
operator|&&
operator|(
name|bus
operator|->
name|trigger_en
operator|||
name|bus
operator|->
name|filter_en
operator|)
condition|)
return|return
name|DBG_STATUS_NO_FILTER_TRIGGER_64B
return|;
name|bus
operator|->
name|hw_dwords
operator|=
name|hw_dwords
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|bus
operator|->
name|hw_dwords
condition|)
block|{
case|case
literal|0
case|:
name|dbg_framing_mode
operator|=
name|DBG_BUS_FRAME_MODE_0HW_4ST
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|dbg_framing_mode
operator|=
name|DBG_BUS_FRAME_MODE_4HW_0ST
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|dbg_framing_mode
operator|=
name|DBG_BUS_FRAME_MODE_8HW_0ST
expr_stmt|;
break|break;
default|default:
name|dbg_framing_mode
operator|=
name|DBG_BUS_FRAME_MODE_0HW_4ST
expr_stmt|;
break|break;
block|}
name|ecore_bus_set_framing_mode
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dbg_framing_mode
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Configure the DBG block Storm data */
end_comment

begin_function
specifier|static
name|enum
name|dbg_status
name|ecore_config_storm_inputs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|u8
name|storm_id
decl_stmt|,
name|i
decl_stmt|,
name|next_storm_id
init|=
literal|0
decl_stmt|;
name|u32
name|storm_id_mask
init|=
literal|0
decl_stmt|;
comment|/* Check if SEMI sync FIFO is empty */
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_storm_data
modifier|*
name|storm_bus
init|=
operator|&
name|bus
operator|->
name|storms
index|[
name|storm_id
index|]
decl_stmt|;
name|struct
name|storm_defs
modifier|*
name|storm
init|=
operator|&
name|s_storm_defs
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
name|storm_bus
operator|->
name|enabled
operator|&&
operator|!
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|storm
operator|->
name|sem_sync_dbg_empty_addr
argument_list|)
condition|)
return|return
name|DBG_STATUS_SEMI_FIFO_NOT_EMPTY
return|;
block|}
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_storm_data
modifier|*
name|storm_bus
init|=
operator|&
name|bus
operator|->
name|storms
index|[
name|storm_id
index|]
decl_stmt|;
if|if
condition|(
name|storm_bus
operator|->
name|enabled
condition|)
name|storm_id_mask
operator||=
operator|(
name|storm_bus
operator|->
name|hw_id
operator|<<
operator|(
name|storm_id
operator|*
name|HW_ID_BITS
operator|)
operator|)
expr_stmt|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_STORM_ID_NUM
argument_list|,
name|storm_id_mask
argument_list|)
expr_stmt|;
comment|/* Disable storm stall if recording to internal buffer in one-shot */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_NO_GRANT_ON_FULL
argument_list|,
operator|(
name|dev_data
operator|->
name|bus
operator|.
name|target
operator|==
name|DBG_BUS_TARGET_ID_INT_BUF
operator|&&
name|bus
operator|->
name|one_shot_en
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Configure calendar */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CALENDAR_SLOTS
condition|;
name|i
operator|++
operator|,
name|next_storm_id
operator|=
operator|(
name|next_storm_id
operator|+
literal|1
operator|)
operator|%
name|MAX_DBG_STORMS
control|)
block|{
comment|/* Find next enabled Storm */
for|for
control|(
init|;
operator|!
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|next_storm_id
index|]
operator|.
name|enabled
condition|;
name|next_storm_id
operator|=
operator|(
name|next_storm_id
operator|+
literal|1
operator|)
operator|%
name|MAX_DBG_STORMS
control|)
empty_stmt|;
comment|/* Configure calendar slot */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_CALENDAR_SLOT0
operator|+
name|DWORDS_TO_BYTES
argument_list|(
name|i
argument_list|)
argument_list|,
name|next_storm_id
argument_list|)
expr_stmt|;
block|}
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Assign HW ID to each dword/qword:  * if the inputs are unified, HW ID 0 is assigned to all dwords/qwords.  * Otherwise, we would like to assign a different HW ID to each dword, to avoid  * data synchronization issues. however, we need to check if there is a trigger  * state for which more than one dword has a constraint. if there is, we cannot  * assign a different HW ID to each dword (since a trigger state has a single  * HW ID), so we assign a different HW ID to each block.  */
end_comment

begin_function
specifier|static
name|void
name|ecore_assign_hw_ids
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|hw_ids
index|[
name|VALUES_PER_CYCLE
index|]
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|bool
name|hw_id_per_dword
init|=
name|true
decl_stmt|;
name|u8
name|val_id
decl_stmt|,
name|state_id
decl_stmt|;
name|u32
name|block_id
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
name|hw_ids
argument_list|,
literal|0
argument_list|,
name|VALUES_PER_CYCLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|unify_inputs
condition|)
return|return;
if|if
condition|(
name|bus
operator|->
name|trigger_en
condition|)
block|{
for|for
control|(
name|state_id
operator|=
literal|0
init|;
name|state_id
operator|<
name|bus
operator|->
name|next_trigger_state
operator|&&
name|hw_id_per_dword
condition|;
name|state_id
operator|++
control|)
block|{
name|u8
name|num_dwords
init|=
literal|0
decl_stmt|;
for|for
control|(
name|val_id
operator|=
literal|0
init|;
name|val_id
operator|<
name|VALUES_PER_CYCLE
condition|;
name|val_id
operator|++
control|)
if|if
condition|(
name|GET_FIELD
argument_list|(
name|bus
operator|->
name|trigger_states
index|[
name|state_id
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_TRIGGER_STATE_DATA_CONSTRAINT_DWORD_MASK
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|val_id
operator|)
condition|)
name|num_dwords
operator|++
expr_stmt|;
if|if
condition|(
name|num_dwords
operator|>
literal|1
condition|)
name|hw_id_per_dword
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw_id_per_dword
condition|)
block|{
comment|/* Assign a different HW ID for each dword */
for|for
control|(
name|val_id
operator|=
literal|0
init|;
name|val_id
operator|<
name|VALUES_PER_CYCLE
condition|;
name|val_id
operator|++
control|)
name|hw_ids
index|[
name|val_id
index|]
operator|=
name|val_id
expr_stmt|;
block|}
else|else
block|{
name|u8
name|shifted_enable_mask
decl_stmt|,
name|next_hw_id
init|=
literal|0
decl_stmt|;
comment|/* Assign HW IDs according to blocks enable /  */
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_block_data
modifier|*
name|block_bus
init|=
operator|&
name|bus
operator|->
name|blocks
index|[
name|block_id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
condition|)
continue|continue;
name|block_bus
operator|->
name|hw_id
operator|=
name|next_hw_id
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|block_bus
operator|->
name|hw_id
condition|)
continue|continue;
name|shifted_enable_mask
operator|=
name|SHR
argument_list|(
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
argument_list|,
name|VALUES_PER_CYCLE
argument_list|,
name|GET_FIELD
argument_list|(
name|block_bus
operator|->
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_RIGHT_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|val_id
operator|=
literal|0
init|;
name|val_id
operator|<
name|VALUES_PER_CYCLE
condition|;
name|val_id
operator|++
control|)
if|if
condition|(
name|shifted_enable_mask
operator|&
operator|(
literal|1
operator|<<
name|val_id
operator|)
condition|)
name|hw_ids
index|[
name|val_id
index|]
operator|=
name|block_bus
operator|->
name|hw_id
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Configure the DBG block HW blocks data */
end_comment

begin_function
specifier|static
name|void
name|ecore_config_block_inputs
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|u8
name|hw_ids
index|[
name|VALUES_PER_CYCLE
index|]
decl_stmt|;
name|u8
name|val_id
decl_stmt|,
name|state_id
decl_stmt|;
name|ecore_assign_hw_ids
argument_list|(
name|p_hwfn
argument_list|,
name|hw_ids
argument_list|)
expr_stmt|;
comment|/* Assign a HW ID to each trigger state */
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|trigger_en
condition|)
block|{
for|for
control|(
name|state_id
operator|=
literal|0
init|;
name|state_id
operator|<
name|bus
operator|->
name|next_trigger_state
condition|;
name|state_id
operator|++
control|)
block|{
for|for
control|(
name|val_id
operator|=
literal|0
init|;
name|val_id
operator|<
name|VALUES_PER_CYCLE
condition|;
name|val_id
operator|++
control|)
block|{
name|u8
name|state_data
init|=
name|bus
operator|->
name|trigger_states
index|[
name|state_id
index|]
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|GET_FIELD
argument_list|(
name|state_data
argument_list|,
name|DBG_BUS_TRIGGER_STATE_DATA_CONSTRAINT_DWORD_MASK
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|val_id
operator|)
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_STATE_ID_0
operator|+
name|state_id
operator|*
name|BYTES_IN_DWORD
argument_list|,
name|hw_ids
index|[
name|val_id
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Configure HW ID mask */
name|dev_data
operator|->
name|bus
operator|.
name|hw_id_mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|val_id
operator|=
literal|0
init|;
name|val_id
operator|<
name|VALUES_PER_CYCLE
condition|;
name|val_id
operator|++
control|)
name|bus
operator|->
name|hw_id_mask
operator||=
operator|(
name|hw_ids
index|[
name|val_id
index|]
operator|<<
operator|(
name|val_id
operator|*
name|HW_ID_BITS
operator|)
operator|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_HW_ID_NUM
argument_list|,
name|bus
operator|->
name|hw_id_mask
argument_list|)
expr_stmt|;
comment|/* Configure additional K2 PCIE registers */
if|if
condition|(
name|dev_data
operator|->
name|chip_id
operator|==
name|CHIP_K2
operator|&&
operator|(
name|GET_FIELD
argument_list|(
name|bus
operator|->
name|blocks
index|[
name|BLOCK_PCIE
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
operator|||
name|GET_FIELD
argument_list|(
name|bus
operator|->
name|blocks
index|[
name|BLOCK_PHY_PCIE
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
operator|)
condition|)
block|{
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PCIE_REG_DBG_REPEAT_THRESHOLD_COUNT_K2_E5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|PCIE_REG_DBG_FW_TRIGGER_ENABLE_K2_E5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_start
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|enum
name|dbg_bus_filter_types
name|filter_type
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
name|u32
name|block_id
decl_stmt|;
name|u8
name|storm_id
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|state
operator|!=
name|DBG_BUS_STATE_READY
condition|)
return|return
name|DBG_STATUS_DBG_BLOCK_NOT_RESET
return|;
comment|/* Check if any input was enabled */
if|if
condition|(
operator|!
name|bus
operator|->
name|num_enabled_storms
operator|&&
operator|!
name|bus
operator|->
name|num_enabled_blocks
operator|&&
operator|!
name|bus
operator|->
name|rcv_from_other_engine
condition|)
return|return
name|DBG_STATUS_NO_INPUT_ENABLED
return|;
comment|/* Check if too many input types were enabled (storm+dbgmux) */
if|if
condition|(
name|bus
operator|->
name|num_enabled_storms
operator|&&
name|bus
operator|->
name|num_enabled_blocks
condition|)
return|return
name|DBG_STATUS_TOO_MANY_INPUTS
return|;
comment|/* Configure framing mode */
if|if
condition|(
operator|(
name|status
operator|=
name|ecore_config_dbg_block_framing_mode
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
operator|)
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
comment|/* Configure DBG block for Storm inputs */
if|if
condition|(
name|bus
operator|->
name|num_enabled_storms
condition|)
if|if
condition|(
operator|(
name|status
operator|=
name|ecore_config_storm_inputs
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
operator|)
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
comment|/* Configure DBG block for block inputs */
if|if
condition|(
name|bus
operator|->
name|num_enabled_blocks
condition|)
name|ecore_config_block_inputs
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* Configure filter type */
if|if
condition|(
name|bus
operator|->
name|filter_en
condition|)
block|{
if|if
condition|(
name|bus
operator|->
name|trigger_en
condition|)
block|{
if|if
condition|(
name|bus
operator|->
name|filter_pre_trigger
condition|)
name|filter_type
operator|=
name|bus
operator|->
name|filter_post_trigger
condition|?
name|DBG_BUS_FILTER_TYPE_ON
else|:
name|DBG_BUS_FILTER_TYPE_PRE
expr_stmt|;
else|else
name|filter_type
operator|=
name|bus
operator|->
name|filter_post_trigger
condition|?
name|DBG_BUS_FILTER_TYPE_POST
else|:
name|DBG_BUS_FILTER_TYPE_OFF
expr_stmt|;
block|}
else|else
block|{
name|filter_type
operator|=
name|DBG_BUS_FILTER_TYPE_ON
expr_stmt|;
block|}
block|}
else|else
block|{
name|filter_type
operator|=
name|DBG_BUS_FILTER_TYPE_OFF
expr_stmt|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_FILTER_ENABLE
argument_list|,
name|filter_type
argument_list|)
expr_stmt|;
comment|/* Restart timestamp */
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TIMESTAMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable debug block */
name|ecore_bus_enable_dbg_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Configure enabled blocks - must be done before the DBG block is 	 * enabled. 	 */
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|num_enabled_blocks
condition|)
block|{
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|GET_FIELD
argument_list|(
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
operator|||
name|block_id
operator|==
name|BLOCK_DBG
condition|)
continue|continue;
name|ecore_config_dbg_line
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
expr|enum
name|block_id
operator|)
name|block_id
argument_list|,
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
operator|.
name|line_num
argument_list|,
name|GET_FIELD
argument_list|(
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|)
argument_list|,
name|GET_FIELD
argument_list|(
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_RIGHT_SHIFT
argument_list|)
argument_list|,
name|GET_FIELD
argument_list|(
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_FORCE_VALID_MASK
argument_list|)
argument_list|,
name|GET_FIELD
argument_list|(
name|dev_data
operator|->
name|bus
operator|.
name|blocks
index|[
name|block_id
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_FORCE_FRAME_MASK
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Configure client mask */
name|ecore_config_dbg_block_client_mask
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* Configure enabled Storms - must be done after the DBG block is 	 * enabled. 	 */
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|num_enabled_storms
condition|)
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
if|if
condition|(
name|dev_data
operator|->
name|bus
operator|.
name|storms
index|[
name|storm_id
index|]
operator|.
name|enabled
condition|)
name|ecore_bus_enable_storm
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|(
expr|enum
name|dbg_storms
operator|)
name|storm_id
argument_list|,
name|filter_type
argument_list|)
expr_stmt|;
name|dev_data
operator|->
name|bus
operator|.
name|state
operator|=
name|DBG_BUS_STATE_RECORDING
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_stop
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|enum
name|dbg_status
name|status
init|=
name|DBG_STATUS_OK
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_stop\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|state
operator|!=
name|DBG_BUS_STATE_RECORDING
condition|)
return|return
name|DBG_STATUS_RECORDING_NOT_STARTED
return|;
name|status
operator|=
name|ecore_bus_disable_inputs
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_CPU_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OSAL_MSLEEP
argument_list|(
name|FLUSH_DELAY_MS
argument_list|)
expr_stmt|;
name|ecore_bus_enable_dbg_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Check if trigger worked */
if|if
condition|(
name|bus
operator|->
name|trigger_en
condition|)
block|{
name|u32
name|trigger_state
init|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DBG_REG_TRIGGER_STATUS_CUR_STATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|trigger_state
operator|!=
name|MAX_TRIGGER_STATES
condition|)
return|return
name|DBG_STATUS_DATA_DIDNT_TRIGGER
return|;
block|}
name|bus
operator|->
name|state
operator|=
name|DBG_BUS_STATE_STOPPED
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_get_dump_buf_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|buf_size
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
name|status
operator|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
operator|*
name|buf_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
comment|/* Add dump header */
operator|*
name|buf_size
operator|=
operator|(
name|u32
operator|)
name|ecore_bus_dump_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus
operator|->
name|target
condition|)
block|{
case|case
name|DBG_BUS_TARGET_ID_INT_BUF
case|:
operator|*
name|buf_size
operator|+=
name|INT_BUF_SIZE_IN_DWORDS
expr_stmt|;
break|break;
case|case
name|DBG_BUS_TARGET_ID_PCI
case|:
operator|*
name|buf_size
operator|+=
name|BYTES_TO_DWORDS
argument_list|(
name|bus
operator|->
name|pci_buf
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Dump last section */
operator|*
name|buf_size
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|OSAL_NULL
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_bus_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|buf_size_in_dwords
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|min_buf_size_in_dwords
decl_stmt|,
name|block_id
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|dbg_bus_data
modifier|*
name|bus
init|=
operator|&
name|dev_data
operator|->
name|bus
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
name|u8
name|storm_id
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ecore_dbg_bus_get_dump_buf_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|min_buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_bus_dump: dump_buf = 0x%p, buf_size_in_dwords = %d\n"
argument_list|,
name|dump_buf
argument_list|,
name|buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|state
operator|!=
name|DBG_BUS_STATE_RECORDING
operator|&&
name|bus
operator|->
name|state
operator|!=
name|DBG_BUS_STATE_STOPPED
condition|)
return|return
name|DBG_STATUS_RECORDING_NOT_STARTED
return|;
if|if
condition|(
name|bus
operator|->
name|state
operator|==
name|DBG_BUS_STATE_RECORDING
condition|)
block|{
name|enum
name|dbg_status
name|stop_state
init|=
name|ecore_dbg_bus_stop
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
if|if
condition|(
name|stop_state
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|stop_state
return|;
block|}
if|if
condition|(
name|buf_size_in_dwords
operator|<
name|min_buf_size_in_dwords
condition|)
return|return
name|DBG_STATUS_DUMP_BUF_TOO_SMALL
return|;
if|if
condition|(
name|bus
operator|->
name|target
operator|==
name|DBG_BUS_TARGET_ID_PCI
operator|&&
operator|!
name|bus
operator|->
name|pci_buf
operator|.
name|size
condition|)
return|return
name|DBG_STATUS_PCI_BUF_NOT_ALLOCATED
return|;
comment|/* Dump header */
name|offset
operator|+=
name|ecore_bus_dump_hdr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Dump recorded data */
if|if
condition|(
name|bus
operator|->
name|target
operator|!=
name|DBG_BUS_TARGET_ID_NIG
condition|)
block|{
name|u32
name|recorded_dwords
init|=
name|ecore_bus_dump_data
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
operator|+
name|offset
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|recorded_dwords
condition|)
return|return
name|DBG_STATUS_NO_DATA_RECORDED
return|;
if|if
condition|(
name|recorded_dwords
operator|%
name|CHUNK_SIZE_IN_DWORDS
condition|)
return|return
name|DBG_STATUS_DUMP_NOT_CHUNK_ALIGNED
return|;
name|offset
operator|+=
name|recorded_dwords
expr_stmt|;
block|}
comment|/* Dump last section */
name|offset
operator|+=
name|ecore_dump_last_section
argument_list|(
name|p_hwfn
argument_list|,
name|dump_buf
argument_list|,
name|offset
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If recorded to PCI buffer - free the buffer */
name|ecore_bus_free_pci_buf
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* Clear debug bus parameters */
name|bus
operator|->
name|state
operator|=
name|DBG_BUS_STATE_IDLE
expr_stmt|;
name|bus
operator|->
name|num_enabled_blocks
operator|=
literal|0
expr_stmt|;
name|bus
operator|->
name|num_enabled_storms
operator|=
literal|0
expr_stmt|;
name|bus
operator|->
name|filter_en
operator|=
name|bus
operator|->
name|trigger_en
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|block_id
operator|=
literal|0
init|;
name|block_id
operator|<
name|MAX_BLOCK_ID
condition|;
name|block_id
operator|++
control|)
name|SET_FIELD
argument_list|(
name|bus
operator|->
name|blocks
index|[
name|BLOCK_PCIE
index|]
operator|.
name|data
argument_list|,
name|DBG_BUS_BLOCK_DATA_ENABLE_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|storm_id
operator|=
literal|0
init|;
name|storm_id
operator|<
name|MAX_DBG_STORMS
condition|;
name|storm_id
operator|++
control|)
block|{
name|struct
name|dbg_bus_storm_data
modifier|*
name|storm_bus
init|=
operator|&
name|bus
operator|->
name|storms
index|[
name|storm_id
index|]
decl_stmt|;
name|storm_bus
operator|->
name|enabled
operator|=
name|false
expr_stmt|;
name|storm_bus
operator|->
name|eid_filter_en
operator|=
name|storm_bus
operator|->
name|cid_filter_en
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|num_dumped_dwords
operator|=
name|offset
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_grc_config
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|dbg_grc_params
name|grc_param
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DEBUG
argument_list|,
literal|"dbg_grc_config: paramId = %d, val = %d\n"
argument_list|,
name|grc_param
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Initializes the GRC parameters (if not initialized). Needed in order 	 * to set the default parameter values for the first time. 	 */
name|ecore_dbg_grc_init_params
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|grc_param
operator|>=
name|MAX_DBG_GRC_PARAMS
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|val
operator|<
name|s_grc_param_defs
index|[
name|grc_param
index|]
operator|.
name|min
operator|||
name|val
operator|>
name|s_grc_param_defs
index|[
name|grc_param
index|]
operator|.
name|max
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
if|if
condition|(
name|s_grc_param_defs
index|[
name|grc_param
index|]
operator|.
name|is_preset
condition|)
block|{
comment|/* Preset param */
comment|/* Disabling a preset is not allowed. Call 		 * dbg_grc_set_params_default instead. 		 */
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
comment|/* Update all params with the preset values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_DBG_GRC_PARAMS
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|preset_val
decl_stmt|;
if|if
condition|(
name|grc_param
operator|==
name|DBG_GRC_PARAM_EXCLUDE_ALL
condition|)
name|preset_val
operator|=
name|s_grc_param_defs
index|[
name|i
index|]
operator|.
name|exclude_all_preset_val
expr_stmt|;
elseif|else
if|if
condition|(
name|grc_param
operator|==
name|DBG_GRC_PARAM_CRASH
condition|)
name|preset_val
operator|=
name|s_grc_param_defs
index|[
name|i
index|]
operator|.
name|crash_preset_val
expr_stmt|;
else|else
return|return
name|DBG_STATUS_INVALID_ARGS
return|;
name|ecore_grc_set_param
argument_list|(
name|p_hwfn
argument_list|,
operator|(
expr|enum
name|dbg_grc_params
operator|)
name|i
argument_list|,
name|preset_val
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Regular param - set its value */
name|ecore_grc_set_param
argument_list|(
name|p_hwfn
argument_list|,
name|grc_param
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Assign default GRC param values */
end_comment

begin_function
name|void
name|ecore_dbg_grc_set_params_default
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|u32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_DBG_GRC_PARAMS
condition|;
name|i
operator|++
control|)
name|dev_data
operator|->
name|grc
operator|.
name|param_val
index|[
name|i
index|]
operator|=
name|s_grc_param_defs
index|[
name|i
index|]
operator|.
name|default_val
index|[
name|dev_data
operator|->
name|chip_id
index|]
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_grc_get_dump_buf_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|buf_size
parameter_list|)
block|{
name|enum
name|dbg_status
name|status
init|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
operator|*
name|buf_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_MODE_TREE
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_DUMP_REG
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_DUMP_MEM
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_ATTN_BLOCKS
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_ATTN_REGS
index|]
operator|.
name|ptr
condition|)
return|return
name|DBG_STATUS_DBG_ARRAY_NOT_SET
return|;
return|return
name|ecore_grc_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|,
name|buf_size
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_grc_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|buf_size_in_dwords
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|needed_buf_size_in_dwords
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ecore_dbg_grc_get_dump_buf_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|needed_buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
name|buf_size_in_dwords
operator|<
name|needed_buf_size_in_dwords
condition|)
return|return
name|DBG_STATUS_DUMP_BUF_TOO_SMALL
return|;
comment|/* Doesn't do anything, needed for compile time asserts */
name|ecore_static_asserts
argument_list|()
expr_stmt|;
comment|/* GRC Dump */
name|status
operator|=
name|ecore_grc_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|true
argument_list|,
name|num_dumped_dwords
argument_list|)
expr_stmt|;
comment|/* Reveret GRC params to their default */
name|ecore_dbg_grc_set_params_default
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_idle_chk_get_dump_buf_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|buf_size
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|idle_chk_data
modifier|*
name|idle_chk
init|=
operator|&
name|dev_data
operator|->
name|idle_chk
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
operator|*
name|buf_size
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_MODE_TREE
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_REGS
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_IMMS
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_IDLE_CHK_RULES
index|]
operator|.
name|ptr
condition|)
return|return
name|DBG_STATUS_DBG_ARRAY_NOT_SET
return|;
if|if
condition|(
operator|!
name|idle_chk
operator|->
name|buf_size_set
condition|)
block|{
name|idle_chk
operator|->
name|buf_size
operator|=
name|ecore_idle_chk_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|idle_chk
operator|->
name|buf_size_set
operator|=
name|true
expr_stmt|;
block|}
operator|*
name|buf_size
operator|=
name|idle_chk
operator|->
name|buf_size
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_idle_chk_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|buf_size_in_dwords
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|needed_buf_size_in_dwords
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ecore_dbg_idle_chk_get_dump_buf_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|needed_buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
name|buf_size_in_dwords
operator|<
name|needed_buf_size_in_dwords
condition|)
return|return
name|DBG_STATUS_DUMP_BUF_TOO_SMALL
return|;
comment|/* Update reset state */
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* Idle Check Dump */
operator|*
name|num_dumped_dwords
operator|=
name|ecore_idle_chk_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Reveret GRC params to their default */
name|ecore_dbg_grc_set_params_default
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_mcp_trace_get_dump_buf_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|buf_size
parameter_list|)
block|{
name|enum
name|dbg_status
name|status
init|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
operator|*
name|buf_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
return|return
name|ecore_mcp_trace_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|,
name|buf_size
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_mcp_trace_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|buf_size_in_dwords
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|needed_buf_size_in_dwords
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
name|status
operator|=
name|ecore_dbg_mcp_trace_get_dump_buf_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|needed_buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
operator|&&
name|status
operator|!=
name|DBG_STATUS_NVRAM_GET_IMAGE_FAILED
condition|)
return|return
name|status
return|;
if|if
condition|(
name|buf_size_in_dwords
operator|<
name|needed_buf_size_in_dwords
condition|)
return|return
name|DBG_STATUS_DUMP_BUF_TOO_SMALL
return|;
comment|/* Update reset state */
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
comment|/* Perform dump */
name|status
operator|=
name|ecore_mcp_trace_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|true
argument_list|,
name|num_dumped_dwords
argument_list|)
expr_stmt|;
comment|/* Reveret GRC params to their default */
name|ecore_dbg_grc_set_params_default
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_reg_fifo_get_dump_buf_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|buf_size
parameter_list|)
block|{
name|enum
name|dbg_status
name|status
init|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
operator|*
name|buf_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
return|return
name|ecore_reg_fifo_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|,
name|buf_size
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_reg_fifo_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|buf_size_in_dwords
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|needed_buf_size_in_dwords
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ecore_dbg_reg_fifo_get_dump_buf_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|needed_buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
name|buf_size_in_dwords
operator|<
name|needed_buf_size_in_dwords
condition|)
return|return
name|DBG_STATUS_DUMP_BUF_TOO_SMALL
return|;
comment|/* Update reset state */
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|status
operator|=
name|ecore_reg_fifo_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|true
argument_list|,
name|num_dumped_dwords
argument_list|)
expr_stmt|;
comment|/* Reveret GRC params to their default */
name|ecore_dbg_grc_set_params_default
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_igu_fifo_get_dump_buf_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|buf_size
parameter_list|)
block|{
name|enum
name|dbg_status
name|status
init|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
operator|*
name|buf_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
return|return
name|ecore_igu_fifo_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|,
name|buf_size
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_igu_fifo_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|buf_size_in_dwords
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|needed_buf_size_in_dwords
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ecore_dbg_igu_fifo_get_dump_buf_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|needed_buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
name|buf_size_in_dwords
operator|<
name|needed_buf_size_in_dwords
condition|)
return|return
name|DBG_STATUS_DUMP_BUF_TOO_SMALL
return|;
comment|/* Update reset state */
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|status
operator|=
name|ecore_igu_fifo_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|true
argument_list|,
name|num_dumped_dwords
argument_list|)
expr_stmt|;
comment|/* Reveret GRC params to their default */
name|ecore_dbg_grc_set_params_default
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_protection_override_get_dump_buf_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|buf_size
parameter_list|)
block|{
name|enum
name|dbg_status
name|status
init|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
operator|*
name|buf_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
return|return
name|ecore_protection_override_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|,
name|buf_size
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_protection_override_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|buf_size_in_dwords
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|needed_buf_size_in_dwords
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ecore_dbg_protection_override_get_dump_buf_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|needed_buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
name|buf_size_in_dwords
operator|<
name|needed_buf_size_in_dwords
condition|)
return|return
name|DBG_STATUS_DUMP_BUF_TOO_SMALL
return|;
comment|/* Update reset state */
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|status
operator|=
name|ecore_protection_override_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|true
argument_list|,
name|num_dumped_dwords
argument_list|)
expr_stmt|;
comment|/* Reveret GRC params to their default */
name|ecore_dbg_grc_set_params_default
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_fw_asserts_get_dump_buf_size
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|buf_size
parameter_list|)
block|{
name|enum
name|dbg_status
name|status
init|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
operator|*
name|buf_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
comment|/* Update reset state */
name|ecore_update_blocks_reset_state
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
operator|*
name|buf_size
operator|=
name|ecore_fw_asserts_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|OSAL_NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_fw_asserts_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
modifier|*
name|dump_buf
parameter_list|,
name|u32
name|buf_size_in_dwords
parameter_list|,
name|u32
modifier|*
name|num_dumped_dwords
parameter_list|)
block|{
name|u32
name|needed_buf_size_in_dwords
decl_stmt|;
name|enum
name|dbg_status
name|status
decl_stmt|;
operator|*
name|num_dumped_dwords
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ecore_dbg_fw_asserts_get_dump_buf_size
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
operator|&
name|needed_buf_size_in_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
name|buf_size_in_dwords
operator|<
name|needed_buf_size_in_dwords
condition|)
return|return
name|DBG_STATUS_DUMP_BUF_TOO_SMALL
return|;
operator|*
name|num_dumped_dwords
operator|=
name|ecore_fw_asserts_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dump_buf
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Reveret GRC params to their default */
name|ecore_dbg_grc_set_params_default
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_read_attn
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|,
name|enum
name|dbg_attn_type
name|attn_type
parameter_list|,
name|bool
name|clear_status
parameter_list|,
name|struct
name|dbg_attn_block_result
modifier|*
name|results
parameter_list|)
block|{
name|enum
name|dbg_status
name|status
init|=
name|ecore_dbg_dev_init
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
name|u8
name|reg_idx
decl_stmt|,
name|num_attn_regs
decl_stmt|,
name|num_result_regs
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|dbg_attn_reg
modifier|*
name|attn_reg_arr
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|DBG_STATUS_OK
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_MODE_TREE
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_ATTN_BLOCKS
index|]
operator|.
name|ptr
operator|||
operator|!
name|s_dbg_arrays
index|[
name|BIN_BUF_DBG_ATTN_REGS
index|]
operator|.
name|ptr
condition|)
return|return
name|DBG_STATUS_DBG_ARRAY_NOT_SET
return|;
name|attn_reg_arr
operator|=
name|ecore_get_block_attn_regs
argument_list|(
name|block_id
argument_list|,
name|attn_type
argument_list|,
operator|&
name|num_attn_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_idx
operator|=
literal|0
init|;
name|reg_idx
operator|<
name|num_attn_regs
condition|;
name|reg_idx
operator|++
control|)
block|{
specifier|const
name|struct
name|dbg_attn_reg
modifier|*
name|reg_data
init|=
operator|&
name|attn_reg_arr
index|[
name|reg_idx
index|]
decl_stmt|;
name|struct
name|dbg_attn_reg_result
modifier|*
name|reg_result
decl_stmt|;
name|u32
name|sts_addr
decl_stmt|,
name|sts_val
decl_stmt|;
name|u16
name|modes_buf_offset
decl_stmt|;
name|bool
name|eval_mode
decl_stmt|;
comment|/* Check mode */
name|eval_mode
operator|=
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_EVAL_MODE
argument_list|)
operator|>
literal|0
expr_stmt|;
name|modes_buf_offset
operator|=
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|mode
operator|.
name|data
argument_list|,
name|DBG_MODE_HDR_MODES_BUF_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval_mode
operator|&&
operator|!
name|ecore_is_mode_match
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|modes_buf_offset
argument_list|)
condition|)
continue|continue;
comment|/* Mode match - read attention status register */
name|sts_addr
operator|=
name|DWORDS_TO_BYTES
argument_list|(
name|clear_status
condition|?
name|reg_data
operator|->
name|sts_clr_address
else|:
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|data
argument_list|,
name|DBG_ATTN_REG_STS_ADDRESS
argument_list|)
argument_list|)
expr_stmt|;
name|sts_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|sts_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sts_val
condition|)
continue|continue;
comment|/* Non-zero attention status - add to results */
name|reg_result
operator|=
operator|&
name|results
operator|->
name|reg_results
index|[
name|num_result_regs
index|]
expr_stmt|;
name|SET_FIELD
argument_list|(
name|reg_result
operator|->
name|data
argument_list|,
name|DBG_ATTN_REG_RESULT_STS_ADDRESS
argument_list|,
name|sts_addr
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|reg_result
operator|->
name|data
argument_list|,
name|DBG_ATTN_REG_RESULT_NUM_REG_ATTN
argument_list|,
name|GET_FIELD
argument_list|(
name|reg_data
operator|->
name|data
argument_list|,
name|DBG_ATTN_REG_NUM_REG_ATTN
argument_list|)
argument_list|)
expr_stmt|;
name|reg_result
operator|->
name|block_attn_offset
operator|=
name|reg_data
operator|->
name|block_attn_offset
expr_stmt|;
name|reg_result
operator|->
name|sts_val
operator|=
name|sts_val
expr_stmt|;
name|reg_result
operator|->
name|mask_val
operator|=
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DWORDS_TO_BYTES
argument_list|(
name|reg_data
operator|->
name|mask_address
argument_list|)
argument_list|)
expr_stmt|;
name|num_result_regs
operator|++
expr_stmt|;
block|}
name|results
operator|->
name|block_id
operator|=
operator|(
name|u8
operator|)
name|block_id
expr_stmt|;
name|results
operator|->
name|names_offset
operator|=
name|ecore_get_block_attn_data
argument_list|(
name|block_id
argument_list|,
name|attn_type
argument_list|)
operator|->
name|names_offset
expr_stmt|;
name|SET_FIELD
argument_list|(
name|results
operator|->
name|data
argument_list|,
name|DBG_ATTN_BLOCK_RESULT_ATTN_TYPE
argument_list|,
name|attn_type
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|results
operator|->
name|data
argument_list|,
name|DBG_ATTN_BLOCK_RESULT_NUM_REGS
argument_list|,
name|num_result_regs
argument_list|)
expr_stmt|;
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|dbg_status
name|ecore_dbg_print_attn
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|dbg_attn_block_result
modifier|*
name|results
parameter_list|)
block|{
name|enum
name|dbg_attn_type
name|attn_type
decl_stmt|;
name|u8
name|num_regs
decl_stmt|,
name|i
decl_stmt|;
name|num_regs
operator|=
name|GET_FIELD
argument_list|(
name|results
operator|->
name|data
argument_list|,
name|DBG_ATTN_BLOCK_RESULT_NUM_REGS
argument_list|)
expr_stmt|;
name|attn_type
operator|=
operator|(
expr|enum
name|dbg_attn_type
operator|)
name|GET_FIELD
argument_list|(
name|results
operator|->
name|data
argument_list|,
name|DBG_ATTN_BLOCK_RESULT_ATTN_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dbg_attn_reg_result
modifier|*
name|reg_result
decl_stmt|;
specifier|const
name|char
modifier|*
name|attn_type_str
decl_stmt|;
name|u32
name|sts_addr
decl_stmt|;
name|reg_result
operator|=
operator|&
name|results
operator|->
name|reg_results
index|[
name|i
index|]
expr_stmt|;
name|attn_type_str
operator|=
operator|(
name|attn_type
operator|==
name|ATTN_TYPE_INTERRUPT
condition|?
literal|"interrupt"
else|:
literal|"parity"
operator|)
expr_stmt|;
name|sts_addr
operator|=
name|GET_FIELD
argument_list|(
name|reg_result
operator|->
name|data
argument_list|,
name|DBG_ATTN_REG_RESULT_STS_ADDRESS
argument_list|)
expr_stmt|;
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"%s: address 0x%08x, status 0x%08x, mask 0x%08x\n"
argument_list|,
name|attn_type_str
argument_list|,
name|sts_addr
argument_list|,
name|reg_result
operator|->
name|sts_val
argument_list|,
name|reg_result
operator|->
name|mask_val
argument_list|)
expr_stmt|;
block|}
return|return
name|DBG_STATUS_OK
return|;
block|}
end_function

begin_function
name|bool
name|ecore_is_block_in_reset
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|enum
name|block_id
name|block_id
parameter_list|)
block|{
name|struct
name|dbg_tools_data
modifier|*
name|dev_data
init|=
operator|&
name|p_hwfn
operator|->
name|dbg_info
decl_stmt|;
name|struct
name|block_defs
modifier|*
name|block
init|=
name|s_block_defs
index|[
name|block_id
index|]
decl_stmt|;
name|u32
name|reset_reg
decl_stmt|;
if|if
condition|(
operator|!
name|block
operator|->
name|has_reset_bit
condition|)
return|return
name|false
return|;
name|reset_reg
operator|=
name|block
operator|->
name|reset_reg
expr_stmt|;
return|return
name|s_reset_regs_defs
index|[
name|reset_reg
index|]
operator|.
name|exists
index|[
name|dev_data
operator|->
name|chip_id
index|]
condition|?
operator|!
operator|(
name|ecore_rd
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|s_reset_regs_defs
index|[
name|reset_reg
index|]
operator|.
name|addr
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|block
operator|->
name|reset_bit_offset
operator|)
operator|)
else|:
name|true
return|;
block|}
end_function

end_unit

