begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * File : ecore_hw.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bcm_osal.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_common.h"
end_include

begin_include
include|#
directive|include
file|"ecore_status.h"
end_include

begin_include
include|#
directive|include
file|"ecore.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hw.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_utils.h"
end_include

begin_include
include|#
directive|include
file|"ecore_iov_api.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ASIC_ONLY
end_ifndef

begin_define
define|#
directive|define
name|ECORE_EMUL_FACTOR
value|2000
end_define

begin_define
define|#
directive|define
name|ECORE_FPGA_FACTOR
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ECORE_BAR_ACQUIRE_TIMEOUT
value|1000
end_define

begin_comment
comment|/* Invalid values */
end_comment

begin_define
define|#
directive|define
name|ECORE_BAR_INVALID_OFFSET
value|(OSAL_CPU_TO_LE32(-1))
end_define

begin_struct
struct|struct
name|ecore_ptt
block|{
name|osal_list_entry_t
name|list_entry
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|struct
name|pxp_ptt_entry
name|pxp
decl_stmt|;
name|u8
name|hwfn_id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_ptt_pool
block|{
name|osal_list_t
name|free_list
decl_stmt|;
name|osal_spinlock_t
name|lock
decl_stmt|;
comment|/* ptt synchronized access */
name|struct
name|ecore_ptt
name|ptts
index|[
name|PXP_EXTERNAL_BAR_PF_WINDOW_NUM
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|enum
name|_ecore_status_t
name|ecore_ptt_pool_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ptt_pool
modifier|*
name|p_pool
init|=
name|OSAL_ALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_pool
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_pool
condition|)
return|return
name|ECORE_NOMEM
return|;
name|OSAL_LIST_INIT
argument_list|(
operator|&
name|p_pool
operator|->
name|free_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PXP_EXTERNAL_BAR_PF_WINDOW_NUM
condition|;
name|i
operator|++
control|)
block|{
name|p_pool
operator|->
name|ptts
index|[
name|i
index|]
operator|.
name|idx
operator|=
name|i
expr_stmt|;
name|p_pool
operator|->
name|ptts
index|[
name|i
index|]
operator|.
name|pxp
operator|.
name|offset
operator|=
name|ECORE_BAR_INVALID_OFFSET
expr_stmt|;
name|p_pool
operator|->
name|ptts
index|[
name|i
index|]
operator|.
name|pxp
operator|.
name|pretend
operator|.
name|control
operator|=
literal|0
expr_stmt|;
name|p_pool
operator|->
name|ptts
index|[
name|i
index|]
operator|.
name|hwfn_id
operator|=
name|p_hwfn
operator|->
name|my_id
expr_stmt|;
comment|/* There are special PTT entries that are taken only by design. 		 * The rest are added ot the list for general usage. 		 */
if|if
condition|(
name|i
operator|>=
name|RESERVED_PTT_MAX
condition|)
name|OSAL_LIST_PUSH_HEAD
argument_list|(
operator|&
name|p_pool
operator|->
name|ptts
index|[
name|i
index|]
operator|.
name|list_entry
argument_list|,
operator|&
name|p_pool
operator|->
name|free_list
argument_list|)
expr_stmt|;
block|}
name|p_hwfn
operator|->
name|p_ptt_pool
operator|=
name|p_pool
expr_stmt|;
name|OSAL_SPIN_LOCK_ALLOC
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_SPIN_LOCK_INIT
argument_list|(
operator|&
name|p_pool
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|ecore_ptt_invalidate
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PXP_EXTERNAL_BAR_PF_WINDOW_NUM
condition|;
name|i
operator|++
control|)
block|{
name|p_ptt
operator|=
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|ptts
index|[
name|i
index|]
expr_stmt|;
name|p_ptt
operator|->
name|pxp
operator|.
name|offset
operator|=
name|ECORE_BAR_INVALID_OFFSET
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_ptt_pool_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
name|p_hwfn
operator|->
name|p_ptt_pool
condition|)
name|OSAL_SPIN_LOCK_DEALLOC
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|p_ptt_pool
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_ptt_pool
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ecore_ptt
modifier|*
name|ecore_ptt_acquire
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Take the free PTT from the list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ECORE_BAR_ACQUIRE_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OSAL_LIST_IS_EMPTY
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|free_list
argument_list|)
condition|)
block|{
name|p_ptt
operator|=
name|OSAL_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|free_list
argument_list|,
expr|struct
name|ecore_ptt
argument_list|,
name|list_entry
argument_list|)
expr_stmt|;
name|OSAL_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|p_ptt
operator|->
name|list_entry
argument_list|,
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"allocated ptt %d\n"
argument_list|,
name|p_ptt
operator|->
name|idx
argument_list|)
expr_stmt|;
return|return
name|p_ptt
return|;
block|}
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_MSLEEP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"PTT acquire timeout - failed to allocate PTT\n"
argument_list|)
expr_stmt|;
return|return
name|OSAL_NULL
return|;
block|}
end_function

begin_function
name|void
name|ecore_ptt_release
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
comment|/* This PTT should not be set to pretend if it is being released */
comment|/* TODO - add some pretend sanity checks, to make sure pretend isn't set on this ptt */
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_LIST_PUSH_HEAD
argument_list|(
operator|&
name|p_ptt
operator|->
name|list_entry
argument_list|,
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u32
name|ecore_ptt_get_hw_addr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
comment|/* The HW is using DWORDS and we need to translate it to Bytes */
return|return
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_ptt
operator|->
name|pxp
operator|.
name|offset
argument_list|)
operator|<<
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|ecore_ptt_config_addr
parameter_list|(
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
return|return
name|PXP_PF_WINDOW_ADMIN_PER_PF_START
operator|+
name|p_ptt
operator|->
name|idx
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pxp_ptt_entry
argument_list|)
return|;
block|}
end_function

begin_function
name|u32
name|ecore_ptt_get_bar_addr
parameter_list|(
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
return|return
name|PXP_EXTERNAL_BAR_PF_WINDOW_START
operator|+
name|p_ptt
operator|->
name|idx
operator|*
name|PXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE
return|;
block|}
end_function

begin_function
name|void
name|ecore_ptt_set_win
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|new_hw_addr
parameter_list|)
block|{
name|u32
name|prev_hw_addr
decl_stmt|;
name|prev_hw_addr
operator|=
name|ecore_ptt_get_hw_addr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_hw_addr
operator|==
name|prev_hw_addr
condition|)
return|return;
comment|/* Update PTT entery in admin window */
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"Updating PTT entry %d to offset 0x%x\n"
argument_list|,
name|p_ptt
operator|->
name|idx
argument_list|,
name|new_hw_addr
argument_list|)
expr_stmt|;
comment|/* The HW is using DWORDS and the address is in Bytes */
name|p_ptt
operator|->
name|pxp
operator|.
name|offset
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|new_hw_addr
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|ecore_ptt_config_addr
argument_list|(
name|p_ptt
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|pxp_ptt_entry
argument_list|,
name|offset
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_ptt
operator|->
name|pxp
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|ecore_set_ptt
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|hw_addr
parameter_list|)
block|{
name|u32
name|win_hw_addr
init|=
name|ecore_ptt_get_hw_addr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
decl_stmt|;
name|u32
name|offset
decl_stmt|;
name|offset
operator|=
name|hw_addr
operator|-
name|win_hw_addr
expr_stmt|;
if|if
condition|(
name|p_ptt
operator|->
name|hwfn_id
operator|!=
name|p_hwfn
operator|->
name|my_id
condition|)
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"ptt[%d] of hwfn[%02x] is used by hwfn[%02x]!\n"
argument_list|,
name|p_ptt
operator|->
name|idx
argument_list|,
name|p_ptt
operator|->
name|hwfn_id
argument_list|,
name|p_hwfn
operator|->
name|my_id
argument_list|)
expr_stmt|;
comment|/* Verify the address is within the window */
if|if
condition|(
name|hw_addr
operator|<
name|win_hw_addr
operator|||
name|offset
operator|>=
name|PXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE
condition|)
block|{
name|ecore_ptt_set_win
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|hw_addr
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ecore_ptt_get_bar_addr
argument_list|(
name|p_ptt
argument_list|)
operator|+
name|offset
return|;
block|}
end_function

begin_function
name|struct
name|ecore_ptt
modifier|*
name|ecore_get_reserved_ptt
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|reserved_ptts
name|ptt_idx
parameter_list|)
block|{
if|if
condition|(
name|ptt_idx
operator|>=
name|RESERVED_PTT_MAX
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Requested PTT %d is out of range\n"
argument_list|,
name|ptt_idx
argument_list|)
expr_stmt|;
return|return
name|OSAL_NULL
return|;
block|}
return|return
operator|&
name|p_hwfn
operator|->
name|p_ptt_pool
operator|->
name|ptts
index|[
name|ptt_idx
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_is_reg_fifo_empty
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|bool
name|is_empty
init|=
name|true
decl_stmt|;
name|u32
name|bar_addr
decl_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_dev
operator|->
name|chk_reg_fifo
condition|)
goto|goto
name|out
goto|;
comment|/* ecore_rd() cannot be used here since it calls this function */
name|bar_addr
operator|=
name|ecore_set_ptt
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|GRC_REG_TRACE_FIFO_VALID_DATA
argument_list|)
expr_stmt|;
name|is_empty
operator|=
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|bar_addr
argument_list|)
operator|==
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|OSAL_UDELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
return|return
name|is_empty
return|;
block|}
end_function

begin_function
name|void
name|ecore_wr
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|hw_addr
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|bool
name|prev_fifo_err
decl_stmt|;
name|u32
name|bar_addr
decl_stmt|;
name|prev_fifo_err
operator|=
operator|!
name|ecore_is_reg_fifo_empty
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|bar_addr
operator|=
name|ecore_set_ptt
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|hw_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|bar_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"bar_addr 0x%x, hw_addr 0x%x, val 0x%x\n"
argument_list|,
name|bar_addr
argument_list|,
name|hw_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|OSAL_UDELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OSAL_WARN
argument_list|(
operator|!
name|prev_fifo_err
operator|&&
operator|!
name|ecore_is_reg_fifo_empty
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
argument_list|,
literal|"reg_fifo error was caused by a call to ecore_wr(0x%x, 0x%x)\n"
argument_list|,
name|hw_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u32
name|ecore_rd
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|hw_addr
parameter_list|)
block|{
name|bool
name|prev_fifo_err
decl_stmt|;
name|u32
name|bar_addr
decl_stmt|,
name|val
decl_stmt|;
name|prev_fifo_err
operator|=
operator|!
name|ecore_is_reg_fifo_empty
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|bar_addr
operator|=
name|ecore_set_ptt
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|hw_addr
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"bar_addr 0x%x, hw_addr 0x%x, val 0x%x\n"
argument_list|,
name|bar_addr
argument_list|,
name|hw_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
name|OSAL_UDELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OSAL_WARN
argument_list|(
operator|!
name|prev_fifo_err
operator|&&
operator|!
name|ecore_is_reg_fifo_empty
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
argument_list|,
literal|"reg_fifo error was caused by a call to ecore_rd(0x%x)\n"
argument_list|,
name|hw_addr
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_memcpy_hw
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|u32
name|hw_addr
parameter_list|,
name|osal_size_t
name|n
parameter_list|,
name|bool
name|to_device
parameter_list|)
block|{
name|u32
name|dw_count
decl_stmt|,
modifier|*
name|host_addr
decl_stmt|,
name|hw_offset
decl_stmt|;
name|osal_size_t
name|quota
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
name|u32
name|OSAL_IOMEM
modifier|*
name|reg_addr
decl_stmt|;
while|while
condition|(
name|done
operator|<
name|n
condition|)
block|{
name|quota
operator|=
name|OSAL_MIN_T
argument_list|(
name|osal_size_t
argument_list|,
name|n
operator|-
name|done
argument_list|,
name|PXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|ecore_ptt_set_win
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|hw_addr
operator|+
name|done
argument_list|)
expr_stmt|;
name|hw_offset
operator|=
name|ecore_ptt_get_bar_addr
argument_list|(
name|p_ptt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw_offset
operator|=
name|hw_addr
operator|+
name|done
expr_stmt|;
block|}
name|dw_count
operator|=
name|quota
operator|/
literal|4
expr_stmt|;
name|host_addr
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|addr
operator|+
name|done
operator|)
expr_stmt|;
name|reg_addr
operator|=
operator|(
name|u32
name|OSAL_IOMEM
operator|*
operator|)
name|OSAL_REG_ADDR
argument_list|(
name|p_hwfn
argument_list|,
name|hw_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_device
condition|)
while|while
condition|(
name|dw_count
operator|--
condition|)
name|DIRECT_REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|reg_addr
operator|++
argument_list|,
operator|*
name|host_addr
operator|++
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|dw_count
operator|--
condition|)
operator|*
name|host_addr
operator|++
operator|=
name|DIRECT_REG_RD
argument_list|(
name|p_hwfn
argument_list|,
name|reg_addr
operator|++
argument_list|)
expr_stmt|;
name|done
operator|+=
name|quota
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_memcpy_from
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|void
modifier|*
name|dest
parameter_list|,
name|u32
name|hw_addr
parameter_list|,
name|osal_size_t
name|n
parameter_list|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"hw_addr 0x%x, dest %p hw_addr 0x%x, size %lu\n"
argument_list|,
name|hw_addr
argument_list|,
name|dest
argument_list|,
name|hw_addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|n
argument_list|)
expr_stmt|;
name|ecore_memcpy_hw
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|dest
argument_list|,
name|hw_addr
argument_list|,
name|n
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_memcpy_to
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|hw_addr
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|osal_size_t
name|n
parameter_list|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"hw_addr 0x%x, hw_addr 0x%x, src %p size %lu\n"
argument_list|,
name|hw_addr
argument_list|,
name|hw_addr
argument_list|,
name|src
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|n
argument_list|)
expr_stmt|;
name|ecore_memcpy_hw
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|src
argument_list|,
name|hw_addr
argument_list|,
name|n
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_fid_pretend
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u16
name|fid
parameter_list|)
block|{
name|u16
name|control
init|=
literal|0
decl_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_IS_CONCRETE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_PRETEND_FUNCTION
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Every pretend undos previous pretends, including 	 * previous port pretend. 	 */
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_PORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_USE_PORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_PRETEND_PORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GET_FIELD
argument_list|(
name|fid
argument_list|,
name|PXP_CONCRETE_FID_VFVALID
argument_list|)
condition|)
name|fid
operator|=
name|GET_FIELD
argument_list|(
name|fid
argument_list|,
name|PXP_CONCRETE_FID_PFID
argument_list|)
expr_stmt|;
name|p_ptt
operator|->
name|pxp
operator|.
name|pretend
operator|.
name|control
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|p_ptt
operator|->
name|pxp
operator|.
name|pretend
operator|.
name|fid
operator|.
name|concrete_fid
operator|.
name|fid
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
name|fid
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|ecore_ptt_config_addr
argument_list|(
name|p_ptt
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|pxp_ptt_entry
argument_list|,
name|pretend
argument_list|)
argument_list|,
operator|*
operator|(
name|u32
operator|*
operator|)
operator|&
name|p_ptt
operator|->
name|pxp
operator|.
name|pretend
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_port_pretend
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u8
name|port_id
parameter_list|)
block|{
name|u16
name|control
init|=
literal|0
decl_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_PORT
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_USE_PORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_PRETEND_PORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p_ptt
operator|->
name|pxp
operator|.
name|pretend
operator|.
name|control
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|ecore_ptt_config_addr
argument_list|(
name|p_ptt
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|pxp_ptt_entry
argument_list|,
name|pretend
argument_list|)
argument_list|,
operator|*
operator|(
name|u32
operator|*
operator|)
operator|&
name|p_ptt
operator|->
name|pxp
operator|.
name|pretend
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_port_unpretend
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|u16
name|control
init|=
literal|0
decl_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_PORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_USE_PORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|control
argument_list|,
name|PXP_PRETEND_CMD_PRETEND_PORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p_ptt
operator|->
name|pxp
operator|.
name|pretend
operator|.
name|control
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|p_hwfn
argument_list|,
name|ecore_ptt_config_addr
argument_list|(
name|p_ptt
argument_list|)
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|pxp_ptt_entry
argument_list|,
name|pretend
argument_list|)
argument_list|,
operator|*
operator|(
name|u32
operator|*
operator|)
operator|&
name|p_ptt
operator|->
name|pxp
operator|.
name|pretend
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u32
name|ecore_vfid_to_concrete
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u8
name|vfid
parameter_list|)
block|{
name|u32
name|concrete_fid
init|=
literal|0
decl_stmt|;
name|SET_FIELD
argument_list|(
name|concrete_fid
argument_list|,
name|PXP_CONCRETE_FID_PFID
argument_list|,
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|concrete_fid
argument_list|,
name|PXP_CONCRETE_FID_VFID
argument_list|,
name|vfid
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|concrete_fid
argument_list|,
name|PXP_CONCRETE_FID_VFVALID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|concrete_fid
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Ecore HW lock  * =============  * Although the implementation is ready, today we don't have any flow that  * utliizes said locks - and we want to keep it this way.  * If this changes, this needs to be revisted.  */
end_comment

begin_define
define|#
directive|define
name|HW_LOCK_MAX_RETRIES
value|1000
end_define

begin_comment
unit|enum _ecore_status_t ecore_hw_lock(struct ecore_hwfn		*p_hwfn, 				   struct ecore_ptt		*p_ptt, 				   u8                           resource, 				   bool				block) { 	u32 cnt, lock_status, hw_lock_cntr_reg; 	enum _ecore_status_t ecore_status;
comment|/* Locate the proper lock register for this function. 	 * Note This code assumes all the H/W lock registers are sequential 	 * in memory. 	 */
end_comment

begin_comment
unit|hw_lock_cntr_reg = MISCS_REG_DRIVER_CONTROL_0 + 			   p_hwfn->rel_pf_id * 			   MISCS_REG_DRIVER_CONTROL_0_SIZE * sizeof(u32);
comment|/* Validate that the resource is not already taken */
end_comment

begin_comment
unit|lock_status = ecore_rd(p_hwfn, p_ptt, hw_lock_cntr_reg);  	if (lock_status& resource) { 		DP_NOTICE(p_hwfn, true, 			  "Resource already locked: lock_status=0x%x resource=0x%x\n", 			  lock_status, resource);  		return ECORE_BUSY; 	}
comment|/* Register for the lock */
end_comment

begin_comment
unit|ecore_wr(p_hwfn, p_ptt, hw_lock_cntr_reg + sizeof(u32), resource);
comment|/* Try for 5 seconds every 5ms */
end_comment

begin_comment
unit|for (cnt = 0; cnt< HW_LOCK_MAX_RETRIES; cnt++) { 		lock_status = ecore_rd(p_hwfn, p_ptt, hw_lock_cntr_reg);  		if (lock_status& resource) 			return ECORE_SUCCESS;  		if (!block) { 			ecore_status = ECORE_BUSY; 			break; 		}  		OSAL_MSLEEP(5); 	}  	if (cnt == HW_LOCK_MAX_RETRIES) { 		DP_NOTICE(p_hwfn, true, "Lock timeout resource=0x%x\n", 			  resource); 		ecore_status = ECORE_TIMEOUT; 	}
comment|/* Clear the pending request */
end_comment

begin_comment
unit|ecore_wr(p_hwfn, p_ptt, hw_lock_cntr_reg, resource);  	return ecore_status; }  enum _ecore_status_t ecore_hw_unlock(struct ecore_hwfn		*p_hwfn, 				     struct ecore_ptt		*p_ptt, 				     u8                         resource) { 	u32 lock_status, hw_lock_cntr_reg;
comment|/* Locate the proper lock register for this function. 	 * Note This code assumes all the H/W lock registers are sequential 	 * in memory. 	 */
end_comment

begin_comment
unit|hw_lock_cntr_reg = MISCS_REG_DRIVER_CONTROL_0 + 			   p_hwfn->rel_pf_id * 			   MISCS_REG_DRIVER_CONTROL_0_SIZE * sizeof(u32);
comment|/*  Validate that the resource is currently taken */
end_comment

begin_comment
unit|lock_status = ecore_rd(p_hwfn, p_ptt, hw_lock_cntr_reg);  	if (!(lock_status& resource)) { 		DP_NOTICE(p_hwfn, true, 			  "resource 0x%x was not taken (lock status 0x%x)\n", 			  resource, lock_status);  		return ECORE_NODEV; 	}
comment|/* clear lock for resource */
end_comment

begin_endif
unit|ecore_wr(p_hwfn, p_ptt, hw_lock_cntr_reg, resource); 	return ECORE_SUCCESS; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* HW locks logic */
end_comment

begin_comment
comment|/* DMAE */
end_comment

begin_function
specifier|static
name|void
name|ecore_dmae_opcode
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
specifier|const
name|u8
name|is_src_type_grc
parameter_list|,
specifier|const
name|u8
name|is_dst_type_grc
parameter_list|,
name|struct
name|ecore_dmae_params
modifier|*
name|p_params
parameter_list|)
block|{
name|u16
name|opcode_b
init|=
literal|0
decl_stmt|;
name|u32
name|opcode
init|=
literal|0
decl_stmt|;
comment|/* Whether the source is the PCIe or the GRC. 	 * 0- The source is the PCIe 	 * 1- The source is the GRC. 	 */
name|opcode
operator||=
operator|(
name|is_src_type_grc
condition|?
name|DMAE_CMD_SRC_MASK_GRC
else|:
name|DMAE_CMD_SRC_MASK_PCIE
operator|)
operator|<<
name|DMAE_CMD_SRC_SHIFT
expr_stmt|;
name|opcode
operator||=
operator|(
name|p_hwfn
operator|->
name|rel_pf_id
operator|&
name|DMAE_CMD_SRC_PF_ID_MASK
operator|)
operator|<<
name|DMAE_CMD_SRC_PF_ID_SHIFT
expr_stmt|;
comment|/* The destination of the DMA can be: 0-None 1-PCIe 2-GRC 3-None */
name|opcode
operator||=
operator|(
name|is_dst_type_grc
condition|?
name|DMAE_CMD_DST_MASK_GRC
else|:
name|DMAE_CMD_DST_MASK_PCIE
operator|)
operator|<<
name|DMAE_CMD_DST_SHIFT
expr_stmt|;
name|opcode
operator||=
operator|(
name|p_hwfn
operator|->
name|rel_pf_id
operator|&
name|DMAE_CMD_DST_PF_ID_MASK
operator|)
operator|<<
name|DMAE_CMD_DST_PF_ID_SHIFT
expr_stmt|;
comment|/* DMAE_E4_TODO need to check which value to specifiy here. */
comment|/* opcode |= (!b_complete_to_host)<< DMAE_CMD_C_DST_SHIFT;*/
comment|/* Whether to write a completion word to the completion destination: 	 * 0-Do not write a completion word 	 * 1-Write the completion word 	 */
name|opcode
operator||=
name|DMAE_CMD_COMP_WORD_EN_MASK
operator|<<
name|DMAE_CMD_COMP_WORD_EN_SHIFT
expr_stmt|;
name|opcode
operator||=
name|DMAE_CMD_SRC_ADDR_RESET_MASK
operator|<<
name|DMAE_CMD_SRC_ADDR_RESET_SHIFT
expr_stmt|;
if|if
condition|(
name|p_params
operator|->
name|flags
operator|&
name|ECORE_DMAE_FLAG_COMPLETION_DST
condition|)
name|opcode
operator||=
literal|1
operator|<<
name|DMAE_CMD_COMP_FUNC_SHIFT
expr_stmt|;
comment|/* swapping mode 3 - big endian there should be a define ifdefed in 	 * the HSI somewhere. Since it is currently 	 */
name|opcode
operator||=
name|DMAE_CMD_ENDIANITY
operator|<<
name|DMAE_CMD_ENDIANITY_MODE_SHIFT
expr_stmt|;
name|opcode
operator||=
name|p_hwfn
operator|->
name|port_id
operator|<<
name|DMAE_CMD_PORT_ID_SHIFT
expr_stmt|;
comment|/* reset source address in next go */
name|opcode
operator||=
name|DMAE_CMD_SRC_ADDR_RESET_MASK
operator|<<
name|DMAE_CMD_SRC_ADDR_RESET_SHIFT
expr_stmt|;
comment|/* reset dest address in next go */
name|opcode
operator||=
name|DMAE_CMD_DST_ADDR_RESET_MASK
operator|<<
name|DMAE_CMD_DST_ADDR_RESET_SHIFT
expr_stmt|;
comment|/* SRC/DST VFID: all 1's - pf, otherwise VF id */
if|if
condition|(
name|p_params
operator|->
name|flags
operator|&
name|ECORE_DMAE_FLAG_VF_SRC
condition|)
block|{
name|opcode
operator||=
operator|(
literal|1
operator|<<
name|DMAE_CMD_SRC_VF_ID_VALID_SHIFT
operator|)
expr_stmt|;
name|opcode_b
operator||=
operator|(
name|p_params
operator|->
name|src_vfid
operator|<<
name|DMAE_CMD_SRC_VF_ID_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|opcode_b
operator||=
operator|(
name|DMAE_CMD_SRC_VF_ID_MASK
operator|<<
name|DMAE_CMD_SRC_VF_ID_SHIFT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|p_params
operator|->
name|flags
operator|&
name|ECORE_DMAE_FLAG_VF_DST
condition|)
block|{
name|opcode
operator||=
literal|1
operator|<<
name|DMAE_CMD_DST_VF_ID_VALID_SHIFT
expr_stmt|;
name|opcode_b
operator||=
name|p_params
operator|->
name|dst_vfid
operator|<<
name|DMAE_CMD_DST_VF_ID_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|opcode_b
operator||=
name|DMAE_CMD_DST_VF_ID_MASK
operator|<<
name|DMAE_CMD_DST_VF_ID_SHIFT
expr_stmt|;
block|}
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
operator|->
name|opcode
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
operator|->
name|opcode_b
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
name|opcode_b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|ecore_dmae_idx_to_go_cmd
parameter_list|(
name|u8
name|idx
parameter_list|)
block|{
name|OSAL_BUILD_BUG_ON
argument_list|(
operator|(
name|DMAE_REG_GO_C31
operator|-
name|DMAE_REG_GO_C0
operator|)
operator|!=
literal|31
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* All the DMAE 'go' registers form an array in internal memory */
return|return
name|DMAE_REG_GO_C0
operator|+
operator|(
name|idx
operator|<<
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_dmae_post_command
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|)
block|{
name|struct
name|dmae_cmd
modifier|*
name|p_command
init|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
decl_stmt|;
name|u8
name|idx_cmd
init|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|channel
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|_ecore_status_t
name|ecore_status
init|=
name|ECORE_SUCCESS
decl_stmt|;
comment|/* verify address is not OSAL_NULL */
if|if
condition|(
operator|(
operator|(
operator|(
operator|!
name|p_command
operator|->
name|dst_addr_lo
operator|)
operator|&&
operator|(
operator|!
name|p_command
operator|->
name|dst_addr_hi
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|p_command
operator|->
name|src_addr_lo
operator|)
operator|&&
operator|(
operator|!
name|p_command
operator|->
name|src_addr_hi
operator|)
operator|)
operator|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"source or destination address 0 idx_cmd=%d\n"
literal|"opcode = [0x%08x,0x%04x] len=0x%x src=0x%x:%x dst=0x%x:%x\n"
argument_list|,
name|idx_cmd
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|opcode
argument_list|)
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_command
operator|->
name|opcode_b
argument_list|)
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_command
operator|->
name|length_dw
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|src_addr_hi
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|src_addr_lo
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|dst_addr_hi
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|dst_addr_lo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"Posting DMAE command [idx %d]: opcode = [0x%08x,0x%04x] len=0x%x src=0x%x:%x dst=0x%x:%x\n"
argument_list|,
name|idx_cmd
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|opcode
argument_list|)
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_command
operator|->
name|opcode_b
argument_list|)
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_command
operator|->
name|length_dw
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|src_addr_hi
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|src_addr_lo
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|dst_addr_hi
argument_list|)
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_command
operator|->
name|dst_addr_lo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the command to DMAE - need to do it before every call 	 * for source/dest address no reset. 	 * The number of commands have been increased to 16 (previous was 14) 	 * The first 9 DWs are the command registers, the 10 DW is the 	 * GO register, and 	 * the rest are result registers (which are read only by the client). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMAE_CMD_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|data
init|=
operator|(
name|i
operator|<
name|DMAE_CMD_SIZE_TO_FILL
operator|)
condition|?
operator|*
operator|(
operator|(
operator|(
name|u32
operator|*
operator|)
name|p_command
operator|)
operator|+
name|i
operator|)
else|:
literal|0
decl_stmt|;
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|DMAE_REG_CMD_MEM
operator|+
operator|(
name|idx_cmd
operator|*
name|DMAE_CMD_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|ecore_wr
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|ecore_dmae_idx_to_go_cmd
argument_list|(
name|idx_cmd
argument_list|)
argument_list|,
name|DMAE_GO_VALUE
argument_list|)
expr_stmt|;
return|return
name|ecore_status
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_dmae_info_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|dma_addr_t
modifier|*
name|p_addr
init|=
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|completion_word_phys_addr
decl_stmt|;
name|struct
name|dmae_cmd
modifier|*
modifier|*
name|p_cmd
init|=
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
decl_stmt|;
name|u32
modifier|*
modifier|*
name|p_buff
init|=
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_intermediate_buffer
decl_stmt|;
name|u32
modifier|*
modifier|*
name|p_comp
init|=
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_completion_word
decl_stmt|;
operator|*
name|p_comp
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p_comp
operator|==
name|OSAL_NULL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `p_completion_word'\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p_addr
operator|=
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|dmae_cmd_phys_addr
expr_stmt|;
operator|*
name|p_cmd
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p_cmd
operator|==
name|OSAL_NULL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `struct dmae_cmd'\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p_addr
operator|=
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|intermediate_buffer_phys_addr
expr_stmt|;
operator|*
name|p_buff
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|DMAE_MAX_RW_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p_buff
operator|==
name|OSAL_NULL
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `intermediate_buffer'\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|channel
operator|=
name|p_hwfn
operator|->
name|rel_pf_id
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
name|err
label|:
name|ecore_dmae_info_free
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
end_function

begin_function
name|void
name|ecore_dmae_info_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|dma_addr_t
name|p_phys
decl_stmt|;
comment|/* Just make sure no one is in the middle */
name|OSAL_MUTEX_ACQUIRE
argument_list|(
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_completion_word
operator|!=
name|OSAL_NULL
condition|)
block|{
name|p_phys
operator|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|completion_word_phys_addr
expr_stmt|;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_completion_word
argument_list|,
name|p_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_completion_word
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
operator|!=
name|OSAL_NULL
condition|)
block|{
name|p_phys
operator|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|dmae_cmd_phys_addr
expr_stmt|;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
argument_list|,
name|p_phys
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_intermediate_buffer
operator|!=
name|OSAL_NULL
condition|)
block|{
name|p_phys
operator|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|intermediate_buffer_phys_addr
expr_stmt|;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_intermediate_buffer
argument_list|,
name|p_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|DMAE_MAX_RW_SIZE
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_intermediate_buffer
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
name|OSAL_MUTEX_RELEASE
argument_list|(
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_dmae_operation_wait
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|u32
name|wait_cnt_limit
init|=
literal|10000
decl_stmt|,
name|wait_cnt
init|=
literal|0
decl_stmt|;
name|enum
name|_ecore_status_t
name|ecore_status
init|=
name|ECORE_SUCCESS
decl_stmt|;
ifndef|#
directive|ifndef
name|ASIC_ONLY
name|u32
name|factor
init|=
operator|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|?
name|ECORE_EMUL_FACTOR
else|:
operator|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|?
name|ECORE_FPGA_FACTOR
else|:
literal|1
operator|)
operator|)
decl_stmt|;
name|wait_cnt_limit
operator|*=
name|factor
expr_stmt|;
endif|#
directive|endif
comment|/* DMAE_E4_TODO : TODO check if we have to call any other function 	 * other than BARRIER to sync the completion_word since we are not 	 * using the volatile keyword for this 	 */
name|OSAL_BARRIER
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_completion_word
operator|!=
name|DMAE_COMPLETION_VAL
condition|)
block|{
name|OSAL_UDELAY
argument_list|(
name|DMAE_MIN_WAIT_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wait_cnt
operator|>
name|wait_cnt_limit
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"Timed-out waiting for operation to complete. Completion word is 0x%08x expected 0x%08x.\n"
argument_list|,
operator|*
operator|(
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_completion_word
operator|)
argument_list|,
name|DMAE_COMPLETION_VAL
argument_list|)
expr_stmt|;
name|ecore_status
operator|=
name|ECORE_TIMEOUT
expr_stmt|;
break|break;
block|}
comment|/* to sync the completion_word since we are not 		 * using the volatile keyword for p_completion_word 		 */
name|OSAL_BARRIER
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecore_status
operator|==
name|ECORE_SUCCESS
condition|)
operator|*
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_completion_word
operator|=
literal|0
expr_stmt|;
return|return
name|ecore_status
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_dmae_execute_sub_operation
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u64
name|src_addr
parameter_list|,
name|u64
name|dst_addr
parameter_list|,
name|u8
name|src_type
parameter_list|,
name|u8
name|dst_type
parameter_list|,
name|u32
name|length_dw
parameter_list|)
block|{
name|dma_addr_t
name|phys
init|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|intermediate_buffer_phys_addr
decl_stmt|;
name|struct
name|dmae_cmd
modifier|*
name|cmd
init|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
decl_stmt|;
name|enum
name|_ecore_status_t
name|ecore_status
init|=
name|ECORE_SUCCESS
decl_stmt|;
switch|switch
condition|(
name|src_type
condition|)
block|{
case|case
name|ECORE_DMAE_ADDRESS_GRC
case|:
case|case
name|ECORE_DMAE_ADDRESS_HOST_PHYS
case|:
name|cmd
operator|->
name|src_addr_hi
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_HI
argument_list|(
name|src_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|src_addr_lo
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_LO
argument_list|(
name|src_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* for virtual source addresses we use the intermediate buffer. */
case|case
name|ECORE_DMAE_ADDRESS_HOST_VIRT
case|:
name|cmd
operator|->
name|src_addr_hi
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_HI
argument_list|(
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|src_addr_lo
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_LO
argument_list|(
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|OSAL_MEMCPY
argument_list|(
operator|&
operator|(
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_intermediate_buffer
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|osal_uintptr_t
operator|)
name|src_addr
argument_list|,
name|length_dw
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
switch|switch
condition|(
name|dst_type
condition|)
block|{
case|case
name|ECORE_DMAE_ADDRESS_GRC
case|:
case|case
name|ECORE_DMAE_ADDRESS_HOST_PHYS
case|:
name|cmd
operator|->
name|dst_addr_hi
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_HI
argument_list|(
name|dst_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|dst_addr_lo
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_LO
argument_list|(
name|dst_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* for virtual destination addresses we use the intermediate buffer. */
case|case
name|ECORE_DMAE_ADDRESS_HOST_VIRT
case|:
name|cmd
operator|->
name|dst_addr_hi
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_HI
argument_list|(
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|dst_addr_lo
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_LO
argument_list|(
name|phys
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
name|cmd
operator|->
name|length_dw
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
operator|(
name|u16
operator|)
name|length_dw
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_type
operator|==
name|ECORE_DMAE_ADDRESS_HOST_VIRT
operator|||
name|src_type
operator|==
name|ECORE_DMAE_ADDRESS_HOST_PHYS
condition|)
name|OSAL_DMA_SYNC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|HILO_U64
argument_list|(
name|cmd
operator|->
name|src_addr_hi
argument_list|,
name|cmd
operator|->
name|src_addr_lo
argument_list|)
argument_list|,
name|length_dw
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ecore_dmae_post_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|)
expr_stmt|;
name|ecore_status
operator|=
name|ecore_dmae_operation_wait
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
comment|/* TODO - is it true ? */
if|if
condition|(
name|src_type
operator|==
name|ECORE_DMAE_ADDRESS_HOST_VIRT
operator|||
name|src_type
operator|==
name|ECORE_DMAE_ADDRESS_HOST_PHYS
condition|)
name|OSAL_DMA_SYNC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|HILO_U64
argument_list|(
name|cmd
operator|->
name|src_addr_hi
argument_list|,
name|cmd
operator|->
name|src_addr_lo
argument_list|)
argument_list|,
name|length_dw
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecore_status
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"Wait Failed. source_addr 0x%llx, grc_addr 0x%llx, size_in_dwords 0x%x, intermediate buffer 0x%llx.\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|src_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|dst_addr
argument_list|,
name|length_dw
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|intermediate_buffer_phys_addr
argument_list|)
expr_stmt|;
return|return
name|ecore_status
return|;
block|}
if|if
condition|(
name|dst_type
operator|==
name|ECORE_DMAE_ADDRESS_HOST_VIRT
condition|)
name|OSAL_MEMCPY
argument_list|(
operator|(
name|void
operator|*
operator|)
call|(
name|osal_uintptr_t
call|)
argument_list|(
name|dst_addr
argument_list|)
argument_list|,
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_intermediate_buffer
index|[
literal|0
index|]
argument_list|,
name|length_dw
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_dmae_execute_command
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u64
name|src_addr
parameter_list|,
name|u64
name|dst_addr
parameter_list|,
name|u8
name|src_type
parameter_list|,
name|u8
name|dst_type
parameter_list|,
name|u32
name|size_in_dwords
parameter_list|,
name|struct
name|ecore_dmae_params
modifier|*
name|p_params
parameter_list|)
block|{
name|dma_addr_t
name|phys
init|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|completion_word_phys_addr
decl_stmt|;
name|u16
name|length_cur
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|,
name|cnt_split
init|=
literal|0
decl_stmt|,
name|length_mod
init|=
literal|0
decl_stmt|;
name|struct
name|dmae_cmd
modifier|*
name|cmd
init|=
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|p_dmae_cmd
decl_stmt|;
name|u64
name|src_addr_split
init|=
literal|0
decl_stmt|,
name|dst_addr_split
init|=
literal|0
decl_stmt|;
name|u16
name|length_limit
init|=
name|DMAE_MAX_RW_SIZE
decl_stmt|;
name|enum
name|_ecore_status_t
name|ecore_status
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|u32
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|recov_in_prog
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_HW
argument_list|,
literal|"Recovery is in progress. Avoid DMAE transaction [{src: addr 0x%llx, type %d}, {dst: addr 0x%llx, type %d}, size %d].\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|src_addr
argument_list|,
name|src_type
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|dst_addr
argument_list|,
name|dst_type
argument_list|,
name|size_in_dwords
argument_list|)
expr_stmt|;
comment|/* Return success to let the flow to be completed successfully 		 * w/o any error handling. 		 */
return|return
name|ECORE_SUCCESS
return|;
block|}
name|ecore_dmae_opcode
argument_list|(
name|p_hwfn
argument_list|,
operator|(
name|src_type
operator|==
name|ECORE_DMAE_ADDRESS_GRC
operator|)
argument_list|,
operator|(
name|dst_type
operator|==
name|ECORE_DMAE_ADDRESS_GRC
operator|)
argument_list|,
name|p_params
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|comp_addr_lo
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_LO
argument_list|(
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|comp_addr_hi
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMA_HI
argument_list|(
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|comp_val
operator|=
name|OSAL_CPU_TO_LE32
argument_list|(
name|DMAE_COMPLETION_VAL
argument_list|)
expr_stmt|;
comment|/* Check if the grc_addr is valid like< MAX_GRC_OFFSET */
name|cnt_split
operator|=
name|size_in_dwords
operator|/
name|length_limit
expr_stmt|;
name|length_mod
operator|=
name|size_in_dwords
operator|%
name|length_limit
expr_stmt|;
name|src_addr_split
operator|=
name|src_addr
expr_stmt|;
name|dst_addr_split
operator|=
name|dst_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cnt_split
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|length_limit
operator|*
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_params
operator|->
name|flags
operator|&
name|ECORE_DMAE_FLAG_RW_REPL_SRC
operator|)
condition|)
block|{
if|if
condition|(
name|src_type
operator|==
name|ECORE_DMAE_ADDRESS_GRC
condition|)
name|src_addr_split
operator|=
name|src_addr
operator|+
name|offset
expr_stmt|;
else|else
name|src_addr_split
operator|=
name|src_addr
operator|+
operator|(
name|offset
operator|*
literal|4
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dst_type
operator|==
name|ECORE_DMAE_ADDRESS_GRC
condition|)
name|dst_addr_split
operator|=
name|dst_addr
operator|+
name|offset
expr_stmt|;
else|else
name|dst_addr_split
operator|=
name|dst_addr
operator|+
operator|(
name|offset
operator|*
literal|4
operator|)
expr_stmt|;
name|length_cur
operator|=
operator|(
name|cnt_split
operator|==
name|i
operator|)
condition|?
name|length_mod
else|:
name|length_limit
expr_stmt|;
comment|/* might be zero on last iteration */
if|if
condition|(
operator|!
name|length_cur
condition|)
continue|continue;
name|ecore_status
operator|=
name|ecore_dmae_execute_sub_operation
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|src_addr_split
argument_list|,
name|dst_addr_split
argument_list|,
name|src_type
argument_list|,
name|dst_type
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecore_status
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"ecore_dmae_execute_sub_operation Failed with error 0x%x. source_addr 0x%llx, destination addr 0x%llx, size_in_dwords 0x%x\n"
argument_list|,
name|ecore_status
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|src_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|dst_addr
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
name|ecore_hw_err_notify
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_ERR_DMAE_FAIL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ecore_status
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_dmae_host2grc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u64
name|source_addr
parameter_list|,
name|u32
name|grc_addr
parameter_list|,
name|u32
name|size_in_dwords
parameter_list|,
name|u32
name|flags
parameter_list|)
block|{
name|u32
name|grc_addr_in_dw
init|=
name|grc_addr
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
decl_stmt|;
name|struct
name|ecore_dmae_params
name|params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_dmae_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|OSAL_MUTEX_ACQUIRE
argument_list|(
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_dmae_execute_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|source_addr
argument_list|,
name|grc_addr_in_dw
argument_list|,
name|ECORE_DMAE_ADDRESS_HOST_VIRT
argument_list|,
name|ECORE_DMAE_ADDRESS_GRC
argument_list|,
name|size_in_dwords
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|OSAL_MUTEX_RELEASE
argument_list|(
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_dmae_grc2host
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|u32
name|grc_addr
parameter_list|,
name|dma_addr_t
name|dest_addr
parameter_list|,
name|u32
name|size_in_dwords
parameter_list|,
name|u32
name|flags
parameter_list|)
block|{
name|u32
name|grc_addr_in_dw
init|=
name|grc_addr
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
decl_stmt|;
name|struct
name|ecore_dmae_params
name|params
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MEMSET
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_dmae_params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|OSAL_MUTEX_ACQUIRE
argument_list|(
operator|&
operator|(
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_dmae_execute_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|grc_addr_in_dw
argument_list|,
name|dest_addr
argument_list|,
name|ECORE_DMAE_ADDRESS_GRC
argument_list|,
name|ECORE_DMAE_ADDRESS_HOST_VIRT
argument_list|,
name|size_in_dwords
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|OSAL_MUTEX_RELEASE
argument_list|(
operator|&
operator|(
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
operator|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_dmae_host2host
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_ptt
modifier|*
name|p_ptt
parameter_list|,
name|dma_addr_t
name|source_addr
parameter_list|,
name|dma_addr_t
name|dest_addr
parameter_list|,
name|u32
name|size_in_dwords
parameter_list|,
name|struct
name|ecore_dmae_params
modifier|*
name|p_params
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|OSAL_MUTEX_ACQUIRE
argument_list|(
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_dmae_execute_command
argument_list|(
name|p_hwfn
argument_list|,
name|p_ptt
argument_list|,
name|source_addr
argument_list|,
name|dest_addr
argument_list|,
name|ECORE_DMAE_ADDRESS_HOST_PHYS
argument_list|,
name|ECORE_DMAE_ADDRESS_HOST_PHYS
argument_list|,
name|size_in_dwords
argument_list|,
name|p_params
argument_list|)
expr_stmt|;
name|OSAL_MUTEX_RELEASE
argument_list|(
operator|&
name|p_hwfn
operator|->
name|dmae_info
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_hw_err_notify
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|enum
name|ecore_hw_err_type
name|err_type
parameter_list|)
block|{
comment|/* Fan failure cannot be masked by handling of another HW error */
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|recov_in_prog
operator|&&
name|err_type
operator|!=
name|ECORE_HW_ERR_FAN_FAIL
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_DRV
argument_list|,
literal|"Recovery is in progress. Avoid notifying about HW error %d.\n"
argument_list|,
name|err_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|OSAL_HW_ERROR_OCCURRED
argument_list|(
name|p_hwfn
argument_list|,
name|err_type
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

