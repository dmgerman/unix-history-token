begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-2018 Cavium, Inc.   * All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * File : ecore_spq.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bcm_osal.h"
end_include

begin_include
include|#
directive|include
file|"reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_gtt_reg_addr.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi_common.h"
end_include

begin_include
include|#
directive|include
file|"ecore.h"
end_include

begin_include
include|#
directive|include
file|"ecore_sp_api.h"
end_include

begin_include
include|#
directive|include
file|"ecore_spq.h"
end_include

begin_include
include|#
directive|include
file|"ecore_iro.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_fw_funcs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_cxt.h"
end_include

begin_include
include|#
directive|include
file|"ecore_int.h"
end_include

begin_include
include|#
directive|include
file|"ecore_dev_api.h"
end_include

begin_include
include|#
directive|include
file|"ecore_mcp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ROCE
end_ifdef

begin_include
include|#
directive|include
file|"ecore_roce.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ecore_hw.h"
end_include

begin_include
include|#
directive|include
file|"ecore_sriov.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ISCSI
end_ifdef

begin_include
include|#
directive|include
file|"ecore_iscsi.h"
end_include

begin_include
include|#
directive|include
file|"ecore_ooo.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/***************************************************************************  * Structures& Definitions  ***************************************************************************/
end_comment

begin_define
define|#
directive|define
name|SPQ_HIGH_PRI_RESERVE_DEFAULT
value|(1)
end_define

begin_define
define|#
directive|define
name|SPQ_BLOCK_DELAY_MAX_ITER
value|(10)
end_define

begin_define
define|#
directive|define
name|SPQ_BLOCK_DELAY_US
value|(10)
end_define

begin_define
define|#
directive|define
name|SPQ_BLOCK_SLEEP_MAX_ITER
value|(1000)
end_define

begin_define
define|#
directive|define
name|SPQ_BLOCK_SLEEP_MS
value|(5)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|REMOVE_DBG
end_ifndef

begin_comment
comment|/***************************************************************************  * Debug [iSCSI] tool  ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ecore_iscsi_eq_dump
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|event_ring_entry
modifier|*
name|p_eqe
parameter_list|)
block|{
if|if
condition|(
name|p_eqe
operator|->
name|opcode
operator|>=
name|MAX_ISCSI_EQE_OPCODE
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"Unknown iSCSI EQ: %x\n"
argument_list|,
name|p_eqe
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p_eqe
operator|->
name|opcode
condition|)
block|{
case|case
name|ISCSI_EVENT_TYPE_INIT_FUNC
case|:
case|case
name|ISCSI_EVENT_TYPE_DESTROY_FUNC
case|:
comment|/* NOPE */
break|break;
case|case
name|ISCSI_EVENT_TYPE_OFFLOAD_CONN
case|:
case|case
name|ISCSI_EVENT_TYPE_TERMINATE_CONN
case|:
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_STORAGE
argument_list|,
literal|"iSCSI EQE: Port %x, Op %x, echo %x, FWret %x, CID %x, ConnID %x, ERR %x\n"
argument_list|,
name|p_hwfn
operator|->
name|port_id
argument_list|,
name|p_eqe
operator|->
name|opcode
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_eqe
operator|->
name|echo
argument_list|)
argument_list|,
name|p_eqe
operator|->
name|fw_return_code
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_eqe
operator|->
name|data
operator|.
name|iscsi_info
operator|.
name|cid
argument_list|)
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_eqe
operator|->
name|data
operator|.
name|iscsi_info
operator|.
name|conn_id
argument_list|)
argument_list|,
name|p_eqe
operator|->
name|data
operator|.
name|iscsi_info
operator|.
name|error_code
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISCSI_EVENT_TYPE_UPDATE_CONN
case|:
case|case
name|ISCSI_EVENT_TYPE_CLEAR_SQ
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_CONNECT_COMPLETE
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_TERMINATE_DONE
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_ABORT_RCVD
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_CLOSE_RCVD
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_SYN_RCVD
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_MAX_RT_TIME
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_MAX_RT_CNT
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_MAX_KA_PROBES_CNT
case|:
case|case
name|ISCSI_EVENT_TYPE_ASYN_FIN_WAIT2
case|:
case|case
name|ISCSI_EVENT_TYPE_ISCSI_CONN_ERROR
case|:
case|case
name|ISCSI_EVENT_TYPE_TCP_CONN_ERROR
case|:
default|default:
comment|/* NOPE */
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/***************************************************************************  * Blocking Imp. (BLOCK/EBLOCK mode)  ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ecore_spq_blocking_cb
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|union
name|event_ring_data
modifier|*
name|data
parameter_list|,
name|u8
name|fw_return_code
parameter_list|)
block|{
name|struct
name|ecore_spq_comp_done
modifier|*
name|comp_done
decl_stmt|;
name|comp_done
operator|=
operator|(
expr|struct
name|ecore_spq_comp_done
operator|*
operator|)
name|cookie
expr_stmt|;
name|comp_done
operator|->
name|done
operator|=
literal|0x1
expr_stmt|;
name|comp_done
operator|->
name|fw_return_code
operator|=
name|fw_return_code
expr_stmt|;
comment|/* make update visible to waiting thread */
name|OSAL_SMP_WMB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|__ecore_spq_block
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
parameter_list|,
name|u8
modifier|*
name|p_fw_ret
parameter_list|,
name|bool
name|sleep_between_iter
parameter_list|)
block|{
name|struct
name|ecore_spq_comp_done
modifier|*
name|comp_done
decl_stmt|;
name|u32
name|iter_cnt
decl_stmt|;
name|comp_done
operator|=
operator|(
expr|struct
name|ecore_spq_comp_done
operator|*
operator|)
name|p_ent
operator|->
name|comp_cb
operator|.
name|cookie
expr_stmt|;
name|iter_cnt
operator|=
name|sleep_between_iter
condition|?
name|SPQ_BLOCK_SLEEP_MAX_ITER
else|:
name|SPQ_BLOCK_DELAY_MAX_ITER
expr_stmt|;
while|while
condition|(
name|iter_cnt
operator|--
condition|)
block|{
name|OSAL_POLL_MODE_DPC
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|OSAL_SMP_RMB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_done
operator|->
name|done
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|p_fw_ret
condition|)
operator|*
name|p_fw_ret
operator|=
name|comp_done
operator|->
name|fw_return_code
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
if|if
condition|(
name|sleep_between_iter
condition|)
block|{
name|OSAL_MSLEEP
argument_list|(
name|SPQ_BLOCK_SLEEP_MS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSAL_UDELAY
argument_list|(
name|SPQ_BLOCK_DELAY_US
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ECORE_TIMEOUT
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_spq_block
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
parameter_list|,
name|u8
modifier|*
name|p_fw_ret
parameter_list|,
name|bool
name|skip_quick_poll
parameter_list|)
block|{
name|struct
name|ecore_spq_comp_done
modifier|*
name|comp_done
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* A relatively short polling period w/o sleeping, to allow the FW to 	 * complete the ramrod and thus possibly to avoid the following sleeps. 	 */
if|if
condition|(
operator|!
name|skip_quick_poll
condition|)
block|{
name|rc
operator|=
name|__ecore_spq_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|,
name|p_fw_ret
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
condition|)
return|return
name|ECORE_SUCCESS
return|;
block|}
comment|/* Move to polling with a sleeping period between iterations */
name|rc
operator|=
name|__ecore_spq_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|,
name|p_fw_ret
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|DP_INFO
argument_list|(
name|p_hwfn
argument_list|,
literal|"Ramrod is stuck, requesting MCP drain\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_mcp_drain
argument_list|(
name|p_hwfn
argument_list|,
name|p_hwfn
operator|->
name|p_main_ptt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"MCP drain failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Retry after drain */
name|rc
operator|=
name|__ecore_spq_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|,
name|p_fw_ret
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_SUCCESS
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|comp_done
operator|=
operator|(
expr|struct
name|ecore_spq_comp_done
operator|*
operator|)
name|p_ent
operator|->
name|comp_cb
operator|.
name|cookie
expr_stmt|;
if|if
condition|(
name|comp_done
operator|->
name|done
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|p_fw_ret
condition|)
operator|*
name|p_fw_ret
operator|=
name|comp_done
operator|->
name|fw_return_code
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
name|err
label|:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Ramrod is stuck [CID %08x cmd %02x protocol %02x echo %04x]\n"
argument_list|,
name|OSAL_LE32_TO_CPU
argument_list|(
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|cid
argument_list|)
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|cmd_id
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|protocol_id
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|echo
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_hw_err_notify
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_HW_ERR_RAMROD_FAIL
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * SPQ entries inner API  ***************************************************************************/
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_spq_fill_entry
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
parameter_list|)
block|{
name|p_ent
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p_ent
operator|->
name|comp_mode
condition|)
block|{
case|case
name|ECORE_SPQ_MODE_EBLOCK
case|:
case|case
name|ECORE_SPQ_MODE_BLOCK
case|:
name|p_ent
operator|->
name|comp_cb
operator|.
name|function
operator|=
name|ecore_spq_blocking_cb
expr_stmt|;
break|break;
case|case
name|ECORE_SPQ_MODE_CB
case|:
break|break;
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unknown SPQE completion mode %d\n"
argument_list|,
name|p_ent
operator|->
name|comp_mode
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SPQ
argument_list|,
literal|"Ramrod header: [CID 0x%08x CMD 0x%02x protocol 0x%02x] Data pointer: [%08x:%08x] Completion Mode: %s\n"
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|cid
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|cmd_id
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|protocol_id
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|data_ptr
operator|.
name|hi
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|data_ptr
operator|.
name|lo
argument_list|,
name|D_TRINE
argument_list|(
name|p_ent
operator|->
name|comp_mode
argument_list|,
name|ECORE_SPQ_MODE_EBLOCK
argument_list|,
name|ECORE_SPQ_MODE_BLOCK
argument_list|,
literal|"MODE_EBLOCK"
argument_list|,
literal|"MODE_BLOCK"
argument_list|,
literal|"MODE_CB"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * HSI access  ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ecore_spq_hw_initialize
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq
modifier|*
name|p_spq
parameter_list|)
block|{
name|struct
name|ecore_cxt_info
name|cxt_info
decl_stmt|;
name|struct
name|core_conn_context
modifier|*
name|p_cxt
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|u16
name|physical_q
decl_stmt|;
name|cxt_info
operator|.
name|iid
operator|=
name|p_spq
operator|->
name|cid
expr_stmt|;
name|rc
operator|=
name|ecore_cxt_get_cid_info
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|cxt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Cannot find context info for cid=%d\n"
argument_list|,
name|p_spq
operator|->
name|cid
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_cxt
operator|=
name|cxt_info
operator|.
name|p_cxt
expr_stmt|;
comment|/* @@@TBD we zero the context until we have ilt_reset implemented. */
name|OSAL_MEM_ZERO
argument_list|(
name|p_cxt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_cxt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECORE_IS_BB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
operator|||
name|ECORE_IS_AH
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
block|{
name|SET_FIELD
argument_list|(
name|p_cxt
operator|->
name|xstorm_ag_context
operator|.
name|flags10
argument_list|,
name|E4_XSTORM_CORE_CONN_AG_CTX_DQ_CF_EN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|p_cxt
operator|->
name|xstorm_ag_context
operator|.
name|flags1
argument_list|,
name|E4_XSTORM_CORE_CONN_AG_CTX_DQ_CF_ACTIVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*SET_FIELD(p_cxt->xstorm_ag_context.flags10, 			  E4_XSTORM_CORE_CONN_AG_CTX_SLOW_PATH_EN, 1);*/
name|SET_FIELD
argument_list|(
name|p_cxt
operator|->
name|xstorm_ag_context
operator|.
name|flags9
argument_list|,
name|E4_XSTORM_CORE_CONN_AG_CTX_CONSOLID_PROD_CF_EN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* E5 */
name|ECORE_E5_MISSING_CODE
expr_stmt|;
block|}
comment|/* CDU validation - FIXME currently disabled */
comment|/* QM physical queue */
name|physical_q
operator|=
name|ecore_get_cm_pq_idx
argument_list|(
name|p_hwfn
argument_list|,
name|PQ_FLAGS_LB
argument_list|)
expr_stmt|;
name|p_cxt
operator|->
name|xstorm_ag_context
operator|.
name|physical_q0
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
name|physical_q
argument_list|)
expr_stmt|;
name|p_cxt
operator|->
name|xstorm_st_context
operator|.
name|spq_base_lo
operator|=
name|DMA_LO_LE
argument_list|(
name|p_spq
operator|->
name|chain
operator|.
name|p_phys_addr
argument_list|)
expr_stmt|;
name|p_cxt
operator|->
name|xstorm_st_context
operator|.
name|spq_base_hi
operator|=
name|DMA_HI_LE
argument_list|(
name|p_spq
operator|->
name|chain
operator|.
name|p_phys_addr
argument_list|)
expr_stmt|;
name|DMA_REGPAIR_LE
argument_list|(
name|p_cxt
operator|->
name|xstorm_st_context
operator|.
name|consolid_base_addr
argument_list|,
name|p_hwfn
operator|->
name|p_consq
operator|->
name|chain
operator|.
name|p_phys_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_spq_hw_post
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq
modifier|*
name|p_spq
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
parameter_list|)
block|{
name|struct
name|ecore_chain
modifier|*
name|p_chain
init|=
operator|&
name|p_hwfn
operator|->
name|p_spq
operator|->
name|chain
decl_stmt|;
name|u16
name|echo
init|=
name|ecore_chain_get_prod_idx
argument_list|(
name|p_chain
argument_list|)
decl_stmt|;
name|struct
name|slow_path_element
modifier|*
name|elem
decl_stmt|;
name|struct
name|core_db_data
name|db
decl_stmt|;
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|echo
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
name|echo
argument_list|)
expr_stmt|;
name|elem
operator|=
name|ecore_chain_produce
argument_list|(
name|p_chain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elem
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to produce from SPQ chain\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
operator|*
name|elem
operator|=
name|p_ent
operator|->
name|elem
expr_stmt|;
comment|/* struct assignment */
comment|/* send a doorbell on the slow hwfn session */
name|OSAL_MEMSET
argument_list|(
operator|&
name|db
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|db
operator|.
name|params
argument_list|,
name|CORE_DB_DATA_DEST
argument_list|,
name|DB_DEST_XCM
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|db
operator|.
name|params
argument_list|,
name|CORE_DB_DATA_AGG_CMD
argument_list|,
name|DB_AGG_CMD_SET
argument_list|)
expr_stmt|;
name|SET_FIELD
argument_list|(
name|db
operator|.
name|params
argument_list|,
name|CORE_DB_DATA_AGG_VAL_SEL
argument_list|,
name|DQ_XCM_CORE_SPQ_PROD_CMD
argument_list|)
expr_stmt|;
name|db
operator|.
name|agg_flags
operator|=
name|DQ_XCM_CORE_DQ_CF_CMD
expr_stmt|;
name|db
operator|.
name|spq_prod
operator|=
name|OSAL_CPU_TO_LE16
argument_list|(
name|ecore_chain_get_prod_idx
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure the SPQE is updated before the doorbell */
name|OSAL_WMB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
name|DOORBELL
argument_list|(
name|p_hwfn
argument_list|,
name|DB_ADDR
argument_list|(
name|p_spq
operator|->
name|cid
argument_list|,
name|DQ_DEMS_LEGACY
argument_list|)
argument_list|,
operator|*
operator|(
name|u32
operator|*
operator|)
operator|&
name|db
argument_list|)
expr_stmt|;
comment|/* make sure doorbell is rang */
name|OSAL_WMB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SPQ
argument_list|,
literal|"Doorbelled [0x%08x, CID 0x%08x] with Flags: %02x agg_params: %02x, prod: %04x\n"
argument_list|,
name|DB_ADDR
argument_list|(
name|p_spq
operator|->
name|cid
argument_list|,
name|DQ_DEMS_LEGACY
argument_list|)
argument_list|,
name|p_spq
operator|->
name|cid
argument_list|,
name|db
operator|.
name|params
argument_list|,
name|db
operator|.
name|agg_flags
argument_list|,
name|ecore_chain_get_prod_idx
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * Asynchronous events  ***************************************************************************/
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_async_event_completion
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|event_ring_entry
modifier|*
name|p_eqe
parameter_list|)
block|{
switch|switch
condition|(
name|p_eqe
operator|->
name|protocol_id
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ROCE
case|case
name|PROTOCOLID_ROCE
case|:
block|{
name|ecore_roce_async_event
argument_list|(
name|p_hwfn
argument_list|,
name|p_eqe
operator|->
name|opcode
argument_list|,
operator|&
name|p_eqe
operator|->
name|data
operator|.
name|rdma_data
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_ECORE_IWARP
case|case
name|PROTOCOLID_IWARP
case|:
block|{
name|ecore_iwarp_async_event
argument_list|(
name|p_hwfn
argument_list|,
name|p_eqe
operator|->
name|opcode
argument_list|,
operator|&
name|p_eqe
operator|->
name|data
operator|.
name|rdma_data
operator|.
name|async_handle
argument_list|,
name|p_eqe
operator|->
name|fw_return_code
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
endif|#
directive|endif
endif|#
directive|endif
case|case
name|PROTOCOLID_COMMON
case|:
return|return
name|ecore_sriov_eqe_event
argument_list|(
name|p_hwfn
argument_list|,
name|p_eqe
operator|->
name|opcode
argument_list|,
name|p_eqe
operator|->
name|echo
argument_list|,
operator|&
name|p_eqe
operator|->
name|data
argument_list|)
return|;
ifdef|#
directive|ifdef
name|CONFIG_ECORE_ISCSI
case|case
name|PROTOCOLID_ISCSI
case|:
if|if
condition|(
name|p_hwfn
operator|->
name|p_iscsi_info
operator|->
name|event_cb
operator|!=
name|OSAL_NULL
condition|)
block|{
name|struct
name|ecore_iscsi_info
modifier|*
name|p_iscsi
init|=
name|p_hwfn
operator|->
name|p_iscsi_info
decl_stmt|;
return|return
name|p_iscsi
operator|->
name|event_cb
argument_list|(
name|p_iscsi
operator|->
name|event_context
argument_list|,
name|p_eqe
operator|->
name|opcode
argument_list|,
operator|&
name|p_eqe
operator|->
name|data
argument_list|)
return|;
block|}
else|else
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|false
argument_list|,
literal|"iSCSI async completion is not set\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOTIMPL
return|;
block|}
endif|#
directive|endif
default|default:
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Unknown Async completion for protocol: %d\n"
argument_list|,
name|p_eqe
operator|->
name|protocol_id
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************************************  * EQ API  ***************************************************************************/
end_comment

begin_function
name|void
name|ecore_eq_prod_update
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|prod
parameter_list|)
block|{
name|u32
name|addr
init|=
name|GTT_BAR0_MAP_REG_USDM_RAM
operator|+
name|USTORM_EQE_CONS_OFFSET
argument_list|(
name|p_hwfn
operator|->
name|rel_pf_id
argument_list|)
decl_stmt|;
name|REG_WR16
argument_list|(
name|p_hwfn
argument_list|,
name|addr
argument_list|,
name|prod
argument_list|)
expr_stmt|;
comment|/* keep prod updates ordered */
name|OSAL_MMIOWB
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_eq_completion
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ecore_eq
modifier|*
name|p_eq
init|=
name|cookie
decl_stmt|;
name|struct
name|ecore_chain
modifier|*
name|p_chain
init|=
operator|&
name|p_eq
operator|->
name|chain
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
literal|0
decl_stmt|;
comment|/* take a snapshot of the FW consumer */
name|u16
name|fw_cons_idx
init|=
name|OSAL_LE16_TO_CPU
argument_list|(
operator|*
name|p_eq
operator|->
name|p_fw_cons
argument_list|)
decl_stmt|;
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SPQ
argument_list|,
literal|"fw_cons_idx %x\n"
argument_list|,
name|fw_cons_idx
argument_list|)
expr_stmt|;
comment|/* Need to guarantee the fw_cons index we use points to a usuable 	 * element (to comply with our chain), so our macros would comply 	 */
if|if
condition|(
operator|(
name|fw_cons_idx
operator|&
name|ecore_chain_get_usable_per_page
argument_list|(
name|p_chain
argument_list|)
operator|)
operator|==
name|ecore_chain_get_usable_per_page
argument_list|(
name|p_chain
argument_list|)
condition|)
block|{
name|fw_cons_idx
operator|+=
name|ecore_chain_get_unusable_per_page
argument_list|(
name|p_chain
argument_list|)
expr_stmt|;
block|}
comment|/* Complete current segment of eq entries */
while|while
condition|(
name|fw_cons_idx
operator|!=
name|ecore_chain_get_cons_idx
argument_list|(
name|p_chain
argument_list|)
condition|)
block|{
name|struct
name|event_ring_entry
modifier|*
name|p_eqe
init|=
name|ecore_chain_consume
argument_list|(
name|p_chain
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_eqe
condition|)
block|{
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
break|break;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SPQ
argument_list|,
literal|"op %x prot %x res0 %x echo %x fwret %x flags %x\n"
argument_list|,
name|p_eqe
operator|->
name|opcode
argument_list|,
comment|/* Event Opcode */
name|p_eqe
operator|->
name|protocol_id
argument_list|,
comment|/* Event Protocol ID */
name|p_eqe
operator|->
name|reserved0
argument_list|,
comment|/* Reserved */
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_eqe
operator|->
name|echo
argument_list|)
argument_list|,
comment|/* Echo value from 							ramrod data on the host 						      */
name|p_eqe
operator|->
name|fw_return_code
argument_list|,
comment|/* FW return code for SP 							ramrods 						      */
name|p_eqe
operator|->
name|flags
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|REMOVE_DBG
if|if
condition|(
name|p_eqe
operator|->
name|protocol_id
operator|==
name|PROTOCOLID_ISCSI
condition|)
name|ecore_iscsi_eq_dump
argument_list|(
name|p_hwfn
argument_list|,
name|p_eqe
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_FIELD
argument_list|(
name|p_eqe
operator|->
name|flags
argument_list|,
name|EVENT_RING_ENTRY_ASYNC
argument_list|)
condition|)
block|{
if|if
condition|(
name|ecore_async_event_completion
argument_list|(
name|p_hwfn
argument_list|,
name|p_eqe
argument_list|)
condition|)
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ecore_spq_completion
argument_list|(
name|p_hwfn
argument_list|,
name|p_eqe
operator|->
name|echo
argument_list|,
name|p_eqe
operator|->
name|fw_return_code
argument_list|,
operator|&
name|p_eqe
operator|->
name|data
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
block|}
name|ecore_chain_recycle_consumed
argument_list|(
name|p_chain
argument_list|)
expr_stmt|;
block|}
name|ecore_eq_prod_update
argument_list|(
name|p_hwfn
argument_list|,
name|ecore_chain_get_prod_idx
argument_list|(
name|p_chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_eq_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|u16
name|num_elem
parameter_list|)
block|{
name|struct
name|ecore_eq
modifier|*
name|p_eq
decl_stmt|;
comment|/* Allocate EQ struct */
name|p_eq
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_eq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_eq
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `struct ecore_eq'\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* Allocate and initialize EQ chain*/
if|if
condition|(
name|ecore_chain_alloc
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|ECORE_CHAIN_USE_TO_PRODUCE
argument_list|,
name|ECORE_CHAIN_MODE_PBL
argument_list|,
name|ECORE_CHAIN_CNT_TYPE_U16
argument_list|,
name|num_elem
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|event_ring_element
argument_list|)
argument_list|,
operator|&
name|p_eq
operator|->
name|chain
argument_list|,
name|OSAL_NULL
argument_list|)
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate eq chain\n"
argument_list|)
expr_stmt|;
goto|goto
name|eq_allocate_fail
goto|;
block|}
comment|/* register EQ completion on the SP SB */
name|ecore_int_register_cb
argument_list|(
name|p_hwfn
argument_list|,
name|ecore_eq_completion
argument_list|,
name|p_eq
argument_list|,
operator|&
name|p_eq
operator|->
name|eq_sb_index
argument_list|,
operator|&
name|p_eq
operator|->
name|p_fw_cons
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_eq
operator|=
name|p_eq
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
name|eq_allocate_fail
label|:
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_eq
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
end_function

begin_function
name|void
name|ecore_eq_setup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|ecore_chain_reset
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_eq
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_eq_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_eq
condition|)
return|return;
name|ecore_chain_free
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_hwfn
operator|->
name|p_eq
operator|->
name|chain
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|p_eq
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_eq
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************************************************************** * CQE API - manipulate EQ functionality ***************************************************************************/
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_cqe_completion
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|eth_slow_path_rx_cqe
modifier|*
name|cqe
parameter_list|,
name|enum
name|protocol_type
name|protocol
parameter_list|)
block|{
if|if
condition|(
name|IS_VF
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|)
condition|)
return|return
name|OSAL_VF_CQE_COMPLETION
argument_list|(
name|p_hwfn
argument_list|,
name|cqe
argument_list|,
name|protocol
argument_list|)
return|;
comment|/* @@@tmp - it's possible we'll eventually want to handle some 	 * actual commands that can arrive here, but for now this is only 	 * used to complete the ramrod using the echo value on the cqe 	 */
return|return
name|ecore_spq_completion
argument_list|(
name|p_hwfn
argument_list|,
name|cqe
operator|->
name|echo
argument_list|,
literal|0
argument_list|,
name|OSAL_NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_eth_cqe_completion
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|eth_slow_path_rx_cqe
modifier|*
name|cqe
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ecore_cqe_completion
argument_list|(
name|p_hwfn
argument_list|,
name|cqe
argument_list|,
name|PROTOCOLID_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to handle RXQ CQE [cmd 0x%02x]\n"
argument_list|,
name|cqe
operator|->
name|ramrod_cmd_id
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * Slow hwfn Queue (spq)  ***************************************************************************/
end_comment

begin_function
name|void
name|ecore_spq_setup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_spq
modifier|*
name|p_spq
init|=
name|p_hwfn
operator|->
name|p_spq
decl_stmt|;
name|struct
name|ecore_spq_entry
modifier|*
name|p_virt
init|=
name|OSAL_NULL
decl_stmt|;
name|dma_addr_t
name|p_phys
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|capacity
decl_stmt|;
name|OSAL_LIST_INIT
argument_list|(
operator|&
name|p_spq
operator|->
name|pending
argument_list|)
expr_stmt|;
name|OSAL_LIST_INIT
argument_list|(
operator|&
name|p_spq
operator|->
name|completion_pending
argument_list|)
expr_stmt|;
name|OSAL_LIST_INIT
argument_list|(
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|)
expr_stmt|;
name|OSAL_LIST_INIT
argument_list|(
operator|&
name|p_spq
operator|->
name|unlimited_pending
argument_list|)
expr_stmt|;
name|OSAL_SPIN_LOCK_INIT
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* SPQ empty pool */
name|p_phys
operator|=
name|p_spq
operator|->
name|p_phys
operator|+
name|OFFSETOF
argument_list|(
expr|struct
name|ecore_spq_entry
argument_list|,
name|ramrod
argument_list|)
expr_stmt|;
name|p_virt
operator|=
name|p_spq
operator|->
name|p_virt
expr_stmt|;
name|capacity
operator|=
name|ecore_chain_get_capacity
argument_list|(
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|capacity
condition|;
name|i
operator|++
control|)
block|{
name|DMA_REGPAIR_LE
argument_list|(
name|p_virt
operator|->
name|elem
operator|.
name|data_ptr
argument_list|,
name|p_phys
argument_list|)
expr_stmt|;
name|OSAL_LIST_PUSH_TAIL
argument_list|(
operator|&
name|p_virt
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|)
expr_stmt|;
name|p_virt
operator|++
expr_stmt|;
name|p_phys
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_spq_entry
argument_list|)
expr_stmt|;
block|}
comment|/* Statistics */
name|p_spq
operator|->
name|normal_count
operator|=
literal|0
expr_stmt|;
name|p_spq
operator|->
name|comp_count
operator|=
literal|0
expr_stmt|;
name|p_spq
operator|->
name|comp_sent_count
operator|=
literal|0
expr_stmt|;
name|p_spq
operator|->
name|unlimited_pending_count
operator|=
literal|0
expr_stmt|;
name|OSAL_MEM_ZERO
argument_list|(
name|p_spq
operator|->
name|p_comp_bitmap
argument_list|,
name|SPQ_COMP_BMAP_SIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
name|p_spq
operator|->
name|comp_bitmap_idx
operator|=
literal|0
expr_stmt|;
comment|/* SPQ cid, cannot fail */
name|ecore_cxt_acquire_cid
argument_list|(
name|p_hwfn
argument_list|,
name|PROTOCOLID_CORE
argument_list|,
operator|&
name|p_spq
operator|->
name|cid
argument_list|)
expr_stmt|;
name|ecore_spq_hw_initialize
argument_list|(
name|p_hwfn
argument_list|,
name|p_spq
argument_list|)
expr_stmt|;
comment|/* reset the chain itself */
name|ecore_chain_reset
argument_list|(
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_spq_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_spq_entry
modifier|*
name|p_virt
init|=
name|OSAL_NULL
decl_stmt|;
name|struct
name|ecore_spq
modifier|*
name|p_spq
init|=
name|OSAL_NULL
decl_stmt|;
name|dma_addr_t
name|p_phys
init|=
literal|0
decl_stmt|;
name|u32
name|capacity
decl_stmt|;
comment|/* SPQ struct */
name|p_spq
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_spq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_spq
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `struct ecore_spq'\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* SPQ ring  */
if|if
condition|(
name|ecore_chain_alloc
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|ECORE_CHAIN_USE_TO_PRODUCE
argument_list|,
name|ECORE_CHAIN_MODE_SINGLE
argument_list|,
name|ECORE_CHAIN_CNT_TYPE_U16
argument_list|,
literal|0
argument_list|,
comment|/* N/A when the mode is SINGLE */
sizeof|sizeof
argument_list|(
expr|struct
name|slow_path_element
argument_list|)
argument_list|,
operator|&
name|p_spq
operator|->
name|chain
argument_list|,
name|OSAL_NULL
argument_list|)
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate spq chain\n"
argument_list|)
expr_stmt|;
goto|goto
name|spq_allocate_fail
goto|;
block|}
comment|/* allocate and fill the SPQ elements (incl. ramrod data list) */
name|capacity
operator|=
name|ecore_chain_get_capacity
argument_list|(
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
name|p_virt
operator|=
name|OSAL_DMA_ALLOC_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_phys
argument_list|,
name|capacity
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_spq_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_virt
condition|)
block|{
goto|goto
name|spq_allocate_fail
goto|;
block|}
name|p_spq
operator|->
name|p_virt
operator|=
name|p_virt
expr_stmt|;
name|p_spq
operator|->
name|p_phys
operator|=
name|p_phys
expr_stmt|;
name|OSAL_SPIN_LOCK_ALLOC
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_spq
operator|=
name|p_spq
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
name|spq_allocate_fail
label|:
name|ecore_chain_free
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_spq
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
end_function

begin_function
name|void
name|ecore_spq_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_spq
modifier|*
name|p_spq
init|=
name|p_hwfn
operator|->
name|p_spq
decl_stmt|;
name|u32
name|capacity
decl_stmt|;
if|if
condition|(
operator|!
name|p_spq
condition|)
return|return;
if|if
condition|(
name|p_spq
operator|->
name|p_virt
condition|)
block|{
name|capacity
operator|=
name|ecore_chain_get_capacity
argument_list|(
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
name|OSAL_DMA_FREE_COHERENT
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_spq
operator|->
name|p_virt
argument_list|,
name|p_spq
operator|->
name|p_phys
argument_list|,
name|capacity
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_spq_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ecore_chain_free
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
name|OSAL_SPIN_LOCK_DEALLOC
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_spq
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_spq
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_spq_get_entry
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
modifier|*
name|pp_ent
parameter_list|)
block|{
name|struct
name|ecore_spq
modifier|*
name|p_spq
init|=
name|p_hwfn
operator|->
name|p_spq
decl_stmt|;
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
init|=
name|OSAL_NULL
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|OSAL_LIST_IS_EMPTY
argument_list|(
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|)
condition|)
block|{
name|p_ent
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_ATOMIC
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_ent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ent
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate an SPQ entry for a pending ramrod\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_NOMEM
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|p_ent
operator|->
name|queue
operator|=
operator|&
name|p_spq
operator|->
name|unlimited_pending
expr_stmt|;
block|}
else|else
block|{
name|p_ent
operator|=
name|OSAL_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|,
expr|struct
name|ecore_spq_entry
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|OSAL_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|)
expr_stmt|;
name|p_ent
operator|->
name|queue
operator|=
operator|&
name|p_spq
operator|->
name|pending
expr_stmt|;
block|}
operator|*
name|pp_ent
operator|=
name|p_ent
expr_stmt|;
name|out_unlock
label|:
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Locked variant; Should be called while the SPQ lock is taken */
end_comment

begin_function
specifier|static
name|void
name|__ecore_spq_return_entry
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
parameter_list|)
block|{
name|OSAL_LIST_PUSH_TAIL
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_hwfn
operator|->
name|p_spq
operator|->
name|free_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_spq_return_entry
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
parameter_list|)
block|{
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|__ecore_spq_return_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|)
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief ecore_spq_add_entry - adds a new entry to the pending  *        list. Should be used while lock is being held.  *  * Addes an entry to the pending list is there is room (en empty  * element is available in the free_pool), or else places the  * entry in the unlimited_pending pool.  *  * @param p_hwfn  * @param p_ent  * @param priority  *  * @return enum _ecore_status_t  */
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_spq_add_entry
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
parameter_list|,
name|enum
name|spq_priority
name|priority
parameter_list|)
block|{
name|struct
name|ecore_spq
modifier|*
name|p_spq
init|=
name|p_hwfn
operator|->
name|p_spq
decl_stmt|;
if|if
condition|(
name|p_ent
operator|->
name|queue
operator|==
operator|&
name|p_spq
operator|->
name|unlimited_pending
condition|)
block|{
if|if
condition|(
name|OSAL_LIST_IS_EMPTY
argument_list|(
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|)
condition|)
block|{
name|OSAL_LIST_PUSH_TAIL
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|unlimited_pending
argument_list|)
expr_stmt|;
name|p_spq
operator|->
name|unlimited_pending_count
operator|++
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
else|else
block|{
name|struct
name|ecore_spq_entry
modifier|*
name|p_en2
decl_stmt|;
name|p_en2
operator|=
name|OSAL_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|,
expr|struct
name|ecore_spq_entry
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|OSAL_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|p_en2
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|)
expr_stmt|;
comment|/* Copy the ring element physical pointer to the new 			 * entry, since we are about to override the entire ring 			 * entry and don't want to lose the pointer. 			 */
name|p_ent
operator|->
name|elem
operator|.
name|data_ptr
operator|=
name|p_en2
operator|->
name|elem
operator|.
name|data_ptr
expr_stmt|;
operator|*
name|p_en2
operator|=
operator|*
name|p_ent
expr_stmt|;
comment|/* EBLOCK responsible to free the allocated p_ent */
if|if
condition|(
name|p_ent
operator|->
name|comp_mode
operator|!=
name|ECORE_SPQ_MODE_EBLOCK
condition|)
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_ent
argument_list|)
expr_stmt|;
name|p_ent
operator|=
name|p_en2
expr_stmt|;
block|}
block|}
comment|/* entry is to be placed in 'pending' queue */
switch|switch
condition|(
name|priority
condition|)
block|{
case|case
name|ECORE_SPQ_PRIORITY_NORMAL
case|:
name|OSAL_LIST_PUSH_TAIL
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|pending
argument_list|)
expr_stmt|;
name|p_spq
operator|->
name|normal_count
operator|++
expr_stmt|;
break|break;
case|case
name|ECORE_SPQ_PRIORITY_HIGH
case|:
name|OSAL_LIST_PUSH_HEAD
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|pending
argument_list|)
expr_stmt|;
name|p_spq
operator|->
name|high_count
operator|++
expr_stmt|;
break|break;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * Accessor  ***************************************************************************/
end_comment

begin_function
name|u32
name|ecore_spq_get_cid
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_spq
condition|)
block|{
return|return
literal|0xffffffff
return|;
comment|/* illegal */
block|}
return|return
name|p_hwfn
operator|->
name|p_spq
operator|->
name|cid
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * Posting new Ramrods  ***************************************************************************/
end_comment

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_spq_post_list
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|osal_list_t
modifier|*
name|head
parameter_list|,
name|u32
name|keep_reserve
parameter_list|)
block|{
name|struct
name|ecore_spq
modifier|*
name|p_spq
init|=
name|p_hwfn
operator|->
name|p_spq
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
comment|/* TODO - implementation might be wasteful; will always keep room 	 * for an additional high priority ramrod (even if one is already 	 * pending FW) 	 */
while|while
condition|(
name|ecore_chain_get_elem_left
argument_list|(
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
operator|>
name|keep_reserve
operator|&&
operator|!
name|OSAL_LIST_IS_EMPTY
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
init|=
name|OSAL_LIST_FIRST_ENTRY
argument_list|(
name|head
argument_list|,
expr|struct
name|ecore_spq_entry
argument_list|,
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_ent
operator|!=
name|OSAL_NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_NTDDK_
argument_list|)
pragma|#
directive|pragma
name|warning
name|(
name|suppress
name|:
name|6011
name|28182
name|)
endif|#
directive|endif
name|OSAL_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|OSAL_LIST_PUSH_TAIL
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|completion_pending
argument_list|)
expr_stmt|;
name|p_spq
operator|->
name|comp_sent_count
operator|++
expr_stmt|;
name|rc
operator|=
name|ecore_spq_hw_post
argument_list|(
name|p_hwfn
argument_list|,
name|p_spq
argument_list|,
name|p_ent
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|OSAL_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|completion_pending
argument_list|)
expr_stmt|;
name|__ecore_spq_return_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|_ecore_status_t
name|ecore_spq_pend_post
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_spq
modifier|*
name|p_spq
init|=
name|p_hwfn
operator|->
name|p_spq
decl_stmt|;
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
init|=
name|OSAL_NULL
decl_stmt|;
while|while
condition|(
operator|!
name|OSAL_LIST_IS_EMPTY
argument_list|(
operator|&
name|p_spq
operator|->
name|free_pool
argument_list|)
condition|)
block|{
if|if
condition|(
name|OSAL_LIST_IS_EMPTY
argument_list|(
operator|&
name|p_spq
operator|->
name|unlimited_pending
argument_list|)
condition|)
break|break;
name|p_ent
operator|=
name|OSAL_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|p_spq
operator|->
name|unlimited_pending
argument_list|,
expr|struct
name|ecore_spq_entry
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ent
condition|)
return|return
name|ECORE_INVAL
return|;
if|#
directive|if
name|defined
argument_list|(
name|_NTDDK_
argument_list|)
pragma|#
directive|pragma
name|warning
name|(
name|suppress
name|:
name|6011
name|)
endif|#
directive|endif
name|OSAL_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|unlimited_pending
argument_list|)
expr_stmt|;
name|ecore_spq_add_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|,
name|p_ent
operator|->
name|priority
argument_list|)
expr_stmt|;
block|}
return|return
name|ecore_spq_post_list
argument_list|(
name|p_hwfn
argument_list|,
operator|&
name|p_spq
operator|->
name|pending
argument_list|,
name|SPQ_HIGH_PRI_RESERVE_DEFAULT
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_spq_post
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
parameter_list|,
name|u8
modifier|*
name|fw_return_code
parameter_list|)
block|{
name|enum
name|_ecore_status_t
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|struct
name|ecore_spq
modifier|*
name|p_spq
init|=
name|p_hwfn
condition|?
name|p_hwfn
operator|->
name|p_spq
else|:
name|OSAL_NULL
decl_stmt|;
name|bool
name|b_ret_ent
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
condition|)
return|return
name|ECORE_INVAL
return|;
if|if
condition|(
operator|!
name|p_ent
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Got a NULL pointer\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|p_hwfn
operator|->
name|p_dev
operator|->
name|recov_in_prog
condition|)
block|{
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SPQ
argument_list|,
literal|"Recovery is in progress -> skip spq post [cmd %02x protocol %02x]\n"
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|cmd_id
argument_list|,
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|protocol_id
argument_list|)
expr_stmt|;
comment|/* Return success to let the flows to be completed successfully 		 * w/o any error handling. 		 */
return|return
name|ECORE_SUCCESS
return|;
block|}
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Complete the entry */
name|rc
operator|=
name|ecore_spq_fill_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|)
expr_stmt|;
comment|/* Check return value after LOCK is taken for cleaner error flow */
if|if
condition|(
name|rc
condition|)
goto|goto
name|spq_post_fail
goto|;
comment|/* Add the request to the pending queue */
name|rc
operator|=
name|ecore_spq_add_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|,
name|p_ent
operator|->
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|spq_post_fail
goto|;
name|rc
operator|=
name|ecore_spq_pend_post
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* Since it's possible that pending failed for a different 		 * entry [although unlikely], the failed entry was already 		 * dealt with; No need to return it here. 		 */
name|b_ret_ent
operator|=
name|false
expr_stmt|;
goto|goto
name|spq_post_fail
goto|;
block|}
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ent
operator|->
name|comp_mode
operator|==
name|ECORE_SPQ_MODE_EBLOCK
condition|)
block|{
comment|/* For entries in ECORE BLOCK mode, the completion code cannot 		 * perform the necessary cleanup - if it did, we couldn't 		 * access p_ent here to see whether it's successful or not. 		 * Thus, after gaining the answer - perform the cleanup here. 		 */
name|rc
operator|=
name|ecore_spq_block
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|,
name|fw_return_code
argument_list|,
name|p_ent
operator|->
name|queue
operator|==
operator|&
name|p_spq
operator|->
name|unlimited_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ent
operator|->
name|queue
operator|==
operator|&
name|p_spq
operator|->
name|unlimited_pending
condition|)
block|{
comment|/* This is an allocated p_ent which does not need to 			 * return to pool. 			 */
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_ent
argument_list|)
expr_stmt|;
comment|/* TBD: handle error flow and remove p_ent from 			 * completion pending 			 */
return|return
name|rc
return|;
block|}
if|if
condition|(
name|rc
condition|)
goto|goto
name|spq_post_fail2
goto|;
comment|/* return to pool */
name|ecore_spq_return_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
name|spq_post_fail2
label|:
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|completion_pending
argument_list|)
expr_stmt|;
name|ecore_chain_return_produced
argument_list|(
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
name|spq_post_fail
label|:
comment|/* return to the free pool */
if|if
condition|(
name|b_ret_ent
condition|)
name|__ecore_spq_return_entry
argument_list|(
name|p_hwfn
argument_list|,
name|p_ent
argument_list|)
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_spq_completion
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|,
name|__le16
name|echo
parameter_list|,
name|u8
name|fw_return_code
parameter_list|,
name|union
name|event_ring_data
modifier|*
name|p_data
parameter_list|)
block|{
name|struct
name|ecore_spq
modifier|*
name|p_spq
decl_stmt|;
name|struct
name|ecore_spq_entry
modifier|*
name|p_ent
init|=
name|OSAL_NULL
decl_stmt|;
name|struct
name|ecore_spq_entry
modifier|*
name|tmp
decl_stmt|;
name|struct
name|ecore_spq_entry
modifier|*
name|found
init|=
name|OSAL_NULL
decl_stmt|;
name|enum
name|_ecore_status_t
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|p_hwfn
condition|)
block|{
return|return
name|ECORE_INVAL
return|;
block|}
name|p_spq
operator|=
name|p_hwfn
operator|->
name|p_spq
expr_stmt|;
if|if
condition|(
operator|!
name|p_spq
condition|)
block|{
return|return
name|ECORE_INVAL
return|;
block|}
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSAL_LIST_FOR_EACH_ENTRY_SAFE
argument_list|(
argument|p_ent
argument_list|,
argument|tmp
argument_list|,
argument|&p_spq->completion_pending
argument_list|,
argument|list
argument_list|,
argument|struct ecore_spq_entry
argument_list|)
block|{
if|if
condition|(
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|echo
operator|==
name|echo
condition|)
block|{
name|OSAL_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|p_ent
operator|->
name|list
argument_list|,
operator|&
name|p_spq
operator|->
name|completion_pending
argument_list|)
expr_stmt|;
comment|/* Avoid overriding of SPQ entries when getting 			 * out-of-order completions, by marking the completions 			 * in a bitmap and increasing the chain consumer only 			 * for the first successive completed entries. 			 */
name|SPQ_COMP_BMAP_SET_BIT
argument_list|(
name|p_spq
argument_list|,
name|echo
argument_list|)
expr_stmt|;
while|while
condition|(
name|SPQ_COMP_BMAP_TEST_BIT
argument_list|(
name|p_spq
argument_list|,
name|p_spq
operator|->
name|comp_bitmap_idx
argument_list|)
condition|)
block|{
name|SPQ_COMP_BMAP_CLEAR_BIT
argument_list|(
name|p_spq
argument_list|,
name|p_spq
operator|->
name|comp_bitmap_idx
argument_list|)
expr_stmt|;
name|p_spq
operator|->
name|comp_bitmap_idx
operator|++
expr_stmt|;
name|ecore_chain_return_produced
argument_list|(
operator|&
name|p_spq
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
name|p_spq
operator|->
name|comp_count
operator|++
expr_stmt|;
name|found
operator|=
name|p_ent
expr_stmt|;
break|break;
block|}
comment|/* This is debug and should be relatively uncommon - depends 		 * on scenarios which have mutliple per-PF sent ramrods. 		 */
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SPQ
argument_list|,
literal|"Got completion for echo %04x - doesn't match echo %04x in completion pending list\n"
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|echo
argument_list|)
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|p_ent
operator|->
name|elem
operator|.
name|hdr
operator|.
name|echo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Release lock before callback, as callback may post 	 * an additional ramrod. 	 */
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to find an entry this EQE [echo %04x] completes\n"
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|echo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_EXISTS
return|;
block|}
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SPQ
argument_list|,
literal|"Complete EQE [echo %04x]: func %p cookie %p)\n"
argument_list|,
name|OSAL_LE16_TO_CPU
argument_list|(
name|echo
argument_list|)
argument_list|,
name|p_ent
operator|->
name|comp_cb
operator|.
name|function
argument_list|,
name|p_ent
operator|->
name|comp_cb
operator|.
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|->
name|comp_cb
operator|.
name|function
condition|)
name|found
operator|->
name|comp_cb
operator|.
name|function
argument_list|(
name|p_hwfn
argument_list|,
name|found
operator|->
name|comp_cb
operator|.
name|cookie
argument_list|,
name|p_data
argument_list|,
name|fw_return_code
argument_list|)
expr_stmt|;
else|else
name|DP_VERBOSE
argument_list|(
name|p_hwfn
argument_list|,
name|ECORE_MSG_SPQ
argument_list|,
literal|"Got a completion without a callback function\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|found
operator|->
name|comp_mode
operator|!=
name|ECORE_SPQ_MODE_EBLOCK
operator|)
operator|||
operator|(
name|found
operator|->
name|queue
operator|==
operator|&
name|p_spq
operator|->
name|unlimited_pending
operator|)
condition|)
comment|/* EBLOCK  is responsible for returning its own entry into the 		 * free list, unless it originally added the entry into the 		 * unlimited pending list. 		 */
name|ecore_spq_return_entry
argument_list|(
name|p_hwfn
argument_list|,
name|found
argument_list|)
expr_stmt|;
comment|/* Attempt to post pending requests */
name|OSAL_SPIN_LOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_spq_pend_post
argument_list|(
name|p_hwfn
argument_list|)
expr_stmt|;
name|OSAL_SPIN_UNLOCK
argument_list|(
operator|&
name|p_spq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|enum
name|_ecore_status_t
name|ecore_consq_alloc
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|struct
name|ecore_consq
modifier|*
name|p_consq
decl_stmt|;
comment|/* Allocate ConsQ struct */
name|p_consq
operator|=
name|OSAL_ZALLOC
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|GFP_KERNEL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_consq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_consq
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate `struct ecore_consq'\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
comment|/* Allocate and initialize EQ chain*/
if|if
condition|(
name|ecore_chain_alloc
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|ECORE_CHAIN_USE_TO_PRODUCE
argument_list|,
name|ECORE_CHAIN_MODE_PBL
argument_list|,
name|ECORE_CHAIN_CNT_TYPE_U16
argument_list|,
name|ECORE_CHAIN_PAGE_SIZE
operator|/
literal|0x80
argument_list|,
literal|0x80
argument_list|,
operator|&
name|p_consq
operator|->
name|chain
argument_list|,
name|OSAL_NULL
argument_list|)
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|DP_NOTICE
argument_list|(
name|p_hwfn
argument_list|,
name|true
argument_list|,
literal|"Failed to allocate consq chain"
argument_list|)
expr_stmt|;
goto|goto
name|consq_allocate_fail
goto|;
block|}
name|p_hwfn
operator|->
name|p_consq
operator|=
name|p_consq
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
name|consq_allocate_fail
label|:
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_consq
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
end_function

begin_function
name|void
name|ecore_consq_setup
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
name|ecore_chain_reset
argument_list|(
operator|&
name|p_hwfn
operator|->
name|p_consq
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_consq_free
parameter_list|(
name|struct
name|ecore_hwfn
modifier|*
name|p_hwfn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hwfn
operator|->
name|p_consq
condition|)
return|return;
name|ecore_chain_free
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
operator|&
name|p_hwfn
operator|->
name|p_consq
operator|->
name|chain
argument_list|)
expr_stmt|;
name|OSAL_FREE
argument_list|(
name|p_hwfn
operator|->
name|p_dev
argument_list|,
name|p_hwfn
operator|->
name|p_consq
argument_list|)
expr_stmt|;
name|p_hwfn
operator|->
name|p_consq
operator|=
name|OSAL_NULL
expr_stmt|;
block|}
end_function

end_unit

