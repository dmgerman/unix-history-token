begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Adaptec Inc.  * All rights reserved.  *  * Written by: David Jeffery  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/ips/ipsreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ips/ips.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_function_decl
specifier|static
name|int
name|ips_pci_free
parameter_list|(
name|ips_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ips_intrhook
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ips_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_VENDOR_ID
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_MORPHEUS_DEVICE_ID
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"IBM ServeRAID Adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_VENDOR_ID
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_COPPERHEAD_DEVICE_ID
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"IBM ServeRAID Adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_VENDOR_ID_ADAPTEC
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_MARCO_DEVICE_ID
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Adaptec ServeRAID Adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ips_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|command
decl_stmt|;
name|ips_softc_t
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"device is disabled\n"
argument_list|)
expr_stmt|;
comment|/* but return 0 so the !$)$)*!$*) unit isn't reused */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DEVICE_PRINTF
argument_list|(
literal|1
argument_list|,
name|dev
argument_list|,
literal|"in attach.\n"
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
name|ips_softc_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
block|{
name|printf
argument_list|(
literal|"how is sc NULL?!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|ips_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_MORPHEUS_DEVICE_ID
condition|)
block|{
name|sc
operator|->
name|ips_adapter_reinit
operator|=
name|ips_morpheus_reinit
expr_stmt|;
name|sc
operator|->
name|ips_adapter_intr
operator|=
name|ips_morpheus_intr
expr_stmt|;
name|sc
operator|->
name|ips_issue_cmd
operator|=
name|ips_issue_morpheus_cmd
expr_stmt|;
name|sc
operator|->
name|ips_poll_cmd
operator|=
name|ips_morpheus_poll
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_COPPERHEAD_DEVICE_ID
condition|)
block|{
name|sc
operator|->
name|ips_adapter_reinit
operator|=
name|ips_copperhead_reinit
expr_stmt|;
name|sc
operator|->
name|ips_adapter_intr
operator|=
name|ips_copperhead_intr
expr_stmt|;
name|sc
operator|->
name|ips_issue_cmd
operator|=
name|ips_issue_copperhead_cmd
expr_stmt|;
name|sc
operator|->
name|ips_poll_cmd
operator|=
name|ips_copperhead_poll
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_MARCO_DEVICE_ID
condition|)
block|{
name|sc
operator|->
name|ips_adapter_reinit
operator|=
name|ips_morpheus_reinit
expr_stmt|;
name|sc
operator|->
name|ips_adapter_intr
operator|=
name|ips_morpheus_intr
expr_stmt|;
name|sc
operator|->
name|ips_issue_cmd
operator|=
name|ips_issue_morpheus_cmd
expr_stmt|;
name|sc
operator|->
name|ips_poll_cmd
operator|=
name|ips_morpheus_poll
expr_stmt|;
block|}
else|else
goto|goto
name|error
goto|;
comment|/* make sure busmastering is on */
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|command
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* seting up io space */
name|sc
operator|->
name|iores
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|PCIM_CMD_MEMEN
condition|)
block|{
name|PRINTF
argument_list|(
literal|10
argument_list|,
literal|"trying MEMIO\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|IPS_COPPERHEAD_DEVICE_ID
condition|)
name|sc
operator|->
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iotype
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|sc
operator|->
name|iores
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|iotype
argument_list|,
operator|&
name|sc
operator|->
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|iores
operator|&&
name|command
operator|&
name|PCIM_CMD_PORTEN
condition|)
block|{
name|PRINTF
argument_list|(
literal|10
argument_list|,
literal|"trying PORTIO\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iotype
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|iores
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|iotype
argument_list|,
operator|&
name|sc
operator|->
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|iores
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"resource allocation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|bustag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|iores
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bushandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|iores
argument_list|)
expr_stmt|;
comment|/*allocate an interrupt. when does the irq become active? after leaving attach? */
name|sc
operator|->
name|irqrid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|irqres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqrid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"irq allocation failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|ips_adapter_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irqcookie
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"irq setup failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent    */
name|NULL
argument_list|,
comment|/* alignemnt */
literal|1
argument_list|,
comment|/* boundary  */
literal|0
argument_list|,
comment|/* lowaddr   */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* highaddr  */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter    */
name|NULL
argument_list|,
comment|/* filterarg */
name|NULL
argument_list|,
comment|/* maxsize   */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* numsegs   */
name|IPS_MAX_SG_ELEMENTS
argument_list|,
comment|/* maxsegsize*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags     */
literal|0
argument_list|,
comment|/* lockfunc  */
name|NULL
argument_list|,
comment|/* lockarg   */
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|adapter_dmatag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"IPS can't alloc dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sc
operator|->
name|ips_ich
operator|.
name|ich_func
operator|=
name|ips_intrhook
expr_stmt|;
name|sc
operator|->
name|ips_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|queue_mtx
argument_list|,
literal|"IPS bioqueue lock"
argument_list|,
name|MTX_DEF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|sc
operator|->
name|cmd_sema
argument_list|,
literal|0
argument_list|,
literal|"IPS Command Semaphore"
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|ips_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"IPS can't establish configuration hook\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
literal|0
return|;
name|error
label|:
name|ips_pci_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ips_intrhook
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ips_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ips_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|ips_ich
argument_list|)
expr_stmt|;
if|if
condition|(
name|ips_adapter_init
argument_list|(
name|sc
argument_list|)
condition|)
name|ips_pci_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|configured
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ips_pci_free
parameter_list|(
name|ips_softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|adapter_dmatag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|adapter_dmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqcookie
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|sc
operator|->
name|irqcookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqres
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqrid
argument_list|,
name|sc
operator|->
name|irqres
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|iores
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|iotype
argument_list|,
name|sc
operator|->
name|rid
argument_list|,
name|sc
operator|->
name|iores
argument_list|)
expr_stmt|;
name|sc
operator|->
name|configured
operator|=
literal|0
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|queue_mtx
argument_list|)
expr_stmt|;
name|sema_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cmd_sema
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ips_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ips_softc_t
modifier|*
name|sc
decl_stmt|;
name|DEVICE_PRINTF
argument_list|(
literal|1
argument_list|,
name|dev
argument_list|,
literal|"detaching ServeRaid\n"
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
name|ips_softc_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|configured
condition|)
block|{
name|sc
operator|->
name|configured
operator|=
literal|0
expr_stmt|;
name|ips_flush_cache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ips_adapter_free
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
name|ips_pci_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bioq_flush
argument_list|(
operator|&
name|sc
operator|->
name|queue
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ips_pci_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ips_softc_t
modifier|*
name|sc
init|=
operator|(
name|ips_softc_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|configured
condition|)
block|{
name|ips_flush_cache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ips_driver_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ips_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ips_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ips_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ips_pci_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ips_pci_driver
init|=
block|{
literal|"ips"
block|,
name|ips_driver_methods
block|,
sizeof|sizeof
argument_list|(
name|ips_softc_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ips_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ips
argument_list|,
name|pci
argument_list|,
name|ips_pci_driver
argument_list|,
name|ips_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

