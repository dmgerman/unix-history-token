begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000-2015 Mark R V Murray  * Copyright (c) 2013 Arthur Mesh  * Copyright (c) 2004 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|RANDOM_LOADABLE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/randomdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/random_harvestq.h>
end_include

begin_function_decl
specifier|static
name|void
name|random_kthread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|random_sources_feed
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_int
name|read_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List for the dynamic sysctls */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sysctl_ctx_list
name|random_clist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * How many events to queue up. We create this many items in  * an 'empty' queue, then transfer them to the 'harvest' queue with  * supplied junk. When used, they are transferred back to the  * 'empty' queue.  */
end_comment

begin_define
define|#
directive|define
name|RANDOM_RING_MAX
value|1024
end_define

begin_define
define|#
directive|define
name|RANDOM_ACCUM_MAX
value|8
end_define

begin_comment
comment|/* 1 to let the kernel thread run, 0 to terminate, -1 to mark completion */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|random_kthread_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Put all the harvest queue context stuff in one place.  * this make is a bit easier to lock and protect.  */
end_comment

begin_struct
specifier|static
struct|struct
name|harvest_context
block|{
comment|/* The harvest mutex protects all of harvest_context and 	 * the related data. 	 */
name|struct
name|mtx
name|hc_mtx
decl_stmt|;
comment|/* Round-robin destination cache. */
name|u_int
name|hc_destination
index|[
name|ENTROPYSOURCE
index|]
decl_stmt|;
comment|/* The context of the kernel thread processing harvested entropy */
name|struct
name|proc
modifier|*
name|hc_kthread_proc
decl_stmt|;
comment|/* Allow the sysadmin to select the broad category of 	 * entropy types to harvest. 	 */
name|u_int
name|hc_source_mask
decl_stmt|;
comment|/* 	 * Lockless ring buffer holding entropy events 	 * If ring.in == ring.out, 	 *     the buffer is empty. 	 * If ring.in != ring.out, 	 *     the buffer contains harvested entropy. 	 * If (ring.in + 1) == ring.out (mod RANDOM_RING_MAX), 	 *     the buffer is full. 	 * 	 * NOTE: ring.in points to the last added element, 	 * and ring.out points to the last consumed element. 	 * 	 * The ring.in variable needs locking as there are multiple 	 * sources to the ring. Only the sources may change ring.in, 	 * but the consumer may examine it. 	 * 	 * The ring.out variable does not need locking as there is 	 * only one consumer. Only the consumer may change ring.out, 	 * but the sources may examine it. 	 */
struct|struct
name|entropy_ring
block|{
name|struct
name|harvest_event
name|ring
index|[
name|RANDOM_RING_MAX
index|]
decl_stmt|;
specifier|volatile
name|u_int
name|in
decl_stmt|;
specifier|volatile
name|u_int
name|out
decl_stmt|;
block|}
name|hc_entropy_ring
struct|;
struct|struct
name|fast_entropy_accumulator
block|{
specifier|volatile
name|u_int
name|pos
decl_stmt|;
name|uint32_t
name|buf
index|[
name|RANDOM_ACCUM_MAX
index|]
decl_stmt|;
block|}
name|hc_entropy_fast_accumulator
struct|;
block|}
name|harvest_context
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|random_proc_kp
init|=
block|{
literal|"rand_harvestq"
block|,
name|random_kthread
block|,
operator|&
name|harvest_context
operator|.
name|hc_kthread_proc
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pass the given event straight through to Fortuna/Yarrow/Whatever. */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|random_harvestq_fast_process_event
parameter_list|(
name|struct
name|harvest_event
modifier|*
name|event
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|RANDOM_LOADABLE
argument_list|)
name|RANDOM_CONFIG_S_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_random_alg_context
condition|)
endif|#
directive|endif
name|p_random_alg_context
operator|->
name|ra_event_processor
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RANDOM_LOADABLE
argument_list|)
name|RANDOM_CONFIG_S_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|random_kthread
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|maxloop
decl_stmt|,
name|ring_out
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Locking is not needed as this is the only place we modify ring.out, and 	 * we only examine ring.in without changing it. Both of these are volatile, 	 * and this is a unique thread. 	 */
for|for
control|(
name|random_kthread_control
operator|=
literal|1
init|;
name|random_kthread_control
condition|;
control|)
block|{
comment|/* Deal with events, if any. Restrict the number we do in one go. */
name|maxloop
operator|=
name|RANDOM_RING_MAX
expr_stmt|;
while|while
condition|(
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|out
operator|!=
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|in
condition|)
block|{
name|ring_out
operator|=
operator|(
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|out
operator|+
literal|1
operator|)
operator|%
name|RANDOM_RING_MAX
expr_stmt|;
name|random_harvestq_fast_process_event
argument_list|(
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|ring
operator|+
name|ring_out
argument_list|)
expr_stmt|;
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|out
operator|=
name|ring_out
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|maxloop
condition|)
break|break;
block|}
name|random_sources_feed
argument_list|()
expr_stmt|;
comment|/* XXX: FIX!! Increase the high-performance data rate? Need some measurements first. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RANDOM_ACCUM_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|harvest_context
operator|.
name|hc_entropy_fast_accumulator
operator|.
name|buf
index|[
name|i
index|]
condition|)
block|{
name|random_harvest_direct
argument_list|(
name|harvest_context
operator|.
name|hc_entropy_fast_accumulator
operator|.
name|buf
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|harvest_context
operator|.
name|hc_entropy_fast_accumulator
operator|.
name|buf
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|4
argument_list|,
name|RANDOM_UMA
argument_list|)
expr_stmt|;
name|harvest_context
operator|.
name|hc_entropy_fast_accumulator
operator|.
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* XXX: FIX!! This is a *great* place to pass hardware/live entropy to random(9) */
name|tsleep_sbt
argument_list|(
operator|&
name|harvest_context
operator|.
name|hc_kthread_proc
argument_list|,
literal|0
argument_list|,
literal|"-"
argument_list|,
name|SBT_1S
operator|/
literal|10
argument_list|,
literal|0
argument_list|,
name|C_PREL
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|random_kthread_control
operator|=
operator|-
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|harvest_context
operator|.
name|hc_kthread_proc
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* This happens well after SI_SUB_RANDOM */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|random_device_h_proc
argument_list|,
name|SI_SUB_KICK_SCHEDULER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|kproc_start
argument_list|,
operator|&
name|random_proc_kp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Run through all fast sources reading entropy for the given  * number of rounds, which should be a multiple of the number  * of entropy accumulation pools in use; 2 for Yarrow and 32  * for Fortuna.  */
end_comment

begin_function
specifier|static
name|void
name|random_sources_feed
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|entropy
index|[
name|HARVESTSIZE
index|]
decl_stmt|;
name|struct
name|random_sources
modifier|*
name|rrs
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|local_read_rate
decl_stmt|;
comment|/* 	 * Step over all of live entropy sources, and feed their output 	 * to the system-wide RNG. 	 */
if|#
directive|if
name|defined
argument_list|(
name|RANDOM_LOADABLE
argument_list|)
name|RANDOM_CONFIG_S_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_random_alg_context
condition|)
block|{
comment|/* It's an indenting error. Yeah, Yeah. */
endif|#
directive|endif
name|local_read_rate
operator|=
name|atomic_readandclear_32
argument_list|(
operator|&
name|read_rate
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rrs
argument_list|,
argument|&source_list
argument_list|,
argument|rrs_entries
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_random_alg_context
operator|->
name|ra_poolcount
operator|*
operator|(
name|local_read_rate
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|rrs
operator|->
name|rrs_source
operator|->
name|rs_read
argument_list|(
name|entropy
argument_list|,
sizeof|sizeof
argument_list|(
name|entropy
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|n
operator|<=
sizeof|sizeof
argument_list|(
name|entropy
argument_list|)
operator|)
argument_list|,
operator|(
literal|"%s: rs_read returned too much data (%u> %zu)"
operator|,
name|__func__
operator|,
name|n
operator|,
sizeof|sizeof
argument_list|(
name|entropy
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* It would appear that in some circumstances (e.g. virtualisation), 			 * the underlying hardware entropy source might not always return 			 * random numbers. Accept this but make a noise. If too much happens, 			 * can that source be trusted? 			 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: rs_read for hardware device '%s' returned no entropy.\n"
argument_list|,
name|__func__
argument_list|,
name|rrs
operator|->
name|rrs_source
operator|->
name|rs_ident
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|random_harvest_direct
argument_list|(
name|entropy
argument_list|,
name|n
argument_list|,
operator|(
name|n
operator|*
literal|8
operator|)
operator|/
literal|2
argument_list|,
name|rrs
operator|->
name|rrs_source
operator|->
name|rs_source
argument_list|)
expr_stmt|;
block|}
block|}
name|explicit_bzero
argument_list|(
name|entropy
argument_list|,
sizeof|sizeof
argument_list|(
name|entropy
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RANDOM_LOADABLE
argument_list|)
block|}
name|RANDOM_CONFIG_S_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|read_rate_increment
parameter_list|(
name|u_int
name|chunk
parameter_list|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|read_rate
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|RANDOM_CHECK_UINT
argument_list|(
name|harvestmask
argument_list|,
literal|0
argument_list|,
name|RANDOM_HARVEST_EVERYTHING_MASK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|random_print_harvestmask
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|RANDOM_ENVIRONMENTAL_END
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|(
name|harvest_context
operator|.
name|hc_source_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
specifier|const
name|char
operator|*
operator|(
name|random_source_descr
index|[]
operator|)
operator|=
block|{
literal|"CACHED"
block|,
literal|"ATTACH"
block|,
literal|"KEYBOARD"
block|,
literal|"MOUSE"
block|,
literal|"NET_TUN"
block|,
literal|"NET_ETHER"
block|,
literal|"NET_NG"
block|,
literal|"INTERRUPT"
block|,
literal|"SWI"
block|,
literal|"FS_ATIME"
block|,
literal|"UMA"
block|,
comment|/* ENVIRONMENTAL_END */
literal|"PURE_OCTEON"
block|,
literal|"PURE_SAFE"
block|,
literal|"PURE_GLXSB"
block|,
literal|"PURE_UBSEC"
block|,
literal|"PURE_HIFN"
block|,
literal|"PURE_RDRAND"
block|,
literal|"PURE_NEHEMIAH"
block|,
literal|"PURE_RNDTEST"
block|,
comment|/* "ENTROPYSOURCE" */
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|random_print_harvestmask_symbolic
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|RANDOM_ENVIRONMENTAL_END
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|(
name|i
operator|==
name|RANDOM_ENVIRONMENTAL_END
operator|)
condition|?
literal|""
else|:
literal|","
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|!
operator|(
name|harvest_context
operator|.
name|hc_source_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|"["
else|:
literal|""
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
name|random_source_descr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|!
operator|(
name|harvest_context
operator|.
name|hc_source_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|"]"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|random_harvestq_init
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|random_sys_o
decl_stmt|;
name|random_sys_o
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|random_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_kern_random
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"harvest"
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Entropy Device Parameters"
argument_list|)
expr_stmt|;
name|harvest_context
operator|.
name|hc_source_mask
operator|=
name|RANDOM_HARVEST_EVERYTHING_MASK
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|random_clist
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|random_sys_o
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mask"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|harvest_context
operator|.
name|hc_source_mask
argument_list|,
literal|0
argument_list|,
name|random_check_uint_harvestmask
argument_list|,
literal|"IU"
argument_list|,
literal|"Entropy harvesting mask"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|random_clist
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|random_sys_o
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mask_bin"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|random_print_harvestmask
argument_list|,
literal|"A"
argument_list|,
literal|"Entropy harvesting mask (printable)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|random_clist
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|random_sys_o
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mask_symbolic"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|random_print_harvestmask_symbolic
argument_list|,
literal|"A"
argument_list|,
literal|"Entropy harvesting mask (symbolic)"
argument_list|)
expr_stmt|;
name|RANDOM_HARVEST_INIT_LOCK
argument_list|()
expr_stmt|;
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|in
operator|=
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|out
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|random_device_h_init
argument_list|,
name|SI_SUB_RANDOM
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|random_harvestq_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This is used to prime the RNG by grabbing any early random stuff  * known to the kernel, and inserting it directly into the hashing  * module, e.g. Fortuna or Yarrow.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|random_harvestq_prime
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|struct
name|harvest_event
name|event
decl_stmt|;
name|size_t
name|count
decl_stmt|,
name|size
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|keyfile
decl_stmt|,
modifier|*
name|data
decl_stmt|;
comment|/* 	 * Get entropy that may have been preloaded by loader(8) 	 * and use it to pre-charge the entropy harvest queue. 	 */
name|keyfile
operator|=
name|preload_search_by_type
argument_list|(
name|RANDOM_CACHED_BOOT_ENTROPY_MODULE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BACKWARD_COMPATIBILITY
if|if
condition|(
name|keyfile
operator|==
name|NULL
condition|)
name|keyfile
operator|=
name|preload_search_by_type
argument_list|(
name|RANDOM_LEGACY_BOOT_ENTROPY_MODULE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keyfile
operator|!=
name|NULL
condition|)
block|{
name|data
operator|=
name|preload_fetch_addr
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
name|size
operator|=
name|preload_fetch_size
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
comment|/* skip the first bit of the stash so others like arc4 can also have some. */
if|if
condition|(
name|size
operator|>
name|RANDOM_CACHED_SKIP_START
condition|)
block|{
name|data
operator|+=
name|RANDOM_CACHED_SKIP_START
expr_stmt|;
name|size
operator|-=
name|RANDOM_CACHED_SKIP_START
expr_stmt|;
block|}
comment|/* Trim the size. If the admin has a file with a funny size, we lose some. Tough. */
name|size
operator|-=
operator|(
name|size
operator|%
sizeof|sizeof
argument_list|(
name|event
operator|.
name|he_entropy
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|event
operator|.
name|he_entropy
argument_list|)
control|)
block|{
name|count
operator|=
sizeof|sizeof
argument_list|(
name|event
operator|.
name|he_entropy
argument_list|)
expr_stmt|;
name|event
operator|.
name|he_somecounter
operator|=
operator|(
name|uint32_t
operator|)
name|get_cyclecount
argument_list|()
expr_stmt|;
name|event
operator|.
name|he_size
operator|=
name|count
expr_stmt|;
name|event
operator|.
name|he_bits
operator|=
name|count
operator|/
literal|4
expr_stmt|;
comment|/* Underestimate the size for Yarrow */
name|event
operator|.
name|he_source
operator|=
name|RANDOM_CACHED
expr_stmt|;
name|event
operator|.
name|he_destination
operator|=
name|harvest_context
operator|.
name|hc_destination
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|event
operator|.
name|he_entropy
argument_list|,
name|data
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|event
operator|.
name|he_entropy
argument_list|)
argument_list|)
expr_stmt|;
name|random_harvestq_fast_process_event
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
operator|&
name|event
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|explicit_bzero
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"random: read %zu bytes from preloaded cache\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"random: no preloaded entropy cache\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|random_device_prime
argument_list|,
name|SI_SUB_RANDOM
argument_list|,
name|SI_ORDER_FOURTH
argument_list|,
name|random_harvestq_prime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|random_harvestq_deinit
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
comment|/* Command the hash/reseed thread to end and wait for it to finish */
name|random_kthread_control
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|random_kthread_control
operator|>=
literal|0
condition|)
name|tsleep
argument_list|(
operator|&
name|harvest_context
operator|.
name|hc_kthread_proc
argument_list|,
literal|0
argument_list|,
literal|"harvqterm"
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|random_clist
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|random_device_h_init
argument_list|,
name|SI_SUB_RANDOM
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|random_harvestq_deinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Entropy harvesting queue routine.  *  * This is supposed to be fast; do not do anything slow in here!  * It is also illegal (and morally reprehensible) to insert any  * high-rate data here. "High-rate" is defined as a data source  * that will usually cause lots of failures of the "Lockless read"  * check a few lines below. This includes the "always-on" sources  * like the Intel "rdrand" or the VIA Nehamiah "xstore" sources.  */
end_comment

begin_comment
comment|/* XXXRW: get_cyclecount() is cheap on most modern hardware, where cycle  * counters are built in, but on older hardware it will do a real time clock  * read which can be quite expensive.  */
end_comment

begin_function
name|void
name|random_harvest_queue
parameter_list|(
specifier|const
name|void
modifier|*
name|entropy
parameter_list|,
name|u_int
name|size
parameter_list|,
name|u_int
name|bits
parameter_list|,
name|enum
name|random_entropy_source
name|origin
parameter_list|)
block|{
name|struct
name|harvest_event
modifier|*
name|event
decl_stmt|;
name|u_int
name|ring_in
decl_stmt|;
name|KASSERT
argument_list|(
name|origin
operator|>=
name|RANDOM_START
operator|&&
name|origin
operator|<
name|ENTROPYSOURCE
argument_list|,
operator|(
literal|"%s: origin %d invalid\n"
operator|,
name|__func__
operator|,
name|origin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|harvest_context
operator|.
name|hc_source_mask
operator|&
operator|(
literal|1
operator|<<
name|origin
operator|)
operator|)
condition|)
return|return;
name|RANDOM_HARVEST_LOCK
argument_list|()
expr_stmt|;
name|ring_in
operator|=
operator|(
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|in
operator|+
literal|1
operator|)
operator|%
name|RANDOM_RING_MAX
expr_stmt|;
if|if
condition|(
name|ring_in
operator|!=
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|out
condition|)
block|{
comment|/* The ring is not full */
name|event
operator|=
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|ring
operator|+
name|ring_in
expr_stmt|;
name|event
operator|->
name|he_somecounter
operator|=
operator|(
name|uint32_t
operator|)
name|get_cyclecount
argument_list|()
expr_stmt|;
name|event
operator|->
name|he_source
operator|=
name|origin
expr_stmt|;
name|event
operator|->
name|he_destination
operator|=
name|harvest_context
operator|.
name|hc_destination
index|[
name|origin
index|]
operator|++
expr_stmt|;
name|event
operator|->
name|he_bits
operator|=
name|bits
expr_stmt|;
if|if
condition|(
name|size
operator|<=
sizeof|sizeof
argument_list|(
name|event
operator|->
name|he_entropy
argument_list|)
condition|)
block|{
name|event
operator|->
name|he_size
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|event
operator|->
name|he_entropy
argument_list|,
name|entropy
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Big event, so squash it */
name|event
operator|->
name|he_size
operator|=
sizeof|sizeof
argument_list|(
name|event
operator|->
name|he_entropy
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|event
operator|->
name|he_entropy
index|[
literal|0
index|]
operator|=
name|jenkins_hash
argument_list|(
name|entropy
argument_list|,
name|size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
name|harvest_context
operator|.
name|hc_entropy_ring
operator|.
name|in
operator|=
name|ring_in
expr_stmt|;
block|}
name|RANDOM_HARVEST_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Entropy harvesting fast routine.  *  * This is supposed to be very fast; do not do anything slow in here!  * This is the right place for high-rate harvested data.  */
end_comment

begin_function
name|void
name|random_harvest_fast
parameter_list|(
specifier|const
name|void
modifier|*
name|entropy
parameter_list|,
name|u_int
name|size
parameter_list|,
name|u_int
name|bits
parameter_list|,
name|enum
name|random_entropy_source
name|origin
parameter_list|)
block|{
name|u_int
name|pos
decl_stmt|;
name|KASSERT
argument_list|(
name|origin
operator|>=
name|RANDOM_START
operator|&&
name|origin
operator|<
name|ENTROPYSOURCE
argument_list|,
operator|(
literal|"%s: origin %d invalid\n"
operator|,
name|__func__
operator|,
name|origin
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: FIX!! The above KASSERT is BS. Right now we ignore most structure and just accumulate the supplied data */
if|if
condition|(
operator|!
operator|(
name|harvest_context
operator|.
name|hc_source_mask
operator|&
operator|(
literal|1
operator|<<
name|origin
operator|)
operator|)
condition|)
return|return;
name|pos
operator|=
name|harvest_context
operator|.
name|hc_entropy_fast_accumulator
operator|.
name|pos
expr_stmt|;
name|harvest_context
operator|.
name|hc_entropy_fast_accumulator
operator|.
name|buf
index|[
name|pos
index|]
operator|^=
name|jenkins_hash
argument_list|(
name|entropy
argument_list|,
name|size
argument_list|,
operator|(
name|uint32_t
operator|)
name|get_cyclecount
argument_list|()
argument_list|)
expr_stmt|;
name|harvest_context
operator|.
name|hc_entropy_fast_accumulator
operator|.
name|pos
operator|=
operator|(
name|pos
operator|+
literal|1
operator|)
operator|%
name|RANDOM_ACCUM_MAX
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Entropy harvesting direct routine.  *  * This is not supposed to be fast, but will only be used during  * (e.g.) booting when initial entropy is being gathered.  */
end_comment

begin_function
name|void
name|random_harvest_direct
parameter_list|(
specifier|const
name|void
modifier|*
name|entropy
parameter_list|,
name|u_int
name|size
parameter_list|,
name|u_int
name|bits
parameter_list|,
name|enum
name|random_entropy_source
name|origin
parameter_list|)
block|{
name|struct
name|harvest_event
name|event
decl_stmt|;
name|KASSERT
argument_list|(
name|origin
operator|>=
name|RANDOM_START
operator|&&
name|origin
operator|<
name|ENTROPYSOURCE
argument_list|,
operator|(
literal|"%s: origin %d invalid\n"
operator|,
name|__func__
operator|,
name|origin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|harvest_context
operator|.
name|hc_source_mask
operator|&
operator|(
literal|1
operator|<<
name|origin
operator|)
operator|)
condition|)
return|return;
name|size
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|event
operator|.
name|he_entropy
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|he_somecounter
operator|=
operator|(
name|uint32_t
operator|)
name|get_cyclecount
argument_list|()
expr_stmt|;
name|event
operator|.
name|he_size
operator|=
name|size
expr_stmt|;
name|event
operator|.
name|he_bits
operator|=
name|bits
expr_stmt|;
name|event
operator|.
name|he_source
operator|=
name|origin
expr_stmt|;
name|event
operator|.
name|he_destination
operator|=
name|harvest_context
operator|.
name|hc_destination
index|[
name|origin
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|event
operator|.
name|he_entropy
argument_list|,
name|entropy
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|random_harvestq_fast_process_event
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
operator|&
name|event
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|random_harvestq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

