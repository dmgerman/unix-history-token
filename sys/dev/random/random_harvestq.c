begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000-2014 Mark R V Murray  * Copyright (c) 2013 Arthur Mesh  * Copyright (c) 2004 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_random.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/randomdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/random_adaptors.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/random_harvestq.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/live_entropy_sources.h>
end_include

begin_comment
comment|/* List for the dynamic sysctls */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sysctl_ctx_list
name|random_clist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * How many events to queue up. We create this many items in  * an 'empty' queue, then transfer them to the 'harvest' queue with  * supplied junk. When used, they are transferred back to the  * 'empty' queue.  */
end_comment

begin_define
define|#
directive|define
name|RANDOM_FIFO_MAX
value|1024
end_define

begin_comment
comment|/*  * The harvest mutex protects the consistency of the entropy Fifos and  * empty fifo and other associated structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|harvest_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Lockable FIFO ring buffer holding entropy events  * If ring_in == ring_out,  *     the buffer is empty.  * If (ring_in + 1) == ring_out (MOD RANDOM_FIFO_MAX),  *     the buffer is full.  *  * The ring_in variable needs locking as there are multiple  * sources to the ring. Only the sources may change ring_in,  * but the consumer may examine it.  *  * The ring_out variable does not need locking as there is  * only one consumer. Only the consumer may change ring_out,  * but the sources may examine it.  */
end_comment

begin_struct
specifier|static
struct|struct
name|entropyfifo
block|{
name|struct
name|harvest_event
name|ring
index|[
name|RANDOM_FIFO_MAX
index|]
decl_stmt|;
specifier|volatile
name|u_int
name|ring_in
decl_stmt|;
specifier|volatile
name|u_int
name|ring_out
decl_stmt|;
block|}
name|entropyfifo
struct|;
end_struct

begin_comment
comment|/* Round-robin destination cache. */
end_comment

begin_decl_stmt
name|u_int
name|harvest_destination
index|[
name|ENTROPYSOURCE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function called to process one harvested stochastic event */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|harvest_process_event
function_decl|)
parameter_list|(
name|struct
name|harvest_event
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Allow the sysadmin to select the broad category of  * entropy types to harvest.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|harvest_source_mask
init|=
operator|(
operator|(
literal|1U
operator|<<
name|RANDOM_ENVIRONMENTAL_END
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pool count is used by anything needing to know how many entropy  * pools are currently being maintained.  * This is of use to (e.g.) the live source feed where we need to give  * all the pools a top-up.  */
end_comment

begin_decl_stmt
name|int
name|harvest_pool_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<0 to end the kthread, 0 to let it run, 1 to flush the harvest queues */
end_comment

begin_decl_stmt
specifier|static
name|int
name|random_kthread_control
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|random_kthread_proc
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|random_kthread
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|u_int
name|maxloop
decl_stmt|,
name|ring_out
decl_stmt|;
comment|/* 	 * Process until told to stop. 	 * 	 * Locking is not needed as this is the only place we modify ring_out, and 	 * we only examine ring_in without changing it. Both of these are volatile, 	 * and this is a unique thread. 	 */
while|while
condition|(
name|random_kthread_control
operator|>=
literal|0
condition|)
block|{
comment|/* Deal with events, if any. Restrict the number we do in one go. */
name|maxloop
operator|=
name|RANDOM_FIFO_MAX
expr_stmt|;
while|while
condition|(
name|entropyfifo
operator|.
name|ring_out
operator|!=
name|entropyfifo
operator|.
name|ring_in
condition|)
block|{
name|ring_out
operator|=
operator|(
name|entropyfifo
operator|.
name|ring_out
operator|+
literal|1
operator|)
operator|%
name|RANDOM_FIFO_MAX
expr_stmt|;
name|harvest_process_event
argument_list|(
name|entropyfifo
operator|.
name|ring
operator|+
name|ring_out
argument_list|)
expr_stmt|;
comment|/* Modifying ring_out here ONLY. Sufficient for atomicity? */
name|entropyfifo
operator|.
name|ring_out
operator|=
name|ring_out
expr_stmt|;
comment|/* The ring may be filled quickly so don't loop forever.  */
if|if
condition|(
operator|--
name|maxloop
condition|)
break|break;
block|}
comment|/* 		 * Give the fast hardware sources a go 		 */
name|live_entropy_sources_feed
argument_list|()
expr_stmt|;
comment|/* 		 * If a queue flush was commanded, it has now happened, 		 * and we can mark this by resetting the command. 		 * A negative value, however, terminates the thread. 		 */
if|if
condition|(
name|random_kthread_control
operator|==
literal|1
condition|)
name|random_kthread_control
operator|=
literal|0
expr_stmt|;
comment|/* Some work is done, so give the rest of the OS a chance. */
name|tsleep_sbt
argument_list|(
operator|&
name|random_kthread_control
argument_list|,
literal|0
argument_list|,
literal|"-"
argument_list|,
name|SBT_1S
operator|/
literal|10
argument_list|,
literal|0
argument_list|,
name|C_PREL
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|randomdev_set_wakeup_exit
argument_list|(
operator|&
name|random_kthread_control
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|void
name|random_harvestq_flush
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Command a entropy queue flush and wait for it to finish */
name|random_kthread_control
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|random_kthread_control
condition|)
name|pause
argument_list|(
literal|"-"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|RANDOM_CHECK_UINT
argument_list|(
name|harvestmask
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
literal|1U
operator|<<
name|RANDOM_ENVIRONMENTAL_END
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|random_print_harvestmask
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|RANDOM_ENVIRONMENTAL_END
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|(
name|harvest_source_mask
operator|&
operator|(
literal|1U
operator|<<
name|i
operator|)
operator|)
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
specifier|const
name|char
operator|*
operator|(
name|random_source_descr
index|[]
operator|)
operator|=
block|{
literal|"CACHED"
block|,
literal|"ATTACH"
block|,
literal|"KEYBOARD"
block|,
literal|"MOUSE"
block|,
literal|"NET_TUN"
block|,
literal|"NET_ETHER"
block|,
literal|"NET_NG"
block|,
literal|"INTERRUPT"
block|,
literal|"SWI"
block|,
literal|"UMA_ALLOC"
block|,
literal|""
block|,
comment|/* "ENVIRONMENTAL_END" */
literal|"PURE_OCTEON"
block|,
literal|"PURE_SAFE"
block|,
literal|"PURE_GLXSB"
block|,
literal|"PURE_UBSEC"
block|,
literal|"PURE_HIFN"
block|,
literal|"PURE_RDRAND"
block|,
literal|"PURE_NEHEMIAH"
block|,
literal|"PURE_RNDTEST"
block|,
comment|/* "ENTROPYSOURCE" */
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|random_print_harvestmask_symbolic
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|RANDOM_ENVIRONMENTAL_END
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|(
name|i
operator|==
name|RANDOM_ENVIRONMENTAL_END
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
literal|","
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|(
name|harvest_source_mask
operator|&
operator|(
literal|1U
operator|<<
name|i
operator|)
operator|)
condition|?
name|random_source_descr
index|[
name|i
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|random_harvestq_init
parameter_list|(
name|void
function_decl|(
modifier|*
name|event_processor
function_decl|)
parameter_list|(
name|struct
name|harvest_event
modifier|*
parameter_list|)
parameter_list|,
name|int
name|poolcount
parameter_list|)
block|{
name|uint8_t
modifier|*
name|keyfile
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|random_sys_o
decl_stmt|;
ifdef|#
directive|ifdef
name|RANDOM_DEBUG
name|printf
argument_list|(
literal|"random: %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|random_sys_o
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|random_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_kern_random
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"harvest"
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Entropy Device Parameters"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|random_clist
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|random_sys_o
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mask"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|harvest_source_mask
argument_list|,
operator|(
operator|(
literal|1U
operator|<<
name|RANDOM_ENVIRONMENTAL_END
operator|)
operator|-
literal|1
operator|)
argument_list|,
name|random_check_uint_harvestmask
argument_list|,
literal|"IU"
argument_list|,
literal|"Entropy harvesting mask"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|random_clist
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|random_sys_o
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mask_bin"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|random_print_harvestmask
argument_list|,
literal|"A"
argument_list|,
literal|"Entropy harvesting mask (printable)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|random_clist
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|random_sys_o
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mask_symbolic"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|random_print_harvestmask_symbolic
argument_list|,
literal|"A"
argument_list|,
literal|"Entropy harvesting mask (symbolic)"
argument_list|)
expr_stmt|;
comment|/* Point to the correct event_processing function */
name|harvest_process_event
operator|=
name|event_processor
expr_stmt|;
comment|/* Store the pool count (used by live source feed) */
name|harvest_pool_count
operator|=
name|poolcount
expr_stmt|;
comment|/* Initialise the harvesting mutex and in/out indexes. */
name|mtx_init
argument_list|(
operator|&
name|harvest_mtx
argument_list|,
literal|"entropy harvest mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|entropyfifo
operator|.
name|ring_in
operator|=
name|entropyfifo
operator|.
name|ring_out
operator|=
literal|0U
expr_stmt|;
comment|/* Start the hash/reseed thread */
name|error
operator|=
name|kproc_create
argument_list|(
name|random_kthread
argument_list|,
name|NULL
argument_list|,
operator|&
name|random_kthread_proc
argument_list|,
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"rand_harvestq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Cannot create entropy maintenance thread."
argument_list|)
expr_stmt|;
comment|/* Get entropy that may have been preloaded by loader(8) 	 * and use it to pre-charge the entropy harvest queue. 	 */
name|keyfile
operator|=
name|preload_search_by_type
argument_list|(
literal|"/boot/entropy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfile
operator|!=
name|NULL
condition|)
block|{
name|data
operator|=
name|preload_fetch_addr
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
name|size
operator|=
name|preload_fetch_size
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|+=
literal|16
control|)
name|random_harvestq_internal
argument_list|(
name|data
operator|+
name|j
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|,
name|RANDOM_CACHED
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"random: read %zu bytes from preloaded cache\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"random: no preloaded entropy cache\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|random_harvestq_deinit
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RANDOM_DEBUG
name|printf
argument_list|(
literal|"random: %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Command the hash/reseed thread to end and wait for it to finish 	 */
name|random_kthread_control
operator|=
operator|-
literal|1
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|random_kthread_control
argument_list|,
literal|0
argument_list|,
literal|"term"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|harvest_mtx
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|random_clist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Entropy harvesting routine.  * This is supposed to be fast; do not do anything slow in here!  *  * It is also illegal (and morally reprehensible) to insert any  * high-rate data here. "High-rate" is define as a data source  * that will usually cause lots of failures of the "Lockless read"  * check a few lines below. This includes the "always-on" sources  * like the Intel "rdrand" or the VIA Nehamiah "xstore" sources.  */
end_comment

begin_comment
comment|/* XXXRW: get_cyclecount() is cheap on most modern hardware, where cycle  * counters are built in, but on older hardware it will do a real time clock  * read which can be quite expensive.  */
end_comment

begin_function
name|void
name|random_harvestq_internal
parameter_list|(
specifier|const
name|void
modifier|*
name|entropy
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|bits
parameter_list|,
name|enum
name|random_entropy_source
name|origin
parameter_list|)
block|{
name|struct
name|harvest_event
modifier|*
name|event
decl_stmt|;
name|u_int
name|ring_in
decl_stmt|;
name|KASSERT
argument_list|(
name|origin
operator|>=
name|RANDOM_START
operator|&&
name|origin
operator|<
name|ENTROPYSOURCE
argument_list|,
operator|(
literal|"random_harvest_internal: origin %d invalid\n"
operator|,
name|origin
operator|)
argument_list|)
expr_stmt|;
comment|/* Mask out unwanted sources */
if|if
condition|(
operator|!
operator|(
name|harvest_source_mask
operator|&
operator|(
literal|1U
operator|<<
name|origin
operator|)
operator|)
condition|)
return|return;
comment|/* Lock ring_in against multi-thread contention */
name|mtx_lock_spin
argument_list|(
operator|&
name|harvest_mtx
argument_list|)
expr_stmt|;
name|ring_in
operator|=
operator|(
name|entropyfifo
operator|.
name|ring_in
operator|+
literal|1
operator|)
operator|%
name|RANDOM_FIFO_MAX
expr_stmt|;
if|if
condition|(
name|ring_in
operator|!=
name|entropyfifo
operator|.
name|ring_out
condition|)
block|{
comment|/* The ring is not full */
name|event
operator|=
name|entropyfifo
operator|.
name|ring
operator|+
name|ring_in
expr_stmt|;
comment|/* Stash the harvested stuff in the *event buffer */
name|count
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|HARVESTSIZE
argument_list|)
expr_stmt|;
name|event
operator|->
name|he_somecounter
operator|=
name|get_cyclecount
argument_list|()
expr_stmt|;
name|event
operator|->
name|he_size
operator|=
name|count
expr_stmt|;
name|event
operator|->
name|he_bits
operator|=
name|bits
expr_stmt|;
name|event
operator|->
name|he_source
operator|=
name|origin
expr_stmt|;
name|event
operator|->
name|he_destination
operator|=
name|harvest_destination
index|[
name|origin
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|event
operator|->
name|he_entropy
argument_list|,
name|entropy
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|event
operator|->
name|he_entropy
operator|+
name|count
argument_list|,
literal|0
argument_list|,
name|HARVESTSIZE
operator|-
name|count
argument_list|)
expr_stmt|;
name|entropyfifo
operator|.
name|ring_in
operator|=
name|ring_in
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|harvest_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

