begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Mark R V Murray  * Copyright (c) 2013 Arthur Mesh<arthurmesh@gmail.com>  * Copyright (c) 2013 David E. O'Brien<obrien@NUXI.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_random.h"
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/randomdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/random_adaptors.h>
end_include

begin_include
include|#
directive|include
file|<dev/random/live_entropy_sources.h>
end_include

begin_comment
comment|/* The random_adaptors_lock protects random_adaptors_list and friends and random_adaptor.  * We need a sleepable lock for uiomove/block/poll/sbuf/sysctl.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sx
name|random_adaptors_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|adaptors_head
argument_list|,
name|random_adaptors
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|adaptors_head
name|random_adaptors_list
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|random_adaptors_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|random_adaptor
modifier|*
name|random_adaptor
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently active adaptor */
end_comment

begin_comment
comment|/* End of data items requiring random_adaptors_lock protection */
end_comment

begin_comment
comment|/* The random_readrate_mtx mutex protects the read-rate estimator.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|random_read_rate_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|random_adaptor_read_rate_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of data items requiring random_readrate_mtx mutex protection */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|selinfo
name|rsel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Utility routine to change active adaptor when the random_adaptors_list  * gets modified.  *  * Walk a list of registered random(4) adaptors and pick either a requested  * one or the highest priority one, whichever comes first. Panic on failure  * as the fallback must always be the "dummy" adaptor.  */
end_comment

begin_function
specifier|static
name|void
name|random_adaptor_choose
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|rngs
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|random_adaptors
modifier|*
name|rra
decl_stmt|,
modifier|*
name|rrai
decl_stmt|;
name|struct
name|random_adaptor
modifier|*
name|random_adaptor_previous
decl_stmt|;
name|int
name|primax
decl_stmt|;
comment|/* We are going to be messing with random_adaptor. 	 * Exclusive lock is mandatory. 	 */
name|sx_assert
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|random_adaptor_previous
operator|=
name|random_adaptor
expr_stmt|;
name|random_adaptor
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TUNABLE_STR_FETCH
argument_list|(
literal|"kern.random.active_adaptor"
argument_list|,
name|rngs
argument_list|,
sizeof|sizeof
argument_list|(
name|rngs
argument_list|)
argument_list|)
condition|)
block|{
name|cp
operator|=
name|rngs
expr_stmt|;
comment|/* XXX: FIX!! (DES): 		 * - fetch tunable once, at boot 		 * - make sysctl r/w 		 * - when fetching tunable or processing a sysctl 		 *   write, parse into list of strings so we don't 		 *   have to do it here again and again 		 * - sysctl read should return a reconstructed string 		 */
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|rra
argument_list|,
argument|&random_adaptors_list
argument_list|,
argument|rra_entries
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|rra
operator|->
name|rra_name
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
block|{
name|random_adaptor
operator|=
name|rra
operator|->
name|rra_ra
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|random_adaptor
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"random: selecting requested adaptor<%s>\n"
argument_list|,
name|random_adaptor
operator|->
name|ra_ident
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|printf
argument_list|(
literal|"random: requested adaptor<%s> not available\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|primax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|random_adaptor
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Fall back to the highest priority item on the available 		 * RNG list. 		 */
name|LIST_FOREACH
argument_list|(
argument|rrai
argument_list|,
argument|&random_adaptors_list
argument_list|,
argument|rra_entries
argument_list|)
block|{
if|if
condition|(
name|rrai
operator|->
name|rra_ra
operator|->
name|ra_priority
operator|>=
name|primax
condition|)
block|{
name|random_adaptor
operator|=
name|rrai
operator|->
name|rra_ra
expr_stmt|;
name|primax
operator|=
name|rrai
operator|->
name|rra_ra
operator|->
name|ra_priority
expr_stmt|;
block|}
block|}
if|if
condition|(
name|random_adaptor
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"random: selecting highest priority adaptor<%s>\n"
argument_list|,
name|random_adaptor
operator|->
name|ra_ident
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"adaptor not found"
operator|)
argument_list|)
expr_stmt|;
comment|/* If we are changing adaptors, deinit the old and init the new. */
if|if
condition|(
name|random_adaptor
operator|!=
name|random_adaptor_previous
condition|)
block|{
ifdef|#
directive|ifdef
name|RANDOM_DEBUG
name|printf
argument_list|(
literal|"random: %s - changing from %s to %s\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|random_adaptor_previous
operator|==
name|NULL
condition|?
literal|"NULL"
else|:
name|random_adaptor_previous
operator|->
name|ra_ident
operator|)
argument_list|,
name|random_adaptor
operator|->
name|ra_ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|random_adaptor_previous
operator|!=
name|NULL
condition|)
call|(
name|random_adaptor_previous
operator|->
name|ra_deinit
call|)
argument_list|()
expr_stmt|;
call|(
name|random_adaptor
operator|->
name|ra_init
call|)
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX: FIX!! Make sure we are not inserting a duplicate */
end_comment

begin_function
name|void
name|random_adaptor_register
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|random_adaptor
modifier|*
name|ra
parameter_list|)
block|{
name|struct
name|random_adaptors
modifier|*
name|rra
decl_stmt|;
name|KASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|ra
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid input to %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|rra
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rra
argument_list|)
argument_list|,
name|M_ENTROPY
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rra
operator|->
name|rra_name
operator|=
name|name
expr_stmt|;
name|rra
operator|->
name|rra_ra
operator|=
name|ra
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|random_adaptors_list
argument_list|,
name|rra
argument_list|,
name|rra_entries
argument_list|)
expr_stmt|;
name|random_adaptor_choose
argument_list|()
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No active random adaptor in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|random_adaptor_deregister
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|random_adaptors
modifier|*
name|rra
decl_stmt|;
name|KASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid input to %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No active random adaptor in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rra
argument_list|,
argument|&random_adaptors_list
argument_list|,
argument|rra_entries
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|rra
operator|->
name|rra_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|rra
argument_list|,
name|rra_entries
argument_list|)
expr_stmt|;
break|break;
block|}
name|random_adaptor_choose
argument_list|()
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rra
argument_list|,
name|M_ENTROPY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|random_adaptor_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
name|__unused
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|random_buf
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
decl_stmt|;
name|ssize_t
name|nbytes
decl_stmt|;
ifdef|#
directive|ifdef
name|RANDOM_DEBUG_VERBOSE
name|printf
argument_list|(
literal|"random: %s %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No active random adaptor in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
comment|/* Let the entropy source do any pre-read setup. */
call|(
name|random_adaptor
operator|->
name|ra_read
call|)
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* (Un)Blocking logic */
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|random_adaptor
operator|->
name|ra_seeded
argument_list|()
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
comment|/* Sleep instead of going into a spin-frenzy */
name|tsleep
argument_list|(
operator|&
name|random_adaptor
argument_list|,
name|PUSER
operator||
name|PCATCH
argument_list|,
literal|"block"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* keep tapping away at the pre-read until we seed/unblock. */
call|(
name|random_adaptor
operator|->
name|ra_read
call|)
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|random_read_rate_mtx
argument_list|)
expr_stmt|;
comment|/* The read-rate stuff is a rough indication of the instantaneous read rate, 	 * used to increase the use of 'live' entropy sources when lots of reads are done. 	 */
name|nbytes
operator|=
operator|(
name|uio
operator|->
name|uio_resid
operator|+
literal|32
operator|-
literal|1
operator|)
operator|/
literal|32
expr_stmt|;
comment|/* Round up to units of 32 */
name|random_adaptor_read_rate_cache
operator|+=
name|nbytes
operator|*
literal|32
expr_stmt|;
name|random_adaptor_read_rate_cache
operator|=
name|MIN
argument_list|(
name|random_adaptor_read_rate_cache
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|random_read_rate_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* The actual read */
name|random_buf
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_ENTROPY
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|&&
operator|!
name|error
condition|)
block|{
name|c
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
call|(
name|random_adaptor
operator|->
name|ra_read
call|)
argument_list|(
name|random_buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|random_buf
argument_list|,
name|c
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
comment|/* Let the entropy source do any post-read cleanup. */
call|(
name|random_adaptor
operator|->
name|ra_read
call|)
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|random_buf
argument_list|,
name|M_ENTROPY
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|random_adaptor_read_rate
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No active random adaptor in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|random_read_rate_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|random_adaptor_read_rate_cache
expr_stmt|;
name|random_adaptor_read_rate_cache
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|random_read_rate_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|random_adaptor_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
name|__unused
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|random_buf
decl_stmt|;
ifdef|#
directive|ifdef
name|RANDOM_DEBUG
name|printf
argument_list|(
literal|"random: %s %zd\n"
argument_list|,
name|__func__
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No active random adaptor in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|random_buf
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_ENTROPY
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|random_buf
argument_list|,
name|c
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
call|(
name|random_adaptor
operator|->
name|ra_write
call|)
argument_list|(
name|random_buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Introduce an annoying delay to stop swamping */
name|tsleep
argument_list|(
operator|&
name|random_adaptor
argument_list|,
name|PUSER
operator||
name|PCATCH
argument_list|,
literal|"block"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|random_buf
argument_list|,
name|M_ENTROPY
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|random_adaptor_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
name|__unused
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RANDOM_DEBUG
name|printf
argument_list|(
literal|"random: %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No active random adaptor in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|random_adaptor
operator|->
name|ra_seeded
argument_list|()
condition|)
name|events
operator|&=
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|rsel
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|events
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This will be called by the entropy processor when it seeds itself and becomes secure */
end_comment

begin_function
name|void
name|random_adaptor_unblock
parameter_list|(
name|void
parameter_list|)
block|{
name|selwakeuppri
argument_list|(
operator|&
name|rsel
argument_list|,
name|PUSER
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|random_adaptor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"random: unblocking device.\n"
argument_list|)
expr_stmt|;
comment|/* Do arc4random(9) a favour while we are about it. */
operator|(
name|void
operator|)
name|atomic_cmpset_int
argument_list|(
operator|&
name|arc4rand_iniseed_state
argument_list|,
name|ARC4_ENTR_NONE
argument_list|,
name|ARC4_ENTR_HAVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|random_sysctl_adaptors_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|random_adaptors
modifier|*
name|rra
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|64
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rra
argument_list|,
argument|&random_adaptors_list
argument_list|,
argument|rra_entries
argument_list|)
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"%s%s(%d)"
argument_list|,
operator|(
name|count
operator|++
condition|?
literal|","
else|:
literal|""
operator|)
argument_list|,
name|rra
operator|->
name|rra_name
argument_list|,
name|rra
operator|->
name|rra_ra
operator|->
name|ra_priority
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|random_sysctl_active_adaptor_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|random_adaptors
modifier|*
name|rra
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No active random adaptor in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rra
argument_list|,
argument|&random_adaptors_list
argument_list|,
argument|rra_entries
argument_list|)
if|if
condition|(
name|rra
operator|->
name|rra_ra
operator|==
name|random_adaptor
condition|)
block|{
name|sbuf_cat
argument_list|(
operator|&
name|sbuf
argument_list|,
name|rra
operator|->
name|rra_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|random_adaptors_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RANDOM_DEBUG
name|printf
argument_list|(
literal|"random: %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_PROC
argument_list|(
name|_kern_random
argument_list|,
name|OID_AUTO
argument_list|,
name|adaptors
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|random_sysctl_adaptors_handler
argument_list|,
literal|"A"
argument_list|,
literal|"Random Number Generator adaptors"
argument_list|)
expr_stmt|;
name|SYSCTL_PROC
argument_list|(
name|_kern_random
argument_list|,
name|OID_AUTO
argument_list|,
name|active_adaptor
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|random_sysctl_active_adaptor_handler
argument_list|,
literal|"A"
argument_list|,
literal|"Active Random Number Generator Adaptor"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|,
literal|"random_adaptors"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|random_read_rate_mtx
argument_list|,
literal|"read rate mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* The dummy adaptor is not a module by itself, but part of the 	 * randomdev module. 	 */
name|random_adaptor_register
argument_list|(
literal|"dummy"
argument_list|,
operator|&
name|randomdev_dummy
argument_list|)
expr_stmt|;
name|live_entropy_sources_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|random_adaptors_deinit
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RANDOM_DEBUG
name|printf
argument_list|(
literal|"random: %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|live_entropy_sources_deinit
argument_list|()
expr_stmt|;
comment|/* Don't do this! Panic will surely follow! */
comment|/* random_adaptor_deregister("dummy"); */
name|mtx_destroy
argument_list|(
operator|&
name|random_read_rate_mtx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reseed the active adaptor shortly before starting init(8).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|random_adaptors_seed
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|random_adaptor
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No active random adaptor in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|random_adaptor
operator|->
name|ra_reseed
argument_list|()
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|random_adaptors_lock
argument_list|)
expr_stmt|;
name|arc4rand
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|random_seed
argument_list|,
name|SI_SUB_KTHREAD_INIT
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|random_adaptors_seed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

