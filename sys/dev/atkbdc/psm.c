begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993 Erik Forsberg.  * Copyright (c) 1996, 1997 Kazutaka YOKOTA.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  Ported to 386bsd Oct 17, 1992  *  Sandi Donno, Computer Science, University of Cape Town, South Africa  *  Please send bug reports to sandi@cs.uct.ac.za  *  *  Thanks are also due to Rick Macklem, rick@snowhite.cis.uoguelph.ca -  *  although I was only partially successful in getting the alpha release  *  of his "driver for the Logitech and ATI Inport Bus mice for use with  *  386bsd and the X386 port" to work with my Microsoft mouse, I nevertheless  *  found his code to be an invaluable reference when porting this driver  *  to 386bsd.  *  *  Further modifications for latest 386BSD+patchkit and port to NetBSD,  *  Andrew Herbert<andrew@werple.apana.org.au> - 8 June 1993  *  *  Cloned from the Microsoft Bus Mouse driver, also by Erik Forsberg, by  *  Andrew Herbert - 12 June 1993  *  *  Modified for PS/2 mouse by Charles Hannum<mycroft@ai.mit.edu>  *  - 13 June 1993  *  *  Modified for PS/2 AUX mouse by Shoji Yuen<yuen@nuie.nagoya-u.ac.jp>  *  - 24 October 1993  *  *  Hardware access routines and probe logic rewritten by  *  Kazutaka Yokota<yokota@zodiac.mech.utsunomiya-u.ac.jp>  *  - 3, 14, 22 October 1996.  *  - 12 November 1996. IOCTLs and rearranging `psmread', `psmioctl'...  *  - 14, 30 November 1996. Uses `kbdio.c'.  *  - 13 December 1996. Uses queuing version of `kbdio.c'.  *  - January/February 1997. Tweaked probe logic for  *    HiNote UltraII/Latitude/Armada laptops.  *  - 30 July 1997. Added APM support.  *  - 5 March 1997. Defined driver configuration flags (PSM_CONFIG_XXX).  *    Improved sync check logic.  *    Vendor specific support routines.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|"opt_psm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/sigio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/mouse.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_ISA
end_ifdef

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/atkbdc/atkbdcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/atkbdc/psm.h>
end_include

begin_comment
comment|/*  * Driver specific options: the following options may be set by  * `options' statements in the kernel configuration file.  */
end_comment

begin_comment
comment|/* debugging */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|PSM_DEBUG
value|0
end_define

begin_comment
comment|/* 				 * logging: 0: none, 1: brief, 2: verbose 				 *          3: sync errors, 4: all packets 				 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VLOG
parameter_list|(
name|level
parameter_list|,
name|args
parameter_list|)
value|do {	\ 	if (verbose>= level)		\ 		log args;		\ } while (0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_INPUT_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|PSM_INPUT_TIMEOUT
value|2000000
end_define

begin_comment
comment|/* 2 sec */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_TAP_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|PSM_TAP_TIMEOUT
value|125000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_TAP_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|PSM_TAP_THRESHOLD
value|25
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of driver specific options */
end_comment

begin_define
define|#
directive|define
name|PSMCPNP_DRIVER_NAME
value|"psmcpnp"
end_define

begin_comment
comment|/* input queue */
end_comment

begin_define
define|#
directive|define
name|PSM_BUFSIZE
value|960
end_define

begin_define
define|#
directive|define
name|PSM_SMALLBUFSIZE
value|240
end_define

begin_comment
comment|/* operation levels */
end_comment

begin_define
define|#
directive|define
name|PSM_LEVEL_BASE
value|0
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_STANDARD
value|1
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_NATIVE
value|2
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_MIN
value|PSM_LEVEL_BASE
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_MAX
value|PSM_LEVEL_NATIVE
end_define

begin_comment
comment|/* Logitech PS2++ protocol */
end_comment

begin_define
define|#
directive|define
name|MOUSE_PS2PLUS_CHECKBITS
parameter_list|(
name|b
parameter_list|)
define|\
value|((((b[2]& 0x03)<< 2) | 0x02) == (b[1]& 0x0f))
end_define

begin_define
define|#
directive|define
name|MOUSE_PS2PLUS_PACKET_TYPE
parameter_list|(
name|b
parameter_list|)
define|\
value|(((b[0]& 0x30)>> 2) | ((b[1]& 0x30)>> 4))
end_define

begin_comment
comment|/* ring buffer */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ringbuf
block|{
name|int
name|count
decl_stmt|;
comment|/* # of valid elements in the buffer */
name|int
name|head
decl_stmt|;
comment|/* head pointer */
name|int
name|tail
decl_stmt|;
comment|/* tail poiner */
name|u_char
name|buf
index|[
name|PSM_BUFSIZE
index|]
decl_stmt|;
block|}
name|ringbuf_t
typedef|;
end_typedef

begin_comment
comment|/* data buffer */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|packetbuf
block|{
name|u_char
name|ipacket
index|[
literal|16
index|]
decl_stmt|;
comment|/* interim input buffer */
name|int
name|inputbytes
decl_stmt|;
comment|/* # of bytes in the input buffer */
block|}
name|packetbuf_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_PACKETQUEUE
end_ifndef

begin_define
define|#
directive|define
name|PSM_PACKETQUEUE
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
block|{
name|SYNAPTICS_SYSCTL_MIN_PRESSURE
block|,
name|SYNAPTICS_SYSCTL_MAX_PRESSURE
block|,
name|SYNAPTICS_SYSCTL_MAX_WIDTH
block|,
name|SYNAPTICS_SYSCTL_MARGIN_TOP
block|,
name|SYNAPTICS_SYSCTL_MARGIN_RIGHT
block|,
name|SYNAPTICS_SYSCTL_MARGIN_BOTTOM
block|,
name|SYNAPTICS_SYSCTL_MARGIN_LEFT
block|,
name|SYNAPTICS_SYSCTL_NA_TOP
block|,
name|SYNAPTICS_SYSCTL_NA_RIGHT
block|,
name|SYNAPTICS_SYSCTL_NA_BOTTOM
block|,
name|SYNAPTICS_SYSCTL_NA_LEFT
block|,
name|SYNAPTICS_SYSCTL_WINDOW_MIN
block|,
name|SYNAPTICS_SYSCTL_WINDOW_MAX
block|,
name|SYNAPTICS_SYSCTL_MULTIPLICATOR
block|,
name|SYNAPTICS_SYSCTL_WEIGHT_CURRENT
block|,
name|SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS
block|,
name|SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS_NA
block|,
name|SYNAPTICS_SYSCTL_WEIGHT_LEN_SQUARED
block|,
name|SYNAPTICS_SYSCTL_DIV_MIN
block|,
name|SYNAPTICS_SYSCTL_DIV_MAX
block|,
name|SYNAPTICS_SYSCTL_DIV_MAX_NA
block|,
name|SYNAPTICS_SYSCTL_DIV_LEN
block|,
name|SYNAPTICS_SYSCTL_TAP_MAX_DELTA
block|,
name|SYNAPTICS_SYSCTL_TAP_MIN_QUEUE
block|,
name|SYNAPTICS_SYSCTL_TAPHOLD_TIMEOUT
block|,
name|SYNAPTICS_SYSCTL_VSCROLL_HOR_AREA
block|,
name|SYNAPTICS_SYSCTL_VSCROLL_VER_AREA
block|,
name|SYNAPTICS_SYSCTL_VSCROLL_MIN_DELTA
block|,
name|SYNAPTICS_SYSCTL_VSCROLL_DIV_MIN
block|,
name|SYNAPTICS_SYSCTL_VSCROLL_DIV_MAX
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|synapticsinfo
block|{
name|struct
name|sysctl_ctx_list
name|sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
decl_stmt|;
name|int
name|directional_scrolls
decl_stmt|;
name|int
name|min_pressure
decl_stmt|;
name|int
name|max_pressure
decl_stmt|;
name|int
name|max_width
decl_stmt|;
name|int
name|margin_top
decl_stmt|;
name|int
name|margin_right
decl_stmt|;
name|int
name|margin_bottom
decl_stmt|;
name|int
name|margin_left
decl_stmt|;
name|int
name|na_top
decl_stmt|;
name|int
name|na_right
decl_stmt|;
name|int
name|na_bottom
decl_stmt|;
name|int
name|na_left
decl_stmt|;
name|int
name|window_min
decl_stmt|;
name|int
name|window_max
decl_stmt|;
name|int
name|multiplicator
decl_stmt|;
name|int
name|weight_current
decl_stmt|;
name|int
name|weight_previous
decl_stmt|;
name|int
name|weight_previous_na
decl_stmt|;
name|int
name|weight_len_squared
decl_stmt|;
name|int
name|div_min
decl_stmt|;
name|int
name|div_max
decl_stmt|;
name|int
name|div_max_na
decl_stmt|;
name|int
name|div_len
decl_stmt|;
name|int
name|tap_max_delta
decl_stmt|;
name|int
name|tap_min_queue
decl_stmt|;
name|int
name|taphold_timeout
decl_stmt|;
name|int
name|vscroll_ver_area
decl_stmt|;
name|int
name|vscroll_hor_area
decl_stmt|;
name|int
name|vscroll_min_delta
decl_stmt|;
name|int
name|vscroll_div_min
decl_stmt|;
name|int
name|vscroll_div_max
decl_stmt|;
block|}
name|synapticsinfo_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|synapticspacket
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
block|}
name|synapticspacket_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SYNAPTICS_PACKETQUEUE
value|10
end_define

begin_define
define|#
directive|define
name|SYNAPTICS_QUEUE_CURSOR
parameter_list|(
name|x
parameter_list|)
define|\
value|(x + SYNAPTICS_PACKETQUEUE) % SYNAPTICS_PACKETQUEUE
end_define

begin_define
define|#
directive|define
name|SYNAPTICS_VERSION_GE
parameter_list|(
name|synhw
parameter_list|,
name|major
parameter_list|,
name|minor
parameter_list|)
define|\
value|((synhw).infoMajor> (major) ||					\      ((synhw).infoMajor == (major)&& (synhw).infoMinor>= (minor)))
end_define

begin_typedef
typedef|typedef
struct|struct
name|synapticsaction
block|{
name|synapticspacket_t
name|queue
index|[
name|SYNAPTICS_PACKETQUEUE
index|]
decl_stmt|;
name|int
name|queue_len
decl_stmt|;
name|int
name|queue_cursor
decl_stmt|;
name|int
name|window_min
decl_stmt|;
name|int
name|start_x
decl_stmt|;
name|int
name|start_y
decl_stmt|;
name|int
name|avg_dx
decl_stmt|;
name|int
name|avg_dy
decl_stmt|;
name|int
name|squelch_x
decl_stmt|;
name|int
name|squelch_y
decl_stmt|;
name|int
name|fingers_nb
decl_stmt|;
name|int
name|tap_button
decl_stmt|;
name|int
name|in_taphold
decl_stmt|;
name|int
name|in_vscroll
decl_stmt|;
block|}
name|synapticsaction_t
typedef|;
end_typedef

begin_enum
enum|enum
block|{
name|TRACKPOINT_SYSCTL_SENSITIVITY
block|,
name|TRACKPOINT_SYSCTL_NEGATIVE_INERTIA
block|,
name|TRACKPOINT_SYSCTL_UPPER_PLATEAU
block|,
name|TRACKPOINT_SYSCTL_BACKUP_RANGE
block|,
name|TRACKPOINT_SYSCTL_DRAG_HYSTERESIS
block|,
name|TRACKPOINT_SYSCTL_MINIMUM_DRAG
block|,
name|TRACKPOINT_SYSCTL_UP_THRESHOLD
block|,
name|TRACKPOINT_SYSCTL_THRESHOLD
block|,
name|TRACKPOINT_SYSCTL_JENKS_CURVATURE
block|,
name|TRACKPOINT_SYSCTL_Z_TIME
block|,
name|TRACKPOINT_SYSCTL_PRESS_TO_SELECT
block|,
name|TRACKPOINT_SYSCTL_SKIP_BACKUPS
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|trackpointinfo
block|{
name|struct
name|sysctl_ctx_list
name|sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
decl_stmt|;
name|int
name|sensitivity
decl_stmt|;
name|int
name|inertia
decl_stmt|;
name|int
name|uplateau
decl_stmt|;
name|int
name|reach
decl_stmt|;
name|int
name|draghys
decl_stmt|;
name|int
name|mindrag
decl_stmt|;
name|int
name|upthresh
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|int
name|jenks
decl_stmt|;
name|int
name|ztime
decl_stmt|;
name|int
name|pts
decl_stmt|;
name|int
name|skipback
decl_stmt|;
block|}
name|trackpointinfo_t
typedef|;
end_typedef

begin_comment
comment|/* driver control block */
end_comment

begin_struct
struct|struct
name|psm_softc
block|{
comment|/* Driver status information */
name|int
name|unit
decl_stmt|;
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* Process selecting for Input */
name|u_char
name|state
decl_stmt|;
comment|/* Mouse driver state */
name|int
name|config
decl_stmt|;
comment|/* driver configuration flags */
name|int
name|flags
decl_stmt|;
comment|/* other flags */
name|KBDC
name|kbdc
decl_stmt|;
comment|/* handle to access kbd controller */
name|struct
name|resource
modifier|*
name|intr
decl_stmt|;
comment|/* IRQ resource */
name|void
modifier|*
name|ih
decl_stmt|;
comment|/* interrupt handle */
name|mousehw_t
name|hw
decl_stmt|;
comment|/* hardware information */
name|synapticshw_t
name|synhw
decl_stmt|;
comment|/* Synaptics hardware information */
name|synapticsinfo_t
name|syninfo
decl_stmt|;
comment|/* Synaptics configuration */
name|synapticsaction_t
name|synaction
decl_stmt|;
comment|/* Synaptics action context */
name|int
name|tphw
decl_stmt|;
comment|/* TrackPoint hardware information */
name|trackpointinfo_t
name|tpinfo
decl_stmt|;
comment|/* TrackPoint configuration */
name|mousemode_t
name|mode
decl_stmt|;
comment|/* operation mode */
name|mousemode_t
name|dflt_mode
decl_stmt|;
comment|/* default operation mode */
name|mousestatus_t
name|status
decl_stmt|;
comment|/* accumulated mouse movement */
name|ringbuf_t
name|queue
decl_stmt|;
comment|/* mouse status queue */
name|packetbuf_t
name|pqueue
index|[
name|PSM_PACKETQUEUE
index|]
decl_stmt|;
comment|/* mouse data queue */
name|int
name|pqueue_start
decl_stmt|;
comment|/* start of data in queue */
name|int
name|pqueue_end
decl_stmt|;
comment|/* end of data in queue */
name|int
name|button
decl_stmt|;
comment|/* the latest button state */
name|int
name|xold
decl_stmt|;
comment|/* previous absolute X position */
name|int
name|yold
decl_stmt|;
comment|/* previous absolute Y position */
name|int
name|xaverage
decl_stmt|;
comment|/* average X position */
name|int
name|yaverage
decl_stmt|;
comment|/* average Y position */
name|int
name|squelch
decl_stmt|;
comment|/* level to filter movement at low speed */
name|int
name|zmax
decl_stmt|;
comment|/* maximum pressure value for touchpads */
name|int
name|syncerrors
decl_stmt|;
comment|/* # of bytes discarded to synchronize */
name|int
name|pkterrors
decl_stmt|;
comment|/* # of packets failed during quaranteen. */
name|struct
name|timeval
name|inputtimeout
decl_stmt|;
name|struct
name|timeval
name|lastsoftintr
decl_stmt|;
comment|/* time of last soft interrupt */
name|struct
name|timeval
name|lastinputerr
decl_stmt|;
comment|/* time last sync error happened */
name|struct
name|timeval
name|taptimeout
decl_stmt|;
comment|/* tap timeout for touchpads */
name|int
name|watchdog
decl_stmt|;
comment|/* watchdog timer flag */
name|struct
name|callout
name|callout
decl_stmt|;
comment|/* watchdog timer call out */
name|struct
name|callout
name|softcallout
decl_stmt|;
comment|/* buffer timer call out */
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|bdev
decl_stmt|;
name|int
name|lasterr
decl_stmt|;
name|int
name|cmdcount
decl_stmt|;
name|struct
name|sigio
modifier|*
name|async
decl_stmt|;
comment|/* Processes waiting for SIGIO */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|devclass_t
name|psm_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* driver state flags (state) */
end_comment

begin_define
define|#
directive|define
name|PSM_VALID
value|0x80
end_define

begin_define
define|#
directive|define
name|PSM_OPEN
value|1
end_define

begin_comment
comment|/* Device is open */
end_comment

begin_define
define|#
directive|define
name|PSM_ASLP
value|2
end_define

begin_comment
comment|/* Waiting for mouse data */
end_comment

begin_define
define|#
directive|define
name|PSM_SOFTARMED
value|4
end_define

begin_comment
comment|/* Software interrupt armed */
end_comment

begin_define
define|#
directive|define
name|PSM_NEED_SYNCBITS
value|8
end_define

begin_comment
comment|/* Set syncbits using next data pkt */
end_comment

begin_comment
comment|/* driver configuration flags (config) */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_RESOLUTION
value|0x000f
end_define

begin_comment
comment|/* resolution */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_ACCEL
value|0x00f0
end_define

begin_comment
comment|/* acceleration factor */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_NOCHECKSYNC
value|0x0100
end_define

begin_comment
comment|/* disable sync. test */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_NOIDPROBE
value|0x0200
end_define

begin_comment
comment|/* disable mouse model probe */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_NORESET
value|0x0400
end_define

begin_comment
comment|/* don't reset the mouse */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_FORCETAP
value|0x0800
end_define

begin_comment
comment|/* assume `tap' action exists */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_IGNPORTERROR
value|0x1000
end_define

begin_comment
comment|/* ignore error in aux port test */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_HOOKRESUME
value|0x2000
end_define

begin_comment
comment|/* hook the system resume event */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_INITAFTERSUSPEND
value|0x4000
end_define

begin_comment
comment|/* init the device at the resume event */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_FLAGS
define|\
value|(PSM_CONFIG_RESOLUTION |	\     PSM_CONFIG_ACCEL |		\     PSM_CONFIG_NOCHECKSYNC |	\     PSM_CONFIG_NOIDPROBE |	\     PSM_CONFIG_NORESET |	\     PSM_CONFIG_FORCETAP |	\     PSM_CONFIG_IGNPORTERROR |	\     PSM_CONFIG_HOOKRESUME |	\     PSM_CONFIG_INITAFTERSUSPEND)
end_define

begin_comment
comment|/* other flags (flags) */
end_comment

begin_define
define|#
directive|define
name|PSM_FLAGS_FINGERDOWN
value|0x0001
end_define

begin_comment
comment|/* VersaPad finger down */
end_comment

begin_comment
comment|/* Tunables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tap_enabled
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.psm.tap_enabled"
argument_list|,
operator|&
name|tap_enabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|synaptics_support
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.psm.synaptics_support"
argument_list|,
operator|&
name|synaptics_support
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|trackpoint_support
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.psm.trackpoint_support"
argument_list|,
operator|&
name|trackpoint_support
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
name|PSM_DEBUG
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.psm.loglevel"
argument_list|,
operator|&
name|verbose
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* for backward compatibility */
end_comment

begin_define
define|#
directive|define
name|OLD_MOUSE_GETHWINFO
value|_IOR('M', 1, old_mousehw_t)
end_define

begin_define
define|#
directive|define
name|OLD_MOUSE_GETMODE
value|_IOR('M', 2, old_mousemode_t)
end_define

begin_define
define|#
directive|define
name|OLD_MOUSE_SETMODE
value|_IOW('M', 3, old_mousemode_t)
end_define

begin_typedef
typedef|typedef
struct|struct
name|old_mousehw
block|{
name|int
name|buttons
decl_stmt|;
name|int
name|iftype
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|hwid
decl_stmt|;
block|}
name|old_mousehw_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|old_mousemode
block|{
name|int
name|protocol
decl_stmt|;
name|int
name|rate
decl_stmt|;
name|int
name|resolution
decl_stmt|;
name|int
name|accelfactor
decl_stmt|;
block|}
name|old_mousemode_t
typedef|;
end_typedef

begin_comment
comment|/* packet formatting function */
end_comment

begin_typedef
typedef|typedef
name|int
name|packetfunc_t
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|mousestatus_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|psmidentify
parameter_list|(
name|driver_t
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmprobe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmattach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmdetach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmresume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|psmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|psmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|psmread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|psmwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|psmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|psmpoll
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|enable_aux_dev
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|disable_aux_dev
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_mouse_status
parameter_list|(
name|KBDC
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_aux_id
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mouse_sampling_rate
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mouse_scaling
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mouse_resolution
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mouse_mode
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_mouse_buttons
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_a_mouse
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|recover_from_error
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|restore_controller
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doinitialize
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|mousemode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doopen
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reinitialize
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|model_name
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psmsoftintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psmintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psmtimeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|timeelapsed
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dropqueue
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flushpackets
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proc_mmanplus
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|packetbuf_t
modifier|*
parameter_list|,
name|mousestatus_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|proc_synaptics
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|packetbuf_t
modifier|*
parameter_list|,
name|mousestatus_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proc_versapad
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|packetbuf_t
modifier|*
parameter_list|,
name|mousestatus_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tame_mouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|packetbuf_t
modifier|*
parameter_list|,
name|mousestatus_t
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* vendor specific features */
end_comment

begin_typedef
typedef|typedef
name|int
name|probefunc_t
parameter_list|(
name|KBDC
parameter_list|,
name|struct
name|psm_softc
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|int
name|mouse_id_proc1
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mouse_ext_command
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_groller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_gmouse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_aglide
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_kmouse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_msexplorer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_msintelli
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_4dmouse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_4dplus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_mmanplus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_synaptics
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_trackpoint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_versapad
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|int
name|model
decl_stmt|;
name|u_char
name|syncmask
decl_stmt|;
name|int
name|packetsize
decl_stmt|;
name|probefunc_t
modifier|*
name|probefunc
decl_stmt|;
block|}
name|vendortype
index|[]
init|=
block|{
comment|/* 	 * WARNING: the order of probe is very important.  Don't mess it 	 * unless you know what you are doing. 	 */
block|{
name|MOUSE_MODEL_NET
block|,
comment|/* Genius NetMouse */
literal|0x08
block|,
name|MOUSE_PS2INTELLI_PACKETSIZE
block|,
name|enable_gmouse
block|}
block|,
block|{
name|MOUSE_MODEL_NETSCROLL
block|,
comment|/* Genius NetScroll */
literal|0xc8
block|,
literal|6
block|,
name|enable_groller
block|}
block|,
block|{
name|MOUSE_MODEL_MOUSEMANPLUS
block|,
comment|/* Logitech MouseMan+ */
literal|0x08
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_mmanplus
block|}
block|,
block|{
name|MOUSE_MODEL_EXPLORER
block|,
comment|/* Microsoft IntelliMouse Explorer */
literal|0x08
block|,
name|MOUSE_PS2INTELLI_PACKETSIZE
block|,
name|enable_msexplorer
block|}
block|,
block|{
name|MOUSE_MODEL_4D
block|,
comment|/* A4 Tech 4D Mouse */
literal|0x08
block|,
name|MOUSE_4D_PACKETSIZE
block|,
name|enable_4dmouse
block|}
block|,
block|{
name|MOUSE_MODEL_4DPLUS
block|,
comment|/* A4 Tech 4D+ Mouse */
literal|0xc8
block|,
name|MOUSE_4DPLUS_PACKETSIZE
block|,
name|enable_4dplus
block|}
block|,
block|{
name|MOUSE_MODEL_SYNAPTICS
block|,
comment|/* Synaptics Touchpad */
literal|0xc0
block|,
name|MOUSE_SYNAPTICS_PACKETSIZE
block|,
name|enable_synaptics
block|}
block|,
block|{
name|MOUSE_MODEL_INTELLI
block|,
comment|/* Microsoft IntelliMouse */
literal|0x08
block|,
name|MOUSE_PS2INTELLI_PACKETSIZE
block|,
name|enable_msintelli
block|}
block|,
block|{
name|MOUSE_MODEL_GLIDEPOINT
block|,
comment|/* ALPS GlidePoint */
literal|0xc0
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_aglide
block|}
block|,
block|{
name|MOUSE_MODEL_THINK
block|,
comment|/* Kensington ThinkingMouse */
literal|0x80
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_kmouse
block|}
block|,
block|{
name|MOUSE_MODEL_VERSAPAD
block|,
comment|/* Interlink electronics VersaPad */
literal|0xe8
block|,
name|MOUSE_PS2VERSA_PACKETSIZE
block|,
name|enable_versapad
block|}
block|,
block|{
name|MOUSE_MODEL_TRACKPOINT
block|,
comment|/* IBM/Lenovo TrackPoint */
literal|0xc0
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_trackpoint
block|}
block|,
block|{
name|MOUSE_MODEL_GENERIC
block|,
literal|0xc0
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|NULL
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|GENERIC_MOUSE_ENTRY
define|\
value|((sizeof(vendortype) / sizeof(*vendortype)) - 1)
end_define

begin_comment
comment|/* device driver declarateion */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|psm_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|psmidentify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|psmprobe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|psmattach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|psmdetach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|psmresume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|psm_driver
init|=
block|{
name|PSM_DRIVER_NAME
block|,
name|psm_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|psm_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|psm_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|psmopen
block|,
operator|.
name|d_close
operator|=
name|psmclose
block|,
operator|.
name|d_read
operator|=
name|psmread
block|,
operator|.
name|d_write
operator|=
name|psmwrite
block|,
operator|.
name|d_ioctl
operator|=
name|psmioctl
block|,
operator|.
name|d_poll
operator|=
name|psmpoll
block|,
operator|.
name|d_name
operator|=
name|PSM_DRIVER_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device I/O routines */
end_comment

begin_function
specifier|static
name|int
name|enable_aux_dev
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_ENABLE_DEV
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: ENABLE_DEV return code:%04x\n"
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|disable_aux_dev
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_DISABLE_DEV
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: DISABLE_DEV return code:%04x\n"
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_status
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cmd
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|0
case|:
default|default:
name|cmd
operator|=
name|PSMC_SEND_DEV_STATUS
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cmd
operator|=
name|PSMC_SEND_DEV_DATA
expr_stmt|;
break|break;
block|}
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: SEND_AUX_DEV_%s return code:%04x\n"
operator|,
operator|(
name|flag
operator|==
literal|1
operator|)
condition|?
literal|"DATA"
else|:
literal|"STATUS"
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|status
index|[
name|i
index|]
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
index|[
name|i
index|]
operator|<
literal|0
condition|)
break|break;
block|}
name|VLOG
argument_list|(
literal|1
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: %s %02x %02x %02x\n"
operator|,
operator|(
name|flag
operator|==
literal|1
operator|)
condition|?
literal|"data"
else|:
literal|"status"
operator|,
name|status
index|[
literal|0
index|]
operator|,
name|status
index|[
literal|1
index|]
operator|,
name|status
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_aux_id
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|id
decl_stmt|;
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SEND_DEV_ID
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: SEND_DEV_ID return code:%04x\n"
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 10ms delay */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|id
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: device ID: %04x\n"
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_sampling_rate
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_SAMPLING_RATE
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: SET_SAMPLING_RATE (%d) %04x\n"
operator|,
name|rate
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|rate
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_scaling
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
switch|switch
condition|(
name|scale
condition|)
block|{
case|case
literal|1
case|:
default|default:
name|scale
operator|=
name|PSMC_SET_SCALING11
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scale
operator|=
name|PSMC_SET_SCALING21
expr_stmt|;
break|break;
block|}
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: SET_SCALING%s return code:%04x\n"
operator|,
operator|(
name|scale
operator|==
name|PSMC_SET_SCALING21
operator|)
condition|?
literal|"21"
else|:
literal|"11"
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* `val' must be 0 through PSMD_MAX_RESOLUTION */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_resolution
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_RESOLUTION
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: SET_RESOLUTION (%d) %04x\n"
operator|,
name|val
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|val
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: once `set_mouse_mode()' is called, the mouse device must be  * re-enabled by calling `enable_aux_dev()'  */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_mode
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_STREAM_MODE
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: SET_STREAM_MODE return code:%04x\n"
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_buttons
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|c
init|=
literal|2
decl_stmt|;
comment|/* assume two buttons by default */
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/* 	 * NOTE: a special sequence to obtain Logitech Mouse specific 	 * information: set resolution to 25 ppi, set scaling to 1:1, set 	 * scaling to 1:1, set scaling to 1:1. Then the second byte of the 	 * mouse status bytes is the number of available buttons. 	 * Some manufactures also support this sequence. 	 */
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|)
operator|!=
name|PSMD_RES_LOW
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
operator|&&
name|status
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|status
index|[
literal|1
index|]
operator|)
return|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* misc subroutines */
end_comment

begin_comment
comment|/*  * Someday, I will get the complete list of valid pointing devices and  * their IDs... XXX  */
end_comment

begin_function
specifier|static
name|int
name|is_a_mouse
parameter_list|(
name|int
name|id
parameter_list|)
block|{
if|#
directive|if
literal|0
block|static int valid_ids[] = { 		PSM_MOUSE_ID,
comment|/* mouse */
block|PSM_BALLPOINT_ID,
comment|/* ballpoint device */
block|PSM_INTELLI_ID,
comment|/* Intellimouse */
block|PSM_EXPLORER_ID,
comment|/* Intellimouse Explorer */
block|-1
comment|/* end of table */
block|}; 	int i;  	for (i = 0; valid_ids[i]>= 0; ++i) 	if (valid_ids[i] == id) 		return (TRUE); 	return (FALSE);
else|#
directive|else
return|return
operator|(
name|TRUE
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|model_name
parameter_list|(
name|int
name|model
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|model_code
decl_stmt|;
name|char
modifier|*
name|model_name
decl_stmt|;
block|}
name|models
index|[]
init|=
block|{
block|{
name|MOUSE_MODEL_NETSCROLL
block|,
literal|"NetScroll"
block|}
block|,
block|{
name|MOUSE_MODEL_NET
block|,
literal|"NetMouse/NetScroll Optical"
block|}
block|,
block|{
name|MOUSE_MODEL_GLIDEPOINT
block|,
literal|"GlidePoint"
block|}
block|,
block|{
name|MOUSE_MODEL_THINK
block|,
literal|"ThinkingMouse"
block|}
block|,
block|{
name|MOUSE_MODEL_INTELLI
block|,
literal|"IntelliMouse"
block|}
block|,
block|{
name|MOUSE_MODEL_MOUSEMANPLUS
block|,
literal|"MouseMan+"
block|}
block|,
block|{
name|MOUSE_MODEL_VERSAPAD
block|,
literal|"VersaPad"
block|}
block|,
block|{
name|MOUSE_MODEL_EXPLORER
block|,
literal|"IntelliMouse Explorer"
block|}
block|,
block|{
name|MOUSE_MODEL_4D
block|,
literal|"4D Mouse"
block|}
block|,
block|{
name|MOUSE_MODEL_4DPLUS
block|,
literal|"4D+ Mouse"
block|}
block|,
block|{
name|MOUSE_MODEL_SYNAPTICS
block|,
literal|"Synaptics Touchpad"
block|}
block|,
block|{
name|MOUSE_MODEL_TRACKPOINT
block|,
literal|"IBM/Lenovo TrackPoint"
block|}
block|,
block|{
name|MOUSE_MODEL_GENERIC
block|,
literal|"Generic PS/2 mouse"
block|}
block|,
block|{
name|MOUSE_MODEL_UNKNOWN
block|,
literal|"Unknown"
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|models
index|[
name|i
index|]
operator|.
name|model_code
operator|!=
name|MOUSE_MODEL_UNKNOWN
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|models
index|[
name|i
index|]
operator|.
name|model_code
operator|==
name|model
condition|)
break|break;
return|return
operator|(
name|models
index|[
name|i
index|]
operator|.
name|model_name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recover_from_error
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
comment|/* discard anything left in the output buffer */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * NOTE: KBDC_RESET_KBD may not restore the communication between the 	 * keyboard and the controller. 	 */
block|reset_kbd(kbdc);
else|#
directive|else
comment|/* 	 * NOTE: somehow diagnostic and keyboard port test commands bring the 	 * keyboard back. 	 */
if|if
condition|(
operator|!
name|test_controller
argument_list|(
name|kbdc
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: keyboard controller failed.\n"
argument_list|)
expr_stmt|;
comment|/* if there isn't a keyboard in the system, the following error is OK */
if|if
condition|(
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
operator|!=
literal|0
condition|)
name|VLOG
argument_list|(
literal|1
argument_list|,
operator|(
name|LOG_ERR
operator|,
literal|"psm: keyboard port failed.\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|restore_controller
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|command_byte
parameter_list|)
block|{
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
literal|0xff
argument_list|,
name|command_byte
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: failed to restore the keyboard controller "
literal|"command byte.\n"
argument_list|)
expr_stmt|;
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Re-initialize the aux port and device. The aux port must be enabled  * and its interrupt must be disabled before calling this routine.  * The aux device will be disabled before returning.  * The keyboard controller must be locked via `kbdc_lock()' before  * calling this routine.  */
end_comment

begin_function
specifier|static
name|int
name|doinitialize
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|mousemode_t
modifier|*
name|mode
parameter_list|)
block|{
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|kbdc
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* ignore these errors */
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
name|PSM_ACK
case|:
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: strange result for test aux port (%d).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_IGNPORTERROR
condition|)
break|break;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NORESET
condition|)
block|{
comment|/* 		 * Don't try to reset the pointing device.  It may possibly 		 * be left in the unknown state, though... 		 */
block|}
else|else
block|{
comment|/* 		 * NOTE: some controllers appears to hang the `keyboard' when 		 * the aux port doesn't exist and `PSMC_RESET_DEV' is issued. 		 */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to reset the aux device.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* 	 * both the aux port and the aux device is functioning, see 	 * if the device can be enabled. 	 */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|kbdc
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* remove stray data if any */
comment|/* Re-enable the mouse. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vendortype
index|[
name|i
index|]
operator|.
name|probefunc
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vendortype
index|[
name|i
index|]
operator|.
name|model
operator|==
name|sc
operator|->
name|hw
operator|.
name|model
condition|)
operator|(
operator|*
name|vendortype
index|[
name|i
index|]
operator|.
name|probefunc
operator|)
operator|(
name|sc
operator|->
name|kbdc
operator|,
name|NULL
operator|)
expr_stmt|;
comment|/* set mouse parameters */
if|if
condition|(
name|mode
operator|!=
operator|(
name|mousemode_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|rate
operator|>
literal|0
condition|)
name|mode
operator|->
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|mode
operator|->
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|resolution
operator|>=
literal|0
condition|)
name|mode
operator|->
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|mode
operator|->
name|resolution
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mouse_mode
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
block|}
comment|/* Record sync on the next data packet we see. */
name|sc
operator|->
name|flags
operator||=
name|PSM_NEED_SYNCBITS
expr_stmt|;
comment|/* just check the status of the mouse */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (doinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|doopen
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|command_byte
parameter_list|)
block|{
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
comment|/* 	 * FIXME: Synaptics TouchPad seems to go back to Relative Mode with 	 * no obvious reason. Thus we check the current mode and restore the 	 * Absolute Mode if it was cleared. 	 * 	 * The previous hack at the end of psmprobe() wasn't efficient when 	 * moused(8) was restarted. 	 * 	 * A Reset (FF) or Set Defaults (F6) command would clear the 	 * Absolute Mode bit. But a verbose boot or debug.psm.loglevel=5 	 * doesn't show any evidence of such a command. 	 */
if|if
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
operator|==
name|MOUSE_MODEL_SYNAPTICS
condition|)
block|{
name|mouse_ext_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SYNAPTICS_VERSION_GE
argument_list|(
name|sc
operator|->
name|synhw
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|)
operator|||
name|stat
index|[
literal|1
index|]
operator|==
literal|0x47
operator|)
operator|&&
name|stat
index|[
literal|2
index|]
operator|==
literal|0x40
condition|)
block|{
comment|/* Set the mode byte -- request wmode where 			 * available */
if|if
condition|(
name|sc
operator|->
name|synhw
operator|.
name|capExtended
condition|)
name|mouse_ext_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0xc1
argument_list|)
expr_stmt|;
else|else
name|mouse_ext_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|5
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm%d: Synaptis Absolute Mode "
literal|"hopefully restored\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * A user may want to disable tap and drag gestures on a Synaptics 	 * TouchPad when it operates in Relative Mode. 	 */
if|if
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
operator|==
name|MOUSE_MODEL_GENERIC
condition|)
block|{
if|if
condition|(
name|tap_enabled
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Enable tap& drag gestures. We use a Mode Byte 			 * and clear the DisGest bit (see Â§2.5 of Synaptics 			 * TouchPad Interfacing Guide). 			 */
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm%d: enable tap and drag gestures\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|mouse_ext_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tap_enabled
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Disable tap& drag gestures. We use a Mode Byte 			 * and set the DisGest bit (see Â§2.5 of Synaptics 			 * TouchPad Interfacing Guide). 			 */
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm%d: disable tap and drag gestures\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|mouse_ext_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* enable the mouse device */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR: failed to enable the mouse because: 		 * 1) the mouse is faulty, 		 * 2) the mouse has been removed(!?) 		 * In the latter case, the keyboard may have hung, and need 		 * recovery procedure... 		 */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: we could reset the mouse here and try to enable 		 * it again. But it will take long time and it's not a good 		 * idea to disable the keyboard that long... 		 */
block|if (!doinitialize(sc,&sc->mode) || !enable_aux_dev(sc->kbdc)) { 			recover_from_error(sc->kbdc);
else|#
directive|else
block|{
endif|#
directive|endif
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
comment|/* mark this device is no longer available */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_VALID
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the device (doopen).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (doopen).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* enable the aux port and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_ENABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the aux interrupt (doopen).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* start the watchdog timer */
name|sc
operator|->
name|watchdog
operator|=
name|FALSE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|,
name|hz
operator|*
literal|2
argument_list|,
name|psmtimeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reinitialize
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|doinit
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* don't let anybody mess with the aux device */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block our watchdog timer */
name|sc
operator|->
name|watchdog
operator|=
name|FALSE
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
comment|/* save the current controller command byte */
name|empty_both_buffers
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm%d: current command byte: %04x (reinitialize).\n"
operator|,
name|sc
operator|->
name|unit
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
comment|/* enable the aux port but disable the aux interrupt and the keyboard */
if|if
condition|(
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: unable to set the command byte (reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* flush any data */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
condition|)
block|{
comment|/* this may fail; but never mind... */
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|flushpackets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|syncerrors
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pkterrors
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|lastinputerr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lastinputerr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* try to detect the aux device; are you still there? */
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doinit
condition|)
block|{
if|if
condition|(
name|doinitialize
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mode
argument_list|)
condition|)
block|{
comment|/* yes */
name|sc
operator|->
name|state
operator||=
name|PSM_VALID
expr_stmt|;
block|}
else|else
block|{
comment|/* the device has gone! */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_VALID
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: the aux device has gone! (reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* restore the driver state */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
operator|)
operator|&&
operator|(
name|err
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* enable the aux device and the port again */
name|err
operator|=
name|doopen
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the device "
literal|"(reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* restore the keyboard port and disable the aux port */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|c
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux port "
literal|"(reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
block|}
block|}
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* psm driver entry points */
end_comment

begin_function
specifier|static
name|void
name|psmidentify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|psmc
decl_stmt|;
name|device_t
name|psm
decl_stmt|;
name|u_long
name|irq
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* always add at least one child */
name|psm
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
name|KBDC_RID_AUX
argument_list|,
name|driver
operator|->
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|psm
operator|==
name|NULL
condition|)
return|return;
name|irq
operator|=
name|bus_get_resource_start
argument_list|(
name|psm
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|KBDC_RID_AUX
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|>
literal|0
condition|)
return|return;
comment|/* 	 * If the PS/2 mouse device has already been reported by ACPI or 	 * PnP BIOS, obtain the IRQ resource from it. 	 * (See psmcpnp_attach() below.) 	 */
name|psmc
operator|=
name|device_find_child
argument_list|(
name|device_get_parent
argument_list|(
name|parent
argument_list|)
argument_list|,
name|PSMCPNP_DRIVER_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|psmc
operator|==
name|NULL
condition|)
return|return;
name|irq
operator|=
name|bus_get_resource_start
argument_list|(
name|psmc
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|<=
literal|0
condition|)
return|return;
name|bus_delete_resource
argument_list|(
name|psmc
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|psm
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|KBDC_RID_AUX
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|endprobe
parameter_list|(
name|v
parameter_list|)
value|do {			\ 	if (bootverbose)			\ 		--verbose;			\ 	kbdc_set_device_mask(sc->kbdc, mask);	\ 	kbdc_lock(sc->kbdc, FALSE);		\ 	return (v);				\ } while (0)
end_define

begin_function
specifier|static
name|int
name|psmprobe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|kbdc_debug(TRUE);
endif|#
directive|endif
comment|/* see if IRQ is available */
name|rid
operator|=
name|KBDC_RID_AUX
expr_stmt|;
name|sc
operator|->
name|intr
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate IRQ\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|intr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|kbdc
operator|=
name|atkbdc_open
argument_list|(
name|device_get_unit
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|PSM_CONFIG_FLAGS
expr_stmt|;
comment|/* XXX: for backward compatibility */
if|#
directive|if
name|defined
argument_list|(
name|PSM_HOOKRESUME
argument_list|)
operator|||
name|defined
argument_list|(
name|PSM_HOOKAPM
argument_list|)
name|sc
operator|->
name|config
operator||=
ifdef|#
directive|ifdef
name|PSM_RESETAFTERSUSPEND
name|PSM_CONFIG_INITAFTERSUSPEND
expr_stmt|;
else|#
directive|else
name|PSM_CONFIG_HOOKRESUME
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PSM_HOOKRESUME | PSM_HOOKAPM */
name|sc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|++
name|verbose
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PS/2 Mouse"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: unable to lock the controller.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * NOTE: two bits in the command byte controls the operation of the 	 * aux port (mouse port): the aux port disable bit (bit 5) and the aux 	 * port interrupt (IRQ 12) enable bit (bit 2). 	 */
comment|/* discard anything left after the keyboard initialization */
name|empty_both_buffers
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* save the current command byte; it will be used later */
name|mask
operator|=
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|&
operator|~
name|KBD_AUX_CONTROL_BITS
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: current command byte:%04x\n"
argument_list|,
name|unit
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|printf
argument_list|(
literal|"psm%d: unable to get the current command byte value.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * disable the keyboard port while probing the aux port, which must be 	 * enabled during this routine 	 */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* 		 * this is CONTROLLER ERROR; I don't know how to recover 		 * from this error... 		 */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|write_controller_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBDC_ENABLE_AUX_PORT
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: `test_aux_port()' is designed to return with zero if the aux 	 * port exists and is functioning. However, some controllers appears 	 * to respond with zero even when the aux port doesn't exist. (It may 	 * be that this is only the case when the controller DOES have the aux 	 * port but the port is not wired on the motherboard.) The keyboard 	 * controllers without the port, such as the original AT, are 	 * supposed to return with an error code or simply time out. In any 	 * case, we have to continue probing the port even when the controller 	 * passes this test. 	 * 	 * XXX: some controllers erroneously return the error code 1, 2 or 3 	 * when it has a perfectly functional aux port. We have to ignore 	 * this error code. Even if the controller HAS error with the aux 	 * port, it will be detected later... 	 * XXX: another incompatible controller returns PSM_ACK (0xfa)... 	 */
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* ignore these errors */
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
name|PSM_ACK
case|:
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: strange result for test aux port "
literal|"(%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_IGNPORTERROR
condition|)
break|break;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NORESET
condition|)
block|{
comment|/* 		 * Don't try to reset the pointing device.  It may possibly be 		 * left in an unknown state, though... 		 */
block|}
else|else
block|{
comment|/* 		 * NOTE: some controllers appears to hang the `keyboard' when 		 * the aux port doesn't exist and `PSMC_RESET_DEV' is issued. 		 * 		 * Attempt to reset the controller twice -- this helps 		 * pierce through some KVM switches. The second reset 		 * is non-fatal. 		 */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to reset the aux "
literal|"device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to reset the aux device "
literal|"(2).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * both the aux port and the aux device are functioning, see if the 	 * device can be enabled. NOTE: when enabled, the device will start 	 * sending data; we shall immediately disable the device once we know 	 * the device can be enabled. 	 */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* save the default values after reset */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
condition|)
block|{
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|stat
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|stat
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* hardware information */
name|sc
operator|->
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_PS2
expr_stmt|;
comment|/* verify the device is a mouse */
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|get_aux_id
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_a_mouse
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
condition|)
block|{
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: unknown device type (%d).\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|hwid
condition|)
block|{
case|case
name|PSM_BALLPOINT_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_TRACKBALL
expr_stmt|;
break|break;
case|case
name|PSM_MOUSE_ID
case|:
case|case
name|PSM_INTELLI_ID
case|:
case|case
name|PSM_EXPLORER_ID
case|:
case|case
name|PSM_4DMOUSE_ID
case|:
case|case
name|PSM_4DPLUS_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_UNKNOWN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NOIDPROBE
condition|)
block|{
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|2
expr_stmt|;
name|i
operator|=
name|GENERIC_MOUSE_ENTRY
expr_stmt|;
block|}
else|else
block|{
comment|/* # of buttons */
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|get_mouse_buttons
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* other parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vendortype
index|[
name|i
index|]
operator|.
name|probefunc
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
operator|*
name|vendortype
index|[
name|i
index|]
operator|.
name|probefunc
operator|)
operator|(
name|sc
operator|->
name|kbdc
operator|,
name|sc
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"psm%d: found %s\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|vendortype
index|[
name|i
index|]
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|hw
operator|.
name|model
operator|=
name|vendortype
index|[
name|i
index|]
operator|.
name|model
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|level
operator|=
name|PSM_LEVEL_BASE
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|accelfactor
operator|=
operator|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_ACCEL
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NOCHECKSYNC
condition|)
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|vendortype
index|[
name|i
index|]
operator|.
name|syncmask
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_FORCETAP
condition|)
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|&=
operator|~
name|MOUSE_PS2_TAP
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* syncbits */
name|sc
operator|->
name|mode
operator|=
name|sc
operator|->
name|dflt_mode
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|vendortype
index|[
name|i
index|]
operator|.
name|packetsize
expr_stmt|;
comment|/* set mouse parameters */
if|#
directive|if
literal|0
comment|/* 	 * A version of Logitech FirstMouse+ won't report wheel movement, 	 * if SET_DEFAULTS is sent...  Don't use this command. 	 * This fix was found by Takashi Nishida. 	 */
block|i = send_aux_command(sc->kbdc, PSMC_SET_DEFAULTS); 	if (verbose>= 2) 		printf("psm%d: SET_DEFAULTS return code:%04x\n", unit, i);
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_RESOLUTION
condition|)
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
operator|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_RESOLUTION
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|>=
literal|0
condition|)
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|rate
operator|>
literal|0
condition|)
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Record sync on the next data packet we see. */
name|sc
operator|->
name|flags
operator||=
name|PSM_NEED_SYNCBITS
expr_stmt|;
comment|/* just check the status of the mouse */
comment|/* 	 * NOTE: XXX there are some arcane controller/mouse combinations out 	 * there, which hung the controller unless there is data transmission 	 * after ACK from the mouse. 	 */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to get status.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * When in its native mode, some mice operate with different 		 * default parameters than in the PS/2 compatible mode. 		 */
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|stat
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|stat
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* disable the aux port for now... */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* 		 * this is CONTROLLER ERROR; I don't know the proper way to 		 * recover from this error... 		 */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* done */
name|kbdc_set_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mask
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmattach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* Setup initial state */
name|sc
operator|->
name|state
operator|=
name|PSM_VALID
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|softcallout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup our interrupt handler */
name|rid
operator|=
name|KBDC_RID_AUX
expr_stmt|;
name|sc
operator|->
name|intr
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|intr
argument_list|,
name|INTR_TYPE_TTY
argument_list|,
name|NULL
argument_list|,
name|psmintr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|intr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Done */
name|sc
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"psm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|bdev
operator|=
name|make_dev
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"bpsm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* Some touchpad devices need full reinitialization after suspend. */
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
condition|)
block|{
case|case
name|MOUSE_MODEL_SYNAPTICS
case|:
case|case
name|MOUSE_MODEL_GLIDEPOINT
case|:
case|case
name|MOUSE_MODEL_VERSAPAD
case|:
name|sc
operator|->
name|config
operator||=
name|PSM_CONFIG_INITAFTERSUSPEND
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|sc
operator|->
name|synhw
operator|.
name|infoMajor
operator|>=
literal|4
operator|||
name|sc
operator|->
name|tphw
operator|>
literal|0
condition|)
name|sc
operator|->
name|config
operator||=
name|PSM_CONFIG_INITAFTERSUSPEND
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: model %s, device ID %d\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|model
argument_list|)
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"psm%d: model %s, device ID %d-%02x, %d buttons\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|model
argument_list|)
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&
literal|0x00ff
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|>>
literal|8
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|buttons
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: config:%08x, flags:%08x, packet size:%d\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|config
argument_list|,
name|sc
operator|->
name|flags
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|packetsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: syncmask:%02x, syncbits:%02x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmdetach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|rid
operator|=
name|KBDC_RID_AUX
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|intr
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|intr
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|bdev
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|softcallout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Get device data */
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Disallow multiple opens */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|device_busy
argument_list|(
name|devclass_get_device
argument_list|(
name|psm_devclass
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize state */
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|level
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|protocol
expr_stmt|;
name|sc
operator|->
name|watchdog
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|async
operator|=
name|NULL
expr_stmt|;
comment|/* flush the event queue */
name|sc
operator|->
name|queue
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pqueue_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pqueue_end
operator|=
literal|0
expr_stmt|;
comment|/* empty input buffer */
name|flushpackets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|syncerrors
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pkterrors
operator|=
literal|0
expr_stmt|;
comment|/* don't let timeout routines in the keyboard driver to poll the kbdc */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* save the current controller command byte */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* enable the aux port and temporalily disable the keyboard */
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR; do you know how to get out of this? */
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: unable to set the command byte (psmopen).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Now that the keyboard controller is told not to generate 	 * the keyboard and mouse interrupts, call `splx()' to allow 	 * the other tty interrupts. The clock interrupt may also occur, 	 * but timeout routines will be blocked by the poll flag set 	 * via `kbdc_lock()' 	 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* enable the mouse device */
name|err
operator|=
name|doopen
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
comment|/* done */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|sc
operator|->
name|state
operator||=
name|PSM_OPEN
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* don't let timeout routines in the keyboard driver to poll the kbdc */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* save the current controller command byte */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* disable the aux interrupt and temporalily disable the keyboard */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux int (psmclose).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* CONTROLLER ERROR; 		 * NOTE: we shall force our way through. Because the only 		 * ill effect we shall see is that we may not be able 		 * to read ACK from the mouse, and it doesn't matter much 		 * so long as the mouse will accept the DISABLE command. 		 */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* stop the watchdog timer */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* disable the aux device, port and interrupt */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
condition|)
block|{
if|if
condition|(
operator|!
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR; 			 * NOTE: we don't return (error) and continue, 			 * pretending we have successfully disabled the device. 			 * It's OK because the interrupt routine will discard 			 * any data from the mouse hereafter. 			 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the device (psmclose).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (psmclose).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* 		 * CONTROLLER ERROR; 		 * we shall ignore this error; see the above comment. 		 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux port (psmclose).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* clean up and sigio requests */
if|if
condition|(
name|sc
operator|->
name|async
operator|!=
name|NULL
condition|)
block|{
name|funsetown
argument_list|(
operator|&
name|sc
operator|->
name|async
argument_list|)
expr_stmt|;
name|sc
operator|->
name|async
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* close is almost always successful */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_OPEN
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|device_unbusy
argument_list|(
name|devclass_get_device
argument_list|(
name|psm_devclass
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tame_mouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|packetbuf_t
modifier|*
name|pb
parameter_list|,
name|mousestatus_t
modifier|*
name|status
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|static
name|u_char
name|butmapps2
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_PS2_BUTTON1DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|, 	}
decl_stmt|;
specifier|static
name|u_char
name|butmapmsc
index|[
literal|8
index|]
init|=
block|{
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON1UP
block|,
literal|0
block|, 	}
decl_stmt|;
name|int
name|mapped
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_BASE
condition|)
block|{
name|mapped
operator|=
name|status
operator|->
name|button
operator|&
operator|~
name|MOUSE_BUTTON4DOWN
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|button
operator|&
name|MOUSE_BUTTON4DOWN
condition|)
name|mapped
operator||=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
name|status
operator|->
name|button
operator|=
name|mapped
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_PS2_SYNC
operator||
name|butmapps2
index|[
name|mapped
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dx
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_XNEG
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dy
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_YNEG
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|MOUSE_PS2_PACKETSIZE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_STANDARD
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmapmsc
index|[
name|status
operator|->
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dx
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|i
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dy
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|i
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dz
argument_list|,
literal|127
argument_list|)
argument_list|,
operator|-
literal|128
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
operator|(
name|i
operator|-
operator|(
name|i
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|status
operator|->
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
return|return
operator|(
name|MOUSE_SYS_PACKETSIZE
operator|)
return|;
block|}
return|return
operator|(
name|pb
operator|->
name|inputbytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmread
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|u_char
name|buf
index|[
name|PSM_SMALLBUFSIZE
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* block until mouse activity occured */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|dev
operator|!=
name|sc
operator|->
name|bdev
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|sc
operator|->
name|state
operator||=
name|PSM_ASLP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"psmrea"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* the device disappeared! */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* copy data to the user land */
while|while
condition|(
operator|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|l
operator|=
name|imin
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|count
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
name|l
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|count
operator|-=
name|l
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|head
operator|+
name|l
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|l
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|block_mouse_data
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* this is CONTROLLER ERROR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * The device may be in the middle of status data transmission. 	 * The transmission will be interrupted, thus, incomplete status 	 * data must be discarded. Although the aux interrupt is disabled 	 * at the keyboard controller level, at most one aux interrupt 	 * may have already been pending and a data byte is in the 	 * output buffer; throw it away. Note that the second argument 	 * to `empty_aux_buffer()' is zero, so that the call will just 	 * flush the internal queue. 	 * `psmintr()' will be invoked after `splx()' if an interrupt is 	 * pending; it will see no data and returns immediately. 	 */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush the queue */
name|read_aux_data_no_wait
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* throw away data if any */
name|flushpackets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dropqueue
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|queue
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_SOFTARMED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_SOFTARMED
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|softcallout
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|pqueue_start
operator|=
name|sc
operator|->
name|pqueue_end
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flushpackets
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|dropqueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|pqueue
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|pqueue
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unblock_mouse_data
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * We may have seen a part of status data during `set_mouse_XXX()'. 	 * they have been queued; flush it. 	 */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* restore ports and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|c
operator|&
operator|(
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
operator|)
argument_list|)
condition|)
block|{
comment|/* 		 * CONTROLLER ERROR; this is serious, we may have 		 * been left with the inaccessible keyboard and 		 * the disabled mouse interrupt. 		 */
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmwrite
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|u_char
name|buf
index|[
name|PSM_SMALLBUFSIZE
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|<
name|PSM_LEVEL_NATIVE
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* copy data from the user land */
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|l
operator|=
name|imin
argument_list|(
name|PSM_SMALLBUFSIZE
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|l
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|VLOG
argument_list|(
literal|4
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: cmd 0x%x\n"
operator|,
name|buf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_aux_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm: cmd 0x%x failed.\n"
operator|,
name|buf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|reinitialize
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|mousestatus_t
name|status
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETVARS
argument_list|)
operator|)
name|mousevar_t
modifier|*
name|var
decl_stmt|;
endif|#
directive|endif
name|mousedata_t
modifier|*
name|data
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Perform IOCTL command */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|OLD_MOUSE_GETHWINFO
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|buttons
operator|=
name|sc
operator|->
name|hw
operator|.
name|buttons
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|iftype
operator|=
name|sc
operator|->
name|hw
operator|.
name|iftype
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|type
operator|=
name|sc
operator|->
name|hw
operator|.
name|type
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|hwid
operator|=
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&
literal|0x00ff
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETHWINFO
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_BASE
condition|)
operator|(
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_SYN_GETHWINFO
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|synhw
operator|.
name|infoMajor
operator|>=
literal|4
condition|)
operator|*
operator|(
name|synapticshw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|synhw
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLD_MOUSE_GETMODE
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
condition|)
block|{
case|case
name|PSM_LEVEL_BASE
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_STANDARD
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_NATIVE
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
block|}
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
expr_stmt|;
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|accelfactor
operator|=
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|PSM_NEED_SYNCBITS
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
condition|)
block|{
case|case
name|PSM_LEVEL_BASE
case|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_STANDARD
case|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_NATIVE
case|:
comment|/* FIXME: this isn't quite correct... XXX */
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLD_MOUSE_SETMODE
case|:
case|case
name|MOUSE_SETMODE
case|:
if|if
condition|(
name|cmd
operator|==
name|OLD_MOUSE_SETMODE
condition|)
block|{
name|mode
operator|.
name|rate
operator|=
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
expr_stmt|;
comment|/* 			 * resolution  old I/F   new I/F 			 * default        0         0 			 * low            1        -2 			 * medium low     2        -3 			 * medium high    3        -4 			 * high           4        -5 			 */
if|if
condition|(
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
operator|-
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|-
literal|1
expr_stmt|;
else|else
name|mode
operator|.
name|resolution
operator|=
literal|0
expr_stmt|;
name|mode
operator|.
name|accelfactor
operator|=
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|accelfactor
expr_stmt|;
name|mode
operator|.
name|level
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|mode
operator|=
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* adjust and validate parameters. */
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
name|UCHAR_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
name|UCHAR_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|200
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|100
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMHIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|50
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
name|MOUSE_RES_DEFAULT
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|<
literal|0
condition|)
comment|/* MOUSE_RES_LOW/MEDIUM/HIGH */
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|mode
operator|.
name|resolution
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|level
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
name|mode
operator|.
name|level
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|.
name|level
operator|<
name|PSM_LEVEL_MIN
operator|)
operator|||
operator|(
name|mode
operator|.
name|level
operator|>
name|PSM_LEVEL_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mode
operator|.
name|accelfactor
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
name|mode
operator|.
name|accelfactor
operator|=
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|accelfactor
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* don't allow anybody to poll the keyboard controller */
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* set mouse parameters */
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|mode
operator|.
name|rate
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|mode
operator|.
name|resolution
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
name|mode
operator|.
name|accelfactor
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
name|mode
operator|.
name|level
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETLEVEL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
break|break;
case|case
name|MOUSE_SETLEVEL
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<
name|PSM_LEVEL_MIN
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
name|PSM_LEVEL_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATUS
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|status
operator|=
name|sc
operator|->
name|status
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|status
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mousestatus_t
operator|*
operator|)
name|addr
operator|=
name|status
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETVARS
argument_list|)
operator|)
case|case
name|MOUSE_GETVARS
case|:
name|var
operator|=
operator|(
name|mousevar_t
operator|*
operator|)
name|addr
expr_stmt|;
name|bzero
argument_list|(
name|var
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|0
index|]
operator|=
name|MOUSE_VARS_PS2_SIG
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|config
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|flags
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_SETVARS
case|:
return|return
operator|(
name|ENODEV
operator|)
return|;
endif|#
directive|endif
comment|/* MOUSE_GETVARS */
case|case
name|MOUSE_READSTATE
case|:
case|case
name|MOUSE_READDATA
case|:
name|data
operator|=
operator|(
name|mousedata_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|data
operator|->
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|data
operator|->
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|data
operator|->
name|len
operator|=
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|data
operator|->
name|buf
argument_list|,
operator|(
name|cmd
operator|==
name|MOUSE_READDATA
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|data
operator|->
name|len
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETRESOLUTION
argument_list|)
operator|)
case|case
name|MOUSE_SETRESOLUTION
case|:
name|mode
operator|.
name|resolution
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
name|UCHAR_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|200
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|100
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMHIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|50
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
name|MOUSE_RES_DEFAULT
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
operator|-
literal|1
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|<
literal|0
condition|)
comment|/* MOUSE_RES_LOW/MEDIUM/HIGH */
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|mode
operator|.
name|resolution
expr_stmt|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|!=
name|mode
operator|.
name|resolution
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETRESOLUTION */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETRATE
argument_list|)
operator|)
case|case
name|MOUSE_SETRATE
case|:
name|mode
operator|.
name|rate
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
name|UCHAR_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|<
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
expr_stmt|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|rate
operator|!=
name|mode
operator|.
name|rate
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETRATE */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETSCALING
argument_list|)
operator|)
case|case
name|MOUSE_SETSCALING
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
literal|2
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|set_mouse_scaling
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETSCALING */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETHWID
argument_list|)
operator|)
case|case
name|MOUSE_GETHWID
case|:
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&=
operator|~
literal|0x00ff
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator||=
name|get_aux_id
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&
literal|0x00ff
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_GETHWID */
case|case
name|FIONBIO
case|:
case|case
name|FIOASYNC
case|:
break|break;
case|case
name|FIOSETOWN
case|:
name|error
operator|=
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|sc
operator|->
name|async
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOGETOWN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|fgetown
argument_list|(
operator|&
name|sc
operator|->
name|async
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|psmtimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|psm_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|watchdog
operator|&&
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|VLOG
argument_list|(
literal|4
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm%d: lost interrupt?\n"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|psmintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|watchdog
operator|=
name|TRUE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|,
name|hz
argument_list|,
name|psmtimeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add all sysctls under the debug.psm and hw.psm nodes */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|psm
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"ps/2 mouse"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|psm
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"ps/2 mouse"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|loglevel
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbosity level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmhz
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|hz
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmhz
argument_list|,
literal|0
argument_list|,
literal|"Frequency of the softcallout (in hz)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmerrsecs
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|errsecs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmerrsecs
argument_list|,
literal|0
argument_list|,
literal|"Number of seconds during which packets will dropped after a sync error"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmerrusecs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|errusecs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmerrusecs
argument_list|,
literal|0
argument_list|,
literal|"Microseconds to add to psmerrsecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmsecs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|secs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmsecs
argument_list|,
literal|0
argument_list|,
literal|"Max number of seconds between soft interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmusecs
init|=
literal|500000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|usecs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmusecs
argument_list|,
literal|0
argument_list|,
literal|"Microseconds to add to psmsecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pkterrthresh
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|pkterrthresh
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pkterrthresh
argument_list|,
literal|0
argument_list|,
literal|"Number of error packets allowed before reinitializing the mouse"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|tap_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tap_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable tap and drag gestures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|tap_threshold
init|=
name|PSM_TAP_THRESHOLD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|tap_threshold
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tap_threshold
argument_list|,
literal|0
argument_list|,
literal|"Button tap threshold"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|tap_timeout
init|=
name|PSM_TAP_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_psm
argument_list|,
name|OID_AUTO
argument_list|,
name|tap_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tap_timeout
argument_list|,
literal|0
argument_list|,
literal|"Tap timeout for touchpads"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|psmintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|c
decl_stmt|;
name|packetbuf_t
modifier|*
name|pb
decl_stmt|;
comment|/* read until there is nothing to read */
while|while
condition|(
operator|(
name|c
operator|=
name|read_aux_data_no_wait
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|pb
operator|=
operator|&
name|sc
operator|->
name|pqueue
index|[
name|sc
operator|->
name|pqueue_end
index|]
expr_stmt|;
comment|/* discard the byte if the device is not open */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pb
operator|->
name|inputbytes
operator|>
literal|0
operator|)
operator|&&
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|sc
operator|->
name|inputtimeout
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: delay too long; "
literal|"resetting byte count\n"
operator|)
argument_list|)
expr_stmt|;
name|pb
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|syncerrors
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pkterrors
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|inputtimeout
operator|.
name|tv_sec
operator|=
name|PSM_INPUT_TIMEOUT
operator|/
literal|1000000
expr_stmt|;
name|sc
operator|->
name|inputtimeout
operator|.
name|tv_usec
operator|=
name|PSM_INPUT_TIMEOUT
operator|%
literal|1000000
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|sc
operator|->
name|inputtimeout
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|pb
operator|->
name|ipacket
index|[
name|pb
operator|->
name|inputbytes
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_NATIVE
condition|)
block|{
name|VLOG
argument_list|(
literal|4
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: %02x\n"
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|syncerrors
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pkterrors
operator|=
literal|0
expr_stmt|;
goto|goto
name|next
goto|;
block|}
else|else
block|{
if|if
condition|(
name|pb
operator|->
name|inputbytes
operator|<
name|sc
operator|->
name|mode
operator|.
name|packetsize
condition|)
continue|continue;
name|VLOG
argument_list|(
literal|4
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: %02x %02x %02x %02x %02x %02x\n"
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|PSM_NEED_SYNCBITS
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
operator|(
name|c
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PSM_NEED_SYNCBITS
expr_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: Sync bytes now %04x,%04x\n"
operator|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|)
operator|!=
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
condition|)
block|{
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: out of sync "
literal|"(%04x != %04x) %d cmds since last error.\n"
operator|,
name|c
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|,
name|sc
operator|->
name|cmdcount
operator|-
name|sc
operator|->
name|lasterr
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lasterr
operator|=
name|sc
operator|->
name|cmdcount
expr_stmt|;
comment|/* 			 * The sync byte test is a weak measure of packet 			 * validity.  Conservatively discard any input yet 			 * to be seen by userland when we detect a sync 			 * error since there is a good chance some of 			 * the queued packets have undetected errors. 			 */
name|dropqueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|syncerrors
operator|==
literal|0
condition|)
name|sc
operator|->
name|pkterrors
operator|++
expr_stmt|;
operator|++
name|sc
operator|->
name|syncerrors
expr_stmt|;
name|sc
operator|->
name|lastinputerr
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|syncerrors
operator|>=
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|*
literal|2
operator|||
name|sc
operator|->
name|pkterrors
operator|>=
name|pkterrthresh
condition|)
block|{
comment|/* 				 * If we've failed to find a single sync byte 				 * in 2 packets worth of data, or we've seen 				 * persistent packet errors during the 				 * validation period, reinitialize the mouse 				 * in hopes of returning it to the expected 				 * mode. 				 */
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: reset the mouse.\n"
operator|)
argument_list|)
expr_stmt|;
name|reinitialize
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|syncerrors
operator|==
name|sc
operator|->
name|mode
operator|.
name|packetsize
condition|)
block|{
comment|/* 				 * Try a soft reset after searching for a sync 				 * byte through a packet length of bytes. 				 */
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: re-enable the mouse.\n"
operator|)
argument_list|)
expr_stmt|;
name|pb
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: discard a byte (%d)\n"
operator|,
name|sc
operator|->
name|syncerrors
operator|)
argument_list|)
expr_stmt|;
name|pb
operator|->
name|inputbytes
operator|--
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
argument_list|,
operator|&
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
argument_list|,
name|pb
operator|->
name|inputbytes
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * We have what appears to be a valid packet. 		 * Reset the error counters. 		 */
name|sc
operator|->
name|syncerrors
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Drop even good packets if they occur within a timeout 		 * period of a sync error.  This allows the detection of 		 * a change in the mouse's packet mode without exposing 		 * erratic mouse behavior to the user.  Some KVMs forget 		 * enhanced mouse modes during switch events. 		 */
if|if
condition|(
operator|!
name|timeelapsed
argument_list|(
operator|&
name|sc
operator|->
name|lastinputerr
argument_list|,
name|psmerrsecs
argument_list|,
name|psmerrusecs
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
name|pb
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Now that we're out of the validation period, reset 		 * the packet error count. 		 */
name|sc
operator|->
name|pkterrors
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|cmdcount
operator|++
expr_stmt|;
name|next
label|:
if|if
condition|(
operator|++
name|sc
operator|->
name|pqueue_end
operator|>=
name|PSM_PACKETQUEUE
condition|)
name|sc
operator|->
name|pqueue_end
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we've filled the queue then call the softintr ourselves, 		 * otherwise schedule the interrupt for later. 		 */
if|if
condition|(
operator|!
name|timeelapsed
argument_list|(
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|,
name|psmsecs
argument_list|,
name|psmusecs
argument_list|,
operator|&
name|now
argument_list|)
operator|||
operator|(
name|sc
operator|->
name|pqueue_end
operator|==
name|sc
operator|->
name|pqueue_start
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_SOFTARMED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_SOFTARMED
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|softcallout
argument_list|)
expr_stmt|;
block|}
name|psmsoftintr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_SOFTARMED
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator||=
name|PSM_SOFTARMED
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|softcallout
argument_list|,
name|psmhz
operator|<
literal|1
condition|?
literal|1
else|:
operator|(
name|hz
operator|/
name|psmhz
operator|)
argument_list|,
name|psmsoftintr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|proc_mmanplus
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|packetbuf_t
modifier|*
name|pb
parameter_list|,
name|mousestatus_t
modifier|*
name|ms
parameter_list|,
name|int
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|z
parameter_list|)
block|{
comment|/* 	 * PS2++ protocol packet 	 * 	 *          b7 b6 b5 b4 b3 b2 b1 b0 	 * byte 1:  *  1  p3 p2 1  *  *  * 	 * byte 2:  c1 c2 p1 p0 d1 d0 1  0 	 * 	 * p3-p0: packet type 	 * c1, c2: c1& c2 == 1, if p2 == 0 	 *         c1& c2 == 0, if p2 == 1 	 * 	 * packet type: 0 (device type) 	 * See comments in enable_mmanplus() below. 	 * 	 * packet type: 1 (wheel data) 	 * 	 *          b7 b6 b5 b4 b3 b2 b1 b0 	 * byte 3:  h  *  B5 B4 s  d2 d1 d0 	 * 	 * h: 1, if horizontal roller data 	 *    0, if vertical roller data 	 * B4, B5: button 4 and 5 	 * s: sign bit 	 * d2-d0: roller data 	 * 	 * packet type: 2 (reserved) 	 */
if|if
condition|(
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2PLUS_SYNCMASK
operator|)
operator|==
name|MOUSE_PS2PLUS_SYNC
operator|)
operator|&&
operator|(
name|abs
argument_list|(
operator|*
name|x
argument_list|)
operator|>
literal|191
operator|)
operator|&&
name|MOUSE_PS2PLUS_CHECKBITS
argument_list|(
name|pb
operator|->
name|ipacket
argument_list|)
condition|)
block|{
comment|/* 		 * the extended data packet encodes button 		 * and wheel events 		 */
switch|switch
condition|(
name|MOUSE_PS2PLUS_PACKET_TYPE
argument_list|(
name|pb
operator|->
name|ipacket
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* wheel data packet */
operator|*
name|x
operator|=
operator|*
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x80
condition|)
block|{
comment|/* XXX horizontal roller count - ignore it */
empty_stmt|;
block|}
else|else
block|{
comment|/* vertical roller count */
operator|*
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_ZNEG
operator|)
condition|?
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
name|ms
operator|->
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|ms
operator|->
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * this packet type is reserved by 			 * Logitech... 			 */
comment|/* 			 * IBM ScrollPoint Mouse uses this 			 * packet type to encode both vertical 			 * and horizontal scroll movement. 			 */
operator|*
name|x
operator|=
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* horizontal count */
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x0f
condition|)
operator|*
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_SPOINT_WNEG
operator|)
condition|?
operator|-
literal|2
else|:
literal|2
expr_stmt|;
comment|/* vertical count */
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0xf0
condition|)
operator|*
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_SPOINT_ZNEG
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* device type packet - shouldn't happen */
comment|/* FALLTHROUGH */
default|default:
operator|*
name|x
operator|=
operator|*
name|y
operator|=
literal|0
expr_stmt|;
name|ms
operator|->
name|button
operator|=
name|ms
operator|->
name|obutton
expr_stmt|;
name|VLOG
argument_list|(
literal|1
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psmintr: unknown PS2++ packet "
literal|"type %d: 0x%02x 0x%02x 0x%02x\n"
operator|,
name|MOUSE_PS2PLUS_PACKET_TYPE
argument_list|(
name|pb
operator|->
name|ipacket
argument_list|)
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|,
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* preserve button states */
name|ms
operator|->
name|button
operator||=
name|ms
operator|->
name|obutton
operator|&
name|MOUSE_EXTBUTTONS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|proc_synaptics
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|packetbuf_t
modifier|*
name|pb
parameter_list|,
name|mousestatus_t
modifier|*
name|ms
parameter_list|,
name|int
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|z
parameter_list|)
block|{
specifier|static
name|int
name|touchpad_buttons
decl_stmt|;
specifier|static
name|int
name|guest_buttons
decl_stmt|;
name|int
name|w
decl_stmt|,
name|x0
decl_stmt|,
name|y0
decl_stmt|;
comment|/* TouchPad PS/2 absolute mode message format 	 * 	 *  Bits:        7   6   5   4   3   2   1   0 (LSB) 	 *  ------------------------------------------------ 	 *  ipacket[0]:  1   0  W3  W2   0  W1   R   L 	 *  ipacket[1]: Yb  Ya  Y9  Y8  Xb  Xa  X9  X8 	 *  ipacket[2]: Z7  Z6  Z5  Z4  Z3  Z2  Z1  Z0 	 *  ipacket[3]:  1   1  Yc  Xc   0  W0   D   U 	 *  ipacket[4]: X7  X6  X5  X4  X3  X2  X1  X0 	 *  ipacket[5]: Y7  Y6  Y5  Y4  Y3  Y2  Y1  Y0 	 * 	 * Legend: 	 *  L: left physical mouse button 	 *  R: right physical mouse button 	 *  D: down button 	 *  U: up button 	 *  W: "wrist" value 	 *  X: x position 	 *  Y: y position 	 *  Z: pressure 	 * 	 * Absolute reportable limits:    0 - 6143. 	 * Typical bezel limits:       1472 - 5472. 	 * Typical edge marings:       1632 - 5312. 	 * 	 * w = 3 Passthrough Packet 	 * 	 * Byte 2,5,6 == Byte 1,2,3 of "Guest" 	 */
if|if
condition|(
operator|!
name|synaptics_support
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Sanity check for out of sync packets. */
if|if
condition|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0xc8
operator|)
operator|!=
literal|0x80
operator|||
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0xc8
operator|)
operator|!=
literal|0xc0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|x
operator|=
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Pressure value. 	 * Interpretation: 	 *   z = 0      No finger contact 	 *   z = 10     Finger hovering near the pad 	 *   z = 30     Very light finger contact 	 *   z = 80     Normal finger contact 	 *   z = 110    Very heavy finger contact 	 *   z = 200    Finger lying flat on pad surface 	 *   z = 255    Maximum reportable Z 	 */
operator|*
name|z
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * Finger width value 	 * Interpretation: 	 *   w = 0      Two finger on the pad (capMultiFinger needed) 	 *   w = 1      Three or more fingers (capMultiFinger needed) 	 *   w = 2      Pen (instead of finger) (capPen needed) 	 *   w = 3      Reserved (passthrough?) 	 *   w = 4-7    Finger of normal width (capPalmDetect needed) 	 *   w = 8-14   Very wide finger or palm (capPalmDetect needed) 	 *   w = 15     Maximum reportable width (capPalmDetect needed) 	 */
comment|/* XXX Is checking capExtended enough? */
if|if
condition|(
name|sc
operator|->
name|synhw
operator|.
name|capExtended
condition|)
name|w
operator|=
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x30
operator|)
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x04
operator|)
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x04
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
else|else
block|{
comment|/* Assume a finger of regular width. */
name|w
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Handle packets from the guest device */
comment|/* XXX Documentation? */
if|if
condition|(
name|w
operator|==
literal|3
operator|&&
name|sc
operator|->
name|synhw
operator|.
name|capPassthrough
condition|)
block|{
operator|*
name|x
operator|=
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x10
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|)
expr_stmt|;
operator|*
name|y
operator|=
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x20
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
operator|)
expr_stmt|;
operator|*
name|z
operator|=
literal|0
expr_stmt|;
name|guest_buttons
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x01
condition|)
name|guest_buttons
operator||=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x04
condition|)
name|guest_buttons
operator||=
name|MOUSE_BUTTON2DOWN
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x02
condition|)
name|guest_buttons
operator||=
name|MOUSE_BUTTON3DOWN
expr_stmt|;
name|ms
operator|->
name|button
operator|=
name|touchpad_buttons
operator||
name|guest_buttons
expr_stmt|;
goto|goto
name|SYNAPTICS_END
goto|;
block|}
comment|/* Button presses */
name|touchpad_buttons
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x02
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON3DOWN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|synhw
operator|.
name|capExtended
operator|&&
name|sc
operator|->
name|synhw
operator|.
name|capFourButtons
condition|)
block|{
if|if
condition|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x01
operator|)
operator|&&
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON4DOWN
expr_stmt|;
if|if
condition|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x02
operator|)
operator|&&
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
operator|==
literal|0
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON5DOWN
expr_stmt|;
block|}
comment|/* 	 * In newer pads - bit 0x02 in the third byte of 	 * the packet indicates that we have an extended 	 * button press. 	 */
comment|/* XXX Documentation? */
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x02
condition|)
block|{
comment|/* 		 * if directional_scrolls is not 1, we treat any of 		 * the scrolling directions as middle-click. 		 */
if|if
condition|(
name|sc
operator|->
name|syninfo
operator|.
name|directional_scrolls
condition|)
block|{
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|&
literal|0x01
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON4DOWN
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
operator|&
literal|0x01
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON5DOWN
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|&
literal|0x02
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON6DOWN
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
operator|&
literal|0x02
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON7DOWN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|&
literal|0x0F
operator|)
operator|||
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
operator|&
literal|0x0F
operator|)
condition|)
name|touchpad_buttons
operator||=
name|MOUSE_BUTTON2DOWN
expr_stmt|;
block|}
block|}
name|ms
operator|->
name|button
operator|=
name|touchpad_buttons
operator||
name|guest_buttons
expr_stmt|;
comment|/* Check pressure to detect a real wanted action on the 	 * touchpad. */
if|if
condition|(
operator|*
name|z
operator|>=
name|sc
operator|->
name|syninfo
operator|.
name|min_pressure
condition|)
block|{
name|synapticsaction_t
modifier|*
name|synaction
decl_stmt|;
name|int
name|cursor
decl_stmt|,
name|peer
decl_stmt|,
name|window
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|dxp
decl_stmt|,
name|dyp
decl_stmt|;
name|int
name|max_width
decl_stmt|,
name|max_pressure
decl_stmt|;
name|int
name|margin_top
decl_stmt|,
name|margin_right
decl_stmt|,
name|margin_bottom
decl_stmt|,
name|margin_left
decl_stmt|;
name|int
name|na_top
decl_stmt|,
name|na_right
decl_stmt|,
name|na_bottom
decl_stmt|,
name|na_left
decl_stmt|;
name|int
name|window_min
decl_stmt|,
name|window_max
decl_stmt|;
name|int
name|multiplicator
decl_stmt|;
name|int
name|weight_current
decl_stmt|,
name|weight_previous
decl_stmt|,
name|weight_len_squared
decl_stmt|;
name|int
name|div_min
decl_stmt|,
name|div_max
decl_stmt|,
name|div_len
decl_stmt|;
name|int
name|vscroll_hor_area
decl_stmt|,
name|vscroll_ver_area
decl_stmt|;
name|int
name|len
decl_stmt|,
name|weight_prev_x
decl_stmt|,
name|weight_prev_y
decl_stmt|;
name|int
name|div_max_x
decl_stmt|,
name|div_max_y
decl_stmt|,
name|div_x
decl_stmt|,
name|div_y
decl_stmt|;
comment|/* Read sysctl. */
comment|/* XXX Verify values? */
name|max_width
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|max_width
expr_stmt|;
name|max_pressure
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|max_pressure
expr_stmt|;
name|margin_top
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|margin_top
expr_stmt|;
name|margin_right
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|margin_right
expr_stmt|;
name|margin_bottom
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|margin_bottom
expr_stmt|;
name|margin_left
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|margin_left
expr_stmt|;
name|na_top
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|na_top
expr_stmt|;
name|na_right
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|na_right
expr_stmt|;
name|na_bottom
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|na_bottom
expr_stmt|;
name|na_left
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|na_left
expr_stmt|;
name|window_min
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|window_min
expr_stmt|;
name|window_max
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|window_max
expr_stmt|;
name|multiplicator
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|multiplicator
expr_stmt|;
name|weight_current
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|weight_current
expr_stmt|;
name|weight_previous
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|weight_previous
expr_stmt|;
name|weight_len_squared
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|weight_len_squared
expr_stmt|;
name|div_min
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|div_min
expr_stmt|;
name|div_max
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|div_max
expr_stmt|;
name|div_len
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|div_len
expr_stmt|;
name|vscroll_hor_area
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_hor_area
expr_stmt|;
name|vscroll_ver_area
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_ver_area
expr_stmt|;
comment|/* Palm detection. */
if|if
condition|(
operator|!
operator|(
operator|(
name|sc
operator|->
name|synhw
operator|.
name|capMultiFinger
operator|&&
operator|(
name|w
operator|==
literal|0
operator|||
name|w
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
name|sc
operator|->
name|synhw
operator|.
name|capPalmDetect
operator|&&
name|w
operator|>=
literal|4
operator|&&
name|w
operator|<=
name|max_width
operator|)
operator|||
operator|(
operator|!
name|sc
operator|->
name|synhw
operator|.
name|capPalmDetect
operator|&&
operator|*
name|z
operator|<=
name|max_pressure
operator|)
operator|||
operator|(
name|sc
operator|->
name|synhw
operator|.
name|capPen
operator|&&
name|w
operator|==
literal|2
operator|)
operator|)
condition|)
block|{
comment|/* 			 * We consider the packet irrelevant for the current 			 * action when: 			 *  - the width isn't comprised in: 			 *    [4; max_width] 			 *  - the pressure isn't comprised in: 			 *    [min_pressure; max_pressure] 			 *  - pen aren't supported but w is 2 			 * 			 *  Note that this doesn't terminate the current action. 			 */
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: palm detected! (%d)\n"
operator|,
name|w
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|SYNAPTICS_END
goto|;
block|}
comment|/* Read current absolute position. */
name|x0
operator|=
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x10
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x0f
operator|)
operator|<<
literal|8
operator|)
operator||
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
expr_stmt|;
name|y0
operator|=
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x20
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator|)
operator||
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
expr_stmt|;
name|synaction
operator|=
operator|&
operator|(
name|sc
operator|->
name|synaction
operator|)
expr_stmt|;
comment|/* 		 * If the action is just beginning, init the structure and 		 * compute tap timeout. 		 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|PSM_FLAGS_FINGERDOWN
operator|)
condition|)
block|{
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: ----\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Store the first point of this action. */
name|synaction
operator|->
name|start_x
operator|=
name|x0
expr_stmt|;
name|synaction
operator|->
name|start_y
operator|=
name|y0
expr_stmt|;
name|dx
operator|=
name|dy
operator|=
literal|0
expr_stmt|;
comment|/* Initialize queue. */
name|synaction
operator|->
name|queue_cursor
operator|=
name|SYNAPTICS_PACKETQUEUE
expr_stmt|;
name|synaction
operator|->
name|queue_len
operator|=
literal|0
expr_stmt|;
name|synaction
operator|->
name|window_min
operator|=
name|window_min
expr_stmt|;
comment|/* Reset average. */
name|synaction
operator|->
name|avg_dx
operator|=
literal|0
expr_stmt|;
name|synaction
operator|->
name|avg_dy
operator|=
literal|0
expr_stmt|;
comment|/* Reset squelch. */
name|synaction
operator|->
name|squelch_x
operator|=
literal|0
expr_stmt|;
name|synaction
operator|->
name|squelch_y
operator|=
literal|0
expr_stmt|;
comment|/* Reset pressure peak. */
name|sc
operator|->
name|zmax
operator|=
literal|0
expr_stmt|;
comment|/* Reset fingers count. */
name|synaction
operator|->
name|fingers_nb
operator|=
literal|0
expr_stmt|;
comment|/* Reset virtual scrolling state. */
name|synaction
operator|->
name|in_vscroll
operator|=
literal|0
expr_stmt|;
comment|/* Compute tap timeout. */
name|sc
operator|->
name|taptimeout
operator|.
name|tv_sec
operator|=
name|tap_timeout
operator|/
literal|1000000
expr_stmt|;
name|sc
operator|->
name|taptimeout
operator|.
name|tv_usec
operator|=
name|tap_timeout
operator|%
literal|1000000
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|sc
operator|->
name|taptimeout
argument_list|,
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
block|}
else|else
block|{
comment|/* Calculate the current delta. */
name|cursor
operator|=
name|synaction
operator|->
name|queue_cursor
expr_stmt|;
name|dx
operator|=
name|x0
operator|-
name|synaction
operator|->
name|queue
index|[
name|cursor
index|]
operator|.
name|x
expr_stmt|;
name|dy
operator|=
name|y0
operator|-
name|synaction
operator|->
name|queue
index|[
name|cursor
index|]
operator|.
name|y
expr_stmt|;
block|}
comment|/* If in tap-hold, add the recorded button. */
if|if
condition|(
name|synaction
operator|->
name|in_taphold
condition|)
name|ms
operator|->
name|button
operator||=
name|synaction
operator|->
name|tap_button
expr_stmt|;
comment|/* 		 * From now on, we can use the SYNAPTICS_END label to skip 		 * the current packet. 		 */
comment|/* 		 * Limit the coordinates to the specified margins because 		 * this area isn't very reliable. 		 */
if|if
condition|(
name|x0
operator|<=
name|margin_left
condition|)
name|x0
operator|=
name|margin_left
expr_stmt|;
elseif|else
if|if
condition|(
name|x0
operator|>=
literal|6143
operator|-
name|margin_right
condition|)
name|x0
operator|=
literal|6143
operator|-
name|margin_right
expr_stmt|;
if|if
condition|(
name|y0
operator|<=
name|margin_bottom
condition|)
name|y0
operator|=
name|margin_bottom
expr_stmt|;
elseif|else
if|if
condition|(
name|y0
operator|>=
literal|6143
operator|-
name|margin_top
condition|)
name|y0
operator|=
literal|6143
operator|-
name|margin_top
expr_stmt|;
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: ipacket: [%d, %d], %d, %d\n"
operator|,
name|x0
operator|,
name|y0
operator|,
operator|*
name|z
operator|,
name|w
operator|)
argument_list|)
expr_stmt|;
comment|/* Queue this new packet. */
name|cursor
operator|=
name|SYNAPTICS_QUEUE_CURSOR
argument_list|(
name|synaction
operator|->
name|queue_cursor
operator|-
literal|1
argument_list|)
expr_stmt|;
name|synaction
operator|->
name|queue
index|[
name|cursor
index|]
operator|.
name|x
operator|=
name|x0
expr_stmt|;
name|synaction
operator|->
name|queue
index|[
name|cursor
index|]
operator|.
name|y
operator|=
name|y0
expr_stmt|;
name|synaction
operator|->
name|queue_cursor
operator|=
name|cursor
expr_stmt|;
if|if
condition|(
name|synaction
operator|->
name|queue_len
operator|<
name|SYNAPTICS_PACKETQUEUE
condition|)
name|synaction
operator|->
name|queue_len
operator|++
expr_stmt|;
name|VLOG
argument_list|(
literal|5
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: cursor[%d]: x=%d, y=%d, dx=%d, dy=%d\n"
operator|,
name|cursor
operator|,
name|x0
operator|,
name|y0
operator|,
name|dx
operator|,
name|dy
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * For tap, we keep the maximum number of fingers and the 		 * pressure peak. Also with multiple fingers, we increase 		 * the minimum window. 		 */
switch|switch
condition|(
name|w
condition|)
block|{
case|case
literal|1
case|:
comment|/* Three or more fingers. */
name|synaction
operator|->
name|fingers_nb
operator|=
name|imax
argument_list|(
literal|3
argument_list|,
name|synaction
operator|->
name|fingers_nb
argument_list|)
expr_stmt|;
name|synaction
operator|->
name|window_min
operator|=
name|window_max
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Two fingers. */
name|synaction
operator|->
name|fingers_nb
operator|=
name|imax
argument_list|(
literal|2
argument_list|,
name|synaction
operator|->
name|fingers_nb
argument_list|)
expr_stmt|;
name|synaction
operator|->
name|window_min
operator|=
name|window_max
expr_stmt|;
break|break;
default|default:
comment|/* One finger or undetectable. */
name|synaction
operator|->
name|fingers_nb
operator|=
name|imax
argument_list|(
literal|1
argument_list|,
name|synaction
operator|->
name|fingers_nb
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|zmax
operator|=
name|imax
argument_list|(
operator|*
name|z
argument_list|,
name|sc
operator|->
name|zmax
argument_list|)
expr_stmt|;
comment|/* Do we have enough packets to consider this a movement? */
if|if
condition|(
name|synaction
operator|->
name|queue_len
operator|<
name|synaction
operator|->
name|window_min
condition|)
goto|goto
name|SYNAPTICS_END
goto|;
comment|/* Is a scrolling action occuring? */
if|if
condition|(
operator|!
name|synaction
operator|->
name|in_taphold
operator|&&
operator|!
name|synaction
operator|->
name|in_vscroll
condition|)
block|{
comment|/* 			 * A scrolling action must not conflict with a tap 			 * action. Here are the conditions to consider a 			 * scrolling action: 			 *  - the action in a configurable area 			 *  - one of the following: 			 *     . the distance between the last packet and the 			 *       first should be above a configurable minimum 			 *     . tap timed out 			 */
name|dxp
operator|=
name|abs
argument_list|(
name|synaction
operator|->
name|queue
index|[
name|synaction
operator|->
name|queue_cursor
index|]
operator|.
name|x
operator|-
name|synaction
operator|->
name|start_x
argument_list|)
expr_stmt|;
name|dyp
operator|=
name|abs
argument_list|(
name|synaction
operator|->
name|queue
index|[
name|synaction
operator|->
name|queue_cursor
index|]
operator|.
name|y
operator|-
name|synaction
operator|->
name|start_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|,
operator|&
name|sc
operator|->
name|taptimeout
argument_list|,
operator|>
argument_list|)
operator|||
name|dxp
operator|>=
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_min_delta
operator|||
name|dyp
operator|>=
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_min_delta
condition|)
block|{
comment|/* Check for horizontal scrolling. */
if|if
condition|(
operator|(
name|vscroll_hor_area
operator|>
literal|0
operator|&&
name|synaction
operator|->
name|start_y
operator|<=
name|vscroll_hor_area
operator|)
operator|||
operator|(
name|vscroll_hor_area
operator|<
literal|0
operator|&&
name|synaction
operator|->
name|start_y
operator|>=
literal|6143
operator|+
name|vscroll_hor_area
operator|)
condition|)
name|synaction
operator|->
name|in_vscroll
operator|+=
literal|2
expr_stmt|;
comment|/* Check for vertical scrolling. */
if|if
condition|(
operator|(
name|vscroll_ver_area
operator|>
literal|0
operator|&&
name|synaction
operator|->
name|start_x
operator|<=
name|vscroll_ver_area
operator|)
operator|||
operator|(
name|vscroll_ver_area
operator|<
literal|0
operator|&&
name|synaction
operator|->
name|start_x
operator|>=
literal|6143
operator|+
name|vscroll_ver_area
operator|)
condition|)
name|synaction
operator|->
name|in_vscroll
operator|+=
literal|1
expr_stmt|;
comment|/* Avoid conflicts if area overlaps. */
if|if
condition|(
name|synaction
operator|->
name|in_vscroll
operator|==
literal|3
condition|)
name|synaction
operator|->
name|in_vscroll
operator|=
operator|(
name|dxp
operator|>
name|dyp
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
name|VLOG
argument_list|(
literal|5
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: virtual scrolling: %s "
literal|"(direction=%d, dxp=%d, dyp=%d)\n"
operator|,
name|synaction
operator|->
name|in_vscroll
condition|?
literal|"YES"
else|:
literal|"NO"
operator|,
name|synaction
operator|->
name|in_vscroll
operator|,
name|dxp
operator|,
name|dyp
operator|)
argument_list|)
expr_stmt|;
block|}
name|weight_prev_x
operator|=
name|weight_prev_y
operator|=
name|weight_previous
expr_stmt|;
name|div_max_x
operator|=
name|div_max_y
operator|=
name|div_max
expr_stmt|;
if|if
condition|(
name|synaction
operator|->
name|in_vscroll
condition|)
block|{
comment|/* Dividers are different with virtual scrolling. */
name|div_min
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_div_min
expr_stmt|;
name|div_max_x
operator|=
name|div_max_y
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_div_max
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * There's a lot of noise in coordinates when 			 * the finger is on the touchpad's borders. When 			 * using this area, we apply a special weight and 			 * div. 			 */
if|if
condition|(
name|x0
operator|<=
name|na_left
operator|||
name|x0
operator|>=
literal|6143
operator|-
name|na_right
condition|)
block|{
name|weight_prev_x
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|weight_previous_na
expr_stmt|;
name|div_max_x
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|div_max_na
expr_stmt|;
block|}
if|if
condition|(
name|y0
operator|<=
name|na_bottom
operator|||
name|y0
operator|>=
literal|6143
operator|-
name|na_top
condition|)
block|{
name|weight_prev_y
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|weight_previous_na
expr_stmt|;
name|div_max_y
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|div_max_na
expr_stmt|;
block|}
block|}
comment|/* 		 * Calculate weights for the average operands and 		 * the divisor. Both depend on the distance between 		 * the current packet and a previous one (based on the 		 * window width). 		 */
name|window
operator|=
name|imin
argument_list|(
name|synaction
operator|->
name|queue_len
argument_list|,
name|window_max
argument_list|)
expr_stmt|;
name|peer
operator|=
name|SYNAPTICS_QUEUE_CURSOR
argument_list|(
name|cursor
operator|+
name|window
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dxp
operator|=
name|abs
argument_list|(
name|x0
operator|-
name|synaction
operator|->
name|queue
index|[
name|peer
index|]
operator|.
name|x
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dyp
operator|=
name|abs
argument_list|(
name|y0
operator|-
name|synaction
operator|->
name|queue
index|[
name|peer
index|]
operator|.
name|y
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|=
operator|(
name|dxp
operator|*
name|dxp
operator|)
operator|+
operator|(
name|dyp
operator|*
name|dyp
operator|)
expr_stmt|;
name|weight_prev_x
operator|=
name|imin
argument_list|(
name|weight_prev_x
argument_list|,
name|weight_len_squared
operator|*
name|weight_prev_x
operator|/
name|len
argument_list|)
expr_stmt|;
name|weight_prev_y
operator|=
name|imin
argument_list|(
name|weight_prev_y
argument_list|,
name|weight_len_squared
operator|*
name|weight_prev_y
operator|/
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|dxp
operator|+
name|dyp
operator|)
operator|/
literal|2
expr_stmt|;
name|div_x
operator|=
name|div_len
operator|*
name|div_max_x
operator|/
name|len
expr_stmt|;
name|div_x
operator|=
name|imin
argument_list|(
name|div_max_x
argument_list|,
name|div_x
argument_list|)
expr_stmt|;
name|div_x
operator|=
name|imax
argument_list|(
name|div_min
argument_list|,
name|div_x
argument_list|)
expr_stmt|;
name|div_y
operator|=
name|div_len
operator|*
name|div_max_y
operator|/
name|len
expr_stmt|;
name|div_y
operator|=
name|imin
argument_list|(
name|div_max_y
argument_list|,
name|div_y
argument_list|)
expr_stmt|;
name|div_y
operator|=
name|imax
argument_list|(
name|div_min
argument_list|,
name|div_y
argument_list|)
expr_stmt|;
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: peer=%d, len=%d, weight=%d/%d, div=%d/%d\n"
operator|,
name|peer
operator|,
name|len
operator|,
name|weight_prev_x
operator|,
name|weight_prev_y
operator|,
name|div_x
operator|,
name|div_y
operator|)
argument_list|)
expr_stmt|;
comment|/* Compute averages. */
name|synaction
operator|->
name|avg_dx
operator|=
operator|(
name|weight_current
operator|*
name|dx
operator|*
name|multiplicator
operator|+
name|weight_prev_x
operator|*
name|synaction
operator|->
name|avg_dx
operator|)
operator|/
operator|(
name|weight_current
operator|+
name|weight_prev_x
operator|)
expr_stmt|;
name|synaction
operator|->
name|avg_dy
operator|=
operator|(
name|weight_current
operator|*
name|dy
operator|*
name|multiplicator
operator|+
name|weight_prev_y
operator|*
name|synaction
operator|->
name|avg_dy
operator|)
operator|/
operator|(
name|weight_current
operator|+
name|weight_prev_y
operator|)
expr_stmt|;
name|VLOG
argument_list|(
literal|5
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: avg_dx~=%d, avg_dy~=%d\n"
operator|,
name|synaction
operator|->
name|avg_dx
operator|/
name|multiplicator
operator|,
name|synaction
operator|->
name|avg_dy
operator|/
name|multiplicator
operator|)
argument_list|)
expr_stmt|;
comment|/* Use these averages to calculate x& y. */
name|synaction
operator|->
name|squelch_x
operator|+=
name|synaction
operator|->
name|avg_dx
expr_stmt|;
operator|*
name|x
operator|=
name|synaction
operator|->
name|squelch_x
operator|/
operator|(
name|div_x
operator|*
name|multiplicator
operator|)
expr_stmt|;
name|synaction
operator|->
name|squelch_x
operator|=
name|synaction
operator|->
name|squelch_x
operator|%
operator|(
name|div_x
operator|*
name|multiplicator
operator|)
expr_stmt|;
name|synaction
operator|->
name|squelch_y
operator|+=
name|synaction
operator|->
name|avg_dy
expr_stmt|;
operator|*
name|y
operator|=
name|synaction
operator|->
name|squelch_y
operator|/
operator|(
name|div_y
operator|*
name|multiplicator
operator|)
expr_stmt|;
name|synaction
operator|->
name|squelch_y
operator|=
name|synaction
operator|->
name|squelch_y
operator|%
operator|(
name|div_y
operator|*
name|multiplicator
operator|)
expr_stmt|;
if|if
condition|(
name|synaction
operator|->
name|in_vscroll
condition|)
block|{
switch|switch
condition|(
name|synaction
operator|->
name|in_vscroll
condition|)
block|{
case|case
literal|1
case|:
comment|/* Vertical scrolling. */
if|if
condition|(
operator|*
name|y
operator|!=
literal|0
condition|)
name|ms
operator|->
name|button
operator||=
operator|(
operator|*
name|y
operator|>
literal|0
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
name|MOUSE_BUTTON5DOWN
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Horizontal scrolling. */
if|if
condition|(
operator|*
name|x
operator|!=
literal|0
condition|)
name|ms
operator|->
name|button
operator||=
operator|(
operator|*
name|x
operator|>
literal|0
operator|)
condition|?
name|MOUSE_BUTTON7DOWN
else|:
name|MOUSE_BUTTON6DOWN
expr_stmt|;
break|break;
block|}
comment|/* The pointer is not moved. */
operator|*
name|x
operator|=
operator|*
name|y
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: [%d, %d] -> [%d, %d]\n"
operator|,
name|dx
operator|,
name|dy
operator|,
operator|*
name|x
operator|,
operator|*
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PSM_FLAGS_FINGERDOWN
condition|)
block|{
comment|/* 		 * An action is currently taking place but the pressure 		 * dropped under the minimum, putting an end to it. 		 */
name|synapticsaction_t
modifier|*
name|synaction
decl_stmt|;
name|int
name|taphold_timeout
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|tap_max_delta
decl_stmt|;
name|synaction
operator|=
operator|&
operator|(
name|sc
operator|->
name|synaction
operator|)
expr_stmt|;
name|dx
operator|=
name|abs
argument_list|(
name|synaction
operator|->
name|queue
index|[
name|synaction
operator|->
name|queue_cursor
index|]
operator|.
name|x
operator|-
name|synaction
operator|->
name|start_x
argument_list|)
expr_stmt|;
name|dy
operator|=
name|abs
argument_list|(
name|synaction
operator|->
name|queue
index|[
name|synaction
operator|->
name|queue_cursor
index|]
operator|.
name|y
operator|-
name|synaction
operator|->
name|start_y
argument_list|)
expr_stmt|;
comment|/* Max delta is disabled for multi-fingers tap. */
if|if
condition|(
name|synaction
operator|->
name|fingers_nb
operator|>
literal|1
condition|)
name|tap_max_delta
operator|=
name|imax
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
else|else
name|tap_max_delta
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|tap_max_delta
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
comment|/* Check for tap. */
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: zmax=%d, dx=%d, dy=%d, "
literal|"delta=%d, fingers=%d, queue=%d\n"
operator|,
name|sc
operator|->
name|zmax
operator|,
name|dx
operator|,
name|dy
operator|,
name|tap_max_delta
operator|,
name|synaction
operator|->
name|fingers_nb
operator|,
name|synaction
operator|->
name|queue_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|synaction
operator|->
name|in_vscroll
operator|&&
name|sc
operator|->
name|zmax
operator|>=
name|tap_threshold
operator|&&
name|timevalcmp
argument_list|(
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|,
operator|&
name|sc
operator|->
name|taptimeout
argument_list|,
operator|<=
argument_list|)
operator|&&
name|dx
operator|<=
name|tap_max_delta
operator|&&
name|dy
operator|<=
name|tap_max_delta
operator|&&
name|synaction
operator|->
name|queue_len
operator|>=
name|sc
operator|->
name|syninfo
operator|.
name|tap_min_queue
condition|)
block|{
comment|/* 			 * We have a tap if: 			 *   - the maximum pressure went over tap_threshold 			 *   - the action ended before tap_timeout 			 * 			 * To handle tap-hold, we must delay any button push to 			 * the next action. 			 */
if|if
condition|(
name|synaction
operator|->
name|in_taphold
condition|)
block|{
comment|/* 				 * This is the second and last tap of a 				 * double tap action, not a tap-hold. 				 */
name|synaction
operator|->
name|in_taphold
operator|=
literal|0
expr_stmt|;
comment|/* 				 * For double-tap to work: 				 *   - no button press is emitted (to 				 *     simulate a button release) 				 *   - PSM_FLAGS_FINGERDOWN is set to 				 *     force the next packet to emit a 				 *     button press) 				 */
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: button RELEASE: %d\n"
operator|,
name|synaction
operator|->
name|tap_button
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * This is the first tap: we set the 				 * tap-hold state and notify the button 				 * down event. 				 */
name|synaction
operator|->
name|in_taphold
operator|=
literal|1
expr_stmt|;
name|taphold_timeout
operator|=
name|sc
operator|->
name|syninfo
operator|.
name|taphold_timeout
expr_stmt|;
name|sc
operator|->
name|taptimeout
operator|.
name|tv_sec
operator|=
name|taphold_timeout
operator|/
literal|1000000
expr_stmt|;
name|sc
operator|->
name|taptimeout
operator|.
name|tv_usec
operator|=
name|taphold_timeout
operator|%
literal|1000000
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|sc
operator|->
name|taptimeout
argument_list|,
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|synaction
operator|->
name|fingers_nb
condition|)
block|{
case|case
literal|3
case|:
name|synaction
operator|->
name|tap_button
operator|=
name|MOUSE_BUTTON2DOWN
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|synaction
operator|->
name|tap_button
operator|=
name|MOUSE_BUTTON3DOWN
expr_stmt|;
break|break;
default|default:
name|synaction
operator|->
name|tap_button
operator|=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
block|}
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: button PRESS: %d\n"
operator|,
name|synaction
operator|->
name|tap_button
operator|)
argument_list|)
expr_stmt|;
name|ms
operator|->
name|button
operator||=
name|synaction
operator|->
name|tap_button
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Not enough pressure or timeout: reset 			 * tap-hold state. 			 */
if|if
condition|(
name|synaction
operator|->
name|in_taphold
condition|)
block|{
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: button RELEASE: %d\n"
operator|,
name|synaction
operator|->
name|tap_button
operator|)
argument_list|)
expr_stmt|;
name|synaction
operator|->
name|in_taphold
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: not a tap-hold\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|PSM_FLAGS_FINGERDOWN
operator|)
operator|&&
name|sc
operator|->
name|synaction
operator|.
name|in_taphold
condition|)
block|{
comment|/* 		 * For a tap-hold to work, the button must remain down at 		 * least until timeout (where the in_taphold flags will be 		 * cleared) or during the next action. 		 */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|,
operator|&
name|sc
operator|->
name|taptimeout
argument_list|,
operator|<=
argument_list|)
condition|)
block|{
name|ms
operator|->
name|button
operator||=
name|sc
operator|->
name|synaction
operator|.
name|tap_button
expr_stmt|;
block|}
else|else
block|{
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: button RELEASE: %d\n"
operator|,
name|sc
operator|->
name|synaction
operator|.
name|tap_button
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|synaction
operator|.
name|in_taphold
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|SYNAPTICS_END
label|:
comment|/* 	 * Use the extra buttons as a scrollwheel 	 * 	 * XXX X.Org uses the Z axis for vertical wheel only, 	 * whereas moused(8) understands special values to differ 	 * vertical and horizontal wheels. 	 * 	 * xf86-input-mouse needs therefore a small patch to 	 * understand these special values. Without it, the 	 * horizontal wheel acts as a vertical wheel in X.Org. 	 * 	 * That's why the horizontal wheel is disabled by 	 * default for now. 	 */
if|if
condition|(
name|ms
operator|->
name|button
operator|&
name|MOUSE_BUTTON4DOWN
condition|)
block|{
operator|*
name|z
operator|=
operator|-
literal|1
expr_stmt|;
name|ms
operator|->
name|button
operator|&=
operator|~
name|MOUSE_BUTTON4DOWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ms
operator|->
name|button
operator|&
name|MOUSE_BUTTON5DOWN
condition|)
block|{
operator|*
name|z
operator|=
literal|1
expr_stmt|;
name|ms
operator|->
name|button
operator|&=
operator|~
name|MOUSE_BUTTON5DOWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ms
operator|->
name|button
operator|&
name|MOUSE_BUTTON6DOWN
condition|)
block|{
operator|*
name|z
operator|=
operator|-
literal|2
expr_stmt|;
name|ms
operator|->
name|button
operator|&=
operator|~
name|MOUSE_BUTTON6DOWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ms
operator|->
name|button
operator|&
name|MOUSE_BUTTON7DOWN
condition|)
block|{
operator|*
name|z
operator|=
literal|2
expr_stmt|;
name|ms
operator|->
name|button
operator|&=
operator|~
name|MOUSE_BUTTON7DOWN
expr_stmt|;
block|}
else|else
operator|*
name|z
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|proc_versapad
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|packetbuf_t
modifier|*
name|pb
parameter_list|,
name|mousestatus_t
modifier|*
name|ms
parameter_list|,
name|int
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|z
parameter_list|)
block|{
specifier|static
name|int
name|butmap_versapad
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
name|int
name|c
decl_stmt|,
name|x0
decl_stmt|,
name|y0
decl_stmt|;
comment|/* VersaPad PS/2 absolute mode message format 	 * 	 * [packet1]     7   6   5   4   3   2   1   0(LSB) 	 *  ipacket[0]:  1   1   0   A   1   L   T   R 	 *  ipacket[1]: H7  H6  H5  H4  H3  H2  H1  H0 	 *  ipacket[2]: V7  V6  V5  V4  V3  V2  V1  V0 	 *  ipacket[3]:  1   1   1   A   1   L   T   R 	 *  ipacket[4]:V11 V10  V9  V8 H11 H10  H9  H8 	 *  ipacket[5]:  0  P6  P5  P4  P3  P2  P1  P0 	 * 	 * [note] 	 *  R: right physical mouse button (1=on) 	 *  T: touch pad virtual button (1=tapping) 	 *  L: left physical mouse button (1=on) 	 *  A: position data is valid (1=valid) 	 *  H: horizontal data (12bit signed integer. H11 is sign bit.) 	 *  V: vertical data (12bit signed integer. V11 is sign bit.) 	 *  P: pressure data 	 * 	 * Tapping is mapped to MOUSE_BUTTON4. 	 */
name|c
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|x
operator|=
operator|*
name|y
operator|=
literal|0
expr_stmt|;
name|ms
operator|->
name|button
operator|=
name|butmap_versapad
index|[
name|c
operator|&
name|MOUSE_PS2VERSA_BUTTONS
index|]
expr_stmt|;
name|ms
operator|->
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2VERSA_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MOUSE_PS2VERSA_IN_USE
condition|)
block|{
name|x0
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator||
operator|(
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|)
operator|&
literal|0x0f
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|y0
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator||
operator|(
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|)
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|x0
operator|&
literal|0x800
condition|)
name|x0
operator|-=
literal|0x1000
expr_stmt|;
if|if
condition|(
name|y0
operator|&
literal|0x800
condition|)
name|y0
operator|-=
literal|0x1000
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PSM_FLAGS_FINGERDOWN
condition|)
block|{
operator|*
name|x
operator|=
name|sc
operator|->
name|xold
operator|-
name|x0
expr_stmt|;
operator|*
name|y
operator|=
name|y0
operator|-
name|sc
operator|->
name|yold
expr_stmt|;
if|if
condition|(
operator|*
name|x
operator|<
literal|0
condition|)
comment|/* XXX */
operator|++
operator|*
name|x
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|x
condition|)
operator|--
operator|*
name|x
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|<
literal|0
condition|)
operator|++
operator|*
name|y
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|y
condition|)
operator|--
operator|*
name|y
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|flags
operator||=
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
name|sc
operator|->
name|xold
operator|=
name|x0
expr_stmt|;
name|sc
operator|->
name|yold
operator|=
name|y0
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|psmsoftintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * the table to turn PS/2 mouse button bits (MOUSE_PS2_BUTTON?DOWN) 	 * into `mousestatus' button bits (MOUSE_BUTTON?DOWN). 	 */
specifier|static
name|int
name|butmap
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|mousestatus_t
name|ms
decl_stmt|;
name|packetbuf_t
modifier|*
name|pb
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|c
decl_stmt|,
name|l
decl_stmt|,
name|s
decl_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
do|do
block|{
name|pb
operator|=
operator|&
name|sc
operator|->
name|pqueue
index|[
name|sc
operator|->
name|pqueue_start
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_NATIVE
condition|)
goto|goto
name|next_native
goto|;
name|c
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * A kludge for Kensington device! 		 * The MSB of the horizontal count appears to be stored in 		 * a strange place. 		 */
if|if
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
operator|==
name|MOUSE_MODEL_THINK
condition|)
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2_XOVERFLOW
operator|)
condition|?
literal|0x80
else|:
literal|0
expr_stmt|;
comment|/* ignore the overflow bits... */
name|x
operator|=
operator|(
name|c
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
operator|(
name|c
operator|&
name|MOUSE_PS2_YNEG
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
name|ms
operator|.
name|obutton
operator|=
name|sc
operator|->
name|button
expr_stmt|;
comment|/* previous button state */
name|ms
operator|.
name|button
operator|=
name|butmap
index|[
name|c
operator|&
name|MOUSE_PS2_BUTTONS
index|]
expr_stmt|;
comment|/* `tapping' action */
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_FORCETAP
condition|)
name|ms
operator|.
name|button
operator||=
operator|(
operator|(
name|c
operator|&
name|MOUSE_PS2_TAP
operator|)
operator|)
condition|?
literal|0
else|:
name|MOUSE_BUTTON4DOWN
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
condition|)
block|{
case|case
name|MOUSE_MODEL_EXPLORER
case|:
comment|/* 			 *          b7 b6 b5 b4 b3 b2 b1 b0 			 * byte 1:  oy ox sy sx 1  M  R  L 			 * byte 2:  x  x  x  x  x  x  x  x 			 * byte 3:  y  y  y  y  y  y  y  y 			 * byte 4:  *  *  S2 S1 s  d2 d1 d0 			 * 			 * L, M, R, S1, S2: left, middle, right and side buttons 			 * s: wheel data sign bit 			 * d2-d0: wheel data 			 */
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_ZNEG
operator|)
condition|?
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_INTELLI
case|:
case|case
name|MOUSE_MODEL_NET
case|:
comment|/* wheel data is in the fourth byte */
name|z
operator|=
operator|(
name|char
operator|)
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
expr_stmt|;
comment|/* 			 * XXX some mice may send 7 when there is no Z movement?			 */
if|if
condition|(
operator|(
name|z
operator|>=
literal|7
operator|)
operator|||
operator|(
name|z
operator|<=
operator|-
literal|7
operator|)
condition|)
name|z
operator|=
literal|0
expr_stmt|;
comment|/* some compatible mice have additional buttons */
name|ms
operator|.
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2INTELLI_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2INTELLI_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_MOUSEMANPLUS
case|:
name|proc_mmanplus
argument_list|(
name|sc
argument_list|,
name|pb
argument_list|,
operator|&
name|ms
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_GLIDEPOINT
case|:
comment|/* `tapping' action */
name|ms
operator|.
name|button
operator||=
operator|(
operator|(
name|c
operator|&
name|MOUSE_PS2_TAP
operator|)
operator|)
condition|?
literal|0
else|:
name|MOUSE_BUTTON4DOWN
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_NETSCROLL
case|:
comment|/* 			 * three addtional bytes encode buttons and 			 * wheel events 			 */
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_BUTTON3DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_BUTTON1DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_THINK
case|:
comment|/* the fourth button state in the first byte */
name|ms
operator|.
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_VERSAPAD
case|:
name|proc_versapad
argument_list|(
name|sc
argument_list|,
name|pb
argument_list|,
operator|&
name|ms
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|x
operator|<
literal|0
operator|)
condition|?
name|MOUSE_PS2_XNEG
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|y
operator|<
literal|0
operator|)
condition|?
name|MOUSE_PS2_YNEG
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_4D
case|:
comment|/* 			 *          b7 b6 b5 b4 b3 b2 b1 b0 			 * byte 1:  s2 d2 s1 d1 1  M  R  L 			 * byte 2:  sx x  x  x  x  x  x  x 			 * byte 3:  sy y  y  y  y  y  y  y 			 * 			 * s1: wheel 1 direction 			 * d1: wheel 1 data 			 * s2: wheel 2 direction 			 * d2: wheel 2 data 			 */
name|x
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x80
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|c
operator|&
name|MOUSE_4D_WHEELBITS
condition|)
block|{
case|case
literal|0x10
case|:
name|z
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|z
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
comment|/* XXX 2nd wheel turning right */
name|z
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
comment|/* XXX 2nd wheel turning left */
name|z
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_MODEL_4DPLUS
case|:
if|if
condition|(
operator|(
name|x
operator|<
literal|16
operator|-
literal|256
operator|)
operator|&&
operator|(
name|y
operator|<
literal|16
operator|-
literal|256
operator|)
condition|)
block|{
comment|/* 				 *          b7 b6 b5 b4 b3 b2 b1 b0 				 * byte 1:  0  0  1  1  1  M  R  L 				 * byte 2:  0  0  0  0  1  0  0  0 				 * byte 3:  0  0  0  0  S  s  d1 d0 				 * 				 * L, M, R, S: left, middle, right, 				 *             and side buttons 				 * s: wheel data sign bit 				 * d1-d0: wheel data 				 */
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_4DPLUS_BUTTON4DOWN
condition|)
name|ms
operator|.
name|button
operator||=
name|MOUSE_BUTTON4DOWN
expr_stmt|;
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_4DPLUS_ZNEG
operator|)
condition|?
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x07
operator|)
operator|-
literal|8
operator|)
else|:
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x07
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* preserve previous button states */
name|ms
operator|.
name|button
operator||=
name|ms
operator|.
name|obutton
operator|&
name|MOUSE_EXTBUTTONS
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_MODEL_SYNAPTICS
case|:
if|if
condition|(
name|proc_synaptics
argument_list|(
name|sc
argument_list|,
name|pb
argument_list|,
operator|&
name|ms
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|z
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|next
goto|;
break|break;
case|case
name|MOUSE_MODEL_TRACKPOINT
case|:
case|case
name|MOUSE_MODEL_GENERIC
case|:
default|default:
break|break;
block|}
comment|/* scale values */
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|x
operator|*
name|x
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MOUSE_PS2_XNEG
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|y
operator|=
name|y
operator|*
name|y
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
name|y
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MOUSE_PS2_YNEG
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
block|}
name|ms
operator|.
name|dx
operator|=
name|x
expr_stmt|;
name|ms
operator|.
name|dy
operator|=
name|y
expr_stmt|;
name|ms
operator|.
name|dz
operator|=
name|z
expr_stmt|;
name|ms
operator|.
name|flags
operator|=
operator|(
operator|(
name|x
operator|||
name|y
operator|||
name|z
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|ms
operator|.
name|obutton
operator|^
name|ms
operator|.
name|button
operator|)
expr_stmt|;
name|pb
operator|->
name|inputbytes
operator|=
name|tame_mouse
argument_list|(
name|sc
argument_list|,
name|pb
argument_list|,
operator|&
name|ms
argument_list|,
name|pb
operator|->
name|ipacket
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator||=
name|ms
operator|.
name|flags
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|+=
name|ms
operator|.
name|dx
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|+=
name|ms
operator|.
name|dy
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|+=
name|ms
operator|.
name|dz
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|ms
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|button
operator|=
name|ms
operator|.
name|button
expr_stmt|;
name|next_native
label|:
name|sc
operator|->
name|watchdog
operator|=
name|FALSE
expr_stmt|;
comment|/* queue data */
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|+
name|pb
operator|->
name|inputbytes
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
condition|)
block|{
name|l
operator|=
name|imin
argument_list|(
name|pb
operator|->
name|inputbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|tail
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|tail
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|inputbytes
operator|>
name|l
condition|)
name|bcopy
argument_list|(
operator|&
name|pb
operator|->
name|ipacket
index|[
name|l
index|]
argument_list|,
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
literal|0
index|]
argument_list|,
name|pb
operator|->
name|inputbytes
operator|-
name|l
argument_list|)
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|tail
operator|+
name|pb
operator|->
name|inputbytes
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|count
operator|+=
name|pb
operator|->
name|inputbytes
expr_stmt|;
block|}
name|pb
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|next
label|:
if|if
condition|(
operator|++
name|sc
operator|->
name|pqueue_start
operator|>=
name|PSM_PACKETQUEUE
condition|)
name|sc
operator|->
name|pqueue_start
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|pqueue_start
operator|!=
name|sc
operator|->
name|pqueue_end
condition|)
do|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|async
operator|!=
name|NULL
condition|)
block|{
name|pgsigio
argument_list|(
operator|&
name|sc
operator|->
name|async
argument_list|,
name|SIGIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_SOFTARMED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmpoll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
comment|/* Return true if a mouse event available */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/* vendor/model specific routines */
end_comment

begin_function
specifier|static
name|int
name|mouse_id_proc1
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|res
parameter_list|,
name|int
name|scale
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|res
argument_list|)
operator|!=
name|res
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
operator|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mouse_ext_command
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|command
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|command
operator|>>
literal|6
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|c
argument_list|)
operator|!=
name|c
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|c
operator|=
operator|(
name|command
operator|>>
literal|4
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|c
argument_list|)
operator|!=
name|c
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|c
operator|=
operator|(
name|command
operator|>>
literal|2
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|c
argument_list|)
operator|!=
name|c
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|c
operator|=
operator|(
name|command
operator|>>
literal|0
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|c
argument_list|)
operator|!=
name|c
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/* Logitech MouseMan Cordless II */
end_comment

begin_function
specifier|static
name|int
name|enable_lcordless
parameter_list|(
name|KDBC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|2
argument_list|,
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_HIGH
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|ch
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* channel # */
if|if
condition|(
operator|(
name|ch
operator|<=
literal|0
operator|)
operator|||
operator|(
name|ch
operator|>
literal|4
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * status[1]: always one? 	 * status[2]: battery status? (0-100) 	 */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/* Genius NetScroll Mouse, MouseSystems SmartScroll Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_groller
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/* 	 * The special sequence to enable the fourth button and the 	 * roller. Immediately after this sequence check status bytes. 	 * if the mouse is NetScroll, the second and the third bytes are 	 * '3' and 'D'. 	 */
comment|/* 	 * If the mouse is an ordinary PS/2 mouse, the status bytes should 	 * look like the following. 	 * 	 * byte 1 bit 7 always 0 	 *        bit 6 stream mode (0) 	 *        bit 5 disabled (0) 	 *        bit 4 1:1 scaling (0) 	 *        bit 3 always 0 	 *        bit 0-2 button status 	 * byte 2 resolution (PSMD_RES_HIGH) 	 * byte 3 report rate (?) 	 */
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|!=
literal|'D'
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* FIXME: SmartScroll Mouse has 5 buttons! XXX */
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|4
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Genius NetMouse/NetMouse Pro, ASCII Mie Mouse, NetScroll Optical */
end_comment

begin_function
specifier|static
name|int
name|enable_gmouse
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/* 	 * The special sequence to enable the middle, "rubber" button. 	 * Immediately after this sequence check status bytes. 	 * if the mouse is NetMouse, NetMouse Pro, or ASCII MIE Mouse, 	 * the second and the third bytes are '3' and 'U'. 	 * NOTE: NetMouse reports that it has three buttons although it has 	 * two buttons and a rubber button. NetMouse Pro and MIE Mouse 	 * say they have three buttons too and they do have a button on the 	 * side... 	 */
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|!=
literal|'U'
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ALPS GlidePoint */
end_comment

begin_function
specifier|static
name|int
name|enable_aglide
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/* 	 * The special sequence to obtain ALPS GlidePoint specific 	 * information. Immediately after this sequence, status bytes will 	 * contain something interesting. 	 * NOTE: ALPS produces several models of GlidePoint. Some of those 	 * do not respond to this sequence, thus, cannot be detected this way. 	 */
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
literal|100
argument_list|)
operator|!=
literal|100
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|,
literal|2
argument_list|,
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_LOW
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|==
literal|100
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Kensington ThinkingMouse/Trackball */
end_comment

begin_function
specifier|static
name|int
name|enable_kmouse
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|u_char
name|rate
index|[]
init|=
block|{
literal|20
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|,
literal|20
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|,
literal|20
block|}
decl_stmt|;
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
name|int
name|id1
decl_stmt|;
name|int
name|id2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|id1
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
operator|!=
literal|10
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * The device is now in the native mode? It returns a different 	 * ID value... 	 */
name|id2
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|==
name|id2
operator|)
operator|||
operator|(
name|id2
operator|!=
literal|2
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|)
operator|!=
name|PSMD_RES_LOW
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|#
directive|if
name|PSM_DEBUG
operator|>=
literal|2
comment|/* at this point, resolution is LOW, sampling rate is 10/sec */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * The special sequence to enable the third and fourth buttons. 	 * Otherwise they behave like the first and second buttons. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * At this point, the device is using default resolution and 	 * sampling rate for the native mode. 	 */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_LOW
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|==
name|rate
index|[
name|i
operator|-
literal|1
index|]
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* the device appears be enabled by this sequence, diable it for now */
name|disable_aux_dev
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Logitech MouseMan+/FirstMouse+, IBM ScrollPoint Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_mmanplus
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|data
index|[
literal|3
index|]
decl_stmt|;
comment|/* the special sequence to enable the fourth button and the roller. */
comment|/* 	 * NOTE: for ScrollPoint to respond correctly, the SET_RESOLUTION 	 * must be called exactly three times since the last RESET command 	 * before this sequence. XXX 	 */
if|if
condition|(
operator|!
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0x39
argument_list|)
operator|||
operator|!
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0xdb
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * PS2++ protocol, packet type 0 	 * 	 *          b7 b6 b5 b4 b3 b2 b1 b0 	 * byte 1:  *  1  p3 p2 1  *  *  * 	 * byte 2:  1  1  p1 p0 m1 m0 1  0 	 * byte 3:  m7 m6 m5 m4 m3 m2 m1 m0 	 * 	 * p3-p0: packet type: 0 	 * m7-m0: model ID: MouseMan+:0x50, 	 *		    FirstMouse+:0x51, 	 *		    ScrollPoint:0x58... 	 */
comment|/* check constant bits */
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2PLUS_SYNCMASK
operator|)
operator|!=
name|MOUSE_PS2PLUS_SYNC
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0xc3
operator|)
operator|!=
literal|0xc2
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* check d3-d0 in byte 2 */
if|if
condition|(
operator|!
name|MOUSE_PS2PLUS_CHECKBITS
argument_list|(
name|data
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* check p3-p0 */
if|if
condition|(
name|MOUSE_PS2PLUS_PACKET_TYPE
argument_list|(
name|data
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&=
literal|0x00ff
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator||=
name|data
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
comment|/* save model ID */
block|}
comment|/* 	 * MouseMan+ (or FirstMouse+) is now in its native mode, in which 	 * the wheel and the fourth button events are encoded in the 	 * special data packet. The mouse may be put in the IntelliMouse mode 	 * if it is initialized by the IntelliMouse's method. 	 */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MS IntelliMouse Explorer */
end_comment

begin_function
specifier|static
name|int
name|enable_msexplorer
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|u_char
name|rate0
index|[]
init|=
block|{
literal|200
block|,
literal|100
block|,
literal|80
block|, }
decl_stmt|;
specifier|static
name|u_char
name|rate1
index|[]
init|=
block|{
literal|200
block|,
literal|200
block|,
literal|80
block|, }
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * This is needed for at least A4Tech X-7xx mice - they do not go 	 * straight to Explorer mode, but need to be set to Intelli mode 	 * first. 	 */
name|enable_msintelli
argument_list|(
name|kbdc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* the special sequence to enable the extra buttons and the roller. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate1
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate1
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate1
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* the device will give the genuine ID only after the above sequence */
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|PSM_EXPLORER_ID
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|5
expr_stmt|;
comment|/* IntelliMouse Explorer XXX */
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
block|}
comment|/* 	 * XXX: this is a kludge to fool some KVM switch products 	 * which think they are clever enough to know the 4-byte IntelliMouse 	 * protocol, and assume any other protocols use 3-byte packets. 	 * They don't convey 4-byte data packets from the IntelliMouse Explorer 	 * correctly to the host computer because of this! 	 * The following sequence is actually IntelliMouse's "wake up" 	 * sequence; it will make the KVM think the mouse is IntelliMouse 	 * when it is in fact IntelliMouse Explorer. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate0
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate0
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate0
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate0
index|[
name|i
index|]
condition|)
break|break;
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MS IntelliMouse */
end_comment

begin_function
specifier|static
name|int
name|enable_msintelli
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Logitech MouseMan+ and FirstMouse+ will also respond to this 	 * probe routine and act like IntelliMouse. 	 */
specifier|static
name|u_char
name|rate
index|[]
init|=
block|{
literal|200
block|,
literal|100
block|,
literal|80
block|, }
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* the special sequence to enable the third button and the roller. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* the device will give the genuine ID only after the above sequence */
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|PSM_INTELLI_ID
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A4 Tech 4D Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_4dmouse
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Newer wheel mice from A4 Tech may use the 4D+ protocol. 	 */
specifier|static
name|u_char
name|rate
index|[]
init|=
block|{
literal|200
block|,
literal|100
block|,
literal|80
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|}
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
comment|/* 	 * WinEasy 4D, 4 Way Scroll 4D: 6 	 * Cable-Free 4D: 8 (4DPLUS) 	 * WinBest 4D+, 4 Way Scroll 4D+: 8 (4DPLUS) 	 */
if|if
condition|(
name|id
operator|!=
name|PSM_4DMOUSE_ID
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
comment|/* XXX some 4D mice have 4? */
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A4 Tech 4D+ Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_4dplus
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Newer wheel mice from A4 Tech seem to use this protocol. 	 * Older models are recognized as either 4D Mouse or IntelliMouse. 	 */
name|int
name|id
decl_stmt|;
comment|/* 	 * enable_4dmouse() already issued the following ID sequence... 	static u_char rate[] = { 200, 100, 80, 60, 40, 20 }; 	int i;  	for (i = 0; i< sizeof(rate)/sizeof(rate[0]); ++i) 		if (set_mouse_sampling_rate(kbdc, rate[i]) != rate[i]) 			return (FALSE); 	*/
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|PSM_4DPLUS_ID
case|:
break|break;
case|case
name|PSM_4DPLUS_RFSW35_ID
case|:
break|break;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
operator|(
name|id
operator|==
name|PSM_4DPLUS_ID
operator|)
condition|?
literal|4
else|:
literal|3
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Synaptics Touchpad */
end_comment

begin_function
specifier|static
name|int
name|synaptics_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|arg
decl_stmt|;
comment|/* Read the current value. */
name|arg
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Check that the new value is in the concerned node's range 	 * of values. 	 */
switch|switch
condition|(
name|oidp
operator|->
name|oid_arg2
condition|)
block|{
case|case
name|SYNAPTICS_SYSCTL_MIN_PRESSURE
case|:
case|case
name|SYNAPTICS_SYSCTL_MAX_PRESSURE
case|:
if|if
condition|(
name|arg
operator|<
literal|0
operator|||
name|arg
operator|>
literal|255
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|SYNAPTICS_SYSCTL_MAX_WIDTH
case|:
if|if
condition|(
name|arg
operator|<
literal|4
operator|||
name|arg
operator|>
literal|15
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|SYNAPTICS_SYSCTL_MARGIN_TOP
case|:
case|case
name|SYNAPTICS_SYSCTL_MARGIN_RIGHT
case|:
case|case
name|SYNAPTICS_SYSCTL_MARGIN_BOTTOM
case|:
case|case
name|SYNAPTICS_SYSCTL_MARGIN_LEFT
case|:
case|case
name|SYNAPTICS_SYSCTL_NA_TOP
case|:
case|case
name|SYNAPTICS_SYSCTL_NA_RIGHT
case|:
case|case
name|SYNAPTICS_SYSCTL_NA_BOTTOM
case|:
case|case
name|SYNAPTICS_SYSCTL_NA_LEFT
case|:
if|if
condition|(
name|arg
operator|<
literal|0
operator|||
name|arg
operator|>
literal|6143
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|SYNAPTICS_SYSCTL_WINDOW_MIN
case|:
case|case
name|SYNAPTICS_SYSCTL_WINDOW_MAX
case|:
case|case
name|SYNAPTICS_SYSCTL_TAP_MIN_QUEUE
case|:
if|if
condition|(
name|arg
operator|<
literal|1
operator|||
name|arg
operator|>
name|SYNAPTICS_PACKETQUEUE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|SYNAPTICS_SYSCTL_MULTIPLICATOR
case|:
case|case
name|SYNAPTICS_SYSCTL_WEIGHT_CURRENT
case|:
case|case
name|SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS
case|:
case|case
name|SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS_NA
case|:
case|case
name|SYNAPTICS_SYSCTL_WEIGHT_LEN_SQUARED
case|:
case|case
name|SYNAPTICS_SYSCTL_DIV_MIN
case|:
case|case
name|SYNAPTICS_SYSCTL_DIV_MAX
case|:
case|case
name|SYNAPTICS_SYSCTL_DIV_MAX_NA
case|:
case|case
name|SYNAPTICS_SYSCTL_DIV_LEN
case|:
case|case
name|SYNAPTICS_SYSCTL_VSCROLL_DIV_MIN
case|:
case|case
name|SYNAPTICS_SYSCTL_VSCROLL_DIV_MAX
case|:
if|if
condition|(
name|arg
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|SYNAPTICS_SYSCTL_TAP_MAX_DELTA
case|:
case|case
name|SYNAPTICS_SYSCTL_TAPHOLD_TIMEOUT
case|:
case|case
name|SYNAPTICS_SYSCTL_VSCROLL_MIN_DELTA
case|:
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|SYNAPTICS_SYSCTL_VSCROLL_HOR_AREA
case|:
case|case
name|SYNAPTICS_SYSCTL_VSCROLL_VER_AREA
case|:
if|if
condition|(
name|arg
operator|<
operator|-
literal|6143
operator|||
name|arg
operator|>
literal|6143
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Update. */
operator|*
operator|(
name|int
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|synaptics_sysctl_create_tree
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
operator|!=
name|NULL
condition|)
return|return;
comment|/* Attach extra synaptics sysctl nodes under hw.psm.synaptics */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_psm
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"synaptics"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Synaptics TouchPad"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.directional_scrolls. */
name|sc
operator|->
name|syninfo
operator|.
name|directional_scrolls
operator|=
literal|1
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"directional_scrolls"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|directional_scrolls
argument_list|,
literal|0
argument_list|,
literal|"Enable hardware scrolling pad (if non-zero) or register it as "
literal|"a middle-click (if 0)"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.min_pressure. */
name|sc
operator|->
name|syninfo
operator|.
name|min_pressure
operator|=
literal|16
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"min_pressure"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|min_pressure
argument_list|,
name|SYNAPTICS_SYSCTL_MIN_PRESSURE
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Minimum pressure required to start an action"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.max_pressure. */
name|sc
operator|->
name|syninfo
operator|.
name|max_pressure
operator|=
literal|220
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_pressure"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|max_pressure
argument_list|,
name|SYNAPTICS_SYSCTL_MAX_PRESSURE
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum pressure to detect palm"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.max_width. */
name|sc
operator|->
name|syninfo
operator|.
name|max_width
operator|=
literal|10
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_width"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|max_width
argument_list|,
name|SYNAPTICS_SYSCTL_MAX_WIDTH
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum finger width to detect palm"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.top_margin. */
name|sc
operator|->
name|syninfo
operator|.
name|margin_top
operator|=
literal|200
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"margin_top"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|margin_top
argument_list|,
name|SYNAPTICS_SYSCTL_MARGIN_TOP
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Top margin"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.right_margin. */
name|sc
operator|->
name|syninfo
operator|.
name|margin_right
operator|=
literal|200
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"margin_right"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|margin_right
argument_list|,
name|SYNAPTICS_SYSCTL_MARGIN_RIGHT
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Right margin"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.bottom_margin. */
name|sc
operator|->
name|syninfo
operator|.
name|margin_bottom
operator|=
literal|200
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"margin_bottom"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|margin_bottom
argument_list|,
name|SYNAPTICS_SYSCTL_MARGIN_BOTTOM
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Bottom margin"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.left_margin. */
name|sc
operator|->
name|syninfo
operator|.
name|margin_left
operator|=
literal|200
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"margin_left"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|margin_left
argument_list|,
name|SYNAPTICS_SYSCTL_MARGIN_LEFT
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Left margin"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.na_top. */
name|sc
operator|->
name|syninfo
operator|.
name|na_top
operator|=
literal|1783
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"na_top"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|na_top
argument_list|,
name|SYNAPTICS_SYSCTL_NA_TOP
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Top noisy area, where weight_previous_na is used instead "
literal|"of weight_previous"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.na_right. */
name|sc
operator|->
name|syninfo
operator|.
name|na_right
operator|=
literal|563
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"na_right"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|na_right
argument_list|,
name|SYNAPTICS_SYSCTL_NA_RIGHT
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Right noisy area, where weight_previous_na is used instead "
literal|"of weight_previous"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.na_bottom. */
name|sc
operator|->
name|syninfo
operator|.
name|na_bottom
operator|=
literal|1408
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"na_bottom"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|na_bottom
argument_list|,
name|SYNAPTICS_SYSCTL_NA_BOTTOM
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Bottom noisy area, where weight_previous_na is used instead "
literal|"of weight_previous"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.na_left. */
name|sc
operator|->
name|syninfo
operator|.
name|na_left
operator|=
literal|1600
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"na_left"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|na_left
argument_list|,
name|SYNAPTICS_SYSCTL_NA_LEFT
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Left noisy area, where weight_previous_na is used instead "
literal|"of weight_previous"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.window_min. */
name|sc
operator|->
name|syninfo
operator|.
name|window_min
operator|=
literal|4
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"window_min"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|window_min
argument_list|,
name|SYNAPTICS_SYSCTL_WINDOW_MIN
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Minimum window size to start an action"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.window_max. */
name|sc
operator|->
name|syninfo
operator|.
name|window_max
operator|=
literal|10
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"window_max"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|window_max
argument_list|,
name|SYNAPTICS_SYSCTL_WINDOW_MAX
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum window size"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.multiplicator. */
name|sc
operator|->
name|syninfo
operator|.
name|multiplicator
operator|=
literal|10000
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"multiplicator"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|multiplicator
argument_list|,
name|SYNAPTICS_SYSCTL_MULTIPLICATOR
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Multiplicator to increase precision in averages and divisions"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.weight_current. */
name|sc
operator|->
name|syninfo
operator|.
name|weight_current
operator|=
literal|3
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"weight_current"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|weight_current
argument_list|,
name|SYNAPTICS_SYSCTL_WEIGHT_CURRENT
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Weight of the current movement in the new average"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.weight_previous. */
name|sc
operator|->
name|syninfo
operator|.
name|weight_previous
operator|=
literal|6
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"weight_previous"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|weight_previous
argument_list|,
name|SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Weight of the previous average"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.weight_previous_na. */
name|sc
operator|->
name|syninfo
operator|.
name|weight_previous_na
operator|=
literal|20
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"weight_previous_na"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|weight_previous_na
argument_list|,
name|SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS_NA
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Weight of the previous average (inside the noisy area)"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.weight_len_squared. */
name|sc
operator|->
name|syninfo
operator|.
name|weight_len_squared
operator|=
literal|2000
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"weight_len_squared"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|weight_len_squared
argument_list|,
name|SYNAPTICS_SYSCTL_WEIGHT_LEN_SQUARED
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Length (squared) of segments where weight_previous "
literal|"starts to decrease"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.div_min. */
name|sc
operator|->
name|syninfo
operator|.
name|div_min
operator|=
literal|9
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"div_min"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|div_min
argument_list|,
name|SYNAPTICS_SYSCTL_DIV_MIN
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Divisor for fast movements"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.div_max. */
name|sc
operator|->
name|syninfo
operator|.
name|div_max
operator|=
literal|17
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"div_max"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|div_max
argument_list|,
name|SYNAPTICS_SYSCTL_DIV_MAX
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Divisor for slow movements"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.div_max_na. */
name|sc
operator|->
name|syninfo
operator|.
name|div_max_na
operator|=
literal|30
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"div_max_na"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|div_max_na
argument_list|,
name|SYNAPTICS_SYSCTL_DIV_MAX_NA
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Divisor with slow movements (inside the noisy area)"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.div_len. */
name|sc
operator|->
name|syninfo
operator|.
name|div_len
operator|=
literal|100
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"div_len"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|div_len
argument_list|,
name|SYNAPTICS_SYSCTL_DIV_LEN
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Length of segments where div_max starts to decrease"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.tap_max_delta. */
name|sc
operator|->
name|syninfo
operator|.
name|tap_max_delta
operator|=
literal|80
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tap_max_delta"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|tap_max_delta
argument_list|,
name|SYNAPTICS_SYSCTL_TAP_MAX_DELTA
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Length of segments above which a tap is ignored"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.tap_min_queue. */
name|sc
operator|->
name|syninfo
operator|.
name|tap_min_queue
operator|=
literal|2
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tap_min_queue"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|tap_min_queue
argument_list|,
name|SYNAPTICS_SYSCTL_TAP_MIN_QUEUE
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Number of packets required to consider a tap"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.taphold_timeout. */
name|sc
operator|->
name|synaction
operator|.
name|in_taphold
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|syninfo
operator|.
name|taphold_timeout
operator|=
name|tap_timeout
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"taphold_timeout"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|taphold_timeout
argument_list|,
name|SYNAPTICS_SYSCTL_TAPHOLD_TIMEOUT
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum elapsed time between two taps to consider a tap-hold "
literal|"action"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.vscroll_hor_area. */
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_hor_area
operator|=
literal|0
expr_stmt|;
comment|/* 1300 */
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vscroll_hor_area"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_hor_area
argument_list|,
name|SYNAPTICS_SYSCTL_VSCROLL_HOR_AREA
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Area reserved for horizontal virtual scrolling"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.vscroll_ver_area. */
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_ver_area
operator|=
operator|-
literal|600
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vscroll_ver_area"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_ver_area
argument_list|,
name|SYNAPTICS_SYSCTL_VSCROLL_VER_AREA
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Area reserved for vertical virtual scrolling"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.vscroll_min_delta. */
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_min_delta
operator|=
literal|50
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vscroll_min_delta"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_min_delta
argument_list|,
name|SYNAPTICS_SYSCTL_VSCROLL_MIN_DELTA
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Minimum movement to consider virtual scrolling"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.vscroll_div_min. */
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_div_min
operator|=
literal|100
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vscroll_div_min"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_div_min
argument_list|,
name|SYNAPTICS_SYSCTL_VSCROLL_DIV_MIN
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Divisor for fast scrolling"
argument_list|)
expr_stmt|;
comment|/* hw.psm.synaptics.vscroll_div_min. */
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_div_max
operator|=
literal|150
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|syninfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vscroll_div_max"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
operator|&
name|sc
operator|->
name|syninfo
operator|.
name|vscroll_div_max
argument_list|,
name|SYNAPTICS_SYSCTL_VSCROLL_DIV_MAX
argument_list|,
name|synaptics_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Divisor for slow scrolling"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|enable_synaptics
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|synapticshw_t
name|synhw
decl_stmt|;
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
name|int
name|buttons
decl_stmt|;
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: BEGIN init\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Just to be on the safe side: this avoids troubles with 	 * following mouse_ext_command() when the previous command 	 * was PSMC_SET_RESOLUTION. Set Scaling has no effect on 	 * Synaptics Touchpad behaviour. 	 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Identify the Touchpad version. */
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|!=
literal|0x47
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|synhw
argument_list|,
sizeof|sizeof
argument_list|(
name|synhw
argument_list|)
argument_list|)
expr_stmt|;
name|synhw
operator|.
name|infoMinor
operator|=
name|status
index|[
literal|0
index|]
expr_stmt|;
name|synhw
operator|.
name|infoMajor
operator|=
name|status
index|[
literal|2
index|]
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Synaptics Touchpad v%d.%d\n"
argument_list|,
name|synhw
operator|.
name|infoMajor
argument_list|,
name|synhw
operator|.
name|infoMinor
argument_list|)
expr_stmt|;
if|if
condition|(
name|synhw
operator|.
name|infoMajor
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"  Unsupported (pre-v4) Touchpad detected\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Get the Touchpad model information. */
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|&
literal|0x01
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  Failed to read model information\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|synhw
operator|.
name|infoRot180
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|infoPortrait
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x40
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|infoSensor
operator|=
name|status
index|[
literal|0
index|]
operator|&
literal|0x3f
expr_stmt|;
name|synhw
operator|.
name|infoHardware
operator|=
operator|(
name|status
index|[
literal|1
index|]
operator|&
literal|0xfe
operator|)
operator|>>
literal|1
expr_stmt|;
name|synhw
operator|.
name|infoNewAbs
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x80
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|capPen
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x40
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|infoSimplC
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x20
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|infoGeometry
operator|=
name|status
index|[
literal|2
index|]
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"  Model information:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoRot180: %d\n"
argument_list|,
name|synhw
operator|.
name|infoRot180
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoPortrait: %d\n"
argument_list|,
name|synhw
operator|.
name|infoPortrait
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoSensor: %d\n"
argument_list|,
name|synhw
operator|.
name|infoSensor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoHardware: %d\n"
argument_list|,
name|synhw
operator|.
name|infoHardware
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoNewAbs: %d\n"
argument_list|,
name|synhw
operator|.
name|infoNewAbs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capPen: %d\n"
argument_list|,
name|synhw
operator|.
name|capPen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoSimplC: %d\n"
argument_list|,
name|synhw
operator|.
name|infoSimplC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoGeometry: %d\n"
argument_list|,
name|synhw
operator|.
name|infoGeometry
argument_list|)
expr_stmt|;
block|}
comment|/* Read the extended capability bits. */
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|SYNAPTICS_VERSION_GE
argument_list|(
name|synhw
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|)
operator|&&
name|status
index|[
literal|1
index|]
operator|!=
literal|0x47
condition|)
block|{
name|printf
argument_list|(
literal|"  Failed to read extended capability bits\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Set the different capabilities when they exist. */
name|buttons
operator|=
literal|0
expr_stmt|;
name|synhw
operator|.
name|capExtended
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|synhw
operator|.
name|capExtended
condition|)
block|{
name|synhw
operator|.
name|capPassthrough
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x80
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|capSleep
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x10
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|capFourButtons
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x08
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|capMultiFinger
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x02
operator|)
operator|!=
literal|0
expr_stmt|;
name|synhw
operator|.
name|capPalmDetect
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x01
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"  Extended capabilities:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capExtended: %d\n"
argument_list|,
name|synhw
operator|.
name|capExtended
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capPassthrough: %d\n"
argument_list|,
name|synhw
operator|.
name|capPassthrough
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capSleep: %d\n"
argument_list|,
name|synhw
operator|.
name|capSleep
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capFourButtons: %d\n"
argument_list|,
name|synhw
operator|.
name|capFourButtons
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capMultiFinger: %d\n"
argument_list|,
name|synhw
operator|.
name|capMultiFinger
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capPalmDetect: %d\n"
argument_list|,
name|synhw
operator|.
name|capPalmDetect
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we have bits set in status[0]& 0x70, then we can load 		 * more information about buttons using query 0x09. 		 */
if|if
condition|(
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x70
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0x09
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|buttons
operator|=
operator|(
name|status
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
block|}
else|else
name|buttons
operator|=
name|synhw
operator|.
name|capFourButtons
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|synhw
operator|.
name|capExtended
condition|)
name|printf
argument_list|(
literal|"  Additional Buttons: %d\n"
argument_list|,
name|buttons
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  No extended capabilities\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read the mode byte. 	 * 	 * XXX: Note the Synaptics documentation also defines the first 	 * byte of the response to this query to be a constant 0x3b, this 	 * does not appear to be true for Touchpads with guest devices. 	 */
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|SYNAPTICS_VERSION_GE
argument_list|(
name|synhw
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|)
operator|&&
name|status
index|[
literal|1
index|]
operator|!=
literal|0x47
condition|)
block|{
name|printf
argument_list|(
literal|"  Failed to read mode byte\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|synhw
operator|=
name|synhw
expr_stmt|;
if|if
condition|(
operator|!
name|synaptics_support
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Set the mode byte; request wmode where available. */
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
name|synhw
operator|.
name|capExtended
condition|?
literal|0xc1
else|:
literal|0xc0
argument_list|)
expr_stmt|;
comment|/* "Commit" the Set Mode Byte command sent above. */
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|buttons
operator|+=
literal|3
expr_stmt|;
name|VLOG
argument_list|(
literal|3
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"synaptics: END init (%d buttons)\n"
operator|,
name|buttons
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
comment|/* Create sysctl tree. */
name|synaptics_sysctl_create_tree
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|buttons
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* IBM/Lenovo TrackPoint */
end_comment

begin_function
specifier|static
name|int
name|trackpoint_command
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|loc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
specifier|const
name|int
name|seq
index|[]
init|=
block|{
literal|0xe2
block|,
name|cmd
block|,
name|loc
block|,
name|val
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|seq
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|seq
index|[
name|i
index|]
argument_list|)
operator|!=
name|PSM_ACK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PSM_TPINFO
parameter_list|(
name|x
parameter_list|)
value|offsetof(struct psm_softc, tpinfo.x)
end_define

begin_define
define|#
directive|define
name|TPMASK
value|0
end_define

begin_define
define|#
directive|define
name|TPLOC
value|1
end_define

begin_define
define|#
directive|define
name|TPINFO
value|2
end_define

begin_function
specifier|static
name|int
name|trackpoint_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|data
index|[]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|0x00
block|,
literal|0x4a
block|,
name|PSM_TPINFO
argument_list|(
argument|sensitivity
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x4d
block|,
name|PSM_TPINFO
argument_list|(
argument|inertia
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x60
block|,
name|PSM_TPINFO
argument_list|(
argument|uplateau
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x57
block|,
name|PSM_TPINFO
argument_list|(
argument|reach
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x58
block|,
name|PSM_TPINFO
argument_list|(
argument|draghys
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x59
block|,
name|PSM_TPINFO
argument_list|(
argument|mindrag
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x5a
block|,
name|PSM_TPINFO
argument_list|(
argument|upthresh
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x5c
block|,
name|PSM_TPINFO
argument_list|(
argument|threshold
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x5d
block|,
name|PSM_TPINFO
argument_list|(
argument|jenks
argument_list|)
block|}
block|,
block|{
literal|0x00
block|,
literal|0x5e
block|,
name|PSM_TPINFO
argument_list|(
argument|ztime
argument_list|)
block|}
block|,
block|{
literal|0x01
block|,
literal|0x2c
block|,
name|PSM_TPINFO
argument_list|(
argument|pts
argument_list|)
block|}
block|,
block|{
literal|0x08
block|,
literal|0x2d
block|,
name|PSM_TPINFO
argument_list|(
argument|skipback
argument_list|)
block|}
block|}
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|newval
decl_stmt|,
modifier|*
name|oldvalp
decl_stmt|;
specifier|const
name|int
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
operator|||
name|arg2
operator|<
literal|0
operator|||
name|arg2
operator|>=
name|nitems
argument_list|(
name|data
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|tp
operator|=
name|data
index|[
name|arg2
index|]
expr_stmt|;
name|oldvalp
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|sc
operator|+
name|tp
index|[
name|TPINFO
index|]
operator|)
expr_stmt|;
name|newval
operator|=
operator|*
name|oldvalp
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|newval
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|newval
operator|==
operator|*
name|oldvalp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newval
operator|<
literal|0
operator|||
name|newval
operator|>
operator|(
name|tp
index|[
name|TPMASK
index|]
operator|==
literal|0
condition|?
literal|255
else|:
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|trackpoint_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|tp
index|[
name|TPMASK
index|]
operator|==
literal|0
condition|?
literal|0x81
else|:
literal|0x47
argument_list|,
name|tp
index|[
name|TPLOC
index|]
argument_list|,
name|tp
index|[
name|TPMASK
index|]
operator|==
literal|0
condition|?
name|newval
else|:
name|tp
index|[
name|TPMASK
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|oldvalp
operator|=
name|newval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trackpoint_sysctl_create_tree
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
operator|!=
name|NULL
condition|)
return|return;
comment|/* Attach extra trackpoint sysctl nodes under hw.psm.trackpoint */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_psm
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trackpoint"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IBM/Lenovo TrackPoint"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.sensitivity */
name|sc
operator|->
name|tpinfo
operator|.
name|sensitivity
operator|=
literal|0x64
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sensitivity"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_SENSITIVITY
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Sensitivity"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.negative_inertia */
name|sc
operator|->
name|tpinfo
operator|.
name|inertia
operator|=
literal|0x06
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"negative_inertia"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_NEGATIVE_INERTIA
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Negative inertia factor"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.upper_plateau */
name|sc
operator|->
name|tpinfo
operator|.
name|uplateau
operator|=
literal|0x61
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"upper_plateau"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_UPPER_PLATEAU
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Transfer function upper plateau speed"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.backup_range */
name|sc
operator|->
name|tpinfo
operator|.
name|reach
operator|=
literal|0x0a
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"backup_range"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_BACKUP_RANGE
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Backup range"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.drag_hysteresis */
name|sc
operator|->
name|tpinfo
operator|.
name|draghys
operator|=
literal|0xff
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"drag_hysteresis"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_DRAG_HYSTERESIS
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Drag hysteresis"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.minimum_drag */
name|sc
operator|->
name|tpinfo
operator|.
name|mindrag
operator|=
literal|0x14
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"minimum_drag"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_MINIMUM_DRAG
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Minimum drag"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.up_threshold */
name|sc
operator|->
name|tpinfo
operator|.
name|upthresh
operator|=
literal|0xff
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"up_threshold"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_UP_THRESHOLD
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Up threshold for release"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.threshold */
name|sc
operator|->
name|tpinfo
operator|.
name|threshold
operator|=
literal|0x08
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"threshold"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_THRESHOLD
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Threshold"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.jenks_curvature */
name|sc
operator|->
name|tpinfo
operator|.
name|jenks
operator|=
literal|0x87
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"jenks_curvature"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_JENKS_CURVATURE
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Jenks curvature"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.z_time */
name|sc
operator|->
name|tpinfo
operator|.
name|ztime
operator|=
literal|0x26
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"z_time"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_Z_TIME
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Z time constant"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.press_to_select */
name|sc
operator|->
name|tpinfo
operator|.
name|pts
operator|=
literal|0x00
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"press_to_select"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_PRESS_TO_SELECT
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Press to Select"
argument_list|)
expr_stmt|;
comment|/* hw.psm.trackpoint.skip_backups */
name|sc
operator|->
name|tpinfo
operator|.
name|skipback
operator|=
literal|0x00
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tpinfo
operator|.
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"skip_backups"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|sc
argument_list|,
name|TRACKPOINT_SYSCTL_SKIP_BACKUPS
argument_list|,
name|trackpoint_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Skip backups from drags"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|enable_trackpoint
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
if|if
condition|(
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
literal|0xe1
argument_list|)
operator|!=
name|PSM_ACK
operator|||
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
operator|!=
literal|0x01
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|id
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0x01
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|tphw
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|trackpoint_support
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
comment|/* Create sysctl tree. */
name|trackpoint_sysctl_create_tree
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x4a
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|sensitivity
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x4d
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|inertia
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x60
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|uplateau
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x57
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|reach
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x58
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|draghys
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x59
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|mindrag
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x5a
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|upthresh
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x5c
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|threshold
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x5d
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|jenks
argument_list|)
expr_stmt|;
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x81
argument_list|,
literal|0x5e
argument_list|,
name|sc
operator|->
name|tpinfo
operator|.
name|ztime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tpinfo
operator|.
name|pts
operator|==
literal|0x01
condition|)
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x47
argument_list|,
literal|0x2c
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tpinfo
operator|.
name|skipback
operator|==
literal|0x01
condition|)
name|trackpoint_command
argument_list|(
name|kbdc
argument_list|,
literal|0x47
argument_list|,
literal|0x2d
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Interlink electronics VersaPad */
end_comment

begin_function
specifier|static
name|int
name|enable_versapad
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|data
index|[
literal|3
index|]
decl_stmt|;
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_MEDIUM_HIGH
argument_list|)
expr_stmt|;
comment|/* set res. 2 */
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* set rate 100 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
comment|/* get status */
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|data
index|[
literal|2
index|]
operator|!=
literal|0xa
operator|||
name|data
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
comment|/* rate == 0xa&& res. == 0 */
return|return
operator|(
name|FALSE
operator|)
return|;
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* PS/2 absolute mode */
block|}
end_function

begin_comment
comment|/*  * Return true if 'now' is earlier than (start + (secs.usecs)).  * Now may be NULL and the function will fetch the current time from  * getmicrouptime(), or a cached 'now' can be passed in.  * All values should be numbers derived from getmicrouptime().  */
end_comment

begin_function
specifier|static
name|int
name|timeelapsed
parameter_list|(
name|start
parameter_list|,
name|secs
parameter_list|,
name|usecs
parameter_list|,
name|now
parameter_list|)
specifier|const
name|struct
name|timeval
modifier|*
name|start
decl_stmt|,
decl|*
name|now
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|secs
decl_stmt|,
name|usecs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeval
name|snow
decl_stmt|,
name|tv
decl_stmt|;
comment|/* if there is no 'now' passed in, the get it as a convience. */
if|if
condition|(
name|now
operator|==
name|NULL
condition|)
block|{
name|getmicrouptime
argument_list|(
operator|&
name|snow
argument_list|)
expr_stmt|;
name|now
operator|=
operator|&
name|snow
expr_stmt|;
block|}
name|tv
operator|.
name|tv_sec
operator|=
name|secs
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|usecs
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tv
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
name|timevalcmp
argument_list|(
operator|&
name|tv
argument_list|,
name|now
argument_list|,
operator|<
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|psmresume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_NOTICE
operator|,
literal|"psm%d: system resume hook called.\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|&
operator|(
name|PSM_CONFIG_HOOKRESUME
operator||
name|PSM_CONFIG_INITAFTERSUSPEND
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|reinitialize
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_INITAFTERSUSPEND
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
condition|)
block|{
comment|/* 		 * Release the blocked process; it must be notified that 		 * the device cannot be accessed anymore. 		 */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|VLOG
argument_list|(
literal|2
argument_list|,
operator|(
name|LOG_DEBUG
operator|,
literal|"psm%d: system resume hook exiting.\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|psm
argument_list|,
name|atkbdc
argument_list|,
name|psm_driver
argument_list|,
name|psm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_ISA
end_ifdef

begin_comment
comment|/*  * This sucks up assignments from PNPBIOS and ACPI.  */
end_comment

begin_comment
comment|/*  * When the PS/2 mouse device is reported by ACPI or PnP BIOS, it may  * appear BEFORE the AT keyboard controller.  As the PS/2 mouse device  * can be probed and attached only after the AT keyboard controller is  * attached, we shall quietly reserve the IRQ resource for later use.  * If the PS/2 mouse device is reported to us AFTER the keyboard controller,  * copy the IRQ resource to the PS/2 mouse device instance hanging  * under the keyboard controller, then probe and attach it.  */
end_comment

begin_decl_stmt
specifier|static
name|devclass_t
name|psmcpnp_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_probe_t
name|psmcpnp_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|psmcpnp_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|psmcpnp_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|psmcpnp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|psmcpnp_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|psmcpnp_driver
init|=
block|{
name|PSMCPNP_DRIVER_NAME
block|,
name|psmcpnp_methods
block|,
literal|1
block|,
comment|/* no softc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|isa_pnp_id
name|psmcpnp_ids
index|[]
init|=
block|{
block|{
literal|0x030fd041
block|,
literal|"PS/2 mouse port"
block|}
block|,
comment|/* PNP0F03 */
block|{
literal|0x0e0fd041
block|,
literal|"PS/2 mouse port"
block|}
block|,
comment|/* PNP0F0E */
block|{
literal|0x120fd041
block|,
literal|"PS/2 mouse port"
block|}
block|,
comment|/* PNP0F12 */
block|{
literal|0x130fd041
block|,
literal|"PS/2 mouse port"
block|}
block|,
comment|/* PNP0F13 */
block|{
literal|0x1303d041
block|,
literal|"PS/2 port"
block|}
block|,
comment|/* PNP0313, XXX */
block|{
literal|0x02002e4f
block|,
literal|"Dell PS/2 mouse port"
block|}
block|,
comment|/* Lat. X200, Dell */
block|{
literal|0x0002a906
block|,
literal|"ALPS Glide Point"
block|}
block|,
comment|/* ALPS Glide Point */
block|{
literal|0x80374d24
block|,
literal|"IBM PS/2 mouse port"
block|}
block|,
comment|/* IBM3780, ThinkPad */
block|{
literal|0x81374d24
block|,
literal|"IBM PS/2 mouse port"
block|}
block|,
comment|/* IBM3781, ThinkPad */
block|{
literal|0x0190d94d
block|,
literal|"SONY VAIO PS/2 mouse port"
block|}
block|,
comment|/* SNY9001, Vaio */
block|{
literal|0x0290d94d
block|,
literal|"SONY VAIO PS/2 mouse port"
block|}
block|,
comment|/* SNY9002, Vaio */
block|{
literal|0x0390d94d
block|,
literal|"SONY VAIO PS/2 mouse port"
block|}
block|,
comment|/* SNY9003, Vaio */
block|{
literal|0x0490d94d
block|,
literal|"SONY VAIO PS/2 mouse port"
block|}
block|,
comment|/* SNY9004, Vaio */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|create_a_copy
parameter_list|(
name|device_t
name|atkbdc
parameter_list|,
name|device_t
name|me
parameter_list|)
block|{
name|device_t
name|psm
decl_stmt|;
name|u_long
name|irq
decl_stmt|;
comment|/* find the PS/2 mouse device instance under the keyboard controller */
name|psm
operator|=
name|device_find_child
argument_list|(
name|atkbdc
argument_list|,
name|PSM_DRIVER_NAME
argument_list|,
name|device_get_unit
argument_list|(
name|atkbdc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psm
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|device_get_state
argument_list|(
name|psm
argument_list|)
operator|!=
name|DS_NOTPRESENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* move our resource to the found device */
name|irq
operator|=
name|bus_get_resource_start
argument_list|(
name|me
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_delete_resource
argument_list|(
name|me
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|psm
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|KBDC_RID_AUX
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ...then probe and attach it */
return|return
operator|(
name|device_probe_and_attach
argument_list|(
name|psm
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmcpnp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|u_long
name|irq
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|ISA_PNP_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|psmcpnp_ids
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * The PnP BIOS and ACPI are supposed to assign an IRQ (12) 	 * to the PS/2 mouse device node. But, some buggy PnP BIOS 	 * declares the PS/2 mouse device node without an IRQ resource! 	 * If this happens, we shall refer to device hints. 	 * If we still don't find it there, use a hardcoded value... XXX 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|irq
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|resource_long_value
argument_list|(
name|PSM_DRIVER_NAME
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"irq"
argument_list|,
operator|&
name|irq
argument_list|)
operator|!=
literal|0
condition|)
name|irq
operator|=
literal|12
expr_stmt|;
comment|/* XXX */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"irq resource info is missing; "
literal|"assuming irq %ld\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
comment|/* keep quiet */
if|if
condition|(
operator|!
name|bootverbose
condition|)
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|NULL
operator|)
condition|?
name|ENXIO
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmcpnp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|atkbdc
decl_stmt|;
comment|/* find the keyboard controller, which may be on acpi* or isa* bus */
name|atkbdc
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
name|ATKBDC_DRIVER_NAME
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|atkbdc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|device_get_state
argument_list|(
name|atkbdc
argument_list|)
operator|==
name|DS_ATTACHED
operator|)
condition|)
name|create_a_copy
argument_list|(
name|atkbdc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|psmcpnp
argument_list|,
name|isa
argument_list|,
name|psmcpnp_driver
argument_list|,
name|psmcpnp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|psmcpnp
argument_list|,
name|acpi
argument_list|,
name|psmcpnp_driver
argument_list|,
name|psmcpnp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_ISA */
end_comment

end_unit

