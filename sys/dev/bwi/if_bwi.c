begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007 The DragonFly Project.  All rights reserved.  *   * This code is derived from software contributed to The DragonFly Project  * by Sepherosa Ziehau<sepherosa@gmail.com>  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of The DragonFly Project nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific, prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * $DragonFly: src/sys/dev/netif/bwi/if_bwi.c,v 1.19 2008/02/15 11:15:38 sephe Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_bwi.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_phy.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/bitops.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/if_bwireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/if_bwivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/bwimac.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/bwirf.h>
end_include

begin_struct
struct|struct
name|bwi_clock_freq
block|{
name|u_int
name|clkfreq_min
decl_stmt|;
name|u_int
name|clkfreq_max
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bwi_myaddr_bssid
block|{
name|uint8_t
name|myaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|bwi_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_init
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_transmit
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_start_locked
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_updateslot
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_calibrate
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_calc_rssi
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|bwi_rxbuf_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_calc_noise
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint8_t
name|bwi_plcp2rate
parameter_list|(
name|uint32_t
parameter_list|,
name|enum
name|ieee80211_phytype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_rx_radiotap
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|bwi_rxbuf_hdr
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_restart
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_init_statechg
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_stop
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_stop_locked
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_newbuf
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_encap
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_encap_raw
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_init_rxdesc_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|bus_addr_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_reset_rx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_init_tx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_init_rx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_init_txstats32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_free_tx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_free_rx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_free_txstats32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_setup_rx_desc32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_addr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_setup_tx_desc32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|struct
name|bwi_ring_data
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_addr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_rxeof32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_start_tx32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_txeof_status32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_init_tx_ring64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_init_rx_ring64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_init_txstats64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_free_tx_ring64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_free_rx_ring64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_free_txstats64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_setup_rx_desc64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_addr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_setup_tx_desc64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|struct
name|bwi_ring_data
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_addr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_rxeof64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_start_tx64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_txeof_status64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_rxeof
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_bwi_txeof
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_txeof
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_txeof_status
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_enable_intrs
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_disable_intrs
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_dma_alloc
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_dma_free
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_dma_ring_alloc
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|bus_dma_tag_t
parameter_list|,
name|struct
name|bwi_ring_data
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_dma_mbuf_create
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_dma_mbuf_destroy
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_dma_txstats_alloc
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_dma_txstats_free
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_dma_ring_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_dma_buf_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_power_on
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_power_off
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_set_clock_mode
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|enum
name|bwi_clock_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_set_clock_delay
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_get_clock_freq
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|struct
name|bwi_clock_freq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_get_pwron_delay
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_set_addr_filter
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_set_bssid
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_get_card_flags
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_get_eaddr
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_bus_attach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_bbp_attach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_bbp_power_on
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|enum
name|bwi_clock_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_bbp_power_off
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|bwi_regwin_name
parameter_list|(
specifier|const
name|struct
name|bwi_regwin
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|bwi_regwin_disable_bits
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_regwin_info
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_regwin_select
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_led_attach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_led_newstate
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_led_event
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_led_blink_start
parameter_list|(
name|struct
name|bwi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_led_blink_next
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_led_blink_end
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|did_min
decl_stmt|;
name|uint16_t
name|did_max
decl_stmt|;
name|uint16_t
name|bbp_id
decl_stmt|;
block|}
name|bwi_bbpid_map
index|[]
init|=
block|{
block|{
literal|0x4301
block|,
literal|0x4301
block|,
literal|0x4301
block|}
block|,
block|{
literal|0x4305
block|,
literal|0x4307
block|,
literal|0x4307
block|}
block|,
block|{
literal|0x4402
block|,
literal|0x4403
block|,
literal|0x4402
block|}
block|,
block|{
literal|0x4610
block|,
literal|0x4615
block|,
literal|0x4610
block|}
block|,
block|{
literal|0x4710
block|,
literal|0x4715
block|,
literal|0x4710
block|}
block|,
block|{
literal|0x4720
block|,
literal|0x4725
block|,
literal|0x4309
block|}
block|}
struct|;
end_struct

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|bbp_id
decl_stmt|;
name|int
name|nregwin
decl_stmt|;
block|}
name|bwi_regwin_count
index|[]
init|=
block|{
block|{
literal|0x4301
block|,
literal|5
block|}
block|,
block|{
literal|0x4306
block|,
literal|6
block|}
block|,
block|{
literal|0x4307
block|,
literal|5
block|}
block|,
block|{
literal|0x4310
block|,
literal|8
block|}
block|,
block|{
literal|0x4401
block|,
literal|3
block|}
block|,
block|{
literal|0x4402
block|,
literal|3
block|}
block|,
block|{
literal|0x4610
block|,
literal|9
block|}
block|,
block|{
literal|0x4704
block|,
literal|9
block|}
block|,
block|{
literal|0x4710
block|,
literal|9
block|}
block|,
block|{
literal|0x5365
block|,
literal|7
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CLKSRC
parameter_list|(
name|src
parameter_list|)
define|\
value|[BWI_CLKSRC_ ## src] = {			\ 	.freq_min = BWI_CLKSRC_ ##src## _FMIN,	\ 	.freq_max = BWI_CLKSRC_ ##src## _FMAX	\ }
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|u_int
name|freq_min
decl_stmt|;
name|u_int
name|freq_max
decl_stmt|;
block|}
name|bwi_clkfreq
index|[
name|BWI_CLKSRC_MAX
index|]
init|=
block|{
name|CLKSRC
argument_list|(
name|LP_OSC
argument_list|)
block|,
name|CLKSRC
argument_list|(
name|CS_OSC
argument_list|)
block|,
name|CLKSRC
argument_list|(
argument|PCI
argument_list|)
block|}
struct|;
end_struct

begin_undef
undef|#
directive|undef
name|CLKSRC
end_undef

begin_define
define|#
directive|define
name|VENDOR_LED_ACT
parameter_list|(
name|vendor
parameter_list|)
define|\
value|{							\ 	.vid = PCI_VENDOR_##vendor,			\ 	.led_act = { BWI_VENDOR_LED_ACT_##vendor }	\ }
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
define|#
directive|define
name|PCI_VENDOR_COMPAQ
value|0x0e11
define|#
directive|define
name|PCI_VENDOR_LINKSYS
value|0x1737
name|uint16_t
name|vid
decl_stmt|;
name|uint8_t
name|led_act
index|[
name|BWI_LED_MAX
index|]
decl_stmt|;
block|}
name|bwi_vendor_led_act
index|[]
init|=
block|{
name|VENDOR_LED_ACT
argument_list|(
name|COMPAQ
argument_list|)
block|,
name|VENDOR_LED_ACT
argument_list|(
argument|LINKSYS
argument_list|)
undef|#
directive|undef
name|PCI_VENDOR_LINKSYS
undef|#
directive|undef
name|PCI_VENDOR_COMPAQ
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|bwi_default_led_act
index|[
name|BWI_LED_MAX
index|]
init|=
block|{
name|BWI_VENDOR_LED_ACT_DEFAULT
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|VENDOR_LED_ACT
end_undef

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|on_dur
decl_stmt|;
name|int
name|off_dur
decl_stmt|;
block|}
name|bwi_led_duration
index|[
literal|109
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
literal|400
block|,
literal|100
block|}
block|,
index|[
literal|2
index|]
operator|=
block|{
literal|150
block|,
literal|75
block|}
block|,
index|[
literal|4
index|]
operator|=
block|{
literal|90
block|,
literal|45
block|}
block|,
index|[
literal|11
index|]
operator|=
block|{
literal|66
block|,
literal|34
block|}
block|,
index|[
literal|12
index|]
operator|=
block|{
literal|53
block|,
literal|26
block|}
block|,
index|[
literal|18
index|]
operator|=
block|{
literal|42
block|,
literal|21
block|}
block|,
index|[
literal|22
index|]
operator|=
block|{
literal|35
block|,
literal|17
block|}
block|,
index|[
literal|24
index|]
operator|=
block|{
literal|32
block|,
literal|16
block|}
block|,
index|[
literal|36
index|]
operator|=
block|{
literal|21
block|,
literal|10
block|}
block|,
index|[
literal|48
index|]
operator|=
block|{
literal|16
block|,
literal|8
block|}
block|,
index|[
literal|72
index|]
operator|=
block|{
literal|11
block|,
literal|5
block|}
block|,
index|[
literal|96
index|]
operator|=
block|{
literal|9
block|,
literal|4
block|}
block|,
index|[
literal|108
index|]
operator|=
block|{
literal|7
block|,
literal|3
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|bwi_chan_2ghz
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BWI_DEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BWI_DEBUG_VERBOSE
end_ifdef

begin_decl_stmt
specifier|static
name|uint32_t
name|bwi_debug
init|=
name|BWI_DBG_ATTACH
operator||
name|BWI_DBG_INIT
operator||
name|BWI_DBG_TXPOWER
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|uint32_t
name|bwi_debug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bwi.debug"
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|bwi_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BWI_DEBUG */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|bwi_zero_addr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|uint16_t
name|bwi_read_sprom
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|ofs
parameter_list|)
block|{
return|return
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|ofs
operator|+
name|BWI_SPROM_START
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|bwi_setup_desc32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_desc32
modifier|*
name|desc_array
parameter_list|,
name|int
name|ndesc
parameter_list|,
name|int
name|desc_idx
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|int
name|tx
parameter_list|)
block|{
name|struct
name|bwi_desc32
modifier|*
name|desc
init|=
operator|&
name|desc_array
index|[
name|desc_idx
index|]
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|,
name|addr
decl_stmt|,
name|addr_hi
decl_stmt|,
name|addr_lo
decl_stmt|;
name|addr_lo
operator|=
name|__SHIFTOUT
argument_list|(
name|paddr
argument_list|,
name|BWI_DESC32_A_ADDR_MASK
argument_list|)
expr_stmt|;
name|addr_hi
operator|=
name|__SHIFTOUT
argument_list|(
name|paddr
argument_list|,
name|BWI_DESC32_A_FUNC_MASK
argument_list|)
expr_stmt|;
name|addr
operator|=
name|__SHIFTIN
argument_list|(
name|addr_lo
argument_list|,
name|BWI_DESC32_A_ADDR_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|BWI_DESC32_A_FUNC_TXRX
argument_list|,
name|BWI_DESC32_A_FUNC_MASK
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|__SHIFTIN
argument_list|(
name|buf_len
argument_list|,
name|BWI_DESC32_C_BUFLEN_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|addr_hi
argument_list|,
name|BWI_DESC32_C_ADDRHI_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc_idx
operator|==
name|ndesc
operator|-
literal|1
condition|)
name|ctrl
operator||=
name|BWI_DESC32_C_EOR
expr_stmt|;
if|if
condition|(
name|tx
condition|)
block|{
comment|/* XXX */
name|ctrl
operator||=
name|BWI_DESC32_C_FRAME_START
operator||
name|BWI_DESC32_C_FRAME_END
operator||
name|BWI_DESC32_C_INTR
expr_stmt|;
block|}
name|desc
operator|->
name|addr
operator|=
name|htole32
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|ctrl
operator|=
name|htole32
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bwi_attach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|sc_dev
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|struct
name|bwi_phy
modifier|*
name|phy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|BWI_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize taskq and various tasks 	 */
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"bwi_taskq"
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_restart_task
argument_list|,
literal|0
argument_list|,
name|bwi_restart
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize sysctl variables 	 */
name|sc
operator|->
name|sc_fw_version
operator|=
name|BWI_FW_VERSION3
expr_stmt|;
name|sc
operator|->
name|sc_led_idle
operator|=
operator|(
literal|2350
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_led_ticks
operator|=
name|ticks
operator|-
name|sc
operator|->
name|sc_led_idle
expr_stmt|;
name|sc
operator|->
name|sc_led_blink
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_txpwr_calib
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BWI_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
name|bwi_debug
expr_stmt|;
endif|#
directive|endif
name|bwi_power_on
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwi_bbp_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bwi_bbp_power_on
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_MODE_FAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|BWI_REGWIN_EXIST
argument_list|(
operator|&
name|sc
operator|->
name|sc_com_regwin
argument_list|)
condition|)
block|{
name|error
operator|=
name|bwi_set_clock_delay
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bwi_set_clock_mode
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_MODE_FAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bwi_get_pwron_delay
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bwi_bus_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|bwi_get_card_flags
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bwi_led_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nmac
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|old
decl_stmt|;
name|mac
operator|=
operator|&
name|sc
operator|->
name|sc_mac
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bwi_mac_lateattach
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * XXX First MAC is known to exist 	 * TODO2 	 */
name|mac
operator|=
operator|&
name|sc
operator|->
name|sc_mac
index|[
literal|0
index|]
expr_stmt|;
name|phy
operator|=
operator|&
name|mac
operator|->
name|mac_phy
expr_stmt|;
name|bwi_bbp_power_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwi_dma_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bwi_mac_fw_alloc
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_timer
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Setup ratesets, phytype, channels and get MAC address 	 */
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11B
operator|||
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11G
condition|)
block|{
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11B
condition|)
block|{
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_DS
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
block|}
name|bwi_get_eaddr
argument_list|(
name|sc
argument_list|,
name|BWI_SPROM_11BG_EADDR
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|ic
operator|->
name|ic_macaddr
argument_list|)
condition|)
block|{
name|bwi_get_eaddr
argument_list|(
name|sc
argument_list|,
name|BWI_SPROM_11A_EADDR
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|ic
operator|->
name|ic_macaddr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid MAC address: %6D\n"
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11A
condition|)
block|{
comment|/* TODO:11A */
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"unknown phymode %d\n"
argument_list|,
name|phy
operator|->
name|phy_mode
argument_list|)
expr_stmt|;
block|}
comment|/* Get locale */
name|sc
operator|->
name|sc_locale
operator|=
name|__SHIFTOUT
argument_list|(
name|bwi_read_sprom
argument_list|(
name|sc
argument_list|,
name|BWI_SPROM_CARD_INFO
argument_list|)
argument_list|,
name|BWI_SPROM_CARD_INFO_LOCALE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
argument_list|,
literal|"locale: %d\n"
argument_list|,
name|sc
operator|->
name|sc_locale
argument_list|)
expr_stmt|;
comment|/* XXX use locale */
name|bwi_getradiocaps
argument_list|(
name|ic
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_softc
operator|=
name|sc
expr_stmt|;
name|ic
operator|->
name|ic_name
operator|=
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
operator||
name|IEEE80211_C_SHSLOT
operator||
name|IEEE80211_C_SHPREAMBLE
operator||
name|IEEE80211_C_WPA
operator||
name|IEEE80211_C_BGSCAN
operator||
name|IEEE80211_C_MONITOR
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_headroom
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_txbuf_hdr
argument_list|)
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_vap_create
operator|=
name|bwi_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|bwi_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|bwi_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_updateslot
operator|=
name|bwi_updateslot
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|bwi_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|bwi_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|bwi_getradiocaps
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|bwi_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_transmit
operator|=
name|bwi_transmit
expr_stmt|;
name|ic
operator|->
name|ic_parent
operator|=
name|bwi_parent
expr_stmt|;
name|sc
operator|->
name|sc_rates
operator|=
name|ieee80211_get_ratetable
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
name|BWI_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
argument_list|,
name|BWI_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
comment|/* 	 * Add sysctl nodes 	 */
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_fw_version
argument_list|,
literal|0
argument_list|,
literal|"Firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"led_idle"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_led_idle
argument_list|,
literal|0
argument_list|,
literal|"# ticks before LED enters idle state"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"led_blink"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_led_blink
argument_list|,
literal|0
argument_list|,
literal|"Allow LED to blink"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txpwr_calib"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_txpwr_calib
argument_list|,
literal|0
argument_list|,
literal|"Enable software TX power calibration"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BWI_DEBUG
name|SYSCTL_ADD_UINT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug flags"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|BWI_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bwi_detach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bwi_stop
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_blink_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_timer
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nmac
condition|;
operator|++
name|i
control|)
name|bwi_mac_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_mac
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bwi_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|mbufq_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|)
expr_stmt|;
name|BWI_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|bwi_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|bwi_vap
modifier|*
name|bvp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|bvp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vap
operator|=
operator|&
name|bvp
operator|->
name|bv_vap
expr_stmt|;
comment|/* enable s/w bmiss handling for sta mode */
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
operator||
name|IEEE80211_CLONE_NOBEACONS
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
comment|/* override default methods */
name|bvp
operator|->
name|bv_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|bwi_newstate
expr_stmt|;
if|#
directive|if
literal|0
block|vap->iv_update_beacon = bwi_beacon_update;
endif|#
directive|endif
name|ieee80211_ratectl_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|bwi_media_change
argument_list|,
name|ieee80211_media_status
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|bwi_vap
modifier|*
name|bvp
init|=
name|BWI_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_ratectl_deinit
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_suspend
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bwi_stop
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_resume
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_nrunning
operator|>
literal|0
condition|)
name|bwi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bwi_shutdown
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bwi_stop
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_power_on
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|with_pll
parameter_list|)
block|{
name|uint32_t
name|gpio_in
decl_stmt|,
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|gpio_in
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_IN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpio_in
operator|&
name|BWI_PCIM_GPIO_PWR_ON
condition|)
goto|goto
name|back
goto|;
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_ENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_out
operator||=
name|BWI_PCIM_GPIO_PWR_ON
expr_stmt|;
name|gpio_en
operator||=
name|BWI_PCIM_GPIO_PWR_ON
expr_stmt|;
if|if
condition|(
name|with_pll
condition|)
block|{
comment|/* Turn off PLL first */
name|gpio_out
operator||=
name|BWI_PCIM_GPIO_PLL_PWR_OFF
expr_stmt|;
name|gpio_en
operator||=
name|BWI_PCIM_GPIO_PLL_PWR_OFF
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_ENABLE
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_pll
condition|)
block|{
comment|/* Turn on PLL */
name|gpio_out
operator|&=
operator|~
name|BWI_PCIM_GPIO_PLL_PWR_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
name|back
label|:
comment|/* Clear "Signaled Target Abort" */
name|status
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|PCIM_STATUS_STABORT
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_power_off
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|with_pll
parameter_list|)
block|{
name|uint32_t
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_IN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* dummy read */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_ENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_out
operator|&=
operator|~
name|BWI_PCIM_GPIO_PWR_ON
expr_stmt|;
name|gpio_en
operator||=
name|BWI_PCIM_GPIO_PWR_ON
expr_stmt|;
if|if
condition|(
name|with_pll
condition|)
block|{
name|gpio_out
operator||=
name|BWI_PCIM_GPIO_PLL_PWR_OFF
expr_stmt|;
name|gpio_en
operator||=
name|BWI_PCIM_GPIO_PLL_PWR_OFF
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_ENABLE
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bwi_regwin_switch
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_regwin
modifier|*
name|rw
parameter_list|,
name|struct
name|bwi_regwin
modifier|*
modifier|*
name|old_rw
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|old_rw
operator|!=
name|NULL
condition|)
operator|*
name|old_rw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|BWI_REGWIN_EXIST
argument_list|(
name|rw
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|sc
operator|->
name|sc_cur_regwin
operator|!=
name|rw
condition|)
block|{
name|error
operator|=
name|bwi_regwin_select
argument_list|(
name|sc
argument_list|,
name|rw
operator|->
name|rw_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't select regwin %d\n"
argument_list|,
name|rw
operator|->
name|rw_id
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
name|old_rw
operator|!=
name|NULL
condition|)
operator|*
name|old_rw
operator|=
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|sc
operator|->
name|sc_cur_regwin
operator|=
name|rw
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_regwin_select
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint32_t
name|win
init|=
name|BWI_PCIM_REGWIN
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|RETRY_MAX
value|50
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RETRY_MAX
condition|;
operator|++
name|i
control|)
block|{
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_SEL_REGWIN
argument_list|,
name|win
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_SEL_REGWIN
argument_list|,
literal|4
argument_list|)
operator|==
name|win
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|RETRY_MAX
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_regwin_info
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
modifier|*
name|type
parameter_list|,
name|uint8_t
modifier|*
name|rev
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_ID_HI
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|BWI_ID_HI_REGWIN_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|rev
operator|=
name|BWI_ID_HI_REGWIN_REV
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
argument_list|,
literal|"regwin: type 0x%03x, rev %d, "
literal|"vendor 0x%04x\n"
argument_list|,
operator|*
name|type
argument_list|,
operator|*
name|rev
argument_list|,
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_ID_HI_REGWIN_VENDOR_MASK
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_bbp_attach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|bbp_id
decl_stmt|,
name|rw_type
decl_stmt|;
name|uint8_t
name|rw_rev
decl_stmt|;
name|uint32_t
name|info
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nregwin
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Get 0th regwin information 	 * NOTE: 0th regwin should exist 	 */
name|error
operator|=
name|bwi_regwin_select
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't select regwin 0\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|bwi_regwin_info
argument_list|(
name|sc
argument_list|,
operator|&
name|rw_type
argument_list|,
operator|&
name|rw_rev
argument_list|)
expr_stmt|;
comment|/* 	 * Find out BBP id 	 */
name|bbp_id
operator|=
literal|0
expr_stmt|;
name|info
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rw_type
operator|==
name|BWI_REGWIN_T_COM
condition|)
block|{
name|info
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_INFO
argument_list|)
expr_stmt|;
name|bbp_id
operator|=
name|__SHIFTOUT
argument_list|(
name|info
argument_list|,
name|BWI_INFO_BBPID_MASK
argument_list|)
expr_stmt|;
name|BWI_CREATE_REGWIN
argument_list|(
operator|&
name|sc
operator|->
name|sc_com_regwin
argument_list|,
literal|0
argument_list|,
name|rw_type
argument_list|,
name|rw_rev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cap
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_CAPABILITY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|bwi_bbpid_map
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_pci_did
operator|>=
name|bwi_bbpid_map
index|[
name|i
index|]
operator|.
name|did_min
operator|&&
name|sc
operator|->
name|sc_pci_did
operator|<=
name|bwi_bbpid_map
index|[
name|i
index|]
operator|.
name|did_max
condition|)
block|{
name|bbp_id
operator|=
name|bwi_bbpid_map
index|[
name|i
index|]
operator|.
name|bbp_id
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bbp_id
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no BBP id for device id "
literal|"0x%04x\n"
argument_list|,
name|sc
operator|->
name|sc_pci_did
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|info
operator|=
name|__SHIFTIN
argument_list|(
name|sc
operator|->
name|sc_pci_revid
argument_list|,
name|BWI_INFO_BBPREV_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
literal|0
argument_list|,
name|BWI_INFO_BBPPKG_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find out number of regwins 	 */
name|nregwin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rw_type
operator|==
name|BWI_REGWIN_T_COM
operator|&&
name|rw_rev
operator|>=
literal|4
condition|)
block|{
name|nregwin
operator|=
name|__SHIFTOUT
argument_list|(
name|info
argument_list|,
name|BWI_INFO_NREGWIN_MASK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|bwi_regwin_count
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bwi_regwin_count
index|[
name|i
index|]
operator|.
name|bbp_id
operator|==
name|bbp_id
condition|)
block|{
name|nregwin
operator|=
name|bwi_regwin_count
index|[
name|i
index|]
operator|.
name|nregwin
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nregwin
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no number of win for "
literal|"BBP id 0x%04x\n"
argument_list|,
name|bbp_id
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
comment|/* Record BBP id/rev for later using */
name|sc
operator|->
name|sc_bbp_id
operator|=
name|bbp_id
expr_stmt|;
name|sc
operator|->
name|sc_bbp_rev
operator|=
name|__SHIFTOUT
argument_list|(
name|info
argument_list|,
name|BWI_INFO_BBPREV_MASK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bbp_pkg
operator|=
name|__SHIFTOUT
argument_list|(
name|info
argument_list|,
name|BWI_INFO_BBPPKG_MASK
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"BBP: id 0x%04x, rev 0x%x, pkg %d\n"
argument_list|,
name|sc
operator|->
name|sc_bbp_id
argument_list|,
name|sc
operator|->
name|sc_bbp_rev
argument_list|,
name|sc
operator|->
name|sc_bbp_pkg
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
argument_list|,
literal|"nregwin %d, cap 0x%08x\n"
argument_list|,
name|nregwin
argument_list|,
name|sc
operator|->
name|sc_cap
argument_list|)
expr_stmt|;
comment|/* 	 * Create rest of the regwins 	 */
comment|/* Don't re-create common regwin, if it is already created */
name|i
operator|=
name|BWI_REGWIN_EXIST
argument_list|(
operator|&
name|sc
operator|->
name|sc_com_regwin
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nregwin
condition|;
operator|++
name|i
control|)
block|{
comment|/* 		 * Get regwin information 		 */
name|error
operator|=
name|bwi_regwin_select
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't select regwin %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|bwi_regwin_info
argument_list|(
name|sc
argument_list|,
operator|&
name|rw_type
argument_list|,
operator|&
name|rw_rev
argument_list|)
expr_stmt|;
comment|/* 		 * Try attach: 		 * 1) Bus (PCI/PCIE) regwin 		 * 2) MAC regwin 		 * Ignore rest types of regwin 		 */
if|if
condition|(
name|rw_type
operator|==
name|BWI_REGWIN_T_BUSPCI
operator|||
name|rw_type
operator|==
name|BWI_REGWIN_T_BUSPCIE
condition|)
block|{
if|if
condition|(
name|BWI_REGWIN_EXIST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus_regwin
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"bus regwin already exists\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BWI_CREATE_REGWIN
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus_regwin
argument_list|,
name|i
argument_list|,
name|rw_type
argument_list|,
name|rw_rev
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
condition|)
block|{
comment|/* XXX ignore return value */
name|bwi_mac_attach
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|rw_rev
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At least one MAC shold exist */
if|if
condition|(
operator|!
name|BWI_REGWIN_EXIST
argument_list|(
operator|&
name|sc
operator|->
name|sc_mac
index|[
literal|0
index|]
operator|.
name|mac_regwin
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no MAC was found\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_nmac
operator|>
literal|0
argument_list|,
operator|(
literal|"no mac's"
operator|)
argument_list|)
expr_stmt|;
comment|/* Bus regwin must exist */
if|if
condition|(
operator|!
name|BWI_REGWIN_EXIST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus_regwin
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no bus regwin was found\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Start with first MAC */
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mac
index|[
literal|0
index|]
operator|.
name|mac_regwin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bwi_bus_init
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|old
decl_stmt|,
modifier|*
name|bus
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bus
operator|=
operator|&
name|sc
operator|->
name|sc_bus_regwin
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|==
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|,
operator|(
literal|"not cur regwin"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Tell bus to generate requested interrupts 	 */
if|if
condition|(
name|bus
operator|->
name|rw_rev
operator|<
literal|6
operator|&&
name|bus
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_BUSPCI
condition|)
block|{
comment|/* 		 * NOTE: Read BWI_FLAGS from MAC regwin 		 */
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_FLAGS
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_INTRVEC
argument_list|,
operator|(
name|val
operator|&
name|BWI_FLAGS_INTR_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|mac_mask
decl_stmt|;
name|mac_mask
operator|=
literal|1
operator|<<
name|mac
operator|->
name|mac_id
expr_stmt|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_INTCTL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator||=
name|mac_mask
operator|<<
literal|8
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_INTCTL
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_BUS_INITED
condition|)
goto|goto
name|back
goto|;
if|if
condition|(
name|bus
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_BUSPCI
condition|)
block|{
comment|/* 		 * Enable prefetch and burst 		 */
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_BUS_CONFIG
argument_list|,
name|BWI_BUS_CONFIG_PREFETCH
operator||
name|BWI_BUS_CONFIG_BURST
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|rw_rev
operator|<
literal|5
condition|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|com
init|=
operator|&
name|sc
operator|->
name|sc_com_regwin
decl_stmt|;
comment|/* 			 * Configure timeouts for bus operation 			 */
comment|/* 			 * Set service timeout and request timeout 			 */
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_CONF_LO
argument_list|,
name|__SHIFTIN
argument_list|(
name|BWI_CONF_LO_SERVTO
argument_list|,
name|BWI_CONF_LO_SERVTO_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|BWI_CONF_LO_REQTO
argument_list|,
name|BWI_CONF_LO_REQTO_MASK
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If there is common regwin, we switch to that regwin 			 * and switch back to bus regwin once we have done. 			 */
if|if
condition|(
name|BWI_REGWIN_EXIST
argument_list|(
name|com
argument_list|)
condition|)
block|{
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* Let bus know what we have changed */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_BUS_ADDR
argument_list|,
name|BWI_BUS_ADDR_MAGIC
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_BUS_ADDR
argument_list|)
expr_stmt|;
comment|/* Flush */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_BUS_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_BUS_DATA
argument_list|)
expr_stmt|;
comment|/* Flush */
if|if
condition|(
name|BWI_REGWIN_EXIST
argument_list|(
name|com
argument_list|)
condition|)
block|{
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|bus
operator|->
name|rw_rev
operator|>=
literal|11
condition|)
block|{
comment|/* 			 * Enable memory read multiple 			 */
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_BUS_CONFIG
argument_list|,
name|BWI_BUS_CONFIG_MRM
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* TODO:PCIE */
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|BWI_F_BUS_INITED
expr_stmt|;
name|back
label|:
return|return
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_get_card_flags
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|PCI_VENDOR_APPLE
value|0x106b
define|#
directive|define
name|PCI_VENDOR_DELL
value|0x1028
name|sc
operator|->
name|sc_card_flags
operator|=
name|bwi_read_sprom
argument_list|(
name|sc
argument_list|,
name|BWI_SPROM_CARD_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_card_flags
operator|==
literal|0xffff
condition|)
name|sc
operator|->
name|sc_card_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pci_subvid
operator|==
name|PCI_VENDOR_DELL
operator|&&
name|sc
operator|->
name|sc_bbp_id
operator|==
name|BWI_BBPID_BCM4301
operator|&&
name|sc
operator|->
name|sc_pci_revid
operator|==
literal|0x74
condition|)
name|sc
operator|->
name|sc_card_flags
operator||=
name|BWI_CARD_F_BT_COEXIST
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pci_subvid
operator|==
name|PCI_VENDOR_APPLE
operator|&&
name|sc
operator|->
name|sc_pci_subdid
operator|==
literal|0x4e
operator|&&
comment|/* XXX */
name|sc
operator|->
name|sc_pci_revid
operator|>
literal|0x40
condition|)
name|sc
operator|->
name|sc_card_flags
operator||=
name|BWI_CARD_F_PA_GPIO9
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
argument_list|,
literal|"card flags 0x%04x\n"
argument_list|,
name|sc
operator|->
name|sc_card_flags
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PCI_VENDOR_DELL
undef|#
directive|undef
name|PCI_VENDOR_APPLE
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_get_eaddr
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|eaddr_ofs
parameter_list|,
name|uint8_t
modifier|*
name|eaddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|eaddr
operator|+
name|i
operator|)
operator|=
name|htobe16
argument_list|(
name|bwi_read_sprom
argument_list|(
name|sc
argument_list|,
name|eaddr_ofs
operator|+
literal|2
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_get_clock_freq
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_clock_freq
modifier|*
name|freq
parameter_list|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|com
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|u_int
name|div
decl_stmt|;
name|int
name|src
decl_stmt|;
name|bzero
argument_list|(
name|freq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|freq
argument_list|)
argument_list|)
expr_stmt|;
name|com
operator|=
operator|&
name|sc
operator|->
name|sc_com_regwin
expr_stmt|;
name|KASSERT
argument_list|(
name|BWI_REGWIN_EXIST
argument_list|(
name|com
argument_list|)
argument_list|,
operator|(
literal|"regwin does not exist"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|==
name|com
argument_list|,
operator|(
literal|"wrong regwin"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cap
operator|&
name|BWI_CAP_CLKMODE
argument_list|,
operator|(
literal|"wrong clock mode"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate clock frequency 	 */
name|src
operator|=
operator|-
literal|1
expr_stmt|;
name|div
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|rw_rev
operator|<
literal|6
condition|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|BWI_PCIR_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BWI_PCIM_GPIO_OUT_CLKSRC
condition|)
block|{
name|src
operator|=
name|BWI_CLKSRC_PCI
expr_stmt|;
name|div
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|BWI_CLKSRC_CS_OSC
expr_stmt|;
name|div
operator|=
literal|32
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|com
operator|->
name|rw_rev
operator|<
literal|10
condition|)
block|{
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_CTRL
argument_list|)
expr_stmt|;
name|src
operator|=
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_CLOCK_CTRL_CLKSRC
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|BWI_CLKSRC_LP_OSC
condition|)
block|{
name|div
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|div
operator|=
operator|(
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_CLOCK_CTRL_FDIV
argument_list|)
operator|+
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* Unknown source */
if|if
condition|(
name|src
operator|>=
name|BWI_CLKSRC_MAX
condition|)
name|src
operator|=
name|BWI_CLKSRC_CS_OSC
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_INFO
argument_list|)
expr_stmt|;
name|src
operator|=
name|BWI_CLKSRC_CS_OSC
expr_stmt|;
name|div
operator|=
operator|(
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_CLOCK_INFO_FDIV
argument_list|)
operator|+
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|src
operator|>=
literal|0
operator|&&
name|src
operator|<
name|BWI_CLKSRC_MAX
argument_list|,
operator|(
literal|"bad src %d"
operator|,
name|src
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|div
operator|!=
literal|0
argument_list|,
operator|(
literal|"div zero"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
argument_list|,
literal|"clksrc %s\n"
argument_list|,
name|src
operator|==
name|BWI_CLKSRC_PCI
condition|?
literal|"PCI"
else|:
operator|(
name|src
operator|==
name|BWI_CLKSRC_LP_OSC
condition|?
literal|"LP_OSC"
else|:
literal|"CS_OSC"
operator|)
argument_list|)
expr_stmt|;
name|freq
operator|->
name|clkfreq_min
operator|=
name|bwi_clkfreq
index|[
name|src
index|]
operator|.
name|freq_min
operator|/
name|div
expr_stmt|;
name|freq
operator|->
name|clkfreq_max
operator|=
name|bwi_clkfreq
index|[
name|src
index|]
operator|.
name|freq_max
operator|/
name|div
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
argument_list|,
literal|"clkfreq min %u, max %u\n"
argument_list|,
name|freq
operator|->
name|clkfreq_min
argument_list|,
name|freq
operator|->
name|clkfreq_max
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_set_clock_mode
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|bwi_clock_mode
name|clk_mode
parameter_list|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|old
decl_stmt|,
modifier|*
name|com
decl_stmt|;
name|uint32_t
name|clk_ctrl
decl_stmt|,
name|clk_src
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pwr_off
init|=
literal|0
decl_stmt|;
name|com
operator|=
operator|&
name|sc
operator|->
name|sc_com_regwin
expr_stmt|;
if|if
condition|(
operator|!
name|BWI_REGWIN_EXIST
argument_list|(
name|com
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|com
operator|->
name|rw_rev
operator|>=
literal|10
operator|||
name|com
operator|->
name|rw_rev
operator|<
literal|6
condition|)
return|return
literal|0
return|;
comment|/* 	 * For common regwin whose rev is [6, 10), the chip 	 * must be capable to change clock mode. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cap
operator|&
name|BWI_CAP_CLKMODE
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|clk_mode
operator|==
name|BWI_CLOCK_MODE_FAST
condition|)
name|bwi_power_on
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't turn on PLL */
name|clk_ctrl
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_CTRL
argument_list|)
expr_stmt|;
name|clk_src
operator|=
name|__SHIFTOUT
argument_list|(
name|clk_ctrl
argument_list|,
name|BWI_CLOCK_CTRL_CLKSRC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|clk_mode
condition|)
block|{
case|case
name|BWI_CLOCK_MODE_FAST
case|:
name|clk_ctrl
operator|&=
operator|~
name|BWI_CLOCK_CTRL_SLOW
expr_stmt|;
name|clk_ctrl
operator||=
name|BWI_CLOCK_CTRL_IGNPLL
expr_stmt|;
break|break;
case|case
name|BWI_CLOCK_MODE_SLOW
case|:
name|clk_ctrl
operator||=
name|BWI_CLOCK_CTRL_SLOW
expr_stmt|;
break|break;
case|case
name|BWI_CLOCK_MODE_DYN
case|:
name|clk_ctrl
operator|&=
operator|~
operator|(
name|BWI_CLOCK_CTRL_SLOW
operator||
name|BWI_CLOCK_CTRL_IGNPLL
operator||
name|BWI_CLOCK_CTRL_NODYN
operator|)
expr_stmt|;
if|if
condition|(
name|clk_src
operator|!=
name|BWI_CLKSRC_CS_OSC
condition|)
block|{
name|clk_ctrl
operator||=
name|BWI_CLOCK_CTRL_NODYN
expr_stmt|;
name|pwr_off
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_CTRL
argument_list|,
name|clk_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwr_off
condition|)
name|bwi_power_off
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Leave PLL as it is */
return|return
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_set_clock_delay
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|old
decl_stmt|,
modifier|*
name|com
decl_stmt|;
name|int
name|error
decl_stmt|;
name|com
operator|=
operator|&
name|sc
operator|->
name|sc_com_regwin
expr_stmt|;
if|if
condition|(
operator|!
name|BWI_REGWIN_EXIST
argument_list|(
name|com
argument_list|)
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|sc
operator|->
name|sc_bbp_id
operator|==
name|BWI_BBPID_BCM4321
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bbp_rev
operator|==
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_CONTROL
argument_list|,
name|BWI_CONTROL_MAGIC0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_bbp_rev
operator|==
literal|1
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_CONTROL
argument_list|,
name|BWI_CONTROL_MAGIC1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_cap
operator|&
name|BWI_CAP_CLKMODE
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|rw_rev
operator|>=
literal|10
condition|)
block|{
name|CSR_FILT_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_INFO
argument_list|,
literal|0xffff
argument_list|,
literal|0x40000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bwi_clock_freq
name|freq
decl_stmt|;
name|bwi_get_clock_freq
argument_list|(
name|sc
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_PLL_ON_DELAY
argument_list|,
name|howmany
argument_list|(
name|freq
operator|.
name|clkfreq_max
operator|*
literal|150
argument_list|,
literal|1000000
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_FREQ_SEL_DELAY
argument_list|,
name|howmany
argument_list|(
name|freq
operator|.
name|clkfreq_max
operator|*
literal|15
argument_list|,
literal|1000000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_init
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bwi_init_statechg
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* start all vap's */
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_init_statechg
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|statechg
parameter_list|)
block|{
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BWI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bwi_stop_locked
argument_list|(
name|sc
argument_list|,
name|statechg
argument_list|)
expr_stmt|;
name|bwi_bbp_power_on
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_MODE_FAST
argument_list|)
expr_stmt|;
comment|/* TODO: 2 MAC */
name|mac
operator|=
operator|&
name|sc
operator|->
name|sc_mac
index|[
literal|0
index|]
expr_stmt|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d on regwin switch\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|bwi_mac_init
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d on MAC init\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bwi_bbp_power_on
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_MODE_DYN
argument_list|)
expr_stmt|;
name|bwi_set_bssid
argument_list|(
name|sc
argument_list|,
name|bwi_zero_addr
argument_list|)
expr_stmt|;
comment|/* Clear BSSID */
name|bwi_set_addr_filter
argument_list|(
name|sc
argument_list|,
name|BWI_ADDR_FILTER_MYADDR
argument_list|,
name|sc
operator|->
name|sc_ic
operator|.
name|ic_macaddr
argument_list|)
expr_stmt|;
name|bwi_mac_reset_hwkeys
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_HAS_TXSTATS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|NRETRY
value|1000
comment|/* 		 * Drain any possible pending TX status 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_TXSTATUS0
argument_list|)
operator|&
name|BWI_TXSTATUS0_VALID
operator|)
operator|==
literal|0
condition|)
break|break;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_TXSTATUS1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't drain TX status\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NRETRY
block|}
if|if
condition|(
name|mac
operator|->
name|mac_phy
operator|.
name|phy_mode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|bwi_mac_updateslot
argument_list|(
name|mac
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Start MAC */
name|error
operator|=
name|bwi_mac_start
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d starting MAC\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Clear stop flag before enabling interrupt */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|BWI_F_STOP
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|BWI_F_RUNNING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_timer
argument_list|,
name|hz
argument_list|,
name|bwi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable intrs */
name|bwi_enable_intrs
argument_list|(
name|sc
argument_list|,
name|BWI_INIT_INTRS
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bwi_stop_locked
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|startall
init|=
literal|0
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|int
name|promisc
init|=
operator|-
literal|1
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_promisc
operator|>
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_PROMISC
operator|)
operator|==
literal|0
condition|)
block|{
name|promisc
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|BWI_F_PROMISC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_promisc
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_PROMISC
operator|)
operator|!=
literal|0
condition|)
block|{
name|promisc
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|BWI_F_PROMISC
expr_stmt|;
block|}
if|if
condition|(
name|promisc
operator|>=
literal|0
condition|)
name|bwi_mac_set_promisc
argument_list|(
name|mac
argument_list|,
name|promisc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|bwi_init_statechg
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
condition|)
name|bwi_stop_locked
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_transmit
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|mbufq_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bwi_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_start_locked
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
init|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|BWI_TX_DATA_RING
index|]
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|trans
decl_stmt|,
name|idx
decl_stmt|;
name|BWI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|trans
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|tbd
operator|->
name|tbd_idx
expr_stmt|;
while|while
condition|(
name|tbd
operator|->
name|tbd_buf
index|[
name|idx
index|]
operator|.
name|tb_mbuf
operator|==
name|NULL
operator|&&
name|tbd
operator|->
name|tbd_used
operator|+
name|BWI_TX_NSPRDESC
operator|<
name|BWI_TX_NDESC
operator|&&
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
operator|)
operator|!=
literal|0
operator|&&
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bwi_encap
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 'm' is freed in bwi_encap() if we reach here */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
name|counter_u64_add
argument_list|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_oerrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|trans
operator|=
literal|1
expr_stmt|;
name|tbd
operator|->
name|tbd_used
operator|++
expr_stmt|;
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|%
name|BWI_TX_NDESC
expr_stmt|;
block|}
name|tbd
operator|->
name|tbd_idx
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|trans
condition|)
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
comment|/* XXX wme? */
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
init|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|BWI_TX_DATA_RING
index|]
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|idx
operator|=
name|tbd
operator|->
name|tbd_idx
expr_stmt|;
name|KASSERT
argument_list|(
name|tbd
operator|->
name|tbd_buf
index|[
name|idx
index|]
operator|.
name|tb_mbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"slot %d not empty"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
name|error
operator|=
name|bwi_encap
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
name|error
operator|=
name|bwi_encap_raw
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|tbd
operator|->
name|tbd_used
operator|++
expr_stmt|;
name|tbd
operator|->
name|tbd_idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|%
name|BWI_TX_NDESC
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
block|}
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|BWI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|!=
literal|0
operator|&&
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_oerrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_restart_task
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_timer
argument_list|,
name|hz
argument_list|,
name|bwi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_stop
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|statechg
parameter_list|)
block|{
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bwi_stop_locked
argument_list|(
name|sc
argument_list|,
name|statechg
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_stop_locked
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|statechg
parameter_list|)
block|{
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|pwr_off
init|=
literal|0
decl_stmt|;
name|BWI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_blink_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_led_blinking
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|BWI_F_STOP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|bwi_disable_intrs
argument_list|(
name|sc
argument_list|,
name|BWI_ALL_INTRS
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_MASK
argument_list|)
expr_stmt|;
name|bwi_mac_stop
argument_list|(
name|mac
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nmac
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|old_rw
decl_stmt|;
name|mac
operator|=
operator|&
name|sc
operator|->
name|sc_mac
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_INITED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|,
operator|&
name|old_rw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
name|bwi_mac_shutdown
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|pwr_off
operator|=
literal|1
expr_stmt|;
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old_rw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pwr_off
condition|)
name|bwi_bbp_power_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_timer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|BWI_F_RUNNING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|uint32_t
name|intr_status
decl_stmt|;
name|uint32_t
name|txrx_intr_status
index|[
name|BWI_TXRX_NRING
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|txrx_error
decl_stmt|,
name|tx
init|=
literal|0
decl_stmt|,
name|rx_data
init|=
operator|-
literal|1
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_STOP
operator|)
condition|)
block|{
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get interrupt status 	 */
name|intr_status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_status
operator|==
literal|0xffffffff
condition|)
block|{
comment|/* Not for us */
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_INTR
argument_list|,
literal|"intr status 0x%08x\n"
argument_list|,
name|intr_status
argument_list|)
expr_stmt|;
name|intr_status
operator|&=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_status
operator|==
literal|0
condition|)
block|{
comment|/* Nothing is interesting */
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|txrx_error
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_INTR
argument_list|,
literal|"%s\n"
argument_list|,
literal|"TX/RX intr"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TXRX_NRING
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|mask
decl_stmt|;
if|if
condition|(
name|BWI_TXRX_IS_RX
argument_list|(
name|i
argument_list|)
condition|)
name|mask
operator|=
name|BWI_TXRX_RX_INTRS
expr_stmt|;
else|else
name|mask
operator|=
name|BWI_TXRX_TX_INTRS
expr_stmt|;
name|txrx_intr_status
index|[
name|i
index|]
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_TXRX_INTR_STATUS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
name|mask
expr_stmt|;
name|_DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_INTR
argument_list|,
literal|", %d 0x%08x"
argument_list|,
name|i
argument_list|,
name|txrx_intr_status
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txrx_intr_status
index|[
name|i
index|]
operator|&
name|BWI_TXRX_INTR_ERROR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: intr fatal TX/RX (%d) error 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|txrx_intr_status
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|txrx_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|_DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_INTR
argument_list|,
literal|"%s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Acknowledge interrupt 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|,
name|intr_status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TXRX_NRING
condition|;
operator|++
name|i
control|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_TXRX_INTR_STATUS
argument_list|(
name|i
argument_list|)
argument_list|,
name|txrx_intr_status
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts */
name|bwi_disable_intrs
argument_list|(
name|sc
argument_list|,
name|BWI_ALL_INTRS
argument_list|)
expr_stmt|;
comment|/* 	 * http://bcm-specs.sipsolutions.net/Interrupts 	 * Says for this bit (0x800): 	 * "Fatal Error 	 * 	 * We got this one while testing things when by accident the 	 * template ram wasn't set to big endian when it should have 	 * been after writing the initial values. It keeps on being 	 * triggered, the only way to stop it seems to shut down the 	 * chip." 	 * 	 * Suggesting that we should never get it and if we do we're not 	 * feeding TX packets into the MAC correctly if we do...  Apparently, 	 * it is valid only on mac version 5 and higher, but I couldn't 	 * find a reference for that...  Since I see them from time to time 	 * on my card, this suggests an error in the tx path still... 	 */
if|if
condition|(
name|intr_status
operator|&
name|BWI_INTR_PHY_TXERR
condition|)
block|{
if|if
condition|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_PHYE_RESET
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: intr PHY TX error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_restart_task
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|txrx_error
condition|)
block|{
comment|/* TODO: reset device */
block|}
if|if
condition|(
name|intr_status
operator|&
name|BWI_INTR_TBTT
condition|)
name|bwi_mac_config_ps
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_status
operator|&
name|BWI_INTR_EO_ATIM
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"EO_ATIM\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_status
operator|&
name|BWI_INTR_PMQ
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_PS_STATUS
argument_list|)
operator|&
literal|0x8
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_PS_STATUS
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intr_status
operator|&
name|BWI_INTR_NOISE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"intr noise\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txrx_intr_status
index|[
literal|0
index|]
operator|&
name|BWI_TXRX_INTR_RX
condition|)
block|{
name|rx_data
operator|=
name|sc
operator|->
name|sc_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_STOP
condition|)
block|{
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|txrx_intr_status
index|[
literal|3
index|]
operator|&
name|BWI_TXRX_INTR_RX
condition|)
block|{
name|sc
operator|->
name|sc_txeof_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|intr_status
operator|&
name|BWI_INTR_TX_DONE
condition|)
block|{
name|bwi_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Re-enable interrupts */
name|bwi_enable_intrs
argument_list|(
name|sc
argument_list|,
name|BWI_INIT_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blink_led
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_led_blink
condition|)
block|{
name|int
name|evt
init|=
name|BWI_LED_EVENT_NONE
decl_stmt|;
if|if
condition|(
name|tx
operator|&&
name|rx_data
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rx_rate
operator|>
name|sc
operator|->
name|sc_tx_rate
condition|)
name|evt
operator|=
name|BWI_LED_EVENT_RX
expr_stmt|;
else|else
name|evt
operator|=
name|BWI_LED_EVENT_TX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tx
condition|)
block|{
name|evt
operator|=
name|BWI_LED_EVENT_TX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_data
operator|>
literal|0
condition|)
block|{
name|evt
operator|=
name|BWI_LED_EVENT_RX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_data
operator|==
literal|0
condition|)
block|{
name|evt
operator|=
name|BWI_LED_EVENT_POLL
expr_stmt|;
block|}
if|if
condition|(
name|evt
operator|!=
name|BWI_LED_EVENT_NONE
condition|)
name|bwi_led_event
argument_list|(
name|sc
argument_list|,
name|evt
argument_list|)
expr_stmt|;
block|}
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable MAC beacon promiscuity */
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_PASS_BCN
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|struct
name|bwi_phy
modifier|*
name|phy
decl_stmt|;
name|uint8_t
name|bands
index|[
name|IEEE80211_MODE_BYTES
index|]
decl_stmt|;
comment|/* 	 * XXX First MAC is known to exist 	 * TODO2 	 */
name|mac
operator|=
operator|&
name|sc
operator|->
name|sc_mac
index|[
literal|0
index|]
expr_stmt|;
name|phy
operator|=
operator|&
name|mac
operator|->
name|mac_phy
expr_stmt|;
name|memset
argument_list|(
name|bands
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bands
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|phy_mode
condition|)
block|{
case|case
name|IEEE80211_MODE_11G
case|:
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_MODE_11B
case|:
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11A
case|:
comment|/* TODO:11A */
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no 11a support\n"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"unknown phymode %d\n"
argument_list|,
name|phy
operator|->
name|phy_mode
argument_list|)
expr_stmt|;
block|}
name|ieee80211_add_channel_list_2ghz
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|bwi_chan_2ghz
argument_list|,
name|nitems
argument_list|(
name|bwi_chan_2ghz
argument_list|)
argument_list|,
name|bands
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|bwi_rf_set_chan
argument_list|(
name|mac
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rates
operator|=
name|ieee80211_get_ratetable
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Setup radio tap channel freq and flags 	 */
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_freq
operator|=
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_flags
operator|=
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_CLRBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_PASS_BCN
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|bwi_vap
modifier|*
name|bvp
init|=
name|BWI_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
init|=
name|vap
operator|->
name|iv_state
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
name|sc
operator|->
name|sc_txpwrcb_type
operator|=
name|BWI_TXPWR_INIT
expr_stmt|;
name|bwi_led_newstate
argument_list|(
name|sc
argument_list|,
name|nstate
argument_list|)
expr_stmt|;
name|error
operator|=
name|bvp
operator|->
name|bv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|back
goto|;
comment|/* 	 * Clear the BSSID when we stop a STA 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|nstate
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 			 * Clear out the BSSID.  If we reassociate to 			 * the same AP, this will reinialize things 			 * correctly... 			 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_STOP
operator|)
condition|)
name|bwi_set_bssid
argument_list|(
name|sc
argument_list|,
name|bwi_zero_addr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
comment|/* Nothing to do */
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|bwi_set_bssid
argument_list|(
name|sc
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
comment|/* Initial TX power calibration */
name|bwi_mac_calibrate_txpower
argument_list|(
name|mac
argument_list|,
name|BWI_TXPWR_INIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|sc
operator|->
name|sc_txpwrcb_type
operator|=
name|BWI_TXPWR_FORCE
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_txpwrcb_type
operator|=
name|BWI_TXPWR_CALIB
expr_stmt|;
endif|#
directive|endif
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_ch
argument_list|,
name|hz
argument_list|,
name|bwi_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|back
label|:
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|error
init|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
return|return
operator|(
name|error
operator|==
name|ENETRESET
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_dma_alloc
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|has_txstats
decl_stmt|;
name|bus_addr_t
name|lowaddr
init|=
literal|0
decl_stmt|;
name|bus_size_t
name|tx_ring_sz
decl_stmt|,
name|rx_ring_sz
decl_stmt|,
name|desc_sz
init|=
literal|0
decl_stmt|;
name|uint32_t
name|txrx_ctrl_step
init|=
literal|0
decl_stmt|;
name|has_txstats
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nmac
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_mac
index|[
name|i
index|]
operator|.
name|mac_flags
operator|&
name|BWI_MAC_F_HAS_TXSTATS
condition|)
block|{
name|has_txstats
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|sc
operator|->
name|sc_bus_space
condition|)
block|{
case|case
name|BWI_BUS_SPACE_30BIT
case|:
case|case
name|BWI_BUS_SPACE_32BIT
case|:
if|if
condition|(
name|sc
operator|->
name|sc_bus_space
operator|==
name|BWI_BUS_SPACE_30BIT
condition|)
name|lowaddr
operator|=
name|BWI_BUS_SPACE_MAXADDR
expr_stmt|;
else|else
name|lowaddr
operator|=
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
name|desc_sz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc32
argument_list|)
expr_stmt|;
name|txrx_ctrl_step
operator|=
literal|0x20
expr_stmt|;
name|sc
operator|->
name|sc_init_tx_ring
operator|=
name|bwi_init_tx_ring32
expr_stmt|;
name|sc
operator|->
name|sc_free_tx_ring
operator|=
name|bwi_free_tx_ring32
expr_stmt|;
name|sc
operator|->
name|sc_init_rx_ring
operator|=
name|bwi_init_rx_ring32
expr_stmt|;
name|sc
operator|->
name|sc_free_rx_ring
operator|=
name|bwi_free_rx_ring32
expr_stmt|;
name|sc
operator|->
name|sc_setup_rxdesc
operator|=
name|bwi_setup_rx_desc32
expr_stmt|;
name|sc
operator|->
name|sc_setup_txdesc
operator|=
name|bwi_setup_tx_desc32
expr_stmt|;
name|sc
operator|->
name|sc_rxeof
operator|=
name|bwi_rxeof32
expr_stmt|;
name|sc
operator|->
name|sc_start_tx
operator|=
name|bwi_start_tx32
expr_stmt|;
if|if
condition|(
name|has_txstats
condition|)
block|{
name|sc
operator|->
name|sc_init_txstats
operator|=
name|bwi_init_txstats32
expr_stmt|;
name|sc
operator|->
name|sc_free_txstats
operator|=
name|bwi_free_txstats32
expr_stmt|;
name|sc
operator|->
name|sc_txeof_status
operator|=
name|bwi_txeof_status32
expr_stmt|;
block|}
break|break;
case|case
name|BWI_BUS_SPACE_64BIT
case|:
name|lowaddr
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
comment|/* XXX */
name|desc_sz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc64
argument_list|)
expr_stmt|;
name|txrx_ctrl_step
operator|=
literal|0x40
expr_stmt|;
name|sc
operator|->
name|sc_init_tx_ring
operator|=
name|bwi_init_tx_ring64
expr_stmt|;
name|sc
operator|->
name|sc_free_tx_ring
operator|=
name|bwi_free_tx_ring64
expr_stmt|;
name|sc
operator|->
name|sc_init_rx_ring
operator|=
name|bwi_init_rx_ring64
expr_stmt|;
name|sc
operator|->
name|sc_free_rx_ring
operator|=
name|bwi_free_rx_ring64
expr_stmt|;
name|sc
operator|->
name|sc_setup_rxdesc
operator|=
name|bwi_setup_rx_desc64
expr_stmt|;
name|sc
operator|->
name|sc_setup_txdesc
operator|=
name|bwi_setup_tx_desc64
expr_stmt|;
name|sc
operator|->
name|sc_rxeof
operator|=
name|bwi_rxeof64
expr_stmt|;
name|sc
operator|->
name|sc_start_tx
operator|=
name|bwi_start_tx64
expr_stmt|;
if|if
condition|(
name|has_txstats
condition|)
block|{
name|sc
operator|->
name|sc_init_txstats
operator|=
name|bwi_init_txstats64
expr_stmt|;
name|sc
operator|->
name|sc_free_txstats
operator|=
name|bwi_free_txstats64
expr_stmt|;
name|sc
operator|->
name|sc_txeof_status
operator|=
name|bwi_txeof_status64
expr_stmt|;
block|}
break|break;
block|}
name|KASSERT
argument_list|(
name|lowaddr
operator|!=
literal|0
argument_list|,
operator|(
literal|"lowaddr zero"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|desc_sz
operator|!=
literal|0
argument_list|,
operator|(
literal|"desc_sz zero"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txrx_ctrl_step
operator|!=
literal|0
argument_list|,
operator|(
literal|"txrx_ctrl_step zero"
operator|)
argument_list|)
expr_stmt|;
name|tx_ring_sz
operator|=
name|roundup
argument_list|(
name|desc_sz
operator|*
name|BWI_TX_NDESC
argument_list|,
name|BWI_RING_ALIGN
argument_list|)
expr_stmt|;
name|rx_ring_sz
operator|=
name|roundup
argument_list|(
name|desc_sz
operator|*
name|BWI_RX_NDESC
argument_list|,
name|BWI_RING_ALIGN
argument_list|)
expr_stmt|;
comment|/* 	 * Create top level DMA tag 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
name|BWI_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|lowaddr
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE
argument_list|,
comment|/* maxsize */
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sc_parent_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create parent DMA tag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
define|#
directive|define
name|TXRX_CTRL
parameter_list|(
name|idx
parameter_list|)
value|(BWI_TXRX_CTRL_BASE + (idx) * txrx_ctrl_step)
comment|/* 	 * Create TX ring DMA stuffs 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_parent_dtag
argument_list|,
name|BWI_RING_ALIGN
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tx_ring_sz
argument_list|,
literal|1
argument_list|,
name|tx_ring_sz
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_txring_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create TX ring DMA tag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TX_NRING
condition|;
operator|++
name|i
control|)
block|{
name|error
operator|=
name|bwi_dma_ring_alloc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txring_dtag
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_rdata
index|[
name|i
index|]
argument_list|,
name|tx_ring_sz
argument_list|,
name|TXRX_CTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%dth TX ring "
literal|"DMA alloc failed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * Create RX ring DMA stuffs 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_parent_dtag
argument_list|,
name|BWI_RING_ALIGN
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rx_ring_sz
argument_list|,
literal|1
argument_list|,
name|rx_ring_sz
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxring_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create RX ring DMA tag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bwi_dma_ring_alloc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxring_dtag
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_rdata
argument_list|,
name|rx_ring_sz
argument_list|,
name|TXRX_CTRL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RX ring DMA alloc failed\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|has_txstats
condition|)
block|{
name|error
operator|=
name|bwi_dma_txstats_alloc
argument_list|(
name|sc
argument_list|,
name|TXRX_CTRL
argument_list|(
literal|3
argument_list|)
argument_list|,
name|desc_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TX stats DMA alloc failed\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
undef|#
directive|undef
name|TXRX_CTRL
return|return
name|bwi_dma_mbuf_create
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_dma_free
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txring_dtag
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TX_NRING
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_ring_data
modifier|*
name|rd
init|=
operator|&
name|sc
operator|->
name|sc_tx_rdata
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rd
operator|->
name|rdata_desc
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_txring_dtag
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_txring_dtag
argument_list|,
name|rd
operator|->
name|rdata_desc
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_txring_dtag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rxring_dtag
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bwi_ring_data
modifier|*
name|rd
init|=
operator|&
name|sc
operator|->
name|sc_rx_rdata
decl_stmt|;
if|if
condition|(
name|rd
operator|->
name|rdata_desc
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rxring_dtag
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_rxring_dtag
argument_list|,
name|rd
operator|->
name|rdata_desc
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rxring_dtag
argument_list|)
expr_stmt|;
block|}
name|bwi_dma_txstats_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bwi_dma_mbuf_destroy
argument_list|(
name|sc
argument_list|,
name|BWI_TX_NRING
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_parent_dtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_parent_dtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_dma_ring_alloc
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|bus_dma_tag_t
name|dtag
parameter_list|,
name|struct
name|bwi_ring_data
modifier|*
name|rd
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|uint32_t
name|txrx_ctrl
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dtag
argument_list|,
operator|&
name|rd
operator|->
name|rdata_desc
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|rd
operator|->
name|rdata_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't allocate DMA mem\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dtag
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|,
name|rd
operator|->
name|rdata_desc
argument_list|,
name|size
argument_list|,
name|bwi_dma_ring_addr
argument_list|,
operator|&
name|rd
operator|->
name|rdata_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't load DMA mem\n"
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dtag
argument_list|,
name|rd
operator|->
name|rdata_desc
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|)
expr_stmt|;
name|rd
operator|->
name|rdata_desc
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
name|rd
operator|->
name|rdata_txrx_ctrl
operator|=
name|txrx_ctrl
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_dma_txstats_alloc
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ctrl_base
parameter_list|,
name|bus_size_t
name|desc_sz
parameter_list|)
block|{
name|struct
name|bwi_txstats_data
modifier|*
name|st
decl_stmt|;
name|bus_size_t
name|dma_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|st
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|st
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't allocate txstats data\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|sc_txstats
operator|=
name|st
expr_stmt|;
comment|/* 	 * Create TX stats descriptor DMA stuffs 	 */
name|dma_size
operator|=
name|roundup
argument_list|(
name|desc_sz
operator|*
name|BWI_TXSTATS_NDESC
argument_list|,
name|BWI_RING_ALIGN
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_parent_dtag
argument_list|,
name|BWI_RING_ALIGN
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dma_size
argument_list|,
literal|1
argument_list|,
name|dma_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|st
operator|->
name|stats_ring_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create txstats ring "
literal|"DMA tag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|,
operator|&
name|st
operator|->
name|stats_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|st
operator|->
name|stats_ring_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't allocate txstats ring "
literal|"DMA mem\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|)
expr_stmt|;
name|st
operator|->
name|stats_ring_dtag
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|,
name|st
operator|->
name|stats_ring_dmap
argument_list|,
name|st
operator|->
name|stats_ring
argument_list|,
name|dma_size
argument_list|,
name|bwi_dma_ring_addr
argument_list|,
operator|&
name|st
operator|->
name|stats_ring_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't load txstats ring DMA mem\n"
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|,
name|st
operator|->
name|stats_ring
argument_list|,
name|st
operator|->
name|stats_ring_dmap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|)
expr_stmt|;
name|st
operator|->
name|stats_ring_dtag
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Create TX stats DMA stuffs 	 */
name|dma_size
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_txstats
argument_list|)
operator|*
name|BWI_TXSTATS_NDESC
argument_list|,
name|BWI_ALIGN
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_parent_dtag
argument_list|,
name|BWI_ALIGN
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dma_size
argument_list|,
literal|1
argument_list|,
name|dma_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|st
operator|->
name|stats_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create txstats DMA tag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|st
operator|->
name|stats
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|st
operator|->
name|stats_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't allocate txstats DMA mem\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|)
expr_stmt|;
name|st
operator|->
name|stats_dtag
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|,
name|st
operator|->
name|stats_dmap
argument_list|,
name|st
operator|->
name|stats
argument_list|,
name|dma_size
argument_list|,
name|bwi_dma_ring_addr
argument_list|,
operator|&
name|st
operator|->
name|stats_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't load txstats DMA mem\n"
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|,
name|st
operator|->
name|stats
argument_list|,
name|st
operator|->
name|stats_dmap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|)
expr_stmt|;
name|st
operator|->
name|stats_dtag
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
name|st
operator|->
name|stats_ctrl_base
operator|=
name|ctrl_base
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_dma_txstats_free
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_txstats_data
modifier|*
name|st
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txstats
operator|==
name|NULL
condition|)
return|return;
name|st
operator|=
name|sc
operator|->
name|sc_txstats
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|stats_ring_dtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|,
name|st
operator|->
name|stats_ring_dmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|,
name|st
operator|->
name|stats_ring
argument_list|,
name|st
operator|->
name|stats_ring_dmap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|->
name|stats_dtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|,
name|st
operator|->
name|stats_dmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|,
name|st
operator|->
name|stats
argument_list|,
name|st
operator|->
name|stats_dmap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|st
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_dma_ring_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many segments\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|)
operator|=
name|seg
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_dma_mbuf_create
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_rxbuf_data
modifier|*
name|rbd
init|=
operator|&
name|sc
operator|->
name|sc_rx_bdata
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|ntx
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Create TX/RX mbuf DMA tag 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_parent_dtag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_buf_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create mbuf DMA tag\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ntx
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Create TX mbuf DMA map 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TX_NRING
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
init|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BWI_TX_NDESC
condition|;
operator|++
name|j
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|tbd
operator|->
name|tbd_buf
index|[
name|j
index|]
operator|.
name|tb_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create "
literal|"%dth tbd, %dth DMA map\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ntx
operator|=
name|i
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
operator|++
name|k
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tbd
operator|->
name|tbd_buf
index|[
name|k
index|]
operator|.
name|tb_dmap
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fail
goto|;
block|}
block|}
block|}
name|ntx
operator|=
name|BWI_TX_NRING
expr_stmt|;
comment|/* 	 * Create RX mbuf DMA map and a spare DMA map 	 */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|rbd
operator|->
name|rbd_tmp_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create spare RX buf DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BWI_RX_NDESC
condition|;
operator|++
name|j
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|rbd
operator|->
name|rbd_buf
index|[
name|j
index|]
operator|.
name|rb_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't create %dth "
literal|"RX buf DMA map\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
operator|++
name|k
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rbd
operator|->
name|rbd_buf
index|[
name|j
index|]
operator|.
name|rb_dmap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rbd
operator|->
name|rbd_tmp_dmap
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
name|bwi_dma_mbuf_destroy
argument_list|(
name|sc
argument_list|,
name|ntx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_dma_mbuf_destroy
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ntx
parameter_list|,
name|int
name|nrx
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_buf_dtag
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntx
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
init|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BWI_TX_NDESC
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|bwi_txbuf
modifier|*
name|tb
init|=
operator|&
name|tbd
operator|->
name|tbd_buf
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tb
operator|->
name|tb_mbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tb
operator|->
name|tb_ni
operator|!=
name|NULL
condition|)
name|ieee80211_free_node
argument_list|(
name|tb
operator|->
name|tb_ni
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nrx
condition|)
block|{
name|struct
name|bwi_rxbuf_data
modifier|*
name|rbd
init|=
operator|&
name|sc
operator|->
name|sc_rx_bdata
decl_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rbd
operator|->
name|rbd_tmp_dmap
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BWI_RX_NDESC
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|bwi_rxbuf
modifier|*
name|rb
init|=
operator|&
name|rbd
operator|->
name|rbd_buf
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|rb
operator|->
name|rb_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rb
operator|->
name|rb_dmap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rb
operator|->
name|rb_mbuf
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rb
operator|->
name|rb_dmap
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_buf_dtag
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_enable_intrs
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|enable_intrs
parameter_list|)
block|{
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_MASK
argument_list|,
name|enable_intrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_disable_intrs
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|disable_intrs
parameter_list|)
block|{
name|CSR_CLRBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_MASK
argument_list|,
name|disable_intrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_init_tx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ring_idx
parameter_list|)
block|{
name|struct
name|bwi_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|addr_hi
decl_stmt|,
name|addr_lo
decl_stmt|;
name|KASSERT
argument_list|(
name|ring_idx
operator|<
name|BWI_TX_NRING
argument_list|,
operator|(
literal|"ring_idx %d"
operator|,
name|ring_idx
operator|)
argument_list|)
expr_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|sc_tx_rdata
index|[
name|ring_idx
index|]
expr_stmt|;
name|tbd
operator|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|ring_idx
index|]
expr_stmt|;
name|tbd
operator|->
name|tbd_idx
operator|=
literal|0
expr_stmt|;
name|tbd
operator|->
name|tbd_used
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|rdata_desc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc32
argument_list|)
operator|*
name|BWI_TX_NDESC
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_txring_dtag
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|addr_lo
operator|=
name|__SHIFTOUT
argument_list|(
name|rd
operator|->
name|rdata_paddr
argument_list|,
name|BWI_TXRX32_RINGINFO_ADDR_MASK
argument_list|)
expr_stmt|;
name|addr_hi
operator|=
name|__SHIFTOUT
argument_list|(
name|rd
operator|->
name|rdata_paddr
argument_list|,
name|BWI_TXRX32_RINGINFO_FUNC_MASK
argument_list|)
expr_stmt|;
name|val
operator|=
name|__SHIFTIN
argument_list|(
name|addr_lo
argument_list|,
name|BWI_TXRX32_RINGINFO_ADDR_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|BWI_TXRX32_RINGINFO_FUNC_TXRX
argument_list|,
name|BWI_TXRX32_RINGINFO_FUNC_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
operator|+
name|BWI_TX32_RINGINFO
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|__SHIFTIN
argument_list|(
name|addr_hi
argument_list|,
name|BWI_TXRX32_CTRL_ADDRHI_MASK
argument_list|)
operator||
name|BWI_TXRX32_CTRL_ENABLE
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
operator|+
name|BWI_TX32_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_init_rxdesc_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ctrl_base
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|int
name|hdr_size
parameter_list|,
name|int
name|ndesc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|addr_hi
decl_stmt|,
name|addr_lo
decl_stmt|;
name|addr_lo
operator|=
name|__SHIFTOUT
argument_list|(
name|paddr
argument_list|,
name|BWI_TXRX32_RINGINFO_ADDR_MASK
argument_list|)
expr_stmt|;
name|addr_hi
operator|=
name|__SHIFTOUT
argument_list|(
name|paddr
argument_list|,
name|BWI_TXRX32_RINGINFO_FUNC_MASK
argument_list|)
expr_stmt|;
name|val
operator|=
name|__SHIFTIN
argument_list|(
name|addr_lo
argument_list|,
name|BWI_TXRX32_RINGINFO_ADDR_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|BWI_TXRX32_RINGINFO_FUNC_TXRX
argument_list|,
name|BWI_TXRX32_RINGINFO_FUNC_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|ctrl_base
operator|+
name|BWI_RX32_RINGINFO
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|__SHIFTIN
argument_list|(
name|hdr_size
argument_list|,
name|BWI_RX32_CTRL_HDRSZ_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|addr_hi
argument_list|,
name|BWI_TXRX32_CTRL_ADDRHI_MASK
argument_list|)
operator||
name|BWI_TXRX32_CTRL_ENABLE
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|ctrl_base
operator|+
name|BWI_RX32_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|ctrl_base
operator|+
name|BWI_RX32_INDEX
argument_list|,
operator|(
name|ndesc
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_init_rx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_ring_data
modifier|*
name|rd
init|=
operator|&
name|sc
operator|->
name|sc_rx_rdata
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|->
name|sc_rx_bdata
operator|.
name|rbd_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_RX_NDESC
condition|;
operator|++
name|i
control|)
block|{
name|error
operator|=
name|bwi_newbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't allocate %dth RX buffer\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rxring_dtag
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bwi_init_rxdesc_ring32
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
argument_list|,
name|rd
operator|->
name|rdata_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_rxbuf_hdr
argument_list|)
argument_list|,
name|BWI_RX_NDESC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_init_txstats32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_txstats_data
modifier|*
name|st
init|=
name|sc
operator|->
name|sc_txstats
decl_stmt|;
name|bus_addr_t
name|stats_paddr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|st
operator|->
name|stats
argument_list|,
name|BWI_TXSTATS_NDESC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_txstats
argument_list|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|,
name|st
operator|->
name|stats_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|st
operator|->
name|stats_idx
operator|=
literal|0
expr_stmt|;
name|stats_paddr
operator|=
name|st
operator|->
name|stats_paddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TXSTATS_NDESC
condition|;
operator|++
name|i
control|)
block|{
name|bwi_setup_desc32
argument_list|(
name|sc
argument_list|,
name|st
operator|->
name|stats_ring
argument_list|,
name|BWI_TXSTATS_NDESC
argument_list|,
name|i
argument_list|,
name|stats_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_txstats
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stats_paddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_txstats
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|st
operator|->
name|stats_ring_dtag
argument_list|,
name|st
operator|->
name|stats_ring_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bwi_init_rxdesc_ring32
argument_list|(
name|sc
argument_list|,
name|st
operator|->
name|stats_ctrl_base
argument_list|,
name|st
operator|->
name|stats_ring_paddr
argument_list|,
literal|0
argument_list|,
name|BWI_TXSTATS_NDESC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_setup_rx_desc32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|buf_idx
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|int
name|buf_len
parameter_list|)
block|{
name|struct
name|bwi_ring_data
modifier|*
name|rd
init|=
operator|&
name|sc
operator|->
name|sc_rx_rdata
decl_stmt|;
name|KASSERT
argument_list|(
name|buf_idx
operator|<
name|BWI_RX_NDESC
argument_list|,
operator|(
literal|"buf_idx %d"
operator|,
name|buf_idx
operator|)
argument_list|)
expr_stmt|;
name|bwi_setup_desc32
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_desc
argument_list|,
name|BWI_RX_NDESC
argument_list|,
name|buf_idx
argument_list|,
name|paddr
argument_list|,
name|buf_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_setup_tx_desc32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_ring_data
modifier|*
name|rd
parameter_list|,
name|int
name|buf_idx
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|int
name|buf_len
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|buf_idx
operator|<
name|BWI_TX_NDESC
argument_list|,
operator|(
literal|"buf_idx %d"
operator|,
name|buf_idx
operator|)
argument_list|)
expr_stmt|;
name|bwi_setup_desc32
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_desc
argument_list|,
name|BWI_TX_NDESC
argument_list|,
name|buf_idx
argument_list|,
name|paddr
argument_list|,
name|buf_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_init_tx_ring64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ring_idx
parameter_list|)
block|{
comment|/* TODO:64 */
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_init_rx_ring64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TODO:64 */
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_init_txstats64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TODO:64 */
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_setup_rx_desc64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|buf_idx
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|int
name|buf_len
parameter_list|)
block|{
comment|/* TODO:64 */
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_setup_tx_desc64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_ring_data
modifier|*
name|rd
parameter_list|,
name|int
name|buf_idx
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|int
name|buf_len
parameter_list|)
block|{
comment|/* TODO:64 */
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_dma_buf_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsz
name|__unused
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many segments(%d)\n"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|)
operator|=
name|seg
operator|->
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_newbuf
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|buf_idx
parameter_list|,
name|int
name|init
parameter_list|)
block|{
name|struct
name|bwi_rxbuf_data
modifier|*
name|rbd
init|=
operator|&
name|sc
operator|->
name|sc_rx_bdata
decl_stmt|;
name|struct
name|bwi_rxbuf
modifier|*
name|rxbuf
init|=
operator|&
name|rbd
operator|->
name|rbd_buf
index|[
name|buf_idx
index|]
decl_stmt|;
name|struct
name|bwi_rxbuf_hdr
modifier|*
name|hdr
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|buf_idx
operator|<
name|BWI_RX_NDESC
argument_list|,
operator|(
literal|"buf_idx %d"
operator|,
name|buf_idx
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
comment|/* 		 * If the NIC is up and running, we need to: 		 * - Clear RX buffer's header. 		 * - Restore RX descriptor settings. 		 */
if|if
condition|(
name|init
condition|)
return|return
name|error
return|;
else|else
goto|goto
name|back
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
comment|/* 	 * Try to load RX buf into temporary DMA map 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rbd
operator|->
name|rbd_tmp_dmap
argument_list|,
name|m
argument_list|,
name|bwi_dma_buf_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * See the comment above 		 */
if|if
condition|(
name|init
condition|)
return|return
name|error
return|;
else|else
goto|goto
name|back
goto|;
block|}
if|if
condition|(
operator|!
name|init
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rxbuf
operator|->
name|rb_dmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|rb_mbuf
operator|=
name|m
expr_stmt|;
name|rxbuf
operator|->
name|rb_paddr
operator|=
name|paddr
expr_stmt|;
comment|/* 	 * Swap RX buf's DMA map with the loaded temporary one 	 */
name|map
operator|=
name|rxbuf
operator|->
name|rb_dmap
expr_stmt|;
name|rxbuf
operator|->
name|rb_dmap
operator|=
name|rbd
operator|->
name|rbd_tmp_dmap
expr_stmt|;
name|rbd
operator|->
name|rbd_tmp_dmap
operator|=
name|map
expr_stmt|;
name|back
label|:
comment|/* 	 * Clear RX buf header 	 */
name|hdr
operator|=
name|mtod
argument_list|(
name|rxbuf
operator|->
name|rb_mbuf
argument_list|,
expr|struct
name|bwi_rxbuf_hdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rxbuf
operator|->
name|rb_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Setup RX buf descriptor 	 */
name|sc
operator|->
name|sc_setup_rxdesc
argument_list|(
name|sc
argument_list|,
name|buf_idx
argument_list|,
name|rxbuf
operator|->
name|rb_paddr
argument_list|,
name|rxbuf
operator|->
name|rb_mbuf
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_set_addr_filter
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|addr_ofs
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_ADDR_FILTER_CTRL
argument_list|,
name|BWI_ADDR_FILTER_CTRL_SET
operator||
name|addr_ofs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|IEEE80211_ADDR_LEN
operator|/
literal|2
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|uint16_t
name|addr_val
decl_stmt|;
name|addr_val
operator|=
operator|(
name|uint16_t
operator|)
name|addr
index|[
name|i
operator|*
literal|2
index|]
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|addr
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_ADDR_FILTER_DATA
argument_list|,
name|addr_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_rxeof
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|end_idx
parameter_list|)
block|{
name|struct
name|bwi_ring_data
modifier|*
name|rd
init|=
operator|&
name|sc
operator|->
name|sc_rx_rdata
decl_stmt|;
name|struct
name|bwi_rxbuf_data
modifier|*
name|rbd
init|=
operator|&
name|sc
operator|->
name|sc_rx_bdata
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rx_data
init|=
literal|0
decl_stmt|;
name|idx
operator|=
name|rbd
operator|->
name|rbd_idx
expr_stmt|;
while|while
condition|(
name|idx
operator|!=
name|end_idx
condition|)
block|{
name|struct
name|bwi_rxbuf
modifier|*
name|rb
init|=
operator|&
name|rbd
operator|->
name|rbd_buf
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|bwi_rxbuf_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|plcp
decl_stmt|;
name|uint16_t
name|flags2
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|wh_ofs
decl_stmt|,
name|hdr_extra
decl_stmt|,
name|rssi
decl_stmt|,
name|noise
decl_stmt|,
name|type
decl_stmt|,
name|rate
decl_stmt|;
name|m
operator|=
name|rb
operator|->
name|rb_mbuf
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rb
operator|->
name|rb_dmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|bwi_newbuf
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|bwi_rxbuf_hdr
operator|*
argument_list|)
expr_stmt|;
name|flags2
operator|=
name|le16toh
argument_list|(
name|hdr
operator|->
name|rxh_flags2
argument_list|)
expr_stmt|;
name|hdr_extra
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags2
operator|&
name|BWI_RXH_F2_TYPE2FRAME
condition|)
name|hdr_extra
operator|=
literal|2
expr_stmt|;
name|wh_ofs
operator|=
name|hdr_extra
operator|+
literal|6
expr_stmt|;
comment|/* XXX magic number */
name|buflen
operator|=
name|le16toh
argument_list|(
name|hdr
operator|->
name|rxh_buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
name|BWI_FRAME_MIN_LEN
argument_list|(
name|wh_ofs
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: zero length data, hdr_extra %d\n"
argument_list|,
name|__func__
argument_list|,
name|hdr_extra
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|bcopy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
operator|+
name|hdr_extra
argument_list|,
operator|&
name|plcp
argument_list|,
sizeof|sizeof
argument_list|(
name|plcp
argument_list|)
argument_list|)
expr_stmt|;
name|rssi
operator|=
name|bwi_calc_rssi
argument_list|(
name|sc
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|noise
operator|=
name|bwi_calc_noise
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|buflen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
name|wh_ofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|htole16
argument_list|(
name|hdr
operator|->
name|rxh_flags1
argument_list|)
operator|&
name|BWI_RXH_F1_OFDM
condition|)
name|rate
operator|=
name|bwi_plcp2rate
argument_list|(
name|plcp
argument_list|,
name|IEEE80211_T_OFDM
argument_list|)
expr_stmt|;
else|else
name|rate
operator|=
name|bwi_plcp2rate
argument_list|(
name|plcp
argument_list|,
name|IEEE80211_T_CCK
argument_list|)
expr_stmt|;
comment|/* RX radio tap */
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
name|bwi_rx_radiotap
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|hdr
argument_list|,
operator|&
name|plcp
argument_list|,
name|rate
argument_list|,
name|rssi
argument_list|,
name|noise
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|IEEE80211_CRC_LEN
argument_list|)
expr_stmt|;
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|type
operator|=
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rssi
operator|-
name|noise
argument_list|,
name|noise
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rssi
operator|-
name|noise
argument_list|,
name|noise
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
name|rx_data
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_rx_rate
operator|=
name|rate
expr_stmt|;
block|}
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|next
label|:
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|%
name|BWI_RX_NDESC
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_STOP
condition|)
block|{
comment|/* 			 * Take the fast lane, don't do 			 * any damage to softc 			 */
return|return
operator|-
literal|1
return|;
block|}
block|}
name|rbd
operator|->
name|rbd_idx
operator|=
name|idx
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rxring_dtag
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
name|rx_data
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_rxeof32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|rx_ctrl
decl_stmt|;
name|int
name|end_idx
decl_stmt|,
name|rx_data
decl_stmt|;
name|rx_ctrl
operator|=
name|sc
operator|->
name|sc_rx_rdata
operator|.
name|rdata_txrx_ctrl
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|rx_ctrl
operator|+
name|BWI_RX32_STATUS
argument_list|)
expr_stmt|;
name|end_idx
operator|=
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_RX32_STATUS_INDEX_MASK
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc32
argument_list|)
expr_stmt|;
name|rx_data
operator|=
name|bwi_rxeof
argument_list|(
name|sc
argument_list|,
name|end_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_data
operator|>=
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|rx_ctrl
operator|+
name|BWI_RX32_INDEX
argument_list|,
name|end_idx
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc32
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rx_data
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_rxeof64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TODO:64 */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_reset_rx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|rx_ctrl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|rx_ctrl
operator|+
name|BWI_RX32_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|NRETRY
value|10
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|rx_ctrl
operator|+
name|BWI_RX32_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|__SHIFTOUT
argument_list|(
name|status
argument_list|,
name|BWI_RX32_STATUS_STATE_MASK
argument_list|)
operator|==
name|BWI_RX32_STATUS_STATE_DISABLED
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reset rx ring timedout\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NRETRY
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|rx_ctrl
operator|+
name|BWI_RX32_RINGINFO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_free_txstats32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bwi_reset_rx_ring32
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txstats
operator|->
name|stats_ctrl_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_free_rx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_ring_data
modifier|*
name|rd
init|=
operator|&
name|sc
operator|->
name|sc_rx_rdata
decl_stmt|;
name|struct
name|bwi_rxbuf_data
modifier|*
name|rbd
init|=
operator|&
name|sc
operator|->
name|sc_rx_bdata
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bwi_reset_rx_ring32
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_RX_NDESC
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_rxbuf
modifier|*
name|rb
init|=
operator|&
name|rbd
operator|->
name|rbd_buf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rb
operator|->
name|rb_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|rb
operator|->
name|rb_dmap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rb
operator|->
name|rb_mbuf
argument_list|)
expr_stmt|;
name|rb
operator|->
name|rb_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_free_tx_ring32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ring_idx
parameter_list|)
block|{
name|struct
name|bwi_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
decl_stmt|;
name|uint32_t
name|state
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|ring_idx
operator|<
name|BWI_TX_NRING
argument_list|,
operator|(
literal|"ring_idx %d"
operator|,
name|ring_idx
operator|)
argument_list|)
expr_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|sc_tx_rdata
index|[
name|ring_idx
index|]
expr_stmt|;
name|tbd
operator|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|ring_idx
index|]
expr_stmt|;
define|#
directive|define
name|NRETRY
value|10
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
operator|+
name|BWI_TX32_STATUS
argument_list|)
expr_stmt|;
name|state
operator|=
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_TX32_STATUS_STATE_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|BWI_TX32_STATUS_STATE_DISABLED
operator|||
name|state
operator|==
name|BWI_TX32_STATUS_STATE_IDLE
operator|||
name|state
operator|==
name|BWI_TX32_STATUS_STATE_STOPPED
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: wait for TX ring(%d) stable timed out\n"
argument_list|,
name|__func__
argument_list|,
name|ring_idx
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
operator|+
name|BWI_TX32_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
operator|+
name|BWI_TX32_STATUS
argument_list|)
expr_stmt|;
name|state
operator|=
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_TX32_STATUS_STATE_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|BWI_TX32_STATUS_STATE_DISABLED
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: reset TX ring (%d) timed out\n"
argument_list|,
name|__func__
argument_list|,
name|ring_idx
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NRETRY
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
operator|+
name|BWI_TX32_RINGINFO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TX_NDESC
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_txbuf
modifier|*
name|tb
init|=
operator|&
name|tbd
operator|->
name|tbd_buf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tb
operator|->
name|tb_mbuf
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tb_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tb
operator|->
name|tb_ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|tb
operator|->
name|tb_ni
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tb_ni
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_free_txstats64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TODO:64 */
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_free_rx_ring64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TODO:64 */
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_free_tx_ring64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ring_idx
parameter_list|)
block|{
comment|/* TODO:64 */
block|}
end_function

begin_comment
comment|/* XXX does not belong here */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_OFDM_PLCP_RATE_MASK
value|__BITS(3, 0)
end_define

begin_define
define|#
directive|define
name|IEEE80211_OFDM_PLCP_LEN_MASK
value|__BITS(16, 5)
end_define

begin_function
specifier|static
name|__inline
name|void
name|bwi_ofdm_plcp_header
parameter_list|(
name|uint32_t
modifier|*
name|plcp0
parameter_list|,
name|int
name|pkt_len
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|uint32_t
name|plcp
decl_stmt|;
name|plcp
operator|=
name|__SHIFTIN
argument_list|(
name|ieee80211_rate2plcp
argument_list|(
name|rate
argument_list|,
name|IEEE80211_T_OFDM
argument_list|)
argument_list|,
name|IEEE80211_OFDM_PLCP_RATE_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|pkt_len
argument_list|,
name|IEEE80211_OFDM_PLCP_LEN_MASK
argument_list|)
expr_stmt|;
operator|*
name|plcp0
operator|=
name|htole32
argument_list|(
name|plcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|bwi_ds_plcp_header
parameter_list|(
name|struct
name|ieee80211_ds_plcp_hdr
modifier|*
name|plcp
parameter_list|,
name|int
name|pkt_len
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|service
decl_stmt|,
name|pkt_bitlen
decl_stmt|;
name|pkt_bitlen
operator|=
name|pkt_len
operator|*
name|NBBY
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|pkt_bitlen
operator|*
literal|2
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|service
operator|=
name|IEEE80211_PLCP_SERVICE_LOCKED
expr_stmt|;
if|if
condition|(
name|rate
operator|==
operator|(
literal|11
operator|*
literal|2
operator|)
condition|)
block|{
name|int
name|pkt_bitlen1
decl_stmt|;
comment|/* 		 * PLCP service field needs to be adjusted, 		 * if TX rate is 11Mbytes/s 		 */
name|pkt_bitlen1
operator|=
name|len
operator|*
literal|11
expr_stmt|;
if|if
condition|(
name|pkt_bitlen1
operator|-
name|pkt_bitlen
operator|>=
name|NBBY
condition|)
name|service
operator||=
name|IEEE80211_PLCP_SERVICE_LENEXT7
expr_stmt|;
block|}
name|plcp
operator|->
name|i_signal
operator|=
name|ieee80211_rate2plcp
argument_list|(
name|rate
argument_list|,
name|IEEE80211_T_CCK
argument_list|)
expr_stmt|;
name|plcp
operator|->
name|i_service
operator|=
name|service
expr_stmt|;
name|plcp
operator|->
name|i_length
operator|=
name|htole16
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* NOTE: do NOT touch i_crc */
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|bwi_plcp_header
parameter_list|(
specifier|const
name|struct
name|ieee80211_rate_table
modifier|*
name|rt
parameter_list|,
name|void
modifier|*
name|plcp
parameter_list|,
name|int
name|pkt_len
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|enum
name|ieee80211_phytype
name|modtype
decl_stmt|;
comment|/* 	 * Assume caller has zeroed 'plcp' 	 */
name|modtype
operator|=
name|ieee80211_rate2phytype
argument_list|(
name|rt
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|modtype
operator|==
name|IEEE80211_T_OFDM
condition|)
name|bwi_ofdm_plcp_header
argument_list|(
name|plcp
argument_list|,
name|pkt_len
argument_list|,
name|rate
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|modtype
operator|==
name|IEEE80211_T_DS
condition|)
name|bwi_ds_plcp_header
argument_list|(
name|plcp
argument_list|,
name|pkt_len
argument_list|,
name|rate
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"unsupport modulation type %u\n"
argument_list|,
name|modtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_encap
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|bwi_ring_data
modifier|*
name|rd
init|=
operator|&
name|sc
operator|->
name|sc_tx_rdata
index|[
name|BWI_TX_DATA_RING
index|]
decl_stmt|;
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
init|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|BWI_TX_DATA_RING
index|]
decl_stmt|;
name|struct
name|bwi_txbuf
modifier|*
name|tb
init|=
operator|&
name|tbd
operator|->
name|tbd_buf
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|struct
name|bwi_txbuf_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
name|ni
operator|->
name|ni_txparms
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|,
name|rate_fb
decl_stmt|;
name|uint32_t
name|mac_ctrl
decl_stmt|;
name|uint16_t
name|phy_ctrl
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|type
decl_stmt|,
name|ismcast
decl_stmt|,
name|pkt_len
decl_stmt|,
name|error
decl_stmt|,
name|rix
decl_stmt|;
if|#
directive|if
literal|0
block|const uint8_t *p; 	int i;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
comment|/* Get 802.11 frame len before prepending TX header */
name|pkt_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* 	 * Find TX rate 	 */
if|if
condition|(
name|type
operator|!=
name|IEEE80211_FC0_TYPE_DATA
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
condition|)
block|{
name|rate
operator|=
name|rate_fb
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ismcast
condition|)
block|{
name|rate
operator|=
name|rate_fb
operator|=
name|tp
operator|->
name|mcastrate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
name|rate
operator|=
name|rate_fb
operator|=
name|tp
operator|->
name|ucastrate
expr_stmt|;
block|}
else|else
block|{
name|rix
operator|=
name|ieee80211_ratectl_rate
argument_list|(
name|ni
argument_list|,
name|NULL
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
if|if
condition|(
name|rix
operator|>
literal|0
condition|)
block|{
name|rate_fb
operator|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
name|rix
operator|-
literal|1
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
block|}
else|else
block|{
name|rate_fb
operator|=
name|rate
expr_stmt|;
block|}
block|}
name|tb
operator|->
name|tb_rate
index|[
literal|0
index|]
operator|=
name|rate
expr_stmt|;
name|tb
operator|->
name|tb_rate
index|[
literal|1
index|]
operator|=
name|rate_fb
expr_stmt|;
name|sc
operator|->
name|sc_tx_rate
operator|=
name|rate
expr_stmt|;
comment|/* 	 * TX radio tap 	 */
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|ieee80211_rate2phytype
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|rate
argument_list|)
operator|==
name|IEEE80211_T_DS
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|rate
operator|!=
operator|(
literal|1
operator|*
literal|2
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
block|}
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|rate
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup the embedded TX header 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: prepend TX header failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|bwi_txbuf_hdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|wh
operator|->
name|i_fc
argument_list|,
name|hdr
operator|->
name|txh_fc
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|txh_fc
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|hdr
operator|->
name|txh_addr1
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|txh_addr1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ismcast
condition|)
block|{
name|uint16_t
name|dur
decl_stmt|;
name|dur
operator|=
name|ieee80211_ack_duration
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|rate
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_F_SHPREAMBLE
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|txh_fb_duration
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|->
name|txh_id
operator|=
name|__SHIFTIN
argument_list|(
name|BWI_TX_DATA_RING
argument_list|,
name|BWI_TXH_ID_RING_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|idx
argument_list|,
name|BWI_TXH_ID_IDX_MASK
argument_list|)
expr_stmt|;
name|bwi_plcp_header
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|hdr
operator|->
name|txh_plcp
argument_list|,
name|pkt_len
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|bwi_plcp_header
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|hdr
operator|->
name|txh_fb_plcp
argument_list|,
name|pkt_len
argument_list|,
name|rate_fb
argument_list|)
expr_stmt|;
name|phy_ctrl
operator|=
name|__SHIFTIN
argument_list|(
name|mac
operator|->
name|mac_rf
operator|.
name|rf_ant_mode
argument_list|,
name|BWI_TXH_PHY_C_ANTMODE_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_rate2phytype
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|rate
argument_list|)
operator|==
name|IEEE80211_T_OFDM
condition|)
name|phy_ctrl
operator||=
name|BWI_TXH_PHY_C_OFDM
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|rate
operator|!=
operator|(
literal|2
operator|*
literal|1
operator|)
condition|)
name|phy_ctrl
operator||=
name|BWI_TXH_PHY_C_SHPREAMBLE
expr_stmt|;
name|mac_ctrl
operator|=
name|BWI_TXH_MAC_C_HWSEQ
operator||
name|BWI_TXH_MAC_C_FIRST_FRAG
expr_stmt|;
if|if
condition|(
operator|!
name|ismcast
condition|)
name|mac_ctrl
operator||=
name|BWI_TXH_MAC_C_ACK
expr_stmt|;
if|if
condition|(
name|ieee80211_rate2phytype
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|rate_fb
argument_list|)
operator|==
name|IEEE80211_T_OFDM
condition|)
name|mac_ctrl
operator||=
name|BWI_TXH_MAC_C_FB_OFDM
expr_stmt|;
name|hdr
operator|->
name|txh_mac_ctrl
operator|=
name|htole32
argument_list|(
name|mac_ctrl
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|txh_phy_ctrl
operator|=
name|htole16
argument_list|(
name|phy_ctrl
argument_list|)
expr_stmt|;
comment|/* Catch any further usage */
name|hdr
operator|=
name|NULL
expr_stmt|;
name|wh
operator|=
name|NULL
expr_stmt|;
comment|/* DMA load */
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|,
name|m
argument_list|,
name|bwi_dma_buf_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't load TX buffer (1) %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|back
goto|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* error == EFBIG */
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|m_new
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't defrag TX buffer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|back
goto|;
block|}
else|else
block|{
name|m
operator|=
name|m_new
expr_stmt|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|,
name|m
argument_list|,
name|bwi_dma_buf_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't load TX buffer (2) %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|back
goto|;
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tb_mbuf
operator|=
name|m
expr_stmt|;
name|tb
operator|->
name|tb_ni
operator|=
name|ni
expr_stmt|;
if|#
directive|if
literal|0
block|p = mtod(m, const uint8_t *); 	for (i = 0; i< m->m_pkthdr.len; ++i) { 		if (i != 0&& i % 8 == 0) 			printf("\n"); 		printf("%02x ", p[i]); 	} 	printf("\n");
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_TX
argument_list|,
literal|"idx %d, pkt_len %d, buflen %d\n"
argument_list|,
name|idx
argument_list|,
name|pkt_len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* Setup TX descriptor */
name|sc
operator|->
name|sc_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|rd
argument_list|,
name|idx
argument_list|,
name|paddr
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_txring_dtag
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Kick start */
name|sc
operator|->
name|sc_start_tx
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|back
label|:
if|if
condition|(
name|error
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_encap_raw
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|bwi_ring_data
modifier|*
name|rd
init|=
operator|&
name|sc
operator|->
name|sc_tx_rdata
index|[
name|BWI_TX_DATA_RING
index|]
decl_stmt|;
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
init|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|BWI_TX_DATA_RING
index|]
decl_stmt|;
name|struct
name|bwi_txbuf
modifier|*
name|tb
init|=
operator|&
name|tbd
operator|->
name|tbd_buf
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|struct
name|bwi_txbuf_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|,
name|rate_fb
decl_stmt|;
name|uint32_t
name|mac_ctrl
decl_stmt|;
name|uint16_t
name|phy_ctrl
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|ismcast
decl_stmt|,
name|pkt_len
decl_stmt|,
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
comment|/* Get 802.11 frame len before prepending TX header */
name|pkt_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* 	 * Find TX rate 	 */
name|rate
operator|=
name|params
operator|->
name|ibp_rate0
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_isratevalid
argument_list|(
name|ic
operator|->
name|ic_rt
argument_list|,
name|rate
argument_list|)
condition|)
block|{
comment|/* XXX fall back to mcast/mgmt rate? */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|params
operator|->
name|ibp_try1
operator|!=
literal|0
condition|)
block|{
name|rate_fb
operator|=
name|params
operator|->
name|ibp_rate1
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_isratevalid
argument_list|(
name|ic
operator|->
name|ic_rt
argument_list|,
name|rate_fb
argument_list|)
condition|)
block|{
comment|/* XXX fall back to rate0? */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
else|else
name|rate_fb
operator|=
name|rate
expr_stmt|;
name|tb
operator|->
name|tb_rate
index|[
literal|0
index|]
operator|=
name|rate
expr_stmt|;
name|tb
operator|->
name|tb_rate
index|[
literal|1
index|]
operator|=
name|rate_fb
expr_stmt|;
name|sc
operator|->
name|sc_tx_rate
operator|=
name|rate
expr_stmt|;
comment|/* 	 * TX radio tap 	 */
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX IEEE80211_BPF_CRYPTO */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|rate
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup the embedded TX header 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: prepend TX header failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|bwi_txbuf_hdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|wh
operator|->
name|i_fc
argument_list|,
name|hdr
operator|->
name|txh_fc
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|txh_fc
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|hdr
operator|->
name|txh_addr1
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|txh_addr1
argument_list|)
argument_list|)
expr_stmt|;
name|mac_ctrl
operator|=
name|BWI_TXH_MAC_C_HWSEQ
operator||
name|BWI_TXH_MAC_C_FIRST_FRAG
expr_stmt|;
if|if
condition|(
operator|!
name|ismcast
operator|&&
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|dur
decl_stmt|;
name|dur
operator|=
name|ieee80211_ack_duration
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|rate_fb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|txh_fb_duration
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
name|mac_ctrl
operator||=
name|BWI_TXH_MAC_C_ACK
expr_stmt|;
block|}
name|hdr
operator|->
name|txh_id
operator|=
name|__SHIFTIN
argument_list|(
name|BWI_TX_DATA_RING
argument_list|,
name|BWI_TXH_ID_RING_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|idx
argument_list|,
name|BWI_TXH_ID_IDX_MASK
argument_list|)
expr_stmt|;
name|bwi_plcp_header
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|hdr
operator|->
name|txh_plcp
argument_list|,
name|pkt_len
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|bwi_plcp_header
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|hdr
operator|->
name|txh_fb_plcp
argument_list|,
name|pkt_len
argument_list|,
name|rate_fb
argument_list|)
expr_stmt|;
name|phy_ctrl
operator|=
name|__SHIFTIN
argument_list|(
name|mac
operator|->
name|mac_rf
operator|.
name|rf_ant_mode
argument_list|,
name|BWI_TXH_PHY_C_ANTMODE_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_rate2phytype
argument_list|(
name|sc
operator|->
name|sc_rates
argument_list|,
name|rate
argument_list|)
operator|==
name|IEEE80211_T_OFDM
condition|)
block|{
name|phy_ctrl
operator||=
name|BWI_TXH_PHY_C_OFDM
expr_stmt|;
name|mac_ctrl
operator||=
name|BWI_TXH_MAC_C_FB_OFDM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|phy_ctrl
operator||=
name|BWI_TXH_PHY_C_SHPREAMBLE
expr_stmt|;
name|hdr
operator|->
name|txh_mac_ctrl
operator|=
name|htole32
argument_list|(
name|mac_ctrl
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|txh_phy_ctrl
operator|=
name|htole16
argument_list|(
name|phy_ctrl
argument_list|)
expr_stmt|;
comment|/* Catch any further usage */
name|hdr
operator|=
name|NULL
expr_stmt|;
name|wh
operator|=
name|NULL
expr_stmt|;
comment|/* DMA load */
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|,
name|m
argument_list|,
name|bwi_dma_buf_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't load TX buffer (1) %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|back
goto|;
block|}
name|m_new
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't defrag TX buffer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|back
goto|;
block|}
name|m
operator|=
name|m_new
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|,
name|m
argument_list|,
name|bwi_dma_buf_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't load TX buffer (2) %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|back
goto|;
block|}
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tb_mbuf
operator|=
name|m
expr_stmt|;
name|tb
operator|->
name|tb_ni
operator|=
name|ni
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_TX
argument_list|,
literal|"idx %d, pkt_len %d, buflen %d\n"
argument_list|,
name|idx
argument_list|,
name|pkt_len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* Setup TX descriptor */
name|sc
operator|->
name|sc_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|rd
argument_list|,
name|idx
argument_list|,
name|paddr
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_txring_dtag
argument_list|,
name|rd
operator|->
name|rdata_dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Kick start */
name|sc
operator|->
name|sc_start_tx
argument_list|(
name|sc
argument_list|,
name|rd
operator|->
name|rdata_txrx_ctrl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|back
label|:
if|if
condition|(
name|error
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_start_tx32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|tx_ctrl
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|%
name|BWI_TX_NDESC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|tx_ctrl
operator|+
name|BWI_TX32_INDEX
argument_list|,
name|idx
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_start_tx64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|tx_ctrl
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
comment|/* TODO:64 */
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_txeof_status32
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|ctrl_base
decl_stmt|;
name|int
name|end_idx
decl_stmt|;
name|ctrl_base
operator|=
name|sc
operator|->
name|sc_txstats
operator|->
name|stats_ctrl_base
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|ctrl_base
operator|+
name|BWI_RX32_STATUS
argument_list|)
expr_stmt|;
name|end_idx
operator|=
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_RX32_STATUS_INDEX_MASK
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc32
argument_list|)
expr_stmt|;
name|bwi_txeof_status
argument_list|(
name|sc
argument_list|,
name|end_idx
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|ctrl_base
operator|+
name|BWI_RX32_INDEX
argument_list|,
name|end_idx
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bwi_desc32
argument_list|)
argument_list|)
expr_stmt|;
name|bwi_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_txeof_status64
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TODO:64 */
block|}
end_function

begin_function
specifier|static
name|void
name|_bwi_txeof
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|tx_id
parameter_list|,
name|int
name|acked
parameter_list|,
name|int
name|data_txcnt
parameter_list|)
block|{
name|struct
name|bwi_txbuf_data
modifier|*
name|tbd
decl_stmt|;
name|struct
name|bwi_txbuf
modifier|*
name|tb
decl_stmt|;
name|int
name|ring_idx
decl_stmt|,
name|buf_idx
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
if|if
condition|(
name|tx_id
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: zero tx id\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ring_idx
operator|=
name|__SHIFTOUT
argument_list|(
name|tx_id
argument_list|,
name|BWI_TXH_ID_RING_MASK
argument_list|)
expr_stmt|;
name|buf_idx
operator|=
name|__SHIFTOUT
argument_list|(
name|tx_id
argument_list|,
name|BWI_TXH_ID_IDX_MASK
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ring_idx
operator|==
name|BWI_TX_DATA_RING
argument_list|,
operator|(
literal|"ring_idx %d"
operator|,
name|ring_idx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|buf_idx
operator|<
name|BWI_TX_NDESC
argument_list|,
operator|(
literal|"buf_idx %d"
operator|,
name|buf_idx
operator|)
argument_list|)
expr_stmt|;
name|tbd
operator|=
operator|&
name|sc
operator|->
name|sc_tx_bdata
index|[
name|ring_idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|tbd
operator|->
name|tbd_used
operator|>
literal|0
argument_list|,
operator|(
literal|"tbd_used %d"
operator|,
name|tbd
operator|->
name|tbd_used
operator|)
argument_list|)
expr_stmt|;
name|tbd
operator|->
name|tbd_used
operator|--
expr_stmt|;
name|tb
operator|=
operator|&
name|tbd
operator|->
name|tbd_buf
index|[
name|buf_idx
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_TXEOF
argument_list|,
literal|"txeof idx %d, "
literal|"acked %d, data_txcnt %d, ni %p\n"
argument_list|,
name|buf_idx
argument_list|,
name|acked
argument_list|,
name|data_txcnt
argument_list|,
name|tb
operator|->
name|tb_ni
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buf_dtag
argument_list|,
name|tb
operator|->
name|tb_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ni
operator|=
name|tb
operator|->
name|tb_ni
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|bwi_txbuf_hdr
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|tb
operator|->
name|tb_mbuf
argument_list|,
specifier|const
expr|struct
name|bwi_txbuf_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_ratectl_tx_status
name|txs
decl_stmt|;
comment|/* NB: update rate control only for unicast frames */
if|if
condition|(
name|hdr
operator|->
name|txh_mac_ctrl
operator|&
name|htole32
argument_list|(
name|BWI_TXH_MAC_C_ACK
argument_list|)
condition|)
block|{
comment|/* 			 * Feed back 'acked and data_txcnt'.  Note that the 			 * generic AMRR code only understands one tx rate 			 * and the estimator doesn't handle real retry counts 			 * well so to avoid over-aggressive downshifting we 			 * treat any number of retries as "1". 			 */
name|txs
operator|.
name|flags
operator|=
name|IEEE80211_RATECTL_STATUS_LONG_RETRY
expr_stmt|;
name|txs
operator|.
name|long_retries
operator|=
name|acked
expr_stmt|;
if|if
condition|(
name|data_txcnt
operator|>
literal|1
condition|)
name|txs
operator|.
name|status
operator|=
name|IEEE80211_RATECTL_TX_SUCCESS
expr_stmt|;
else|else
block|{
name|txs
operator|.
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED
expr_stmt|;
block|}
name|ieee80211_ratectl_tx_complete
argument_list|(
name|ni
argument_list|,
operator|&
name|txs
argument_list|)
expr_stmt|;
block|}
name|ieee80211_tx_complete
argument_list|(
name|ni
argument_list|,
name|tb
operator|->
name|tb_mbuf
argument_list|,
operator|!
name|acked
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tb_ni
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|tb
operator|->
name|tb_mbuf
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tb_mbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tbd
operator|->
name|tbd_used
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_txeof_status
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|end_idx
parameter_list|)
block|{
name|struct
name|bwi_txstats_data
modifier|*
name|st
init|=
name|sc
operator|->
name|sc_txstats
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|st
operator|->
name|stats_dtag
argument_list|,
name|st
operator|->
name|stats_dmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|idx
operator|=
name|st
operator|->
name|stats_idx
expr_stmt|;
while|while
condition|(
name|idx
operator|!=
name|end_idx
condition|)
block|{
specifier|const
name|struct
name|bwi_txstats
modifier|*
name|stats
init|=
operator|&
name|st
operator|->
name|stats
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|stats
operator|->
name|txs_flags
operator|&
name|BWI_TXS_F_PENDING
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|data_txcnt
decl_stmt|;
name|data_txcnt
operator|=
name|__SHIFTOUT
argument_list|(
name|stats
operator|->
name|txs_txcnt
argument_list|,
name|BWI_TXS_TXCNT_DATA
argument_list|)
expr_stmt|;
name|_bwi_txeof
argument_list|(
name|sc
argument_list|,
name|le16toh
argument_list|(
name|stats
operator|->
name|txs_id
argument_list|)
argument_list|,
name|stats
operator|->
name|txs_flags
operator|&
name|BWI_TXS_F_ACKED
argument_list|,
name|data_txcnt
argument_list|)
expr_stmt|;
block|}
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|%
name|BWI_TXSTATS_NDESC
expr_stmt|;
block|}
name|st
operator|->
name|stats_idx
operator|=
name|idx
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_txeof
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint32_t
name|tx_status0
decl_stmt|,
name|tx_status1
decl_stmt|;
name|uint16_t
name|tx_id
decl_stmt|;
name|int
name|data_txcnt
decl_stmt|;
name|tx_status0
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_TXSTATUS0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tx_status0
operator|&
name|BWI_TXSTATUS0_VALID
operator|)
operator|==
literal|0
condition|)
break|break;
name|tx_status1
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_TXSTATUS1
argument_list|)
expr_stmt|;
name|tx_id
operator|=
name|__SHIFTOUT
argument_list|(
name|tx_status0
argument_list|,
name|BWI_TXSTATUS0_TXID_MASK
argument_list|)
expr_stmt|;
name|data_txcnt
operator|=
name|__SHIFTOUT
argument_list|(
name|tx_status0
argument_list|,
name|BWI_TXSTATUS0_DATA_TXCNT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_status0
operator|&
operator|(
name|BWI_TXSTATUS0_AMPDU
operator||
name|BWI_TXSTATUS0_PENDING
operator|)
condition|)
continue|continue;
name|_bwi_txeof
argument_list|(
name|sc
argument_list|,
name|le16toh
argument_list|(
name|tx_id
argument_list|)
argument_list|,
name|tx_status0
operator|&
name|BWI_TXSTATUS0_ACKED
argument_list|,
name|data_txcnt
argument_list|)
expr_stmt|;
block|}
name|bwi_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_bbp_power_on
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|bwi_clock_mode
name|clk_mode
parameter_list|)
block|{
name|bwi_power_on
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|bwi_set_clock_mode
argument_list|(
name|sc
argument_list|,
name|clk_mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_bbp_power_off
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bwi_set_clock_mode
argument_list|(
name|sc
argument_list|,
name|BWI_CLOCK_MODE_SLOW
argument_list|)
expr_stmt|;
name|bwi_power_off
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_get_pwron_delay
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|com
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|struct
name|bwi_clock_freq
name|freq
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|com
operator|=
operator|&
name|sc
operator|->
name|sc_com_regwin
expr_stmt|;
name|KASSERT
argument_list|(
name|BWI_REGWIN_EXIST
argument_list|(
name|com
argument_list|)
argument_list|,
operator|(
literal|"no regwin"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cap
operator|&
name|BWI_CAP_CLKMODE
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|com
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bwi_get_clock_freq
argument_list|(
name|sc
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_PLL_ON_DELAY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pwron_delay
operator|=
name|howmany
argument_list|(
operator|(
name|val
operator|+
literal|2
operator|)
operator|*
literal|1000000
argument_list|,
name|freq
operator|.
name|clkfreq_min
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
argument_list|,
literal|"power on delay %u\n"
argument_list|,
name|sc
operator|->
name|sc_pwron_delay
argument_list|)
expr_stmt|;
return|return
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_bus_attach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_regwin
modifier|*
name|bus
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bus
operator|=
operator|&
name|sc
operator|->
name|sc_bus_regwin
expr_stmt|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|bwi_regwin_is_enabled
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|)
condition|)
name|bwi_regwin_enable
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interripts */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_INTRVEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bwi_regwin_name
parameter_list|(
specifier|const
name|struct
name|bwi_regwin
modifier|*
name|rw
parameter_list|)
block|{
switch|switch
condition|(
name|rw
operator|->
name|rw_type
condition|)
block|{
case|case
name|BWI_REGWIN_T_COM
case|:
return|return
literal|"COM"
return|;
case|case
name|BWI_REGWIN_T_BUSPCI
case|:
return|return
literal|"PCI"
return|;
case|case
name|BWI_REGWIN_T_MAC
case|:
return|return
literal|"MAC"
return|;
case|case
name|BWI_REGWIN_T_BUSPCIE
case|:
return|return
literal|"PCIE"
return|;
block|}
name|panic
argument_list|(
literal|"unknown regwin type 0x%04x\n"
argument_list|,
name|rw
operator|->
name|rw_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bwi_regwin_disable_bits
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|busrev
decl_stmt|;
comment|/* XXX cache this */
name|busrev
operator|=
name|__SHIFTOUT
argument_list|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_ID_LO
argument_list|)
argument_list|,
name|BWI_ID_LO_BUSREV_MASK
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
operator||
name|BWI_DBG_INIT
operator||
name|BWI_DBG_MISC
argument_list|,
literal|"bus rev %u\n"
argument_list|,
name|busrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|busrev
operator|==
name|BWI_BUSREV_0
condition|)
return|return
name|BWI_STATE_LO_DISABLE1
return|;
elseif|else
if|if
condition|(
name|busrev
operator|==
name|BWI_BUSREV_1
condition|)
return|return
name|BWI_STATE_LO_DISABLE2
return|;
else|else
return|return
operator|(
name|BWI_STATE_LO_DISABLE1
operator||
name|BWI_STATE_LO_DISABLE2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bwi_regwin_is_enabled
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_regwin
modifier|*
name|rw
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|disable_bits
decl_stmt|;
name|disable_bits
operator|=
name|bwi_regwin_disable_bits
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|BWI_STATE_LO_CLOCK
operator||
name|BWI_STATE_LO_RESET
operator||
name|disable_bits
operator|)
operator|)
operator|==
name|BWI_STATE_LO_CLOCK
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
operator||
name|BWI_DBG_INIT
argument_list|,
literal|"%s is enabled\n"
argument_list|,
name|bwi_regwin_name
argument_list|(
name|rw
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
operator||
name|BWI_DBG_INIT
argument_list|,
literal|"%s is disabled\n"
argument_list|,
name|bwi_regwin_name
argument_list|(
name|rw
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|bwi_regwin_disable
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_regwin
modifier|*
name|rw
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint32_t
name|state_lo
decl_stmt|,
name|disable_bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|state_lo
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
comment|/* 	 * If current regwin is in 'reset' state, it was already disabled. 	 */
if|if
condition|(
name|state_lo
operator|&
name|BWI_STATE_LO_RESET
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_ATTACH
operator||
name|BWI_DBG_INIT
argument_list|,
literal|"%s was already disabled\n"
argument_list|,
name|bwi_regwin_name
argument_list|(
name|rw
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|disable_bits
operator|=
name|bwi_regwin_disable_bits
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Disable normal clock 	 */
name|state_lo
operator|=
name|BWI_STATE_LO_CLOCK
operator||
name|disable_bits
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
name|state_lo
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until normal clock is disabled 	 */
define|#
directive|define
name|NRETRY
value|1000
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
name|state_lo
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_lo
operator|&
name|disable_bits
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s disable clock timeout\n"
argument_list|,
name|bwi_regwin_name
argument_list|(
name|rw
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|state_hi
decl_stmt|;
name|state_hi
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_HI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state_hi
operator|&
name|BWI_STATE_HI_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s wait BUSY unset timeout\n"
argument_list|,
name|bwi_regwin_name
argument_list|(
name|rw
argument_list|)
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|NRETRY
comment|/* 	 * Reset and disable regwin with gated clock 	 */
name|state_lo
operator|=
name|BWI_STATE_LO_RESET
operator||
name|disable_bits
operator||
name|BWI_STATE_LO_CLOCK
operator||
name|BWI_STATE_LO_GATED_CLOCK
operator||
name|__SHIFTIN
argument_list|(
name|flags
argument_list|,
name|BWI_STATE_LO_FLAGS_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
name|state_lo
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Reset and disable regwin */
name|state_lo
operator|=
name|BWI_STATE_LO_RESET
operator||
name|disable_bits
operator||
name|__SHIFTIN
argument_list|(
name|flags
argument_list|,
name|BWI_STATE_LO_FLAGS_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
name|state_lo
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_regwin_enable
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bwi_regwin
modifier|*
name|rw
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint32_t
name|state_lo
decl_stmt|,
name|state_hi
decl_stmt|,
name|imstate
decl_stmt|;
name|bwi_regwin_disable
argument_list|(
name|sc
argument_list|,
name|rw
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Reset regwin with gated clock */
name|state_lo
operator|=
name|BWI_STATE_LO_RESET
operator||
name|BWI_STATE_LO_CLOCK
operator||
name|BWI_STATE_LO_GATED_CLOCK
operator||
name|__SHIFTIN
argument_list|(
name|flags
argument_list|,
name|BWI_STATE_LO_FLAGS_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
name|state_lo
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|state_hi
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_HI
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_hi
operator|&
name|BWI_STATE_HI_SERROR
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imstate
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_IMSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|imstate
operator|&
operator|(
name|BWI_IMSTATE_INBAND_ERR
operator||
name|BWI_IMSTATE_TIMEOUT
operator|)
condition|)
block|{
name|imstate
operator|&=
operator|~
operator|(
name|BWI_IMSTATE_INBAND_ERR
operator||
name|BWI_IMSTATE_TIMEOUT
operator|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_IMSTATE
argument_list|,
name|imstate
argument_list|)
expr_stmt|;
block|}
comment|/* Enable regwin with gated clock */
name|state_lo
operator|=
name|BWI_STATE_LO_CLOCK
operator||
name|BWI_STATE_LO_GATED_CLOCK
operator||
name|__SHIFTIN
argument_list|(
name|flags
argument_list|,
name|BWI_STATE_LO_FLAGS_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
name|state_lo
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable regwin with normal clock */
name|state_lo
operator|=
name|BWI_STATE_LO_CLOCK
operator||
name|__SHIFTIN
argument_list|(
name|flags
argument_list|,
name|BWI_STATE_LO_FLAGS_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
name|state_lo
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_set_bssid
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|bssid
parameter_list|)
block|{
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|struct
name|bwi_myaddr_bssid
name|buf
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|bwi_set_addr_filter
argument_list|(
name|sc
argument_list|,
name|BWI_ADDR_FILTER_BSSID
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_macaddr
argument_list|,
name|buf
operator|.
name|myaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|myaddr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bssid
argument_list|,
name|buf
operator|.
name|bssid
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|bssid
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|val
argument_list|)
condition|;
operator|++
name|j
control|)
name|val
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|)
operator|<<
operator|(
name|j
operator|*
literal|8
operator|)
expr_stmt|;
name|TMPLT_WRITE_4
argument_list|(
name|mac
argument_list|,
literal|0x20
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_updateslot
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_80211
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|bwi_mac_updateslot
argument_list|(
name|mac
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
operator|)
argument_list|)
expr_stmt|;
block|}
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_calibrate
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|BWI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_opmode
operator|!=
name|IEEE80211_M_MONITOR
argument_list|,
operator|(
literal|"opmode %d"
operator|,
name|sc
operator|->
name|sc_ic
operator|.
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
name|bwi_mac_calibrate_txpower
argument_list|(
name|mac
argument_list|,
name|sc
operator|->
name|sc_txpwrcb_type
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txpwrcb_type
operator|=
name|BWI_TXPWR_CALIB
expr_stmt|;
comment|/* XXX 15 seconds */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_ch
argument_list|,
name|hz
operator|*
literal|15
argument_list|,
name|bwi_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_calc_rssi
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bwi_rxbuf_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
return|return
name|bwi_rf_calc_rssi
argument_list|(
name|mac
argument_list|,
name|hdr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_calc_noise
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|==
name|BWI_REGWIN_T_MAC
argument_list|,
operator|(
literal|"current regwin type %d"
operator|,
name|sc
operator|->
name|sc_cur_regwin
operator|->
name|rw_type
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|=
operator|(
expr|struct
name|bwi_mac
operator|*
operator|)
name|sc
operator|->
name|sc_cur_regwin
expr_stmt|;
return|return
name|bwi_rf_calc_noise
argument_list|(
name|mac
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
name|bwi_plcp2rate
parameter_list|(
specifier|const
name|uint32_t
name|plcp0
parameter_list|,
name|enum
name|ieee80211_phytype
name|type
parameter_list|)
block|{
name|uint32_t
name|plcp
init|=
name|le32toh
argument_list|(
name|plcp0
argument_list|)
operator|&
name|IEEE80211_OFDM_PLCP_RATE_MASK
decl_stmt|;
return|return
operator|(
name|ieee80211_plcp2rate
argument_list|(
name|plcp
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_rx_radiotap
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|bwi_rxbuf_hdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|void
modifier|*
name|plcp
parameter_list|,
name|int
name|rate
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|noise
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
decl_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator|=
name|IEEE80211_RADIOTAP_F_FCS
expr_stmt|;
if|if
condition|(
name|htole16
argument_list|(
name|hdr
operator|->
name|rxh_flags1
argument_list|)
operator|&
name|BWI_RXH_F1_SHPREAMBLE
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_tsf
operator|=
name|hdr
operator|->
name|rxh_tsf
expr_stmt|;
comment|/* No endian conversion */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|=
name|rate
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antsignal
operator|=
name|rssi
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antnoise
operator|=
name|noise
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_led_attach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|led_act
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|gpio
decl_stmt|,
name|val
index|[
name|BWI_LED_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|bwi_vendor_led_act
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_pci_subvid
operator|==
name|bwi_vendor_led_act
index|[
name|i
index|]
operator|.
name|vid
condition|)
block|{
name|led_act
operator|=
name|bwi_vendor_led_act
index|[
name|i
index|]
operator|.
name|led_act
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|led_act
operator|==
name|NULL
condition|)
name|led_act
operator|=
name|bwi_default_led_act
expr_stmt|;
name|gpio
operator|=
name|bwi_read_sprom
argument_list|(
name|sc
argument_list|,
name|BWI_SPROM_GPIO01
argument_list|)
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|=
name|__SHIFTOUT
argument_list|(
name|gpio
argument_list|,
name|BWI_SPROM_GPIO_0
argument_list|)
expr_stmt|;
name|val
index|[
literal|1
index|]
operator|=
name|__SHIFTOUT
argument_list|(
name|gpio
argument_list|,
name|BWI_SPROM_GPIO_1
argument_list|)
expr_stmt|;
name|gpio
operator|=
name|bwi_read_sprom
argument_list|(
name|sc
argument_list|,
name|BWI_SPROM_GPIO23
argument_list|)
expr_stmt|;
name|val
index|[
literal|2
index|]
operator|=
name|__SHIFTOUT
argument_list|(
name|gpio
argument_list|,
name|BWI_SPROM_GPIO_2
argument_list|)
expr_stmt|;
name|val
index|[
literal|3
index|]
operator|=
name|__SHIFTOUT
argument_list|(
name|gpio
argument_list|,
name|BWI_SPROM_GPIO_3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_LED_MAX
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_led
modifier|*
name|led
init|=
operator|&
name|sc
operator|->
name|sc_leds
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|val
index|[
name|i
index|]
operator|==
literal|0xff
condition|)
block|{
name|led
operator|->
name|l_act
operator|=
name|led_act
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val
index|[
name|i
index|]
operator|&
name|BWI_LED_ACT_LOW
condition|)
name|led
operator|->
name|l_flags
operator||=
name|BWI_LED_F_ACTLOW
expr_stmt|;
name|led
operator|->
name|l_act
operator|=
name|__SHIFTOUT
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
name|BWI_LED_ACT_MASK
argument_list|)
expr_stmt|;
block|}
name|led
operator|->
name|l_mask
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_BLINK_SLOW
operator|||
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_BLINK_POLL
operator|||
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_BLINK
condition|)
block|{
name|led
operator|->
name|l_flags
operator||=
name|BWI_LED_F_BLINK
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_BLINK_POLL
condition|)
name|led
operator|->
name|l_flags
operator||=
name|BWI_LED_F_POLLABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_BLINK_SLOW
condition|)
name|led
operator|->
name|l_flags
operator||=
name|BWI_LED_F_SLOW
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blink_led
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_blink_led
operator|=
name|led
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|l_flags
operator|&
name|BWI_LED_F_SLOW
condition|)
name|BWI_LED_SLOWDOWN
argument_list|(
name|sc
operator|->
name|sc_led_idle
argument_list|)
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_LED
operator||
name|BWI_DBG_ATTACH
argument_list|,
literal|"%dth led, act %d, lowact %d\n"
argument_list|,
name|i
argument_list|,
name|led
operator|->
name|l_act
argument_list|,
name|led
operator|->
name|l_flags
operator|&
name|BWI_LED_F_ACTLOW
argument_list|)
expr_stmt|;
block|}
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_blink_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint16_t
name|bwi_led_onoff
parameter_list|(
specifier|const
name|struct
name|bwi_led
modifier|*
name|led
parameter_list|,
name|uint16_t
name|val
parameter_list|,
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|led
operator|->
name|l_flags
operator|&
name|BWI_LED_F_ACTLOW
condition|)
name|on
operator|=
operator|!
name|on
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|val
operator||=
name|led
operator|->
name|l_mask
expr_stmt|;
else|else
name|val
operator|&=
operator|~
name|led
operator|->
name|l_mask
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_led_newstate
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_blink_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_led_blinking
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BWI_F_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|val
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_GPIO_CTRL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_LED_MAX
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|bwi_led
modifier|*
name|led
init|=
operator|&
name|sc
operator|->
name|sc_leds
index|[
name|i
index|]
decl_stmt|;
name|int
name|on
decl_stmt|;
if|if
condition|(
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_UNKN
operator|||
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|led
operator|->
name|l_flags
operator|&
name|BWI_LED_F_BLINK
operator|)
operator|&&
name|nstate
operator|!=
name|IEEE80211_S_INIT
condition|)
continue|continue;
switch|switch
condition|(
name|led
operator|->
name|l_act
condition|)
block|{
case|case
name|BWI_LED_ACT_ON
case|:
comment|/* Always on */
name|on
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BWI_LED_ACT_OFF
case|:
comment|/* Always off */
case|case
name|BWI_LED_ACT_5GHZ
case|:
comment|/* TODO: 11A */
name|on
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|on
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
name|on
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_RUN
case|:
if|if
condition|(
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_11G
operator|&&
name|ic
operator|->
name|ic_curmode
operator|!=
name|IEEE80211_MODE_11G
condition|)
name|on
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|led
operator|->
name|l_act
operator|==
name|BWI_LED_ACT_ASSOC
condition|)
name|on
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|val
operator|=
name|bwi_led_onoff
argument_list|(
name|led
argument_list|,
name|val
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_GPIO_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_led_event
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|struct
name|bwi_led
modifier|*
name|led
init|=
name|sc
operator|->
name|sc_blink_led
decl_stmt|;
name|int
name|rate
decl_stmt|;
if|if
condition|(
name|event
operator|==
name|BWI_LED_EVENT_POLL
condition|)
block|{
if|if
condition|(
operator|(
name|led
operator|->
name|l_flags
operator|&
name|BWI_LED_F_POLLABLE
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ticks
operator|-
name|sc
operator|->
name|sc_led_ticks
operator|<
name|sc
operator|->
name|sc_led_idle
condition|)
return|return;
block|}
name|sc
operator|->
name|sc_led_ticks
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_led_blinking
condition|)
return|return;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|BWI_LED_EVENT_RX
case|:
name|rate
operator|=
name|sc
operator|->
name|sc_rx_rate
expr_stmt|;
break|break;
case|case
name|BWI_LED_EVENT_TX
case|:
name|rate
operator|=
name|sc
operator|->
name|sc_tx_rate
expr_stmt|;
break|break;
case|case
name|BWI_LED_EVENT_POLL
case|:
name|rate
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown LED event %d\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
name|bwi_led_blink_start
argument_list|(
name|sc
argument_list|,
name|bwi_led_duration
index|[
name|rate
index|]
operator|.
name|on_dur
argument_list|,
name|bwi_led_duration
index|[
name|rate
index|]
operator|.
name|off_dur
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_led_blink_start
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on_dur
parameter_list|,
name|int
name|off_dur
parameter_list|)
block|{
name|struct
name|bwi_led
modifier|*
name|led
init|=
name|sc
operator|->
name|sc_blink_led
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|val
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_GPIO_CTRL
argument_list|)
expr_stmt|;
name|val
operator|=
name|bwi_led_onoff
argument_list|(
name|led
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_GPIO_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|l_flags
operator|&
name|BWI_LED_F_SLOW
condition|)
block|{
name|BWI_LED_SLOWDOWN
argument_list|(
name|on_dur
argument_list|)
expr_stmt|;
name|BWI_LED_SLOWDOWN
argument_list|(
name|off_dur
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_led_blinking
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_led_blink_offdur
operator|=
name|off_dur
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_blink_ch
argument_list|,
name|on_dur
argument_list|,
name|bwi_led_blink_next
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_led_blink_next
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|val
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_GPIO_CTRL
argument_list|)
expr_stmt|;
name|val
operator|=
name|bwi_led_onoff
argument_list|(
name|sc
operator|->
name|sc_blink_led
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_GPIO_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_blink_ch
argument_list|,
name|sc
operator|->
name|sc_led_blink_offdur
argument_list|,
name|bwi_led_blink_end
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_led_blink_end
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|sc
operator|->
name|sc_led_blinking
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_restart
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s begin, help!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|BWI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bwi_init_statechg
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bwi_start_locked(sc);
endif|#
directive|endif
name|BWI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

