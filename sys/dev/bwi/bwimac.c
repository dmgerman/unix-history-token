begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007 The DragonFly Project.  All rights reserved.  *   * This code is derived from software contributed to The DragonFly Project  * by Sepherosa Ziehau<sepherosa@gmail.com>  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of The DragonFly Project nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific, prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * $DragonFly: src/sys/dev/netif/bwi/bwimac.c,v 1.13 2008/02/15 11:15:38 sephe Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_bwi.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_amrr.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_phy.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/bitops.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/if_bwireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/if_bwivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/bwimac.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/bwirf.h>
end_include

begin_include
include|#
directive|include
file|<dev/bwi/bwiphy.h>
end_include

begin_struct
struct|struct
name|bwi_retry_lim
block|{
name|uint16_t
name|shretry
decl_stmt|;
name|uint16_t
name|shretry_fb
decl_stmt|;
name|uint16_t
name|lgretry
decl_stmt|;
name|uint16_t
name|lgretry_fb
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|bwi_mac_test
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_mac_get_property
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_set_retry_lim
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|,
specifier|const
name|struct
name|bwi_retry_lim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_set_ackrates
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_rate_table
modifier|*
name|rt
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_mac_gpio_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_mac_gpio_fini
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_opmode_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_hostflags_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_bss_param_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_mac_fw_alloc
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_fw_free
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_mac_fw_load
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_mac_fw_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bwi_mac_fw_load_iv
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_setup_tpctl
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_adjust_tpctl
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_lock
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bwi_mac_unlock
parameter_list|(
name|struct
name|bwi_mac
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|bwi_sup_macrev
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|9
block|,
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bwi_tmplt_write_4
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|uint32_t
name|ofs
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_BSWAP
condition|)
name|val
operator|=
name|bswap32
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_TMPLT_CTRL
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_TMPLT_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_hostflags_write
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|flags
operator|&
literal|0xffff
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_HFLAGS_LO
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|flags
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_HFLAGS_MI
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* HI has unclear meaning, so leave it as it is */
block|}
end_function

begin_function
name|uint64_t
name|bwi_hostflags_read
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|uint64_t
name|flags
decl_stmt|,
name|val
decl_stmt|;
comment|/* HI has unclear meaning, so don't touch it */
name|flags
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|MOBJ_READ_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_HFLAGS_MI
argument_list|)
expr_stmt|;
name|flags
operator||=
name|val
operator|<<
literal|16
expr_stmt|;
name|val
operator|=
name|MOBJ_READ_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_HFLAGS_LO
argument_list|)
expr_stmt|;
name|flags
operator||=
name|val
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_function
name|uint16_t
name|bwi_memobj_read_2
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|uint16_t
name|obj_id
parameter_list|,
name|uint16_t
name|ofs0
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|uint32_t
name|data_reg
decl_stmt|;
name|int
name|ofs
decl_stmt|;
name|data_reg
operator|=
name|BWI_MOBJ_DATA
expr_stmt|;
name|ofs
operator|=
name|ofs0
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|ofs0
operator|%
literal|4
operator|!=
literal|0
condition|)
name|data_reg
operator|=
name|BWI_MOBJ_DATA_UNALIGN
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|obj_id
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|data_reg
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|bwi_memobj_read_4
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|uint16_t
name|obj_id
parameter_list|,
name|uint16_t
name|ofs0
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|int
name|ofs
decl_stmt|;
name|ofs
operator|=
name|ofs0
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|ofs0
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|ret
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|obj_id
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA_UNALIGN
argument_list|)
expr_stmt|;
name|ret
operator|<<=
literal|16
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|obj_id
argument_list|,
name|ofs
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator||=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|obj_id
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|bwi_memobj_write_2
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|uint16_t
name|obj_id
parameter_list|,
name|uint16_t
name|ofs0
parameter_list|,
name|uint16_t
name|v
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|uint32_t
name|data_reg
decl_stmt|;
name|int
name|ofs
decl_stmt|;
name|data_reg
operator|=
name|BWI_MOBJ_DATA
expr_stmt|;
name|ofs
operator|=
name|ofs0
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|ofs0
operator|%
literal|4
operator|!=
literal|0
condition|)
name|data_reg
operator|=
name|BWI_MOBJ_DATA_UNALIGN
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|obj_id
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|data_reg
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_memobj_write_4
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|uint16_t
name|obj_id
parameter_list|,
name|uint16_t
name|ofs0
parameter_list|,
name|uint32_t
name|v
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|int
name|ofs
decl_stmt|;
name|ofs
operator|=
name|ofs0
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|ofs0
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|obj_id
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA_UNALIGN
argument_list|,
name|v
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|obj_id
argument_list|,
name|ofs
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA
argument_list|,
name|v
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|obj_id
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|bwi_mac_lateattach
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|>=
literal|5
condition|)
name|CSR_READ_4
argument_list|(
name|mac
operator|->
name|mac_sc
argument_list|,
name|BWI_STATE_HI
argument_list|)
expr_stmt|;
comment|/* dummy read */
name|bwi_mac_reset
argument_list|(
name|mac
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwi_phy_attach
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|bwi_rf_attach
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* Link 11B/G PHY, unlink 11A PHY */
if|if
condition|(
name|mac
operator|->
name|mac_phy
operator|.
name|phy_mode
operator|==
name|IEEE80211_MODE_11A
condition|)
name|bwi_mac_reset
argument_list|(
name|mac
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|bwi_mac_reset
argument_list|(
name|mac
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwi_mac_test
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|bwi_mac_get_property
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|bwi_rf_map_txpower
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bwi_rf_off
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|mac
operator|->
name|mac_sc
argument_list|,
name|BWI_BBP_ATTEN
argument_list|,
name|BWI_BBP_ATTEN_MAGIC
argument_list|)
expr_stmt|;
name|bwi_regwin_disable
argument_list|(
name|mac
operator|->
name|mac_sc
argument_list|,
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bwi_mac_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* Clear MAC/PHY/RF states */
name|bwi_mac_setup_tpctl
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|bwi_rf_clear_state
argument_list|(
operator|&
name|mac
operator|->
name|mac_rf
argument_list|)
expr_stmt|;
name|bwi_phy_clear_state
argument_list|(
operator|&
name|mac
operator|->
name|mac_phy
argument_list|)
expr_stmt|;
comment|/* Enable MAC and linked it to PHY */
if|if
condition|(
operator|!
name|bwi_regwin_is_enabled
argument_list|(
name|sc
argument_list|,
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|)
condition|)
name|bwi_mac_reset
argument_list|(
name|mac
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize backplane */
name|error
operator|=
name|bwi_bus_init
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* do timeout fixup */
if|if
condition|(
name|sc
operator|->
name|sc_bus_regwin
operator|.
name|rw_rev
operator|<=
literal|5
operator|&&
name|sc
operator|->
name|sc_bus_regwin
operator|.
name|rw_type
operator|!=
name|BWI_REGWIN_T_BUSPCIE
condition|)
block|{
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_CONF_LO
argument_list|,
name|__SHIFTIN
argument_list|(
name|BWI_CONF_LO_SERVTO
argument_list|,
name|BWI_CONF_LO_SERVTO_MASK
argument_list|)
operator||
name|__SHIFTIN
argument_list|(
name|BWI_CONF_LO_REQTO
argument_list|,
name|BWI_CONF_LO_REQTO_MASK
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Calibrate PHY */
name|error
operator|=
name|bwi_phy_calibrate
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"PHY calibrate failed\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Prepare to initialize firmware */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_UCODE_JUMP0
operator||
name|BWI_MAC_STATUS_IHREN
argument_list|)
expr_stmt|;
comment|/* 	 * Load and initialize firmwares 	 */
name|error
operator|=
name|bwi_mac_fw_alloc
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|bwi_mac_fw_load
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|bwi_mac_gpio_init
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|bwi_mac_fw_init
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * Turn on RF 	 */
name|bwi_rf_on
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* TODO: LED, hardware rf enabled is only related to LED setting */
comment|/* 	 * Initialize PHY 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_BBP_ATTEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bwi_phy_init
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* TODO: interference mitigation */
comment|/* 	 * Setup antenna mode 	 */
name|bwi_rf_set_ant_mode
argument_list|(
name|mac
argument_list|,
name|mac
operator|->
name|mac_rf
operator|.
name|rf_ant_mode
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize operation mode (RX configuration) 	 */
name|bwi_mac_opmode_init
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* set up Beacon interval */
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|<
literal|3
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x60e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x610
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x604
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x606
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
literal|0x188
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
literal|0x18c
argument_list|,
literal|0x2000000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize TX/RX interrupts' mask 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|,
name|BWI_INTR_TIMER1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TXRX_NRING
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|intrs
decl_stmt|;
if|if
condition|(
name|BWI_TXRX_IS_RX
argument_list|(
name|i
argument_list|)
condition|)
name|intrs
operator|=
name|BWI_TXRX_RX_INTRS
expr_stmt|;
else|else
name|intrs
operator|=
name|BWI_TXRX_TX_INTRS
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_TXRX_INTR_MASK
argument_list|(
name|i
argument_list|)
argument_list|,
name|intrs
argument_list|)
expr_stmt|;
block|}
comment|/* allow the MAC to control the PHY clock (dynamic on/off) */
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
literal|0x100000
argument_list|)
expr_stmt|;
comment|/* Setup MAC power up delay */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_POWERUP_DELAY
argument_list|,
name|sc
operator|->
name|sc_pwron_delay
argument_list|)
expr_stmt|;
comment|/* Set MAC regwin revision */
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_MACREV
argument_list|,
name|mac
operator|->
name|mac_rev
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize host flags 	 */
name|bwi_mac_hostflags_init
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize BSS parameters 	 */
name|bwi_mac_bss_param_init
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize TX rings 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TX_NRING
condition|;
operator|++
name|i
control|)
block|{
name|error
operator|=
name|sc
operator|->
name|sc_init_tx_ring
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't initialize %dth TX ring\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * Initialize RX ring 	 */
name|error
operator|=
name|sc
operator|->
name|sc_init_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't initialize RX ring\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Initialize TX stats if the current MAC uses that 	 */
if|if
condition|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_HAS_TXSTATS
condition|)
block|{
name|error
operator|=
name|sc
operator|->
name|sc_init_txstats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't initialize TX stats ring\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* update PRETBTT */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x612
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
comment|/* Force Pre-TBTT to 80? */
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
literal|0x416
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
literal|0x414
argument_list|,
literal|0x1f4
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_flags
operator||=
name|BWI_MAC_F_INITED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bwi_mac_reset
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|int
name|link_phy
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|,
name|state_lo
decl_stmt|,
name|status
decl_stmt|;
name|flags
operator|=
name|BWI_STATE_LO_FLAG_PHYRST
operator||
name|BWI_STATE_LO_FLAG_PHYCLKEN
expr_stmt|;
if|if
condition|(
name|link_phy
condition|)
name|flags
operator||=
name|BWI_STATE_LO_FLAG_PHYLNK
expr_stmt|;
name|bwi_regwin_enable
argument_list|(
name|sc
argument_list|,
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|state_lo
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
name|state_lo
operator||=
name|BWI_STATE_LO_GATED_CLOCK
expr_stmt|;
name|state_lo
operator|&=
operator|~
name|__SHIFTIN
argument_list|(
name|BWI_STATE_LO_FLAG_PHYRST
argument_list|,
name|BWI_STATE_LO_FLAGS_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
name|state_lo
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|state_lo
operator|&=
operator|~
name|BWI_STATE_LO_GATED_CLOCK
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|,
name|state_lo
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_LO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_BBP_ATTEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
name|status
operator||=
name|BWI_MAC_STATUS_IHREN
expr_stmt|;
if|if
condition|(
name|link_phy
condition|)
name|status
operator||=
name|BWI_MAC_STATUS_PHYLNK
expr_stmt|;
else|else
name|status
operator|&=
operator|~
name|BWI_MAC_STATUS_PHYLNK
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_phy
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_ATTACH
operator||
name|BWI_DBG_INIT
argument_list|,
literal|"%s\n"
argument_list|,
literal|"PHY is linked"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_phy
operator|.
name|phy_flags
operator||=
name|BWI_PHY_F_LINKED
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_ATTACH
operator||
name|BWI_DBG_INIT
argument_list|,
literal|"%s\n"
argument_list|,
literal|"PHY is unlinked"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_phy
operator|.
name|phy_flags
operator|&=
operator|~
name|BWI_PHY_F_LINKED
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bwi_mac_set_tpctl_11bg
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
specifier|const
name|struct
name|bwi_tpctl
modifier|*
name|new_tpctl
parameter_list|)
block|{
name|struct
name|bwi_rf
modifier|*
name|rf
init|=
operator|&
name|mac
operator|->
name|mac_rf
decl_stmt|;
name|struct
name|bwi_tpctl
modifier|*
name|tpctl
init|=
operator|&
name|mac
operator|->
name|mac_tpctl
decl_stmt|;
if|if
condition|(
name|new_tpctl
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|new_tpctl
operator|->
name|bbp_atten
operator|<=
name|BWI_BBP_ATTEN_MAX
argument_list|,
operator|(
literal|"bbp_atten %d"
operator|,
name|new_tpctl
operator|->
name|bbp_atten
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|new_tpctl
operator|->
name|rf_atten
operator|<=
operator|(
name|rf
operator|->
name|rf_rev
operator|<
literal|6
condition|?
name|BWI_RF_ATTEN_MAX0
else|:
name|BWI_RF_ATTEN_MAX1
operator|)
argument_list|,
operator|(
literal|"rf_atten %d"
operator|,
name|new_tpctl
operator|->
name|rf_atten
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|new_tpctl
operator|->
name|tp_ctrl1
operator|<=
name|BWI_TPCTL1_MAX
argument_list|,
operator|(
literal|"tp_ctrl1 %d"
operator|,
name|new_tpctl
operator|->
name|tp_ctrl1
operator|)
argument_list|)
expr_stmt|;
name|tpctl
operator|->
name|bbp_atten
operator|=
name|new_tpctl
operator|->
name|bbp_atten
expr_stmt|;
name|tpctl
operator|->
name|rf_atten
operator|=
name|new_tpctl
operator|->
name|rf_atten
expr_stmt|;
name|tpctl
operator|->
name|tp_ctrl1
operator|=
name|new_tpctl
operator|->
name|tp_ctrl1
expr_stmt|;
block|}
comment|/* Set BBP attenuation */
name|bwi_phy_set_bbp_atten
argument_list|(
name|mac
argument_list|,
name|tpctl
operator|->
name|bbp_atten
argument_list|)
expr_stmt|;
comment|/* Set RF attenuation */
name|RF_WRITE
argument_list|(
name|mac
argument_list|,
name|BWI_RFR_ATTEN
argument_list|,
name|tpctl
operator|->
name|rf_atten
argument_list|)
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_RF_ATTEN
argument_list|,
name|tpctl
operator|->
name|rf_atten
argument_list|)
expr_stmt|;
comment|/* Set TX power */
if|if
condition|(
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2050
condition|)
block|{
name|RF_FILT_SETBITS
argument_list|(
name|mac
argument_list|,
name|BWI_RFR_TXPWR
argument_list|,
operator|~
name|BWI_RFR_TXPWR1_MASK
argument_list|,
name|__SHIFTIN
argument_list|(
name|tpctl
operator|->
name|tp_ctrl1
argument_list|,
name|BWI_RFR_TXPWR1_MASK
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust RF Local Oscillator */
if|if
condition|(
name|mac
operator|->
name|mac_phy
operator|.
name|phy_mode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|bwi_rf_lo_adjust
argument_list|(
name|mac
argument_list|,
name|tpctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_mac_test
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|uint32_t
name|orig_val
decl_stmt|,
name|val
decl_stmt|;
define|#
directive|define
name|TEST_VAL1
value|0xaa5555aa
define|#
directive|define
name|TEST_VAL2
value|0x55aaaa55
comment|/* Save it for later restoring */
name|orig_val
operator|=
name|MOBJ_READ_4
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Test 1 */
name|MOBJ_WRITE_4
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
literal|0
argument_list|,
name|TEST_VAL1
argument_list|)
expr_stmt|;
name|val
operator|=
name|MOBJ_READ_4
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TEST_VAL1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TEST1 failed\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Test 2 */
name|MOBJ_WRITE_4
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
literal|0
argument_list|,
name|TEST_VAL2
argument_list|)
expr_stmt|;
name|val
operator|=
name|MOBJ_READ_4
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TEST_VAL2
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TEST2 failed\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Restore to the original value */
name|MOBJ_WRITE_4
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
literal|0
argument_list|,
name|orig_val
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|~
name|BWI_MAC_STATUS_PHYLNK
operator|)
operator|!=
name|BWI_MAC_STATUS_IHREN
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s failed, MAC status 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s failed, intr status %08x\n"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
undef|#
directive|undef
name|TEST_VAL2
undef|#
directive|undef
name|TEST_VAL1
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_setup_tpctl
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_rf
modifier|*
name|rf
init|=
operator|&
name|mac
operator|->
name|mac_rf
decl_stmt|;
name|struct
name|bwi_phy
modifier|*
name|phy
init|=
operator|&
name|mac
operator|->
name|mac_phy
decl_stmt|;
name|struct
name|bwi_tpctl
modifier|*
name|tpctl
init|=
operator|&
name|mac
operator|->
name|mac_tpctl
decl_stmt|;
comment|/* Calc BBP attenuation */
if|if
condition|(
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2050
operator|&&
name|rf
operator|->
name|rf_rev
operator|<
literal|6
condition|)
name|tpctl
operator|->
name|bbp_atten
operator|=
literal|0
expr_stmt|;
else|else
name|tpctl
operator|->
name|bbp_atten
operator|=
literal|2
expr_stmt|;
comment|/* Calc TX power CTRL1?? */
name|tpctl
operator|->
name|tp_ctrl1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2050
condition|)
block|{
if|if
condition|(
name|rf
operator|->
name|rf_rev
operator|==
literal|1
condition|)
name|tpctl
operator|->
name|tp_ctrl1
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|rf
operator|->
name|rf_rev
operator|<
literal|6
condition|)
name|tpctl
operator|->
name|tp_ctrl1
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rf
operator|->
name|rf_rev
operator|==
literal|8
condition|)
name|tpctl
operator|->
name|tp_ctrl1
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Empty TX power CTRL2?? */
name|tpctl
operator|->
name|tp_ctrl2
operator|=
literal|0xffff
expr_stmt|;
comment|/* 	 * Calc RF attenuation 	 */
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11A
condition|)
block|{
name|tpctl
operator|->
name|rf_atten
operator|=
literal|0x60
expr_stmt|;
goto|goto
name|back
goto|;
block|}
if|if
condition|(
name|BWI_IS_BRCM_BCM4309G
argument_list|(
name|sc
argument_list|)
operator|&&
name|sc
operator|->
name|sc_pci_revid
operator|<
literal|0x51
condition|)
block|{
name|tpctl
operator|->
name|rf_atten
operator|=
name|sc
operator|->
name|sc_pci_revid
operator|<
literal|0x43
condition|?
literal|2
else|:
literal|3
expr_stmt|;
goto|goto
name|back
goto|;
block|}
name|tpctl
operator|->
name|rf_atten
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|rf_type
operator|!=
name|BWI_RF_T_BCM2050
condition|)
block|{
if|if
condition|(
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2053
operator|&&
name|rf
operator|->
name|rf_rev
operator|==
literal|1
condition|)
name|tpctl
operator|->
name|rf_atten
operator|=
literal|6
expr_stmt|;
goto|goto
name|back
goto|;
block|}
comment|/* 	 * NB: If we reaches here and the card is BRCM_BCM4309G, 	 *     then the card's PCI revision must>= 0x51 	 */
comment|/* BCM2050 RF */
switch|switch
condition|(
name|rf
operator|->
name|rf_rev
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11G
condition|)
block|{
if|if
condition|(
name|BWI_IS_BRCM_BCM4309G
argument_list|(
name|sc
argument_list|)
operator|||
name|BWI_IS_BRCM_BU4306
argument_list|(
name|sc
argument_list|)
condition|)
name|tpctl
operator|->
name|rf_atten
operator|=
literal|3
expr_stmt|;
else|else
name|tpctl
operator|->
name|rf_atten
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|BWI_IS_BRCM_BCM4309G
argument_list|(
name|sc
argument_list|)
condition|)
name|tpctl
operator|->
name|rf_atten
operator|=
literal|7
expr_stmt|;
else|else
name|tpctl
operator|->
name|rf_atten
operator|=
literal|6
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11G
condition|)
block|{
comment|/* 			 * NOTE: Order of following conditions is critical 			 */
if|if
condition|(
name|BWI_IS_BRCM_BCM4309G
argument_list|(
name|sc
argument_list|)
condition|)
name|tpctl
operator|->
name|rf_atten
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|BWI_IS_BRCM_BU4306
argument_list|(
name|sc
argument_list|)
condition|)
name|tpctl
operator|->
name|rf_atten
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_bbp_id
operator|==
name|BWI_BBPID_BCM4320
condition|)
name|tpctl
operator|->
name|rf_atten
operator|=
literal|4
expr_stmt|;
else|else
name|tpctl
operator|->
name|rf_atten
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|tpctl
operator|->
name|rf_atten
operator|=
literal|6
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
name|tpctl
operator|->
name|rf_atten
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|tpctl
operator|->
name|rf_atten
operator|=
literal|0x1a
expr_stmt|;
break|break;
block|}
name|back
label|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_INIT
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"bbp atten: %u, rf atten: %u, ctrl1: %u, ctrl2: %u\n"
argument_list|,
name|tpctl
operator|->
name|bbp_atten
argument_list|,
name|tpctl
operator|->
name|rf_atten
argument_list|,
name|tpctl
operator|->
name|tp_ctrl1
argument_list|,
name|tpctl
operator|->
name|tp_ctrl2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_mac_dummy_xmit
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
define|#
directive|define
name|PACKET_LEN
value|5
specifier|static
specifier|const
name|uint32_t
name|packet_11a
index|[
name|PACKET_LEN
index|]
init|=
block|{
literal|0x000201cc
block|,
literal|0x00d40000
block|,
literal|0x00000000
block|,
literal|0x01000000
block|,
literal|0x00000000
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|packet_11bg
index|[
name|PACKET_LEN
index|]
init|=
block|{
literal|0x000b846e
block|,
literal|0x00d40000
block|,
literal|0x00000000
block|,
literal|0x01000000
block|,
literal|0x00000000
block|}
decl_stmt|;
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_rf
modifier|*
name|rf
init|=
operator|&
name|mac
operator|->
name|mac_rf
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|packet
decl_stmt|;
name|uint16_t
name|val_50c
decl_stmt|;
name|int
name|wait_max
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_phy
operator|.
name|phy_mode
operator|==
name|IEEE80211_MODE_11A
condition|)
block|{
name|wait_max
operator|=
literal|30
expr_stmt|;
name|packet
operator|=
name|packet_11a
expr_stmt|;
name|val_50c
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wait_max
operator|=
literal|250
expr_stmt|;
name|packet
operator|=
name|packet_11bg
expr_stmt|;
name|val_50c
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PACKET_LEN
condition|;
operator|++
name|i
control|)
name|TMPLT_WRITE_4
argument_list|(
name|mac
argument_list|,
name|i
operator|*
literal|4
argument_list|,
name|packet
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
comment|/* dummy read */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x568
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x7c0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x50c
argument_list|,
name|val_50c
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x508
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x50a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x54c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x56a
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x568
argument_list|,
literal|0x826
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x500
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
literal|0x502
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2050
operator|&&
name|rf
operator|->
name|rf_rev
operator|<=
literal|5
condition|)
name|RF_WRITE
argument_list|(
name|mac
argument_list|,
literal|0x51
argument_list|,
literal|0x17
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wait_max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
literal|0x50e
argument_list|)
operator|&
literal|0x80
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
literal|0x50e
argument_list|)
operator|&
literal|0x400
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
literal|0x690
argument_list|)
operator|&
literal|0x100
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2050
operator|&&
name|rf
operator|->
name|rf_rev
operator|<=
literal|5
condition|)
name|RF_WRITE
argument_list|(
name|mac
argument_list|,
literal|0x51
argument_list|,
literal|0x37
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PACKET_LEN
block|}
end_function

begin_function
name|void
name|bwi_mac_init_tpctl_11bg
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_phy
modifier|*
name|phy
init|=
operator|&
name|mac
operator|->
name|mac_phy
decl_stmt|;
name|struct
name|bwi_rf
modifier|*
name|rf
init|=
operator|&
name|mac
operator|->
name|mac_rf
decl_stmt|;
name|struct
name|bwi_tpctl
name|tpctl_orig
decl_stmt|;
name|int
name|restore_tpctl
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|phy
operator|->
name|phy_mode
operator|!=
name|IEEE80211_MODE_11A
argument_list|,
operator|(
literal|"phy_mode %d"
operator|,
name|phy
operator|->
name|phy_mode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BWI_IS_BRCM_BU4306
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
name|PHY_WRITE
argument_list|(
name|mac
argument_list|,
literal|0x28
argument_list|,
literal|0x8018
argument_list|)
expr_stmt|;
name|CSR_CLRBITS_2
argument_list|(
name|sc
argument_list|,
name|BWI_BBP_ATTEN
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11G
condition|)
block|{
if|if
condition|(
operator|(
name|phy
operator|->
name|phy_flags
operator|&
name|BWI_PHY_F_LINKED
operator|)
operator|==
literal|0
condition|)
return|return;
name|PHY_WRITE
argument_list|(
name|mac
argument_list|,
literal|0x47a
argument_list|,
literal|0xc111
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_TPCTL_INITED
condition|)
return|return;
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11B
operator|&&
name|phy
operator|->
name|phy_rev
operator|>=
literal|2
operator|&&
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2050
condition|)
block|{
name|RF_SETBITS
argument_list|(
name|mac
argument_list|,
literal|0x76
argument_list|,
literal|0x84
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bwi_tpctl
name|tpctl
decl_stmt|;
comment|/* Backup original TX power control variables */
name|bcopy
argument_list|(
operator|&
name|mac
operator|->
name|mac_tpctl
argument_list|,
operator|&
name|tpctl_orig
argument_list|,
sizeof|sizeof
argument_list|(
name|tpctl_orig
argument_list|)
argument_list|)
expr_stmt|;
name|restore_tpctl
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|mac
operator|->
name|mac_tpctl
argument_list|,
operator|&
name|tpctl
argument_list|,
sizeof|sizeof
argument_list|(
name|tpctl
argument_list|)
argument_list|)
expr_stmt|;
name|tpctl
operator|.
name|bbp_atten
operator|=
literal|11
expr_stmt|;
name|tpctl
operator|.
name|tp_ctrl1
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|rf
operator|->
name|rf_rev
operator|>=
literal|6
operator|&&
name|rf
operator|->
name|rf_rev
operator|<=
literal|8
condition|)
name|tpctl
operator|.
name|rf_atten
operator|=
literal|31
expr_stmt|;
else|else
endif|#
directive|endif
name|tpctl
operator|.
name|rf_atten
operator|=
literal|9
expr_stmt|;
name|bwi_mac_set_tpctl_11bg
argument_list|(
name|mac
argument_list|,
operator|&
name|tpctl
argument_list|)
expr_stmt|;
block|}
name|bwi_mac_dummy_xmit
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_flags
operator||=
name|BWI_MAC_F_TPCTL_INITED
expr_stmt|;
name|rf
operator|->
name|rf_base_tssi
operator|=
name|PHY_READ
argument_list|(
name|mac
argument_list|,
literal|0x29
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_INIT
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"base tssi %d\n"
argument_list|,
name|rf
operator|->
name|rf_base_tssi
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|rf
operator|->
name|rf_base_tssi
operator|-
name|rf
operator|->
name|rf_idle_tssi
argument_list|)
operator|>=
literal|20
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"base tssi measure failed\n"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_flags
operator||=
name|BWI_MAC_F_TPCTL_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|restore_tpctl
condition|)
name|bwi_mac_set_tpctl_11bg
argument_list|(
name|mac
argument_list|,
operator|&
name|tpctl_orig
argument_list|)
expr_stmt|;
else|else
name|RF_CLRBITS
argument_list|(
name|mac
argument_list|,
literal|0x76
argument_list|,
literal|0x84
argument_list|)
expr_stmt|;
name|bwi_rf_clear_tssi
argument_list|(
name|mac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_mac_detach
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|bwi_mac_fw_free
argument_list|(
name|mac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|bwi_fwimage_is_valid
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
name|fw
parameter_list|,
name|uint8_t
name|fw_type
parameter_list|)
block|{
specifier|const
name|struct
name|bwi_fwhdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|fw
operator|->
name|datasize
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid firmware (%s): invalid size %zu\n"
argument_list|,
name|fw
operator|->
name|name
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|bwi_fwhdr
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|fw_type
operator|!=
name|BWI_FW_T_IV
condition|)
block|{
comment|/* 		 * Don't verify IV's size, it has different meaning 		 */
if|if
condition|(
name|be32toh
argument_list|(
name|hdr
operator|->
name|fw_size
argument_list|)
operator|!=
name|fw
operator|->
name|datasize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid firmware (%s): size mismatch, "
literal|"fw %u, real %zu\n"
argument_list|,
name|fw
operator|->
name|name
argument_list|,
name|be32toh
argument_list|(
name|hdr
operator|->
name|fw_size
argument_list|)
argument_list|,
name|fw
operator|->
name|datasize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|hdr
operator|->
name|fw_type
operator|!=
name|fw_type
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid firmware (%s): type mismatch, "
literal|"fw \'%c\', target \'%c\'\n"
argument_list|,
name|fw
operator|->
name|name
argument_list|,
name|hdr
operator|->
name|fw_type
argument_list|,
name|fw_type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|fw_gen
operator|!=
name|BWI_FW_GEN_1
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid firmware (%s): wrong generation, "
literal|"fw %d, target %d\n"
argument_list|,
name|fw
operator|->
name|name
argument_list|,
name|hdr
operator|->
name|fw_gen
argument_list|,
name|BWI_FW_GEN_1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * XXX Error cleanup  */
end_comment

begin_function
specifier|static
name|int
name|bwi_mac_fw_alloc
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|char
name|fwname
index|[
literal|64
index|]
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* 	 * Try getting the firmware stub so firmware 	 * module would be loaded automatically 	 */
if|if
condition|(
name|mac
operator|->
name|mac_stub
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|fwname
argument_list|,
sizeof|sizeof
argument_list|(
name|fwname
argument_list|)
argument_list|,
name|BWI_FW_STUB_PATH
argument_list|,
name|sc
operator|->
name|sc_fw_version
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_stub
operator|=
name|firmware_get
argument_list|(
name|fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_stub
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"request firmware %s failed\n"
argument_list|,
name|fwname
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
if|if
condition|(
name|mac
operator|->
name|mac_ucode
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|fwname
argument_list|,
sizeof|sizeof
argument_list|(
name|fwname
argument_list|)
argument_list|,
name|BWI_FW_UCODE_PATH
argument_list|,
name|sc
operator|->
name|sc_fw_version
argument_list|,
name|mac
operator|->
name|mac_rev
operator|>=
literal|5
condition|?
literal|5
else|:
name|mac
operator|->
name|mac_rev
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_ucode
operator|=
name|firmware_get
argument_list|(
name|fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_ucode
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"request firmware %s failed\n"
argument_list|,
name|fwname
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|!
name|bwi_fwimage_is_valid
argument_list|(
name|sc
argument_list|,
name|mac
operator|->
name|mac_ucode
argument_list|,
name|BWI_FW_T_UCODE
argument_list|)
condition|)
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_pcm
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|fwname
argument_list|,
sizeof|sizeof
argument_list|(
name|fwname
argument_list|)
argument_list|,
name|BWI_FW_PCM_PATH
argument_list|,
name|sc
operator|->
name|sc_fw_version
argument_list|,
name|mac
operator|->
name|mac_rev
operator|<
literal|5
condition|?
literal|4
else|:
literal|5
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_pcm
operator|=
name|firmware_get
argument_list|(
name|fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_pcm
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"request firmware %s failed\n"
argument_list|,
name|fwname
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|!
name|bwi_fwimage_is_valid
argument_list|(
name|sc
argument_list|,
name|mac
operator|->
name|mac_pcm
argument_list|,
name|BWI_FW_T_PCM
argument_list|)
condition|)
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_iv
operator|==
name|NULL
condition|)
block|{
comment|/* TODO: 11A */
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|==
literal|2
operator|||
name|mac
operator|->
name|mac_rev
operator|==
literal|4
condition|)
block|{
name|idx
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|>=
literal|5
operator|&&
name|mac
operator|->
name|mac_rev
operator|<=
literal|10
condition|)
block|{
name|idx
operator|=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"no suitible IV for MAC rev %d\n"
argument_list|,
name|mac
operator|->
name|mac_rev
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
name|snprintf
argument_list|(
name|fwname
argument_list|,
sizeof|sizeof
argument_list|(
name|fwname
argument_list|)
argument_list|,
name|BWI_FW_IV_PATH
argument_list|,
name|sc
operator|->
name|sc_fw_version
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_iv
operator|=
name|firmware_get
argument_list|(
name|fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_iv
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"request firmware %s failed\n"
argument_list|,
name|fwname
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|!
name|bwi_fwimage_is_valid
argument_list|(
name|sc
argument_list|,
name|mac
operator|->
name|mac_iv
argument_list|,
name|BWI_FW_T_IV
argument_list|)
condition|)
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_iv_ext
operator|==
name|NULL
condition|)
block|{
comment|/* TODO: 11A */
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|==
literal|2
operator|||
name|mac
operator|->
name|mac_rev
operator|==
literal|4
operator|||
name|mac
operator|->
name|mac_rev
operator|>=
literal|11
condition|)
block|{
comment|/* No extended IV */
goto|goto
name|back
goto|;
block|}
elseif|else
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|>=
literal|5
operator|&&
name|mac
operator|->
name|mac_rev
operator|<=
literal|10
condition|)
block|{
name|idx
operator|=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"no suitible ExtIV for MAC rev %d\n"
argument_list|,
name|mac
operator|->
name|mac_rev
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
name|snprintf
argument_list|(
name|fwname
argument_list|,
sizeof|sizeof
argument_list|(
name|fwname
argument_list|)
argument_list|,
name|BWI_FW_IV_EXT_PATH
argument_list|,
name|sc
operator|->
name|sc_fw_version
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_iv_ext
operator|=
name|firmware_get
argument_list|(
name|fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_iv_ext
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"request firmware %s failed\n"
argument_list|,
name|fwname
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|!
name|bwi_fwimage_is_valid
argument_list|(
name|sc
argument_list|,
name|mac
operator|->
name|mac_iv_ext
argument_list|,
name|BWI_FW_T_IV
argument_list|)
condition|)
return|return
name|EINVAL
return|;
block|}
name|back
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_fw_free
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
if|if
condition|(
name|mac
operator|->
name|mac_ucode
operator|!=
name|NULL
condition|)
block|{
name|firmware_put
argument_list|(
name|mac
operator|->
name|mac_ucode
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_ucode
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_pcm
operator|!=
name|NULL
condition|)
block|{
name|firmware_put
argument_list|(
name|mac
operator|->
name|mac_pcm
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_pcm
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_iv
operator|!=
name|NULL
condition|)
block|{
name|firmware_put
argument_list|(
name|mac
operator|->
name|mac_iv
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_iv
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_iv_ext
operator|!=
name|NULL
condition|)
block|{
name|firmware_put
argument_list|(
name|mac
operator|->
name|mac_iv_ext
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_iv_ext
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_stub
operator|!=
name|NULL
condition|)
block|{
name|firmware_put
argument_list|(
name|mac
operator|->
name|mac_stub
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_stub
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_mac_fw_load
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|fw
decl_stmt|;
name|uint16_t
name|fw_rev
decl_stmt|;
name|int
name|fw_len
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Load ucode image 	 */
name|fw
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|mac
operator|->
name|mac_ucode
operator|->
name|data
operator|+
name|BWI_FWHDR_SZ
operator|)
expr_stmt|;
name|fw_len
operator|=
operator|(
name|mac
operator|->
name|mac_ucode
operator|->
name|datasize
operator|-
name|BWI_FWHDR_SZ
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|BWI_FW_UCODE_MOBJ
operator||
name|BWI_WR_MOBJ_AUTOINC
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fw_len
condition|;
operator|++
name|i
control|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA
argument_list|,
name|be32toh
argument_list|(
name|fw
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Load PCM image 	 */
name|fw
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|mac
operator|->
name|mac_pcm
operator|->
name|data
operator|+
name|BWI_FWHDR_SZ
operator|)
expr_stmt|;
name|fw_len
operator|=
operator|(
name|mac
operator|->
name|mac_pcm
operator|->
name|datasize
operator|-
name|BWI_FWHDR_SZ
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|BWI_FW_PCM_MOBJ
argument_list|,
literal|0x01ea
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA
argument_list|,
literal|0x4000
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_CTRL
argument_list|,
name|BWI_MOBJ_CTRL_VAL
argument_list|(
name|BWI_FW_PCM_MOBJ
argument_list|,
literal|0x01eb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fw_len
condition|;
operator|++
name|i
control|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MOBJ_DATA
argument_list|,
name|be32toh
argument_list|(
name|fw
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|,
name|BWI_ALL_INTRS
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_UCODE_START
operator||
name|BWI_MAC_STATUS_IHREN
operator||
name|BWI_MAC_STATUS_INFRA
argument_list|)
expr_stmt|;
define|#
directive|define
name|NRETRY
value|200
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|intr_status
decl_stmt|;
name|intr_status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_status
operator|==
name|BWI_INTR_READY
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"firmware (ucode&pcm) loading timed out\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
undef|#
directive|undef
name|NRETRY
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|)
expr_stmt|;
comment|/* dummy read */
name|fw_rev
operator|=
name|MOBJ_READ_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_FWREV
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_rev
operator|>
name|BWI_FW_VERSION3_REVMAX
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"firmware version 4 is not supported yet\n"
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"firmware rev 0x%04x, patch level 0x%04x\n"
argument_list|,
name|fw_rev
argument_list|,
name|MOBJ_READ_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_FWPATCHLV
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_mac_gpio_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_regwin
modifier|*
name|old
decl_stmt|,
modifier|*
name|gpio_rw
decl_stmt|;
name|uint32_t
name|filt
decl_stmt|,
name|bits
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CSR_CLRBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_GPOSEL_MASK
argument_list|)
expr_stmt|;
comment|/* TODO:LED */
name|CSR_SETBITS_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_GPIO_MASK
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
name|filt
operator|=
literal|0x1f
expr_stmt|;
name|bits
operator|=
literal|0xf
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bbp_id
operator|==
name|BWI_BBPID_BCM4301
condition|)
block|{
name|filt
operator||=
literal|0x60
expr_stmt|;
name|bits
operator||=
literal|0x60
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_card_flags
operator|&
name|BWI_CARD_F_PA_GPIO9
condition|)
block|{
name|CSR_SETBITS_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_GPIO_MASK
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
name|filt
operator||=
literal|0x200
expr_stmt|;
name|bits
operator||=
literal|0x200
expr_stmt|;
block|}
name|gpio_rw
operator|=
name|BWI_GPIO_REGWIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|gpio_rw
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|CSR_FILT_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_GPIO_CTRL
argument_list|,
name|filt
argument_list|,
name|bits
argument_list|)
expr_stmt|;
return|return
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_mac_gpio_fini
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_regwin
modifier|*
name|old
decl_stmt|,
modifier|*
name|gpio_rw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|gpio_rw
operator|=
name|BWI_GPIO_REGWIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|gpio_rw
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_GPIO_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|bwi_regwin_switch
argument_list|(
name|sc
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_mac_fw_load_iv
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
name|fw
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
specifier|const
name|struct
name|bwi_fwhdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|struct
name|bwi_fw_iv
modifier|*
name|iv
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|iv_img_size
decl_stmt|;
comment|/* Get the number of IVs in the IV image */
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|bwi_fwhdr
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
name|n
operator|=
name|be32toh
argument_list|(
name|hdr
operator|->
name|fw_iv_cnt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_INIT
operator||
name|BWI_DBG_FIRMWARE
argument_list|,
literal|"IV count %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Calculate the IV image size, for later sanity check */
name|iv_img_size
operator|=
name|fw
operator|->
name|datasize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
comment|/* Locate the first IV */
name|iv
operator|=
operator|(
specifier|const
expr|struct
name|bwi_fw_iv
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|uint16_t
name|iv_ofs
decl_stmt|,
name|ofs
decl_stmt|;
name|int
name|sz
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iv_img_size
operator|<
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_ofs
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid IV image, ofs\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|iv_img_size
operator|-=
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_ofs
argument_list|)
expr_stmt|;
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_ofs
argument_list|)
expr_stmt|;
name|iv_ofs
operator|=
name|be16toh
argument_list|(
name|iv
operator|->
name|iv_ofs
argument_list|)
expr_stmt|;
name|ofs
operator|=
name|__SHIFTOUT
argument_list|(
name|iv_ofs
argument_list|,
name|BWI_FW_IV_OFS_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs
operator|>=
literal|0x1000
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid ofs (0x%04x) "
literal|"for %dth iv\n"
argument_list|,
name|ofs
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|iv_ofs
operator|&
name|BWI_FW_IV_IS_32BIT
condition|)
block|{
name|uint32_t
name|val32
decl_stmt|;
if|if
condition|(
name|iv_img_size
operator|<
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_val
operator|.
name|val32
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid IV image, val32\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|iv_img_size
operator|-=
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_val
operator|.
name|val32
argument_list|)
expr_stmt|;
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_val
operator|.
name|val32
argument_list|)
expr_stmt|;
name|val32
operator|=
name|be32toh
argument_list|(
name|iv
operator|->
name|iv_val
operator|.
name|val32
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|ofs
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint16_t
name|val16
decl_stmt|;
if|if
condition|(
name|iv_img_size
operator|<
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_val
operator|.
name|val16
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid IV image, val16\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|iv_img_size
operator|-=
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_val
operator|.
name|val16
argument_list|)
expr_stmt|;
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|iv
operator|->
name|iv_val
operator|.
name|val16
argument_list|)
expr_stmt|;
name|val16
operator|=
name|be16toh
argument_list|(
name|iv
operator|->
name|iv_val
operator|.
name|val16
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|ofs
argument_list|,
name|val16
argument_list|)
expr_stmt|;
block|}
name|iv
operator|=
operator|(
specifier|const
expr|struct
name|bwi_fw_iv
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|iv
operator|+
name|sz
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|iv_img_size
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid IV image, size left %d\n"
argument_list|,
name|iv_img_size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_mac_fw_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|mac
operator|->
name|mac_sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bwi_mac_fw_load_iv
argument_list|(
name|mac
argument_list|,
name|mac
operator|->
name|mac_iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"load IV failed\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_iv_ext
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bwi_mac_fw_load_iv
argument_list|(
name|mac
argument_list|,
name|mac
operator|->
name|mac_iv_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"load ExtIV failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_opmode_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|mac_status
decl_stmt|;
name|uint16_t
name|pre_tbtt
decl_stmt|;
name|CSR_CLRBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_INFRA
argument_list|)
expr_stmt|;
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_INFRA
argument_list|)
expr_stmt|;
comment|/* Set probe resp timeout to infinite */
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_PROBE_RESP_TO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: factor out following part 	 */
name|mac_status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
name|mac_status
operator|&=
operator|~
operator|(
name|BWI_MAC_STATUS_OPMODE_HOSTAP
operator||
name|BWI_MAC_STATUS_PASS_CTL
operator||
name|BWI_MAC_STATUS_PASS_BCN
operator||
name|BWI_MAC_STATUS_PASS_BADPLCP
operator||
name|BWI_MAC_STATUS_PASS_BADFCS
operator||
name|BWI_MAC_STATUS_PROMISC
operator|)
expr_stmt|;
name|mac_status
operator||=
name|BWI_MAC_STATUS_INFRA
expr_stmt|;
comment|/* Always turn on PROMISC on old hardware */
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|<
literal|5
condition|)
name|mac_status
operator||=
name|BWI_MAC_STATUS_PROMISC
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_IBSS
case|:
name|mac_status
operator|&=
operator|~
name|BWI_MAC_STATUS_INFRA
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|mac_status
operator||=
name|BWI_MAC_STATUS_OPMODE_HOSTAP
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
if|#
directive|if
literal|0
comment|/* Do you want data from your microwave oven? */
block|mac_status |= BWI_MAC_STATUS_PASS_CTL | 			      BWI_MAC_STATUS_PASS_BADPLCP | 			      BWI_MAC_STATUS_PASS_BADFCS;
else|#
directive|else
name|mac_status
operator||=
name|BWI_MAC_STATUS_PASS_CTL
expr_stmt|;
endif|#
directive|endif
comment|/* Promisc? */
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|mac_status
operator||=
name|BWI_MAC_STATUS_PROMISC
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|mac_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_IBSS
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bbp_id
operator|==
name|BWI_BBPID_BCM4306
operator|&&
name|sc
operator|->
name|sc_bbp_rev
operator|==
literal|3
condition|)
name|pre_tbtt
operator|=
literal|100
expr_stmt|;
else|else
name|pre_tbtt
operator|=
literal|50
expr_stmt|;
block|}
else|else
block|{
name|pre_tbtt
operator|=
literal|2
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_PRE_TBTT
argument_list|,
name|pre_tbtt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_hostflags_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_phy
modifier|*
name|phy
init|=
operator|&
name|mac
operator|->
name|mac_phy
decl_stmt|;
name|struct
name|bwi_rf
modifier|*
name|rf
init|=
operator|&
name|mac
operator|->
name|mac_rf
decl_stmt|;
name|uint64_t
name|host_flags
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11A
condition|)
return|return;
name|host_flags
operator|=
name|HFLAGS_READ
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|host_flags
operator||=
name|BWI_HFLAG_SYM_WA
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11G
condition|)
block|{
if|if
condition|(
name|phy
operator|->
name|phy_rev
operator|==
literal|1
condition|)
name|host_flags
operator||=
name|BWI_HFLAG_GDC_WA
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_card_flags
operator|&
name|BWI_CARD_F_PA_GPIO9
condition|)
name|host_flags
operator||=
name|BWI_HFLAG_OFDM_PA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11B
condition|)
block|{
if|if
condition|(
name|phy
operator|->
name|phy_rev
operator|>=
literal|2
operator|&&
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2050
condition|)
name|host_flags
operator|&=
operator|~
name|BWI_HFLAG_GDC_WA
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"unknown PHY mode %u\n"
argument_list|,
name|phy
operator|->
name|phy_mode
argument_list|)
expr_stmt|;
block|}
name|HFLAGS_WRITE
argument_list|(
name|mac
argument_list|,
name|host_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_bss_param_init
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_phy
modifier|*
name|phy
init|=
operator|&
name|mac
operator|->
name|mac_phy
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rate_table
modifier|*
name|rt
decl_stmt|;
name|struct
name|bwi_retry_lim
name|lim
decl_stmt|;
name|uint16_t
name|cw_min
decl_stmt|;
comment|/* 	 * Set short/long retry limits 	 */
name|bzero
argument_list|(
operator|&
name|lim
argument_list|,
sizeof|sizeof
argument_list|(
name|lim
argument_list|)
argument_list|)
expr_stmt|;
name|lim
operator|.
name|shretry
operator|=
name|BWI_SHRETRY
expr_stmt|;
name|lim
operator|.
name|shretry_fb
operator|=
name|BWI_SHRETRY_FB
expr_stmt|;
name|lim
operator|.
name|lgretry
operator|=
name|BWI_LGRETRY
expr_stmt|;
name|lim
operator|.
name|lgretry_fb
operator|=
name|BWI_LGRETRY_FB
expr_stmt|;
name|bwi_mac_set_retry_lim
argument_list|(
name|mac
argument_list|,
operator|&
name|lim
argument_list|)
expr_stmt|;
comment|/* 	 * Implicitly prevent firmware from sending probe response 	 * by setting its "probe response timeout" to 1us. 	 */
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_PROBE_RESP_TO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * XXX MAC level acknowledge and CW min/max should depend 	 * on the char rateset of the IBSS/BSS to join. 	 * XXX this is all wrong; should be done on channel change 	 */
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11B
condition|)
block|{
name|rt
operator|=
name|ieee80211_get_ratetable
argument_list|(
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
literal|2412
argument_list|,
name|IEEE80211_CHAN_B
argument_list|)
argument_list|)
expr_stmt|;
name|bwi_mac_set_ackrates
argument_list|(
name|mac
argument_list|,
name|rt
argument_list|,
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11B
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rt
operator|=
name|ieee80211_get_ratetable
argument_list|(
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
literal|2412
argument_list|,
name|IEEE80211_CHAN_G
argument_list|)
argument_list|)
expr_stmt|;
name|bwi_mac_set_ackrates
argument_list|(
name|mac
argument_list|,
name|rt
argument_list|,
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11G
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set CW min 	 */
if|if
condition|(
name|phy
operator|->
name|phy_mode
operator|==
name|IEEE80211_MODE_11B
condition|)
name|cw_min
operator|=
name|IEEE80211_CW_MIN_0
expr_stmt|;
else|else
name|cw_min
operator|=
name|IEEE80211_CW_MIN_1
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_80211_MOBJ
argument_list|,
name|BWI_80211_MOBJ_CWMIN
argument_list|,
name|cw_min
argument_list|)
expr_stmt|;
comment|/* 	 * Set CW max 	 */
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_80211_MOBJ
argument_list|,
name|BWI_80211_MOBJ_CWMAX
argument_list|,
name|IEEE80211_CW_MAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_set_retry_lim
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
specifier|const
name|struct
name|bwi_retry_lim
modifier|*
name|lim
parameter_list|)
block|{
comment|/* Short/Long retry limit */
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_80211_MOBJ
argument_list|,
name|BWI_80211_MOBJ_SHRETRY
argument_list|,
name|lim
operator|->
name|shretry
argument_list|)
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_80211_MOBJ
argument_list|,
name|BWI_80211_MOBJ_LGRETRY
argument_list|,
name|lim
operator|->
name|lgretry
argument_list|)
expr_stmt|;
comment|/* Short/Long retry fallback limit */
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_SHRETRY_FB
argument_list|,
name|lim
operator|->
name|shretry_fb
argument_list|)
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_LGRETEY_FB
argument_list|,
name|lim
operator|->
name|lgretry_fb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_set_ackrates
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
specifier|const
name|struct
name|ieee80211_rate_table
modifier|*
name|rt
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* XXX not standard conforming */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
operator|++
name|i
control|)
block|{
name|enum
name|ieee80211_phytype
name|modtype
decl_stmt|;
name|uint16_t
name|ofs
decl_stmt|;
name|modtype
operator|=
name|ieee80211_rate2phytype
argument_list|(
name|rt
argument_list|,
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|modtype
condition|)
block|{
case|case
name|IEEE80211_T_DS
case|:
name|ofs
operator|=
literal|0x4c0
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_OFDM
case|:
name|ofs
operator|=
literal|0x480
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unsupported modtype %u\n"
argument_list|,
name|modtype
argument_list|)
expr_stmt|;
block|}
name|ofs
operator|+=
literal|2
operator|*
operator|(
name|ieee80211_rate2plcp
argument_list|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
argument_list|,
name|modtype
argument_list|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|ofs
operator|+
literal|0x20
argument_list|,
name|MOBJ_READ_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|bwi_mac_start
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_ENABLE
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|,
name|BWI_INTR_READY
argument_list|)
expr_stmt|;
comment|/* Flush pending bus writes */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|)
expr_stmt|;
return|return
name|bwi_mac_config_ps
argument_list|(
name|mac
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|bwi_mac_stop
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|bwi_mac_config_ps
argument_list|(
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|CSR_CLRBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_ENABLE
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
define|#
directive|define
name|NRETRY
value|10000
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_INTR_STATUS
argument_list|)
operator|&
name|BWI_INTR_READY
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't stop MAC\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
undef|#
directive|undef
name|NRETRY
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bwi_mac_config_ps
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|BWI_MAC_STATUS_HW_PS
expr_stmt|;
name|status
operator||=
name|BWI_MAC_STATUS_WAKEUP
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|>=
literal|5
condition|)
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|NRETRY
value|100
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRETRY
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|MOBJ_READ_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_UCODE_STATE
argument_list|)
operator|!=
name|BWI_UCODE_STATE_PS
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NRETRY
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"config PS failed\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
undef|#
directive|undef
name|NRETRY
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bwi_mac_reset_hwkeys
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
comment|/* TODO: firmware crypto */
name|MOBJ_READ_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_KEYTABLE_OFS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_mac_shutdown
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_HAS_TXSTATS
condition|)
name|sc
operator|->
name|sc_free_txstats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_free_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BWI_TX_NRING
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|sc_free_tx_ring
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bwi_rf_off
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* TODO:LED */
name|bwi_mac_gpio_fini
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|bwi_rf_off
argument_list|(
name|mac
argument_list|)
expr_stmt|;
comment|/* XXX again */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BWI_BBP_ATTEN
argument_list|,
name|BWI_BBP_ATTEN_MAGIC
argument_list|)
expr_stmt|;
name|bwi_regwin_disable
argument_list|(
name|sc
argument_list|,
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_flags
operator|&=
operator|~
name|BWI_MAC_F_INITED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bwi_mac_get_property
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|enum
name|bwi_bus_space
name|old_bus_space
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
comment|/* 	 * Byte swap 	 */
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|BWI_MAC_STATUS_BSWAP
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_ATTACH
argument_list|,
literal|"%s\n"
argument_list|,
literal|"need byte swap"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_flags
operator||=
name|BWI_MAC_F_BSWAP
expr_stmt|;
block|}
comment|/* 	 * DMA address space 	 */
name|old_bus_space
operator|=
name|sc
operator|->
name|sc_bus_space
expr_stmt|;
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_STATE_HI
argument_list|)
expr_stmt|;
if|if
condition|(
name|__SHIFTOUT
argument_list|(
name|val
argument_list|,
name|BWI_STATE_HI_FLAGS_MASK
argument_list|)
operator|&
name|BWI_STATE_HI_FLAG_64BIT
condition|)
block|{
comment|/* 64bit address */
name|sc
operator|->
name|sc_bus_space
operator|=
name|BWI_BUS_SPACE_64BIT
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_ATTACH
argument_list|,
literal|"%s\n"
argument_list|,
literal|"64bit bus space"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|txrx_reg
init|=
name|BWI_TXRX_CTRL_BASE
operator|+
name|BWI_TX32_CTRL
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|txrx_reg
argument_list|,
name|BWI_TXRX32_CTRL_ADDRHI_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|txrx_reg
argument_list|)
operator|&
name|BWI_TXRX32_CTRL_ADDRHI_MASK
condition|)
block|{
comment|/* 32bit address */
name|sc
operator|->
name|sc_bus_space
operator|=
name|BWI_BUS_SPACE_32BIT
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_ATTACH
argument_list|,
literal|"%s\n"
argument_list|,
literal|"32bit bus space"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 30bit address */
name|sc
operator|->
name|sc_bus_space
operator|=
name|BWI_BUS_SPACE_30BIT
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_ATTACH
argument_list|,
literal|"%s\n"
argument_list|,
literal|"30bit bus space"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old_bus_space
operator|!=
literal|0
operator|&&
name|old_bus_space
operator|!=
name|sc
operator|->
name|sc_bus_space
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MACs bus space mismatch!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bwi_mac_updateslot
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|int
name|shslot
parameter_list|)
block|{
name|uint16_t
name|slot_time
decl_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_phy
operator|.
name|phy_mode
operator|==
name|IEEE80211_MODE_11B
condition|)
return|return;
if|if
condition|(
name|shslot
condition|)
name|slot_time
operator|=
name|IEEE80211_DUR_SHSLOT
expr_stmt|;
else|else
name|slot_time
operator|=
name|IEEE80211_DUR_SLOT
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|mac
operator|->
name|mac_sc
argument_list|,
name|BWI_MAC_SLOTTIME
argument_list|,
name|slot_time
operator|+
name|BWI_MAC_SLOTTIME_ADJUST
argument_list|)
expr_stmt|;
name|MOBJ_WRITE_2
argument_list|(
name|mac
argument_list|,
name|BWI_COMM_MOBJ
argument_list|,
name|BWI_COMM_MOBJ_SLOTTIME
argument_list|,
name|slot_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bwi_mac_attach
parameter_list|(
name|struct
name|bwi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|,
name|uint8_t
name|rev
parameter_list|)
block|{
name|struct
name|bwi_mac
modifier|*
name|mac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_nmac
operator|<=
name|BWI_MAC_MAX
operator|&&
name|sc
operator|->
name|sc_nmac
operator|>=
literal|0
argument_list|,
operator|(
literal|"sc_nmac %d"
operator|,
name|sc
operator|->
name|sc_nmac
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nmac
operator|==
name|BWI_MAC_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"too many MACs\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * More than one MAC is only supported by BCM4309 	 */
if|if
condition|(
name|sc
operator|->
name|sc_nmac
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|sc_pci_did
operator|!=
name|PCI_PRODUCT_BROADCOM_BCM4309
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_ATTACH
argument_list|,
literal|"%s\n"
argument_list|,
literal|"ignore second MAC"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mac
operator|=
operator|&
name|sc
operator|->
name|sc_mac
index|[
name|sc
operator|->
name|sc_nmac
index|]
expr_stmt|;
comment|/* XXX will this happen? */
if|if
condition|(
name|BWI_REGWIN_EXIST
argument_list|(
operator|&
name|mac
operator|->
name|mac_regwin
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%dth MAC already attached\n"
argument_list|,
name|sc
operator|->
name|sc_nmac
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Test whether the revision of this MAC is supported 	 */
define|#
directive|define
name|N
parameter_list|(
name|arr
parameter_list|)
value|(int)(sizeof(arr) / sizeof(arr[0]))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|bwi_sup_macrev
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bwi_sup_macrev
index|[
name|i
index|]
operator|==
name|rev
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|N
argument_list|(
name|bwi_sup_macrev
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC rev %u is "
literal|"not supported\n"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
undef|#
directive|undef
name|N
name|BWI_CREATE_MAC
argument_list|(
name|mac
argument_list|,
name|sc
argument_list|,
name|id
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nmac
operator|++
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|<
literal|5
condition|)
block|{
name|mac
operator|->
name|mac_flags
operator||=
name|BWI_MAC_F_HAS_TXSTATS
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_ATTACH
argument_list|,
literal|"%s\n"
argument_list|,
literal|"has TX stats"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|mac_flags
operator||=
name|BWI_MAC_F_PHYE_RESET
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC: rev %u\n"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|bwi_mac_balance_atten
parameter_list|(
name|int
modifier|*
name|bbp_atten0
parameter_list|,
name|int
modifier|*
name|rf_atten0
parameter_list|)
block|{
name|int
name|bbp_atten
decl_stmt|,
name|rf_atten
decl_stmt|,
name|rf_atten_lim
init|=
operator|-
literal|1
decl_stmt|;
name|bbp_atten
operator|=
operator|*
name|bbp_atten0
expr_stmt|;
name|rf_atten
operator|=
operator|*
name|rf_atten0
expr_stmt|;
comment|/* 	 * RF attenuation affects TX power BWI_RF_ATTEN_FACTOR times 	 * as much as BBP attenuation, so we try our best to keep RF 	 * attenuation within range.  BBP attenuation will be clamped 	 * later if it is out of range during balancing. 	 * 	 * BWI_RF_ATTEN_MAX0 is used as RF attenuation upper limit. 	 */
comment|/* 	 * Use BBP attenuation to balance RF attenuation 	 */
if|if
condition|(
name|rf_atten
operator|<
literal|0
condition|)
name|rf_atten_lim
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rf_atten
operator|>
name|BWI_RF_ATTEN_MAX0
condition|)
name|rf_atten_lim
operator|=
name|BWI_RF_ATTEN_MAX0
expr_stmt|;
if|if
condition|(
name|rf_atten_lim
operator|>=
literal|0
condition|)
block|{
name|bbp_atten
operator|+=
operator|(
name|BWI_RF_ATTEN_FACTOR
operator|*
operator|(
name|rf_atten
operator|-
name|rf_atten_lim
operator|)
operator|)
expr_stmt|;
name|rf_atten
operator|=
name|rf_atten_lim
expr_stmt|;
block|}
comment|/* 	 * If possible, use RF attenuation to balance BBP attenuation 	 * NOTE: RF attenuation is still kept within range. 	 */
while|while
condition|(
name|rf_atten
operator|<
name|BWI_RF_ATTEN_MAX0
operator|&&
name|bbp_atten
operator|>
name|BWI_BBP_ATTEN_MAX
condition|)
block|{
name|bbp_atten
operator|-=
name|BWI_RF_ATTEN_FACTOR
expr_stmt|;
operator|++
name|rf_atten
expr_stmt|;
block|}
while|while
condition|(
name|rf_atten
operator|>
literal|0
operator|&&
name|bbp_atten
operator|<
literal|0
condition|)
block|{
name|bbp_atten
operator|+=
name|BWI_RF_ATTEN_FACTOR
expr_stmt|;
operator|--
name|rf_atten
expr_stmt|;
block|}
comment|/* RF attenuation MUST be within range */
name|KASSERT
argument_list|(
name|rf_atten
operator|>=
literal|0
operator|&&
name|rf_atten
operator|<=
name|BWI_RF_ATTEN_MAX0
argument_list|,
operator|(
literal|"rf_atten %d"
operator|,
name|rf_atten
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clamp BBP attenuation 	 */
if|if
condition|(
name|bbp_atten
operator|<
literal|0
condition|)
name|bbp_atten
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|bbp_atten
operator|>
name|BWI_BBP_ATTEN_MAX
condition|)
name|bbp_atten
operator|=
name|BWI_BBP_ATTEN_MAX
expr_stmt|;
operator|*
name|rf_atten0
operator|=
name|rf_atten
expr_stmt|;
operator|*
name|bbp_atten0
operator|=
name|bbp_atten
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_adjust_tpctl
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|int
name|rf_atten_adj
parameter_list|,
name|int
name|bbp_atten_adj
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_rf
modifier|*
name|rf
init|=
operator|&
name|mac
operator|->
name|mac_rf
decl_stmt|;
name|struct
name|bwi_tpctl
name|tpctl
decl_stmt|;
name|int
name|bbp_atten
decl_stmt|,
name|rf_atten
decl_stmt|,
name|tp_ctrl1
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|mac
operator|->
name|mac_tpctl
argument_list|,
operator|&
name|tpctl
argument_list|,
sizeof|sizeof
argument_list|(
name|tpctl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: Use signed value to do calulation */
name|bbp_atten
operator|=
name|tpctl
operator|.
name|bbp_atten
expr_stmt|;
name|rf_atten
operator|=
name|tpctl
operator|.
name|rf_atten
expr_stmt|;
name|tp_ctrl1
operator|=
name|tpctl
operator|.
name|tp_ctrl1
expr_stmt|;
name|bbp_atten
operator|+=
name|bbp_atten_adj
expr_stmt|;
name|rf_atten
operator|+=
name|rf_atten_adj
expr_stmt|;
name|bwi_mac_balance_atten
argument_list|(
operator|&
name|bbp_atten
argument_list|,
operator|&
name|rf_atten
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|rf_type
operator|==
name|BWI_RF_T_BCM2050
operator|&&
name|rf
operator|->
name|rf_rev
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|rf_atten
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|tp_ctrl1
operator|==
literal|0
condition|)
block|{
name|tp_ctrl1
operator|=
literal|3
expr_stmt|;
name|bbp_atten
operator|+=
literal|2
expr_stmt|;
name|rf_atten
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_card_flags
operator|&
name|BWI_CARD_F_PA_GPIO9
condition|)
block|{
name|bbp_atten
operator|+=
operator|(
name|BWI_RF_ATTEN_FACTOR
operator|*
operator|(
name|rf_atten
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
name|rf_atten
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rf_atten
operator|>
literal|4
operator|&&
name|tp_ctrl1
operator|!=
literal|0
condition|)
block|{
name|tp_ctrl1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bbp_atten
operator|<
literal|3
condition|)
block|{
name|bbp_atten
operator|+=
literal|2
expr_stmt|;
name|rf_atten
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|bbp_atten
operator|-=
literal|2
expr_stmt|;
name|rf_atten
operator|-=
literal|2
expr_stmt|;
block|}
block|}
name|bwi_mac_balance_atten
argument_list|(
operator|&
name|bbp_atten
argument_list|,
operator|&
name|rf_atten
argument_list|)
expr_stmt|;
block|}
name|tpctl
operator|.
name|bbp_atten
operator|=
name|bbp_atten
expr_stmt|;
name|tpctl
operator|.
name|rf_atten
operator|=
name|rf_atten
expr_stmt|;
name|tpctl
operator|.
name|tp_ctrl1
operator|=
name|tp_ctrl1
expr_stmt|;
name|bwi_mac_lock
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|bwi_mac_set_tpctl_11bg
argument_list|(
name|mac
argument_list|,
operator|&
name|tpctl
argument_list|)
expr_stmt|;
name|bwi_mac_unlock
argument_list|(
name|mac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * http://bcm-specs.sipsolutions.net/RecalculateTransmissionPower  */
end_comment

begin_function
name|void
name|bwi_mac_calibrate_txpower
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|enum
name|bwi_txpwrcb_type
name|type
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|bwi_rf
modifier|*
name|rf
init|=
operator|&
name|mac
operator|->
name|mac_rf
decl_stmt|;
name|int8_t
name|tssi
index|[
literal|4
index|]
decl_stmt|,
name|tssi_avg
decl_stmt|,
name|cur_txpwr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|ofdm_tssi
decl_stmt|;
name|int
name|txpwr_diff
decl_stmt|,
name|rf_atten_adj
decl_stmt|,
name|bbp_atten_adj
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_txpwr_calib
condition|)
return|return;
if|if
condition|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_TPCTL_ERROR
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"%s\n"
argument_list|,
literal|"tpctl error happened, can't set txpower"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|BWI_IS_BRCM_BU4306
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"%s\n"
argument_list|,
literal|"BU4306, can't set txpower"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Save latest TSSI and reset the related memory objects 	 */
name|ofdm_tssi
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bwi_rf_get_latest_tssi
argument_list|(
name|mac
argument_list|,
name|tssi
argument_list|,
name|BWI_COMM_MOBJ_TSSI_DS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"%s\n"
argument_list|,
literal|"no DS tssi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_phy
operator|.
name|phy_mode
operator|==
name|IEEE80211_MODE_11B
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BWI_TXPWR_FORCE
condition|)
block|{
name|rf_atten_adj
operator|=
literal|0
expr_stmt|;
name|bbp_atten_adj
operator|=
literal|1
expr_stmt|;
goto|goto
name|calib
goto|;
block|}
else|else
block|{
return|return;
block|}
block|}
name|error
operator|=
name|bwi_rf_get_latest_tssi
argument_list|(
name|mac
argument_list|,
name|tssi
argument_list|,
name|BWI_COMM_MOBJ_TSSI_OFDM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"%s\n"
argument_list|,
literal|"no OFDM tssi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|BWI_TXPWR_FORCE
condition|)
block|{
name|rf_atten_adj
operator|=
literal|0
expr_stmt|;
name|bbp_atten_adj
operator|=
literal|1
expr_stmt|;
goto|goto
name|calib
goto|;
block|}
else|else
block|{
return|return;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|tssi
index|[
name|i
index|]
operator|+=
literal|0x20
expr_stmt|;
name|tssi
index|[
name|i
index|]
operator|&=
literal|0x3f
expr_stmt|;
block|}
name|ofdm_tssi
operator|=
literal|1
expr_stmt|;
block|}
name|bwi_rf_clear_tssi
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"tssi0 %d, tssi1 %d, tssi2 %d, tssi3 %d\n"
argument_list|,
name|tssi
index|[
literal|0
index|]
argument_list|,
name|tssi
index|[
literal|1
index|]
argument_list|,
name|tssi
index|[
literal|2
index|]
argument_list|,
name|tssi
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate RF/BBP attenuation adjustment based on 	 * the difference between desired TX power and sampled 	 * TX power. 	 */
comment|/* +8 == "each incremented by 1/2" */
name|tssi_avg
operator|=
operator|(
name|tssi
index|[
literal|0
index|]
operator|+
name|tssi
index|[
literal|1
index|]
operator|+
name|tssi
index|[
literal|2
index|]
operator|+
name|tssi
index|[
literal|3
index|]
operator|+
literal|8
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|ofdm_tssi
operator|&&
operator|(
name|HFLAGS_READ
argument_list|(
name|mac
argument_list|)
operator|&
name|BWI_HFLAG_PWR_BOOST_DS
operator|)
condition|)
name|tssi_avg
operator|-=
literal|13
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"tssi avg %d\n"
argument_list|,
name|tssi_avg
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwi_rf_tssi2dbm
argument_list|(
name|mac
argument_list|,
name|tssi_avg
argument_list|,
operator|&
name|cur_txpwr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"current txpower %d\n"
argument_list|,
name|cur_txpwr
argument_list|)
expr_stmt|;
name|txpwr_diff
operator|=
name|rf
operator|->
name|rf_txpower_max
operator|-
name|cur_txpwr
expr_stmt|;
comment|/* XXX ni_txpower */
name|rf_atten_adj
operator|=
operator|-
name|howmany
argument_list|(
name|txpwr_diff
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|BWI_TXPWR_INIT
condition|)
block|{
comment|/* 		 * Move toward EEPROM max TX power as fast as we can 		 */
name|bbp_atten_adj
operator|=
operator|-
name|txpwr_diff
expr_stmt|;
block|}
else|else
block|{
name|bbp_atten_adj
operator|=
operator|-
operator|(
name|txpwr_diff
operator|/
literal|2
operator|)
expr_stmt|;
block|}
name|bbp_atten_adj
operator|-=
operator|(
name|BWI_RF_ATTEN_FACTOR
operator|*
name|rf_atten_adj
operator|)
expr_stmt|;
if|if
condition|(
name|rf_atten_adj
operator|==
literal|0
operator|&&
name|bbp_atten_adj
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"%s\n"
argument_list|,
literal|"no need to adjust RF/BBP attenuation"
argument_list|)
expr_stmt|;
comment|/* TODO: LO */
return|return;
block|}
name|calib
label|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|BWI_DBG_MAC
operator||
name|BWI_DBG_TXPOWER
argument_list|,
literal|"rf atten adjust %d, bbp atten adjust %d\n"
argument_list|,
name|rf_atten_adj
argument_list|,
name|bbp_atten_adj
argument_list|)
expr_stmt|;
name|bwi_mac_adjust_tpctl
argument_list|(
name|mac
argument_list|,
name|rf_atten_adj
argument_list|,
name|bbp_atten_adj
argument_list|)
expr_stmt|;
comment|/* TODO: LO */
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_lock
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_LOCKED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"mac_flags 0x%x"
operator|,
name|mac
operator|->
name|mac_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|<
literal|3
condition|)
name|bwi_mac_stop
argument_list|(
name|mac
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
condition|)
name|bwi_mac_config_ps
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_RFLOCK
argument_list|)
expr_stmt|;
comment|/* Flush pending bus write */
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_flags
operator||=
name|BWI_MAC_F_LOCKED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bwi_mac_unlock
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|KASSERT
argument_list|(
name|mac
operator|->
name|mac_flags
operator|&
name|BWI_MAC_F_LOCKED
argument_list|,
operator|(
literal|"mac_flags 0x%x"
operator|,
name|mac
operator|->
name|mac_flags
operator|)
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BWI_PHYINFO
argument_list|)
expr_stmt|;
comment|/* dummy read */
name|CSR_CLRBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_RFLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|<
literal|3
condition|)
name|bwi_mac_start
argument_list|(
name|mac
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
condition|)
name|bwi_mac_config_ps
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_flags
operator|&=
operator|~
name|BWI_MAC_F_LOCKED
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bwi_mac_set_promisc
parameter_list|(
name|struct
name|bwi_mac
modifier|*
name|mac
parameter_list|,
name|int
name|promisc
parameter_list|)
block|{
name|struct
name|bwi_softc
modifier|*
name|sc
init|=
name|mac
operator|->
name|mac_sc
decl_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_rev
operator|<
literal|5
condition|)
comment|/* Promisc is always on */
return|return;
if|if
condition|(
name|promisc
condition|)
name|CSR_SETBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_PROMISC
argument_list|)
expr_stmt|;
else|else
name|CSR_CLRBITS_4
argument_list|(
name|sc
argument_list|,
name|BWI_MAC_STATUS
argument_list|,
name|BWI_MAC_STATUS_PROMISC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

