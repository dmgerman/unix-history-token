begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* via_dma.c -- DMA support for the VIA Unichrome/Pro  *  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.  * All Rights Reserved.  *  * Copyright 2004 Digeo, Inc., Palo Alto, CA, U.S.A.  * All Rights Reserved.  *  * Copyright 2004 The Unichrome project.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sub license,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  * USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Tungsten Graphics,  *    Erdi Chen,  *    Thomas Hellstrom.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/via_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/via_drv.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/via_3d_reg.h"
end_include

begin_define
define|#
directive|define
name|CMDBUF_ALIGNMENT_SIZE
value|(0x100)
end_define

begin_define
define|#
directive|define
name|CMDBUF_ALIGNMENT_MASK
value|(0x0ff)
end_define

begin_comment
comment|/* defines for VIA 3D registers */
end_comment

begin_define
define|#
directive|define
name|VIA_REG_STATUS
value|0x400
end_define

begin_define
define|#
directive|define
name|VIA_REG_TRANSET
value|0x43C
end_define

begin_define
define|#
directive|define
name|VIA_REG_TRANSPACE
value|0x440
end_define

begin_comment
comment|/* VIA_REG_STATUS(0x400): Engine Status */
end_comment

begin_define
define|#
directive|define
name|VIA_CMD_RGTR_BUSY
value|0x00000080
end_define

begin_comment
comment|/* Command Regulator is busy */
end_comment

begin_define
define|#
directive|define
name|VIA_2D_ENG_BUSY
value|0x00000001
end_define

begin_comment
comment|/* 2D Engine is busy */
end_comment

begin_define
define|#
directive|define
name|VIA_3D_ENG_BUSY
value|0x00000002
end_define

begin_comment
comment|/* 3D Engine is busy */
end_comment

begin_define
define|#
directive|define
name|VIA_VR_QUEUE_BUSY
value|0x00020000
end_define

begin_comment
comment|/* Virtual Queue is busy */
end_comment

begin_define
define|#
directive|define
name|SetReg2DAGP
parameter_list|(
name|nReg
parameter_list|,
name|nData
parameter_list|)
value|{				\ 	*((uint32_t *)(vb)) = ((nReg)>> 2) | HALCYON_HEADER1;	\ 	*((uint32_t *)(vb) + 1) = (nData);			\ 	vb = ((uint32_t *)vb) + 2;				\ 	dev_priv->dma_low +=8;					\ }
end_define

begin_define
define|#
directive|define
name|via_flush_write_combine
parameter_list|()
value|DRM_MEMORYBARRIER()
end_define

begin_define
define|#
directive|define
name|VIA_OUT_RING_QW
parameter_list|(
name|w1
parameter_list|,
name|w2
parameter_list|)
define|\
value|*vb++ = (w1);				\ 	*vb++ = (w2);				\ 	dev_priv->dma_low += 8;
end_define

begin_function_decl
specifier|static
name|void
name|via_cmdbuf_start
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|via_cmdbuf_pause
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|via_cmdbuf_reset
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|via_cmdbuf_rewind
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|via_wait_idle
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|via_pad_cache
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|qwords
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Free space in command buffer.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|via_cmdbuf_space
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|uint32_t
name|agp_base
init|=
name|dev_priv
operator|->
name|dma_offset
operator|+
operator|(
name|uint32_t
operator|)
name|dev_priv
operator|->
name|agpAddr
decl_stmt|;
name|uint32_t
name|hw_addr
init|=
operator|*
operator|(
name|dev_priv
operator|->
name|hw_addr_ptr
operator|)
operator|-
name|agp_base
decl_stmt|;
return|return
operator|(
operator|(
name|hw_addr
operator|<=
name|dev_priv
operator|->
name|dma_low
operator|)
condition|?
operator|(
name|dev_priv
operator|->
name|dma_high
operator|+
name|hw_addr
operator|-
name|dev_priv
operator|->
name|dma_low
operator|)
else|:
operator|(
name|hw_addr
operator|-
name|dev_priv
operator|->
name|dma_low
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * How much does the command regulator lag behind?  */
end_comment

begin_function
specifier|static
name|uint32_t
name|via_cmdbuf_lag
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|uint32_t
name|agp_base
init|=
name|dev_priv
operator|->
name|dma_offset
operator|+
operator|(
name|uint32_t
operator|)
name|dev_priv
operator|->
name|agpAddr
decl_stmt|;
name|uint32_t
name|hw_addr
init|=
operator|*
operator|(
name|dev_priv
operator|->
name|hw_addr_ptr
operator|)
operator|-
name|agp_base
decl_stmt|;
return|return
operator|(
operator|(
name|hw_addr
operator|<=
name|dev_priv
operator|->
name|dma_low
operator|)
condition|?
operator|(
name|dev_priv
operator|->
name|dma_low
operator|-
name|hw_addr
operator|)
else|:
operator|(
name|dev_priv
operator|->
name|dma_wrap
operator|+
name|dev_priv
operator|->
name|dma_low
operator|-
name|hw_addr
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that the given size fits in the buffer, otherwise wait.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|via_cmdbuf_wait
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|uint32_t
name|agp_base
init|=
name|dev_priv
operator|->
name|dma_offset
operator|+
operator|(
name|uint32_t
operator|)
name|dev_priv
operator|->
name|agpAddr
decl_stmt|;
name|uint32_t
name|cur_addr
decl_stmt|,
name|hw_addr
decl_stmt|,
name|next_addr
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|hw_addr_ptr
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|hw_addr_ptr
operator|=
name|dev_priv
operator|->
name|hw_addr_ptr
expr_stmt|;
name|cur_addr
operator|=
name|dev_priv
operator|->
name|dma_low
expr_stmt|;
name|next_addr
operator|=
name|cur_addr
operator|+
name|size
operator|+
literal|512
operator|*
literal|1024
expr_stmt|;
name|count
operator|=
literal|1000000
expr_stmt|;
do|do
block|{
name|hw_addr
operator|=
operator|*
name|hw_addr_ptr
operator|-
name|agp_base
expr_stmt|;
if|if
condition|(
name|count
operator|--
operator|==
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"via_cmdbuf_wait timed out hw %x cur_addr %x next_addr %x\n"
argument_list|,
name|hw_addr
argument_list|,
name|cur_addr
argument_list|,
name|next_addr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|cur_addr
operator|<
name|hw_addr
operator|)
operator|&&
operator|(
name|next_addr
operator|>=
name|hw_addr
operator|)
condition|)
name|DRM_UDELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cur_addr
operator|<
name|hw_addr
operator|)
operator|&&
operator|(
name|next_addr
operator|>=
name|hw_addr
operator|)
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Checks whether buffer head has reach the end. Rewind the ring buffer  * when necessary.  *  * Returns virtual pointer to ring buffer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
modifier|*
name|via_check_dma
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|dma_low
operator|+
name|size
operator|+
literal|4
operator|*
name|CMDBUF_ALIGNMENT_SIZE
operator|)
operator|>
name|dev_priv
operator|->
name|dma_high
condition|)
block|{
name|via_cmdbuf_rewind
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|via_cmdbuf_wait
argument_list|(
name|dev_priv
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|dev_priv
operator|->
name|dma_ptr
operator|+
name|dev_priv
operator|->
name|dma_low
operator|)
return|;
block|}
end_function

begin_function
name|int
name|via_dma_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dev_private
condition|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
condition|)
block|{
name|via_cmdbuf_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|drm_core_ioremapfree
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
operator|.
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|via_initialize
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_via_dma_init_t
modifier|*
name|init
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dev_priv
operator|||
operator|!
name|dev_priv
operator|->
name|mmio
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"via_dma_init called before via_map_init\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
operator|!=
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called again without calling cleanup\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
if|if
condition|(
operator|!
name|dev
operator|->
name|agp
operator|||
operator|!
name|dev
operator|->
name|agp
operator|->
name|base
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no agp memory available\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|chipset
operator|==
name|VIA_DX9_0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"AGP DMA is not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|offset
operator|=
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|init
operator|->
name|offset
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|size
operator|=
name|init
operator|->
name|size
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|mtrr
operator|=
literal|0
expr_stmt|;
name|drm_core_ioremap_wc
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
operator|.
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|handle
operator|==
name|NULL
condition|)
block|{
name|via_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"can not ioremap virtual address for"
literal|" ring buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
operator|=
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|handle
expr_stmt|;
name|dev_priv
operator|->
name|dma_ptr
operator|=
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
expr_stmt|;
name|dev_priv
operator|->
name|dma_low
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|dma_high
operator|=
name|init
operator|->
name|size
expr_stmt|;
name|dev_priv
operator|->
name|dma_wrap
operator|=
name|init
operator|->
name|size
expr_stmt|;
name|dev_priv
operator|->
name|dma_offset
operator|=
name|init
operator|->
name|offset
expr_stmt|;
name|dev_priv
operator|->
name|last_pause_ptr
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|hw_addr_ptr
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dev_priv
operator|->
name|mmio
operator|->
name|handle
operator|+
name|init
operator|->
name|reg_pause_addr
operator|)
expr_stmt|;
name|via_cmdbuf_start
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|via_dma_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_via_dma_init_t
modifier|*
name|init
init|=
name|data
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|init
operator|->
name|func
condition|)
block|{
case|case
name|VIA_INIT_DMA
case|:
if|if
condition|(
operator|!
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
condition|)
name|retcode
operator|=
operator|-
name|EPERM
expr_stmt|;
else|else
name|retcode
operator|=
name|via_initialize
argument_list|(
name|dev
argument_list|,
name|dev_priv
argument_list|,
name|init
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIA_CLEANUP_DMA
case|:
if|if
condition|(
operator|!
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
condition|)
name|retcode
operator|=
operator|-
name|EPERM
expr_stmt|;
else|else
name|retcode
operator|=
name|via_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIA_DMA_INITIALIZED
case|:
name|retcode
operator|=
operator|(
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
operator|!=
name|NULL
operator|)
condition|?
literal|0
else|:
operator|-
name|EFAULT
expr_stmt|;
break|break;
default|default:
name|retcode
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|retcode
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|via_dispatch_cmdbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_via_cmdbuffer_t
modifier|*
name|cmd
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|uint32_t
modifier|*
name|vb
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev_priv
operator|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called without initializing AGP ring buffer.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
if|if
condition|(
name|cmd
operator|->
name|size
operator|>
name|VIA_PCI_BUF_SIZE
condition|)
block|{
return|return
operator|-
name|ENOMEM
return|;
block|}
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
name|dev_priv
operator|->
name|pci_buf
argument_list|,
name|cmd
operator|->
name|buf
argument_list|,
name|cmd
operator|->
name|size
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
comment|/* 	 * Running this function on AGP memory is dead slow. Therefore 	 * we run it on a temporary cacheable system memory buffer and 	 * copy it to AGP memory when ready. 	 */
if|if
condition|(
operator|(
name|ret
operator|=
name|via_verify_command_stream
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|pci_buf
argument_list|,
name|cmd
operator|->
name|size
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
return|return
name|ret
return|;
block|}
name|vb
operator|=
name|via_check_dma
argument_list|(
name|dev_priv
argument_list|,
operator|(
name|cmd
operator|->
name|size
operator|<
literal|0x100
operator|)
condition|?
literal|0x102
else|:
name|cmd
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|vb
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
name|EAGAIN
return|;
block|}
name|memcpy
argument_list|(
name|vb
argument_list|,
name|dev_priv
operator|->
name|pci_buf
argument_list|,
name|cmd
operator|->
name|size
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_low
operator|+=
name|cmd
operator|->
name|size
expr_stmt|;
comment|/* 	 * Small submissions somehow stalls the CPU. (AGP cache effects?) 	 * pad to greater size. 	 */
if|if
condition|(
name|cmd
operator|->
name|size
operator|<
literal|0x100
condition|)
name|via_pad_cache
argument_list|(
name|dev_priv
argument_list|,
operator|(
literal|0x100
operator|-
name|cmd
operator|->
name|size
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|via_cmdbuf_pause
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|via_driver_dma_quiescent
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|via_wait_idle
argument_list|(
name|dev_priv
argument_list|)
condition|)
block|{
return|return
operator|-
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|via_flush_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
return|return
name|via_driver_dma_quiescent
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|via_cmdbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_via_cmdbuffer_t
modifier|*
name|cmdbuf
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"buf %p size %lu\n"
argument_list|,
name|cmdbuf
operator|->
name|buf
argument_list|,
name|cmdbuf
operator|->
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|via_dispatch_cmdbuffer
argument_list|(
name|dev
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|via_dispatch_pci_cmdbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_via_cmdbuffer_t
modifier|*
name|cmd
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|size
operator|>
name|VIA_PCI_BUF_SIZE
condition|)
block|{
return|return
operator|-
name|ENOMEM
return|;
block|}
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
name|dev_priv
operator|->
name|pci_buf
argument_list|,
name|cmd
operator|->
name|buf
argument_list|,
name|cmd
operator|->
name|size
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|via_verify_command_stream
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|pci_buf
argument_list|,
name|cmd
operator|->
name|size
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|via_parse_command_stream
argument_list|(
name|dev
argument_list|,
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|pci_buf
argument_list|,
name|cmd
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|via_pci_cmdbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_via_cmdbuffer_t
modifier|*
name|cmdbuf
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"buf %p size %lu\n"
argument_list|,
name|cmdbuf
operator|->
name|buf
argument_list|,
name|cmdbuf
operator|->
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|via_dispatch_pci_cmdbuffer
argument_list|(
name|dev
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
modifier|*
name|via_align_buffer
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|uint32_t
modifier|*
name|vb
parameter_list|,
name|int
name|qw_count
parameter_list|)
block|{
for|for
control|(
init|;
name|qw_count
operator|>
literal|0
condition|;
operator|--
name|qw_count
control|)
block|{
name|VIA_OUT_RING_QW
argument_list|(
name|HC_DUMMY
argument_list|,
name|HC_DUMMY
argument_list|)
expr_stmt|;
block|}
return|return
name|vb
return|;
block|}
end_function

begin_comment
comment|/*  * This function is used internally by ring buffer management code.  *  * Returns virtual pointer to ring buffer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
modifier|*
name|via_get_dma
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
return|return
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|dev_priv
operator|->
name|dma_ptr
operator|+
name|dev_priv
operator|->
name|dma_low
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hooks a segment of data into the tail of the ring-buffer by  * modifying the pause address stored in the buffer itself. If  * the regulator has already paused, restart it.  */
end_comment

begin_function
specifier|static
name|int
name|via_hook_segment
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|uint32_t
name|pause_addr_hi
parameter_list|,
name|uint32_t
name|pause_addr_lo
parameter_list|,
name|int
name|no_pci_fire
parameter_list|)
block|{
name|int
name|paused
decl_stmt|,
name|count
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|paused_at
init|=
name|dev_priv
operator|->
name|last_pause_ptr
decl_stmt|;
name|uint32_t
name|reader
decl_stmt|,
name|ptr
decl_stmt|;
name|uint32_t
name|diff
decl_stmt|;
name|paused
operator|=
literal|0
expr_stmt|;
name|via_flush_write_combine
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|via_get_dma
argument_list|(
name|dev_priv
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|paused_at
operator|=
name|pause_addr_lo
expr_stmt|;
name|via_flush_write_combine
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
operator|*
name|paused_at
expr_stmt|;
name|reader
operator|=
operator|*
operator|(
name|dev_priv
operator|->
name|hw_addr_ptr
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|paused_at
operator|-
name|dev_priv
operator|->
name|dma_ptr
operator|)
operator|+
name|dev_priv
operator|->
name|dma_offset
operator|+
operator|(
name|uint32_t
operator|)
name|dev_priv
operator|->
name|agpAddr
operator|+
literal|4
expr_stmt|;
name|dev_priv
operator|->
name|last_pause_ptr
operator|=
name|via_get_dma
argument_list|(
name|dev_priv
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If there is a possibility that the command reader will 	 * miss the new pause address and pause on the old one, 	 * In that case we need to program the new start address 	 * using PCI. 	 */
name|diff
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ptr
operator|-
name|reader
argument_list|)
operator|-
name|dev_priv
operator|->
name|dma_diff
expr_stmt|;
name|count
operator|=
literal|10000000
expr_stmt|;
while|while
condition|(
name|diff
operator|==
literal|0
operator|&&
name|count
operator|--
condition|)
block|{
name|paused
operator|=
operator|(
name|VIA_READ
argument_list|(
literal|0x41c
argument_list|)
operator|&
literal|0x80000000
operator|)
expr_stmt|;
if|if
condition|(
name|paused
condition|)
break|break;
name|reader
operator|=
operator|*
operator|(
name|dev_priv
operator|->
name|hw_addr_ptr
operator|)
expr_stmt|;
name|diff
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ptr
operator|-
name|reader
argument_list|)
operator|-
name|dev_priv
operator|->
name|dma_diff
expr_stmt|;
block|}
name|paused
operator|=
name|VIA_READ
argument_list|(
literal|0x41c
argument_list|)
operator|&
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|paused
operator|&&
operator|!
name|no_pci_fire
condition|)
block|{
name|reader
operator|=
operator|*
operator|(
name|dev_priv
operator|->
name|hw_addr_ptr
operator|)
expr_stmt|;
name|diff
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ptr
operator|-
name|reader
argument_list|)
operator|-
name|dev_priv
operator|->
name|dma_diff
expr_stmt|;
name|diff
operator|&=
operator|(
name|dev_priv
operator|->
name|dma_high
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
operator|&&
name|diff
operator|<
operator|(
name|dev_priv
operator|->
name|dma_high
operator|>>
literal|1
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Paused at incorrect address. "
literal|"0x%08x, 0x%08x 0x%08x\n"
argument_list|,
name|ptr
argument_list|,
name|reader
argument_list|,
name|dev_priv
operator|->
name|dma_diff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
comment|/* 			 * There is a concern that these writes may stall the PCI bus 			 * if the GPU is not idle. However, idling the GPU first 			 * doesn't make a difference. 			 */
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSET
argument_list|,
operator|(
name|HC_ParaType_PreCR
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|,
name|pause_addr_hi
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|,
name|pause_addr_lo
argument_list|)
expr_stmt|;
name|VIA_READ
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|paused
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|via_wait_idle
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|int
name|count
init|=
literal|10000000
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|VIA_READ
argument_list|(
name|VIA_REG_STATUS
argument_list|)
operator|&
name|VIA_VR_QUEUE_BUSY
operator|)
operator|&&
operator|--
name|count
condition|)
empty_stmt|;
while|while
condition|(
name|count
operator|&&
operator|(
name|VIA_READ
argument_list|(
name|VIA_REG_STATUS
argument_list|)
operator|&
operator|(
name|VIA_CMD_RGTR_BUSY
operator||
name|VIA_2D_ENG_BUSY
operator||
name|VIA_3D_ENG_BUSY
operator|)
operator|)
condition|)
operator|--
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
modifier|*
name|via_align_cmd
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|uint32_t
name|cmd_type
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|cmd_addr_hi
parameter_list|,
name|uint32_t
modifier|*
name|cmd_addr_lo
parameter_list|,
name|int
name|skip_wait
parameter_list|)
block|{
name|uint32_t
name|agp_base
decl_stmt|;
name|uint32_t
name|cmd_addr
decl_stmt|,
name|addr_lo
decl_stmt|,
name|addr_hi
decl_stmt|;
name|uint32_t
modifier|*
name|vb
decl_stmt|;
name|uint32_t
name|qw_pad_count
decl_stmt|;
if|if
condition|(
operator|!
name|skip_wait
condition|)
name|via_cmdbuf_wait
argument_list|(
name|dev_priv
argument_list|,
literal|2
operator|*
name|CMDBUF_ALIGNMENT_SIZE
argument_list|)
expr_stmt|;
name|vb
operator|=
name|via_get_dma
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|VIA_OUT_RING_QW
argument_list|(
name|HC_HEADER2
operator||
operator|(
operator|(
name|VIA_REG_TRANSET
operator|>>
literal|2
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
name|VIA_REG_TRANSPACE
operator|>>
literal|2
operator|)
argument_list|,
name|HC_ParaType_PreCR
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|agp_base
operator|=
name|dev_priv
operator|->
name|dma_offset
operator|+
operator|(
name|uint32_t
operator|)
name|dev_priv
operator|->
name|agpAddr
expr_stmt|;
name|qw_pad_count
operator|=
operator|(
name|CMDBUF_ALIGNMENT_SIZE
operator|>>
literal|3
operator|)
operator|-
operator|(
operator|(
name|dev_priv
operator|->
name|dma_low
operator|&
name|CMDBUF_ALIGNMENT_MASK
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|cmd_addr
operator|=
operator|(
name|addr
operator|)
condition|?
name|addr
else|:
name|agp_base
operator|+
name|dev_priv
operator|->
name|dma_low
operator|-
literal|8
operator|+
operator|(
name|qw_pad_count
operator|<<
literal|3
operator|)
expr_stmt|;
name|addr_lo
operator|=
operator|(
operator|(
name|HC_SubA_HAGPBpL
operator|<<
literal|24
operator|)
operator||
operator|(
name|cmd_type
operator|&
name|HC_HAGPBpID_MASK
operator|)
operator||
operator|(
name|cmd_addr
operator|&
name|HC_HAGPBpL_MASK
operator|)
operator|)
expr_stmt|;
name|addr_hi
operator|=
operator|(
operator|(
name|HC_SubA_HAGPBpH
operator|<<
literal|24
operator|)
operator||
operator|(
name|cmd_addr
operator|>>
literal|24
operator|)
operator|)
expr_stmt|;
name|vb
operator|=
name|via_align_buffer
argument_list|(
name|dev_priv
argument_list|,
name|vb
argument_list|,
name|qw_pad_count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VIA_OUT_RING_QW
argument_list|(
operator|*
name|cmd_addr_hi
operator|=
name|addr_hi
argument_list|,
operator|*
name|cmd_addr_lo
operator|=
name|addr_lo
argument_list|)
expr_stmt|;
return|return
name|vb
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_cmdbuf_start
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|uint32_t
name|pause_addr_lo
decl_stmt|,
name|pause_addr_hi
decl_stmt|;
name|uint32_t
name|start_addr
decl_stmt|,
name|start_addr_lo
decl_stmt|;
name|uint32_t
name|end_addr
decl_stmt|,
name|end_addr_lo
decl_stmt|;
name|uint32_t
name|command
decl_stmt|;
name|uint32_t
name|agp_base
decl_stmt|;
name|uint32_t
name|ptr
decl_stmt|;
name|uint32_t
name|reader
decl_stmt|;
name|int
name|count
decl_stmt|;
name|dev_priv
operator|->
name|dma_low
operator|=
literal|0
expr_stmt|;
name|agp_base
operator|=
name|dev_priv
operator|->
name|dma_offset
operator|+
operator|(
name|uint32_t
operator|)
name|dev_priv
operator|->
name|agpAddr
expr_stmt|;
name|start_addr
operator|=
name|agp_base
expr_stmt|;
name|end_addr
operator|=
name|agp_base
operator|+
name|dev_priv
operator|->
name|dma_high
expr_stmt|;
name|start_addr_lo
operator|=
operator|(
operator|(
name|HC_SubA_HAGPBstL
operator|<<
literal|24
operator|)
operator||
operator|(
name|start_addr
operator|&
literal|0xFFFFFF
operator|)
operator|)
expr_stmt|;
name|end_addr_lo
operator|=
operator|(
operator|(
name|HC_SubA_HAGPBendL
operator|<<
literal|24
operator|)
operator||
operator|(
name|end_addr
operator|&
literal|0xFFFFFF
operator|)
operator|)
expr_stmt|;
name|command
operator|=
operator|(
operator|(
name|HC_SubA_HAGPCMNT
operator|<<
literal|24
operator|)
operator||
operator|(
name|start_addr
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|end_addr
operator|&
literal|0xff000000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|last_pause_ptr
operator|=
name|via_align_cmd
argument_list|(
name|dev_priv
argument_list|,
name|HC_HAGPBpID_PAUSE
argument_list|,
literal|0
argument_list|,
operator|&
name|pause_addr_hi
argument_list|,
operator|&
name|pause_addr_lo
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|via_flush_write_combine
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|last_pause_ptr
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSET
argument_list|,
operator|(
name|HC_ParaType_PreCR
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|,
name|start_addr_lo
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|,
name|end_addr_lo
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|,
name|pause_addr_hi
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|,
name|pause_addr_lo
argument_list|)
expr_stmt|;
name|DRM_WRITEMEMORYBARRIER
argument_list|()
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|,
name|command
operator||
name|HC_HAGPCMNT_MASK
argument_list|)
expr_stmt|;
name|VIA_READ
argument_list|(
name|VIA_REG_TRANSPACE
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_diff
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|10000000
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|VIA_READ
argument_list|(
literal|0x41c
argument_list|)
operator|&
literal|0x80000000
operator|)
operator|&&
name|count
operator|--
condition|)
empty_stmt|;
name|reader
operator|=
operator|*
operator|(
name|dev_priv
operator|->
name|hw_addr_ptr
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|dev_priv
operator|->
name|last_pause_ptr
operator|-
name|dev_priv
operator|->
name|dma_ptr
operator|)
operator|+
name|dev_priv
operator|->
name|dma_offset
operator|+
operator|(
name|uint32_t
operator|)
name|dev_priv
operator|->
name|agpAddr
operator|+
literal|4
expr_stmt|;
comment|/* 	 * This is the difference between where we tell the 	 * command reader to pause and where it actually pauses. 	 * This differs between hw implementation so we need to 	 * detect it. 	 */
name|dev_priv
operator|->
name|dma_diff
operator|=
name|ptr
operator|-
name|reader
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_pad_cache
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|qwords
parameter_list|)
block|{
name|uint32_t
modifier|*
name|vb
decl_stmt|;
name|via_cmdbuf_wait
argument_list|(
name|dev_priv
argument_list|,
name|qwords
operator|+
literal|2
argument_list|)
expr_stmt|;
name|vb
operator|=
name|via_get_dma
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|VIA_OUT_RING_QW
argument_list|(
name|HC_HEADER2
argument_list|,
name|HC_ParaType_NotTex
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|via_align_buffer
argument_list|(
name|dev_priv
argument_list|,
name|vb
argument_list|,
name|qwords
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|via_dummy_bitblt
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|uint32_t
modifier|*
name|vb
init|=
name|via_get_dma
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
name|SetReg2DAGP
argument_list|(
literal|0x0C
argument_list|,
operator|(
literal|0
operator||
operator|(
literal|0
operator|<<
literal|16
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SetReg2DAGP
argument_list|(
literal|0x10
argument_list|,
literal|0
operator||
operator|(
literal|0
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|SetReg2DAGP
argument_list|(
literal|0x0
argument_list|,
literal|0x1
operator||
literal|0x2000
operator||
literal|0xAA000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_cmdbuf_jump
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|uint32_t
name|agp_base
decl_stmt|;
name|uint32_t
name|pause_addr_lo
decl_stmt|,
name|pause_addr_hi
decl_stmt|;
name|uint32_t
name|jump_addr_lo
decl_stmt|,
name|jump_addr_hi
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|last_pause_ptr
decl_stmt|;
name|uint32_t
name|dma_low_save1
decl_stmt|,
name|dma_low_save2
decl_stmt|;
name|agp_base
operator|=
name|dev_priv
operator|->
name|dma_offset
operator|+
operator|(
name|uint32_t
operator|)
name|dev_priv
operator|->
name|agpAddr
expr_stmt|;
name|via_align_cmd
argument_list|(
name|dev_priv
argument_list|,
name|HC_HAGPBpID_JUMP
argument_list|,
literal|0
argument_list|,
operator|&
name|jump_addr_hi
argument_list|,
operator|&
name|jump_addr_lo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_wrap
operator|=
name|dev_priv
operator|->
name|dma_low
expr_stmt|;
comment|/* 	 * Wrap command buffer to the beginning. 	 */
name|dev_priv
operator|->
name|dma_low
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|via_cmdbuf_wait
argument_list|(
name|dev_priv
argument_list|,
name|CMDBUF_ALIGNMENT_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"via_cmdbuf_jump failed\n"
argument_list|)
expr_stmt|;
block|}
name|via_dummy_bitblt
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|via_dummy_bitblt
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|last_pause_ptr
operator|=
name|via_align_cmd
argument_list|(
name|dev_priv
argument_list|,
name|HC_HAGPBpID_PAUSE
argument_list|,
literal|0
argument_list|,
operator|&
name|pause_addr_hi
argument_list|,
operator|&
name|pause_addr_lo
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|via_align_cmd
argument_list|(
name|dev_priv
argument_list|,
name|HC_HAGPBpID_PAUSE
argument_list|,
literal|0
argument_list|,
operator|&
name|pause_addr_hi
argument_list|,
operator|&
name|pause_addr_lo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|last_pause_ptr
operator|=
name|pause_addr_lo
expr_stmt|;
name|dma_low_save1
operator|=
name|dev_priv
operator|->
name|dma_low
expr_stmt|;
comment|/* 	 * Now, set a trap that will pause the regulator if it tries to rerun the old 	 * command buffer. (Which may happen if via_hook_segment detecs a command regulator pause 	 * and reissues the jump command over PCI, while the regulator has already taken the jump 	 * and actually paused at the current buffer end). 	 * There appears to be no other way to detect this condition, since the hw_addr_pointer 	 * does not seem to get updated immediately when a jump occurs. 	 */
name|last_pause_ptr
operator|=
name|via_align_cmd
argument_list|(
name|dev_priv
argument_list|,
name|HC_HAGPBpID_PAUSE
argument_list|,
literal|0
argument_list|,
operator|&
name|pause_addr_hi
argument_list|,
operator|&
name|pause_addr_lo
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|via_align_cmd
argument_list|(
name|dev_priv
argument_list|,
name|HC_HAGPBpID_PAUSE
argument_list|,
literal|0
argument_list|,
operator|&
name|pause_addr_hi
argument_list|,
operator|&
name|pause_addr_lo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|last_pause_ptr
operator|=
name|pause_addr_lo
expr_stmt|;
name|dma_low_save2
operator|=
name|dev_priv
operator|->
name|dma_low
expr_stmt|;
name|dev_priv
operator|->
name|dma_low
operator|=
name|dma_low_save1
expr_stmt|;
name|via_hook_segment
argument_list|(
name|dev_priv
argument_list|,
name|jump_addr_hi
argument_list|,
name|jump_addr_lo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_low
operator|=
name|dma_low_save2
expr_stmt|;
name|via_hook_segment
argument_list|(
name|dev_priv
argument_list|,
name|pause_addr_hi
argument_list|,
name|pause_addr_lo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_cmdbuf_rewind
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|via_cmdbuf_jump
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_cmdbuf_flush
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|,
name|uint32_t
name|cmd_type
parameter_list|)
block|{
name|uint32_t
name|pause_addr_lo
decl_stmt|,
name|pause_addr_hi
decl_stmt|;
name|via_align_cmd
argument_list|(
name|dev_priv
argument_list|,
name|cmd_type
argument_list|,
literal|0
argument_list|,
operator|&
name|pause_addr_hi
argument_list|,
operator|&
name|pause_addr_lo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|via_hook_segment
argument_list|(
name|dev_priv
argument_list|,
name|pause_addr_hi
argument_list|,
name|pause_addr_lo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_cmdbuf_pause
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|via_cmdbuf_flush
argument_list|(
name|dev_priv
argument_list|,
name|HC_HAGPBpID_PAUSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_cmdbuf_reset
parameter_list|(
name|drm_via_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|via_cmdbuf_flush
argument_list|(
name|dev_priv
argument_list|,
name|HC_HAGPBpID_STOP
argument_list|)
expr_stmt|;
name|via_wait_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User interface to the space and lag functions.  */
end_comment

begin_function
specifier|static
name|int
name|via_cmdbuf_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_via_cmdbuf_size_t
modifier|*
name|d_siz
init|=
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|uint32_t
name|tmp_size
decl_stmt|,
name|count
decl_stmt|;
name|drm_via_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called without initializing AGP ring buffer.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
name|count
operator|=
literal|1000000
expr_stmt|;
name|tmp_size
operator|=
name|d_siz
operator|->
name|size
expr_stmt|;
switch|switch
condition|(
name|d_siz
operator|->
name|func
condition|)
block|{
case|case
name|VIA_CMDBUF_SPACE
case|:
while|while
condition|(
operator|(
operator|(
name|tmp_size
operator|=
name|via_cmdbuf_space
argument_list|(
name|dev_priv
argument_list|)
operator|)
operator|<
name|d_siz
operator|->
name|size
operator|)
operator|&&
operator|--
name|count
condition|)
block|{
if|if
condition|(
operator|!
name|d_siz
operator|->
name|wait
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"VIA_CMDBUF_SPACE timed out.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
block|}
break|break;
case|case
name|VIA_CMDBUF_LAG
case|:
while|while
condition|(
operator|(
operator|(
name|tmp_size
operator|=
name|via_cmdbuf_lag
argument_list|(
name|dev_priv
argument_list|)
operator|)
operator|>
name|d_siz
operator|->
name|size
operator|)
operator|&&
operator|--
name|count
condition|)
block|{
if|if
condition|(
operator|!
name|d_siz
operator|->
name|wait
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"VIA_CMDBUF_LAG timed out.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
block|}
break|break;
default|default:
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
block|}
name|d_siz
operator|->
name|size
operator|=
name|tmp_size
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|drm_ioctl_desc
name|via_ioctls
index|[]
init|=
block|{
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_ALLOCMEM
argument_list|,
name|via_mem_alloc
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_FREEMEM
argument_list|,
name|via_mem_free
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_AGP_INIT
argument_list|,
name|via_agp_init
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_FB_INIT
argument_list|,
name|via_fb_init
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_MAP_INIT
argument_list|,
name|via_map_init
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_DEC_FUTEX
argument_list|,
name|via_decoder_futex
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_DMA_INIT
argument_list|,
name|via_dma_init
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_CMDBUFFER
argument_list|,
name|via_cmdbuffer
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_FLUSH
argument_list|,
name|via_flush_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_PCICMD
argument_list|,
name|via_pci_cmdbuffer
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_CMDBUF_SIZE
argument_list|,
name|via_cmdbuf_size
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_WAIT_IRQ
argument_list|,
name|via_wait_irq
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_VIA_DMA_BLIT
argument_list|,
name|via_dma_blit
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
argument|DRM_VIA_BLIT_SYNC
argument_list|,
argument|via_dma_blit_sync
argument_list|,
argument|DRM_AUTH
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|via_max_ioctl
init|=
name|DRM_ARRAY_SIZE
argument_list|(
name|via_ioctls
argument_list|)
decl_stmt|;
end_decl_stmt

end_unit

