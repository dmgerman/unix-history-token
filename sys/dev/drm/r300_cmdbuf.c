begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* r300_cmdbuf.c -- Command buffer emission for R300 -*- linux-c -*-  *  * Copyright (C) The Weather Channel, Inc.  2002.  * Copyright (C) 2004 Nicolai Haehnle.  * All Rights Reserved.  *  * The Weather Channel (TM) funded Tungsten Graphics to develop the  * initial release of the Radeon 8500 driver under the XFree86 license.  * This notice must be preserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Nicolai Haehnle<prefect_@gmx.net>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/radeon_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/radeon_drv.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/r300_reg.h"
end_include

begin_define
define|#
directive|define
name|R300_SIMULTANEOUS_CLIPRECTS
value|4
end_define

begin_comment
comment|/* Values for R300_RE_CLIPRECT_CNTL depending on the number of cliprects  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|r300_cliprect_cntl
index|[
literal|4
index|]
init|=
block|{
literal|0xAAAA
block|,
literal|0xEEEE
block|,
literal|0xFEFE
block|,
literal|0xFFFE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Emit up to R300_SIMULTANEOUS_CLIPRECTS cliprects from the given command  * buffer, starting with index n.  */
end_comment

begin_function
specifier|static
name|int
name|r300_emit_cliprects
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|drm_clip_rect_t
name|box
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|nr
operator|=
name|cmdbuf
operator|->
name|nbox
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|nr
operator|>
name|R300_SIMULTANEOUS_CLIPRECTS
condition|)
name|nr
operator|=
name|R300_SIMULTANEOUS_CLIPRECTS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%i cliprects\n"
argument_list|,
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|6
operator|+
name|nr
operator|*
literal|2
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|R300_RE_CLIPRECT_TL_0
argument_list|,
name|nr
operator|*
literal|2
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|box
argument_list|,
operator|&
name|cmdbuf
operator|->
name|boxes
index|[
name|n
operator|+
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|box
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"copy cliprect faulted\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
name|box
operator|.
name|x1
operator|=
operator|(
name|box
operator|.
name|x1
operator|+
name|R300_CLIPRECT_OFFSET
operator|)
operator|&
name|R300_CLIPRECT_MASK
expr_stmt|;
name|box
operator|.
name|y1
operator|=
operator|(
name|box
operator|.
name|y1
operator|+
name|R300_CLIPRECT_OFFSET
operator|)
operator|&
name|R300_CLIPRECT_MASK
expr_stmt|;
name|box
operator|.
name|x2
operator|=
operator|(
name|box
operator|.
name|x2
operator|+
name|R300_CLIPRECT_OFFSET
operator|)
operator|&
name|R300_CLIPRECT_MASK
expr_stmt|;
name|box
operator|.
name|y2
operator|=
operator|(
name|box
operator|.
name|y2
operator|+
name|R300_CLIPRECT_OFFSET
operator|)
operator|&
name|R300_CLIPRECT_MASK
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|box
operator|.
name|x1
operator|<<
name|R300_CLIPRECT_X_SHIFT
operator|)
operator||
operator|(
name|box
operator|.
name|y1
operator|<<
name|R300_CLIPRECT_Y_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|box
operator|.
name|x2
operator|<<
name|R300_CLIPRECT_X_SHIFT
operator|)
operator||
operator|(
name|box
operator|.
name|y2
operator|<<
name|R300_CLIPRECT_Y_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
name|OUT_RING_REG
argument_list|(
name|R300_RE_CLIPRECT_CNTL
argument_list|,
name|r300_cliprect_cntl
index|[
name|nr
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* TODO/SECURITY: Force scissors to a safe value, otherwise the 		* client might be able to trample over memory. 		* The impact should be very limited, but I'd rather be safe than 		* sorry. 		*/
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|R300_RE_SCISSORS_TL
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|R300_SCISSORS_X_MASK
operator||
name|R300_SCISSORS_Y_MASK
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Why we allow zero cliprect rendering: 		 * There are some commands in a command buffer that must be submitted 		 * even when there are no cliprects, e.g. DMA buffer discard 		 * or state setting (though state setting could be avoided by 		 * simulating a loss of context). 		 * 		 * Now since the cmdbuf interface is so chaotic right now (and is 		 * bound to remain that way for a bit until things settle down), 		 * it is basically impossible to filter out the commands that are 		 * necessary and those that aren't. 		 * 		 * So I choose the safe way and don't do any filtering at all; 		 * instead, I simply set up the engine so that all rendering 		 * can't produce any fragments. 		 */
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|R300_RE_CLIPRECT_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|u8
name|r300_reg_flags
index|[
literal|0x10000
operator|>>
literal|2
index|]
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|r300_init_reg_flags
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|r300_reg_flags
argument_list|,
literal|0
argument_list|,
literal|0x10000
operator|>>
literal|2
argument_list|)
expr_stmt|;
define|#
directive|define
name|ADD_RANGE_MARK
parameter_list|(
name|reg
parameter_list|,
name|count
parameter_list|,
name|mark
parameter_list|)
define|\
value|for(i=((reg)>>2);i<((reg)>>2)+(count);i++)\ 			r300_reg_flags[i]|=(mark);
define|#
directive|define
name|MARK_SAFE
value|1
define|#
directive|define
name|MARK_CHECK_OFFSET
value|2
define|#
directive|define
name|ADD_RANGE
parameter_list|(
name|reg
parameter_list|,
name|count
parameter_list|)
value|ADD_RANGE_MARK(reg, count, MARK_SAFE)
comment|/* these match cmducs() command in r300_driver/r300/r300_cmdbuf.c */
name|ADD_RANGE
argument_list|(
name|R300_SE_VPORT_XSCALE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x2080
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_SE_VTE_CNTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x2134
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x2140
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_VAP_INPUT_CNTL_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x21DC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x221C
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x2220
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x2288
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_VAP_OUTPUT_VTX_FMT_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_VAP_PVS_CNTL_1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_GB_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_GB_MSPOS0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_TX_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4200
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4214
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RE_POINTSIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4230
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RE_LINE_CNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4238
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4260
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4274
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4288
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x42A0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RE_ZBIAS_T_FACTOR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x42B4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RE_CULL_CNTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x42C0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RS_CNTL_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RS_INTERP_0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RS_ROUTE_0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x43A4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x43E8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PFS_CNTL_0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PFS_NODE_0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PFS_TEXI_0
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x46A4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PFS_INSTR0_0
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PFS_INSTR1_0
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PFS_INSTR2_0
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PFS_INSTR3_0
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4BC0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4BC8
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PP_ALPHA_TEST
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4BD8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_PFS_PARAM_0_X
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4E00
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RB3D_CBLEND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RB3D_COLORMASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4E10
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ADD_RANGE_MARK
argument_list|(
name|R300_RB3D_COLOROFFSET0
argument_list|,
literal|1
argument_list|,
name|MARK_CHECK_OFFSET
argument_list|)
expr_stmt|;
comment|/* check offset */
name|ADD_RANGE
argument_list|(
name|R300_RB3D_COLORPITCH0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4E50
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4E88
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4EA0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RB3D_ZSTENCIL_CNTL_0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4F10
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ADD_RANGE_MARK
argument_list|(
name|R300_RB3D_DEPTHOFFSET
argument_list|,
literal|1
argument_list|,
name|MARK_CHECK_OFFSET
argument_list|)
expr_stmt|;
comment|/* check offset */
name|ADD_RANGE
argument_list|(
name|R300_RB3D_DEPTHPITCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4F28
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4F30
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4F44
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
literal|0x4F54
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_TX_FILTER_0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_TX_UNK1_0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_TX_SIZE_0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_TX_FORMAT_0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Texture offset is dangerous and needs more checking */
name|ADD_RANGE_MARK
argument_list|(
name|R300_TX_OFFSET_0
argument_list|,
literal|16
argument_list|,
name|MARK_CHECK_OFFSET
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_TX_UNK4_0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_TX_BORDER_COLOR_0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Sporadic registers used as primitives are emitted */
name|ADD_RANGE
argument_list|(
literal|0x4f18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_RB3D_DSTCACHE_CTLSTAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_VAP_INPUT_ROUTE_0_0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ADD_RANGE
argument_list|(
name|R300_VAP_INPUT_ROUTE_1_0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|r300_check_range
parameter_list|(
name|unsigned
name|reg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|reg
operator|&
operator|~
literal|0xffff
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
operator|(
name|reg
operator|>>
literal|2
operator|)
init|;
name|i
operator|<
operator|(
name|reg
operator|>>
literal|2
operator|)
operator|+
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|r300_reg_flags
index|[
name|i
index|]
operator|!=
name|MARK_SAFE
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* we expect offsets passed to the framebuffer to be either within video memory or       within AGP space */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|r300_check_offset
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|u32
name|offset
parameter_list|)
block|{
comment|/* we realy want to check against end of video aperture 		but this value is not being kept.  		This code is correct for now (does the same thing as the 		code that sets MC_FB_LOCATION) in radeon_cp.c */
if|if
condition|(
operator|(
name|offset
operator|>=
name|dev_priv
operator|->
name|fb_location
operator|)
operator|&&
operator|(
name|offset
operator|<
name|dev_priv
operator|->
name|gart_vm_start
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|offset
operator|>=
name|dev_priv
operator|->
name|gart_vm_start
operator|)
operator|&&
operator|(
name|offset
operator|<
name|dev_priv
operator|->
name|gart_vm_start
operator|+
name|dev_priv
operator|->
name|gart_size
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|r300_emit_carefully_checked_packet0
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|,
name|drm_r300_cmd_header_t
name|header
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|values
index|[
literal|64
index|]
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|sz
operator|=
name|header
operator|.
name|packet0
operator|.
name|count
expr_stmt|;
name|reg
operator|=
operator|(
name|header
operator|.
name|packet0
operator|.
name|reghi
operator|<<
literal|8
operator|)
operator||
name|header
operator|.
name|packet0
operator|.
name|reglo
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|>
literal|64
operator|)
operator|||
operator|(
name|sz
operator|<
literal|0
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Cannot emit more than 64 values at a time (reg=%04x sz=%d)\n"
argument_list|,
name|reg
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|int
name|__user
operator|*
operator|)
name|cmdbuf
operator|->
name|buf
operator|)
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|r300_reg_flags
index|[
operator|(
name|reg
operator|>>
literal|2
operator|)
operator|+
name|i
index|]
condition|)
block|{
case|case
name|MARK_SAFE
case|:
break|break;
case|case
name|MARK_CHECK_OFFSET
case|:
if|if
condition|(
name|r300_check_offset
argument_list|(
name|dev_priv
argument_list|,
operator|(
name|u32
operator|)
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Offset failed range check (reg=%04x sz=%d)\n"
argument_list|,
name|reg
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Register %04x failed check as flag=%02x\n"
argument_list|,
name|reg
operator|+
name|i
operator|*
literal|4
argument_list|,
name|r300_reg_flags
index|[
operator|(
name|reg
operator|>>
literal|2
operator|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
name|BEGIN_RING
argument_list|(
literal|1
operator|+
name|sz
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|reg
argument_list|,
name|sz
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|values
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|sz
operator|*
literal|4
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|sz
operator|*
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Emits a packet0 setting arbitrary registers.  * Called by r300_do_cp_cmdbuf.  *  * Note that checks are performed on contents and addresses of the registers  */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|r300_emit_packet0
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|,
name|drm_r300_cmd_header_t
name|header
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|sz
operator|=
name|header
operator|.
name|packet0
operator|.
name|count
expr_stmt|;
name|reg
operator|=
operator|(
name|header
operator|.
name|packet0
operator|.
name|reghi
operator|<<
literal|8
operator|)
operator||
name|header
operator|.
name|packet0
operator|.
name|reglo
expr_stmt|;
if|if
condition|(
operator|!
name|sz
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sz
operator|*
literal|4
operator|>
name|cmdbuf
operator|->
name|bufsz
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|reg
operator|+
name|sz
operator|*
literal|4
operator|>=
literal|0x10000
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"No such registers in hardware reg=%04x sz=%d\n"
argument_list|,
name|reg
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|r300_check_range
argument_list|(
name|reg
argument_list|,
name|sz
argument_list|)
condition|)
block|{
comment|/* go and check everything */
return|return
name|r300_emit_carefully_checked_packet0
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|,
name|header
argument_list|)
return|;
block|}
comment|/* the rest of the data is safe to emit, whatever the values the user passed */
name|BEGIN_RING
argument_list|(
literal|1
operator|+
name|sz
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|reg
argument_list|,
name|sz
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
operator|(
name|int
name|__user
operator|*
operator|)
name|cmdbuf
operator|->
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|sz
operator|*
literal|4
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|sz
operator|*
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Uploads user-supplied vertex program instructions or parameters onto  * the graphics card.  * Called by r300_do_cp_cmdbuf.  */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|r300_emit_vpu
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|,
name|drm_r300_cmd_header_t
name|header
parameter_list|)
block|{
name|int
name|sz
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|sz
operator|=
name|header
operator|.
name|vpu
operator|.
name|count
expr_stmt|;
name|addr
operator|=
operator|(
name|header
operator|.
name|vpu
operator|.
name|adrhi
operator|<<
literal|8
operator|)
operator||
name|header
operator|.
name|vpu
operator|.
name|adrlo
expr_stmt|;
if|if
condition|(
operator|!
name|sz
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sz
operator|*
literal|16
operator|>
name|cmdbuf
operator|->
name|bufsz
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|BEGIN_RING
argument_list|(
literal|5
operator|+
name|sz
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Wait for VAP to come to senses.. */
comment|/* there is no need to emit it multiple times, (only once before VAP is programmed, 	   but this optimization is for later */
name|OUT_RING_REG
argument_list|(
name|R300_VAP_PVS_WAITIDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|R300_VAP_PVS_UPLOAD_ADDRESS
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0_TABLE
argument_list|(
name|R300_VAP_PVS_UPLOAD_DATA
argument_list|,
name|sz
operator|*
literal|4
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
operator|(
name|int
name|__user
operator|*
operator|)
name|cmdbuf
operator|->
name|buf
argument_list|,
name|sz
operator|*
literal|4
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|sz
operator|*
literal|16
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|sz
operator|*
literal|16
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Emit a clear packet from userspace.  * Called by r300_emit_packet3.  */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|r300_emit_clear
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
literal|8
operator|*
literal|4
operator|>
name|cmdbuf
operator|->
name|bufsz
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|BEGIN_RING
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|R200_3D_DRAW_IMMD_2
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|R300_PRIM_TYPE_POINT
operator||
name|R300_PRIM_WALK_RING
operator||
operator|(
literal|1
operator|<<
name|R300_PRIM_NUM_VERTICES_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
operator|(
name|int
name|__user
operator|*
operator|)
name|cmdbuf
operator|->
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
literal|8
operator|*
literal|4
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
literal|8
operator|*
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|r300_emit_3d_load_vbpntr
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|,
name|u32
name|header
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|;
define|#
directive|define
name|MAX_ARRAY_PACKET
value|64
name|u32
name|payload
index|[
name|MAX_ARRAY_PACKET
index|]
decl_stmt|;
name|u32
name|narrays
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|count
operator|=
operator|(
name|header
operator|>>
literal|16
operator|)
operator|&
literal|0x3fff
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|>
name|MAX_ARRAY_PACKET
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Too large payload in 3D_LOAD_VBPNTR (count=%d)\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
name|MAX_ARRAY_PACKET
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|payload
argument_list|,
name|cmdbuf
operator|->
name|buf
operator|+
literal|4
argument_list|,
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* carefully check packet contents */
name|narrays
operator|=
name|payload
index|[
literal|0
index|]
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|<
name|narrays
operator|)
operator|&&
operator|(
name|i
operator|<
operator|(
name|count
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* skip attribute field */
if|if
condition|(
name|r300_check_offset
argument_list|(
name|dev_priv
argument_list|,
name|payload
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Offset failed range check (k=%d i=%d) while processing 3D_LOAD_VBPNTR packet.\n"
argument_list|,
name|k
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|k
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|narrays
condition|)
break|break;
comment|/* have one more to process, they come in pairs */
if|if
condition|(
name|r300_check_offset
argument_list|(
name|dev_priv
argument_list|,
name|payload
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Offset failed range check (k=%d i=%d) while processing 3D_LOAD_VBPNTR packet.\n"
argument_list|,
name|k
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|k
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* do the counts match what we expect ? */
if|if
condition|(
operator|(
name|k
operator|!=
name|narrays
operator|)
operator|||
operator|(
name|i
operator|!=
operator|(
name|count
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Malformed 3D_LOAD_VBPNTR packet (k=%d i=%d narrays=%d count+1=%d).\n"
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|narrays
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* all clear, output packet */
name|BEGIN_RING
argument_list|(
name|count
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|payload
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
operator|(
name|count
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
operator|(
name|count
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|r300_emit_raw_packet3
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|u32
name|header
decl_stmt|;
name|int
name|count
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
literal|4
operator|>
name|cmdbuf
operator|->
name|bufsz
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* Fixme !! This simply emits a packet without much checking. 	   We need to be smarter. */
comment|/* obtain first word - actual packet3 header */
name|header
operator|=
operator|*
operator|(
name|u32
name|__user
operator|*
operator|)
name|cmdbuf
operator|->
name|buf
expr_stmt|;
comment|/* Is it packet 3 ? */
if|if
condition|(
operator|(
name|header
operator|>>
literal|30
operator|)
operator|!=
literal|0x3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Not a packet3 header (0x%08x)\n"
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|count
operator|=
operator|(
name|header
operator|>>
literal|16
operator|)
operator|&
literal|0x3fff
expr_stmt|;
comment|/* Check again now that we know how much data to expect */
if|if
condition|(
operator|(
name|count
operator|+
literal|2
operator|)
operator|*
literal|4
operator|>
name|cmdbuf
operator|->
name|bufsz
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Expected packet3 of length %d but have only %d bytes left\n"
argument_list|,
operator|(
name|count
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
name|cmdbuf
operator|->
name|bufsz
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* Is it a packet type we know about ? */
switch|switch
condition|(
name|header
operator|&
literal|0xff00
condition|)
block|{
case|case
name|RADEON_3D_LOAD_VBPNTR
case|:
comment|/* load vertex array pointers */
return|return
name|r300_emit_3d_load_vbpntr
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|,
name|header
argument_list|)
return|;
case|case
name|RADEON_CP_3D_DRAW_IMMD_2
case|:
comment|/* triggers drawing using in-packet vertex data */
case|case
name|RADEON_CP_3D_DRAW_VBUF_2
case|:
comment|/* triggers drawing of vertex buffers setup elsewhere */
case|case
name|RADEON_CP_3D_DRAW_INDX_2
case|:
comment|/* triggers drawing using indices to vertex buffer */
case|case
name|RADEON_CP_INDX_BUFFER
case|:
comment|/* DRAW_INDX_2 without INDX_BUFFER seems to lock up the gpu */
case|case
name|RADEON_WAIT_FOR_IDLE
case|:
case|case
name|RADEON_CP_NOP
case|:
comment|/* these packets are safe */
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown packet3 header (0x%08x)\n"
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|BEGIN_RING
argument_list|(
name|count
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
operator|(
name|int
name|__user
operator|*
operator|)
operator|(
name|cmdbuf
operator|->
name|buf
operator|+
literal|4
operator|)
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
operator|(
name|count
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
operator|(
name|count
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Emit a rendering packet3 from userspace.  * Called by r300_do_cp_cmdbuf.  */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|r300_emit_packet3
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|,
name|drm_r300_cmd_header_t
name|header
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|__user
modifier|*
name|orig_buf
init|=
name|cmdbuf
operator|->
name|buf
decl_stmt|;
name|int
name|orig_bufsz
init|=
name|cmdbuf
operator|->
name|bufsz
decl_stmt|;
comment|/* This is a do-while-loop so that we run the interior at least once, 	 * even if cmdbuf->nbox is 0. Compare r300_emit_cliprects for rationale. 	 */
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cmdbuf
operator|->
name|nbox
operator|>
name|R300_SIMULTANEOUS_CLIPRECTS
condition|)
block|{
name|ret
operator|=
name|r300_emit_cliprects
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|cmdbuf
operator|->
name|buf
operator|=
name|orig_buf
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|=
name|orig_bufsz
expr_stmt|;
block|}
switch|switch
condition|(
name|header
operator|.
name|packet3
operator|.
name|packet
condition|)
block|{
case|case
name|R300_CMD_PACKET3_CLEAR
case|:
name|DRM_DEBUG
argument_list|(
literal|"R300_CMD_PACKET3_CLEAR\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|r300_emit_clear
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"r300_emit_clear failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
break|break;
case|case
name|R300_CMD_PACKET3_RAW
case|:
name|DRM_DEBUG
argument_list|(
literal|"R300_CMD_PACKET3_RAW\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|r300_emit_raw_packet3
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"r300_emit_raw_packet3 failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"bad packet3 type %i at %p\n"
argument_list|,
name|header
operator|.
name|packet3
operator|.
name|packet
argument_list|,
name|cmdbuf
operator|->
name|buf
operator|-
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|n
operator|+=
name|R300_SIMULTANEOUS_CLIPRECTS
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|<
name|cmdbuf
operator|->
name|nbox
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Some of the R300 chips seem to be extremely touchy about the two registers  * that are configured in r300_pacify.  * Among the worst offenders seems to be the R300 ND (0x4E44): When userspace  * sends a command buffer that contains only state setting commands and a  * vertex program/parameter upload sequence, this will eventually lead to a  * lockup, unless the sequence is bracketed by calls to r300_pacify.  * So we should take great care to *always* call r300_pacify before  * *anything* 3D related, and again afterwards. This is what the  * call bracket in r300_do_cp_cmdbuf is for.  */
end_comment

begin_comment
comment|/**  * Emit the sequence to pacify R300.  */
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|r300_pacify
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|RING_LOCALS
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|R300_RB3D_DSTCACHE_CTLSTAT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0xa
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
literal|0x4f18
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x3
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_CP_NOP
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called by r300_do_cp_cmdbuf to update the internal buffer age and state.  * The actual age emit is done by r300_do_cp_cmdbuf, which is why you must  * be careful about how this function is called.  */
end_comment

begin_function
specifier|static
name|void
name|r300_discard_buffer
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_buf_priv_t
modifier|*
name|buf_priv
init|=
name|buf
operator|->
name|dev_private
decl_stmt|;
name|buf_priv
operator|->
name|age
operator|=
operator|++
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Parses and validates a user-supplied command buffer and emits appropriate  * commands on the DMA ring buffer.  * Called by the ioctl handler function radeon_cp_cmdbuf.  */
end_comment

begin_function
name|int
name|r300_do_cp_cmdbuf
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|DRMFILE
name|filp
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|drm_radeon_cmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|emit_dispatch_age
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* See the comment above r300_emit_begin3d for why this call must be here, 	 * and what the cleanup gotos are for. */
name|r300_pacify
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdbuf
operator|->
name|nbox
operator|<=
name|R300_SIMULTANEOUS_CLIPRECTS
condition|)
block|{
name|ret
operator|=
name|r300_emit_cliprects
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|cleanup
goto|;
block|}
while|while
condition|(
name|cmdbuf
operator|->
name|bufsz
operator|>=
sizeof|sizeof
argument_list|(
name|drm_r300_cmd_header_t
argument_list|)
condition|)
block|{
name|int
name|idx
decl_stmt|;
name|drm_r300_cmd_header_t
name|header
decl_stmt|;
name|header
operator|.
name|u
operator|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|cmdbuf
operator|->
name|buf
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
operator|.
name|header
operator|.
name|cmd_type
condition|)
block|{
case|case
name|R300_CMD_PACKET0
case|:
name|DRM_DEBUG
argument_list|(
literal|"R300_CMD_PACKET0\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|r300_emit_packet0
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"r300_emit_packet0 failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
break|break;
case|case
name|R300_CMD_VPU
case|:
name|DRM_DEBUG
argument_list|(
literal|"R300_CMD_VPU\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|r300_emit_vpu
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"r300_emit_vpu failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
break|break;
case|case
name|R300_CMD_PACKET3
case|:
name|DRM_DEBUG
argument_list|(
literal|"R300_CMD_PACKET3\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|r300_emit_packet3
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"r300_emit_packet3 failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
break|break;
case|case
name|R300_CMD_END3D
case|:
name|DRM_DEBUG
argument_list|(
literal|"R300_CMD_END3D\n"
argument_list|)
expr_stmt|;
comment|/* TODO:  				Ideally userspace driver should not need to issue this call,  				i.e. the drm driver should issue it automatically and prevent 				lockups. 				 				In practice, we do not understand why this call is needed and what 				it does (except for some vague guesses that it has to do with cache 				coherence) and so the user space driver does it.  				 				Once we are sure which uses prevent lockups the code could be moved 				into the kernel and the userspace driver will not 				need to use this command.  				Note that issuing this command does not hurt anything 				except, possibly, performance */
name|r300_pacify
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
break|break;
case|case
name|R300_CMD_CP_DELAY
case|:
comment|/* simple enough, we can do it here */
name|DRM_DEBUG
argument_list|(
literal|"R300_CMD_CP_DELAY\n"
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|BEGIN_RING
argument_list|(
name|header
operator|.
name|delay
operator|.
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|delay
operator|.
name|count
condition|;
name|i
operator|++
control|)
name|OUT_RING
argument_list|(
name|RADEON_CP_PACKET2
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|R300_CMD_DMA_DISCARD
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_DMA_DISCARD\n"
argument_list|)
expr_stmt|;
name|idx
operator|=
name|header
operator|.
name|dma
operator|.
name|buf_idx
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer index %d (of %d max)\n"
argument_list|,
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|filp
operator|!=
name|filp
operator|||
name|buf
operator|->
name|pending
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad buffer %p %p %d\n"
argument_list|,
name|buf
operator|->
name|filp
argument_list|,
name|filp
argument_list|,
name|buf
operator|->
name|pending
argument_list|)
expr_stmt|;
name|ret
operator|=
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|emit_dispatch_age
operator|=
literal|1
expr_stmt|;
name|r300_discard_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|R300_CMD_WAIT
case|:
comment|/* simple enough, we can do it here */
name|DRM_DEBUG
argument_list|(
literal|"R300_CMD_WAIT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|wait
operator|.
name|flags
operator|==
literal|0
condition|)
break|break;
comment|/* nothing to do */
block|{
name|RING_LOCALS
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_WAIT_UNTIL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|header
operator|.
name|wait
operator|.
name|flags
operator|&
literal|0xf
operator|)
operator|<<
literal|14
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"bad cmd_type %i at %p\n"
argument_list|,
name|header
operator|.
name|header
operator|.
name|cmd_type
argument_list|,
name|cmdbuf
operator|->
name|buf
operator|-
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|DRM_DEBUG
argument_list|(
literal|"END\n"
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|r300_pacify
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* We emit the vertex buffer age here, outside the pacifier "brackets" 	 * for two reasons: 	 *  (1) This may coalesce multiple age emissions into a single one and 	 *  (2) more importantly, some chips lock up hard when scratch registers 	 *      are written inside the pacifier bracket. 	 */
if|if
condition|(
name|emit_dispatch_age
condition|)
block|{
name|RING_LOCALS
expr_stmt|;
comment|/* Emit the vertex buffer age */
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_DISPATCH_AGE
argument_list|(
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

