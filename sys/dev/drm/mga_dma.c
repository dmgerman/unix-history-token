begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mga_dma.c -- DMA support for mga g200/g400 -*- linux-c -*-  * Created: Mon Dec 13 01:50:01 1999 by jhartmann@precisioninsight.com  */
end_comment

begin_comment
comment|/* Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.  * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * \file mga_dma.c  * DMA support for MGA G200 / G400.  *  * \author Rickard E. (Rik) Faith<faith@valinux.com>  * \author Jeff Hartmann<jhartmann@valinux.com>  * \author Keith Whitwell<keith@tungstengraphics.com>  * \author Gareth Hughes<gareth@valinux.com>  */
end_comment

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm_sarea.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/mga_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/mga_drv.h"
end_include

begin_define
define|#
directive|define
name|MGA_DEFAULT_USEC_TIMEOUT
value|10000
end_define

begin_define
define|#
directive|define
name|MGA_FREELIST_DEBUG
value|0
end_define

begin_define
define|#
directive|define
name|MINIMAL_CLEANUP
value|0
end_define

begin_define
define|#
directive|define
name|FULL_CLEANUP
value|1
end_define

begin_function_decl
specifier|static
name|int
name|mga_do_cleanup_dma
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|full_cleanup
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ================================================================  * Engine control  */
end_comment

begin_function
name|int
name|mga_do_wait_for_idle
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|MGA_READ
argument_list|(
name|MGA_STATUS
argument_list|)
operator|&
name|MGA_ENGINE_IDLE_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MGA_ENDPRDMASTS
condition|)
block|{
name|MGA_WRITE8
argument_list|(
name|MGA_CRTC_INDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MGA_DMA_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"   status=0x%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mga_do_dma_reset
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mga_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_mga_primary_buffer_t
modifier|*
name|primary
init|=
operator|&
name|dev_priv
operator|->
name|prim
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* The primary DMA stream should look like new right about now. 	 */
name|primary
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|primary
operator|->
name|space
operator|=
name|primary
operator|->
name|size
expr_stmt|;
name|primary
operator|->
name|last_flush
operator|=
literal|0
expr_stmt|;
name|sarea_priv
operator|->
name|last_wrap
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: Reset counters, buffer ages etc... 	 */
comment|/* FIXME: What else do we need to reinitialize?  WARP stuff? 	 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * Primary DMA stream  */
end_comment

begin_function
name|void
name|mga_do_dma_flush
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mga_primary_buffer_t
modifier|*
name|primary
init|=
operator|&
name|dev_priv
operator|->
name|prim
decl_stmt|;
name|u32
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|u32
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DMA_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* We need to wait so that we can do an safe flush */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|MGA_READ
argument_list|(
name|MGA_STATUS
argument_list|)
operator|&
name|MGA_ENGINE_IDLE_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MGA_ENDPRDMASTS
condition|)
break|break;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|primary
operator|->
name|tail
operator|==
name|primary
operator|->
name|last_flush
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"   bailing out...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tail
operator|=
name|primary
operator|->
name|tail
operator|+
name|dev_priv
operator|->
name|primary
operator|->
name|offset
expr_stmt|;
comment|/* We need to pad the stream between flushes, as the card 	 * actually (partially?) reads the first of these commands. 	 * See page 4-16 in the G400 manual, middle of the page or so. 	 */
name|BEGIN_DMA
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DMA_BLOCK
argument_list|(
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|ADVANCE_DMA
argument_list|()
expr_stmt|;
name|primary
operator|->
name|last_flush
operator|=
name|primary
operator|->
name|tail
expr_stmt|;
name|head
operator|=
name|MGA_READ
argument_list|(
name|MGA_PRIMADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|<=
name|tail
condition|)
block|{
name|primary
operator|->
name|space
operator|=
name|primary
operator|->
name|size
operator|-
name|primary
operator|->
name|tail
expr_stmt|;
block|}
else|else
block|{
name|primary
operator|->
name|space
operator|=
name|head
operator|-
name|tail
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"   head = 0x%06lx\n"
argument_list|,
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   tail = 0x%06lx\n"
argument_list|,
name|tail
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"  space = 0x%06x\n"
argument_list|,
name|primary
operator|->
name|space
argument_list|)
expr_stmt|;
name|mga_flush_write_combine
argument_list|()
expr_stmt|;
name|MGA_WRITE
argument_list|(
name|MGA_PRIMEND
argument_list|,
name|tail
operator||
name|dev_priv
operator|->
name|dma_access
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mga_do_dma_wrap_start
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mga_primary_buffer_t
modifier|*
name|primary
init|=
operator|&
name|dev_priv
operator|->
name|prim
decl_stmt|;
name|u32
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|DMA_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|BEGIN_DMA_WRAP
argument_list|()
expr_stmt|;
name|DMA_BLOCK
argument_list|(
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|ADVANCE_DMA
argument_list|()
expr_stmt|;
name|tail
operator|=
name|primary
operator|->
name|tail
operator|+
name|dev_priv
operator|->
name|primary
operator|->
name|offset
expr_stmt|;
name|primary
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|primary
operator|->
name|last_flush
operator|=
literal|0
expr_stmt|;
name|primary
operator|->
name|last_wrap
operator|++
expr_stmt|;
name|head
operator|=
name|MGA_READ
argument_list|(
name|MGA_PRIMADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|dev_priv
operator|->
name|primary
operator|->
name|offset
condition|)
block|{
name|primary
operator|->
name|space
operator|=
name|primary
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|primary
operator|->
name|space
operator|=
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"   head = 0x%06lx\n"
argument_list|,
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   tail = 0x%06x\n"
argument_list|,
name|primary
operator|->
name|tail
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   wrap = %d\n"
argument_list|,
name|primary
operator|->
name|last_wrap
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"  space = 0x%06x\n"
argument_list|,
name|primary
operator|->
name|space
argument_list|)
expr_stmt|;
name|mga_flush_write_combine
argument_list|()
expr_stmt|;
name|MGA_WRITE
argument_list|(
name|MGA_PRIMEND
argument_list|,
name|tail
operator||
name|dev_priv
operator|->
name|dma_access
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
literal|0
argument_list|,
operator|&
name|primary
operator|->
name|wrapped
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mga_do_dma_wrap_end
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mga_primary_buffer_t
modifier|*
name|primary
init|=
operator|&
name|dev_priv
operator|->
name|prim
decl_stmt|;
name|drm_mga_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|u32
name|head
init|=
name|dev_priv
operator|->
name|primary
operator|->
name|offset
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|last_wrap
operator|++
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   wrap = %d\n"
argument_list|,
name|sarea_priv
operator|->
name|last_wrap
argument_list|)
expr_stmt|;
name|mga_flush_write_combine
argument_list|()
expr_stmt|;
name|MGA_WRITE
argument_list|(
name|MGA_PRIMADDRESS
argument_list|,
name|head
operator||
name|MGA_DMA_GENERAL
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
literal|0
argument_list|,
operator|&
name|primary
operator|->
name|wrapped
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ================================================================  * Freelist management  */
end_comment

begin_define
define|#
directive|define
name|MGA_BUFFER_USED
value|~0
end_define

begin_define
define|#
directive|define
name|MGA_BUFFER_FREE
value|0
end_define

begin_if
if|#
directive|if
name|MGA_FREELIST_DEBUG
end_if

begin_function
specifier|static
name|void
name|mga_freelist_print
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|entry
decl_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"current dispatch: last=0x%x done=0x%x\n"
argument_list|,
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|MGA_READ
argument_list|(
name|MGA_PRIMADDRESS
argument_list|)
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"current freelist:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|dev_priv
operator|->
name|head
operator|->
name|next
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|DRM_INFO
argument_list|(
literal|"   %p   idx=%2d  age=0x%x 0x%06lx\n"
argument_list|,
name|entry
argument_list|,
name|entry
operator|->
name|buf
operator|->
name|idx
argument_list|,
name|entry
operator|->
name|age
operator|.
name|head
argument_list|,
name|entry
operator|->
name|age
operator|.
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mga_freelist_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|drm_mga_buf_priv_t
modifier|*
name|buf_priv
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count=%d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|=
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|head
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|memset
argument_list|(
name|dev_priv
operator|->
name|head
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|)
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|head
operator|->
name|age
argument_list|,
name|MGA_BUFFER_USED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
name|buf_priv
operator|=
name|buf
operator|->
name|dev_private
expr_stmt|;
name|entry
operator|=
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|memset
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|dev_priv
operator|->
name|head
operator|->
name|next
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|dev_priv
operator|->
name|head
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|entry
operator|->
name|age
argument_list|,
name|MGA_BUFFER_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|head
operator|->
name|next
operator|!=
name|NULL
condition|)
name|dev_priv
operator|->
name|head
operator|->
name|next
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|==
name|NULL
condition|)
name|dev_priv
operator|->
name|tail
operator|=
name|entry
expr_stmt|;
name|buf_priv
operator|->
name|list_entry
operator|=
name|entry
expr_stmt|;
name|buf_priv
operator|->
name|discard
operator|=
literal|0
expr_stmt|;
name|buf_priv
operator|->
name|dispatched
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|->
name|next
operator|=
name|entry
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mga_freelist_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|entry
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|next
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|entry
operator|=
name|dev_priv
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|drm_free
argument_list|(
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
name|dev_priv
operator|->
name|head
operator|=
name|dev_priv
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME: Still needed?  */
end_comment

begin_endif
unit|static void mga_freelist_reset(struct drm_device * dev) { 	drm_device_dma_t *dma = dev->dma; 	struct drm_buf *buf; 	drm_mga_buf_priv_t *buf_priv; 	int i;  	for (i = 0; i< dma->buf_count; i++) { 		buf = dma->buflist[i]; 		buf_priv = buf->dev_private; 		SET_AGE(&buf_priv->list_entry->age, MGA_BUFFER_FREE, 0); 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|drm_buf
modifier|*
name|mga_freelist_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|next
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|prev
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|tail
init|=
name|dev_priv
operator|->
name|tail
decl_stmt|;
name|u32
name|head
decl_stmt|,
name|wrap
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|head
operator|=
name|MGA_READ
argument_list|(
name|MGA_PRIMADDRESS
argument_list|)
expr_stmt|;
name|wrap
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_wrap
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   tail=0x%06lx %d\n"
argument_list|,
name|tail
operator|->
name|age
operator|.
name|head
condition|?
name|tail
operator|->
name|age
operator|.
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
else|:
literal|0
argument_list|,
name|tail
operator|->
name|age
operator|.
name|wrap
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   head=0x%06lx %d\n"
argument_list|,
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_AGE
argument_list|(
operator|&
name|tail
operator|->
name|age
argument_list|,
name|head
argument_list|,
name|wrap
argument_list|)
condition|)
block|{
name|prev
operator|=
name|dev_priv
operator|->
name|tail
operator|->
name|prev
expr_stmt|;
name|next
operator|=
name|dev_priv
operator|->
name|tail
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|tail
operator|=
name|prev
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|next
operator|->
name|age
argument_list|,
name|MGA_BUFFER_USED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|next
operator|->
name|buf
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"returning NULL!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|mga_freelist_put
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_buf_priv_t
modifier|*
name|buf_priv
init|=
name|buf
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|head
decl_stmt|,
modifier|*
name|entry
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"age=0x%06lx wrap=%d\n"
argument_list|,
name|buf_priv
operator|->
name|list_entry
operator|->
name|age
operator|.
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|,
name|buf_priv
operator|->
name|list_entry
operator|->
name|age
operator|.
name|wrap
argument_list|)
expr_stmt|;
name|entry
operator|=
name|buf_priv
operator|->
name|list_entry
expr_stmt|;
name|head
operator|=
name|dev_priv
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|buf_priv
operator|->
name|list_entry
operator|->
name|age
operator|.
name|head
operator|==
name|MGA_BUFFER_USED
condition|)
block|{
name|SET_AGE
argument_list|(
operator|&
name|entry
operator|->
name|age
argument_list|,
name|MGA_BUFFER_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|dev_priv
operator|->
name|tail
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|prev
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|head
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|prev
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * DMA initialization, cleanup  */
end_comment

begin_function
name|int
name|mga_driver_load
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|dev_priv
operator|=
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_mga_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|memset
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_private_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|usec_timeout
operator|=
name|MGA_DEFAULT_USEC_TIMEOUT
expr_stmt|;
name|dev_priv
operator|->
name|chipset
operator|=
name|flags
expr_stmt|;
name|dev_priv
operator|->
name|mmio_base
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mmio_size
operator|=
name|drm_get_resource_len
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dev
operator|->
name|counters
operator|+=
literal|3
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|6
index|]
operator|=
name|_DRM_STAT_IRQ
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|7
index|]
operator|=
name|_DRM_STAT_PRIMARY
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|8
index|]
operator|=
name|_DRM_STAT_SECONDARY
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Bootstrap the driver for AGP DMA.  *  * \todo  * Investigate whether there is any benifit to storing the WARP microcode in  * AGP memory.  If not, the microcode may as well always be put in PCI  * memory.  *  * \todo  * This routine needs to set dma_bs->agp_mode to the mode actually configured  * in the hardware.  Looking just at the Linux AGP driver code, I don't see  * an easy way to determine this.  *  * \sa mga_do_dma_bootstrap, mga_do_pci_dma_bootstrap  */
end_comment

begin_function
specifier|static
name|int
name|mga_do_agp_dma_bootstrap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_mga_dma_bootstrap_t
modifier|*
name|dma_bs
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
specifier|const
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|unsigned
name|int
name|warp_size
init|=
name|mga_warp_microcode_size
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|unsigned
name|offset
decl_stmt|;
specifier|const
name|unsigned
name|secondary_size
init|=
name|dma_bs
operator|->
name|secondary_bin_count
operator|*
name|dma_bs
operator|->
name|secondary_bin_size
decl_stmt|;
specifier|const
name|unsigned
name|agp_size
init|=
operator|(
name|dma_bs
operator|->
name|agp_size
operator|<<
literal|20
operator|)
decl_stmt|;
name|struct
name|drm_buf_desc
name|req
decl_stmt|;
name|struct
name|drm_agp_mode
name|mode
decl_stmt|;
name|struct
name|drm_agp_info
name|info
decl_stmt|;
name|struct
name|drm_agp_buffer
name|agp_req
decl_stmt|;
name|struct
name|drm_agp_binding
name|bind_req
decl_stmt|;
comment|/* Acquire AGP. */
name|err
operator|=
name|drm_agp_acquire
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to acquire AGP: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|drm_agp_info
argument_list|(
name|dev
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to get AGP info: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mode
operator|.
name|mode
operator|=
operator|(
name|info
operator|.
name|mode
operator|&
operator|~
literal|0x07
operator|)
operator||
name|dma_bs
operator|->
name|agp_mode
expr_stmt|;
name|err
operator|=
name|drm_agp_enable
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to enable AGP (mode = 0x%lx)\n"
argument_list|,
name|mode
operator|.
name|mode
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* In addition to the usual AGP mode configuration, the G200 AGP cards 	 * need to have the AGP mode "manually" set. 	 */
if|if
condition|(
name|dev_priv
operator|->
name|chipset
operator|==
name|MGA_CARD_TYPE_G200
condition|)
block|{
if|if
condition|(
name|mode
operator|.
name|mode
operator|&
literal|0x02
condition|)
block|{
name|MGA_WRITE
argument_list|(
name|MGA_AGP_PLL
argument_list|,
name|MGA_AGP2XPLL_ENABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGA_WRITE
argument_list|(
name|MGA_AGP_PLL
argument_list|,
name|MGA_AGP2XPLL_DISABLE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate and bind AGP memory. */
name|agp_req
operator|.
name|size
operator|=
name|agp_size
expr_stmt|;
name|agp_req
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|drm_agp_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|agp_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_priv
operator|->
name|agp_size
operator|=
literal|0
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"Unable to allocate %uMB AGP memory\n"
argument_list|,
name|dma_bs
operator|->
name|agp_size
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|dev_priv
operator|->
name|agp_size
operator|=
name|agp_size
expr_stmt|;
name|dev_priv
operator|->
name|agp_handle
operator|=
name|agp_req
operator|.
name|handle
expr_stmt|;
name|bind_req
operator|.
name|handle
operator|=
name|agp_req
operator|.
name|handle
expr_stmt|;
name|bind_req
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|drm_agp_bind
argument_list|(
name|dev
argument_list|,
operator|&
name|bind_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to bind AGP memory: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Make drm_addbufs happy by not trying to create a mapping for less 	 * than a page. 	 */
if|if
condition|(
name|warp_size
operator|<
name|PAGE_SIZE
condition|)
name|warp_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|offset
argument_list|,
name|warp_size
argument_list|,
name|_DRM_AGP
argument_list|,
name|_DRM_READ_ONLY
argument_list|,
operator|&
name|dev_priv
operator|->
name|warp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to map WARP microcode: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|offset
operator|+=
name|warp_size
expr_stmt|;
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|offset
argument_list|,
name|dma_bs
operator|->
name|primary_size
argument_list|,
name|_DRM_AGP
argument_list|,
name|_DRM_READ_ONLY
argument_list|,
operator|&
name|dev_priv
operator|->
name|primary
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to map primary DMA region: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|offset
operator|+=
name|dma_bs
operator|->
name|primary_size
expr_stmt|;
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|offset
argument_list|,
name|secondary_size
argument_list|,
name|_DRM_AGP
argument_list|,
literal|0
argument_list|,
operator|&
name|dev
operator|->
name|agp_buffer_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to map secondary DMA region: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|count
operator|=
name|dma_bs
operator|->
name|secondary_bin_count
expr_stmt|;
name|req
operator|.
name|size
operator|=
name|dma_bs
operator|->
name|secondary_bin_size
expr_stmt|;
name|req
operator|.
name|flags
operator|=
name|_DRM_AGP_BUFFER
expr_stmt|;
name|req
operator|.
name|agp_start
operator|=
name|offset
expr_stmt|;
name|err
operator|=
name|drm_addbufs_agp
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to add secondary DMA buffers: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
ifdef|#
directive|ifdef
name|__linux__
block|{
name|struct
name|drm_map_list
modifier|*
name|_entry
decl_stmt|;
name|unsigned
name|long
name|agp_token
init|=
literal|0
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|_entry
argument_list|,
argument|&dev->maplist
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|_entry
operator|->
name|map
operator|==
name|dev
operator|->
name|agp_buffer_map
condition|)
name|agp_token
operator|=
name|_entry
operator|->
name|user_token
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|agp_token
condition|)
return|return
operator|-
name|EFAULT
return|;
name|dev
operator|->
name|agp_buffer_token
operator|=
name|agp_token
expr_stmt|;
block|}
endif|#
directive|endif
name|offset
operator|+=
name|secondary_size
expr_stmt|;
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|offset
argument_list|,
name|agp_size
operator|-
name|offset
argument_list|,
name|_DRM_AGP
argument_list|,
literal|0
argument_list|,
operator|&
name|dev_priv
operator|->
name|agp_textures
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to map AGP texture region: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|drm_core_ioremap
argument_list|(
name|dev_priv
operator|->
name|warp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|drm_core_ioremap
argument_list|(
name|dev_priv
operator|->
name|primary
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|drm_core_ioremap
argument_list|(
name|dev
operator|->
name|agp_buffer_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|warp
operator|->
name|handle
operator|||
operator|!
name|dev_priv
operator|->
name|primary
operator|->
name|handle
operator|||
operator|!
name|dev
operator|->
name|agp_buffer_map
operator|->
name|handle
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to ioremap agp regions! (%p, %p, %p)\n"
argument_list|,
name|dev_priv
operator|->
name|warp
operator|->
name|handle
argument_list|,
name|dev_priv
operator|->
name|primary
operator|->
name|handle
argument_list|,
name|dev
operator|->
name|agp_buffer_map
operator|->
name|handle
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev_priv
operator|->
name|dma_access
operator|=
name|MGA_PAGPXFER
expr_stmt|;
name|dev_priv
operator|->
name|wagp_enable
operator|=
name|MGA_WAGP_ENABLE
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"Initialized card for AGP DMA.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Bootstrap the driver for PCI DMA.  *  * \todo  * The algorithm for decreasing the size of the primary DMA buffer could be  * better.  The size should be rounded up to the nearest page size, then  * decrease the request size by a single page each pass through the loop.  *  * \todo  * Determine whether the maximum address passed to drm_pci_alloc is correct.  * The same goes for drm_addbufs_pci.  *  * \sa mga_do_dma_bootstrap, mga_do_agp_dma_bootstrap  */
end_comment

begin_function
specifier|static
name|int
name|mga_do_pci_dma_bootstrap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_mga_dma_bootstrap_t
modifier|*
name|dma_bs
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
specifier|const
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|unsigned
name|int
name|warp_size
init|=
name|mga_warp_microcode_size
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|primary_size
decl_stmt|;
name|unsigned
name|int
name|bin_count
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|drm_buf_desc
name|req
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|dma
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"dev->dma is NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
comment|/* Make drm_addbufs happy by not trying to create a mapping for less 	 * than a page. 	 */
if|if
condition|(
name|warp_size
operator|<
name|PAGE_SIZE
condition|)
name|warp_size
operator|=
name|PAGE_SIZE
expr_stmt|;
comment|/* The proper alignment is 0x100 for this mapping */
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|warp_size
argument_list|,
name|_DRM_CONSISTENT
argument_list|,
name|_DRM_READ_ONLY
argument_list|,
operator|&
name|dev_priv
operator|->
name|warp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to create mapping for WARP microcode: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Other than the bottom two bits being used to encode other 	 * information, there don't appear to be any restrictions on the 	 * alignment of the primary or secondary DMA buffers. 	 */
for|for
control|(
name|primary_size
operator|=
name|dma_bs
operator|->
name|primary_size
init|;
name|primary_size
operator|!=
literal|0
condition|;
name|primary_size
operator|>>=
literal|1
control|)
block|{
comment|/* The proper alignment for this mapping is 0x04 */
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|primary_size
argument_list|,
name|_DRM_CONSISTENT
argument_list|,
name|_DRM_READ_ONLY
argument_list|,
operator|&
name|dev_priv
operator|->
name|primary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
break|break;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to allocate primary DMA region: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|primary
operator|->
name|size
operator|!=
name|dma_bs
operator|->
name|primary_size
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"Primary DMA buffer size reduced from %u to %u.\n"
argument_list|,
name|dma_bs
operator|->
name|primary_size
argument_list|,
operator|(
name|unsigned
operator|)
name|dev_priv
operator|->
name|primary
operator|->
name|size
argument_list|)
expr_stmt|;
name|dma_bs
operator|->
name|primary_size
operator|=
name|dev_priv
operator|->
name|primary
operator|->
name|size
expr_stmt|;
block|}
for|for
control|(
name|bin_count
operator|=
name|dma_bs
operator|->
name|secondary_bin_count
init|;
name|bin_count
operator|>
literal|0
condition|;
name|bin_count
operator|--
control|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|count
operator|=
name|bin_count
expr_stmt|;
name|req
operator|.
name|size
operator|=
name|dma_bs
operator|->
name|secondary_bin_size
expr_stmt|;
name|err
operator|=
name|drm_addbufs_pci
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|bin_count
operator|==
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to add secondary DMA buffers: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|bin_count
operator|!=
name|dma_bs
operator|->
name|secondary_bin_count
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"Secondary PCI DMA buffer bin count reduced from %u "
literal|"to %u.\n"
argument_list|,
name|dma_bs
operator|->
name|secondary_bin_count
argument_list|,
name|bin_count
argument_list|)
expr_stmt|;
name|dma_bs
operator|->
name|secondary_bin_count
operator|=
name|bin_count
expr_stmt|;
block|}
name|dev_priv
operator|->
name|dma_access
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|wagp_enable
operator|=
literal|0
expr_stmt|;
name|dma_bs
operator|->
name|agp_mode
operator|=
literal|0
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"Initialized card for PCI DMA.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mga_do_dma_bootstrap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_mga_dma_bootstrap_t
modifier|*
name|dma_bs
parameter_list|)
block|{
specifier|const
name|int
name|is_agp
init|=
operator|(
name|dma_bs
operator|->
name|agp_mode
operator|!=
literal|0
operator|)
operator|&&
name|drm_device_is_agp
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|drm_mga_private_t
modifier|*
specifier|const
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|dev_priv
operator|->
name|used_new_dma_init
operator|=
literal|1
expr_stmt|;
comment|/* The first steps are the same for both PCI and AGP based DMA.  Map 	 * the cards MMIO registers and map a status page. 	 */
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|mmio_base
argument_list|,
name|dev_priv
operator|->
name|mmio_size
argument_list|,
name|_DRM_REGISTERS
argument_list|,
name|_DRM_READ_ONLY
argument_list|,
operator|&
name|dev_priv
operator|->
name|mmio
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to map MMIO region: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SAREA_MAX
argument_list|,
name|_DRM_SHM
argument_list|,
name|_DRM_READ_ONLY
operator||
name|_DRM_LOCKED
operator||
name|_DRM_KERNEL
argument_list|,
operator|&
name|dev_priv
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Unable to map status region: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* The DMA initialization procedure is slightly different for PCI and 	 * AGP cards.  AGP cards just allocate a large block of AGP memory and 	 * carve off portions of it for internal uses.  The remaining memory 	 * is returned to user-mode to be used for AGP textures. 	 */
if|if
condition|(
name|is_agp
condition|)
block|{
name|err
operator|=
name|mga_do_agp_dma_bootstrap
argument_list|(
name|dev
argument_list|,
name|dma_bs
argument_list|)
expr_stmt|;
block|}
comment|/* If we attempted to initialize the card for AGP DMA but failed, 	 * clean-up any mess that may have been created. 	 */
if|if
condition|(
name|err
condition|)
block|{
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|,
name|MINIMAL_CLEANUP
argument_list|)
expr_stmt|;
block|}
comment|/* Not only do we want to try and initialized PCI cards for PCI DMA, 	 * but we also try to initialized AGP cards that could not be 	 * initialized for AGP DMA.  This covers the case where we have an AGP 	 * card in a system with an unsupported AGP chipset.  In that case the 	 * card will be detected as AGP, but we won't be able to allocate any 	 * AGP memory, etc. 	 */
if|if
condition|(
operator|!
name|is_agp
operator|||
name|err
condition|)
block|{
name|err
operator|=
name|mga_do_pci_dma_bootstrap
argument_list|(
name|dev
argument_list|,
name|dma_bs
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mga_dma_bootstrap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mga_dma_bootstrap_t
modifier|*
name|bootstrap
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|static
specifier|const
name|int
name|modes
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
specifier|const
name|drm_mga_private_t
modifier|*
specifier|const
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|err
operator|=
name|mga_do_dma_bootstrap
argument_list|(
name|dev
argument_list|,
name|bootstrap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|,
name|FULL_CLEANUP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|agp_textures
operator|!=
name|NULL
condition|)
block|{
name|bootstrap
operator|->
name|texture_handle
operator|=
name|dev_priv
operator|->
name|agp_textures
operator|->
name|offset
expr_stmt|;
name|bootstrap
operator|->
name|texture_size
operator|=
name|dev_priv
operator|->
name|agp_textures
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|bootstrap
operator|->
name|texture_handle
operator|=
literal|0
expr_stmt|;
name|bootstrap
operator|->
name|texture_size
operator|=
literal|0
expr_stmt|;
block|}
name|bootstrap
operator|->
name|agp_mode
operator|=
name|modes
index|[
name|bootstrap
operator|->
name|agp_mode
operator|&
literal|0x07
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mga_do_init_dma
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_mga_init_t
modifier|*
name|init
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|dev
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|init
operator|->
name|sgram
condition|)
block|{
name|dev_priv
operator|->
name|clear_cmd
operator|=
name|MGA_DWGCTL_CLEAR
operator||
name|MGA_ATYPE_BLK
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|clear_cmd
operator|=
name|MGA_DWGCTL_CLEAR
operator||
name|MGA_ATYPE_RSTR
expr_stmt|;
block|}
name|dev_priv
operator|->
name|maccess
operator|=
name|init
operator|->
name|maccess
expr_stmt|;
name|dev_priv
operator|->
name|fb_cpp
operator|=
name|init
operator|->
name|fb_cpp
expr_stmt|;
name|dev_priv
operator|->
name|front_offset
operator|=
name|init
operator|->
name|front_offset
expr_stmt|;
name|dev_priv
operator|->
name|front_pitch
operator|=
name|init
operator|->
name|front_pitch
expr_stmt|;
name|dev_priv
operator|->
name|back_offset
operator|=
name|init
operator|->
name|back_offset
expr_stmt|;
name|dev_priv
operator|->
name|back_pitch
operator|=
name|init
operator|->
name|back_pitch
expr_stmt|;
name|dev_priv
operator|->
name|depth_cpp
operator|=
name|init
operator|->
name|depth_cpp
expr_stmt|;
name|dev_priv
operator|->
name|depth_offset
operator|=
name|init
operator|->
name|depth_offset
expr_stmt|;
name|dev_priv
operator|->
name|depth_pitch
operator|=
name|init
operator|->
name|depth_pitch
expr_stmt|;
comment|/* FIXME: Need to support AGP textures... 	 */
name|dev_priv
operator|->
name|texture_offset
operator|=
name|init
operator|->
name|texture_offset
index|[
literal|0
index|]
expr_stmt|;
name|dev_priv
operator|->
name|texture_size
operator|=
name|init
operator|->
name|texture_size
index|[
literal|0
index|]
expr_stmt|;
name|dev_priv
operator|->
name|sarea
operator|=
name|drm_getsarea
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find sarea!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|used_new_dma_init
condition|)
block|{
name|dev_priv
operator|->
name|dma_access
operator|=
name|MGA_PAGPXFER
expr_stmt|;
name|dev_priv
operator|->
name|wagp_enable
operator|=
name|MGA_WAGP_ENABLE
expr_stmt|;
name|dev_priv
operator|->
name|status
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|status_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|status
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find status page!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|mmio
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|mmio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mmio
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find mmio region!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|warp
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|warp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|warp
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find warp microcode region!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|primary
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|primary_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|primary
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find primary dma region!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev
operator|->
name|agp_buffer_token
operator|=
name|init
operator|->
name|buffers_offset
expr_stmt|;
name|dev
operator|->
name|agp_buffer_map
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|buffers_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|agp_buffer_map
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find dma buffer region!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|drm_core_ioremap
argument_list|(
name|dev_priv
operator|->
name|warp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|drm_core_ioremap
argument_list|(
name|dev_priv
operator|->
name|primary
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|drm_core_ioremap
argument_list|(
name|dev
operator|->
name|agp_buffer_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|sarea_priv
operator|=
operator|(
name|drm_mga_sarea_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|sarea
operator|->
name|handle
operator|+
name|init
operator|->
name|sarea_priv_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|warp
operator|->
name|handle
operator|||
operator|!
name|dev_priv
operator|->
name|primary
operator|->
name|handle
operator|||
operator|(
operator|(
name|dev_priv
operator|->
name|dma_access
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|dev
operator|->
name|agp_buffer_map
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dev
operator|->
name|agp_buffer_map
operator|->
name|handle
operator|==
name|NULL
operator|)
operator|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to ioremap agp regions!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|mga_warp_install_microcode
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to install WARP ucode: %d!\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|mga_warp_init
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to init WARP engine: %d!\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|dev_priv
operator|->
name|prim
operator|.
name|status
operator|=
operator|(
name|u32
operator|*
operator|)
name|dev_priv
operator|->
name|status
operator|->
name|handle
expr_stmt|;
name|mga_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* Init the primary DMA registers. 	 */
name|MGA_WRITE
argument_list|(
name|MGA_PRIMADDRESS
argument_list|,
name|dev_priv
operator|->
name|primary
operator|->
name|offset
operator||
name|MGA_DMA_GENERAL
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|start
operator|=
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|primary
operator|->
name|handle
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|end
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|primary
operator|->
name|handle
operator|+
name|dev_priv
operator|->
name|primary
operator|->
name|size
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|size
operator|=
name|dev_priv
operator|->
name|primary
operator|->
name|size
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|space
operator|=
name|dev_priv
operator|->
name|prim
operator|.
name|size
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|wrapped
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|last_flush
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|last_wrap
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|high_mark
operator|=
literal|256
operator|*
name|DMA_BLOCK_SIZE
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|status
index|[
literal|0
index|]
operator|=
name|dev_priv
operator|->
name|primary
operator|->
name|offset
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_wrap
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
operator|.
name|wrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mga_freelist_init
argument_list|(
name|dev
argument_list|,
name|dev_priv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not initialize freelist\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mga_do_cleanup_dma
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|full_cleanup
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Make sure interrupts are disabled here because the uninstall ioctl 	 * may not have been called from userspace and after dev_private 	 * is freed, it's too late. 	 */
if|if
condition|(
name|dev
operator|->
name|irq_enabled
condition|)
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev_private
condition|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|warp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dev_priv
operator|->
name|warp
operator|->
name|type
operator|!=
name|_DRM_CONSISTENT
operator|)
condition|)
name|drm_core_ioremapfree
argument_list|(
name|dev_priv
operator|->
name|warp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|primary
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dev_priv
operator|->
name|primary
operator|->
name|type
operator|!=
name|_DRM_CONSISTENT
operator|)
condition|)
name|drm_core_ioremapfree
argument_list|(
name|dev_priv
operator|->
name|primary
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|agp_buffer_map
operator|!=
name|NULL
condition|)
name|drm_core_ioremapfree
argument_list|(
name|dev
operator|->
name|agp_buffer_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|used_new_dma_init
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|agp_handle
operator|!=
literal|0
condition|)
block|{
name|struct
name|drm_agp_binding
name|unbind_req
decl_stmt|;
name|struct
name|drm_agp_buffer
name|free_req
decl_stmt|;
name|unbind_req
operator|.
name|handle
operator|=
name|dev_priv
operator|->
name|agp_handle
expr_stmt|;
name|drm_agp_unbind
argument_list|(
name|dev
argument_list|,
operator|&
name|unbind_req
argument_list|)
expr_stmt|;
name|free_req
operator|.
name|handle
operator|=
name|dev_priv
operator|->
name|agp_handle
expr_stmt|;
name|drm_agp_free
argument_list|(
name|dev
argument_list|,
operator|&
name|free_req
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|agp_textures
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|agp_size
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|agp_handle
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|agp
operator|!=
name|NULL
operator|)
operator|&&
name|dev
operator|->
name|agp
operator|->
name|acquired
condition|)
block|{
name|err
operator|=
name|drm_agp_release
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
name|dev_priv
operator|->
name|warp
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|primary
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|sarea
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|agp_buffer_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|full_cleanup
condition|)
block|{
name|dev_priv
operator|->
name|mmio
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|status
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|used_new_dma_init
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|dev_priv
operator|->
name|prim
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_priv
operator|->
name|prim
argument_list|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|warp_pipe
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|dev_priv
operator|->
name|warp_pipe_phys
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_priv
operator|->
name|warp_pipe_phys
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|mga_freelist_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mga_dma_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mga_init_t
modifier|*
name|init
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|init
operator|->
name|func
condition|)
block|{
case|case
name|MGA_INIT_DMA
case|:
name|err
operator|=
name|mga_do_init_dma
argument_list|(
name|dev
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|(
name|void
operator|)
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|,
name|FULL_CLEANUP
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
case|case
name|MGA_CLEANUP_DMA
case|:
return|return
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|,
name|FULL_CLEANUP
argument_list|)
return|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * Primary DMA stream management  */
end_comment

begin_function
name|int
name|mga_dma_flush
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_lock
modifier|*
name|lock
init|=
name|data
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s%s%s\n"
argument_list|,
operator|(
name|lock
operator|->
name|flags
operator|&
name|_DRM_LOCK_FLUSH
operator|)
condition|?
literal|"flush, "
else|:
literal|""
argument_list|,
operator|(
name|lock
operator|->
name|flags
operator|&
name|_DRM_LOCK_FLUSH_ALL
operator|)
condition|?
literal|"flush all, "
else|:
literal|""
argument_list|,
operator|(
name|lock
operator|->
name|flags
operator|&
name|_DRM_LOCK_QUIESCENT
operator|)
condition|?
literal|"idle, "
else|:
literal|""
argument_list|)
expr_stmt|;
name|WRAP_WAIT_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|flags
operator|&
operator|(
name|_DRM_LOCK_FLUSH
operator||
name|_DRM_LOCK_FLUSH_ALL
operator|)
condition|)
block|{
name|mga_do_dma_flush
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|->
name|flags
operator|&
name|_DRM_LOCK_QUIESCENT
condition|)
block|{
if|#
directive|if
name|MGA_DMA_DEBUG
name|int
name|ret
init|=
name|mga_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|DRM_INFO
argument_list|(
literal|"-EBUSY\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
else|#
directive|else
return|return
name|mga_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|mga_dma_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
return|return
name|mga_do_dma_reset
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * DMA buffer management  */
end_comment

begin_function
specifier|static
name|int
name|mga_dma_get_buffers
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|struct
name|drm_dma
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|->
name|granted_count
init|;
name|i
operator|<
name|d
operator|->
name|request_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|mga_freelist_get
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|-
name|EAGAIN
return|;
name|buf
operator|->
name|file_priv
operator|=
name|file_priv
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|d
operator|->
name|request_indices
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|idx
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|d
operator|->
name|request_sizes
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|total
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|d
operator|->
name|granted_count
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mga_dma_buffers
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_dma
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
comment|/* Please don't send us buffers. 	 */
if|if
condition|(
name|d
operator|->
name|send_count
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to send %d buffers via drmDMA\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|d
operator|->
name|send_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* We'll send you buffers. 	 */
if|if
condition|(
name|d
operator|->
name|request_count
operator|<
literal|0
operator|||
name|d
operator|->
name|request_count
operator|>
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to get %d buffers (of %d max)\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|d
operator|->
name|request_count
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|WRAP_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|d
operator|->
name|granted_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|request_count
condition|)
block|{
name|ret
operator|=
name|mga_dma_get_buffers
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Called just before the module is unloaded.  */
end_comment

begin_function
name|int
name|mga_driver_unload
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_free
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Called when the last opener of the device is closed.  */
end_comment

begin_function
name|void
name|mga_driver_lastclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|,
name|FULL_CLEANUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mga_driver_dma_quiescent
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
return|return
name|mga_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

end_unit

