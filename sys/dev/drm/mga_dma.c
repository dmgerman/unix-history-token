begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mga_dma.c -- DMA support for mga g200/g400 -*- linux-c -*-  * Created: Mon Dec 13 01:50:01 1999 by jhartmann@precisioninsight.com  *  * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.  * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Rickard E. (Rik) Faith<faith@valinux.com>  *    Jeff Hartmann<jhartmann@valinux.com>  *    Keith Whitwell<keith@tungstengraphics.com>  *  * Rewritten by:  *    Gareth Hughes<gareth@valinux.com>  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"dev/drm/mga.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/mga_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/mga_drv.h"
end_include

begin_define
define|#
directive|define
name|MGA_DEFAULT_USEC_TIMEOUT
value|10000
end_define

begin_define
define|#
directive|define
name|MGA_FREELIST_DEBUG
value|0
end_define

begin_comment
comment|/* ================================================================  * Engine control  */
end_comment

begin_function
name|int
name|mga_do_wait_for_idle
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|MGA_READ
argument_list|(
name|MGA_STATUS
argument_list|)
operator|&
name|MGA_ENGINE_IDLE_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MGA_ENDPRDMASTS
condition|)
block|{
name|MGA_WRITE8
argument_list|(
name|MGA_CRTC_INDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MGA_DMA_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"   status=0x%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DRM_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mga_do_dma_idle
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|MGA_READ
argument_list|(
name|MGA_STATUS
argument_list|)
operator|&
name|MGA_DMA_IDLE_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MGA_ENDPRDMASTS
condition|)
return|return
literal|0
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MGA_DMA_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed! status=0x%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DRM_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mga_do_dma_reset
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mga_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_mga_primary_buffer_t
modifier|*
name|primary
init|=
operator|&
name|dev_priv
operator|->
name|prim
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* The primary DMA stream should look like new right about now. 	 */
name|primary
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|primary
operator|->
name|space
operator|=
name|primary
operator|->
name|size
expr_stmt|;
name|primary
operator|->
name|last_flush
operator|=
literal|0
expr_stmt|;
name|sarea_priv
operator|->
name|last_wrap
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: Reset counters, buffer ages etc... 	 */
comment|/* FIXME: What else do we need to reinitialize?  WARP stuff? 	 */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mga_do_engine_reset
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Okay, so we've completely screwed up and locked the engine. 	 * How about we clean up after ourselves? 	 */
name|MGA_WRITE
argument_list|(
name|MGA_RST
argument_list|,
name|MGA_SOFTRESET
argument_list|)
expr_stmt|;
name|DRM_UDELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* Wait at least 10 usecs */
name|MGA_WRITE
argument_list|(
name|MGA_RST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the registers that get clobbered by the soft 	 * reset.  Many of the core register values survive a reset, 	 * but the drawing registers are basically all gone. 	 * 	 * 3D clients should probably die after calling this.  The X 	 * server should reset the engine state to known values. 	 */
if|#
directive|if
literal|0
block|MGA_WRITE( MGA_PRIMPTR, 		   virt_to_bus((void *)dev_priv->prim.status_page) | 		   MGA_PRIMPTREN0 | 		   MGA_PRIMPTREN1 );
endif|#
directive|endif
name|MGA_WRITE
argument_list|(
name|MGA_ICLEAR
argument_list|,
name|MGA_SOFTRAPICLR
argument_list|)
expr_stmt|;
name|MGA_WRITE
argument_list|(
name|MGA_IEN
argument_list|,
name|MGA_SOFTRAPIEN
argument_list|)
expr_stmt|;
comment|/* The primary DMA stream should look like new right about now. 	 */
name|mga_do_dma_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* This bad boy will never fail. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * Primary DMA stream  */
end_comment

begin_function
name|void
name|mga_do_dma_flush
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mga_primary_buffer_t
modifier|*
name|primary
init|=
operator|&
name|dev_priv
operator|->
name|prim
decl_stmt|;
name|u32
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|u32
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DMA_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* We need to wait so that we can do an safe flush */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|MGA_READ
argument_list|(
name|MGA_STATUS
argument_list|)
operator|&
name|MGA_ENGINE_IDLE_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MGA_ENDPRDMASTS
condition|)
break|break;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|primary
operator|->
name|tail
operator|==
name|primary
operator|->
name|last_flush
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"   bailing out...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tail
operator|=
name|primary
operator|->
name|tail
operator|+
name|dev_priv
operator|->
name|primary
operator|->
name|offset
expr_stmt|;
comment|/* We need to pad the stream between flushes, as the card 	 * actually (partially?) reads the first of these commands. 	 * See page 4-16 in the G400 manual, middle of the page or so. 	 */
name|BEGIN_DMA
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DMA_BLOCK
argument_list|(
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|ADVANCE_DMA
argument_list|()
expr_stmt|;
name|primary
operator|->
name|last_flush
operator|=
name|primary
operator|->
name|tail
expr_stmt|;
name|head
operator|=
name|MGA_READ
argument_list|(
name|MGA_PRIMADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|<=
name|tail
condition|)
block|{
name|primary
operator|->
name|space
operator|=
name|primary
operator|->
name|size
operator|-
name|primary
operator|->
name|tail
expr_stmt|;
block|}
else|else
block|{
name|primary
operator|->
name|space
operator|=
name|head
operator|-
name|tail
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"   head = 0x%06lx\n"
argument_list|,
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   tail = 0x%06lx\n"
argument_list|,
name|tail
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"  space = 0x%06x\n"
argument_list|,
name|primary
operator|->
name|space
argument_list|)
expr_stmt|;
name|mga_flush_write_combine
argument_list|()
expr_stmt|;
name|MGA_WRITE
argument_list|(
name|MGA_PRIMEND
argument_list|,
name|tail
operator||
name|MGA_PAGPXFER
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mga_do_dma_wrap_start
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mga_primary_buffer_t
modifier|*
name|primary
init|=
operator|&
name|dev_priv
operator|->
name|prim
decl_stmt|;
name|u32
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|DMA_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|BEGIN_DMA_WRAP
argument_list|()
expr_stmt|;
name|DMA_BLOCK
argument_list|(
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|,
name|MGA_DMAPAD
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|ADVANCE_DMA
argument_list|()
expr_stmt|;
name|tail
operator|=
name|primary
operator|->
name|tail
operator|+
name|dev_priv
operator|->
name|primary
operator|->
name|offset
expr_stmt|;
name|primary
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|primary
operator|->
name|last_flush
operator|=
literal|0
expr_stmt|;
name|primary
operator|->
name|last_wrap
operator|++
expr_stmt|;
name|head
operator|=
name|MGA_READ
argument_list|(
name|MGA_PRIMADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|dev_priv
operator|->
name|primary
operator|->
name|offset
condition|)
block|{
name|primary
operator|->
name|space
operator|=
name|primary
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|primary
operator|->
name|space
operator|=
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"   head = 0x%06lx\n"
argument_list|,
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   tail = 0x%06x\n"
argument_list|,
name|primary
operator|->
name|tail
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   wrap = %d\n"
argument_list|,
name|primary
operator|->
name|last_wrap
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"  space = 0x%06x\n"
argument_list|,
name|primary
operator|->
name|space
argument_list|)
expr_stmt|;
name|mga_flush_write_combine
argument_list|()
expr_stmt|;
name|MGA_WRITE
argument_list|(
name|MGA_PRIMEND
argument_list|,
name|tail
operator||
name|MGA_PAGPXFER
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
literal|0
argument_list|,
operator|&
name|primary
operator|->
name|wrapped
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mga_do_dma_wrap_end
parameter_list|(
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mga_primary_buffer_t
modifier|*
name|primary
init|=
operator|&
name|dev_priv
operator|->
name|prim
decl_stmt|;
name|drm_mga_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|u32
name|head
init|=
name|dev_priv
operator|->
name|primary
operator|->
name|offset
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|last_wrap
operator|++
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   wrap = %d\n"
argument_list|,
name|sarea_priv
operator|->
name|last_wrap
argument_list|)
expr_stmt|;
name|mga_flush_write_combine
argument_list|()
expr_stmt|;
name|MGA_WRITE
argument_list|(
name|MGA_PRIMADDRESS
argument_list|,
name|head
operator||
name|MGA_DMA_GENERAL
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
literal|0
argument_list|,
operator|&
name|primary
operator|->
name|wrapped
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ================================================================  * Freelist management  */
end_comment

begin_define
define|#
directive|define
name|MGA_BUFFER_USED
value|~0
end_define

begin_define
define|#
directive|define
name|MGA_BUFFER_FREE
value|0
end_define

begin_if
if|#
directive|if
name|MGA_FREELIST_DEBUG
end_if

begin_function
specifier|static
name|void
name|mga_freelist_print
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|entry
decl_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"current dispatch: last=0x%x done=0x%x\n"
argument_list|,
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|MGA_READ
argument_list|(
name|MGA_PRIMADDRESS
argument_list|)
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"current freelist:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|dev_priv
operator|->
name|head
operator|->
name|next
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|DRM_INFO
argument_list|(
literal|"   %p   idx=%2d  age=0x%x 0x%06lx\n"
argument_list|,
name|entry
argument_list|,
name|entry
operator|->
name|buf
operator|->
name|idx
argument_list|,
name|entry
operator|->
name|age
operator|.
name|head
argument_list|,
name|entry
operator|->
name|age
operator|.
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mga_freelist_init
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_mga_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|drm_mga_buf_priv_t
modifier|*
name|buf_priv
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count=%d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|head
operator|==
name|NULL
condition|)
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
name|memset
argument_list|(
name|dev_priv
operator|->
name|head
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|)
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|head
operator|->
name|age
argument_list|,
name|MGA_BUFFER_USED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
name|buf_priv
operator|=
name|buf
operator|->
name|dev_private
expr_stmt|;
name|entry
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
name|memset
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|dev_priv
operator|->
name|head
operator|->
name|next
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|dev_priv
operator|->
name|head
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|entry
operator|->
name|age
argument_list|,
name|MGA_BUFFER_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|head
operator|->
name|next
operator|!=
name|NULL
condition|)
name|dev_priv
operator|->
name|head
operator|->
name|next
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|==
name|NULL
condition|)
name|dev_priv
operator|->
name|tail
operator|=
name|entry
expr_stmt|;
name|buf_priv
operator|->
name|list_entry
operator|=
name|entry
expr_stmt|;
name|buf_priv
operator|->
name|discard
operator|=
literal|0
expr_stmt|;
name|buf_priv
operator|->
name|dispatched
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|->
name|next
operator|=
name|entry
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mga_freelist_cleanup
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|entry
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|next
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|entry
operator|=
name|dev_priv
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_freelist_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
name|dev_priv
operator|->
name|head
operator|=
name|dev_priv
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME: Still needed?  */
end_comment

begin_endif
unit|static void mga_freelist_reset( drm_device_t *dev ) { 	drm_device_dma_t *dma = dev->dma; 	drm_buf_t *buf; 	drm_mga_buf_priv_t *buf_priv; 	int i;  	for ( i = 0 ; i< dma->buf_count ; i++ ) { 		buf = dma->buflist[i]; 	        buf_priv = buf->dev_private; 		SET_AGE(&buf_priv->list_entry->age, 			 MGA_BUFFER_FREE, 0 ); 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|drm_buf_t
modifier|*
name|mga_freelist_get
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|next
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|prev
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|tail
init|=
name|dev_priv
operator|->
name|tail
decl_stmt|;
name|u32
name|head
decl_stmt|,
name|wrap
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|head
operator|=
name|MGA_READ
argument_list|(
name|MGA_PRIMADDRESS
argument_list|)
expr_stmt|;
name|wrap
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_wrap
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   tail=0x%06lx %d\n"
argument_list|,
name|tail
operator|->
name|age
operator|.
name|head
condition|?
name|tail
operator|->
name|age
operator|.
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
else|:
literal|0
argument_list|,
name|tail
operator|->
name|age
operator|.
name|wrap
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   head=0x%06lx %d\n"
argument_list|,
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_AGE
argument_list|(
operator|&
name|tail
operator|->
name|age
argument_list|,
name|head
argument_list|,
name|wrap
argument_list|)
condition|)
block|{
name|prev
operator|=
name|dev_priv
operator|->
name|tail
operator|->
name|prev
expr_stmt|;
name|next
operator|=
name|dev_priv
operator|->
name|tail
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|tail
operator|=
name|prev
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|next
operator|->
name|age
argument_list|,
name|MGA_BUFFER_USED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|next
operator|->
name|buf
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"returning NULL!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|mga_freelist_put
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_buf_priv_t
modifier|*
name|buf_priv
init|=
name|buf
operator|->
name|dev_private
decl_stmt|;
name|drm_mga_freelist_t
modifier|*
name|head
decl_stmt|,
modifier|*
name|entry
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"age=0x%06lx wrap=%d\n"
argument_list|,
name|buf_priv
operator|->
name|list_entry
operator|->
name|age
operator|.
name|head
operator|-
name|dev_priv
operator|->
name|primary
operator|->
name|offset
argument_list|,
name|buf_priv
operator|->
name|list_entry
operator|->
name|age
operator|.
name|wrap
argument_list|)
expr_stmt|;
name|entry
operator|=
name|buf_priv
operator|->
name|list_entry
expr_stmt|;
name|head
operator|=
name|dev_priv
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|buf_priv
operator|->
name|list_entry
operator|->
name|age
operator|.
name|head
operator|==
name|MGA_BUFFER_USED
condition|)
block|{
name|SET_AGE
argument_list|(
operator|&
name|entry
operator|->
name|age
argument_list|,
name|MGA_BUFFER_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|dev_priv
operator|->
name|tail
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|prev
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|head
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|prev
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * DMA initialization, cleanup  */
end_comment

begin_function
specifier|static
name|int
name|mga_do_init_dma
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_mga_init_t
modifier|*
name|init
parameter_list|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_mga_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
name|memset
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_private_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|chipset
operator|=
name|init
operator|->
name|chipset
expr_stmt|;
name|dev_priv
operator|->
name|usec_timeout
operator|=
name|MGA_DEFAULT_USEC_TIMEOUT
expr_stmt|;
if|if
condition|(
name|init
operator|->
name|sgram
condition|)
block|{
name|dev_priv
operator|->
name|clear_cmd
operator|=
name|MGA_DWGCTL_CLEAR
operator||
name|MGA_ATYPE_BLK
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|clear_cmd
operator|=
name|MGA_DWGCTL_CLEAR
operator||
name|MGA_ATYPE_RSTR
expr_stmt|;
block|}
name|dev_priv
operator|->
name|maccess
operator|=
name|init
operator|->
name|maccess
expr_stmt|;
name|dev_priv
operator|->
name|fb_cpp
operator|=
name|init
operator|->
name|fb_cpp
expr_stmt|;
name|dev_priv
operator|->
name|front_offset
operator|=
name|init
operator|->
name|front_offset
expr_stmt|;
name|dev_priv
operator|->
name|front_pitch
operator|=
name|init
operator|->
name|front_pitch
expr_stmt|;
name|dev_priv
operator|->
name|back_offset
operator|=
name|init
operator|->
name|back_offset
expr_stmt|;
name|dev_priv
operator|->
name|back_pitch
operator|=
name|init
operator|->
name|back_pitch
expr_stmt|;
name|dev_priv
operator|->
name|depth_cpp
operator|=
name|init
operator|->
name|depth_cpp
expr_stmt|;
name|dev_priv
operator|->
name|depth_offset
operator|=
name|init
operator|->
name|depth_offset
expr_stmt|;
name|dev_priv
operator|->
name|depth_pitch
operator|=
name|init
operator|->
name|depth_pitch
expr_stmt|;
comment|/* FIXME: Need to support AGP textures... 	 */
name|dev_priv
operator|->
name|texture_offset
operator|=
name|init
operator|->
name|texture_offset
index|[
literal|0
index|]
expr_stmt|;
name|dev_priv
operator|->
name|texture_size
operator|=
name|init
operator|->
name|texture_size
index|[
literal|0
index|]
expr_stmt|;
name|DRM_GETSAREA
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find sarea!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|fb
argument_list|,
name|init
operator|->
name|fb_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|fb
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find framebuffer!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|mmio
argument_list|,
name|init
operator|->
name|mmio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mmio
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find mmio region!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|status
argument_list|,
name|init
operator|->
name|status_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|status
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find status page!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|warp
argument_list|,
name|init
operator|->
name|warp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|warp
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find warp microcode region!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|primary
argument_list|,
name|init
operator|->
name|primary_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|primary
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find primary dma region!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|buffers
argument_list|,
name|init
operator|->
name|buffers_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|buffers
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to find dma buffer region!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|dev_priv
operator|->
name|sarea_priv
operator|=
operator|(
name|drm_mga_sarea_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|sarea
operator|->
name|handle
operator|+
name|init
operator|->
name|sarea_priv_offset
operator|)
expr_stmt|;
name|DRM_IOREMAP
argument_list|(
name|dev_priv
operator|->
name|warp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|DRM_IOREMAP
argument_list|(
name|dev_priv
operator|->
name|primary
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|DRM_IOREMAP
argument_list|(
name|dev_priv
operator|->
name|buffers
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|warp
operator|->
name|handle
operator|||
operator|!
name|dev_priv
operator|->
name|primary
operator|->
name|handle
operator|||
operator|!
name|dev_priv
operator|->
name|buffers
operator|->
name|handle
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to ioremap agp regions!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|ret
operator|=
name|mga_warp_install_microcode
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to install WARP ucode!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|mga_warp_init
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to init WARP engine!\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|dev_priv
operator|->
name|prim
operator|.
name|status
operator|=
operator|(
name|u32
operator|*
operator|)
name|dev_priv
operator|->
name|status
operator|->
name|handle
expr_stmt|;
name|mga_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* Init the primary DMA registers. 	 */
name|MGA_WRITE
argument_list|(
name|MGA_PRIMADDRESS
argument_list|,
name|dev_priv
operator|->
name|primary
operator|->
name|offset
operator||
name|MGA_DMA_GENERAL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|MGA_WRITE( MGA_PRIMPTR, 		   virt_to_bus((void *)dev_priv->prim.status) | 		   MGA_PRIMPTREN0 |
comment|/* Soft trap, SECEND, SETUPEND */
block|MGA_PRIMPTREN1 );
comment|/* DWGSYNC */
endif|#
directive|endif
name|dev_priv
operator|->
name|prim
operator|.
name|start
operator|=
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|primary
operator|->
name|handle
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|end
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|primary
operator|->
name|handle
operator|+
name|dev_priv
operator|->
name|primary
operator|->
name|size
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|size
operator|=
name|dev_priv
operator|->
name|primary
operator|->
name|size
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|space
operator|=
name|dev_priv
operator|->
name|prim
operator|.
name|size
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|wrapped
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|last_flush
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|last_wrap
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|high_mark
operator|=
literal|256
operator|*
name|DMA_BLOCK_SIZE
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|status
index|[
literal|0
index|]
operator|=
name|dev_priv
operator|->
name|primary
operator|->
name|offset
expr_stmt|;
name|dev_priv
operator|->
name|prim
operator|.
name|status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_wrap
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
operator|.
name|wrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mga_freelist_init
argument_list|(
name|dev
argument_list|,
name|dev_priv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not initialize freelist\n"
argument_list|)
expr_stmt|;
comment|/* Assign dev_private so we can do cleanup. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
comment|/* Make dev_private visable to others. */
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mga_do_cleanup_dma
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|_HAVE_DMA_IRQ
comment|/* Make sure interrupts are disabled here because the uninstall ioctl 	 * may not have been called from userspace and after dev_private 	 * is freed, it's too late. 	 */
if|if
condition|(
name|dev
operator|->
name|irq
condition|)
name|DRM
function_decl|(
name|irq_uninstall
function_decl|)
parameter_list|(
name|dev
parameter_list|)
function_decl|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|->
name|dev_private
condition|)
block|{
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|warp
operator|!=
name|NULL
condition|)
name|DRM_IOREMAPFREE
argument_list|(
name|dev_priv
operator|->
name|warp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|primary
operator|!=
name|NULL
condition|)
name|DRM_IOREMAPFREE
argument_list|(
name|dev_priv
operator|->
name|primary
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|buffers
operator|!=
name|NULL
condition|)
name|DRM_IOREMAPFREE
argument_list|(
name|dev_priv
operator|->
name|buffers
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|mga_freelist_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mga_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mga_dma_init
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_mga_init_t
name|init
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|init
argument_list|,
operator|(
name|drm_mga_init_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|init
operator|.
name|func
condition|)
block|{
case|case
name|MGA_INIT_DMA
case|:
return|return
name|mga_do_init_dma
argument_list|(
name|dev
argument_list|,
operator|&
name|init
argument_list|)
return|;
case|case
name|MGA_CLEANUP_DMA
case|:
return|return
name|mga_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
return|;
block|}
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * Primary DMA stream management  */
end_comment

begin_function
name|int
name|mga_dma_flush
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_lock_t
name|lock
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|lock
argument_list|,
operator|(
name|drm_lock_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s%s%s\n"
argument_list|,
operator|(
name|lock
operator|.
name|flags
operator|&
name|_DRM_LOCK_FLUSH
operator|)
condition|?
literal|"flush, "
else|:
literal|""
argument_list|,
operator|(
name|lock
operator|.
name|flags
operator|&
name|_DRM_LOCK_FLUSH_ALL
operator|)
condition|?
literal|"flush all, "
else|:
literal|""
argument_list|,
operator|(
name|lock
operator|.
name|flags
operator|&
name|_DRM_LOCK_QUIESCENT
operator|)
condition|?
literal|"idle, "
else|:
literal|""
argument_list|)
expr_stmt|;
name|WRAP_WAIT_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|.
name|flags
operator|&
operator|(
name|_DRM_LOCK_FLUSH
operator||
name|_DRM_LOCK_FLUSH_ALL
operator|)
condition|)
block|{
name|mga_do_dma_flush
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|.
name|flags
operator|&
name|_DRM_LOCK_QUIESCENT
condition|)
block|{
if|#
directive|if
name|MGA_DMA_DEBUG
name|int
name|ret
init|=
name|mga_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|DRM_INFO
argument_list|(
literal|"%s: -EBUSY\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
else|#
directive|else
return|return
name|mga_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|mga_dma_reset
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
return|return
name|mga_do_dma_reset
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * DMA buffer management  */
end_comment

begin_function
specifier|static
name|int
name|mga_dma_get_buffers
parameter_list|(
name|DRMFILE
name|filp
parameter_list|,
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_dma_t
modifier|*
name|d
parameter_list|)
block|{
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|->
name|granted_count
init|;
name|i
operator|<
name|d
operator|->
name|request_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|mga_freelist_get
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EAGAIN
argument_list|)
return|;
name|buf
operator|->
name|filp
operator|=
name|filp
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|d
operator|->
name|request_indices
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|idx
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|d
operator|->
name|request_sizes
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|total
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|d
operator|->
name|granted_count
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mga_dma_buffers
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_mga_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_mga_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_dma_t
name|d
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|d
argument_list|,
operator|(
name|drm_dma_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Please don't send us buffers. 	 */
if|if
condition|(
name|d
operator|.
name|send_count
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to send %d buffers via drmDMA\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|d
operator|.
name|send_count
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* We'll send you buffers. 	 */
if|if
condition|(
name|d
operator|.
name|request_count
operator|<
literal|0
operator|||
name|d
operator|.
name|request_count
operator|>
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to get %d buffers (of %d max)\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|d
operator|.
name|request_count
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|WRAP_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|d
operator|.
name|granted_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|request_count
condition|)
block|{
name|ret
operator|=
name|mga_dma_get_buffers
argument_list|(
name|filp
argument_list|,
name|dev
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
name|DRM_COPY_TO_USER_IOCTL
argument_list|(
operator|(
name|drm_dma_t
operator|*
operator|)
name|data
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

